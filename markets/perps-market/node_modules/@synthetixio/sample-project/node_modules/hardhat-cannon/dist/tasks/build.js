"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const builder_1 = require("@usecannon/builder");
const cli_1 = require("@usecannon/cli");
const chains_1 = require("@usecannon/cli/dist/src/chains");
const rpc_1 = require("@usecannon/cli/dist/src/rpc");
const chalk_1 = require("chalk");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const viem = __importStar(require("viem"));
const augment_provider_1 = require("../internal/augment-provider");
const get_hardhat_signers_1 = require("../internal/get-hardhat-signers");
const load_pkg_json_1 = require("../internal/load-pkg-json");
const parse_anvil_options_1 = require("../internal/parse-anvil-options");
const task_names_2 = require("../task-names");
(0, config_1.task)(task_names_2.TASK_BUILD, 'Assemble a defined chain and save it to to a state which can be used later')
    .addPositionalParam('cannonfile', 'Path to a cannonfile to build', 'cannonfile.toml')
    .addOptionalVariadicPositionalParam('settings', 'Custom settings for building the cannonfile', [])
    .addOptionalParam('preset', '(Optional) The preset label for storing the build with the given settings')
    .addOptionalParam('registryPriority', '(Optional) Which registry should be used first? Default: onchain')
    .addOptionalParam('anvilOptions', '(Optional) Custom anvil options string or json file or string to configure when running on the cannon network or a local forked node')
    .addFlag('dryRun', 'Run a shadow deployment on a local forked node instead of actually deploying')
    .addFlag('wipe', 'Do not reuse any previously built artifacts')
    .addFlag('usePlugins', 'Load plugins globally installed using the cannon CLI')
    .addOptionalParam('upgradeFrom', '(Optional) Wipe the deployment files, and use the deployment files from another cannon package as base')
    .addOptionalParam('impersonate', '(Optional) When dry running, uses forked signers rather than actual signing keys')
    .addFlag('noCompile', 'Do not execute hardhat compile before build')
    .setAction(async ({ cannonfile, settings, upgradeFrom, preset: presetArg, noCompile, wipe, usePlugins, registryPriority, dryRun, anvilOptions: anvilOptionsParam, impersonate, }, hre) => {
    if (!noCompile) {
        await hre.run(task_names_1.TASK_COMPILE);
        console.log('');
    }
    // If the first param is not a cannonfile, it should be parsed as settings
    if (typeof cannonfile === 'string' && cannonfile !== '-' && !cannonfile.endsWith('.toml')) {
        settings.unshift(cannonfile);
        cannonfile = 'cannonfile.toml';
    }
    const parsedSettings = (0, cli_1.parseSettings)(settings);
    const { name, version, def, preset } = await (0, cli_1.loadCannonfile)(node_path_1.default.join(hre.config.paths.root, cannonfile));
    if (hre.network.name === 'hardhat' && dryRun) {
        throw new Error('You cannot use --dry-run param when using the "hardhat" network');
    }
    const providerOptions = hre.network.name === 'hardhat'
        ? // hardhat network is "special" in that it looks like its a jsonrpc provider,
            // but really you can't use it like that.
            {
                mode: 'hardhat',
                chain: (0, chains_1.getChainById)(31337),
                transport: viem.custom(hre.network.provider),
            }
        : {
            mode: 'anvil',
            chain: (0, chains_1.getChainById)(hre.network.config.chainId || builder_1.CANNON_CHAIN_ID),
            transport: viem.http(hre.network.config.url),
        };
    let provider = viem
        .createTestClient(providerOptions)
        .extend(viem.walletActions)
        .extend(viem.publicActions);
    if (dryRun) {
        console.log((0, chalk_1.yellowBright)((0, chalk_1.bold)('⚠️ This is a simulation. No changes will be made to the chain. No package data will be saved.\n')));
    }
    const anvilOptions = (0, parse_anvil_options_1.parseAnvilOptions)(anvilOptionsParam);
    const node = await hre.run(task_names_2.SUBTASK_RUN_ANVIL_NODE, { dryRun, anvilOptions });
    if (node) {
        provider = (0, rpc_1.getProvider)(node);
    }
    const signers = (0, get_hardhat_signers_1.getHardhatSigners)(hre /*, provider*/);
    const getSigner = (address) => {
        for (const signer of signers) {
            if (viem.isAddressEqual(signer.address, address))
                return {
                    address: signer.address,
                    wallet: viem.createWalletClient({
                        account: signer,
                        chain: provider.chain,
                        transport: viem.custom(provider.transport),
                    }),
                };
        }
        return null;
    };
    let defaultSigner = null;
    if (hre.network.name !== 'cannon') {
        if (impersonate) {
            await provider.impersonateAccount({ address: impersonate });
            await provider.setBalance({ address: impersonate, value: viem.parseEther('10000') });
            defaultSigner = getSigner(impersonate) || null;
            // Add the impersonated signer if it is not part of the hardhat config
            if (!defaultSigner) {
                defaultSigner = { address: impersonate, wallet: provider };
                signers.push({ address: impersonate });
            }
        }
        else {
            defaultSigner = getSigner(signers[0].address);
        }
    }
    if (defaultSigner) {
        // print out any live deployment info that might be relevant
        console.log((0, chalk_1.yellow)(`default signer is ${defaultSigner.address}`));
    }
    const params = {
        provider,
        def,
        packageDefinition: {
            name,
            version,
            preset,
            settings: parsedSettings,
        },
        getArtifact: async (contractName) => await hre.run(task_names_2.SUBTASK_GET_ARTIFACT, { name: contractName }),
        async getSigner(addr) {
            if (impersonate || hre.network.name === 'cannon' || hre.network.name === 'hardhat') {
                // on test network any user can be conjured
                await provider.impersonateAccount({ address: addr });
                await provider.setBalance({ address: addr, value: viem.parseEther('10000') });
                return { address: addr, wallet: provider };
            }
            else {
                // return the actual signer with private key
                const signer = getSigner(addr);
                if (signer)
                    return signer;
                throw new Error(`The current operation requests usage of the signer with address ${addr}, but this signer is not found. Please either supply the private key, or change the cannon configuration to use a different signer.`);
            }
        },
        getDefaultSigner: defaultSigner ? async () => defaultSigner : undefined,
        pkgInfo: (0, load_pkg_json_1.loadPackageJson)(node_path_1.default.join(hre.config.paths.root, 'package.json')),
        projectDirectory: hre.config.paths.root,
        presetArg,
        upgradeFrom,
        wipe,
        registryPriority,
        persist: !dryRun && hre.network.name !== 'hardhat',
        overrideResolver: dryRun ? await (0, cli_1.createDryRunRegistry)((0, cli_1.resolveCliSettings)()) : undefined,
        plugins: !!usePlugins,
        publicSourceCode: hre.config.cannon.publicSourceCode,
    };
    const { outputs } = await (0, cli_1.build)(params);
    if (hre.network.name === 'hardhat') {
        console.log((0, chalk_1.yellow)('Keep in mind that regardless this package was succefully built, it was not saved because the "hardhat" network is being used. If this is not what you want, consider using --network cannon'));
    }
    // Include provider error parsing
    provider = (0, augment_provider_1.augmentProvider)(provider, outputs);
    hre.cannon.outputs = outputs;
    hre.cannon.provider = provider;
    hre.cannon.signers = signers;
    return { outputs, provider, signers };
});
//# sourceMappingURL=build.js.map