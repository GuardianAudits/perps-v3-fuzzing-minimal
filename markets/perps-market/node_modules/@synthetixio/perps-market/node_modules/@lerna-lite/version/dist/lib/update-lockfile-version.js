import { loadJsonFile } from 'load-json-file';
import { promises } from 'node:fs';
import { EOL } from 'node:os';
import { join } from 'node:path';
import log from 'npmlog';
import semver from 'semver';
import { writeJsonFile } from 'write-json-file';
import { execPackageManager, execPackageManagerSync } from '@lerna-lite/core';
export async function loadPackageLockFileWhenExists(lockFileFolderPath) {
    try {
        const lockFilePath = join(lockFileFolderPath, 'package-lock.json');
        const pkgLockFileObj = await loadJsonFile(lockFilePath);
        const lockfileVersion = +(pkgLockFileObj?.['lockfileVersion'] ?? 1);
        return {
            path: lockFilePath,
            json: pkgLockFileObj,
            lockfileVersion,
        };
    }
    catch (error) { }
}
export async function updateClassicLockfileVersion(pkg) {
    try {
        const lockFilePath = join(pkg.location, 'package-lock.json');
        const pkgLockFileObj = await loadJsonFile(lockFilePath);
        if (pkgLockFileObj) {
            pkgLockFileObj.version = pkg.version;
            if (pkgLockFileObj.packages?.['']) {
                pkgLockFileObj.packages[''].version = pkg.version;
                if (pkgLockFileObj.packages[''].dependencies) {
                    pkgLockFileObj.packages[''].dependencies = pkg.dependencies;
                }
                if (pkgLockFileObj.packages[''].devDependencies) {
                    pkgLockFileObj.packages[''].devDependencies = pkg.devDependencies;
                }
            }
            await writeJsonFile(lockFilePath, pkgLockFileObj, {
                detectIndent: true,
                indent: 2,
            });
            return lockFilePath;
        }
    }
    catch (error) { }
}
export function updateTempModernLockfileVersion(pkg, projLockFileObj) {
    if (projLockFileObj) {
        updateNpmLockFileVersion2(projLockFileObj, pkg.name, pkg.version);
    }
}
export async function saveUpdatedLockJsonFile(filePath, updateLockFileObj) {
    try {
        await writeJsonFile(filePath, updateLockFileObj, {
            detectIndent: true,
            indent: 2,
        });
        return filePath;
    }
    catch (error) { }
}
export function updateNpmLockFileVersion2(obj, pkgName, newVersion) {
    if (typeof obj === 'object' && pkgName && newVersion) {
        for (const k in obj) {
            if (typeof obj[k] === 'object' && obj[k] !== null) {
                updateNpmLockFileVersion2(obj[k], pkgName, newVersion);
            }
            else {
                if (k === pkgName) {
                    const [_, versionPrefix, _versionStr] = obj[k].match(/^([\^~])?(.*)$/) || [];
                    obj[k] = `${versionPrefix}${newVersion}`;
                }
                else if (k === 'name' && obj[k] === pkgName && obj['version'] !== undefined) {
                    if (obj['version'] !== undefined) {
                        obj['version'] = newVersion;
                    }
                }
            }
        }
    }
}
export async function runInstallLockFileOnly(npmClient, cwd, npmArgs) {
    let inputLockfileName = '';
    let outputLockfileName;
    const npmClientArgsRaw = npmArgs || [];
    const npmClientArgs = npmClientArgsRaw.reduce((args, arg) => args.concat(arg.split(/\s|,/)), []);
    switch (npmClient) {
        case 'pnpm':
            inputLockfileName = 'pnpm-lock.yaml';
            if (await validateFileExists(join(cwd, inputLockfileName))) {
                log.verbose('lock', `updating lock file via "pnpm install --lockfile-only --ignore-scripts"`);
                await execPackageManager('pnpm', ['install', '--lockfile-only', '--ignore-scripts', ...npmClientArgs], { cwd });
                outputLockfileName = inputLockfileName;
            }
            break;
        case 'yarn':
            inputLockfileName = 'yarn.lock';
            const yarnVersion = execPackageManagerSync('yarn', ['--version']);
            if (semver.gte(yarnVersion, '2.0.0') && (await validateFileExists(join(cwd, inputLockfileName)))) {
                log.verbose('lock', `updating lock file via "yarn install --mode update-lockfile"`);
                await execPackageManager('yarn', ['install', '--mode', 'update-lockfile', ...npmClientArgs], {
                    cwd,
                    env: {
                        ...process.env,
                        YARN_ENABLE_SCRIPTS: 'false',
                    },
                });
                outputLockfileName = inputLockfileName;
            }
            break;
        case 'npm':
        default:
            inputLockfileName = 'package-lock.json';
            if (await validateFileExists(join(cwd, inputLockfileName))) {
                const localNpmVersion = execPackageManagerSync('npm', ['--version']);
                log.silly(`npm`, `current local npm version is "${localNpmVersion}"`);
                if (semver.gte(localNpmVersion, '8.5.0')) {
                    log.verbose('lock', `updating lock file via "npm install --package-lock-only"`);
                    await execPackageManager('npm', ['install', '--package-lock-only', ...npmClientArgs], { cwd });
                }
                else {
                    log.error('lock', 'your npm version is lower than 8.5.0 which is the minimum requirement to use `--sync-workspace-lock`');
                }
                outputLockfileName = inputLockfileName;
            }
            break;
    }
    if (!outputLockfileName) {
        log.error('lock', [
            `we could not sync neither locate "${inputLockfileName}" by using "${npmClient}" client at location ${cwd}`,
            `Note: if you were expecting a different lock file name, make sure to configure "npmClient" into your "lerna.json" config file.`,
        ].join(EOL));
    }
    return outputLockfileName;
}
export async function validateFileExists(filePath) {
    try {
        await promises.access(filePath);
        return true;
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=update-lockfile-version.js.map