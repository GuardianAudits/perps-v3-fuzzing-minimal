import { EOL } from '@lerna-lite/core';
import conventionalChangelogCore from 'conventional-changelog-core';
import { writeFile } from 'fs/promises';
import getStream from 'get-stream';
import log from 'npmlog';
import { BLANK_LINE, CHANGELOG_HEADER } from './constants.js';
import { GetChangelogConfig } from './get-changelog-config.js';
import { makeBumpOnlyFilter } from './make-bump-only-filter.js';
import { readExistingChangelog } from './read-existing-changelog.js';
import { setConfigChangelogCommitClientLogin, setConfigChangelogCommitGitAuthor } from './writer-opts-transform.js';
export async function updateChangelog(pkg, type, updateOptions) {
    log.silly(type, 'for %s at %s', pkg.name, pkg.location);
    const { changelogPreset, changelogIncludeCommitsGitAuthor, changelogIncludeCommitsClientLogin, changelogHeaderMessage = '', commitsSinceLastRelease, rootPath, tagPrefix = 'v', version, } = updateOptions;
    const config = await GetChangelogConfig.getChangelogConfig(changelogPreset, rootPath);
    const options = {};
    const context = {};
    const writerOpts = {};
    if (config.conventionalChangelog) {
        options.config = Object.assign({}, config.conventionalChangelog);
    }
    else {
        options.config = Object.assign({}, config);
    }
    const gitRawCommitsOpts = Object.assign({}, options.config.gitRawCommitsOpts);
    if (changelogIncludeCommitsGitAuthor || changelogIncludeCommitsGitAuthor === '') {
        setConfigChangelogCommitGitAuthor(config, gitRawCommitsOpts, writerOpts, changelogIncludeCommitsGitAuthor);
    }
    else if ((changelogIncludeCommitsClientLogin || changelogIncludeCommitsClientLogin === '') && commitsSinceLastRelease) {
        setConfigChangelogCommitClientLogin(config, gitRawCommitsOpts, writerOpts, commitsSinceLastRelease, changelogIncludeCommitsClientLogin);
    }
    if (type === 'root') {
        context.version = version;
        context.currentTag = `${tagPrefix}${version}`;
        options.tagPrefix = tagPrefix;
    }
    else {
        gitRawCommitsOpts.path = pkg.location;
        options.pkg = { path: pkg.manifestLocation };
        if (type === 'independent') {
            options.lernaPackage = pkg.name;
        }
        else {
            options.tagPrefix = tagPrefix;
            context.currentTag = `${tagPrefix}${pkg.version}`;
            context.version = pkg.version;
        }
    }
    const changelogStream = conventionalChangelogCore(options, context, gitRawCommitsOpts, undefined, writerOpts);
    return Promise.all([
        getStream(changelogStream).then(makeBumpOnlyFilter(pkg)),
        readExistingChangelog(pkg),
    ]).then(([inputEntry, [changelogFileLoc, changelogContents]]) => {
        const newEntry = inputEntry;
        log.silly(type, 'writing new entry: %j', newEntry);
        const changelogHeader = CHANGELOG_HEADER.replace(/%s/g, changelogHeaderMessage?.length > 0 ? changelogHeaderMessage + EOL : '');
        const content = [changelogHeader, newEntry, changelogContents]
            .join(BLANK_LINE)
            .trim()
            .replace(/[\r\n]{2,}/gm, '\n\n');
        return writeFile(changelogFileLoc, content + EOL).then(() => {
            log.verbose(type, 'wrote', changelogFileLoc);
            return {
                logPath: changelogFileLoc,
                content,
                newEntry,
            };
        });
    });
}
//# sourceMappingURL=update-changelog.js.map