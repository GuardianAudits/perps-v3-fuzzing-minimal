import { ValidationError } from '@lerna-lite/core';
import chalk from 'chalk';
import log from 'npmlog';
import newGithubReleaseUrl from 'new-github-release-url';
import semver from 'semver';
import { createGitHubClient, createGitLabClient, parseGitRepo } from '../git-clients/index.js';
export async function createReleaseClient(type) {
    switch (type) {
        case 'gitlab':
            return createGitLabClient();
        case 'github':
            return await createGitHubClient();
        default:
            throw new ValidationError('ERELEASE', 'Invalid release client type');
    }
}
export function createRelease({ client, type, generateReleaseNotes, releaseDiscussion, }, { tags, releaseNotes }, { gitRemote, execOpts, skipBumpOnlyReleases }, dryRun = false) {
    const { GH_TOKEN, GITHUB_TOKEN } = process.env;
    const repo = parseGitRepo(gitRemote, execOpts);
    return Promise.all(releaseNotes.map(({ notes, name, pkg }) => {
        const tag = name === 'fixed' ? tags[0] : tags.find((t) => t.startsWith(`${name}@`));
        if (!tag || (skipBumpOnlyReleases && pkg?.isBumpOnlyVersion)) {
            return Promise.resolve();
        }
        const prereleaseParts = semver.prerelease(tag.replace(`${name}@`, '')) || [];
        if (type === 'github' && !GH_TOKEN && !GITHUB_TOKEN) {
            const releaseUrl = newGithubReleaseUrl({
                user: repo.owner,
                repo: repo.name,
                tag,
                isPrerelease: prereleaseParts.length > 0,
                title: tag,
                body: notes,
            });
            log.verbose('github', 'GH_TOKEN (or GITHUB_TOKEN) environment variable could not be found');
            log.info('github', `ðŸ·ï¸ (GitHub Release web interface) - ðŸ”— ${releaseUrl}`);
            return Promise.resolve();
        }
        const releaseOptions = {
            owner: repo.owner,
            repo: repo.name,
            tag_name: tag,
            draft: false,
            prerelease: prereleaseParts.length > 0,
        };
        if (releaseDiscussion) {
            releaseOptions.discussion_category_name = releaseDiscussion;
        }
        if (generateReleaseNotes) {
            releaseOptions.generate_release_notes = generateReleaseNotes;
        }
        else {
            releaseOptions.name = tag;
            releaseOptions.body = notes;
        }
        if (dryRun) {
            log.info(chalk.bold.magenta('[dry-run] >'), `Create Release with repo options: `, JSON.stringify(releaseOptions));
            return Promise.resolve();
        }
        return client.repos.createRelease(releaseOptions);
    }));
}
//# sourceMappingURL=create-release.js.map