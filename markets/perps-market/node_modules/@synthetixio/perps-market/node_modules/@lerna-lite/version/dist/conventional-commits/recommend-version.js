import conventionalRecommendedBump from 'conventional-recommended-bump';
import log from 'npmlog';
import semver from 'semver';
import { GetChangelogConfig } from './get-changelog-config.js';
import { applyBuildMetadata } from './apply-build-metadata.js';
export async function recommendVersion(pkg, type, recommendationOptions, premajorVersionBump) {
    const { changelogPreset, rootPath, tagPrefix, prereleaseId, conventionalBumpPrerelease, buildMetadata } = recommendationOptions;
    log.silly(type, 'for %s at %s', pkg.name, pkg.location);
    const options = {
        path: pkg.location,
    };
    if (type === 'independent') {
        options.lernaPackage = pkg.name;
    }
    else {
        options.tagPrefix = tagPrefix;
    }
    const shouldBumpPrerelease = (releaseType, version) => {
        if (!semver.prerelease(version)) {
            return true;
        }
        switch (releaseType) {
            case 'major':
                return semver.minor(version) !== 0 || semver.patch(version) !== 0;
            case 'minor':
                return semver.patch(version) !== 0;
            default:
                return false;
        }
    };
    options.config = (await GetChangelogConfig.getChangelogConfig(changelogPreset, rootPath));
    return new Promise(async (resolve, reject) => {
        try {
            const data = await conventionalRecommendedBump(options);
            let releaseType = data.releaseType || 'patch';
            if (prereleaseId) {
                const shouldBump = conventionalBumpPrerelease || shouldBumpPrerelease(releaseType, pkg.version);
                const prereleaseType = shouldBump ? `pre${releaseType}` : 'prerelease';
                log.verbose(type, 'increment %s by %s - %s', pkg.version, prereleaseType, pkg.name);
                resolve(applyBuildMetadata(semver.inc(pkg.version, prereleaseType, prereleaseId), buildMetadata));
            }
            else {
                if (semver.major(pkg.version) === 0) {
                    if (releaseType === 'major') {
                        releaseType = 'minor';
                    }
                    else if (premajorVersionBump === 'force-patch') {
                        releaseType = 'patch';
                    }
                }
                log.verbose(type, 'increment %s by %s - %s', pkg.version, releaseType, pkg.name);
                resolve(applyBuildMetadata(semver.inc(pkg.version, releaseType), buildMetadata));
            }
        }
        catch (err) {
            reject(err);
        }
    });
}
//# sourceMappingURL=recommend-version.js.map