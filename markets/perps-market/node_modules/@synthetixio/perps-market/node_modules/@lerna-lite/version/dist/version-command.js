import chalk from 'chalk';
import dedent from 'dedent';
import { minimatch } from 'minimatch';
import { EOL as OS_EOL } from 'node:os';
import pMap from 'p-map';
import pPipe from 'p-pipe';
import pReduce from 'p-reduce';
import semver from 'semver';
import { EOL, checkWorkingTree, collectPackages, collectUpdates, Command, createRunner, logOutput, promptConfirmation, runTopologically, throwIfUncommitted, ValidationError, } from '@lerna-lite/core';
import { getCurrentBranch } from './lib/get-current-branch.js';
import { createRelease, createReleaseClient } from './lib/create-release.js';
import { isAnythingCommitted } from './lib/is-anything-committed.js';
import { remoteBranchExists } from './lib/remote-branch-exists.js';
import { isBehindUpstream } from './lib/is-behind-upstream.js';
import { isBreakingChange } from './lib/is-breaking-change.js';
import { gitAdd } from './lib/git-add.js';
import { gitCommit } from './lib/git-commit.js';
import { gitTag } from './lib/git-tag.js';
import { gitPush } from './lib/git-push.js';
import { makePromptVersion } from './lib/prompt-version.js';
import { loadPackageLockFileWhenExists, updateClassicLockfileVersion, updateTempModernLockfileVersion, runInstallLockFileOnly, saveUpdatedLockJsonFile, } from './lib/update-lockfile-version.js';
import { applyBuildMetadata, getCommitsSinceLastRelease, recommendVersion, updateChangelog, } from './conventional-commits/index.js';
export function factory(argv) {
    return new VersionCommand(argv);
}
export class VersionCommand extends Command {
    get otherCommandConfigs() {
        return ['publish'];
    }
    get requiresGit() {
        return (this.commitAndTag ||
            this.pushToRemote ||
            this.options.allowBranch ||
            this.options.conventionalCommits);
    }
    constructor(argv) {
        super(argv);
        this.name = 'version';
        this.globalVersion = '';
        this.currentBranch = '';
        this.gitRemote = '';
        this.tagPrefix = '';
        this.commitAndTag = true;
        this.pushToRemote = true;
        this.hasRootedLeaf = false;
        this.releaseNotes = [];
        this.savePrefix = '';
        this.tags = [];
        this.packagesToVersion = [];
        this.updates = [];
    }
    async configureProperties() {
        super.configureProperties();
        const { amend, changelogIncludeCommitsClientLogin, changelogIncludeCommitsGitAuthor, commitHooks = true, gitRemote = 'origin', gitTagVersion = true, granularPathspec = true, push = true, signGitCommit, signoffGitCommit, signGitTag, forceGitTag, tagVersionPrefix = 'v', premajorVersionBump = 'default', } = this.options;
        this.gitRemote = gitRemote;
        this.tagPrefix = tagVersionPrefix;
        this.commitAndTag = gitTagVersion;
        this.pushToRemote = gitTagVersion && amend !== true && push;
        this.changelogIncludeCommitsClientLogin =
            changelogIncludeCommitsClientLogin === '' ? true : changelogIncludeCommitsClientLogin;
        this.changelogIncludeCommitsGitAuthor = changelogIncludeCommitsGitAuthor === '' ? true : changelogIncludeCommitsGitAuthor;
        this.premajorVersionBump = premajorVersionBump;
        if (this.pushToRemote && this.options.createRelease) {
            this.releaseClient = await createReleaseClient(this.options.createRelease);
        }
        this.releaseNotes = [];
        if (this.releaseClient && this.options.conventionalCommits !== true) {
            throw new ValidationError('ERELEASE', 'To create a release, you must enable --conventional-commits');
        }
        if (this.options.generateReleaseNotes && !this.options.createRelease) {
            throw new ValidationError('ERELEASE', 'To generate release notes, you must define --create-release');
        }
        if (this.options.createReleaseDiscussion && !this.options.createRelease) {
            throw new ValidationError('ERELEASE', 'To create a release discussion, you must define --create-release');
        }
        if (this.options.createReleaseDiscussion !== undefined && !this.options.createReleaseDiscussion) {
            throw new ValidationError('ERELEASE', 'A discussion category name must be provided to the --create-release-discussion option.');
        }
        if (this.releaseClient && this.options.changelog === false && this.options.generateReleaseNotes !== true) {
            throw new ValidationError('ERELEASE', 'To create a release, you cannot pass --no-changelog');
        }
        this.gitOpts = {
            amend,
            commitHooks,
            granularPathspec,
            signGitCommit,
            signoffGitCommit,
            signGitTag,
            forceGitTag,
        };
        this.savePrefix = this.options.exact ? '' : '^';
    }
    async initialize() {
        const isIndependent = this.project.isIndependent();
        const describeTag = this.project.config.describeTag;
        if (!isIndependent) {
            this.logger.info('current project version', this.project.version ?? '');
        }
        if (this.requiresGit) {
            if (!isAnythingCommitted(this.execOpts, this.options.dryRun)) {
                throw new ValidationError('ENOCOMMIT', 'No commits in this repository. Please commit something before using version.');
            }
            this.currentBranch = getCurrentBranch(this.execOpts, false);
            if (this.currentBranch === 'HEAD') {
                throw new ValidationError('ENOGIT', 'Detached git HEAD, please checkout a branch to choose versions.');
            }
            if (this.pushToRemote && !remoteBranchExists(this.gitRemote, this.currentBranch, this.execOpts, this.options.dryRun)) {
                throw new ValidationError('ENOREMOTEBRANCH', dedent `
            Branch "${this.currentBranch}" doesn't exist in remote "${this.gitRemote}".
            If this is a new branch, please make sure you push it to the remote first.
          `);
            }
            if (this.options.allowBranch &&
                ![].concat(this.options.allowBranch).some((x) => minimatch(this.currentBranch, x))) {
                throw new ValidationError('ENOTALLOWED', dedent `
            Branch "${this.currentBranch}" is restricted from versioning due to allowBranch config.
            Please consider the reasons for this restriction before overriding the option.
          `);
            }
            if (this.commitAndTag &&
                this.pushToRemote &&
                isBehindUpstream(this.gitRemote, this.currentBranch, this.execOpts, this.options.dryRun)) {
                const message = `Local branch "${this.currentBranch}" is behind remote upstream ${this.gitRemote}/${this.currentBranch}`;
                if (!this.options.ci) {
                    throw new ValidationError('EBEHIND', dedent `
              ${message}
              Please merge remote changes into "${this.currentBranch}" with "git pull"
            `);
                }
                this.logger.warn('EBEHIND', `${message}, exiting`);
                return false;
            }
        }
        else {
            this.logger.notice('FYI', 'git repository validation has been skipped, please ensure your version bumps are correct');
        }
        if (this.options.conventionalPrerelease && this.options.conventionalGraduate) {
            throw new ValidationError('ENOTALLOWED', dedent `
          --conventional-prerelease cannot be combined with --conventional-graduate.
        `);
        }
        if (this.options.manuallyUpdateRootLockfile && this.options.syncWorkspaceLock) {
            throw new ValidationError('ENOTALLOWED', dedent `
          --manually-update-root-lockfile cannot be combined with --sync-workspace-lock.
        `);
        }
        if (this.changelogIncludeCommitsClientLogin && this.changelogIncludeCommitsGitAuthor) {
            throw new ValidationError('ENOTALLOWED', dedent `
          --changelog-include-commits-client-login cannot be combined with --changelog-include-commits-git-author.
        `);
        }
        const remoteClient = this.options.createRelease || this.options.remoteClient;
        if (this.options.conventionalCommits && this.changelogIncludeCommitsClientLogin) {
            if (!remoteClient) {
                throw new ValidationError('EMISSINGCLIENT', dedent `
            --changelog-include-commits-client-login requires one of these two option --remote-client or --create-release to be defined.
          `);
            }
            this.commitsSinceLastRelease = await getCommitsSinceLastRelease(remoteClient, this.options.gitRemote, this.currentBranch, isIndependent, this.execOpts);
        }
        this.updates = collectUpdates(this.packageGraph.rawPackageList, this.packageGraph, this.execOpts, {
            ...this.options,
            isIndependent,
            describeTag,
        }).filter((node) => {
            if (node.pkg.private && this.options.private === false) {
                return false;
            }
            if (!node.version) {
                if (node.pkg.private) {
                    this.logger.info('version', 'Skipping unversioned private package %j', node.name);
                }
                else {
                    throw new ValidationError('ENOVERSION', dedent `
              A version field is required in ${node.name}'s package.json file.
              If you wish to keep the package unversioned, it must be made private.
            `);
                }
            }
            return !!node.version;
        });
        if (!this.updates.length) {
            this.logger.success(`No changed packages to ${this.composed ? 'publish' : 'version'}`);
            return false;
        }
        this.hasRootedLeaf = this.packageGraph.has(this.project.manifest.name);
        if (this.hasRootedLeaf && !this.composed) {
            this.logger.info('version', 'rooted leaf detected, skipping synthetic root lifecycles');
        }
        this.runPackageLifecycle = createRunner({ ...this.options, stdio: 'inherit' });
        this.runRootLifecycle = /^(pre|post)?version$/.test(process.env.npm_lifecycle_event)
            ? (stage) => this.logger.warn('lifecycle', 'Skipping root %j because it has already been called', stage)
            : (stage) => this.runPackageLifecycle(this.project.manifest, stage);
        if (this.commitAndTag && this.gitOpts.amend !== true) {
            const { forcePublish, conventionalCommits, conventionalGraduate } = this.options;
            const checkUncommittedOnly = forcePublish || (conventionalCommits && conventionalGraduate);
            const check = checkUncommittedOnly ? throwIfUncommitted : checkWorkingTree;
            await check(this.execOpts, this.options.dryRun);
        }
        else {
            this.logger.warn('version', 'Skipping working tree validation, proceed at your own risk');
        }
        const versionsForUpdate = await this.getVersionsForUpdates();
        await this.setUpdatesForVersions(versionsForUpdate);
        return this.confirmVersions();
    }
    async execute() {
        await this.updatePackageVersions();
        if (this.commitAndTag) {
            await this.commitAndTagUpdates();
        }
        else {
            this.logger.info('execute', 'Skipping git tag/commit');
        }
        if (this.pushToRemote) {
            await this.gitPushToRemote();
        }
        else {
            this.logger.info('execute', 'Skipping git push');
        }
        if (this.releaseClient) {
            this.logger.info('execute', 'Creating releases...');
            try {
                await createRelease({
                    client: this.releaseClient,
                    type: this.options.createRelease,
                    generateReleaseNotes: this.options.generateReleaseNotes,
                    releaseDiscussion: this.options.createReleaseDiscussion,
                }, { tags: this.tags, releaseNotes: this.releaseNotes }, {
                    gitRemote: this.options.gitRemote,
                    execOpts: this.execOpts,
                    skipBumpOnlyReleases: this.options.skipBumpOnlyReleases,
                }, this.options.dryRun);
            }
            catch (err) {
                this.logger.error('ERELEASE', `Something went wrong when creating the ${this.options.createRelease} release. Error:: ${err?.message ?? err}`);
            }
        }
        else {
            this.logger.info('execute', 'Skipping releases');
        }
        if (!this.composed) {
            this.logger.success('version', 'finished');
        }
        return {
            updates: this.updates,
            updatesVersions: this.updatesVersions,
        };
    }
    getVersionsForUpdates() {
        const independentVersions = this.project.isIndependent();
        const { bump, conventionalCommits, preid } = this.options;
        const repoVersion = (bump ? semver.clean(bump) : '');
        const increment = (bump && !semver.valid(bump) ? bump : '');
        const resolvePrereleaseId = (existingPreid) => preid || existingPreid || 'alpha';
        const makeGlobalVersionPredicate = (nextVersion) => {
            this.globalVersion = nextVersion;
            return () => nextVersion;
        };
        let predicate;
        if (repoVersion) {
            predicate = makeGlobalVersionPredicate(applyBuildMetadata(repoVersion, this.options.buildMetadata));
        }
        else if (increment && independentVersions) {
            predicate = (node) => applyBuildMetadata(semver.inc(node.version, increment, resolvePrereleaseId(node.prereleaseId)), this.options.buildMetadata);
        }
        else if (increment) {
            const prereleaseId = prereleaseIdFromVersion(this.project.version);
            const nextVersion = applyBuildMetadata(semver.inc(this.project.version, increment, resolvePrereleaseId(prereleaseId)), this.options.buildMetadata);
            predicate = makeGlobalVersionPredicate(nextVersion);
        }
        else if (conventionalCommits) {
            return this.recommendVersions(resolvePrereleaseId);
        }
        else if (independentVersions) {
            predicate = makePromptVersion(resolvePrereleaseId, this.options.buildMetadata);
        }
        else {
            const prereleaseId = prereleaseIdFromVersion(this.project.version);
            const node = { version: this.project.version, prereleaseId };
            predicate = makePromptVersion(resolvePrereleaseId, this.options.buildMetadata);
            predicate = predicate(node).then(makeGlobalVersionPredicate);
        }
        return Promise.resolve(predicate).then((getVersion) => this.reduceVersions(getVersion));
    }
    reduceVersions(getVersion) {
        const iterator = (versionMap, node) => Promise.resolve(getVersion(node)).then((version) => versionMap.set(node.name, version));
        return pReduce(this.updates, iterator, new Map());
    }
    setUpdatesForVersions(versions) {
        if (this.project.isIndependent()) {
            this.updatesVersions = versions;
        }
        else {
            let hasBreakingChange = false;
            for (const [name, bump] of versions) {
                hasBreakingChange = hasBreakingChange || isBreakingChange(this.packageGraph?.get(name).version, bump);
            }
            if (hasBreakingChange) {
                this.updates = Array.from(this.packageGraph?.values() ?? []);
                if (this.options.private === false) {
                    this.updates = this.updates.filter((node) => !node.pkg.private);
                }
                this.updatesVersions = new Map(this.updates.map((node) => [node.name, this.globalVersion]));
            }
            else {
                this.updatesVersions = versions;
            }
        }
        this.packagesToVersion = this.updates.map((node) => node.pkg);
    }
    getPrereleasePackageNames() {
        const prereleasePackageNames = this.getPackagesForOption(this.options.conventionalPrerelease);
        const isCandidate = prereleasePackageNames.has('*')
            ? () => true
            : (_node, name) => prereleasePackageNames.has(name);
        const prePkgs = collectPackages(this.packageGraph, { isCandidate }).map((pkg) => pkg?.name ?? '');
        if (this.options.conventionalPrerelease !== undefined &&
            typeof this.options.conventionalPrerelease !== 'boolean' &&
            prePkgs.length === 0) {
            throw new ValidationError('ENOPRERELEASE', `No packages found to prerelease when using "--conventional-prerelease ${this.options.conventionalPrerelease}".`);
        }
        return prePkgs;
    }
    getPackagesForOption(option) {
        let inputs = null;
        if (option === true) {
            inputs = ['*'];
        }
        else if (typeof option === 'string') {
            inputs = option.split(',');
        }
        else if (Array.isArray(option)) {
            inputs = [...option];
        }
        return new Set(inputs);
    }
    async recommendVersions(resolvePrereleaseId) {
        const independentVersions = this.project.isIndependent();
        const { buildMetadata, changelogPreset, conventionalGraduate, conventionalBumpPrerelease } = this.options;
        const rootPath = this.project.manifest.location;
        const type = independentVersions ? 'independent' : 'fixed';
        const prereleasePackageNames = this.getPrereleasePackageNames();
        const graduatePackageNames = Array.from(this.getPackagesForOption(conventionalGraduate));
        const shouldPrerelease = (name) => prereleasePackageNames?.includes(name);
        const shouldGraduate = (name) => graduatePackageNames.includes('*') || graduatePackageNames.includes(name);
        const getPrereleaseId = (node) => {
            if (!shouldGraduate(node.name) && (shouldPrerelease(node.name) || node.prereleaseId)) {
                return resolvePrereleaseId(node.prereleaseId);
            }
        };
        if (type === 'fixed') {
            this.setGlobalVersionFloor();
        }
        const versions = await this.reduceVersions((node) => recommendVersion(node, type, {
            changelogPreset,
            rootPath,
            tagPrefix: this.tagPrefix,
            prereleaseId: getPrereleaseId(node),
            conventionalBumpPrerelease,
            buildMetadata,
        }, this.premajorVersionBump));
        if (type === 'fixed') {
            this.globalVersion = this.setGlobalVersionCeiling(versions) ?? '';
        }
        return versions;
    }
    confirmVersions() {
        const changes = this.packagesToVersion.map((pkg) => {
            let line = ` - ${pkg.name ?? '[n/a]'}: ${pkg.version} => ${chalk.cyan(this.updatesVersions?.get(pkg?.name ?? ''))}`;
            if (pkg.private) {
                line += ` (${chalk.red('private')})`;
            }
            return line;
        });
        logOutput('');
        logOutput(`Changes (${changes.length} packages):`);
        logOutput(changes.join(EOL));
        logOutput('');
        if (this.options.yes) {
            this.logger.info('auto-confirmed', '');
            return true;
        }
        let confirmMessage = this.options.dryRun ? chalk.bgMagenta('[dry-run]') : '';
        confirmMessage += this.composed
            ? ' Are you sure you want to publish these packages?'
            : ' Are you sure you want to create these versions?';
        return promptConfirmation(confirmMessage.trim());
    }
    updatePackageVersions() {
        const { conventionalCommits, changelogPreset, changelogHeaderMessage, changelog = true } = this.options;
        const independentVersions = this.project.isIndependent();
        const rootPath = this.project.manifest.location;
        const changedFiles = new Set();
        const npmClient = this.options.npmClient || 'npm';
        let chain = Promise.resolve();
        if (!this.hasRootedLeaf) {
            chain = chain.then(() => this.runRootLifecycle('preversion'));
        }
        const actions = [
            (pkg) => this.runPackageLifecycle(pkg, 'preversion').then(() => pkg),
            (pkg) => pkg.refresh(),
            (pkg) => {
                pkg.set('version', this.updatesVersions?.get(pkg?.name ?? ''));
                for (const [depName, resolved] of this.packageGraph?.get(pkg.name).localDependencies) {
                    const depVersion = this.updatesVersions?.get(depName);
                    if (depVersion && resolved.type !== 'directory') {
                        pkg.updateLocalDependency(resolved, depVersion, this.savePrefix, this.options.allowPeerDependenciesUpdate, this.commandName);
                    }
                }
                return Promise.all([updateClassicLockfileVersion(pkg), pkg.serialize()]).then(([lockfilePath]) => {
                    changedFiles.add(pkg.manifestLocation);
                    if (lockfilePath) {
                        changedFiles.add(lockfilePath);
                    }
                    return pkg;
                });
            },
            (pkg) => this.runPackageLifecycle(pkg, 'version').then(() => pkg),
        ];
        if (conventionalCommits && changelog) {
            const type = independentVersions ? 'independent' : 'fixed';
            actions.push((pkg) => updateChangelog(pkg, type, {
                changelogPreset,
                rootPath,
                tagPrefix: this.tagPrefix,
                changelogIncludeCommitsGitAuthor: this.changelogIncludeCommitsGitAuthor,
                changelogIncludeCommitsClientLogin: this.changelogIncludeCommitsClientLogin,
                changelogHeaderMessage,
                commitsSinceLastRelease: this.commitsSinceLastRelease,
            }).then(({ logPath, newEntry }) => {
                changedFiles.add(logPath);
                if (independentVersions) {
                    this.releaseNotes.push({
                        name: pkg.name,
                        notes: newEntry,
                        pkg,
                    });
                }
                return pkg;
            }));
        }
        else if (this.options.generateReleaseNotes && !changelog) {
            actions.push((pkg) => {
                this.releaseNotes.push({
                    name: pkg.name,
                    pkg,
                });
            });
        }
        const mapUpdate = pPipe(...actions);
        chain = chain.then(() => runTopologically(this.packagesToVersion, mapUpdate, {
            concurrency: this.concurrency,
            rejectCycles: this.options.rejectCycles,
            graphType: this.options.allowPeerDependenciesUpdate ? 'allPlusPeerDependencies' : 'allDependencies',
        }));
        if (npmClient === 'npm' &&
            (this.options.manuallyUpdateRootLockfile ||
                (this.options.manuallyUpdateRootLockfile === undefined && !this.options.syncWorkspaceLock))) {
            this.logger.warn('npm', 'we recommend using --sync-workspace-lock which will sync your lock file via your favorite npm client instead of relying on Lerna-Lite itself to update it.');
            chain = chain.then(() => loadPackageLockFileWhenExists(rootPath).then((lockFileResponse) => {
                if (lockFileResponse && lockFileResponse.lockfileVersion >= 2) {
                    this.logger.verbose(`lock`, `start process loop of manually updating npm lock file`);
                    for (const pkg of this.packagesToVersion) {
                        this.logger.verbose(`lock`, `updating root "package-lock-json" for package "${pkg.name}"`);
                        updateTempModernLockfileVersion(pkg, lockFileResponse.json);
                    }
                    return saveUpdatedLockJsonFile(lockFileResponse.path, lockFileResponse.json).then((lockfilePath) => {
                        if (lockfilePath) {
                            changedFiles.add(lockfilePath);
                        }
                    });
                }
            }));
        }
        else if (this.options.syncWorkspaceLock) {
            chain = chain.then(() => runInstallLockFileOnly(npmClient, this.project.manifest.location, this.options.npmClientArgs || []).then((lockfilePath) => {
                if (lockfilePath) {
                    changedFiles.add(lockfilePath);
                }
            }));
        }
        if (!independentVersions) {
            this.project.version = this.globalVersion;
            if (conventionalCommits && changelog) {
                chain = chain.then(() => updateChangelog(this.project.manifest, 'root', {
                    changelogPreset,
                    rootPath,
                    tagPrefix: this.tagPrefix,
                    version: this.globalVersion,
                    changelogIncludeCommitsGitAuthor: this.changelogIncludeCommitsGitAuthor,
                    changelogIncludeCommitsClientLogin: this.changelogIncludeCommitsClientLogin,
                    changelogHeaderMessage,
                    commitsSinceLastRelease: this.commitsSinceLastRelease,
                }).then(({ logPath, newEntry }) => {
                    changedFiles.add(logPath);
                    this.releaseNotes.push({
                        name: 'fixed',
                        notes: newEntry,
                    });
                }));
            }
            else if (this.options.generateReleaseNotes && !changelog) {
                chain.then(() => {
                    this.releaseNotes.push({
                        name: 'fixed',
                    });
                });
            }
            chain = chain.then(() => this.project.serializeConfig().then((lernaConfigLocation) => {
                changedFiles.add(lernaConfigLocation);
            }));
        }
        if (!this.hasRootedLeaf) {
            chain = chain.then(() => this.runRootLifecycle('version'));
        }
        if (this.commitAndTag) {
            chain = chain.then(() => gitAdd(Array.from(changedFiles), this.gitOpts, this.execOpts, this.options.dryRun));
        }
        return chain;
    }
    async commitAndTagUpdates() {
        if (this.project.isIndependent()) {
            this.tags = await this.gitCommitAndTagVersionForUpdates();
        }
        else {
            this.tags = await this.gitCommitAndTagVersion();
        }
        await pMap(this.packagesToVersion, (pkg) => this.runPackageLifecycle(pkg, 'postversion'));
        if (!this.hasRootedLeaf) {
            await this.runRootLifecycle('postversion');
        }
    }
    async gitCommitAndTagVersionForUpdates() {
        const tagVersionSeparator = this.options.tagVersionSeparator || '@';
        const tags = this.packagesToVersion.map((pkg) => `${pkg.name}${tagVersionSeparator}${this.updatesVersions?.get(pkg.name)}`);
        const subject = this.options.message || 'chore: Publish new release';
        const message = tags.reduce((msg, tag) => `${msg}${OS_EOL} - ${tag}`, `${subject}${OS_EOL}`);
        await gitCommit(message, this.gitOpts, this.execOpts, this.options.dryRun);
        for (const tag of tags) {
            await gitTag(tag, this.gitOpts, this.execOpts, this.options.gitTagCommand, this.options.dryRun);
        }
        return tags;
    }
    async gitCommitAndTagVersion() {
        const version = this.globalVersion;
        const tag = `${this.tagPrefix}${version}`;
        const message = this.options.message ? this.options.message.replace(/%s/g, tag).replace(/%v/g, version) : tag;
        await gitCommit(message, this.gitOpts, this.execOpts, this.options.dryRun);
        await gitTag(tag, this.gitOpts, this.execOpts, this.options.gitTagCommand, this.options.dryRun);
        return [tag];
    }
    gitPushToRemote() {
        this.logger.info('git', 'Pushing tags...');
        return gitPush(this.gitRemote, this.currentBranch, this.execOpts, this.options.dryRun);
    }
    setGlobalVersionFloor() {
        const globalVersion = this.project.version;
        for (const node of this.updates) {
            if (semver.lt(node.version, globalVersion)) {
                this.logger.verbose('version', `Overriding version of ${node.name} from ${node.version} to ${globalVersion}`);
                node.pkg.version = globalVersion;
            }
        }
    }
    setGlobalVersionCeiling(versions) {
        let highestVersion = this.project.version;
        versions.forEach((bump) => {
            if (bump && semver.gt(bump, highestVersion)) {
                highestVersion = bump;
            }
        });
        versions.forEach((_, name) => versions.set(name, highestVersion));
        return highestVersion;
    }
}
function prereleaseIdFromVersion(version) {
    return (semver.prerelease(version) || []).shift();
}
//# sourceMappingURL=version-command.js.map