import { ValidationError } from '@lerna-lite/core';
import log from 'npmlog';
import npa from 'npm-package-arg';
import pify from 'pify';
export class GetChangelogConfig {
    static isFunction(config) {
        return (Object.prototype.toString.call(config) === '[object Function]' ||
            Object.prototype.toString.call(config) === '[object AsyncFunction]');
    }
    static async resolveConfigPromise(presetPackageName, presetConfig) {
        log.verbose('getChangelogConfig', 'Attempting to resolve preset %j', presetPackageName);
        let config = await import(presetPackageName);
        if (config?.default) {
            config = config.default;
        }
        log.info('getChangelogConfig', 'Successfully resolved preset %j', presetPackageName);
        if (this.isFunction(config)) {
            try {
                config = config(presetConfig);
            }
            catch (_) {
                config = pify(config)();
            }
        }
        return config;
    }
    static async getChangelogConfig(changelogPreset = 'conventional-changelog-angular', rootPath) {
        const presetName = typeof changelogPreset === 'string' ? changelogPreset : changelogPreset.name;
        const presetConfig = typeof changelogPreset === 'object' ? changelogPreset : {};
        const cacheKey = `${presetName}${presetConfig ? JSON.stringify(presetConfig) : ''}`;
        let config = GetChangelogConfig.cfgCache.get(cacheKey);
        if (!config) {
            let presetPackageName = presetName;
            const parsed = npa(presetPackageName, rootPath);
            log.verbose('getChangelogConfig', 'using preset %j', presetPackageName);
            log.silly('npa', parsed);
            if (parsed.type === 'directory') {
                if (parsed.raw[0] === '@') {
                    parsed.name = parsed.raw;
                    parsed.scope = parsed.raw.substring(0, parsed.raw.indexOf('/'));
                }
                else {
                    presetPackageName = parsed.fetchSpec;
                }
            }
            else if (parsed.type === 'git' && parsed.hosted && parsed.hosted.default === 'shortcut') {
                parsed.name = parsed.raw;
            }
            try {
                config = await this.resolveConfigPromise(presetPackageName, presetConfig);
                GetChangelogConfig.cfgCache.set(cacheKey, config);
                return Promise.resolve(config);
            }
            catch (err) {
                log.verbose('getChangelogConfig', err.message);
                log.info('getChangelogConfig', 'Auto-prefixing conventional-changelog preset %j', presetName);
                parsed.name = parsed.raw;
            }
            if (parsed.name.indexOf('conventional-changelog-') < 0) {
                const parts = parsed.name.split('/');
                const start = parsed.scope ? 1 : 0;
                parts.splice(start, 1, `conventional-changelog-${parts[start]}`);
                presetPackageName = parts.join('/');
            }
            try {
                config = await this.resolveConfigPromise(presetPackageName, presetConfig);
                GetChangelogConfig.cfgCache.set(cacheKey, config);
            }
            catch (err) {
                log.warn('getChangelogConfig', err.message);
                throw new ValidationError('EPRESET', `Unable to load conventional-changelog preset "${presetName}"${presetName !== presetPackageName ? ` (${presetPackageName})` : ''}`);
            }
        }
        return Promise.resolve(config);
    }
}
GetChangelogConfig.cfgCache = new Map();
//# sourceMappingURL=get-changelog-config.js.map