import multimatch from 'multimatch';
import util from 'node:util';
import log from 'npmlog';
import { ValidationError } from '@lerna-lite/core';
export function filterPackages(packagesToFilter, include = [], exclude = [], showPrivate, continueIfNoMatch) {
    const filtered = new Set(packagesToFilter);
    const patterns = [].concat(arrify(include), negate(exclude));
    if (showPrivate === false) {
        for (const pkg of filtered) {
            if (pkg.private) {
                filtered.delete(pkg);
            }
        }
    }
    if (patterns.length) {
        log.info('filter', JSON.stringify(patterns));
        if (!include.length) {
            patterns.unshift('**');
        }
        const pnames = Array.from(filtered).map((pkg) => pkg?.name ?? '');
        const chosen = new Set(multimatch(pnames, patterns));
        for (const pkg of filtered) {
            if (!chosen.has(pkg?.name ?? '')) {
                filtered.delete(pkg);
            }
        }
        if (!filtered.size && !continueIfNoMatch) {
            throw new ValidationError('EFILTER', util.format('No packages remain after filtering', patterns));
        }
    }
    return Array.from(filtered);
}
function arrify(thing) {
    if (!thing) {
        return [];
    }
    if (!Array.isArray(thing)) {
        return [thing];
    }
    return thing;
}
function negate(patterns) {
    return arrify(patterns).map((pattern) => `!${pattern}`);
}
//# sourceMappingURL=filter-packages.js.map