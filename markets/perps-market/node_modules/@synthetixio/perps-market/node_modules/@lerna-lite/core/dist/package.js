import { loadJsonFile, loadJsonFileSync } from 'load-json-file';
import npa from 'npm-package-arg';
import npmlog from 'npmlog';
import { basename, dirname, join, resolve as pathResolve, relative } from 'node:path';
import { writePackage } from 'write-pkg';
const PKG = Symbol('pkg');
const _location = Symbol('location');
const _resolved = Symbol('resolved');
const _rootPath = Symbol('rootPath');
const _scripts = Symbol('scripts');
const _contents = Symbol('contents');
function binSafeName({ name, scope }) {
    return scope ? name.substring(scope.length + 1) : name;
}
function shallowCopy(json) {
    return Object.keys(json).reduce((obj, key) => {
        const val = json[key];
        if (Array.isArray(val)) {
            obj[key] = val.slice();
        }
        else if (val && typeof val === 'object') {
            obj[key] = Object.assign({}, val);
        }
        else {
            obj[key] = val;
        }
        return obj;
    }, {});
}
export class Package {
    static lazy(ref, dir = '.') {
        if (typeof ref === 'string') {
            const location = pathResolve(basename(ref) === 'package.json' ? dirname(ref) : ref);
            const manifest = loadJsonFileSync(join(location, 'package.json'));
            return new Package(manifest, location);
        }
        if ('__isLernaPackage' in ref) {
            return ref;
        }
        return new Package(ref, dir);
    }
    constructor(pkg, location, rootPath = location) {
        this._id = '';
        this.isBumpOnlyVersion = false;
        this.licensePath = '';
        this.localDependencies = new Map();
        const resolved = npa.resolve(pkg?.name ?? '', `file:${relative(rootPath, location)}`, rootPath);
        this.name = pkg?.name ?? '';
        this[PKG] = pkg;
        Object.defineProperty(this, PKG, { enumerable: false, writable: true });
        this[_location] = location;
        this[_resolved] = resolved;
        this[_rootPath] = rootPath;
        this[_scripts] = { ...pkg.scripts };
    }
    get location() {
        return this[_location];
    }
    get private() {
        return Boolean(this[PKG].private);
    }
    get resolved() {
        return this[_resolved];
    }
    get rootPath() {
        return this[_rootPath];
    }
    get scripts() {
        return this[_scripts];
    }
    get bin() {
        const pkg = this[PKG];
        return typeof pkg.bin === 'string'
            ? { [binSafeName(this.resolved)]: pkg.bin }
            : Object.assign({}, pkg.bin);
    }
    get binLocation() {
        return join(this.location, 'node_modules', '.bin');
    }
    get manifest() {
        return this[PKG];
    }
    get manifestLocation() {
        return join(this.location, 'package.json');
    }
    get nodeModulesLocation() {
        return join(this.location, 'node_modules');
    }
    get __isLernaPackage() {
        return true;
    }
    get version() {
        return this[PKG].version;
    }
    set version(version) {
        this[PKG].version = version;
    }
    get workspaces() {
        return this[PKG].workspaces;
    }
    set workspaces(workspaces) {
        this[PKG].workspaces = workspaces;
    }
    get contents() {
        if (this[_contents]) {
            return this[_contents];
        }
        if (this[PKG].publishConfig?.directory) {
            return join(this.location, this[PKG].publishConfig.directory);
        }
        return this.location;
    }
    set contents(subDirectory) {
        this[_contents] = join(this.location, subDirectory);
    }
    get dependencies() {
        return this[PKG].dependencies;
    }
    get devDependencies() {
        return this[PKG].devDependencies;
    }
    get optionalDependencies() {
        return this[PKG].optionalDependencies;
    }
    get peerDependencies() {
        return this[PKG].peerDependencies;
    }
    get pkg() {
        return this[PKG];
    }
    get(key) {
        return this[PKG][key];
    }
    set(key, val) {
        this[PKG][key] = val;
        return this;
    }
    toJSON() {
        return shallowCopy(this[PKG]);
    }
    refresh() {
        return loadJsonFile(this.manifestLocation).then((pkg) => {
            this[PKG] = pkg;
            return this;
        });
    }
    serialize() {
        return writePackage(this.manifestLocation, this[PKG]).then(() => this);
    }
    removeDependencyWorkspaceProtocolPrefix(pkgName, resolved) {
        const depName = resolved.name;
        const workspaceSpec = resolved?.workspaceSpec ?? '';
        const localDependencies = this.retrievePackageDependencies(depName);
        const inspectDependencies = [localDependencies];
        if (this.peerDependencies?.[depName]) {
            inspectDependencies.push(this.peerDependencies);
        }
        for (const depCollection of inspectDependencies) {
            if (depCollection && (resolved.registry || resolved.type === 'directory') && /^(workspace:)+(.*)$/.test(workspaceSpec)) {
                if (workspaceSpec) {
                    if (resolved.fetchSpec === 'latest' || resolved.fetchSpec === '') {
                        npmlog.error(`publish`, [
                            `Your package named "${pkgName}" has external dependencies not handled by Lerna-Lite and without workspace version suffix, `,
                            `we recommend using defined versions with workspace protocol. `,
                            `Your dependency is currently being published with "${depName}": "${resolved.fetchSpec}".`,
                        ].join(''));
                    }
                    depCollection[depName] = resolved.fetchSpec;
                }
            }
        }
    }
    updateLocalDependency(resolved, depVersion, savePrefix, allowPeerDependenciesUpdate = false, updatedByCommand) {
        const depName = resolved.name;
        const localDependencies = this.retrievePackageDependencies(depName);
        const updatingDependencies = [localDependencies];
        if (this.peerDependencies?.[depName]) {
            if (allowPeerDependenciesUpdate && /^(workspace:)?[~^*]?[\d\.]*([\-]+[\w\.\-\+]+)*$/i.test(this.peerDependencies[depName] || '')) {
                updatingDependencies.push(this.peerDependencies);
            }
            else if (updatedByCommand === 'publish' && this.peerDependencies[depName].startsWith('workspace:')) {
                this.peerDependencies[depName] = this.peerDependencies[depName].replace('workspace:', '');
                if (/^[~^]$/.test(this.peerDependencies[depName])) {
                    this.peerDependencies[depName] = resolved.fetchSpec || '';
                }
            }
        }
        for (const depCollection of updatingDependencies) {
            if (depCollection && (resolved.registry || resolved.type === 'directory')) {
                depCollection[depName] = `${savePrefix}${depVersion}`;
                if (resolved.workspaceSpec) {
                    const workspaceSpec = resolved?.workspaceSpec ?? '';
                    const [_, _wsTxt, operatorPrefix, rangePrefix, semver] = workspaceSpec.match(/^(workspace:)?([<>=]{0,2})?([*|~|^])?(.*)$/) || [];
                    if (operatorPrefix) {
                        depCollection[depName] = `${operatorPrefix}${rangePrefix || ''}${semver}`;
                    }
                    else {
                        depCollection[depName] = `${rangePrefix || ''}${depVersion}`;
                    }
                    if (updatedByCommand === 'publish') {
                        if (workspaceSpec === 'workspace:*') {
                            depCollection[depName] = depVersion;
                        }
                        else if (workspaceSpec === 'workspace:~') {
                            depCollection[depName] = `~${depVersion}`;
                        }
                        else if (workspaceSpec === 'workspace:^') {
                            depCollection[depName] = `^${depVersion}`;
                        }
                    }
                    else {
                        depCollection[depName] = /^workspace:[*|~|^]{1}$/.test(workspaceSpec)
                            ? resolved.workspaceSpec
                            : `workspace:${depCollection[depName]}`;
                    }
                }
            }
            else if (resolved.gitCommittish) {
                const [tagPrefix] = /^\D*/.exec(resolved.gitCommittish);
                const { hosted } = resolved;
                hosted.committish = `${tagPrefix}${depVersion}`;
                depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
            }
            else if (resolved.gitRange) {
                const { hosted } = resolved;
                hosted.committish = `semver:${savePrefix}${depVersion}`;
                depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
            }
        }
    }
    retrievePackageDependencies(depName) {
        let depCollection = this.dependencies;
        if (!depCollection || !depCollection[depName]) {
            depCollection = this.optionalDependencies;
        }
        if (!depCollection || !depCollection[depName]) {
            depCollection = this.devDependencies;
        }
        return depCollection;
    }
}
//# sourceMappingURL=package.js.map