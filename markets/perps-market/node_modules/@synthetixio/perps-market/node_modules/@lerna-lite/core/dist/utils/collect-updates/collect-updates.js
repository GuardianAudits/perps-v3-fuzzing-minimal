import log from 'npmlog';
import { describeRefSync } from '../describe-ref.js';
import { collectPackages } from './lib/collect-packages.js';
import { getPackagesForOption } from './lib/get-packages-for-option.js';
import { hasTags } from './lib/has-tags.js';
import { makeDiffPredicate } from './lib/make-diff-predicate.js';
export function collectUpdates(filteredPackages, packageGraph, execOpts, commandOptions) {
    const { forcePublish, forceConventionalGraduate, conventionalCommits, conventionalGraduate, excludeDependents, independentSubpackages, isIndependent, describeTag, tagVersionSeparator, } = commandOptions;
    const useConventionalGraduate = conventionalCommits && (conventionalGraduate || forceConventionalGraduate);
    const forced = getPackagesForOption(useConventionalGraduate ? conventionalGraduate : forcePublish);
    const packages = filteredPackages.length === packageGraph.size
        ? packageGraph
        : new Map(filteredPackages.map(({ name }) => [name, packageGraph.get(name)]));
    let committish = commandOptions.since;
    const tagPattern = describeTag ? describeTag : isIndependent ? '*@*' : '';
    if (hasTags(execOpts, tagPattern)) {
        const describeOptions = {
            ...execOpts,
            match: tagPattern,
            separator: tagVersionSeparator,
        };
        const { sha, refCount, lastTagName } = describeRefSync(describeOptions, commandOptions.includeMergedTags);
        if (refCount === '0' && forced.size === 0 && !committish) {
            log.notice('', 'Current HEAD is already released, skipping change detection.');
            return [];
        }
        if (commandOptions.canary) {
            committish = `${sha}^..${sha}`;
        }
        else if (!committish) {
            committish = lastTagName;
        }
    }
    if (forced.size) {
        log.warn(useConventionalGraduate ? 'conventional-graduate' : 'force-publish', forced.has('*') ? 'all packages' : Array.from(forced.values()).join('\n'));
    }
    if (useConventionalGraduate) {
        if (forced.has('*')) {
            log.info('', 'Graduating all prereleased packages');
        }
        else {
            log.info('', 'Graduating prereleased packages');
        }
    }
    else if (!committish || forced.has('*')) {
        log.info('', 'Assuming all packages changed');
        return collectPackages(packages, {
            onInclude: (name) => log.verbose('updated', name),
            excludeDependents,
        });
    }
    log.info('', `Looking for changed packages since ${committish}`);
    const hasDiff = makeDiffPredicate(committish, execOpts, commandOptions.ignoreChanges, {
        independentSubpackages,
    });
    const needsBump = !commandOptions.bump || commandOptions.bump.startsWith('pre')
        ? () => false
        :
            (node) => node.prereleaseId;
    const isForced = (node, name) => (forced.has('*') || forced.has(name)) && ((useConventionalGraduate ? node.prereleaseId : true) || forceConventionalGraduate);
    return collectPackages(packages, {
        isCandidate: (node, name) => isForced(node, name) || needsBump(node) || hasDiff(node),
        onInclude: (name) => log.verbose('updated', name),
        excludeDependents,
    });
}
//# sourceMappingURL=collect-updates.js.map