import cloneDeep from 'clone-deep';
import dedent from 'dedent';
import { execaSync } from 'execa';
import isCI from 'is-ci';
import log from 'npmlog';
import { cpus } from 'node:os';
import { cleanStack } from './utils/clean-stack.js';
import { logExecCommand } from './child-process.js';
import { logPackageError } from './utils/log-package-error.js';
import { warnIfHanging } from './utils/warn-if-hanging.js';
import { writeLogFile } from './utils/write-log-file.js';
import { Project } from './project/project.js';
import { ValidationError } from './validation-error.js';
import { PackageGraph } from './package-graph/package-graph.js';
const DEFAULT_CONCURRENCY = cpus().length;
export class Command {
    constructor(_argv) {
        this.commandName = '';
        log.pause();
        log.heading = 'lerna-lite';
        const argv = cloneDeep(_argv);
        log.silly('argv', argv.toString());
        this.commandName = this.constructor.name.replace(/Command$/, '').toLowerCase();
        this.composed = typeof argv.composed === 'string' && argv.composed !== this.commandName;
        if (!this.composed) {
            log.notice('cli', `v${argv.lernaVersion}`);
        }
        let runner = new Promise((resolve, reject) => {
            let chain = Promise.resolve();
            chain = chain.then(() => (this.project = new Project(argv.cwd)));
            chain = chain.then(() => this.configureEnvironment());
            chain = chain.then(() => this.configureOptions());
            chain = chain.then(() => this.configureProperties());
            chain = chain.then(() => this.configureLogging());
            chain = chain.then(() => this.runValidations());
            chain = chain.then(() => this.runPreparations());
            chain = chain.then(() => this.runCommand());
            chain.then((result) => {
                warnIfHanging();
                resolve(result);
            }, (err) => {
                if (err.pkg) {
                    logPackageError(err, this.options.stream);
                }
                else if (err.name !== 'ValidationError') {
                    log.error('', cleanStack(err, this.constructor.name));
                }
                if (err.name !== 'ValidationError' && !err.pkg) {
                    writeLogFile(this.project.rootPath);
                }
                warnIfHanging();
                reject(err);
                if (err.name === 'ValidationError') {
                    log.error(err.code, (err.body && err.body.error) || err.message);
                }
            });
        });
        if (argv.onResolved || argv.onRejected) {
            runner = runner.then(argv.onResolved, argv.onRejected);
            delete argv.onResolved;
            delete argv.onRejected;
        }
        for (const key of ['cwd', '$0']) {
            Object.defineProperty(argv, key, { enumerable: false });
        }
        Object.defineProperty(this, 'argv', {
            value: Object.freeze(argv),
        });
        Object.defineProperty(this, 'runner', {
            value: runner,
        });
    }
    then(onResolved, onRejected) {
        return this.runner?.then(onResolved, onRejected);
    }
    catch(onRejected) {
        return this.runner?.catch(onRejected);
    }
    get requiresGit() {
        return true;
    }
    get otherCommandConfigs() {
        return [];
    }
    configureEnvironment() {
        let loglevel;
        let progress;
        if (isCI || !process.stderr.isTTY || process.env.TERM === 'dumb') {
            log.disableColor();
            progress = false;
        }
        else if (!process.stdout.isTTY) {
            progress = false;
            loglevel = 'error';
        }
        else if (process.stderr.isTTY) {
            log.enableColor();
            log.enableUnicode();
        }
        Object.defineProperty(this, 'envDefaults', {
            value: {
                ci: isCI,
                progress,
                loglevel,
            },
        });
    }
    configureOptions() {
        const commandConfig = this.project.config.command || {};
        const overrides = [this.commandName, ...this.otherCommandConfigs].map((key) => commandConfig[key]);
        this.options = defaultOptions(this.argv, ...overrides, this.project.config, this.envDefaults);
        if (this.options.verbose && this.options.loglevel !== 'silly') {
            this.options.loglevel = 'verbose';
        }
    }
    configureProperties() {
        const { concurrency, sort, maxBuffer } = this.options;
        this.concurrency = Math.max(1, +concurrency || DEFAULT_CONCURRENCY);
        this.toposort = sort === undefined || sort;
        this.execOpts = {
            cwd: this.project.rootPath ?? '',
            maxBuffer,
        };
    }
    configureLogging() {
        const { loglevel } = this.options;
        if (loglevel) {
            log.level = loglevel;
        }
        log.addLevel('success', 3001, { fg: 'green', bold: true });
        Object.defineProperty(this, 'logger', {
            value: log.newGroup(this.commandName),
        });
        log.resume();
    }
    enableProgressBar() {
        if (this.options.progress !== false) {
            log.enableProgress();
        }
    }
    gitInitialized() {
        const opts = {
            cwd: this.project.rootPath ?? '',
            reject: false,
            stdio: 'ignore',
        };
        const gitCommand = 'git';
        const gitArgs = ['rev-parse'];
        if (this.options.dryRun) {
            logExecCommand(gitCommand, gitArgs);
            return true;
        }
        return execaSync(gitCommand, gitArgs, opts).exitCode === 0;
    }
    runValidations() {
        if ((this.options.since !== undefined || this.requiresGit) && !this.gitInitialized()) {
            throw new ValidationError('ENOGIT', "The git binary was not found, this is not a git repository, or you git doesn't have the right ownership. Run `git rev-parse` to get more details.");
        }
        if (!this.project.manifest) {
            throw new ValidationError('ENOPKG', 'No `package.json` file found, make sure it exist in the root of your project.');
        }
        if (this.project.configNotFound) {
            throw new ValidationError('ENOLERNA', '`lerna.json` does not exist, have you run `lerna init`?');
        }
        if (!this.project.version) {
            throw new ValidationError('ENOVERSION', 'Required property `version` does not exist in `lerna.json`, make sure to provide one of two modes (fixed or independent). For example "version": "independent" OR "version": "1.0.0"');
        }
        if (this.options.independent && !this.project.isIndependent()) {
            throw new ValidationError('EVERSIONMODE', dedent `
          You ran lerna-lite with --independent or -i, but the repository is not set to independent mode.
          To use independent mode you need to set lerna.json's "version" property to "independent".
          Then you won't need to pass the --independent or -i flags.
        `);
        }
    }
    runPreparations() {
        if (!this.composed && this.project.isIndependent()) {
            log.info('versioning', 'independent');
        }
        if (!this.composed && this.options.ci) {
            log.info('ci', 'enabled');
        }
        let chain = Promise.resolve();
        if (this.commandName !== 'info') {
            chain = chain.then(() => this.project.getPackages());
            chain = chain.then((packages) => {
                this.packageGraph = new PackageGraph(packages || [], this.options.allowPeerDependenciesUpdate ? 'allPlusPeerDependencies' : 'allDependencies');
            });
        }
        return chain;
    }
    async runCommand() {
        return Promise.resolve()
            .then(() => this.initialize())
            .then((proceed) => {
            if (proceed !== false) {
                return this.execute();
            }
        });
    }
    initialize() {
        throw new ValidationError(this.commandName, 'initialize() needs to be implemented.');
    }
    execute() {
        throw new ValidationError(this.commandName, 'execute() needs to be implemented.');
    }
}
function defaultOptions(...sources) {
    const options = {};
    for (const source of sources) {
        if (source !== null && source !== undefined) {
            for (const key of Object.keys(source)) {
                if (options[key] === undefined) {
                    options[key] = source[key];
                }
            }
        }
    }
    return options;
}
//# sourceMappingURL=command.js.map