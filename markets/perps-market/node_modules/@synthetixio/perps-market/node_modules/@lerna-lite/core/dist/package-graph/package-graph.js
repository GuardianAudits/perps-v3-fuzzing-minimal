import npa from 'npm-package-arg';
import { CyclicPackageGraphNode, PackageGraphNode, reportCycles } from './lib/index.js';
import { ValidationError } from '../validation-error.js';
export class PackageGraph extends Map {
    constructor(packages, graphType = 'allDependencies', localDependencies = 'auto') {
        if (localDependencies === true || localDependencies === 'forceLocal') {
            localDependencies = 'force';
        }
        super(packages.map((pkg) => [pkg?.name ?? '', new PackageGraphNode(pkg)]));
        if (packages.length !== this.size) {
            const seen = new Map();
            for (const { name, location } of packages) {
                if (seen.has(name)) {
                    seen.get(name).push(location);
                }
                else {
                    seen.set(name, [location]);
                }
            }
            for (const [name, locations] of seen) {
                if (locations.length > 1) {
                    throw new ValidationError('ENAME', [`Package name "${name}" used in multiple packages:`, ...locations].join('\n\t'));
                }
            }
        }
        this.forEach((currentNode, currentName) => {
            const graphDependencies = graphType === 'dependencies'
                ? Object.assign({}, currentNode.pkg.optionalDependencies, currentNode.pkg.dependencies)
                : Object.assign({}, currentNode.pkg.devDependencies, currentNode.pkg.optionalDependencies, graphType === 'allPlusPeerDependencies' ? currentNode.pkg.peerDependencies : {}, currentNode.pkg.dependencies);
            Object.keys(graphDependencies).forEach((depName) => {
                const depNode = this.get(depName);
                let spec = graphDependencies[depName].replace(/^link:/, 'file:');
                const isWorkspaceSpec = /^workspace:/.test(spec);
                let fullWorkspaceSpec;
                if (isWorkspaceSpec) {
                    fullWorkspaceSpec = spec;
                    spec = spec.replace(/^workspace:/, '');
                    if (spec === '*' || spec === '^' || spec === '~') {
                        const depPkg = packages.find((pkg) => pkg.name === depName);
                        const version = depPkg?.version;
                        const specTarget = spec === '*' ? '' : spec;
                        spec = depPkg ? `${specTarget}${version}` : '';
                    }
                }
                const resolved = npa.resolve(depName, spec, currentNode.location);
                resolved.workspaceSpec = fullWorkspaceSpec;
                if (!depNode) {
                    return currentNode.externalDependencies.set(depName, resolved);
                }
                if (isWorkspaceSpec ||
                    localDependencies === 'force' ||
                    resolved.fetchSpec === depNode.location ||
                    (localDependencies !== 'explicit' && depNode.satisfies(resolved))) {
                    currentNode.localDependencies.set(depName, resolved);
                    depNode.localDependents.set(currentName, currentNode);
                }
                else {
                    currentNode.externalDependencies.set(depName, resolved);
                }
            });
        });
    }
    get rawPackageList() {
        return Array.from(this.values()).map((node) => node.pkg);
    }
    addDependencies(filteredPackages) {
        return this.extendList(filteredPackages, 'localDependencies');
    }
    addDependents(filteredPackages) {
        return this.extendList(filteredPackages, 'localDependents');
    }
    extendList(packageList, nodeProp) {
        const search = new Set(packageList.map(({ name }) => this.get(name)));
        const result = [];
        search.forEach((currentNode) => {
            result.push(currentNode);
            currentNode[nodeProp].forEach((meta, depName) => {
                const depNode = this.get(depName);
                if (depNode && depNode !== currentNode && !search.has(depNode)) {
                    search.add(depNode);
                }
            });
        });
        return result.map((node) => node.pkg);
    }
    collapseCycles(rejectCycles) {
        const cyclePaths = [];
        const nodeToCycle = new Map();
        const cycles = new Set();
        const alreadyVisited = new Set();
        const walkStack = [];
        function visits(baseNode, dependentNode) {
            if (nodeToCycle.has(baseNode)) {
                return;
            }
            let topLevelDependent = dependentNode;
            while (nodeToCycle.has(topLevelDependent)) {
                topLevelDependent = nodeToCycle.get(topLevelDependent);
            }
            const identifier = `${baseNode.name}:${topLevelDependent.name}`;
            if (alreadyVisited.has(identifier)) {
                return;
            }
            alreadyVisited.add(identifier);
            if (topLevelDependent === baseNode || (topLevelDependent.isCycle && topLevelDependent.has(baseNode.name))) {
                const cycle = new CyclicPackageGraphNode();
                walkStack.forEach((nodeInCycle) => {
                    nodeToCycle.set(nodeInCycle, cycle);
                    cycle.insert(nodeInCycle);
                    cycles.delete(nodeInCycle);
                });
                cycles.add(cycle);
                cyclePaths.push(cycle.toString());
                return;
            }
            if (walkStack.indexOf(topLevelDependent) === -1) {
                visitWithStack(baseNode, topLevelDependent);
            }
        }
        function visitWithStack(baseNode, currentNode = baseNode) {
            walkStack.push(currentNode);
            currentNode.localDependents.forEach(visits.bind(null, baseNode));
            walkStack.pop();
        }
        this.forEach((currentNode) => visitWithStack(currentNode));
        cycles.forEach((collapsedNode) => visitWithStack(collapsedNode));
        reportCycles(cyclePaths, rejectCycles);
        return cycles;
    }
    prune(...candidates) {
        if (candidates.length === this.size) {
            return this.clear();
        }
        candidates.forEach((node) => this.remove(node));
    }
    remove(candidateNode) {
        this.delete(candidateNode.name);
        this.forEach((node) => {
            node.localDependencies.delete(candidateNode.name);
            node.localDependents.delete(candidateNode.name);
        });
    }
}
//# sourceMappingURL=package-graph.js.map