import log from 'npmlog';
import runScript from '@npmcli/run-script';
import PQueue from 'p-queue';
import { npmConf } from '../utils/npm-conf.js';
const queue = new PQueue({ concurrency: 1 });
function flattenOptions(obj) {
    return {
        ignorePrepublish: obj['ignore-prepublish'],
        ignoreScripts: obj['ignore-scripts'],
        nodeOptions: obj['node-options'],
        scriptShell: obj['script-shell'],
        scriptsPrependNodePath: obj['scripts-prepend-node-path'],
        ...obj,
    };
}
function printCommandBanner(id, event, cmd, path) {
    return console.log(`\n> ${id ? `${id} ` : ''}${event} ${path}\n> ${cmd.trim().replace(/\n/g, '\n> ')}\n`);
}
export function runLifecycle(pkg, stage, options) {
    if ('root' in options) {
        options = options.snapshot;
    }
    const opts = {
        log,
        unsafePerm: true,
        ...flattenOptions(options),
    };
    const dir = pkg.location;
    const id = `${pkg.name}@${pkg.version}`;
    const config = {};
    if (opts.ignoreScripts) {
        opts.log.verbose('lifecycle', '%j ignored in %j', stage, pkg.name);
        return Promise.resolve();
    }
    if (!pkg.scripts || !pkg.scripts[stage]) {
        opts.log.silly('lifecycle', 'No script for %j in %j, continuing', stage, pkg.name);
        return Promise.resolve();
    }
    if (stage === 'prepublish' && opts.ignorePrepublish) {
        opts.log.verbose('lifecycle', '%j ignored in %j', stage, pkg.name);
        return Promise.resolve();
    }
    for (const [key, val] of Object.entries(opts)) {
        if (val !== null && key !== 'log' && key !== 'logstream') {
            config[key] = val;
        }
    }
    if (pkg.__isLernaPackage) {
        pkg = pkg.toJSON();
    }
    pkg._id = id;
    opts.log.silly('lifecycle', '%j starting in %j', stage, pkg.name);
    opts.log.info('lifecycle', `${id}~${stage}: ${id}`);
    const stdio = opts.stdio || 'pipe';
    if (log.level !== 'silent') {
        printCommandBanner(id, stage, pkg.scripts[stage], dir);
    }
    return queue.add(async () => {
        try {
            const { stdout } = await runScript({
                event: stage,
                path: dir,
                pkg,
                args: [],
                stdio,
                banner: false,
                scriptShell: config.scriptShell,
            });
            if (stdout) {
                console.log(stdout.toString().trimEnd());
            }
            opts.log.silly('lifecycle', '%j finished in %j', stage, pkg.name);
        }
        catch (err) {
            const exitCode = err.code || 1;
            log.error('lifecycle', '%j errored in %j, exiting %d', stage, pkg.name, exitCode);
            err.name = 'ValidationError';
            err.exitCode = exitCode;
            process.exitCode = exitCode;
            throw err;
        }
    });
}
export function createRunner(commandOptions) {
    const cfg = npmConf(commandOptions).snapshot;
    return (pkg, stage) => runLifecycle(pkg, stage, cfg);
}
//# sourceMappingURL=run-lifecycle.js.map