import { cosmiconfigSync, defaultLoaders } from 'cosmiconfig';
import dedent from 'dedent';
import { globbySync } from 'globby';
import globParent from 'glob-parent';
import JSON5 from 'json5';
import log from 'npmlog';
import { writeFileSync } from 'node:fs';
import { basename, dirname, join, normalize, resolve as pathResolve } from 'node:path';
import pMap from 'p-map';
import { loadJsonFile, loadJsonFileSync } from 'load-json-file';
import { writeJsonFile } from 'write-json-file';
import { Package } from '../package.js';
import { applyExtends } from './lib/apply-extends.js';
import { ValidationError } from '../validation-error.js';
import { makeFileFinder, makeSyncFileFinder } from './lib/make-file-finder.js';
export class Project {
    constructor(cwd) {
        let explorer;
        try {
            explorer = cosmiconfigSync('lerna', {
                loaders: {
                    ...defaultLoaders,
                    '.json': this.json5Loader,
                    '.jsonc': this.json5Loader,
                    '.json5': this.json5Loader,
                },
                searchPlaces: ['lerna.json', 'lerna.jsonc', 'lerna.json5', 'package.json'],
                transform(obj) {
                    if (!obj) {
                        return {
                            config: {},
                            configNotFound: true,
                            filepath: pathResolve(cwd || '.', 'lerna.json'),
                        };
                    }
                    obj.config = applyExtends(obj.config, dirname(obj.filepath));
                    return obj;
                },
            });
        }
        catch (err) {
            if (err.name === 'JSONError') {
                throw new ValidationError(err.name, err.message);
            }
            throw err;
        }
        let loaded;
        try {
            loaded = explorer.search(cwd);
        }
        catch (err) {
            if (err.name === 'JSONError') {
                throw new ValidationError(err.name, err.message);
            }
            throw err;
        }
        this.config = loaded?.config;
        this.configNotFound = loaded?.configNotFound;
        this.rootConfigLocation = loaded?.filepath ?? '';
        this.rootPath = dirname(loaded?.filepath ?? '');
        log.verbose('rootPath', this.rootPath);
    }
    static getPackages(cwd) {
        return new Project(cwd).getPackages();
    }
    static getPackagesSync(cwd) {
        return new Project(cwd).getPackagesSync();
    }
    get version() {
        return this.config.version;
    }
    set version(val) {
        this.config.version = val;
    }
    get packageConfigs() {
        if (this.config.useWorkspaces) {
            const workspaces = this.manifest?.get('workspaces');
            if (!workspaces) {
                throw new ValidationError('EWORKSPACES', dedent `
            Yarn workspaces need to be defined in the root package.json.
            See: https://github.com/lerna/lerna/blob/master/commands/bootstrap/README.md#--use-workspaces
          `);
            }
            const workspaceList = (workspaces.packages || workspaces);
            log.verbose('project workspaces packages', workspaceList.join(' '));
            return workspaceList;
        }
        log.verbose('project packages', (this.config.packages || [Project.PACKAGE_GLOB]).join(' '));
        return this.config.packages || [Project.PACKAGE_GLOB];
    }
    get packageParentDirs() {
        return this.packageConfigs.map(globParent).map((parentDir) => pathResolve(this.rootPath, parentDir));
    }
    get manifest() {
        let manifest;
        try {
            const manifestLocation = join(this.rootPath, 'package.json');
            const packageJson = loadJsonFileSync(manifestLocation);
            if (!packageJson.name) {
                packageJson.name = basename(dirname(manifestLocation));
            }
            manifest = new Package(packageJson, this.rootPath);
            Object.defineProperty(this, 'manifest', {
                value: manifest,
            });
        }
        catch (err) {
            if (err.name === 'JSONError') {
                throw new ValidationError(err.name, err.message);
            }
        }
        return manifest;
    }
    get licensePath() {
        let licensePath;
        try {
            const search = globbySync(Project.LICENSE_GLOB, {
                cwd: this.rootPath,
                absolute: true,
                caseSensitiveMatch: false,
                deep: 0,
            });
            licensePath = search.shift();
            if (licensePath) {
                licensePath = normalize(licensePath);
                Object.defineProperty(this, 'licensePath', {
                    value: licensePath,
                });
            }
        }
        catch (err) {
            throw new ValidationError(err.name, err.message);
        }
        return licensePath;
    }
    get fileFinder() {
        const finder = makeFileFinder(this.rootPath, this.packageConfigs);
        Object.defineProperty(this, 'fileFinder', {
            value: finder,
        });
        return finder;
    }
    getPackages() {
        const mapper = (packageConfigPath) => loadJsonFile(packageConfigPath)?.then((packageJson) => new Package(packageJson, dirname(packageConfigPath), this.rootPath));
        return this.fileFinder('package.json', (filePaths) => pMap(filePaths, mapper, { concurrency: 50 }));
    }
    getPackagesSync() {
        return makeSyncFileFinder(this.rootPath, this.packageConfigs)('package.json', (packageConfigPath) => {
            return new Package(loadJsonFileSync(packageConfigPath), dirname(packageConfigPath), this.rootPath);
        });
    }
    getPackageLicensePaths() {
        return this.fileFinder(Project.LICENSE_GLOB, null, { caseSensitiveMatch: false });
    }
    isIndependent() {
        return this.version === 'independent';
    }
    json5Loader(filepath, content) {
        if (!/.*lerna\.json[c|5]?$/gi.test(filepath)) {
            return defaultLoaders['.json'](filepath, content);
        }
        try {
            return JSON5.parse(content);
        }
        catch (err) {
            if (err instanceof Error) {
                err.name = 'JSONError';
                err.message = `Error in: ${filepath}\n${err.message}`;
            }
            throw err;
        }
    }
    serializeConfig() {
        if (this.rootConfigLocation.endsWith('lerna.json5')) {
            return new Promise((resolve) => {
                writeFileSync(this.rootConfigLocation, JSON5.stringify(this.config, { space: 2 }));
                resolve(this.rootConfigLocation);
            });
        }
        else {
            return writeJsonFile(this.rootConfigLocation, this.config, { indent: 2, detectIndent: true }).then(() => this.rootConfigLocation);
        }
    }
}
Project.PACKAGE_GLOB = 'packages/*';
Project.LICENSE_GLOB = 'LICEN{S,C}E{,.*}';
Project.PACKAGE_GLOB = 'packages/*';
Project.LICENSE_GLOB = 'LICEN{S,C}E{,.*}';
//# sourceMappingURL=project.js.map