import assert from 'node:assert';
import { readFileSync, statSync } from 'node:fs';
import { resolve as pathResolve } from 'node:path';
import { ConfigChain } from 'config-chain';
import { envReplace } from './env-replace.js';
import { findPrefix } from './find-prefix.js';
import { parseField } from './parse-field.js';
import { toNerfDart } from './nerf-dart.js';
export class Conf extends ConfigChain {
    constructor(base) {
        super(base);
        this.globalPrefix = '';
        this.localPrefix = '';
        this.root = base;
    }
    add(data, marker) {
        try {
            for (const x of Object.keys(data)) {
                const newKey = envReplace(x);
                const newField = parseField(data[x], newKey);
                delete data[x];
                data[newKey] = newField;
            }
        }
        catch (err) {
            throw err;
        }
        return super.add(data, marker);
    }
    addFile(file, name = file) {
        const marker = { __source__: name };
        this.sources[name] = { path: file, type: 'ini' };
        this.push(marker);
        this._await();
        try {
            const contents = readFileSync(file, 'utf8');
            this.addString(contents, file, 'ini', marker);
        }
        catch (err) {
            this.add({}, marker);
        }
        return this;
    }
    addEnv(env = process.env) {
        const conf = {};
        Object.keys(env)
            .filter((x) => /^npm_config_/i.test(x))
            .forEach((x) => {
            if (!env[x]) {
                return;
            }
            const p = x
                .toLowerCase()
                .replace(/^npm_config_/, '')
                .replace(/(?!^)_/g, '-');
            conf[p] = env[x];
        });
        return super.addEnv('', conf, 'env');
    }
    loadPrefix() {
        const cli = this.list[0];
        Object.defineProperty(this, 'prefix', {
            enumerable: true,
            set: (prefix) => {
                const g = this.get('global');
                this[g ? 'globalPrefix' : 'localPrefix'] = prefix;
            },
            get: () => {
                const g = this.get('global');
                return g ? this.globalPrefix : this.localPrefix;
            },
        });
        Object.defineProperty(this, 'globalPrefix', {
            enumerable: true,
            set: (prefix) => {
                this.set('prefix', prefix);
            },
            get: () => pathResolve(this.get('prefix')),
        });
        let p;
        Object.defineProperty(this, 'localPrefix', {
            enumerable: true,
            set: (prefix) => {
                p = prefix;
            },
            get: () => p,
        });
        if (Object.prototype.hasOwnProperty.call(cli, 'prefix')) {
            p = pathResolve(cli.prefix);
        }
        else {
            try {
                p = findPrefix(process.cwd());
            }
            catch (err) {
                throw err;
            }
        }
        return p;
    }
    loadCAFile(file) {
        if (!file) {
            return;
        }
        try {
            const contents = readFileSync(file, 'utf8');
            const delim = '-----END CERTIFICATE-----';
            const output = contents
                .split(delim)
                .filter((x) => Boolean(x.trim()))
                .map((x) => x.trimLeft() + delim);
            this.set('ca', output);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return;
            }
            throw err;
        }
    }
    loadUser() {
        const defConf = this.root;
        if (this.get('global')) {
            return;
        }
        if (process.env.SUDO_UID) {
            defConf.user = Number(process.env.SUDO_UID);
            return;
        }
        const prefix = pathResolve(this.get('prefix'));
        try {
            const stats = statSync(prefix);
            defConf.user = stats.uid;
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return;
            }
            throw err;
        }
    }
    getCredentialsByURI(uri) {
        assert(uri && typeof uri === 'string', 'registry URL is required');
        const nerfed = toNerfDart(uri);
        const defnerf = toNerfDart(this.get('registry'));
        const c = {
            scope: nerfed,
            token: undefined,
            password: undefined,
            username: undefined,
            email: undefined,
            auth: undefined,
            alwaysAuth: undefined,
        };
        if (this.get(`${nerfed}:always-auth`) !== undefined) {
            const val = this.get(`${nerfed}:always-auth`);
            c.alwaysAuth = val === 'false' ? false : !!val;
        }
        else if (this.get('always-auth') !== undefined) {
            c.alwaysAuth = this.get('always-auth');
        }
        if (this.get(`${nerfed}:_authToken`)) {
            c.token = this.get(`${nerfed}:_authToken`);
            return c;
        }
        let authDef = this.get('_auth');
        let userDef = this.get('username');
        let passDef = this.get('_password');
        if (authDef && !(userDef && passDef)) {
            authDef = Buffer.from(authDef, 'base64').toString();
            authDef = authDef.split(':');
            userDef = authDef.shift();
            passDef = authDef.join(':');
        }
        if (this.get(`${nerfed}:_password`)) {
            c.password = Buffer.from(this.get(`${nerfed}:_password`), 'base64').toString('utf8');
        }
        else if (nerfed === defnerf && passDef) {
            c.password = passDef;
        }
        if (this.get(`${nerfed}:username`)) {
            c.username = this.get(`${nerfed}:username`);
        }
        else if (nerfed === defnerf && userDef) {
            c.username = userDef;
        }
        if (this.get(`${nerfed}:email`)) {
            c.email = this.get(`${nerfed}:email`);
        }
        else if (this.get('email')) {
            c.email = this.get('email');
        }
        if (c.username && c.password) {
            c.auth = Buffer.from(`${c.username}:${c.password}`).toString('base64');
        }
        return c;
    }
    setCredentialsByURI(uri, c) {
        assert(uri && typeof uri === 'string', 'registry URL is required');
        assert(c && typeof c === 'object', 'credentials are required');
        const nerfed = toNerfDart(uri);
        if (c.token) {
            this.set(`${nerfed}:_authToken`, c.token, 'user');
            this.del(`${nerfed}:_password`, 'user');
            this.del(`${nerfed}:username`, 'user');
            this.del(`${nerfed}:email`, 'user');
            this.del(`${nerfed}:always-auth`, 'user');
        }
        else if (c.username || c.password || c.email) {
            assert(c.username, 'must include username');
            assert(c.password, 'must include password');
            assert(c.email, 'must include email address');
            this.del(`${nerfed}:_authToken`, 'user');
            const encoded = Buffer.from(c.password, 'utf8').toString('base64');
            this.set(`${nerfed}:_password`, encoded, 'user');
            this.set(`${nerfed}:username`, c.username, 'user');
            this.set(`${nerfed}:email`, c.email, 'user');
            if (c.alwaysAuth !== undefined) {
                this.set(`${nerfed}:always-auth`, c.alwaysAuth, 'user');
            }
            else {
                this.del(`${nerfed}:always-auth`, 'user');
            }
        }
        else {
            throw new Error('No credentials to set.');
        }
    }
}
//# sourceMappingURL=conf.js.map