import 'dotenv/config';
import chalk from 'chalk';
import pMap from 'p-map';
import { Command, logOutput, runTopologically, spawn, spawnStreaming, ValidationError, } from '@lerna-lite/core';
import { getFilteredPackages } from '@lerna-lite/filter-packages';
import { Profiler } from '@lerna-lite/profiler';
export function factory(argv) {
    return new ExecCommand(argv);
}
export class ExecCommand extends Command {
    get requiresGit() {
        return false;
    }
    constructor(argv) {
        super(argv);
        this.name = 'exec';
        this.args = [];
        this.bail = false;
        this.env = {};
        this.filteredPackages = [];
        this.prefix = false;
        this.command = '';
    }
    initialize() {
        const dashedArgs = this.options['--'] || [];
        this.command = this.options.cmd || dashedArgs.shift();
        this.args = (this.options.args || []).concat(dashedArgs);
        if (!this.command) {
            throw new ValidationError('ENOCOMMAND', 'A command to execute is required');
        }
        this.bail = this.options.bail !== false;
        this.prefix = this.options.prefix !== false;
        this.env = Object.assign({}, process.env);
        let chain = Promise.resolve();
        this.options.isIndependent = this.project.isIndependent();
        chain = chain.then(() => getFilteredPackages(this.packageGraph, this.execOpts, this.options));
        chain = chain.then((filteredPackages) => {
            this.filteredPackages = filteredPackages;
        });
        return chain.then(() => {
            this.count = this.filteredPackages.length;
            this.packagePlural = this.count === 1 ? 'package' : 'packages';
            this.joinedCommand = [this.command].concat(this.args).join(' ');
        });
    }
    execute() {
        this.logger.info('', 'Executing command in %d %s: %j', this.count, this.packagePlural, this.joinedCommand);
        let chain = Promise.resolve();
        if (this.options.parallel) {
            chain = chain.then(() => this.runCommandInPackagesParallel());
        }
        else if (this.toposort) {
            chain = chain.then(() => this.runCommandInPackagesTopological());
        }
        else {
            chain = chain.then(() => this.runCommandInPackagesLexical());
        }
        if (this.bail) {
            chain = chain.catch((err) => {
                process.exitCode = err.exitCode;
                throw err;
            });
        }
        else {
            chain = chain.then((results) => {
                if (results.some((result) => result.failed)) {
                    const codes = results.filter((result) => result.failed).map((result) => result.exitCode);
                    const exitCode = Math.max(...codes, 1);
                    this.logger.error('', 'Received non-zero exit code %d during execution', exitCode);
                    process.exitCode = exitCode;
                }
            });
        }
        return chain.then(() => {
            this.logger.success('exec', 'Executed command in %d %s: %j', this.count, this.packagePlural, this.joinedCommand);
        });
    }
    getOpts(pkg) {
        return {
            cwd: pkg.location,
            shell: true,
            extendEnv: false,
            env: Object.assign({}, this.env, {
                LERNA_PACKAGE_NAME: pkg.name,
                LERNA_ROOT_PATH: this.project.rootPath,
            }),
            reject: this.bail,
            pkg,
        };
    }
    getRunner() {
        return this.options.stream
            ? (pkg) => this.runCommandInPackageStreaming(pkg)
            : (pkg) => this.runCommandInPackageCapturing(pkg);
    }
    runCommandInPackagesTopological() {
        let profiler;
        let runner;
        if (this.options.profile) {
            profiler = new Profiler({
                concurrency: this.concurrency,
                log: this.logger,
                outputDirectory: this.options.profileLocation || this.project.rootPath,
            });
            const callback = this.getRunner();
            runner = (pkg) => profiler.run(() => callback(pkg), pkg.name);
        }
        else {
            runner = this.getRunner();
        }
        let chain = runTopologically(this.filteredPackages, runner, {
            concurrency: this.concurrency,
            rejectCycles: this.options.rejectCycles,
        });
        if (profiler) {
            chain = chain.then((results) => profiler.output().then(() => results));
        }
        return chain;
    }
    runCommandInPackagesParallel() {
        return pMap(this.filteredPackages, (pkg) => this.runCommandInPackageStreaming(pkg));
    }
    runCommandInPackagesLexical() {
        return pMap(this.filteredPackages, this.getRunner(), { concurrency: this.concurrency });
    }
    runCommandInPackageStreaming(pkg) {
        if (this.options.dryRun) {
            return this.dryRunExec(this.command, pkg.name);
        }
        return spawnStreaming(this.command, this.args, this.getOpts(pkg), this.prefix && pkg.name);
    }
    runCommandInPackageCapturing(pkg) {
        if (this.options.dryRun) {
            return this.dryRunExec(this.command, pkg.name);
        }
        return spawn(this.command, this.args, this.getOpts(pkg));
    }
    dryRunExec(commandName, pkgName) {
        this.logger.info(chalk.bold.magenta('[dry-run] >'), `Exec command '%s' in '%s'`, commandName, pkgName);
        logOutput(`${chalk.bold.magenta('[dry-run] >')} ${pkgName}`);
        return Promise.resolve();
    }
}
//# sourceMappingURL=exec-command.js.map