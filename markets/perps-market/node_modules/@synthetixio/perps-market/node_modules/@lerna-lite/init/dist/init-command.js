import { Command, exec } from '@lerna-lite/core';
import { mkdirp } from 'fs-extra/esm';
import { join } from 'node:path';
import pMap from 'p-map';
import { writeJsonFile } from 'write-json-file';
const LERNA_CLI_PKG_NAME = '@lerna-lite/cli';
export function factory(argv) {
    return new InitCommand(argv);
}
export class InitCommand extends Command {
    constructor(argv) {
        super(argv);
        this.name = 'init';
        this.exact = false;
        this.lernaVersion = '';
    }
    get requiresGit() {
        return false;
    }
    runValidations() {
        this.logger.verbose(this.name, 'skipping validations');
    }
    runPreparations() {
        this.logger.verbose(this.name, 'skipping preparations');
    }
    initialize() {
        this.exact = this.options.exact;
        this.lernaVersion = this.options.lernaVersion;
        if (!this.gitInitialized()) {
            this.logger.info('', 'Initializing Git repository');
            return exec('git', ['init'], this.execOpts);
        }
    }
    async execute() {
        await this.ensurePackageJSON();
        await this.ensureLernaConfig();
        await this.ensurePackagesDir();
        this.logger.success('', 'Initialized Lerna files');
    }
    async ensurePackageJSON() {
        if (!this.project.manifest) {
            this.logger.info('', 'Creating package.json');
            await writeJsonFile(join(this.project.rootPath, 'package.json'), { name: 'root', private: true }, { indent: 2 });
        }
        else {
            this.logger.info('', 'Updating package.json');
        }
        const rootPkg = this.project.manifest;
        let targetDependencies;
        if (rootPkg.dependencies?.[LERNA_CLI_PKG_NAME]) {
            targetDependencies = rootPkg.dependencies;
        }
        else {
            if (!rootPkg.devDependencies) {
                rootPkg.set('devDependencies', {});
            }
            targetDependencies = rootPkg.devDependencies;
        }
        targetDependencies[LERNA_CLI_PKG_NAME] = this.exact ? this.lernaVersion : `^${this.lernaVersion}`;
        if (this.options.useWorkspaces && !rootPkg.workspaces) {
            rootPkg.workspaces = ['packages/*'];
        }
        return rootPkg.serialize();
    }
    ensureLernaConfig() {
        const { config, version: projectVersion } = this.project;
        let version;
        if (this.options.independent) {
            version = 'independent';
        }
        else if (projectVersion) {
            version = projectVersion;
        }
        else {
            version = '0.0.0';
        }
        const logMessage = !projectVersion ? 'Creating lerna.json' : 'Updating lerna.json';
        this.logger.info('', logMessage);
        delete config[LERNA_CLI_PKG_NAME];
        if (this.exact) {
            const commandConfig = config.command || (config.command = {});
            const initConfig = commandConfig.init || (commandConfig.init = {});
            initConfig.exact = true;
        }
        const lernaConfig = {
            $schema: 'node_modules/@lerna-lite/cli/schemas/lerna-schema.json',
            version,
        };
        if (this.options.useWorkspaces) {
            lernaConfig.useWorkspaces = true;
        }
        else {
            lernaConfig.packages = ['packages/*'];
        }
        Object.assign(config, lernaConfig);
        return this.project.serializeConfig();
    }
    ensurePackagesDir() {
        this.logger.info('', 'Creating packages directory');
        return pMap(this.project.packageParentDirs, (dir) => mkdirp(dir));
    }
}
//# sourceMappingURL=init-command.js.map