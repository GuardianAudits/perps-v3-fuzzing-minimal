import { outputJson } from 'fs-extra/esm';
import npmlog from 'npmlog';
import upath from 'upath';
const getTimeBasedFilename = () => {
    const now = new Date();
    const datetime = now.toISOString().split('.')[0];
    const datetimeNormalized = datetime.replace(/-|:/g, '');
    return `Lerna-Profile-${datetimeNormalized}.json`;
};
const hrtimeToMicroseconds = (hrtime) => {
    return (hrtime[0] * 1e9 + hrtime[1]) / 1000;
};
const range = (len) => {
    return (Array(len)
        .fill()
        .map((_, idx) => idx));
};
export class Profiler {
    constructor({ concurrency, log = npmlog, outputDirectory }) {
        this.events = [];
        this.events = [];
        this.logger = log;
        this.outputPath = upath.join(upath.resolve(outputDirectory || '.'), getTimeBasedFilename());
        this.threads = range(concurrency);
    }
    run(fn, name) {
        let startTime;
        let threadId;
        return Promise.resolve()
            .then(() => {
            startTime = process.hrtime();
            threadId = this.threads.shift();
        })
            .then(() => fn())
            .then((value) => {
            const duration = process.hrtime(startTime);
            const event = {
                name,
                ph: 'X',
                ts: hrtimeToMicroseconds(startTime),
                pid: 1,
                tid: threadId,
                dur: hrtimeToMicroseconds(duration),
            };
            this.events.push(event);
            this.threads.unshift(threadId);
            this.threads.sort();
            return value;
        });
    }
    output() {
        return outputJson(this.outputPath, this.events).then(() => this.logger.info('profiler', `Performance profile saved to ${this.outputPath}`));
    }
}
//# sourceMappingURL=profiler.js.map