import { Package, runLifecycle } from '@lerna-lite/core';
import { tempWrite } from '@lerna-lite/version';
import Arborist from '@npmcli/arborist';
import packlist from 'npm-packlist';
import log from 'npmlog';
import { relative } from 'node:path';
import tar from 'tar';
import { getPacked } from './get-packed.js';
export async function packDirectory(_pkg, dir, options) {
    const pkg = Package.lazy(_pkg, dir);
    const opts = {
        log,
        ...options,
    };
    opts.log.verbose('pack-directory', relative('.', pkg.contents));
    if (opts.ignorePrepublish !== true) {
        await runLifecycle(pkg, 'prepublish', opts);
    }
    await runLifecycle(pkg, 'prepare', opts);
    if (opts.lernaCommand === 'publish') {
        opts.stdio = 'inherit';
        await pkg.refresh();
        await runLifecycle(pkg, 'prepublishOnly', opts);
        await pkg.refresh();
    }
    await runLifecycle(pkg, 'prepack', opts);
    await pkg.refresh();
    const arborist = new Arborist({ path: pkg.contents });
    const tree = await arborist.loadActual();
    const files = await packlist(tree);
    const stream = tar.create({
        cwd: pkg.contents,
        prefix: 'package/',
        portable: true,
        mtime: new Date('1985-10-26T08:15:00.000Z'),
        gzip: true,
    }, files.map((f) => `./${f}`));
    const tarFilePath = await tempWrite(stream, getTarballName(pkg));
    return getPacked(pkg, tarFilePath).then((packed) => Promise.resolve()
        .then(() => runLifecycle(pkg, 'postpack', opts))
        .then(() => packed));
}
function getTarballName(pkg) {
    const name = pkg.name[0] === '@'
        ?
            pkg.name.substring(1).replace(/\//g, '-')
        : pkg.name;
    return `${name}-${pkg.version}.tgz`;
}
//# sourceMappingURL=pack-directory.js.map