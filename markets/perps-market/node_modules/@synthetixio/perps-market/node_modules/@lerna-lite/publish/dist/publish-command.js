import chalk from 'chalk';
import { glob } from 'glob';
import { outputFileSync, removeSync } from 'fs-extra/esm';
import { EOL } from 'node:os';
import { join, relative } from 'node:path';
import crypto from 'crypto';
import normalizePath from 'normalize-path';
import pMap from 'p-map';
import pPipe from 'p-pipe';
import semver from 'semver';
import tempDir from 'temp-dir';
import { getOneTimePassword, VersionCommand } from '@lerna-lite/version';
import { collectUpdates, Command, createRunner, deleteComplexObjectProp, describeRef, excludeValuesFromArray, logOutput, npmConf, prereleaseIdFromVersion, promptConfirmation, pulseTillDone, runTopologically, throwIfUncommitted, ValidationError, } from '@lerna-lite/core';
import { getCurrentTags } from './lib/get-current-tags.js';
import { getTaggedPackages } from './lib/get-tagged-packages.js';
import { getUnpublishedPackages } from './lib/get-unpublished-packages.js';
import { getNpmUsername } from './lib/get-npm-username.js';
import { verifyNpmPackageAccess } from './lib/verify-npm-package-access.js';
import { getTwoFactorAuthRequired } from './lib/get-two-factor-auth-required.js';
import { getCurrentSHA } from './lib/get-current-sha.js';
import { gitCheckout } from './lib/git-checkout.js';
import { packDirectory } from './lib/pack-directory.js';
import { npmPublish } from './lib/npm-publish.js';
import { logPacked } from './lib/log-packed.js';
import { add, remove } from './lib/npm-dist-tag.js';
import { overridePublishConfig } from './lib/override-publish-config.js';
import { removeTempLicenses } from './lib/remove-temp-licenses.js';
import { createTempLicenses } from './lib/create-temp-licenses.js';
import { getPackagesWithoutLicense } from './lib/get-packages-without-license.js';
import { isNpmJsPublishVersionConflict } from './lib/is-npm-js-publish-version-conflict.js';
import { isNpmPkgGitHubPublishVersionConflict } from './lib/is-npm-pkg-github-publish-version-conflict.js';
export function factory(argv) {
    return new PublishCommand(argv);
}
export class PublishCommand extends Command {
    get otherCommandConfigs() {
        return ['version'];
    }
    get requiresGit() {
        return this.options.bump !== 'from-package';
    }
    constructor(argv) {
        super(argv);
        this.name = 'publish';
        this.gitReset = false;
        this.savePrefix = '';
        this.tagPrefix = '';
        this.hasRootedLeaf = false;
        this.npmSession = '';
        this.packagesToPublish = [];
        this.publishedPackages = [];
        this.packagesToBeLicensed = [];
        this.verifyAccess = false;
        this.toposort = false;
        this.twoFactorAuthRequired = false;
        this.updates = [];
        this.uniqueProvenanceUrls = new Set();
    }
    configureProperties() {
        super.configureProperties();
        this.toposort = this.options.sort !== false;
        const { exact, gitHead, gitReset, tagVersionPrefix = 'v', verifyAccess, } = this.options;
        if (this.requiresGit && gitHead) {
            throw new ValidationError('EGITHEAD', '--git-head is only allowed with "from-package" positional');
        }
        this.savePrefix = exact ? '' : '^';
        this.tagPrefix = tagVersionPrefix;
        this.gitReset = gitReset !== false;
        this.npmSession = crypto.randomBytes(8).toString('hex');
        this.verifyAccess = verifyAccess;
    }
    get userAgent() {
        return `lerna/${this.options.lernaVersion}/node@${process.version}+${process.arch} (${process.platform})`;
    }
    initialize() {
        if (this.options.verifyAccess === false) {
            this.logger.warn('verify-access', '--verify-access=false and --no-verify-access are no longer needed, because the legacy preemptive access verification is now disabled by default. Requests will fail with appropriate errors when not authorized correctly.');
        }
        if (this.options.graphType === 'dependencies') {
            this.logger.warn('graph-type', '--graph-type=dependencies is deprecated and will be removed in the next major version of lerna-lite. If you have a use-case you feel requires it please open an issue to discuss: https://github.com/lerna/lerna/issues/new/choose');
        }
        if (this.options.buildMetadata && this.options.canary) {
            throw new ValidationError('ENOTSATISFIED', 'Cannot use --build-metadata in conjunction with --canary option.');
        }
        else if (this.options.canary) {
            this.logger.info('canary', 'enabled');
        }
        this.logger.verbose('session', this.npmSession);
        this.logger.verbose('user-agent', this.userAgent);
        this.conf = npmConf({
            lernaCommand: 'publish',
            _auth: this.options.legacyAuth,
            npmSession: this.npmSession,
            npmVersion: this.userAgent,
            otp: this.options.otp,
            registry: this.options.registry,
            'ignore-prepublish': this.options.ignorePrepublish,
            'ignore-scripts': this.options.ignoreScripts,
        });
        this.otpCache = { otp: this.conf.get('otp') };
        this.conf.set('user-agent', this.userAgent, 'cli');
        if (this.conf.get('registry') === 'https://registry.yarnpkg.com') {
            this.logger.warn('', `Yarn's registry proxy is broken, replacing with public npm registry`);
            this.logger.warn('', `If you don't have an npm token, you should exit and run "npm login"`);
            this.conf.set('registry', 'https://registry.npmjs.org/', 'cli');
        }
        const distTag = this.getDistTag();
        if (distTag) {
            this.conf.set('tag', distTag.trim(), 'cli');
        }
        this.hasRootedLeaf = this.packageGraph.has(this.project.manifest.name);
        if (this.hasRootedLeaf) {
            this.logger.info('publish', 'rooted leaf detected, skipping synthetic root lifecycles');
        }
        this.runPackageLifecycle = createRunner(this.options);
        this.runRootLifecycle = /^(pre|post)?publish$/.test(process.env.npm_lifecycle_event || '')
            ? (stage) => this.logger.warn('lifecycle', 'Skipping root %j because it has already been called', stage)
            : (stage) => this.runPackageLifecycle(this.project.manifest, stage);
        let chain = Promise.resolve();
        if (this.options.bump === 'from-git') {
            chain = chain.then(() => this.detectFromGit());
        }
        else if (this.options.bump === 'from-package') {
            chain = chain.then(() => this.detectFromPackage());
        }
        else if (this.options.canary) {
            chain = chain.then(() => this.detectCanaryVersions());
        }
        else {
            chain = chain.then(() => new VersionCommand(this.argv));
        }
        return chain.then((result) => {
            if (!result) {
                return false;
            }
            if (!result.updates.length) {
                this.logger.success('No changed packages to publish');
                return false;
            }
            this.updates = result.updates.filter((node) => !node.pkg.private);
            this.updatesVersions = new Map(result.updatesVersions);
            this.packagesToPublish = this.updates.map((node) => node.pkg);
            if (this.options.contents) {
                for (const pkg of this.packagesToPublish) {
                    pkg.contents = this.options.contents;
                }
            }
            if (result.needsConfirmation) {
                return this.confirmPublish();
            }
            return true;
        });
    }
    async execute() {
        const logPrefix = this.options.dryRun ? chalk.bgMagenta('[dry-run]') : '';
        this.enableProgressBar();
        this.logger.info('publish', `Publishing packages to npm... ${logPrefix}`);
        await this.prepareRegistryActions();
        await this.prepareLicenseActions();
        if (this.options.canary) {
            await this.updateCanaryVersions();
        }
        await this.resolveLocalDependencyLinks();
        await this.resolveLocalDependencyWorkspaceProtocols();
        if (this.options.removePackageFields) {
            await this.removePackageProperties();
        }
        if (this.options.publishConfigOverrides !== false) {
            await this.applyPublishConfigOverrides();
        }
        await this.annotateGitHead();
        await this.serializeChanges();
        await this.packUpdated();
        await this.publishPacked();
        if (this.gitReset) {
            await this.resetChanges();
        }
        if (this.options.tempTag) {
            await this.npmUpdateAsLatest();
        }
        const count = this.publishedPackages?.length;
        const publishedPackagesSorted = this.publishedPackages.sort((a, b) => a.name.localeCompare(b.name));
        if (!count) {
            this.logger.success('All packages have already been published.');
            return;
        }
        logOutput(`Successfully published: ${logPrefix}`);
        if (this.options.summaryFile !== undefined) {
            const filePath = this.options.summaryFile
                ? `${this.options.summaryFile}/lerna-publish-summary.json`
                : './lerna-publish-summary.json';
            const jsonObject = publishedPackagesSorted.map((pkg) => {
                return {
                    packageName: pkg.name,
                    version: pkg.version,
                };
            });
            logOutput(jsonObject);
            try {
                outputFileSync(filePath, JSON.stringify(jsonObject));
                logOutput('Publish summary created: ', filePath);
            }
            catch (error) {
                logOutput('Failed to create the summary report', error);
            }
        }
        else {
            const message = publishedPackagesSorted.map((pkg) => ` - ${pkg.name}@${pkg.version}`);
            logOutput(message.join(EOL));
        }
        if (this.options.cleanupTempFiles) {
            glob(normalizePath(join(tempDir, '/lerna-*'))).then((deleteFolders) => {
                deleteFolders.forEach((folder) => removeSync(folder));
                this.logger.verbose('publish', `Found ${deleteFolders.length} temp folders to cleanup after publish.`);
            });
        }
        this.logger.success('published', `%d %s ${logPrefix}`, count, count === 1 ? 'package' : 'packages');
        if (this.uniqueProvenanceUrls.size > 0) {
            logOutput('The following provenance transparency log entries were created during publishing:');
            const message = Array.from(this.uniqueProvenanceUrls).map((url) => ` - ${url}`);
            logOutput(message.join(EOL));
        }
    }
    verifyWorkingTreeClean() {
        return describeRef(this.execOpts, undefined, this.options.dryRun).then(throwIfUncommitted);
    }
    detectFromGit() {
        const matchingPattern = this.project.isIndependent() ? `*@*` : `${this.tagPrefix}*.*.*`;
        let chain = Promise.resolve();
        chain = chain.then(() => this.verifyWorkingTreeClean());
        chain = chain.then(() => getCurrentTags(this.execOpts, matchingPattern));
        chain = chain.then((taggedPackageNames) => {
            if (!taggedPackageNames.length) {
                this.logger.notice('from-git', 'No tagged release found. You might not have fetched tags.');
                return [];
            }
            if (this.project.isIndependent()) {
                return taggedPackageNames.map((name) => this.packageGraph.get(name));
            }
            return getTaggedPackages(this.packageGraph, this.project.rootPath, this.execOpts);
        });
        chain = chain.then((updates) => updates.filter((node) => !node.pkg.private));
        return chain.then((updates) => {
            const updatesVersions = updates.map((node) => [node.name, node.version]);
            return {
                updates,
                updatesVersions,
                needsConfirmation: true,
            };
        });
    }
    detectFromPackage() {
        let chain = Promise.resolve();
        chain = chain
            .then(() => this.verifyWorkingTreeClean())
            .catch((err) => {
            if (err.failed && /git describe/.test(err.command)) {
                this.logger.silly('EWORKINGTREE', err.message);
                this.logger.notice('FYI', 'Unable to verify working tree, proceed at your own risk');
                process.exitCode = 0;
            }
            else {
                throw err;
            }
        });
        chain = chain.then(() => getUnpublishedPackages(this.packageGraph, this.conf.snapshot));
        chain = chain.then((unpublished) => {
            if (!unpublished.length) {
                this.logger.notice('from-package', 'No unpublished release found');
            }
            return unpublished;
        });
        return chain.then((updates) => {
            const updatesVersions = updates.map((node) => [node.name, node.version]);
            return {
                updates,
                updatesVersions,
                needsConfirmation: true,
            };
        });
    }
    detectCanaryVersions() {
        const { cwd } = this.execOpts;
        const { bump = 'prepatch', preid = 'alpha', ignoreChanges, forcePublish, includeMergedTags } = this.options;
        const release = bump.startsWith('pre') ? bump.replace('release', 'patch') : `pre${bump}`;
        let chain = Promise.resolve();
        chain = chain
            .then(() => this.verifyWorkingTreeClean())
            .catch((err) => {
            if (err.failed && /git describe/.test(err.command)) {
                this.logger.silly('EWORKINGTREE', err.message);
                this.logger.notice('FYI', 'Unable to verify working tree, proceed at your own risk');
            }
            else {
                throw err;
            }
        });
        const isIndependent = this.project.isIndependent();
        const describeTag = this.project.config.describeTag;
        chain = chain.then(() => collectUpdates(this.packageGraph?.rawPackageList ?? [], this.packageGraph, this.execOpts, {
            bump: 'prerelease',
            canary: true,
            ignoreChanges,
            forcePublish,
            includeMergedTags,
            isIndependent,
            describeTag,
        }).filter((node) => !node.pkg.private));
        const makeVersion = (fallback) => ({ lastVersion = fallback, refCount, sha }) => {
            const nextVersion = semver.inc(lastVersion.replace(this.tagPrefix, ''), release.replace('pre', ''));
            return `${nextVersion}-${preid}.${Math.max(0, refCount - 1)}+${sha}`;
        };
        if (isIndependent) {
            chain = chain.then((updates) => pMap(updates, (node) => describeRef({
                match: `${node.name}@*`,
                cwd,
            }, includeMergedTags)
                .then(makeVersion(node.version))
                .then((version) => [node.name, version])).then((updatesVersions) => ({
                updates,
                updatesVersions,
            })));
        }
        else {
            chain = chain.then((updates) => describeRef({
                match: `${this.tagPrefix}*.*.*`,
                cwd,
            }, includeMergedTags)
                .then(makeVersion(this.project.version))
                .then((version) => updates.map((node) => [node.name, version]))
                .then((updatesVersions) => ({
                updates,
                updatesVersions,
            })));
        }
        return chain.then(({ updates, updatesVersions }) => ({
            updates,
            updatesVersions,
            needsConfirmation: true,
        }));
    }
    confirmPublish() {
        const logPrefix = this.options.dryRun ? chalk.bgMagenta('[dry-run]') : '';
        const count = this.packagesToPublish?.length;
        const message = this.packagesToPublish?.map((pkg) => ` - ${pkg.name} => ${this.updatesVersions?.get(pkg.name)}`) ?? [];
        logOutput('');
        logOutput(`Found ${count} ${count === 1 ? 'package' : 'packages'} to publish: ${logPrefix}`);
        logOutput(message.join(EOL));
        logOutput('');
        if (this.options.yes) {
            this.logger.info('auto-confirmed', '');
            return true;
        }
        let confirmMessage = this.options.dryRun ? chalk.bgMagenta('[dry-run]') : '';
        confirmMessage += ' Are you sure you want to publish these packages?';
        return promptConfirmation(confirmMessage.trim());
    }
    prepareLicenseActions() {
        return Promise.resolve()
            .then(() => getPackagesWithoutLicense(this.project, this.packagesToPublish ?? []))
            .then((packagesWithoutLicense) => {
            if (packagesWithoutLicense.length && !this.project.licensePath) {
                this.packagesToBeLicensed = [];
                const names = packagesWithoutLicense.map((pkg) => pkg.name);
                const noun = names.length > 1 ? 'Packages' : 'Package';
                const verb = names.length > 1 ? 'are' : 'is';
                const list = names.length > 1
                    ? `${names.slice(0, -1).join(', ')}${names.length > 2 ? ',' : ''} and ${names[names.length - 1]}`
                    : names[0];
                this.logger.warn('ENOLICENSE', '%s %s %s missing a license.\n%s\n%s', noun, list, verb, 'One way to fix this is to add a LICENSE.md file to the root of this repository.', 'See https://choosealicense.com for additional guidance.');
            }
            else {
                this.packagesToBeLicensed = packagesWithoutLicense;
            }
        });
    }
    prepareRegistryActions() {
        let chain = Promise.resolve();
        if (this.conf.get('registry') !== 'https://registry.npmjs.org/') {
            this.logger.notice('', 'Skipping all user and access validation due to third-party registry');
            this.logger.notice('', `Make sure you're authenticated properly "\\_(ツ)_ /"`);
            return chain;
        }
        if (process.env.LERNA_INTEGRATION) {
            return chain;
        }
        if (this.verifyAccess) {
            chain = chain.then(() => getNpmUsername(this.conf.snapshot));
            chain = chain.then((username) => {
                if (username) {
                    return verifyNpmPackageAccess(this.packagesToPublish ?? [], username, this.conf.snapshot);
                }
            });
            chain = chain.then(() => getTwoFactorAuthRequired(this.conf.snapshot));
            chain = chain.then((isRequired) => {
                this.twoFactorAuthRequired = isRequired;
            });
        }
        return chain;
    }
    updateCanaryVersions() {
        return pMap(this.updates, (node) => {
            node.pkg.set('version', this.updatesVersions?.get(node.name));
            for (const [depName, resolved] of node.localDependencies) {
                const depVersion = this.updatesVersions?.get(depName) || this.packageGraph?.get(depName).pkg.version;
                node.pkg.updateLocalDependency(resolved, depVersion, this.savePrefix, this.options.allowPeerDependenciesUpdate, this.commandName);
            }
        });
    }
    applyPublishConfigOverrides() {
        return pMap(this.updates, (node) => overridePublishConfig(node.pkg.manifest));
    }
    resolveLocalDependencyLinks() {
        const updatesWithLocalLinks = this.updates.filter((node) => Array.from(node.localDependencies.values()).some((resolved) => resolved.type === 'directory'));
        return pMap(updatesWithLocalLinks, (node) => {
            for (const [depName, resolved] of node.localDependencies) {
                const depVersion = this.updatesVersions?.get(depName) || this.packageGraph?.get(depName).pkg.version;
                node.pkg.updateLocalDependency(resolved, depVersion, this.savePrefix, this.options.allowPeerDependenciesUpdate, this.commandName);
            }
        });
    }
    resolveLocalDependencyWorkspaceProtocols() {
        const publishingPackagesWithLocalWorkspaces = this.updates.filter((node) => Array.from(node.localDependencies.values()).some((resolved) => resolved.workspaceSpec));
        return pMap(publishingPackagesWithLocalWorkspaces, (node) => {
            for (const [depName, resolved] of node.localDependencies) {
                const depVersion = this.updatesVersions?.get(depName) || this.packageGraph?.get(depName).pkg.version;
                node.pkg.updateLocalDependency(resolved, depVersion, this.savePrefix, this.options.allowPeerDependenciesUpdate, this.commandName);
            }
            for (const [_depName, resolved] of node.externalDependencies) {
                node.pkg.removeDependencyWorkspaceProtocolPrefix(node.name, resolved);
            }
        });
    }
    annotateGitHead() {
        try {
            const gitHead = this.options.gitHead || getCurrentSHA(this.execOpts);
            for (const pkg of this.packagesToPublish ?? []) {
                pkg.set('gitHead', gitHead);
            }
        }
        catch (err) {
            this.logger.silly('EGITHEAD', err.message);
            this.logger.notice('FYI', 'Unable to set temporary gitHead property, it will be missing from registry metadata');
        }
    }
    serializeChanges() {
        return pMap(this.packagesToPublish ?? [], (pkg) => pkg.serialize());
    }
    resetChanges() {
        const { cwd } = this.execOpts;
        const gitOpts = {
            granularPathspec: this.options.granularPathspec !== false,
        };
        const dirtyManifests = [this.project.manifest]
            .concat(this.packagesToPublish)
            .map((pkg) => relative(cwd, pkg.manifestLocation));
        return gitCheckout(dirtyManifests, gitOpts, this.execOpts, this.options.dryRun).catch((err) => {
            this.logger.silly('EGITCHECKOUT', err.message);
            this.logger.notice('FYI', `Unable to reset working tree changes, this probably isn't a git repo.`);
        });
    }
    removePackageProperties() {
        const { removePackageFields } = this.options;
        return pMap(this.packagesToPublish, (node) => {
            if (Array.isArray(removePackageFields)) {
                for (const removeField of removePackageFields) {
                    if (removeField === 'scripts') {
                        const scriptNames = Object.keys(node.pkg['scripts'] ?? {});
                        const remainingScripts = excludeValuesFromArray(scriptNames, ['prepublish', 'prepublishOnly', 'prepack', 'postpack']);
                        if (remainingScripts.length < scriptNames.length) {
                            remainingScripts.forEach((scriptName) => deleteComplexObjectProp(node.pkg['scripts'], scriptName, `"${node.pkg.name}" package`));
                            continue;
                        }
                    }
                    deleteComplexObjectProp(node.pkg, removeField, `"${node.pkg.name}" package`);
                }
            }
        });
    }
    removeTempLicensesOnError(error) {
        return Promise.resolve()
            .then(() => removeTempLicenses(this.packagesToBeLicensed ?? []).catch((removeError) => {
            this.logger.error('licenses', 'error removing temporary license files', removeError.stack || removeError);
        }))
            .then(() => {
            throw error;
        });
    }
    requestOneTimePassword() {
        if (this.options.dryRun) {
            this.logger.info(chalk.bold.magenta('[dry-run] >'), 'will ask OTP');
            return;
        }
        if (this.otpCache.otp) {
            return;
        }
        return Promise.resolve()
            .then(() => getOneTimePassword('Enter OTP:'))
            .then((otp) => (this.otpCache.otp = otp));
    }
    topoMapPackages(mapper) {
        return runTopologically(this.packagesToPublish, mapper, {
            concurrency: this.concurrency,
            rejectCycles: this.options.rejectCycles,
            graphType: this.options.graphType === 'dependencies'
                ? 'dependencies'
                : this.options.allowPeerDependenciesUpdate
                    ? 'allPlusPeerDependencies'
                    : 'allDependencies',
        });
    }
    packUpdated() {
        const tracker = this.logger.newItem('npm pack');
        tracker.addWork(this.packagesToPublish?.length);
        let chain = Promise.resolve();
        chain = chain.then(() => createTempLicenses(this.project.licensePath, this.packagesToBeLicensed ?? []));
        if (!this.hasRootedLeaf) {
            chain = chain.then(() => this.runRootLifecycle('prepublish'));
            chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, 'prepare'));
            chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, 'prepublishOnly'));
            chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, 'prepack'));
        }
        const opts = this.conf.snapshot;
        const mapper = pPipe(...[
            (pkg) => pulseTillDone(packDirectory(pkg, pkg.location, opts)).then((packed) => {
                tracker.verbose('packed', relative(this.project.rootPath ?? '', pkg.contents));
                tracker.completeWork(1);
                pkg.packed = packed;
                return pkg.refresh();
            }),
        ].filter(Boolean));
        chain = chain.then(() => {
            if (this.toposort) {
                return this.topoMapPackages(mapper);
            }
            return pMap(this.packagesToPublish, mapper, { concurrency: this.concurrency });
        });
        chain = chain.then(() => removeTempLicenses(this.packagesToBeLicensed ?? []));
        chain = chain.catch((error) => this.removeTempLicensesOnError(error));
        if (!this.hasRootedLeaf) {
            chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, 'postpack'));
        }
        return chain.finally(() => tracker.finish());
    }
    publishPacked() {
        this.publishedPackages = [];
        const tracker = this.logger.newItem('publish');
        tracker.addWork(this.packagesToPublish?.length);
        let chain = Promise.resolve();
        if (this.twoFactorAuthRequired) {
            chain = chain.then(() => this.requestOneTimePassword());
        }
        const opts = Object.assign(this.conf.snapshot, {
            tag: this.options.tempTag ? 'lerna-temp' : this.conf.get('tag'),
            'git-dry-run': this.options.dryRun || false,
        });
        const logListener = (...args) => {
            const str = args.join(' ');
            if (str.toLowerCase().includes('provenance statement') && str.includes('https://')) {
                const url = str.match(/https:\/\/[^ ]+/)?.[0] ?? '';
                this.uniqueProvenanceUrls.add(url);
            }
        };
        process.on('log', logListener);
        const mapper = pPipe(...[
            (pkg) => {
                const preDistTag = this.getPreDistTag(pkg);
                const tag = !this.options.tempTag && preDistTag ? preDistTag : opts.tag;
                const pkgOpts = Object.assign({}, opts, { tag });
                return pulseTillDone(npmPublish(pkg, pkg.packed.tarFilePath, pkgOpts, this.otpCache))
                    .then(() => {
                    this.publishedPackages.push(pkg);
                    tracker.success('published', pkg.name, pkg.version);
                    tracker.completeWork(1);
                    logPacked(pkg, this.options.dryRun);
                    return pkg;
                })
                    .catch((err) => {
                    const isNpmJsComConflict = isNpmJsPublishVersionConflict(err);
                    const isNpmPkgGitHubComConflict = isNpmPkgGitHubPublishVersionConflict(err);
                    if (isNpmJsComConflict || isNpmPkgGitHubComConflict) {
                        tracker.warn('publish', `Package is already published: ${pkg.name}@${pkg.version}`);
                        tracker.completeWork(1);
                        return pkg;
                    }
                    this.logger.silly('', err);
                    this.logger.warn('notice', `Package failed to publish: ${pkg.name}`);
                    this.logger.error(err.code, (err.body && err.body.error) || err.message);
                    err.name = 'ValidationError';
                    if ('errno' in err && typeof err.errno === 'number' && Number.isFinite(err.errno)) {
                        process.exitCode = err.errno;
                    }
                    else {
                        this.logger.error('', `errno "${err.errno}" is not a valid exit code - exiting with code 1`);
                        process.exitCode = 1;
                    }
                    throw err;
                });
            },
        ].filter(Boolean));
        chain = chain.then(() => {
            if (this.toposort) {
                return this.topoMapPackages(mapper);
            }
            return pMap(this.packagesToPublish, mapper, { concurrency: this.concurrency });
        });
        if (!this.hasRootedLeaf) {
            chain = chain.then(() => this.runRootLifecycle('publish'));
            chain = chain.then(() => this.runRootLifecycle('postpublish'));
        }
        return chain.finally(() => {
            process.removeListener('log', logListener);
            tracker.finish();
        });
    }
    npmUpdateAsLatest() {
        const tracker = this.logger.newItem('npmUpdateAsLatest');
        tracker.addWork(this.packagesToPublish?.length);
        tracker.showProgress();
        let chain = Promise.resolve();
        const opts = this.conf.snapshot;
        const getDistTag = (publishConfig) => {
            if (opts.tag === 'latest' && publishConfig?.tag) {
                return publishConfig.tag;
            }
            return opts.tag;
        };
        const mapper = (pkg) => {
            const spec = `${pkg.name}@${pkg.version}`;
            const preDistTag = this.getPreDistTag(pkg);
            const distTag = preDistTag || getDistTag(pkg.get('publishConfig'));
            return Promise.resolve()
                .then(() => pulseTillDone(remove(spec, 'lerna-temp', opts, this.otpCache)))
                .then(() => pulseTillDone(add(spec, distTag, opts, this.otpCache)))
                .then(() => {
                tracker.success('dist-tag', '%s@%s => %j', pkg.name, pkg.version, distTag);
                tracker.completeWork(1);
                return pkg;
            });
        };
        chain = chain.then(() => {
            if (this.toposort) {
                return this.topoMapPackages(mapper);
            }
            return pMap(this.packagesToPublish, mapper, { concurrency: this.concurrency });
        });
        return chain.finally(() => tracker.finish());
    }
    getDistTag() {
        if (this.options.distTag) {
            return this.options.distTag;
        }
        if (this.options.canary) {
            return 'canary';
        }
    }
    getPreDistTag(pkg) {
        if (!this.options.preDistTag) {
            return;
        }
        const isPrerelease = prereleaseIdFromVersion(pkg.version);
        if (isPrerelease) {
            return this.options.preDistTag;
        }
    }
}
//# sourceMappingURL=publish-command.js.map