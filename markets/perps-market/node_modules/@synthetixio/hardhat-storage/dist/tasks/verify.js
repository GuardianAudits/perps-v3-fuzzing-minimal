"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const types = __importStar(require("@synthetixio/core-utils/utils/hardhat/argument-types"));
const contracts_1 = require("@synthetixio/core-utils/utils/hardhat/contracts");
const logger_1 = __importDefault(require("@synthetixio/core-utils/utils/io/logger"));
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const dump_1 = require("../internal/dump");
const validate_1 = require("../internal/validate");
const task_names_1 = require("../task-names");
(0, config_1.task)(task_names_1.TASK_STORAGE_VERIFY, 'Validate all the contracts against existing storage dump and, if valid, update it')
    .addOptionalParam('artifacts', 'Contract files, names, fully qualified names or folder of contracts to include', ['contracts/**'], types.stringArray)
    .addOptionalParam('skip', 'Optional whitelist of contracts to skip the validations', [], types.stringArray)
    .addOptionalParam('output', 'Storage dump output file relative to the root of the project', 'storage.dump.sol')
    .addFlag('log', 'Show the result in the console')
    .addFlag('noSave', 'Do not update storage dump file')
    .setAction(async (params, hre) => {
    const userOverrideConfig = hre.config.storage ?? {};
    const artifacts = userOverrideConfig.artifacts ?? params.artifacts;
    const skip = userOverrideConfig.skip ?? params.skip;
    const output = userOverrideConfig.output ?? params.output;
    const log = userOverrideConfig.log ?? params.log;
    const noSave = userOverrideConfig.noSave ?? params.noSave;
    if (log) {
        logger_1.default.quiet = true;
    }
    const now = Date.now();
    logger_1.default.subtitle('Validating storage');
    for (const contract of artifacts) {
        logger_1.default.info(contract);
    }
    await hre.run('compile', { quiet: true, force: true });
    const allContracts = await (0, contracts_1.getContractsFullyQualifiedNames)(hre, artifacts);
    const sourceUnits = await hre.run(task_names_1.SUBTASK_STORAGE_GET_SOURCE_UNITS, {
        artifacts: allContracts,
    });
    const prevSourceUnits = await hre.run(task_names_1.SUBTASK_STORAGE_PARSE_DUMP, { output });
    const errors = (0, validate_1.validate)({ sourceUnits, prevSourceUnits, skip });
    errors.forEach((err) => console.error(err, '\n'));
    if (errors.length) {
        throw new plugins_1.HardhatPluginError('hardhat-storage', 'Storage validation failed');
    }
    const dump = await (0, dump_1.dumpStorage)(sourceUnits);
    if (log) {
        console.log(dump);
    }
    // Sanity check to verify that the generated dump is parseable
    await hre.run(task_names_1.SUBTASK_STORAGE_PARSE_CONTENTS, {
        contents: {
            [output]: dump,
        },
    });
    if (!noSave) {
        const target = node_path_1.default.resolve(hre.config.paths.root, output);
        await promises_1.default.mkdir(node_path_1.default.dirname(target), { recursive: true });
        await promises_1.default.writeFile(target, dump);
        logger_1.default.success(`Storage dump written to ${output} in ${Date.now() - now}ms`);
    }
    return dump;
});
//# sourceMappingURL=verify.js.map