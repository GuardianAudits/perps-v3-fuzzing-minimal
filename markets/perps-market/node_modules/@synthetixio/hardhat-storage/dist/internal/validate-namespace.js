"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSlotNamespaceCollisions = void 0;
const finders_1 = require("@synthetixio/core-utils/utils/ast/finders");
const error_1 = require("./error");
const iterators_1 = require("./iterators");
const misc_1 = require("./misc");
function validateSlotNamespaceCollisions({ sourceUnits }) {
    const slots = [];
    return [...(0, iterators_1.iterateSlotAssignments)(sourceUnits)]
        .map(([sourceUnit, contractNode, functionNode, yulAssignment]) => {
        const _error = (message, ...nodes) => ({
            message,
            sourceUnit,
            nodes: [contractNode, functionNode, ...nodes],
        });
        const val = yulAssignment.value;
        // The assignment of the .slot value should be an existing variable
        if (val.nodeType !== 'YulIdentifier') {
            return _error('Store assignments can only be assignments to a constant value in the contract', yulAssignment);
        }
        // Find when the value is declared inside the current function
        const varStatement = _findVariableDeclarationStatementOf(functionNode, val.name);
        if (!varStatement) {
            return _error(`Could not find variable declaration value for "${val.name}"`, val);
        }
        if (!varStatement.initialValue) {
            return _error('Slot value not initialized', varStatement);
        }
        let slotValue;
        // If the slot value is a function call, is a dynamic value initialized inside
        // the function
        if (varStatement.initialValue.nodeType === 'FunctionCall') {
            slotValue = varStatement.initialValue;
            // If it is an identifier, it should be pointing to a contract constant
        }
        else if (varStatement.initialValue.nodeType === 'Identifier') {
            const slotName = varStatement.initialValue.name;
            const constantDeclaration = contractNode.nodes.find((node) => node.nodeType === 'VariableDeclaration' && node.constant && node.name === slotName);
            if (!constantDeclaration?.value || constantDeclaration.value.nodeType !== 'FunctionCall') {
                return _error('Slot value should be a contract constant with a value initialized', varStatement);
            }
            slotValue = constantDeclaration.value;
        }
        else {
            return _error('Slot value should be a contract constant or a dynamic local value', varStatement);
        }
        // Get the first string key value from keccak256(abi.encode("slot-name", ...))
        const slotKey = _getSlotValueFromFunctionCall(slotValue);
        if (!slotKey) {
            return _error('Store slot definition should have the format keccak256(abi.encode("your-slot-name", ...))', val);
        }
        if (slots.includes(slotKey)) {
            return _error(`Store slot name repeated: ${slotKey}`, val);
        }
        slots.push(slotKey);
    })
        .filter(misc_1.isPresent)
        .map((err) => (0, error_1.createError)(err));
}
exports.validateSlotNamespaceCollisions = validateSlotNamespaceCollisions;
function _findVariableDeclarationStatementOf(functionNode, varName) {
    return (0, finders_1.findOne)(functionNode, 'VariableDeclarationStatement', (declarationStatement) => {
        return !!(0, finders_1.findOne)(declarationStatement, 'VariableDeclaration', ({ name }) => name === varName);
    });
}
function _getSlotValueFromFunctionCall(slotValue) {
    if (slotValue.nodeType !== 'FunctionCall')
        return;
    if (slotValue.typeDescriptions.typeString !== 'bytes32')
        return;
    const { expression } = slotValue;
    if (expression.nodeType !== 'Identifier' || expression.name !== 'keccak256')
        return;
    if (slotValue.arguments.length !== 1 || slotValue.arguments[0].nodeType !== 'FunctionCall')
        return;
    const encode = slotValue.arguments[0];
    if (encode.expression.nodeType !== 'MemberAccess' || encode.expression.memberName !== 'encode')
        return;
    if (encode.arguments.length === 0)
        return;
    const [slotKey] = encode.arguments;
    if (slotKey.nodeType !== 'Literal' || slotKey.kind !== 'string')
        return;
    if (typeof slotKey.value !== 'string' || !slotKey.value)
        return;
    return slotKey.value;
}
//# sourceMappingURL=validate-namespace.js.map