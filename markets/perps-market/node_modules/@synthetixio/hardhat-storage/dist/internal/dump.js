"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dumpStorage = void 0;
const finders_1 = require("@synthetixio/core-utils/utils/ast/finders");
const clone_1 = require("@synthetixio/core-utils/utils/misc/clone");
const iterators_1 = require("./iterators");
const render_1 = require("./render");
/**
 * Generate a single solidity file including all the given contracts but only
 * rendering its storage defintions.
 */
async function dumpStorage(astNodes, version, license = 'UNLICENSED') {
    if (!Array.isArray(astNodes) || !astNodes.length) {
        throw new Error('No solidity files found');
    }
    const result = [
        `// SPDX-License-Identifier: ${license}`,
        version ? `pragma solidity ${version};` : _renderPragmaDirective(astNodes),
        '',
    ];
    for (const [sourceUnit, contractNode] of (0, iterators_1.iterateContracts)(astNodes)) {
        const sourceName = sourceUnit.absolutePath;
        const contractName = contractNode.name;
        const fqName = `${sourceName}:${contractName}`;
        const resultNode = (0, clone_1.clone)(contractNode);
        const constDeclarations = (0, finders_1.findAll)(contractNode, 'VariableDeclaration', (node) => node.mutability === 'constant');
        const enumDefinitions = (0, finders_1.findAll)(contractNode, 'EnumDefinition');
        const structDefinitions = (0, finders_1.findAll)(contractNode, 'StructDefinition');
        const slotAssignments = [...(0, iterators_1.iterateSlotAssignments)([sourceUnit])].map(([, , functionNode]) => functionNode);
        // Filter all the contract nodes to only include Structs and Storage Slot Definitions
        resultNode.nodes = [
            ...constDeclarations,
            ...enumDefinitions,
            ...structDefinitions,
            ...slotAssignments,
        ];
        if (!resultNode.nodes.length)
            continue;
        // Render the contract only including storage definitions
        const contract = (0, render_1.render)(resultNode);
        result.push(`// @custom:artifact ${fqName}`, contract, '');
    }
    return result.join('\n');
}
exports.dumpStorage = dumpStorage;
function _renderPragmaDirective(sourceUnits) {
    const sourceUnit = sourceUnits[sourceUnits.length - 1];
    // TODO: calculate the best solc version based on all the files, instead of using
    // the one from the last file
    for (const node of (0, finders_1.findAll)(sourceUnit, 'PragmaDirective'))
        return (0, render_1.render)(node);
}
//# sourceMappingURL=dump.js.map