"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderTestableStorage = void 0;
const node_path_1 = __importDefault(require("node:path"));
const logger_1 = __importDefault(require("@synthetixio/core-utils/utils/io/logger"));
const contract_names_1 = require("hardhat/utils/contract-names");
const utils_1 = require("solidity-ast/utils");
const render_template_1 = require("./render-template");
function renderTestableStorage({ artifact, relativeSourceName, sourceAstNode, template = node_path_1.default.resolve(__dirname, '..', '..', 'templates', 'TestableStorage.sol.mustache'), }) {
    const { sourceName, contractName } = (0, contract_names_1.parseFullyQualifiedName)(artifact);
    const input = _generateTemplateInputs(relativeSourceName, sourceName, contractName, sourceAstNode);
    return (0, render_template_1.renderTemplate)(template, input);
}
exports.renderTestableStorage = renderTestableStorage;
function _generateTemplateInputs(relativeSourceName, sourceFile, contractName, astNode) {
    const contractDefinition = _findContractNode(contractName, astNode);
    const dataStructDefinition = Array.from((0, utils_1.findAll)('StructDefinition', contractDefinition)).find((def) => def.name === 'Data');
    if (!dataStructDefinition) {
        throw new Error(`Storage contract in "${sourceFile}" needs a struct named "Data" to render`);
    }
    const fields = [];
    const indexedFields = [];
    for (const variableDeclaration of dataStructDefinition.members) {
        if (variableDeclaration.typeName?.nodeType === 'Mapping') {
            if (variableDeclaration.typeName.valueType.nodeType !== 'ElementaryTypeName') {
                logger_1.default.info(`Skipping generated getter/setter for ${variableDeclaration.name} because it has a nested type`);
                continue;
            }
            indexedFields.push({
                name: variableDeclaration.name,
                type: variableDeclaration.typeName.valueType.name,
                indexType: variableDeclaration.typeName.keyType.name,
                isArray: false,
            });
        }
        else if (variableDeclaration.typeName?.nodeType === 'ArrayTypeName') {
            if (variableDeclaration.typeName.baseType.nodeType !== 'ElementaryTypeName') {
                logger_1.default.info(`Skipping generated getter/setter for ${variableDeclaration.name} because it has a nested type`);
                continue;
            }
            indexedFields.push({
                name: variableDeclaration.name,
                type: variableDeclaration.typeName.baseType.name,
                indexType: 'uint',
                isArray: false,
            });
        }
        else if (variableDeclaration.typeName?.nodeType === 'ElementaryTypeName') {
            fields.push({
                name: variableDeclaration.name,
                type: variableDeclaration.typeName.name === 'string' ||
                    variableDeclaration.typeName.name === 'bytes'
                    ? `${variableDeclaration.typeName.name} memory`
                    : variableDeclaration.typeName.name,
            });
        }
        // else, don't know what to do about nested types atm
    }
    const methods = [];
    let loadParams = undefined;
    let loadInject = undefined;
    for (const functionDefinition of (0, utils_1.findAll)('FunctionDefinition', contractDefinition)) {
        if (functionDefinition.visibility === 'private') {
            logger_1.default.info(`Skipping function ${functionDefinition.name} because its private`);
            continue;
        }
        if (functionDefinition.name === 'load') {
            loadParams = functionDefinition.parameters.parameters
                .map((p) => `${_renderAstType(contractName, p.typeName)}${p.storageLocation !== 'default' ? ' ' + p.storageLocation : ''} _load_${p.name}`)
                .join(', ');
            loadInject = functionDefinition.parameters.parameters
                .map((p) => '_load_' + p.name)
                .join(', ');
            continue; // we have handled the load function
        }
        if (functionDefinition.returnParameters.parameters.filter((p) => p.storageLocation === 'storage')
            .length) {
            logger_1.default.info(`Skipping function ${functionDefinition.name} because it returns an unsupported storage input parameter`);
            continue; // cannot return non-storage
        }
        const storageParams = functionDefinition.parameters.parameters.filter((p) => p.storageLocation === 'storage');
        const memoryParams = functionDefinition.parameters.parameters.filter((p) => p.storageLocation === 'memory');
        if (memoryParams.length || storageParams.length > 1) {
            logger_1.default.info(`Skipping function ${functionDefinition.name} because it contains unsupported storage or memory input parameter type`);
            continue; // input parameter must be of the same type as the contract
        }
        methods.push({
            name: functionDefinition.name,
            mutability: functionDefinition.stateMutability === 'view' ||
                functionDefinition.stateMutability === 'pure'
                ? functionDefinition.stateMutability
                : undefined,
            usesLoad: storageParams.length > 0,
            params: functionDefinition.parameters.parameters
                .filter((p) => p.storageLocation !== 'storage') // only non-storage values can be injected (storage values will be injected later)
                .map((p) => `${_renderAstType(contractName, p.typeName)}${p.storageLocation !== 'default' ? ' ' + p.storageLocation : ''} ${p.name}`)
                .join(', '),
            paramsInject: functionDefinition.parameters.parameters
                .map((p) => (p.storageLocation === 'storage' ? 'store' : p.name))
                .join(', '),
            returns: functionDefinition.returnParameters.parameters
                .map((p) => `${_renderAstType(contractName, p.typeName)}${p.storageLocation !== 'default' ? ' ' + p.storageLocation : ''}`)
                .join(', '),
        });
    }
    const input = {
        relativeSourceName,
        loadParams,
        loadInject,
        libraryName: contractDefinition.name,
        fields,
        indexedFields,
        methods,
    };
    return input;
}
function _findContractNode(contractName, astNode) {
    for (const contractDefiniton of (0, utils_1.findAll)('ContractDefinition', astNode)) {
        if (contractDefiniton.name === contractName) {
            return contractDefiniton;
        }
    }
    throw new Error(`Contract node for "${contractName}" not found`);
}
function _renderAstType(context, t) {
    if (t.nodeType === 'Mapping') {
        return `mapping(${_renderAstType(context, t.keyType)} => ${_renderAstType(context, t.valueType)})`;
    }
    else if (t.nodeType === 'ArrayTypeName') {
        return `${_renderAstType(context, t.baseType)}[${t.length || ''}]`;
    }
    else if (t.nodeType === 'FunctionTypeName') {
        return 'function'; // dont know what to do with this
    }
    else if (t.nodeType === 'UserDefinedTypeName') {
        const n = t.pathNode?.name || t.name || '';
        return n === 'Data' ? `${context}.${n}` : n;
    }
    else {
        return t.name;
    }
}
//# sourceMappingURL=render-testable-storage.js.map