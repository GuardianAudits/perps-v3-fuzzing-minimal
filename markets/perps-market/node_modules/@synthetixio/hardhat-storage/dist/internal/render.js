"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = void 0;
const TAB = '  ';
/**
 * Minimal solidity renderer, only renders contracts with storage slot assignments
 * and struct declarations.
 */
function render(node) {
    if (!_has(_render, node.nodeType)) {
        console.log(JSON.stringify(node, null, 2));
        throw new Error(`Rendering of node of type "${node?.nodeType}" not implemented`);
    }
    try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return _render[node.nodeType](node);
    }
    catch (err) {
        console.log(JSON.stringify(node, null, 2));
        throw err;
    }
}
exports.render = render;
function _renderSemicolons(parentType) {
    return function (node) {
        const semi = _colons[parentType].includes(node.nodeType) ? ';' : '';
        return render(node) + semi;
    };
}
const _colons = {
    ContractDefinition: [
        'ErrorDefinition',
        'EventDefinition',
        'ModifierDefinition',
        'UsingForDirective',
        'VariableDeclaration',
    ],
    StructDefinition: ['VariableDeclaration'],
    Block: [
        'EmitStatement',
        'ExpressionStatement',
        'Return',
        'RevertStatement',
        'VariableDeclarationStatement',
    ],
    YulBlock: [
        'YulAssignment',
        'YulBreak',
        'YulContinue',
        'YulExpressionStatement',
        'YulLeave',
        'YulVariableDeclaration',
    ],
};
const _render = {
    PragmaDirective(node) {
        const [solidity, ...version] = node.literals;
        return `pragma ${solidity} ${version.join('')};`;
    },
    VariableDeclaration(node) {
        const val = [render(node.typeName)];
        if (node.stateVariable)
            val.push(node.visibility);
        if (node.mutability !== 'mutable')
            val.push(node.mutability);
        if (node.storageLocation !== 'default')
            val.push(node.storageLocation);
        val.push(node.name);
        if (node.value)
            val.push('=', render(node.value));
        return `${val.join(' ')}`;
    },
    VariableDeclarationStatement(node) {
        if (node.declarations.length !== 1 || !node.declarations[0]) {
            throw new Error('Rendering of node not implemented');
        }
        const declaration = render(node.declarations[0]);
        return node.initialValue ? `${declaration} = ${render(node.initialValue)}` : declaration;
    },
    ElementaryTypeName(node) {
        return node.name;
    },
    EnumDefinition(node) {
        if (!Array.isArray(node.members) || !node.members.length)
            return 'enum {}';
        const members = node.members.map(render).map(_indent());
        return [`enum ${node.name} {`, members.join(',\n'), '}'].join('\n');
    },
    EnumValue(node) {
        return node.name;
    },
    UserDefinedTypeName(node) {
        if (node.typeDescriptions.typeString?.startsWith('contract ')) {
            return 'address';
        }
        return node.pathNode.name;
    },
    Mapping(node) {
        return `mapping(${render(node.keyType)} => ${render(node.valueType)})`;
    },
    ArrayTypeName(node) {
        return `${render(node.baseType)}[]`;
    },
    Literal(node) {
        if (!node.isPure || !['number', 'string'].includes(node.kind)) {
            throw new Error('Rendering of node not implemented');
        }
        return node.kind === 'string' ? `"${node.value}"` : `${node.value}`;
    },
    YulLiteral(node) {
        if (!['number', 'string'].includes(node.kind)) {
            throw new Error('Rendering of node not implemented');
        }
        return node.kind === 'string' ? `"${node.value}"` : `${node.value}`;
    },
    ContractDefinition(node) {
        const children = node.nodes
            .map(_renderSemicolons('ContractDefinition'))
            .map(_indent())
            .join('\n');
        return [`${node.contractKind} ${node.name} {`, children, '}'].join('\n');
    },
    StructDefinition(node) {
        if (node.visibility !== 'public')
            throw new Error('Rendering of node not implemented');
        const vars = node.members
            .map(_renderSemicolons('StructDefinition'))
            .map(_indent())
            .join('\n');
        return [`struct ${node.name} {`, vars, '}'].join('\n');
    },
    FunctionDefinition(node) {
        if (node.kind !== 'function')
            throw new Error('Rendering of node not implemented');
        if (node.modifiers.length)
            throw new Error('Rendering of node not implemented');
        if (node.overrides)
            throw new Error('Rendering of node not implemented');
        const params = render(node.parameters);
        const attrs = [node.visibility, node.stateMutability];
        if (node.virtual)
            attrs.push('virtual');
        if (node.returnParameters.parameters.length) {
            attrs.push(`returns (${render(node.returnParameters)})`);
        }
        const semi = node.body ? '' : ';';
        const block = node.body ? render(node.body) : '';
        return `function ${node.name}(${params}) ${attrs.join(' ')}${semi}${block}`;
    },
    ParameterList(node) {
        return node.parameters.map(render).join(', ');
    },
    Block(node) {
        if (!Array.isArray(node.statements) || !node.statements.length)
            return ' {}';
        const statements = node.statements.map(_renderSemicolons('Block')).map(_indent());
        return [' {', ...statements, '}'].join('\n');
    },
    YulBlock(node) {
        if (!Array.isArray(node.statements) || !node.statements.length)
            return ' {}';
        const statements = node.statements.map(render).map(_indent());
        return ['assembly {', ...statements, '}'].join('\n');
    },
    YulAssignment(node) {
        if (node.variableNames.length !== 1)
            throw new Error('Rendering of node not implemented');
        return `${render(node.variableNames[0])} := ${render(node.value)}`;
    },
    InlineAssembly(node) {
        return render(node.AST);
    },
    FunctionCall(node) {
        const name = render(node.expression);
        const params = node.arguments.map(render);
        return `${name}(${params.join(', ')})`;
    },
    Identifier(node) {
        return node.name;
    },
    YulIdentifier(node) {
        return node.name;
    },
    ElementaryTypeNameExpression(node) {
        return node.typeName.name;
    },
    MemberAccess(node) {
        return `${render(node.expression)}.${node.memberName}`;
    },
    UnaryOperation(node) {
        return `${node.operator}${render(node.subExpression)}`;
    },
    BinaryOperation(node) {
        return `${render(node.leftExpression)} ${node.operator} ${render(node.rightExpression)}`;
    },
};
function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function _indent(amount = 2) {
    const indentation = TAB.repeat(amount);
    return (str) => str.replace(/^(.+)/gm, `${indentation}$1`);
}
//# sourceMappingURL=render.js.map