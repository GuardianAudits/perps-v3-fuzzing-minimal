<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/Proxy.sol</b>
<code>
  1 |     | <span class='unexecuted'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {UUPSProxyWithOwner} from &quot;@synthetixio/core-contracts/contracts/proxy/UUPSProxyWithOwner.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * Synthetix V3 Perps Factory -- Proxy Contract</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Visit https://usecannon.com/packages/synthetix-perps-market to interact with this protocol</span>
 10 |     | <span class='neutral'> */</span>
 11 | *   | <span class='executed'>contract Proxy is UUPSProxyWithOwner {</span>
 12 |     | <span class='neutral'>    // solhint-disable-next-line no-empty-blocks</span>
 13 |     | <span class='unexecuted'>    constructor(</span>
 14 |     | <span class='neutral'>        address firstImplementation,</span>
 15 |     | <span class='neutral'>        address initialOwner</span>
 16 |     | <span class='unexecuted'>    ) UUPSProxyWithOwner(firstImplementation, initialOwner) {}</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/Fuzz.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./FuzzModules.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *r  | <span class='executed'>contract Fuzz is FuzzModules {</span>
  7 |     | <span class='neutral'>    constructor() payable {</span>
  8 |     | <span class='unexecuted'>        setup();</span>
  9 |     | <span class='unexecuted'>        setupActors();</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzAdmin.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./helper/preconditions/PreconditionsAdmin.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./helper/postconditions/PostconditionsAdmin.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>contract FuzzAdmin is PreconditionsAdmin, PostconditionsAdmin {</span>
   8 | *   | <span class='executed'>    function fuzz_mintUSDToSynthetix(uint256 amount) public {</span>
   9 | *   | <span class='executed'>        amount = mintUSDToSynthetixPreconditions(amount);</span>
  10 |     | <span class='neutral'></span>
  11 | *   | <span class='executed'>        v3Mock.mintUSDToSynthetix(amount);</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 | *   | <span class='executed'>    function fuzz_burnUSDFromSynthetix(uint256 amount) public {</span>
  15 | *   | <span class='executed'>        amount = burnUSDFromSynthetixPreconditions(amount);</span>
  16 |     | <span class='neutral'></span>
  17 | *r  | <span class='executed'>        v3Mock.burnUSDFromSynthetix(amount);</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event DebugPrice(int256 p, string s);</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>    function fuzz_changeWETHPythPrice(int64 newPrice) public {</span>
  23 | *   | <span class='executed'>        ChangePythPriceParams memory params = changeWETHPythPricePreconditions(</span>
  24 | *   | <span class='executed'>            newPrice</span>
  25 |     | <span class='neutral'>        );</span>
  26 | *   | <span class='executed'>        fl.gt(</span>
  27 | *   | <span class='executed'>            params.newPrice,</span>
  28 |     | <span class='neutral'>            0,</span>
  29 |     | <span class='neutral'>            &quot;fuzz_changeWETHPythPrice AFTER CHANGED PRICE&quot;</span>
  30 |     | <span class='neutral'>        );</span>
  31 |     | <span class='neutral'></span>
  32 | *   | <span class='executed'>        pythWrapper.setBenchmarkPrice(WETH_FEED_ID, params.newPrice);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>        changePythPricePostconditions(params.id, params.newPrice);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>    function fuzz_changeWBTCPythPrice(int64 newPrice) public {</span>
  38 | *   | <span class='executed'>        ChangePythPriceParams memory params = changeWBTCPythPricePreconditions(</span>
  39 | *   | <span class='executed'>            newPrice</span>
  40 |     | <span class='neutral'>        );</span>
  41 | *   | <span class='executed'>        fl.gt(</span>
  42 | *   | <span class='executed'>            params.newPrice,</span>
  43 |     | <span class='neutral'>            0,</span>
  44 |     | <span class='neutral'>            &quot;fuzz_changeWBTCPythPrice AFTER CHANGED PRICE&quot;</span>
  45 |     | <span class='neutral'>        );</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>        pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, params.newPrice);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        changePythPricePostconditions(params.id, params.newPrice);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    event OM(bytes32 node, string s);</span>
  53 |     | <span class='neutral'></span>
  54 | *   | <span class='executed'>    function fuzz_changeOracleManagerPrice(</span>
  55 |     | <span class='neutral'>        uint256 nodeIndex,</span>
  56 |     | <span class='neutral'>        int256 newPrice</span>
  57 |     | <span class='unexecuted'>    ) public {</span>
  58 | *   | <span class='executed'>        (</span>
  59 | *   | <span class='executed'>            int256 newClampedPrice,</span>
  60 | *   | <span class='executed'>            bytes32 nodeId</span>
  61 | *   | <span class='executed'>        ) = changeOracleManagerPricePreconditions(nodeIndex, newPrice);</span>
  62 | *   | <span class='executed'>        fl.gt(</span>
  63 |     | <span class='neutral'>            newClampedPrice,</span>
  64 |     | <span class='neutral'>            0,</span>
  65 |     | <span class='neutral'>            &quot;fuzz_changeOracleManagerPrice CLAMPED PRICE NEGATIVE!&quot;</span>
  66 |     | <span class='neutral'>        );</span>
  67 |     | <span class='neutral'></span>
  68 | *   | <span class='executed'>        mockOracleManager.changePrice(nodeId, newClampedPrice);</span>
  69 |     | <span class='neutral'></span>
  70 | *   | <span class='executed'>        changeOracleManagerPricePostconditions(nodeId, newClampedPrice);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>    function fuzz_delegateCollateral(</span>
  74 |     | <span class='neutral'>        uint128 accountId,</span>
  75 |     | <span class='neutral'>        uint128 poolId,</span>
  76 |     | <span class='neutral'>        uint256 collateralIndex,</span>
  77 |     | <span class='neutral'>        uint256 newCollateralAmountD18,</span>
  78 |     | <span class='neutral'>        uint256 leverage</span>
  79 | *   | <span class='executed'>    ) public {</span>
  80 | *   | <span class='executed'>        (</span>
  81 | *   | <span class='executed'>            uint256 clampedNewCollateralAmountD18,</span>
  82 | *   | <span class='executed'>            address collateralType,</span>
  83 | *   | <span class='executed'>            uint128 marketId</span>
  84 | *   | <span class='executed'>        ) = delegateCollateralPreconditions(</span>
  85 | *   | <span class='executed'>                newCollateralAmountD18,</span>
  86 | *   | <span class='executed'>                collateralIndex</span>
  87 |     | <span class='neutral'>            );</span>
  88 |     | <span class='neutral'></span>
  89 | *r  | <span class='executed'>        vaultModuleMock.delegateCollateral(</span>
  90 |     | <span class='neutral'>            accountId,</span>
  91 |     | <span class='neutral'>            poolId,</span>
  92 |     | <span class='neutral'>            collateralType,</span>
  93 |     | <span class='neutral'>            clampedNewCollateralAmountD18,</span>
  94 |     | <span class='neutral'>            leverage,</span>
  95 |     | <span class='neutral'>            marketId</span>
  96 |     | <span class='neutral'>        );</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>    function fuzz_crashWBTCPythPrice(uint loops) public {</span>
 100 | *   | <span class='executed'>        loops = fl.clamp(loops, 1, 20);</span>
 101 |     | <span class='neutral'>        ChangePythPriceParams memory params;</span>
 102 | *   | <span class='executed'>        for (uint i; i &lt; loops; i++) {</span>
 103 | *   | <span class='executed'>            params = crashWBTCPythPricePreconditions();</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>            pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, params.newPrice);</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>        fl.gt(</span>
 108 |     | <span class='neutral'>            params.newPrice,</span>
 109 |     | <span class='neutral'>            0,</span>
 110 |     | <span class='neutral'>            &quot;fuzz_crashWBTCPythPrice AFTER CHANGED PRICE&quot;</span>
 111 |     | <span class='neutral'>        );</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        changePythPricePostconditions(params.id, params.newPrice);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>    function fuzz_pumpWBTCPythPrice(uint loops) public {</span>
 117 | *   | <span class='executed'>        loops = fl.clamp(loops, 1, 20);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        ChangePythPriceParams memory params;</span>
 120 | *   | <span class='executed'>        for (uint i; i &lt; loops; i++) {</span>
 121 | *   | <span class='executed'>            params = pumpWBTCPythPricePreconditions();</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>            pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, params.newPrice);</span>
 124 |     | <span class='neutral'>        }</span>
 125 | *   | <span class='executed'>        fl.gt(</span>
 126 | *   | <span class='executed'>            params.newPrice,</span>
 127 |     | <span class='neutral'>            0,</span>
 128 |     | <span class='neutral'>            &quot;fuzz_crashWBTCPythPrice AFTER CHANGED PRICE&quot;</span>
 129 |     | <span class='neutral'>        );</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>        changePythPricePostconditions(params.id, params.newPrice);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 | *   | <span class='executed'>    function fuzz_crashWETHPythPrice(uint loops) public {</span>
 135 | *   | <span class='executed'>        loops = fl.clamp(loops, 1, 20);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>        ChangePythPriceParams memory params;</span>
 138 | *   | <span class='executed'>        for (uint i; i &lt; loops; i++) {</span>
 139 | *   | <span class='executed'>            params = crashWETHPythPricePreconditions();</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>            pythWrapper.setBenchmarkPrice(WETH_FEED_ID, params.newPrice);</span>
 142 |     | <span class='neutral'>        }</span>
 143 | *   | <span class='executed'>        fl.gt(</span>
 144 | *   | <span class='executed'>            params.newPrice,</span>
 145 |     | <span class='neutral'>            0,</span>
 146 |     | <span class='neutral'>            &quot;fuzz_crashWETHPythPrice AFTER CHANGED PRICE&quot;</span>
 147 |     | <span class='neutral'>        );</span>
 148 |     | <span class='neutral'></span>
 149 | *   | <span class='executed'>        changePythPricePostconditions(params.id, params.newPrice);</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 | *   | <span class='executed'>    function fuzz_pumpWETHPythPrice(uint loops) public {</span>
 153 | *   | <span class='executed'>        loops = fl.clamp(loops, 1, 20);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        ChangePythPriceParams memory params;</span>
 156 | *   | <span class='executed'>        for (uint i; i &lt; loops; i++) {</span>
 157 | *   | <span class='executed'>            params = pumpWETHPythPricePreconditions();</span>
 158 |     | <span class='neutral'></span>
 159 | *   | <span class='executed'>            pythWrapper.setBenchmarkPrice(WETH_FEED_ID, params.newPrice);</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>        fl.gt(</span>
 162 |     | <span class='neutral'>            params.newPrice,</span>
 163 |     | <span class='neutral'>            0,</span>
 164 |     | <span class='neutral'>            &quot;fuzz_crashWETHPythPrice AFTER CHANGED PRICE&quot;</span>
 165 |     | <span class='neutral'>        );</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>        changePythPricePostconditions(params.id, params.newPrice);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'>}</span>
 170 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzGuidedModule.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzLiquidationModule.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./FuzzOrderModule.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./FuzzAdmin.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./FuzzPerpsAccountModule.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>contract FuzzGuidedModule is</span>
  10 |     | <span class='neutral'>    FuzzLiquidationModule,</span>
  11 |     | <span class='neutral'>    FuzzPerpsAccountModule,</span>
  12 |     | <span class='neutral'>    FuzzOrderModule,</span>
  13 |     | <span class='neutral'>    FuzzAdmin</span>
  14 |     | <span class='neutral'>{</span>
  15 | *   | <span class='executed'>    function fuzz_guided_depositAndShort() public {</span>
  16 | *   | <span class='executed'>        fuzz_modifyCollateral(1e18, 1);</span>
  17 | *   | <span class='executed'>        fuzz_commitOrder(-2e18, type(uint256).max - 1); //-1 is weth short</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 | *   | <span class='executed'>    function fuzz_guided_depositAndShortWBTC() public {</span>
  21 | *   | <span class='executed'>        fuzz_modifyCollateral(1e18, 1);</span>
  22 | *   | <span class='executed'>        fuzz_commitOrder(-2e18, 6); //-1 is weth short</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 | *   | <span class='executed'>    function fuzz_guided_createDebt_LiquidateMarginOnly(</span>
  26 |     | <span class='neutral'>        bool isWETH,</span>
  27 |     | <span class='neutral'>        int amountToDeposit</span>
  28 | *   | <span class='executed'>    ) public setCurrentActor {</span>
  29 | *   | <span class='executed'>        getPendingOrders(currentActor);</span>
  30 | *   | <span class='executed'>        closeAllPositions(userToAccountIds[currentActor]);</span>
  31 | *   | <span class='executed'>        repayDebt();</span>
  32 | *   | <span class='executed'>        uint collateralBeforeWithdrawal = getTotalCollateralValue(</span>
  33 | *   | <span class='executed'>            userToAccountIds[currentActor]</span>
  34 |     | <span class='neutral'>        );</span>
  35 | *r  | <span class='executed'>        require(collateralBeforeWithdrawal &gt; 0);</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>        fl.log(</span>
  38 |     | <span class='neutral'>            &quot;fuzz_guided_createDebt_LiquidateMarginOnly::collateralBeforeWithdrawal&quot;,</span>
  39 |     | <span class='neutral'>            collateralBeforeWithdrawal</span>
  40 |     | <span class='neutral'>        );</span>
  41 |     | <span class='neutral'></span>
  42 | *   | <span class='executed'>        fuzz_withdrawAllCollateral(</span>
  43 | *   | <span class='executed'>            userToAccountIds[currentActor],</span>
  44 |     | <span class='neutral'>            true,</span>
  45 |     | <span class='neutral'>            true,</span>
  46 |     | <span class='neutral'>            true</span>
  47 |     | <span class='neutral'>        );</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>        uint collateralAfrterWithdrawal = getTotalCollateralValue(</span>
  50 | *   | <span class='executed'>            userToAccountIds[currentActor]</span>
  51 |     | <span class='neutral'>        );</span>
  52 | *   | <span class='executed'>        fl.log(</span>
  53 |     | <span class='neutral'>            &quot;fuzz_guided_createDebt_LiquidateMarginOnly::collateralAfrterWithdrawal&quot;,</span>
  54 |     | <span class='neutral'>            collateralAfrterWithdrawal</span>
  55 |     | <span class='neutral'>        );</span>
  56 | *   | <span class='executed'>        uint collateralId = isWETH ? 1 : 2;</span>
  57 | *r  | <span class='executed'>        amountToDeposit = fl.clamp(amountToDeposit, 1e18, 500e18);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        //Make sure it is zero @giraffe</span>
  60 |     | <span class='neutral'>        //pump here $50k</span>
  61 | *   | <span class='executed'>        isWETH ? fuzz_pumpWETHPythPrice(2) : fuzz_pumpWBTCPythPrice(2);</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>        fuzz_modifyCollateral(amountToDeposit, collateralId);</span>
  64 |     | <span class='neutral'></span>
  65 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  66 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  67 |     | <span class='neutral'>                perpsAccountModuleImpl.getCollateralAmount.selector,</span>
  68 | *   | <span class='executed'>                userToAccountIds[currentActor],</span>
  69 |     | <span class='neutral'>                collateralId</span>
  70 |     | <span class='neutral'>            )</span>
  71 |     | <span class='neutral'>        );</span>
  72 | *   | <span class='executed'>        require(success);</span>
  73 | *   | <span class='executed'>        uint256 amount = abi.decode(returnData, (uint256));</span>
  74 | *   | <span class='executed'>        fl.log(</span>
  75 |     | <span class='neutral'>            &quot;Currect collateral amount afrer withdrawal and deposits&quot;,</span>
  76 |     | <span class='neutral'>            amount</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 | *r  | <span class='executed'>        require(amount &gt; 0, &quot;User needs some collateral&quot;);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        //make sure we are on high enough price @giraffe</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>        fuzz_commitOrder(</span>
  84 | *   | <span class='executed'>            int128(uint128(amount) * 2),</span>
  85 | *   | <span class='executed'>            isWETH ? type(uint256).max - 1 : type(uint256).max //maxprice + marketId</span>
  86 |     | <span class='neutral'>        );</span>
  87 |     | <span class='neutral'></span>
  88 | *   | <span class='executed'>        _settleOrderCall(currentActor, userToAccountIds[currentActor]);</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>        isWETH</span>
  91 | *   | <span class='executed'>            ? fuzz_crashWETHPythPrice(uint(1))</span>
  92 | *   | <span class='executed'>            : fuzz_crashWBTCPythPrice(uint(1)); //20% lower</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  95 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  96 |     | <span class='neutral'>                liquidationModuleImpl.canLiquidate.selector,</span>
  97 | *   | <span class='executed'>                userToAccountIds[currentActor]</span>
  98 |     | <span class='neutral'>            )</span>
  99 |     | <span class='neutral'>        );</span>
 100 | *   | <span class='executed'>        assert(success);</span>
 101 | *   | <span class='executed'>        require(</span>
 102 | *   | <span class='executed'>            !abi.decode(returnData, (bool)),</span>
 103 |     | <span class='neutral'>            &quot;Position should not be liquidatable at this momment&quot;</span>
 104 |     | <span class='neutral'>        );</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>        fuzz_commitOrder((int128(uint128(amount * 2)) * -1), isWETH ? 6 : 5); //maxprice + marketId</span>
 107 |     | <span class='neutral'></span>
 108 | *   | <span class='executed'>        _settleOrderCall(currentActor, userToAccountIds[currentActor]);</span>
 109 |     | <span class='neutral'></span>
 110 | *   | <span class='executed'>        isWETH ? fuzz_crashWETHPythPrice(10) : fuzz_crashWBTCPythPrice(10); //</span>
 111 | *   | <span class='executed'>        fuzz_liquidateMarginOnly();</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>    function fuzz_liquidatePositionAndICheckAfterPriceMove()</span>
 115 |     | <span class='neutral'>        public</span>
 116 |     | <span class='neutral'>        setCurrentActor</span>
 117 | *   | <span class='executed'>    {</span>
 118 | *   | <span class='executed'>        LiquidatePositionParams</span>
 119 | *   | <span class='executed'>            memory params = liquidatePositionPreconditions();</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](2);</span>
 122 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor; //This is liquidator</span>
 123 | *   | <span class='executed'>        actorsToUpdate[1] = params.user;</span>
 124 |     | <span class='neutral'></span>
 125 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _liquidatePositionCall(</span>
 128 | *   | <span class='executed'>            params.accountId</span>
 129 |     | <span class='neutral'>        );</span>
 130 |     | <span class='neutral'></span>
 131 | *   | <span class='executed'>        fuzz_pumpWETHPythPrice(1); //20%</span>
 132 | *   | <span class='executed'>        fuzz_pumpWBTCPythPrice(1);</span>
 133 |     | <span class='neutral'></span>
 134 | *   | <span class='executed'>        liquidatePositionPostconditionsAndICheckAfterPriceMove(</span>
 135 | *   | <span class='executed'>            success,</span>
 136 | *   | <span class='executed'>            returnData,</span>
 137 | *   | <span class='executed'>            actorsToUpdate,</span>
 138 | *   | <span class='executed'>            params.user,</span>
 139 | *   | <span class='executed'>            currentActor,</span>
 140 | *   | <span class='executed'>            params.accountId</span>
 141 |     | <span class='neutral'>        );</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>    function repayDebt() public returns (int256 debt) {</span>
 145 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
 146 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 147 |     | <span class='neutral'>                perpsAccountModuleImpl.debt.selector,</span>
 148 | *   | <span class='executed'>                userToAccountIds[currentActor]</span>
 149 |     | <span class='neutral'>            )</span>
 150 |     | <span class='neutral'>        );</span>
 151 | *r  | <span class='executed'>        require(success);</span>
 152 | *   | <span class='executed'>        debt = abi.decode(returnData, (int256));</span>
 153 | *   | <span class='executed'>        if (debt &gt; 0) {</span>
 154 | *   | <span class='executed'>            fuzz_payDebt(uint128(int128(debt)));</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 | *   | <span class='executed'>    function getPendingOrders(address user) internal {</span>
 159 | *   | <span class='executed'>        uint128 accountId = userToAccountIds[user];</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>        // Get the order</span>
 162 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
 163 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 164 |     | <span class='neutral'>                asyncOrderModuleImpl.getOrder.selector,</span>
 165 |     | <span class='neutral'>                accountId</span>
 166 |     | <span class='neutral'>            )</span>
 167 |     | <span class='neutral'>        );</span>
 168 | *   | <span class='executed'>        if (success) {</span>
 169 | *   | <span class='executed'>            AsyncOrder.Data memory order = abi.decode(</span>
 170 | *   | <span class='executed'>                returnData,</span>
 171 |     | <span class='neutral'>                (AsyncOrder.Data)</span>
 172 |     | <span class='neutral'>            );</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>            // Check if the order is expired</span>
 175 | *   | <span class='executed'>            (success, returnData) = perps.call(</span>
 176 | *   | <span class='executed'>                abi.encodeWithSelector(</span>
 177 |     | <span class='neutral'>                    mockLensModuleImpl.isOrderExpired.selector,</span>
 178 |     | <span class='neutral'>                    accountId</span>
 179 |     | <span class='neutral'>                )</span>
 180 |     | <span class='neutral'>            );</span>
 181 | *   | <span class='executed'>            require(success);</span>
 182 | *   | <span class='executed'>            bool isOrderExpired = abi.decode(returnData, (bool));</span>
 183 | *   | <span class='executed'>            fl.log(&quot;getPendingOrders::isOrderExpired&quot;, isOrderExpired);</span>
 184 |     | <span class='neutral'>            // Validate the order</span>
 185 |     | <span class='neutral'></span>
 186 | *   | <span class='executed'>            if (order.request.sizeDelta != 0) {</span>
 187 | *   | <span class='executed'>                require(</span>
 188 | *   | <span class='executed'>                    isOrderExpired,</span>
 189 |     | <span class='neutral'>                    &quot;Current order not expired. No unsettled orders&quot;</span>
 190 |     | <span class='neutral'>                );</span>
 191 |     | <span class='neutral'>            }</span>
 192 | *   | <span class='executed'>            require(order.request.sizeDelta == 0, &quot;No unsettled orders&quot;);</span>
 193 |     | <span class='neutral'>        }</span>
 194 |     | <span class='neutral'>    }</span>
 195 | *   | <span class='executed'>    function closeAllPositions(uint128 accountId) internal {</span>
 196 | *   | <span class='executed'>        uint128[] memory marketIds = new uint128[](2);</span>
 197 | *   | <span class='executed'>        marketIds[0] = 1; // WETH market</span>
 198 | *   | <span class='executed'>        marketIds[1] = 2; // WBTC market</span>
 199 |     | <span class='neutral'></span>
 200 | *   | <span class='executed'>        for (uint i = 0; i &lt; marketIds.length; i++) {</span>
 201 | *   | <span class='executed'>            uint128 marketId = marketIds[i];</span>
 202 | *   | <span class='executed'>            bool isWETH = (marketId == 1);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>            // Get open position</span>
 205 | *   | <span class='executed'>            (bool success, bytes memory returnData) = perps.call(</span>
 206 | *   | <span class='executed'>                abi.encodeWithSelector(</span>
 207 |     | <span class='neutral'>                    perpsAccountModuleImpl.getOpenPosition.selector,</span>
 208 |     | <span class='neutral'>                    accountId,</span>
 209 |     | <span class='neutral'>                    marketId</span>
 210 |     | <span class='neutral'>                )</span>
 211 |     | <span class='neutral'>            );</span>
 212 | *   | <span class='executed'>            if (success) {</span>
 213 | *   | <span class='executed'>                (</span>
 214 | *   | <span class='executed'>                    int256 totalPnl,</span>
 215 | *   | <span class='executed'>                    int256 accruedFunding,</span>
 216 | *   | <span class='executed'>                    int128 positionSize,</span>
 217 | *   | <span class='executed'>                    uint256 owedInterest</span>
 218 | *   | <span class='executed'>                ) = abi.decode(returnData, (int256, int256, int128, uint256));</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>                // If position size is not zero, close the position</span>
 221 | *   | <span class='executed'>                if (positionSize != 0) {</span>
 222 | *   | <span class='executed'>                    vm.prank(accountIdToUser[accountId]);</span>
 223 | *   | <span class='executed'>                    fuzz_commitOrder(</span>
 224 | *   | <span class='executed'>                        int128(uint128(positionSize)) * -1,</span>
 225 | *   | <span class='executed'>                        isWETH ? 6 : 5 // 6 for WETH (marketId 1), 5 for WBTC (marketId 2)</span>
 226 |     | <span class='neutral'>                    );</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>                    // Settle the order</span>
 229 | *   | <span class='executed'>                    fuzz_settleOrder();</span>
 230 |     | <span class='neutral'>                }</span>
 231 |     | <span class='neutral'>            }</span>
 232 |     | <span class='neutral'>        }</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 | *   | <span class='executed'>    function fuzz_withdrawAllCollateral(</span>
 236 |     | <span class='neutral'>        uint128 accountId,</span>
 237 |     | <span class='neutral'>        bool weth,</span>
 238 |     | <span class='neutral'>        bool wbtc,</span>
 239 |     | <span class='neutral'>        bool huge</span>
 240 |     | <span class='neutral'>    ) internal {</span>
 241 | *   | <span class='executed'>        uint128[] memory collateralIds = new uint128[](4);</span>
 242 | *   | <span class='executed'>        uint8 collateralCount = 0;</span>
 243 |     | <span class='neutral'></span>
 244 | *   | <span class='executed'>        if (weth) {</span>
 245 | *   | <span class='executed'>            collateralIds[collateralCount] = 1;</span>
 246 | *   | <span class='executed'>            collateralCount++;</span>
 247 |     | <span class='neutral'>        }</span>
 248 | *   | <span class='executed'>        if (wbtc) {</span>
 249 | *   | <span class='executed'>            collateralIds[collateralCount] = 2;</span>
 250 | *   | <span class='executed'>            collateralCount++;</span>
 251 |     | <span class='neutral'>        }</span>
 252 | *   | <span class='executed'>        if (huge) {</span>
 253 | *   | <span class='executed'>            collateralIds[collateralCount] = 3;</span>
 254 | *   | <span class='executed'>            collateralCount++;</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'>        //finally, always susd</span>
 257 | *   | <span class='executed'>        collateralIds[collateralCount] = 0;</span>
 258 | *   | <span class='executed'>        collateralCount++;</span>
 259 | *   | <span class='executed'>        for (uint i = 0; i &lt; collateralCount; i++) {</span>
 260 | *   | <span class='executed'>            uint128 collateralId = collateralIds[i];</span>
 261 |     | <span class='neutral'>            // Get collateral amount</span>
 262 | *   | <span class='executed'>            (bool success, bytes memory returnData) = perps.call(</span>
 263 | *   | <span class='executed'>                abi.encodeWithSelector(</span>
 264 |     | <span class='neutral'>                    perpsAccountModuleImpl.getCollateralAmount.selector,</span>
 265 |     | <span class='neutral'>                    accountId,</span>
 266 |     | <span class='neutral'>                    collateralId</span>
 267 |     | <span class='neutral'>                )</span>
 268 |     | <span class='neutral'>            );</span>
 269 | *   | <span class='executed'>            fl.t(</span>
 270 |     | <span class='neutral'>                success,</span>
 271 |     | <span class='neutral'>                &quot;perpsAccountModuleImpl.getCollateralAmount call failed&quot;</span>
 272 |     | <span class='neutral'>            );</span>
 273 | *   | <span class='executed'>            uint256 amount = abi.decode(returnData, (uint256));</span>
 274 | *   | <span class='executed'>            fl.log(&quot;fuzz_withdrawAllCollateral::CollateralID,&quot;, collateralId);</span>
 275 | *   | <span class='executed'>            fl.log(&quot;fuzz_withdrawAllCollateral::amount,&quot;, amount);</span>
 276 |     | <span class='neutral'></span>
 277 | *   | <span class='executed'>            if (amount &gt; 0) {</span>
 278 | *   | <span class='executed'>                vm.prank(accountIdToUser[accountId]);</span>
 279 | *   | <span class='executed'>                withdraw(accountId, collateralId, -int256(amount));</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>                // (success, returnData) = perps.call(</span>
 282 |     | <span class='neutral'>                //     abi.encodeWithSelector(</span>
 283 |     | <span class='neutral'>                //         perpsAccountModuleImpl.modifyCollateral.selector,</span>
 284 |     | <span class='neutral'>                //         accountId,</span>
 285 |     | <span class='neutral'>                //         collateralId,</span>
 286 |     | <span class='neutral'>                //         -int256(amount)</span>
 287 |     | <span class='neutral'>                //     )</span>
 288 |     | <span class='neutral'>                // );</span>
 289 |     | <span class='neutral'>                // require(success);</span>
 290 |     | <span class='neutral'>            }</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    function deposit(</span>
 295 |     | <span class='neutral'>        uint128 accountId,</span>
 296 |     | <span class='neutral'>        uint128 collateralId,</span>
 297 |     | <span class='neutral'>        int delta</span>
 298 |     | <span class='neutral'>    ) internal {</span>
 299 |     | <span class='neutral'>        address user;</span>
 300 |     | <span class='neutral'>        if (accountId == 1) {</span>
 301 |     | <span class='neutral'>            user = USER1;</span>
 302 |     | <span class='neutral'>        } else if (accountId == 2) {</span>
 303 |     | <span class='neutral'>            user = USER2;</span>
 304 |     | <span class='neutral'>        } else {</span>
 305 |     | <span class='neutral'>            user = USER3;</span>
 306 |     | <span class='neutral'>        }</span>
 307 |     | <span class='neutral'>        vm.prank(user);</span>
 308 |     | <span class='neutral'>        (bool success, bytes memory returnData) = perps.call(</span>
 309 |     | <span class='neutral'>            abi.encodeWithSelector(</span>
 310 |     | <span class='neutral'>                perpsAccountModuleImpl.modifyCollateral.selector,</span>
 311 |     | <span class='neutral'>                accountId,</span>
 312 |     | <span class='neutral'>                collateralId,</span>
 313 |     | <span class='neutral'>                delta</span>
 314 |     | <span class='neutral'>            )</span>
 315 |     | <span class='neutral'>        );</span>
 316 |     | <span class='neutral'>        if (!success) {</span>
 317 |     | <span class='neutral'>            if (returnData.length &gt; 0) {</span>
 318 |     | <span class='neutral'>                string memory errorMessage = abi.decode(returnData, (string));</span>
 319 |     | <span class='neutral'>                revert(errorMessage);</span>
 320 |     | <span class='neutral'>            } else {</span>
 321 |     | <span class='neutral'>                revert(&quot;Call to perps contract failed&quot;);</span>
 322 |     | <span class='neutral'>            }</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>    }</span>
 325 | *   | <span class='executed'>    function withdraw(</span>
 326 |     | <span class='neutral'>        uint128 accountId,</span>
 327 |     | <span class='neutral'>        uint128 collateralId,</span>
 328 |     | <span class='neutral'>        int delta</span>
 329 |     | <span class='neutral'>    ) internal {</span>
 330 | *   | <span class='executed'>        address user;</span>
 331 | *   | <span class='executed'>        if (accountId == 1) {</span>
 332 |     | <span class='neutral'>            user = USER1;</span>
 333 | *   | <span class='executed'>        } else if (accountId == 2) {</span>
 334 |     | <span class='neutral'>            user = USER2;</span>
 335 |     | <span class='neutral'>        } else {</span>
 336 |     | <span class='neutral'>            user = USER3;</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='neutral'>        // vm.prank(user);</span>
 339 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
 340 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 341 |     | <span class='neutral'>                perpsAccountModuleImpl.modifyCollateral.selector,</span>
 342 |     | <span class='neutral'>                accountId,</span>
 343 |     | <span class='neutral'>                collateralId,</span>
 344 |     | <span class='neutral'>                delta</span>
 345 |     | <span class='neutral'>            )</span>
 346 |     | <span class='neutral'>        );</span>
 347 | *   | <span class='executed'>        if (!success) {</span>
 348 | *   | <span class='executed'>            if (returnData.length &gt; 0) {</span>
 349 | *   | <span class='executed'>                string memory errorMessage = abi.decode(returnData, (string));</span>
 350 |     | <span class='unexecuted'>                revert(errorMessage);</span>
 351 |     | <span class='neutral'>            } else {</span>
 352 |     | <span class='unexecuted'>                revert(&quot;Call to perps contract failed&quot;);</span>
 353 |     | <span class='neutral'>            }</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'>}</span>
 357 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzLiquidationModule.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzSetup.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./helper/preconditions/PreconditionsLiquidationModule.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./helper/postconditions/PostconditionsLiquidationModule.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./util/FunctionCalls.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @title FuzzLiquidationModule</span>
  11 |     | <span class='neutral'> * @author 0xScourgedev</span>
  12 |     | <span class='neutral'> * @notice Fuzz handlers for LiquidationModule</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>contract FuzzLiquidationModule is</span>
  15 |     | <span class='neutral'>    PreconditionsLiquidationModule,</span>
  16 |     | <span class='neutral'>    PostconditionsLiquidationModule</span>
  17 |     | <span class='neutral'>{</span>
  18 |     | <span class='neutral'>    event Debug(string s);</span>
  19 |     | <span class='neutral'>    event LogBytes(bytes data);</span>
  20 |     | <span class='neutral'></span>
  21 | *   | <span class='executed'>    function fuzz_liquidatePosition() public setCurrentActor {</span>
  22 | *   | <span class='executed'>        LiquidatePositionParams</span>
  23 | *   | <span class='executed'>            memory params = liquidatePositionPreconditions();</span>
  24 |     | <span class='neutral'></span>
  25 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](2);</span>
  26 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor; //This is liquidator</span>
  27 | *   | <span class='executed'>        actorsToUpdate[1] = params.user;</span>
  28 |     | <span class='neutral'></span>
  29 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _liquidatePositionCall(</span>
  32 | *   | <span class='executed'>            params.accountId</span>
  33 |     | <span class='neutral'>        );</span>
  34 |     | <span class='neutral'></span>
  35 | *   | <span class='executed'>        liquidatePositionPostconditions(</span>
  36 | *   | <span class='executed'>            success,</span>
  37 | *   | <span class='executed'>            returnData,</span>
  38 | *   | <span class='executed'>            actorsToUpdate,</span>
  39 | *   | <span class='executed'>            params.user,</span>
  40 | *   | <span class='executed'>            currentActor,</span>
  41 | *   | <span class='executed'>            params.accountId</span>
  42 |     | <span class='neutral'>        );</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 | *   | <span class='executed'>    function fuzz_liquidateMarginOnly() public setCurrentActor {</span>
  46 | *   | <span class='executed'>        LiquidateMarginOnlyParams</span>
  47 | *   | <span class='executed'>            memory params = liquidateMarginOnlyPreconditions();</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](2);</span>
  50 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor; //This is liquidator</span>
  51 | *   | <span class='executed'>        actorsToUpdate[1] = params.user;</span>
  52 |     | <span class='neutral'></span>
  53 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
  54 |     | <span class='neutral'></span>
  55 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _liquidateMarginOnlyCall(</span>
  56 | *   | <span class='executed'>            params.accountId</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'></span>
  59 | *   | <span class='executed'>        liquidateMarginOnlyPostconditions(</span>
  60 | *   | <span class='executed'>            success,</span>
  61 | *   | <span class='executed'>            returnData,</span>
  62 | *   | <span class='executed'>            actorsToUpdate,</span>
  63 | *   | <span class='executed'>            params.user,</span>
  64 | *   | <span class='executed'>            params.accountId</span>
  65 |     | <span class='neutral'>        );</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 | *   | <span class='executed'>    function fuzz_liquidateFlagged(</span>
  69 |     | <span class='neutral'>        uint8 maxNumberOfAccounts</span>
  70 | *   | <span class='executed'>    ) public setCurrentActor {</span>
  71 | *   | <span class='executed'>        LiquidateFlaggedParams memory params = liquidateFlaggedPreconditions(</span>
  72 | *   | <span class='executed'>            maxNumberOfAccounts</span>
  73 |     | <span class='neutral'>        );</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](2);</span>
  76 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor; //This is liquidator</span>
  77 |     | <span class='neutral'></span>
  78 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
  79 |     | <span class='neutral'></span>
  80 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _liquidateFlaggedCall(</span>
  81 | *   | <span class='executed'>            params.numberOfAccounts</span>
  82 |     | <span class='neutral'>        );</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        liquidateFlaggedPostconditions(</span>
  85 | *   | <span class='executed'>            success,</span>
  86 | *   | <span class='executed'>            returnData,</span>
  87 | *   | <span class='executed'>            actorsToUpdate,</span>
  88 | *   | <span class='executed'>            params.flaggedAccounts</span>
  89 |     | <span class='neutral'>        );</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>    function fuzz_liquidateFlaggedAccounts(</span>
  93 |     | <span class='neutral'>        uint8 maxNumberOfAccounts</span>
  94 |     | <span class='neutral'>    ) public setCurrentActor {</span>
  95 | *   | <span class='executed'>        LiquidateFlaggedParams memory params = liquidateFlaggedPreconditions(</span>
  96 | *   | <span class='executed'>            maxNumberOfAccounts</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](2);</span>
 100 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor; //This is liquidator</span>
 101 |     | <span class='neutral'></span>
 102 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _liquidateFlaggedAccountsCall(</span>
 105 | *   | <span class='executed'>            params.flaggedAccounts</span>
 106 |     | <span class='neutral'>        );</span>
 107 |     | <span class='neutral'></span>
 108 | *   | <span class='executed'>        luquidateFlaggedAccountsPostconditions(</span>
 109 | *   | <span class='executed'>            success,</span>
 110 | *   | <span class='executed'>            returnData,</span>
 111 | *   | <span class='executed'>            actorsToUpdate,</span>
 112 | *   | <span class='executed'>            params.flaggedAccounts</span>
 113 |     | <span class='neutral'>        );</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'>}</span>
 116 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzModules.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import &quot;./FuzzGuidedModule.sol&quot;;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='unexecuted'>contract FuzzModules is FuzzGuidedModule {}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzOrderModule.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzSetup.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./helper/preconditions/PreconditionsOrderModule.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./helper/postconditions/PostconditionsOrderModule.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./util/FunctionCalls.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../storage/Position.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract FuzzOrderModule is</span>
  11 |     | <span class='neutral'>    PreconditionsOrderModule,</span>
  12 |     | <span class='neutral'>    PostconditionsOrderModule</span>
  13 |     | <span class='neutral'>{</span>
  14 | *   | <span class='executed'>    mapping(uint128 accountId =&gt; CommitOrderParams params) public pendingOrder;</span>
  15 |     | <span class='neutral'></span>
  16 | *   | <span class='executed'>    function fuzz_commitOrder(</span>
  17 |     | <span class='neutral'>        int128 sizeDelta,</span>
  18 |     | <span class='neutral'>        uint256 acceptablePrice</span>
  19 | *   | <span class='executed'>    ) public setCurrentActor {</span>
  20 | *   | <span class='executed'>        console2.log(&quot;===== FuzzOrderModule::fuzz_commitOrder START =====&quot;);</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
  23 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  24 | *   | <span class='executed'>        console2.log(&quot;===== _currentActor  =====&quot;, msg.sender);</span>
  25 |     | <span class='neutral'></span>
  26 | *   | <span class='executed'>        bytes32 trackingCode;</span>
  27 | *   | <span class='executed'>        address referrer;</span>
  28 | *   | <span class='executed'>        int128 positionSize;</span>
  29 | *   | <span class='executed'>        console2.log(&quot;msg.sender&quot;, msg.sender);</span>
  30 | *   | <span class='executed'>        console2.log(&quot;===== _before START =====&quot;);</span>
  31 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
  32 | *   | <span class='executed'>        console2.log(&quot;msg.sender&quot;, msg.sender);</span>
  33 |     | <span class='neutral'></span>
  34 | *   | <span class='executed'>        console2.log(&quot;===== _before END =====&quot;);</span>
  35 |     | <span class='neutral'></span>
  36 | *   | <span class='executed'>        console2.log(&quot;===== commitOrderPreconditions START =====&quot;);</span>
  37 | *   | <span class='executed'>        CommitOrderParams memory params = commitOrderPreconditions(</span>
  38 | *   | <span class='executed'>            sizeDelta,</span>
  39 | *   | <span class='executed'>            acceptablePrice,</span>
  40 | *   | <span class='executed'>            trackingCode,</span>
  41 | *   | <span class='executed'>            referrer</span>
  42 |     | <span class='neutral'>        );</span>
  43 |     | <span class='neutral'></span>
  44 | *   | <span class='executed'>        require(params.marketId != 0);</span>
  45 | *   | <span class='executed'>        _beforeSettlement(params.accountId, params.marketId);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // require(pendingOrder[params.accountId].accountId == uint128(0), &quot;User has a pending order&quot;);</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>        console2.log(&quot;msg.sender&quot;, msg.sender);</span>
  50 |     | <span class='neutral'></span>
  51 | *   | <span class='executed'>        console2.log(&quot;===== commitOrderPreconditions END =====&quot;);</span>
  52 |     | <span class='neutral'></span>
  53 | *   | <span class='executed'>        positionSize = params.marketId == 1</span>
  54 | *   | <span class='executed'>            ? states[0].actorStates[params.accountId].wethMarket.positionSize</span>
  55 | *   | <span class='executed'>            : states[0].actorStates[params.accountId].wbtcMarket.positionSize;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // Close position entirely.</span>
  58 | *   | <span class='executed'>        if (acceptablePrice % 5 == 0 &amp;&amp; positionSize != 0) {</span>
  59 | *   | <span class='executed'>            params.sizeDelta = positionSize * -1;</span>
  60 |     | <span class='neutral'>        }</span>
  61 | *   | <span class='executed'>        console2.log(&quot;===== _commitOrderCall START =====&quot;);</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _commitOrderCall(</span>
  64 | *   | <span class='executed'>            params.accountId,</span>
  65 | *   | <span class='executed'>            params.marketId,</span>
  66 | *   | <span class='executed'>            params.sizeDelta,</span>
  67 | *   | <span class='executed'>            params.acceptablePrice,</span>
  68 | *   | <span class='executed'>            params.settlementStrategyId,</span>
  69 | *   | <span class='executed'>            params.trackingCode,</span>
  70 | *   | <span class='executed'>            params.referrer</span>
  71 |     | <span class='neutral'>        );</span>
  72 | *   | <span class='executed'>        console2.log(&quot;===== _commitOrderCall END =====&quot;);</span>
  73 | *   | <span class='executed'>        console2.log(&quot;===== commitOrderPostconditions START =====&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>        commitOrderPostconditions(</span>
  76 | *   | <span class='executed'>            success,</span>
  77 | *   | <span class='executed'>            returnData,</span>
  78 | *   | <span class='executed'>            actorsToUpdate,</span>
  79 | *   | <span class='executed'>            params.accountId,</span>
  80 | *   | <span class='executed'>            params.marketId</span>
  81 |     | <span class='neutral'>        );</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>        pendingOrder[params.accountId] = params;</span>
  84 | *   | <span class='executed'>        console2.log(&quot;===== commitOrderPostconditions END =====&quot;);</span>
  85 |     | <span class='neutral'></span>
  86 | *   | <span class='executed'>        console2.log(&quot;===== FuzzOrderModule::fuzz_commitOrder END =====&quot;);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function fuzz_settleOrder() public setCurrentActor {</span>
  90 | *   | <span class='executed'>        SettleOrderParams memory params = settleOrderPreconditions();</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](2);</span>
  93 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
  94 | *   | <span class='executed'>        actorsToUpdate[1] = params.settleUser;</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
  97 |     | <span class='neutral'></span>
  98 | *   | <span class='executed'>        fl.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;CURRENT ACTOR:&quot;, currentActor);</span>
  99 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _settleOrderCall(</span>
 100 | *   | <span class='executed'>            actorsToUpdate[1],</span>
 101 | *   | <span class='executed'>            params.accountId</span>
 102 |     | <span class='neutral'>        );</span>
 103 |     | <span class='neutral'>        // if (success &amp;&amp; (params.sizeDelta &lt; 0)) {</span>
 104 |     | <span class='neutral'>        //     fl.eq(params.sizeDelta, 0, &quot;SO SIZE NEGATIVE SETTLED&quot;);</span>
 105 |     | <span class='neutral'>        // }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>        if (pendingOrder[params.accountId].marketId != 0) {</span>
 108 | *   | <span class='executed'>            settleOrderPostconditions(</span>
 109 | *   | <span class='executed'>                success,</span>
 110 | *   | <span class='executed'>                returnData,</span>
 111 | *   | <span class='executed'>                actorsToUpdate,</span>
 112 | *   | <span class='executed'>                params.settleUser,</span>
 113 | *   | <span class='executed'>                params.accountId,</span>
 114 | *   | <span class='executed'>                pendingOrder[params.accountId].marketId</span>
 115 |     | <span class='neutral'>            );</span>
 116 |     | <span class='neutral'>        }</span>
 117 | *   | <span class='executed'>        delete pendingOrder[params.accountId];</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 | *   | <span class='executed'>    function fuzz_cancelOrder(uint8 cancelUser) public setCurrentActor {</span>
 121 | *   | <span class='executed'>        CancelOrderParams memory params = cancelOrderPreconditions(cancelUser);</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](2);</span>
 124 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 125 | *   | <span class='executed'>        actorsToUpdate[1] = params.cancelUser;</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
 128 |     | <span class='neutral'></span>
 129 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _cancelOrderCall(</span>
 130 | *   | <span class='executed'>            actorsToUpdate[1],</span>
 131 | *   | <span class='executed'>            params.accountId</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='neutral'></span>
 134 | *   | <span class='executed'>        cancelOrderPostconditions(</span>
 135 | *   | <span class='executed'>            success,</span>
 136 | *   | <span class='executed'>            returnData,</span>
 137 | *   | <span class='executed'>            actorsToUpdate,</span>
 138 | *   | <span class='executed'>            params.cancelUser,</span>
 139 | *   | <span class='executed'>            params.accountId</span>
 140 |     | <span class='neutral'>        );</span>
 141 | *   | <span class='executed'>        delete pendingOrder[params.accountId];</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzPerpsAccountModule.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./helper/preconditions/PreconditionsPerpsAccountModule.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./helper/postconditions/PostconditionsPerpsAccountModule.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./util/FunctionCalls.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract FuzzPerpsAccountModule is</span>
  9 |     | <span class='neutral'>    PreconditionsPerpsAccountModule,</span>
 10 |     | <span class='neutral'>    PostconditionsPerpsAccountModule</span>
 11 |     | <span class='neutral'>{</span>
 12 |     | <span class='neutral'>    event DebugPerpsAccount(string s);</span>
 13 | *   | <span class='executed'>    function fuzz_modifyCollateral(</span>
 14 |     | <span class='neutral'>        int256 amountDelta,</span>
 15 |     | <span class='neutral'>        uint collateralTokenIndex</span>
 16 | *   | <span class='executed'>    ) public setCurrentActor {</span>
 17 | *   | <span class='executed'>        ModifyCollateralParams memory params = modifyCollateralPreconditions(</span>
 18 | *   | <span class='executed'>            amountDelta,</span>
 19 | *   | <span class='executed'>            collateralTokenIndex</span>
 20 |     | <span class='neutral'>        );</span>
 21 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 22 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 23 | *   | <span class='executed'>        emit DebugPerpsAccount(&quot;HERE#1&quot;);</span>
 24 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
 25 | *   | <span class='executed'>        emit DebugPerpsAccount(&quot;HERE#2&quot;);</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _modifyCollateralCall(</span>
 28 | *   | <span class='executed'>            params.accountId,</span>
 29 | *   | <span class='executed'>            params.collateralId,</span>
 30 | *   | <span class='executed'>            params.amountDelta</span>
 31 |     | <span class='neutral'>        );</span>
 32 | *   | <span class='executed'>        emit DebugPerpsAccount(&quot;HERE#3&quot;);</span>
 33 |     | <span class='neutral'></span>
 34 | *   | <span class='executed'>        modifyCollateralPostconditions(</span>
 35 | *   | <span class='executed'>            params.amountDelta,</span>
 36 | *   | <span class='executed'>            success,</span>
 37 | *   | <span class='executed'>            returnData,</span>
 38 | *   | <span class='executed'>            actorsToUpdate,</span>
 39 | *   | <span class='executed'>            params.collateralAddress,</span>
 40 | *   | <span class='executed'>            params.accountId</span>
 41 |     | <span class='neutral'>        );</span>
 42 | *   | <span class='executed'>        emit DebugPerpsAccount(&quot;HERE#4&quot;);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 | *   | <span class='executed'>    function fuzz_payDebt(uint128 amount) public setCurrentActor {</span>
 46 | *   | <span class='executed'>        PayDebtParams memory params = payDebtPreconditions(amount);</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>        address[] memory actorsToUpdate = new address[](1);</span>
 49 | *   | <span class='executed'>        actorsToUpdate[0] = currentActor;</span>
 50 |     | <span class='neutral'></span>
 51 | *   | <span class='executed'>        _before(actorsToUpdate);</span>
 52 |     | <span class='neutral'></span>
 53 | *   | <span class='executed'>        (bool success, bytes memory returnData) = _payDebtCall(</span>
 54 | *   | <span class='executed'>            params.accountId,</span>
 55 | *   | <span class='executed'>            params.amount</span>
 56 |     | <span class='neutral'>        );</span>
 57 |     | <span class='neutral'></span>
 58 | *   | <span class='executed'>        payDebtPostconditions(</span>
 59 | *   | <span class='executed'>            success,</span>
 60 | *   | <span class='executed'>            returnData,</span>
 61 | *   | <span class='executed'>            actorsToUpdate,</span>
 62 | *   | <span class='executed'>            params.accountId</span>
 63 |     | <span class='neutral'>        );</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzSetup.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
    3 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
    4 |     | <span class='neutral'>import {MarketConfiguration} from &quot;../../storage.dump.sol&quot;;</span>
    5 |     | <span class='neutral'>import {Flags} from &quot;../utils/Flags.sol&quot;;</span>
    6 |     | <span class='neutral'>import {AccountRBAC} from &quot;@synthetixio/main/contracts/storage/AccountRBAC.sol&quot;;</span>
    7 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
    8 |     | <span class='neutral'></span>
    9 |     | <span class='neutral'>import &quot;./helper/FuzzStorageVariables.sol&quot;;</span>
   10 |     | <span class='unexecuted'>contract FuzzSetup is FuzzBase, FuzzStorageVariables {</span>
   11 |     | <span class='unexecuted'>    function setup() internal {</span>
   12 |     | <span class='neutral'>        //Foundry comparibility</span>
   13 |     | <span class='unexecuted'>        checkCaller = new CheckCaller();</span>
   14 |     | <span class='neutral'></span>
   15 |     | <span class='unexecuted'>        router = new MockRouter();</span>
   16 |     | <span class='unexecuted'>        perps = address(new Proxy(address(router), address(this)));</span>
   17 |     | <span class='neutral'></span>
   18 |     | <span class='unexecuted'>        deployImplementations();</span>
   19 |     | <span class='neutral'></span>
   20 |     | <span class='unexecuted'>        addAsyncOrderModuleSels();</span>
   21 |     | <span class='unexecuted'>        addAsyncOrderCancelModuleSels();</span>
   22 |     | <span class='unexecuted'>        addAsyncOrderSettlementPythModuleSels();</span>
   23 |     | <span class='unexecuted'>        addCollateralConfigurationModuleSels();</span>
   24 |     | <span class='unexecuted'>        addGlobalPerpsMarketModuleSels();</span>
   25 |     | <span class='unexecuted'>        addMarketConfigurationModuleSels();</span>
   26 |     | <span class='unexecuted'>        addPerpsAccountModuleSels();</span>
   27 |     | <span class='unexecuted'>        addPerpsMarketFactoryModuleSels();</span>
   28 |     | <span class='unexecuted'>        addPerpsMarketModuleSels();</span>
   29 |     | <span class='unexecuted'>        addLiquidationModuleSels();</span>
   30 |     | <span class='unexecuted'>        addMockLensModuleSels();</span>
   31 |     | <span class='unexecuted'>        addFeatureFlagModuleSels();</span>
   32 |     | <span class='unexecuted'>        addMockModuleSels();</span>
   33 |     | <span class='unexecuted'>        addMockPythERC7412WrapperSels();</span>
   34 |     | <span class='neutral'>        //bootstrap()</span>
   35 |     | <span class='unexecuted'>        setPythPriceFeed();</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='unexecuted'>        addWETHSettlementStrategy();</span>
   38 |     | <span class='unexecuted'>        addWBTCSettlementStrategy();</span>
   39 |     | <span class='unexecuted'>        addHUGESettlementStrategy();</span>
   40 |     | <span class='unexecuted'>        setSnxUSDCollateralConfiguration();</span>
   41 |     | <span class='unexecuted'>        setWETHCollateralConfiguration();</span>
   42 |     | <span class='unexecuted'>        setWBTCCollateralConfiguration();</span>
   43 |     | <span class='unexecuted'>        setHUGECollateralConfiguration();</span>
   44 |     | <span class='unexecuted'>        registerWETHDistributor();</span>
   45 |     | <span class='unexecuted'>        registerWBTCDistributor();</span>
   46 |     | <span class='unexecuted'>        registerHugeDistributor();</span>
   47 |     | <span class='unexecuted'>        setSynthMaketIdAndAddresses();</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>        //bootstrapPerpsMarkets()</span>
   50 |     | <span class='unexecuted'>        addToFeatureFlagAllowlist();</span>
   51 |     | <span class='unexecuted'>        enableAllFeatureFlags();</span>
   52 |     | <span class='unexecuted'>        initializePerpsMarketFactory();</span>
   53 |     | <span class='unexecuted'>        setPerpsMarketName();</span>
   54 |     | <span class='unexecuted'>        setCreateMarketWETH();</span>
   55 |     | <span class='unexecuted'>        setCreateMarketWBTC();</span>
   56 |     | <span class='unexecuted'>        setCreateMarketHUGE();</span>
   57 |     | <span class='unexecuted'>        setUpdatePriceDataWETH();</span>
   58 |     | <span class='unexecuted'>        setUpdatePriceDataWBTC();</span>
   59 |     | <span class='unexecuted'>        setUpdatePriceDataHUGE();</span>
   60 |     | <span class='unexecuted'>        setFundingParametersWETH();</span>
   61 |     | <span class='unexecuted'>        setFundingParametersWBTC();</span>
   62 |     | <span class='unexecuted'>        setFundingParametersHUGE();</span>
   63 |     | <span class='unexecuted'>        setMaxMarketSizeWETH();</span>
   64 |     | <span class='unexecuted'>        setMaxMarketSizeWBTC();</span>
   65 |     | <span class='unexecuted'>        setMaxMarketSizeHUGE();</span>
   66 |     | <span class='unexecuted'>        setMaxMarketValueWETH();</span>
   67 |     | <span class='unexecuted'>        setMaxMarketValueWBTC();</span>
   68 |     | <span class='unexecuted'>        setMaxMarketValueHUGE();</span>
   69 |     | <span class='unexecuted'>        setOrderFeesWETH();</span>
   70 |     | <span class='unexecuted'>        setOrderFeesWBTC();</span>
   71 |     | <span class='unexecuted'>        setOrderFeesHUGE();</span>
   72 |     | <span class='unexecuted'>        setLiquidationParametersWETH();</span>
   73 |     | <span class='unexecuted'>        setLiquidationParametersWBTC();</span>
   74 |     | <span class='unexecuted'>        setLiquidationParametersHUGE();</span>
   75 |     | <span class='unexecuted'>        setMaxLiquidationParametersWETH();</span>
   76 |     | <span class='unexecuted'>        setMaxLiquidationParametersWBTC();</span>
   77 |     | <span class='unexecuted'>        setMaxLiquidationParametersHUGE();</span>
   78 |     | <span class='unexecuted'>        createKeeperCostNode();</span>
   79 |     | <span class='unexecuted'>        updateKeeperCostNodeId();</span>
   80 |     | <span class='unexecuted'>        createAccounts();</span>
   81 |     | <span class='unexecuted'>        grantAccountPermissions();</span>
   82 |     | <span class='unexecuted'>        setMaxCollateralsPerAccount();</span>
   83 |     | <span class='unexecuted'>        setPerpMarketFactoryModuleImplInVault();</span>
   84 |     | <span class='unexecuted'>        setPythWrappeInLens();</span>
   85 |     | <span class='unexecuted'>        setupActors();</span>
   86 |     | <span class='neutral'>    }</span>
   87 |     | <span class='neutral'></span>
   88 |     | <span class='unexecuted'>    function deployImplementations() private {</span>
   89 |     | <span class='unexecuted'>        sUSDTokenMock = new MockERC20(&quot;sUSD Token&quot;, &quot;sUSD&quot;, 18);</span>
   90 |     | <span class='unexecuted'>        wethTokenMock = new MockERC20(&quot;weth Token&quot;, &quot;WETH&quot;, 18);</span>
   91 |     | <span class='unexecuted'>        wbtcTokenMock = new MockERC20(&quot;wbtc Token&quot;, &quot;WBTC&quot;, 18);</span>
   92 |     | <span class='unexecuted'>        hugePrecisionTokenMock = new MockERC20(</span>
   93 |     | <span class='neutral'>            &quot;Huge Precision Token&quot;,</span>
   94 |     | <span class='neutral'>            &quot;HUGE&quot;,</span>
   95 |     | <span class='unexecuted'>            30</span>
   96 |     | <span class='neutral'>        );</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='unexecuted'>        v3Mock = new MockSynthetixV3();</span>
   99 |     | <span class='neutral'></span>
  100 |     | <span class='unexecuted'>        deployMockOracleManager();</span>
  101 |     | <span class='unexecuted'>        deployMockSpotMarket();</span>
  102 |     | <span class='unexecuted'>        deployMockPythERC7412Wrapper();</span>
  103 |     | <span class='neutral'></span>
  104 |     | <span class='unexecuted'>        setOracleManager();</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='unexecuted'>        setMockSynthetixUSDToken();</span>
  107 |     | <span class='unexecuted'>        setMockWethToken();</span>
  108 |     | <span class='unexecuted'>        setMockWbtcToken();</span>
  109 |     | <span class='unexecuted'>        setMockhugeToken();</span>
  110 |     | <span class='neutral'>        // increaseCreditCapacity();</span>
  111 |     | <span class='neutral'></span>
  112 |     | <span class='unexecuted'>        coreModuleImpl = new CoreModule();</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='unexecuted'>        asyncOrderCancelModuleImpl = new AsyncOrderCancelModule();</span>
  115 |     | <span class='unexecuted'>        asyncOrderModuleImpl = new AsyncOrderModule();</span>
  116 |     | <span class='unexecuted'>        asyncOrderSettlementPythModuleImpl = new AsyncOrderSettlementPythModule();</span>
  117 |     | <span class='unexecuted'>        collateralConfigurationModuleImpl = new CollateralConfigurationModule();</span>
  118 |     | <span class='unexecuted'>        featureFlagModuleImpl = new FeatureFlagModule();</span>
  119 |     | <span class='unexecuted'>        globalPerpsMarketModuleImpl = new GlobalPerpsMarketModule();</span>
  120 |     | <span class='unexecuted'>        liquidationModuleImpl = new LiquidationModule();</span>
  121 |     | <span class='unexecuted'>        marketConfigurationModuleImpl = new MarketConfigurationModule();</span>
  122 |     | <span class='unexecuted'>        perpsAccountModuleImpl = new PerpsAccountModule();</span>
  123 |     | <span class='unexecuted'>        perpsMarketFactoryModuleImpl = new PerpsMarketFactoryModule();</span>
  124 |     | <span class='unexecuted'>        perpsMarketModuleImpl = new PerpsMarketModule();</span>
  125 |     | <span class='neutral'></span>
  126 |     | <span class='neutral'>        //Mocks</span>
  127 |     | <span class='unexecuted'>        mockModuleImpl = new MockModule();</span>
  128 |     | <span class='unexecuted'>        mockPyth = new MockPyth();</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='unexecuted'>        rewardWETHDistributorMock = new MockRewardDistributor(</span>
  131 |     | <span class='unexecuted'>            v3Mock,</span>
  132 |     | <span class='neutral'>            REWARD_DISTRIBUTOR_WETH_POOL_ID,</span>
  133 |     | <span class='neutral'>            1 //WETH</span>
  134 |     | <span class='neutral'>        );</span>
  135 |     | <span class='unexecuted'>        rewardWBTCDistributorMock = new MockRewardDistributor(</span>
  136 |     | <span class='unexecuted'>            v3Mock,</span>
  137 |     | <span class='neutral'>            REWARD_DISTRIBUTOR_WBTC_POOL_ID,</span>
  138 |     | <span class='neutral'>            2 //WBTC</span>
  139 |     | <span class='neutral'>        );</span>
  140 |     | <span class='unexecuted'>        rewardHUGEDistributorMock = new MockRewardDistributor(</span>
  141 |     | <span class='unexecuted'>            v3Mock,</span>
  142 |     | <span class='neutral'>            REWARD_DISTRIBUTOR_HUGE_POOL_ID,</span>
  143 |     | <span class='neutral'>            3 //WBTC</span>
  144 |     | <span class='neutral'>        );</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='unexecuted'>        vaultModuleMock = new MockVaultModule(v3Mock, perps);</span>
  147 |     | <span class='neutral'></span>
  148 |     | <span class='unexecuted'>        mockLensModuleImpl = new MockLensModule();</span>
  149 |     | <span class='neutral'>    }</span>
  150 |     | <span class='neutral'></span>
  151 |     | <span class='unexecuted'>    function deployMockPythERC7412Wrapper() private {</span>
  152 |     | <span class='unexecuted'>        pythWrapper = new MockPythERC7412Wrapper(address(mockOracleManager));</span>
  153 |     | <span class='unexecuted'>        pythWrapper.setBenchmarkPrice(WETH_FEED_ID, 3_000e18);</span>
  154 |     | <span class='neutral'>        pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, 10_000e18);</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='unexecuted'>    function deployMockOracleManager() private {</span>
  158 |     | <span class='unexecuted'>        bytes32[] memory initialIds = new bytes32[](4);</span>
  159 |     | <span class='unexecuted'>        int256[] memory initialPrices = new int256[](4);</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='unexecuted'>        initialIds[0] = SUSD_ORACLE_NODE_ID;</span>
  162 |     | <span class='unexecuted'>        initialIds[1] = WETH_ORACLE_NODE_ID;</span>
  163 |     | <span class='unexecuted'>        initialIds[2] = WBTC_ORACLE_NODE_ID;</span>
  164 |     | <span class='unexecuted'>        initialIds[3] = KEEPER_NODE_ID;</span>
  165 |     | <span class='neutral'></span>
  166 |     | <span class='unexecuted'>        initialPrices[0] = 1e18;</span>
  167 |     | <span class='unexecuted'>        initialPrices[1] = 3_000e18;</span>
  168 |     | <span class='unexecuted'>        initialPrices[2] = 10_000e18;</span>
  169 |     | <span class='unexecuted'>        initialPrices[3] = 1e18;</span>
  170 |     | <span class='neutral'></span>
  171 |     | <span class='unexecuted'>        tokenChainlinkNode[address(sUSDTokenMock)] = SUSD_ORACLE_NODE_ID;</span>
  172 |     | <span class='unexecuted'>        tokenChainlinkNode[address(wethTokenMock)] = WETH_ORACLE_NODE_ID;</span>
  173 |     | <span class='unexecuted'>        tokenChainlinkNode[address(wbtcTokenMock)] = WBTC_ORACLE_NODE_ID;</span>
  174 |     | <span class='unexecuted'>        tokenChainlinkNode[</span>
  175 |     | <span class='unexecuted'>            address(hugePrecisionTokenMock)</span>
  176 |     | <span class='neutral'>        ] = HUGE_ORACLE_NODE_ID;</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='unexecuted'>        mockOracleManager = new MockOracleManager(initialIds, initialPrices);</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='unexecuted'>    function deployMockSpotMarket() private {</span>
  182 |     | <span class='unexecuted'>        spot = new MockSpotMarket(</span>
  183 |     | <span class='unexecuted'>            v3Mock,</span>
  184 |     | <span class='unexecuted'>            mockOracleManager,</span>
  185 |     | <span class='unexecuted'>            address(wethTokenMock),</span>
  186 |     | <span class='neutral'>            WETH_MARKET_SKEW_SCALE,</span>
  187 |     | <span class='unexecuted'>            address(wbtcTokenMock),</span>
  188 |     | <span class='neutral'>            WBTC_MARKET_SKEW_SCALE,</span>
  189 |     | <span class='unexecuted'>            address(hugePrecisionTokenMock),</span>
  190 |     | <span class='neutral'>            HUGE_MARKET_SKEW_SCALE,</span>
  191 |     | <span class='unexecuted'>            WETH_ORACLE_NODE_ID,</span>
  192 |     | <span class='unexecuted'>            WBTC_ORACLE_NODE_ID,</span>
  193 |     | <span class='neutral'>            HUGE_ORACLE_NODE_ID</span>
  194 |     | <span class='neutral'>        );</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='unexecuted'>    function setOracleManager() private {</span>
  198 |     | <span class='unexecuted'>        v3Mock.setOracleManager(address(mockOracleManager));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='unexecuted'>    function setPythWrappeInLens() private {</span>
  202 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = perps.call(</span>
  203 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  204 |     | <span class='unexecuted'>                mockLensModuleImpl.setPythWrapperAddress.selector,</span>
  205 |     | <span class='unexecuted'>                address(pythWrapper)</span>
  206 |     | <span class='neutral'>            )</span>
  207 |     | <span class='neutral'>        );</span>
  208 |     | <span class='neutral'>        assert(success);</span>
  209 |     | <span class='neutral'>    }</span>
  210 |     | <span class='neutral'></span>
  211 |     | <span class='unexecuted'>    function setMockSynthetixUSDToken() private {</span>
  212 |     | <span class='unexecuted'>        v3Mock.setUSDToken(address(sUSDTokenMock), SUSD_ORACLE_NODE_ID);</span>
  213 |     | <span class='neutral'>    }</span>
  214 |     | <span class='neutral'></span>
  215 |     | <span class='unexecuted'>    function setMockWethToken() private {</span>
  216 |     | <span class='unexecuted'>        v3Mock.setWethToken(address(wethTokenMock), WETH_ORACLE_NODE_ID);</span>
  217 |     | <span class='neutral'>    }</span>
  218 |     | <span class='neutral'></span>
  219 |     | <span class='unexecuted'>    function setMockWbtcToken() private {</span>
  220 |     | <span class='unexecuted'>        v3Mock.setWbtcToken(address(wbtcTokenMock), WBTC_ORACLE_NODE_ID);</span>
  221 |     | <span class='neutral'>    }</span>
  222 |     | <span class='unexecuted'>    function setMockhugeToken() private {</span>
  223 |     | <span class='unexecuted'>        v3Mock.setHugeToken(</span>
  224 |     | <span class='unexecuted'>            address(hugePrecisionTokenMock),</span>
  225 |     | <span class='neutral'>            HUGE_ORACLE_NODE_ID</span>
  226 |     | <span class='neutral'>        );</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function increaseCreditCapacity() private {</span>
  230 |     | <span class='neutral'>        v3Mock.updateCreditCapacity(type(uint64).max, true);</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='unexecuted'>    function addLiquidationModuleSels() private {</span>
  234 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  235 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  236 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  237 |     | <span class='neutral'>                liquidationModuleImpl.liquidate.selector,</span>
  238 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  239 |     | <span class='neutral'>            )</span>
  240 |     | <span class='neutral'>        );</span>
  241 |     | <span class='unexecuted'>        assert(success);</span>
  242 |     | <span class='neutral'></span>
  243 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  244 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  245 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  246 |     | <span class='neutral'>                liquidationModuleImpl.liquidateMarginOnly.selector,</span>
  247 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  248 |     | <span class='neutral'>            )</span>
  249 |     | <span class='neutral'>        );</span>
  250 |     | <span class='unexecuted'>        assert(success);</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  253 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  254 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  255 |     | <span class='neutral'>                liquidationModuleImpl.liquidateFlagged.selector,</span>
  256 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  257 |     | <span class='neutral'>            )</span>
  258 |     | <span class='neutral'>        );</span>
  259 |     | <span class='unexecuted'>        assert(success);</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  262 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  263 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  264 |     | <span class='neutral'>                liquidationModuleImpl.liquidateFlaggedAccounts.selector,</span>
  265 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  266 |     | <span class='neutral'>            )</span>
  267 |     | <span class='neutral'>        );</span>
  268 |     | <span class='unexecuted'>        assert(success);</span>
  269 |     | <span class='neutral'></span>
  270 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  271 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  272 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  273 |     | <span class='neutral'>                liquidationModuleImpl.flaggedAccounts.selector,</span>
  274 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  275 |     | <span class='neutral'>            )</span>
  276 |     | <span class='neutral'>        );</span>
  277 |     | <span class='unexecuted'>        assert(success);</span>
  278 |     | <span class='neutral'></span>
  279 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  280 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  281 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  282 |     | <span class='neutral'>                liquidationModuleImpl.canLiquidate.selector,</span>
  283 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  284 |     | <span class='neutral'>            )</span>
  285 |     | <span class='neutral'>        );</span>
  286 |     | <span class='unexecuted'>        assert(success);</span>
  287 |     | <span class='neutral'></span>
  288 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  289 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  290 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  291 |     | <span class='neutral'>                liquidationModuleImpl.canLiquidateMarginOnly.selector,</span>
  292 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  293 |     | <span class='neutral'>            )</span>
  294 |     | <span class='neutral'>        );</span>
  295 |     | <span class='unexecuted'>        assert(success);</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  298 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  299 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  300 |     | <span class='neutral'>                liquidationModuleImpl.liquidationCapacity.selector,</span>
  301 |     | <span class='unexecuted'>                address(liquidationModuleImpl)</span>
  302 |     | <span class='neutral'>            )</span>
  303 |     | <span class='neutral'>        );</span>
  304 |     | <span class='neutral'>        assert(success);</span>
  305 |     | <span class='neutral'>    }</span>
  306 |     | <span class='unexecuted'>    function addAsyncOrderModuleSels() private {</span>
  307 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  308 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  309 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  310 |     | <span class='neutral'>                asyncOrderModuleImpl.commitOrder.selector,</span>
  311 |     | <span class='unexecuted'>                address(asyncOrderModuleImpl)</span>
  312 |     | <span class='neutral'>            )</span>
  313 |     | <span class='neutral'>        );</span>
  314 |     | <span class='unexecuted'>        assert(success);</span>
  315 |     | <span class='neutral'></span>
  316 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  317 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  318 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  319 |     | <span class='neutral'>                asyncOrderModuleImpl.getOrder.selector,</span>
  320 |     | <span class='unexecuted'>                address(asyncOrderModuleImpl)</span>
  321 |     | <span class='neutral'>            )</span>
  322 |     | <span class='neutral'>        );</span>
  323 |     | <span class='unexecuted'>        assert(success);</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  326 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  327 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  328 |     | <span class='neutral'>                asyncOrderModuleImpl.computeOrderFees.selector,</span>
  329 |     | <span class='unexecuted'>                address(asyncOrderModuleImpl)</span>
  330 |     | <span class='neutral'>            )</span>
  331 |     | <span class='neutral'>        );</span>
  332 |     | <span class='unexecuted'>        assert(success);</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  335 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  336 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  337 |     | <span class='neutral'>                asyncOrderModuleImpl.computeOrderFeesWithPrice.selector,</span>
  338 |     | <span class='unexecuted'>                address(asyncOrderModuleImpl)</span>
  339 |     | <span class='neutral'>            )</span>
  340 |     | <span class='neutral'>        );</span>
  341 |     | <span class='unexecuted'>        assert(success);</span>
  342 |     | <span class='neutral'></span>
  343 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  344 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  345 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  346 |     | <span class='neutral'>                asyncOrderModuleImpl.getSettlementRewardCost.selector,</span>
  347 |     | <span class='unexecuted'>                address(asyncOrderModuleImpl)</span>
  348 |     | <span class='neutral'>            )</span>
  349 |     | <span class='neutral'>        );</span>
  350 |     | <span class='unexecuted'>        assert(success);</span>
  351 |     | <span class='neutral'></span>
  352 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  353 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  354 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  355 |     | <span class='neutral'>                asyncOrderModuleImpl.requiredMarginForOrder.selector,</span>
  356 |     | <span class='unexecuted'>                address(asyncOrderModuleImpl)</span>
  357 |     | <span class='neutral'>            )</span>
  358 |     | <span class='neutral'>        );</span>
  359 |     | <span class='unexecuted'>        assert(success);</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  362 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  363 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  364 |     | <span class='neutral'>                asyncOrderModuleImpl.requiredMarginForOrderWithPrice.selector,</span>
  365 |     | <span class='unexecuted'>                address(asyncOrderModuleImpl)</span>
  366 |     | <span class='neutral'>            )</span>
  367 |     | <span class='neutral'>        );</span>
  368 |     | <span class='unexecuted'>        assert(success);</span>
  369 |     | <span class='neutral'>    }</span>
  370 |     | <span class='unexecuted'>    function addAsyncOrderCancelModuleSels() private {</span>
  371 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  372 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  373 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  374 |     | <span class='neutral'>                asyncOrderCancelModuleImpl.cancelOrder.selector,</span>
  375 |     | <span class='unexecuted'>                address(asyncOrderCancelModuleImpl)</span>
  376 |     | <span class='neutral'>            )</span>
  377 |     | <span class='neutral'>        );</span>
  378 |     | <span class='unexecuted'>        assert(success);</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='unexecuted'>    function addMockPythERC7412WrapperSels() private {</span>
  382 |     | <span class='unexecuted'>        pythWrapper.setBenchmarkPrice(WETH_FEED_ID, 3_000e18);</span>
  383 |     | <span class='unexecuted'>        pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, 10_000e18);</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='unexecuted'>    function addAsyncOrderSettlementPythModuleSels() private {</span>
  387 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  388 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  389 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  390 |     | <span class='neutral'>                asyncOrderSettlementPythModuleImpl.settleOrder.selector,</span>
  391 |     | <span class='unexecuted'>                address(asyncOrderSettlementPythModuleImpl)</span>
  392 |     | <span class='neutral'>            )</span>
  393 |     | <span class='neutral'>        );</span>
  394 |     | <span class='neutral'>        assert(success);</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='unexecuted'>    function addCollateralConfigurationModuleSels() private {</span>
  398 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  399 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  400 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  401 |     | <span class='neutral'>                collateralConfigurationModuleImpl</span>
  402 |     | <span class='neutral'>                    .setCollateralConfiguration</span>
  403 |     | <span class='neutral'>                    .selector,</span>
  404 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  405 |     | <span class='neutral'>            )</span>
  406 |     | <span class='neutral'>        );</span>
  407 |     | <span class='unexecuted'>        assert(success);</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  410 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  411 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  412 |     | <span class='neutral'>                collateralConfigurationModuleImpl</span>
  413 |     | <span class='neutral'>                    .getCollateralConfiguration</span>
  414 |     | <span class='neutral'>                    .selector,</span>
  415 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  416 |     | <span class='neutral'>            )</span>
  417 |     | <span class='neutral'>        );</span>
  418 |     | <span class='unexecuted'>        assert(success);</span>
  419 |     | <span class='neutral'></span>
  420 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  421 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  422 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  423 |     | <span class='neutral'>                collateralConfigurationModuleImpl</span>
  424 |     | <span class='neutral'>                    .getCollateralConfigurationFull</span>
  425 |     | <span class='neutral'>                    .selector,</span>
  426 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  427 |     | <span class='neutral'>            )</span>
  428 |     | <span class='neutral'>        );</span>
  429 |     | <span class='unexecuted'>        assert(success);</span>
  430 |     | <span class='neutral'></span>
  431 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  432 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  433 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  434 |     | <span class='neutral'>                collateralConfigurationModuleImpl</span>
  435 |     | <span class='neutral'>                    .setCollateralLiquidateRewardRatio</span>
  436 |     | <span class='neutral'>                    .selector,</span>
  437 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  438 |     | <span class='neutral'>            )</span>
  439 |     | <span class='neutral'>        );</span>
  440 |     | <span class='unexecuted'>        assert(success);</span>
  441 |     | <span class='neutral'></span>
  442 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  443 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  444 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  445 |     | <span class='neutral'>                collateralConfigurationModuleImpl</span>
  446 |     | <span class='neutral'>                    .getCollateralLiquidateRewardRatio</span>
  447 |     | <span class='neutral'>                    .selector,</span>
  448 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  449 |     | <span class='neutral'>            )</span>
  450 |     | <span class='neutral'>        );</span>
  451 |     | <span class='unexecuted'>        assert(success);</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  454 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  455 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  456 |     | <span class='neutral'>                collateralConfigurationModuleImpl.registerDistributor.selector,</span>
  457 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  458 |     | <span class='neutral'>            )</span>
  459 |     | <span class='neutral'>        );</span>
  460 |     | <span class='unexecuted'>        assert(success);</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  463 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  464 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  465 |     | <span class='neutral'>                collateralConfigurationModuleImpl.isRegistered.selector,</span>
  466 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  467 |     | <span class='neutral'>            )</span>
  468 |     | <span class='neutral'>        );</span>
  469 |     | <span class='unexecuted'>        assert(success);</span>
  470 |     | <span class='neutral'></span>
  471 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  472 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  473 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  474 |     | <span class='neutral'>                collateralConfigurationModuleImpl</span>
  475 |     | <span class='neutral'>                    .getRegisteredDistributor</span>
  476 |     | <span class='neutral'>                    .selector,</span>
  477 |     | <span class='unexecuted'>                address(collateralConfigurationModuleImpl)</span>
  478 |     | <span class='neutral'>            )</span>
  479 |     | <span class='neutral'>        );</span>
  480 |     | <span class='neutral'>        assert(success);</span>
  481 |     | <span class='neutral'>    }</span>
  482 |     | <span class='neutral'></span>
  483 |     | <span class='unexecuted'>    function addGlobalPerpsMarketModuleSels() private {</span>
  484 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  485 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  486 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  487 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getSupportedCollaterals.selector,</span>
  488 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  489 |     | <span class='neutral'>            )</span>
  490 |     | <span class='neutral'>        );</span>
  491 |     | <span class='unexecuted'>        assert(success);</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  494 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  495 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  496 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.setKeeperRewardGuards.selector,</span>
  497 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  498 |     | <span class='neutral'>            )</span>
  499 |     | <span class='neutral'>        );</span>
  500 |     | <span class='unexecuted'>        assert(success);</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  503 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  504 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  505 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getKeeperRewardGuards.selector,</span>
  506 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  507 |     | <span class='neutral'>            )</span>
  508 |     | <span class='neutral'>        );</span>
  509 |     | <span class='unexecuted'>        assert(success);</span>
  510 |     | <span class='neutral'></span>
  511 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  512 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  513 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  514 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.totalGlobalCollateralValue.selector,</span>
  515 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  516 |     | <span class='neutral'>            )</span>
  517 |     | <span class='neutral'>        );</span>
  518 |     | <span class='unexecuted'>        assert(success);</span>
  519 |     | <span class='neutral'></span>
  520 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  521 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  522 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  523 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.globalCollateralValue.selector,</span>
  524 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  525 |     | <span class='neutral'>            )</span>
  526 |     | <span class='neutral'>        );</span>
  527 |     | <span class='unexecuted'>        assert(success);</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  530 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  531 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  532 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.setFeeCollector.selector,</span>
  533 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  534 |     | <span class='neutral'>            )</span>
  535 |     | <span class='neutral'>        );</span>
  536 |     | <span class='unexecuted'>        assert(success);</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  539 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  540 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  541 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getFeeCollector.selector,</span>
  542 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  543 |     | <span class='neutral'>            )</span>
  544 |     | <span class='neutral'>        );</span>
  545 |     | <span class='unexecuted'>        assert(success);</span>
  546 |     | <span class='neutral'></span>
  547 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  548 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  549 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  550 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.updateKeeperCostNodeId.selector,</span>
  551 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  552 |     | <span class='neutral'>            )</span>
  553 |     | <span class='neutral'>        );</span>
  554 |     | <span class='unexecuted'>        assert(success);</span>
  555 |     | <span class='neutral'></span>
  556 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  557 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  558 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  559 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getKeeperCostNodeId.selector,</span>
  560 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  561 |     | <span class='neutral'>            )</span>
  562 |     | <span class='neutral'>        );</span>
  563 |     | <span class='unexecuted'>        assert(success);</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  566 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  567 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  568 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.updateReferrerShare.selector,</span>
  569 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  570 |     | <span class='neutral'>            )</span>
  571 |     | <span class='neutral'>        );</span>
  572 |     | <span class='unexecuted'>        assert(success);</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  575 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  576 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  577 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getReferrerShare.selector,</span>
  578 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  579 |     | <span class='neutral'>            )</span>
  580 |     | <span class='neutral'>        );</span>
  581 |     | <span class='unexecuted'>        assert(success);</span>
  582 |     | <span class='neutral'></span>
  583 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  584 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  585 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  586 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getMarkets.selector,</span>
  587 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  588 |     | <span class='neutral'>            )</span>
  589 |     | <span class='neutral'>        );</span>
  590 |     | <span class='unexecuted'>        assert(success);</span>
  591 |     | <span class='neutral'></span>
  592 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  593 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  594 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  595 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.setPerAccountCaps.selector,</span>
  596 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  597 |     | <span class='neutral'>            )</span>
  598 |     | <span class='neutral'>        );</span>
  599 |     | <span class='unexecuted'>        assert(success);</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  602 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  603 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  604 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getPerAccountCaps.selector,</span>
  605 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  606 |     | <span class='neutral'>            )</span>
  607 |     | <span class='neutral'>        );</span>
  608 |     | <span class='unexecuted'>        assert(success);</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  611 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  612 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  613 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.setInterestRateParameters.selector,</span>
  614 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  615 |     | <span class='neutral'>            )</span>
  616 |     | <span class='neutral'>        );</span>
  617 |     | <span class='unexecuted'>        assert(success);</span>
  618 |     | <span class='neutral'></span>
  619 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  620 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  621 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  622 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getInterestRateParameters.selector,</span>
  623 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  624 |     | <span class='neutral'>            )</span>
  625 |     | <span class='neutral'>        );</span>
  626 |     | <span class='unexecuted'>        assert(success);</span>
  627 |     | <span class='neutral'></span>
  628 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  629 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  630 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  631 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.updateInterestRate.selector,</span>
  632 |     | <span class='unexecuted'>                address(globalPerpsMarketModuleImpl)</span>
  633 |     | <span class='neutral'>            )</span>
  634 |     | <span class='neutral'>        );</span>
  635 |     | <span class='neutral'>        assert(success);</span>
  636 |     | <span class='neutral'>    }</span>
  637 |     | <span class='neutral'></span>
  638 |     | <span class='unexecuted'>    function addMarketConfigurationModuleSels() private {</span>
  639 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  640 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  641 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  642 |     | <span class='neutral'>                marketConfigurationModuleImpl.addSettlementStrategy.selector,</span>
  643 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  644 |     | <span class='neutral'>            )</span>
  645 |     | <span class='neutral'>        );</span>
  646 |     | <span class='unexecuted'>        assert(success);</span>
  647 |     | <span class='neutral'></span>
  648 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  649 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  650 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  651 |     | <span class='neutral'>                marketConfigurationModuleImpl.setSettlementStrategy.selector,</span>
  652 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  653 |     | <span class='neutral'>            )</span>
  654 |     | <span class='neutral'>        );</span>
  655 |     | <span class='unexecuted'>        assert(success);</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  658 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  659 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  660 |     | <span class='neutral'>                marketConfigurationModuleImpl</span>
  661 |     | <span class='neutral'>                    .setSettlementStrategyEnabled</span>
  662 |     | <span class='neutral'>                    .selector,</span>
  663 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  664 |     | <span class='neutral'>            )</span>
  665 |     | <span class='neutral'>        );</span>
  666 |     | <span class='unexecuted'>        assert(success);</span>
  667 |     | <span class='neutral'></span>
  668 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  669 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  670 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  671 |     | <span class='neutral'>                marketConfigurationModuleImpl.setOrderFees.selector,</span>
  672 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  673 |     | <span class='neutral'>            )</span>
  674 |     | <span class='neutral'>        );</span>
  675 |     | <span class='unexecuted'>        assert(success);</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  678 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  679 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  680 |     | <span class='neutral'>                marketConfigurationModuleImpl.updatePriceData.selector,</span>
  681 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  682 |     | <span class='neutral'>            )</span>
  683 |     | <span class='neutral'>        );</span>
  684 |     | <span class='unexecuted'>        assert(success);</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  687 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  688 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  689 |     | <span class='neutral'>                marketConfigurationModuleImpl.getPriceData.selector,</span>
  690 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  691 |     | <span class='neutral'>            )</span>
  692 |     | <span class='neutral'>        );</span>
  693 |     | <span class='unexecuted'>        assert(success);</span>
  694 |     | <span class='neutral'></span>
  695 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  696 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  697 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  698 |     | <span class='neutral'>                marketConfigurationModuleImpl.setMaxMarketSize.selector,</span>
  699 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  700 |     | <span class='neutral'>            )</span>
  701 |     | <span class='neutral'>        );</span>
  702 |     | <span class='unexecuted'>        assert(success);</span>
  703 |     | <span class='neutral'></span>
  704 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  705 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  706 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  707 |     | <span class='neutral'>                marketConfigurationModuleImpl.setMaxMarketValue.selector,</span>
  708 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  709 |     | <span class='neutral'>            )</span>
  710 |     | <span class='neutral'>        );</span>
  711 |     | <span class='unexecuted'>        assert(success);</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  714 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  715 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  716 |     | <span class='neutral'>                marketConfigurationModuleImpl.setFundingParameters.selector,</span>
  717 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  718 |     | <span class='neutral'>            )</span>
  719 |     | <span class='neutral'>        );</span>
  720 |     | <span class='unexecuted'>        assert(success);</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  723 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  724 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  725 |     | <span class='neutral'>                marketConfigurationModuleImpl</span>
  726 |     | <span class='neutral'>                    .setMaxLiquidationParameters</span>
  727 |     | <span class='neutral'>                    .selector,</span>
  728 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  729 |     | <span class='neutral'>            )</span>
  730 |     | <span class='neutral'>        );</span>
  731 |     | <span class='unexecuted'>        assert(success);</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  734 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  735 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  736 |     | <span class='neutral'>                marketConfigurationModuleImpl.setLiquidationParameters.selector,</span>
  737 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  738 |     | <span class='neutral'>            )</span>
  739 |     | <span class='neutral'>        );</span>
  740 |     | <span class='unexecuted'>        assert(success);</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  743 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  744 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  745 |     | <span class='neutral'>                marketConfigurationModuleImpl.setLockedOiRatio.selector,</span>
  746 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  747 |     | <span class='neutral'>            )</span>
  748 |     | <span class='neutral'>        );</span>
  749 |     | <span class='unexecuted'>        assert(success);</span>
  750 |     | <span class='neutral'></span>
  751 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  752 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  753 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  754 |     | <span class='neutral'>                marketConfigurationModuleImpl.getSettlementStrategy.selector,</span>
  755 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  756 |     | <span class='neutral'>            )</span>
  757 |     | <span class='neutral'>        );</span>
  758 |     | <span class='unexecuted'>        assert(success);</span>
  759 |     | <span class='neutral'></span>
  760 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  761 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  762 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  763 |     | <span class='neutral'>                marketConfigurationModuleImpl</span>
  764 |     | <span class='neutral'>                    .getMaxLiquidationParameters</span>
  765 |     | <span class='neutral'>                    .selector,</span>
  766 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  767 |     | <span class='neutral'>            )</span>
  768 |     | <span class='neutral'>        );</span>
  769 |     | <span class='unexecuted'>        assert(success);</span>
  770 |     | <span class='neutral'></span>
  771 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  772 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  773 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  774 |     | <span class='neutral'>                marketConfigurationModuleImpl.getLiquidationParameters.selector,</span>
  775 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  776 |     | <span class='neutral'>            )</span>
  777 |     | <span class='neutral'>        );</span>
  778 |     | <span class='unexecuted'>        assert(success);</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  781 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  782 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  783 |     | <span class='neutral'>                marketConfigurationModuleImpl.getFundingParameters.selector,</span>
  784 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  785 |     | <span class='neutral'>            )</span>
  786 |     | <span class='neutral'>        );</span>
  787 |     | <span class='unexecuted'>        assert(success);</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  790 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  791 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  792 |     | <span class='neutral'>                marketConfigurationModuleImpl.getMaxMarketSize.selector,</span>
  793 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  794 |     | <span class='neutral'>            )</span>
  795 |     | <span class='neutral'>        );</span>
  796 |     | <span class='unexecuted'>        assert(success);</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  799 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  800 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  801 |     | <span class='neutral'>                marketConfigurationModuleImpl.getMaxMarketValue.selector,</span>
  802 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  803 |     | <span class='neutral'>            )</span>
  804 |     | <span class='neutral'>        );</span>
  805 |     | <span class='unexecuted'>        assert(success);</span>
  806 |     | <span class='neutral'></span>
  807 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  808 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  809 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  810 |     | <span class='neutral'>                marketConfigurationModuleImpl.getOrderFees.selector,</span>
  811 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  812 |     | <span class='neutral'>            )</span>
  813 |     | <span class='neutral'>        );</span>
  814 |     | <span class='unexecuted'>        assert(success);</span>
  815 |     | <span class='neutral'></span>
  816 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  817 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  818 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  819 |     | <span class='neutral'>                marketConfigurationModuleImpl.getLockedOiRatio.selector,</span>
  820 |     | <span class='unexecuted'>                address(marketConfigurationModuleImpl)</span>
  821 |     | <span class='neutral'>            )</span>
  822 |     | <span class='neutral'>        );</span>
  823 |     | <span class='neutral'>        assert(success);</span>
  824 |     | <span class='neutral'>    }</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='unexecuted'>    function addPerpsAccountModuleSels() private {</span>
  827 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  828 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  829 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  830 |     | <span class='neutral'>                perpsAccountModuleImpl.modifyCollateral.selector,</span>
  831 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  832 |     | <span class='neutral'>            )</span>
  833 |     | <span class='neutral'>        );</span>
  834 |     | <span class='unexecuted'>        assert(success);</span>
  835 |     | <span class='neutral'></span>
  836 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  837 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  838 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  839 |     | <span class='neutral'>                perpsAccountModuleImpl.debt.selector,</span>
  840 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  841 |     | <span class='neutral'>            )</span>
  842 |     | <span class='neutral'>        );</span>
  843 |     | <span class='unexecuted'>        assert(success);</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  846 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  847 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  848 |     | <span class='neutral'>                perpsAccountModuleImpl.payDebt.selector,</span>
  849 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  850 |     | <span class='neutral'>            )</span>
  851 |     | <span class='neutral'>        );</span>
  852 |     | <span class='unexecuted'>        assert(success);</span>
  853 |     | <span class='neutral'></span>
  854 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  855 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  856 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  857 |     | <span class='neutral'>                perpsAccountModuleImpl.totalCollateralValue.selector,</span>
  858 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  859 |     | <span class='neutral'>            )</span>
  860 |     | <span class='neutral'>        );</span>
  861 |     | <span class='unexecuted'>        assert(success);</span>
  862 |     | <span class='neutral'></span>
  863 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  864 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  865 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  866 |     | <span class='neutral'>                perpsAccountModuleImpl.totalAccountOpenInterest.selector,</span>
  867 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  868 |     | <span class='neutral'>            )</span>
  869 |     | <span class='neutral'>        );</span>
  870 |     | <span class='unexecuted'>        assert(success);</span>
  871 |     | <span class='neutral'></span>
  872 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  873 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  874 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  875 |     | <span class='neutral'>                perpsAccountModuleImpl.getOpenPosition.selector,</span>
  876 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  877 |     | <span class='neutral'>            )</span>
  878 |     | <span class='neutral'>        );</span>
  879 |     | <span class='unexecuted'>        assert(success);</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  882 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  883 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  884 |     | <span class='neutral'>                perpsAccountModuleImpl.getOpenPositionSize.selector,</span>
  885 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  886 |     | <span class='neutral'>            )</span>
  887 |     | <span class='neutral'>        );</span>
  888 |     | <span class='unexecuted'>        assert(success);</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  891 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  892 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  893 |     | <span class='neutral'>                perpsAccountModuleImpl.getAvailableMargin.selector,</span>
  894 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  895 |     | <span class='neutral'>            )</span>
  896 |     | <span class='neutral'>        );</span>
  897 |     | <span class='unexecuted'>        assert(success);</span>
  898 |     | <span class='neutral'></span>
  899 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  900 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  901 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  902 |     | <span class='neutral'>                perpsAccountModuleImpl.getWithdrawableMargin.selector,</span>
  903 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  904 |     | <span class='neutral'>            )</span>
  905 |     | <span class='neutral'>        );</span>
  906 |     | <span class='unexecuted'>        assert(success);</span>
  907 |     | <span class='neutral'></span>
  908 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  909 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  910 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  911 |     | <span class='neutral'>                perpsAccountModuleImpl.getRequiredMargins.selector,</span>
  912 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  913 |     | <span class='neutral'>            )</span>
  914 |     | <span class='neutral'>        );</span>
  915 |     | <span class='unexecuted'>        assert(success);</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  918 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  919 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  920 |     | <span class='neutral'>                perpsAccountModuleImpl.getCollateralAmount.selector,</span>
  921 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  922 |     | <span class='neutral'>            )</span>
  923 |     | <span class='neutral'>        );</span>
  924 |     | <span class='unexecuted'>        assert(success);</span>
  925 |     | <span class='neutral'></span>
  926 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  927 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  928 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  929 |     | <span class='neutral'>                perpsAccountModuleImpl.getAccountCollateralIds.selector,</span>
  930 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  931 |     | <span class='neutral'>            )</span>
  932 |     | <span class='neutral'>        );</span>
  933 |     | <span class='unexecuted'>        assert(success);</span>
  934 |     | <span class='neutral'></span>
  935 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  936 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  937 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
  938 |     | <span class='neutral'>                perpsAccountModuleImpl.getAccountOpenPositions.selector,</span>
  939 |     | <span class='unexecuted'>                address(perpsAccountModuleImpl)</span>
  940 |     | <span class='neutral'>            )</span>
  941 |     | <span class='neutral'>        );</span>
  942 |     | <span class='neutral'>        assert(success);</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='unexecuted'>    function addPerpsMarketFactoryModuleSels() private {</span>
  946 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
  947 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  948 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  949 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.initializeFactory.selector,</span>
  950 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
  951 |     | <span class='neutral'>            )</span>
  952 |     | <span class='neutral'>        );</span>
  953 |     | <span class='unexecuted'>        assert(success);</span>
  954 |     | <span class='neutral'></span>
  955 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  956 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  957 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  958 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.setPerpsMarketName.selector,</span>
  959 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
  960 |     | <span class='neutral'>            )</span>
  961 |     | <span class='neutral'>        );</span>
  962 |     | <span class='unexecuted'>        assert(success);</span>
  963 |     | <span class='neutral'></span>
  964 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  965 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  966 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  967 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.createMarket.selector,</span>
  968 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
  969 |     | <span class='neutral'>            )</span>
  970 |     | <span class='neutral'>        );</span>
  971 |     | <span class='unexecuted'>        assert(success);</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  974 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  975 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  976 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.name.selector,</span>
  977 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
  978 |     | <span class='neutral'>            )</span>
  979 |     | <span class='neutral'>        );</span>
  980 |     | <span class='unexecuted'>        assert(success);</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  983 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  984 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  985 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.reportedDebt.selector,</span>
  986 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
  987 |     | <span class='neutral'>            )</span>
  988 |     | <span class='neutral'>        );</span>
  989 |     | <span class='unexecuted'>        assert(success);</span>
  990 |     | <span class='neutral'></span>
  991 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
  992 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  993 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
  994 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.minimumCredit.selector,</span>
  995 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
  996 |     | <span class='neutral'>            )</span>
  997 |     | <span class='neutral'>        );</span>
  998 |     | <span class='unexecuted'>        assert(success);</span>
  999 |     | <span class='neutral'></span>
 1000 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1001 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1002 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1003 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.interestRate.selector,</span>
 1004 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
 1005 |     | <span class='neutral'>            )</span>
 1006 |     | <span class='neutral'>        );</span>
 1007 |     | <span class='unexecuted'>        assert(success);</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1010 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1011 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1012 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.utilizationRate.selector,</span>
 1013 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
 1014 |     | <span class='neutral'>            )</span>
 1015 |     | <span class='neutral'>        );</span>
 1016 |     | <span class='unexecuted'>        assert(success);</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1019 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1020 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
 1021 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.supportsInterface.selector,</span>
 1022 |     | <span class='unexecuted'>                address(perpsMarketFactoryModuleImpl)</span>
 1023 |     | <span class='neutral'>            )</span>
 1024 |     | <span class='neutral'>        );</span>
 1025 |     | <span class='neutral'>        assert(success);</span>
 1026 |     | <span class='neutral'>    }</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='unexecuted'>    function addPerpsMarketModuleSels() private {</span>
 1029 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1030 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1031 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1032 |     | <span class='neutral'>                perpsMarketModuleImpl.metadata.selector,</span>
 1033 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1034 |     | <span class='neutral'>            )</span>
 1035 |     | <span class='neutral'>        );</span>
 1036 |     | <span class='unexecuted'>        assert(success);</span>
 1037 |     | <span class='neutral'></span>
 1038 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1039 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1040 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1041 |     | <span class='neutral'>                perpsMarketModuleImpl.skew.selector,</span>
 1042 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1043 |     | <span class='neutral'>            )</span>
 1044 |     | <span class='neutral'>        );</span>
 1045 |     | <span class='unexecuted'>        assert(success);</span>
 1046 |     | <span class='neutral'></span>
 1047 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1048 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1049 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1050 |     | <span class='neutral'>                perpsMarketModuleImpl.size.selector,</span>
 1051 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1052 |     | <span class='neutral'>            )</span>
 1053 |     | <span class='neutral'>        );</span>
 1054 |     | <span class='unexecuted'>        assert(success);</span>
 1055 |     | <span class='neutral'></span>
 1056 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1057 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1058 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1059 |     | <span class='neutral'>                perpsMarketModuleImpl.maxOpenInterest.selector,</span>
 1060 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1061 |     | <span class='neutral'>            )</span>
 1062 |     | <span class='neutral'>        );</span>
 1063 |     | <span class='unexecuted'>        assert(success);</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1066 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1067 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1068 |     | <span class='neutral'>                perpsMarketModuleImpl.currentFundingRate.selector,</span>
 1069 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1070 |     | <span class='neutral'>            )</span>
 1071 |     | <span class='neutral'>        );</span>
 1072 |     | <span class='unexecuted'>        assert(success);</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1075 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1076 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1077 |     | <span class='neutral'>                perpsMarketModuleImpl.currentFundingVelocity.selector,</span>
 1078 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1079 |     | <span class='neutral'>            )</span>
 1080 |     | <span class='neutral'>        );</span>
 1081 |     | <span class='unexecuted'>        assert(success);</span>
 1082 |     | <span class='neutral'></span>
 1083 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1084 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1085 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1086 |     | <span class='neutral'>                perpsMarketModuleImpl.indexPrice.selector,</span>
 1087 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1088 |     | <span class='neutral'>            )</span>
 1089 |     | <span class='neutral'>        );</span>
 1090 |     | <span class='unexecuted'>        assert(success);</span>
 1091 |     | <span class='neutral'></span>
 1092 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1093 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1094 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1095 |     | <span class='neutral'>                perpsMarketModuleImpl.fillPrice.selector,</span>
 1096 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1097 |     | <span class='neutral'>            )</span>
 1098 |     | <span class='neutral'>        );</span>
 1099 |     | <span class='unexecuted'>        assert(success);</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1102 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1103 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
 1104 |     | <span class='neutral'>                perpsMarketModuleImpl.getMarketSummary.selector,</span>
 1105 |     | <span class='unexecuted'>                address(perpsMarketModuleImpl)</span>
 1106 |     | <span class='neutral'>            )</span>
 1107 |     | <span class='neutral'>        );</span>
 1108 |     | <span class='neutral'>        assert(success);</span>
 1109 |     | <span class='neutral'>    }</span>
 1110 |     | <span class='neutral'></span>
 1111 |     | <span class='unexecuted'>    function addMockModuleSels() private {</span>
 1112 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1113 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1114 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1115 |     | <span class='neutral'>                mockModuleImpl.createAccount.selector,</span>
 1116 |     | <span class='unexecuted'>                address(mockModuleImpl)</span>
 1117 |     | <span class='neutral'>            )</span>
 1118 |     | <span class='neutral'>        );</span>
 1119 |     | <span class='unexecuted'>        assert(success);</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1122 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1123 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
 1124 |     | <span class='neutral'>                mockModuleImpl.grantPermission.selector,</span>
 1125 |     | <span class='unexecuted'>                address(mockModuleImpl)</span>
 1126 |     | <span class='neutral'>            )</span>
 1127 |     | <span class='neutral'>        );</span>
 1128 |     | <span class='neutral'>        assert(success);</span>
 1129 |     | <span class='neutral'>    }</span>
 1130 |     | <span class='neutral'></span>
 1131 |     | <span class='unexecuted'>    function addFeatureFlagModuleSels() private {</span>
 1132 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1133 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1134 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1135 |     | <span class='neutral'>                featureFlagModuleImpl.setFeatureFlagAllowAll.selector,</span>
 1136 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1137 |     | <span class='neutral'>            )</span>
 1138 |     | <span class='neutral'>        );</span>
 1139 |     | <span class='unexecuted'>        assert(success);</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1142 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1143 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1144 |     | <span class='neutral'>                featureFlagModuleImpl.setFeatureFlagDenyAll.selector,</span>
 1145 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1146 |     | <span class='neutral'>            )</span>
 1147 |     | <span class='neutral'>        );</span>
 1148 |     | <span class='unexecuted'>        assert(success);</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1151 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1152 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1153 |     | <span class='neutral'>                featureFlagModuleImpl.addToFeatureFlagAllowlist.selector,</span>
 1154 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1155 |     | <span class='neutral'>            )</span>
 1156 |     | <span class='neutral'>        );</span>
 1157 |     | <span class='unexecuted'>        assert(success);</span>
 1158 |     | <span class='neutral'></span>
 1159 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1160 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1161 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1162 |     | <span class='neutral'>                featureFlagModuleImpl.removeFromFeatureFlagAllowlist.selector,</span>
 1163 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1164 |     | <span class='neutral'>            )</span>
 1165 |     | <span class='neutral'>        );</span>
 1166 |     | <span class='unexecuted'>        assert(success);</span>
 1167 |     | <span class='neutral'></span>
 1168 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1169 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1170 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1171 |     | <span class='neutral'>                featureFlagModuleImpl.setDeniers.selector,</span>
 1172 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1173 |     | <span class='neutral'>            )</span>
 1174 |     | <span class='neutral'>        );</span>
 1175 |     | <span class='unexecuted'>        assert(success);</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1178 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1179 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1180 |     | <span class='neutral'>                featureFlagModuleImpl.getDeniers.selector,</span>
 1181 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1182 |     | <span class='neutral'>            )</span>
 1183 |     | <span class='neutral'>        );</span>
 1184 |     | <span class='unexecuted'>        assert(success);</span>
 1185 |     | <span class='neutral'></span>
 1186 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1187 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1188 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1189 |     | <span class='neutral'>                featureFlagModuleImpl.getFeatureFlagAllowAll.selector,</span>
 1190 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1191 |     | <span class='neutral'>            )</span>
 1192 |     | <span class='neutral'>        );</span>
 1193 |     | <span class='unexecuted'>        assert(success);</span>
 1194 |     | <span class='neutral'></span>
 1195 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1196 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1197 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1198 |     | <span class='neutral'>                featureFlagModuleImpl.getFeatureFlagDenyAll.selector,</span>
 1199 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1200 |     | <span class='neutral'>            )</span>
 1201 |     | <span class='neutral'>        );</span>
 1202 |     | <span class='unexecuted'>        assert(success);</span>
 1203 |     | <span class='neutral'></span>
 1204 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1205 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1206 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1207 |     | <span class='neutral'>                featureFlagModuleImpl.getFeatureFlagAllowlist.selector,</span>
 1208 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1209 |     | <span class='neutral'>            )</span>
 1210 |     | <span class='neutral'>        );</span>
 1211 |     | <span class='unexecuted'>        assert(success);</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1214 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1215 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
 1216 |     | <span class='neutral'>                featureFlagModuleImpl.isFeatureAllowed.selector,</span>
 1217 |     | <span class='unexecuted'>                address(featureFlagModuleImpl)</span>
 1218 |     | <span class='neutral'>            )</span>
 1219 |     | <span class='neutral'>        );</span>
 1220 |     | <span class='neutral'>        assert(success);</span>
 1221 |     | <span class='neutral'>    }</span>
 1222 |     | <span class='neutral'></span>
 1223 |     | <span class='unexecuted'>    function addMockLensModuleSels() private {</span>
 1224 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1225 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1226 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1227 |     | <span class='neutral'>                mockLensModuleImpl.isOrderExpired.selector,</span>
 1228 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1229 |     | <span class='neutral'>            )</span>
 1230 |     | <span class='neutral'>        );</span>
 1231 |     | <span class='unexecuted'>        assert(success);</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1234 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1235 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1236 |     | <span class='neutral'>                mockLensModuleImpl.getOrder.selector,</span>
 1237 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1238 |     | <span class='neutral'>            )</span>
 1239 |     | <span class='neutral'>        );</span>
 1240 |     | <span class='unexecuted'>        assert(success);</span>
 1241 |     | <span class='neutral'></span>
 1242 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1243 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1244 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1245 |     | <span class='neutral'>                mockLensModuleImpl.getSettlementRewardCost.selector,</span>
 1246 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1247 |     | <span class='neutral'>            )</span>
 1248 |     | <span class='neutral'>        );</span>
 1249 |     | <span class='unexecuted'>        assert(success);</span>
 1250 |     | <span class='neutral'></span>
 1251 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1252 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1253 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1254 |     | <span class='neutral'>                mockLensModuleImpl.calculateFillPrice.selector,</span>
 1255 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1256 |     | <span class='neutral'>            )</span>
 1257 |     | <span class='neutral'>        );</span>
 1258 |     | <span class='unexecuted'>        assert(success);</span>
 1259 |     | <span class='neutral'></span>
 1260 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1261 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1262 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1263 |     | <span class='neutral'>                mockLensModuleImpl.getOpenPositionMarketIds.selector,</span>
 1264 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1265 |     | <span class='neutral'>            )</span>
 1266 |     | <span class='neutral'>        );</span>
 1267 |     | <span class='unexecuted'>        assert(success);</span>
 1268 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1269 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1270 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1271 |     | <span class='neutral'>                mockLensModuleImpl.getGlobalCollateralTypes.selector,</span>
 1272 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1273 |     | <span class='neutral'>            )</span>
 1274 |     | <span class='neutral'>        );</span>
 1275 |     | <span class='unexecuted'>        assert(success);</span>
 1276 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1277 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1278 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1279 |     | <span class='neutral'>                mockLensModuleImpl.getGlobalTotalAccountsDebt.selector,</span>
 1280 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1281 |     | <span class='neutral'>            )</span>
 1282 |     | <span class='neutral'>        );</span>
 1283 |     | <span class='unexecuted'>        assert(success);</span>
 1284 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1285 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1286 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1287 |     | <span class='neutral'>                mockLensModuleImpl.getDebtCorrectionAccumulator.selector,</span>
 1288 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1289 |     | <span class='neutral'>            )</span>
 1290 |     | <span class='neutral'>        );</span>
 1291 |     | <span class='unexecuted'>        assert(success);</span>
 1292 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1293 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1294 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1295 |     | <span class='neutral'>                mockLensModuleImpl.getPositionData.selector,</span>
 1296 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1297 |     | <span class='neutral'>            )</span>
 1298 |     | <span class='neutral'>        );</span>
 1299 |     | <span class='unexecuted'>        assert(success);</span>
 1300 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1301 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1302 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1303 |     | <span class='neutral'>                mockLensModuleImpl.isAccountLiquidatable.selector,</span>
 1304 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1305 |     | <span class='neutral'>            )</span>
 1306 |     | <span class='neutral'>        );</span>
 1307 |     | <span class='unexecuted'>        assert(success);</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1310 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1311 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1312 |     | <span class='neutral'>                mockLensModuleImpl.getMaxLiquidatableAmount.selector,</span>
 1313 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1314 |     | <span class='neutral'>            )</span>
 1315 |     | <span class='neutral'>        );</span>
 1316 |     | <span class='unexecuted'>        assert(success);</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1319 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1320 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1321 |     | <span class='neutral'>                mockLensModuleImpl.getChargeAmount.selector,</span>
 1322 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1323 |     | <span class='neutral'>            )</span>
 1324 |     | <span class='neutral'>        );</span>
 1325 |     | <span class='unexecuted'>        assert(success);</span>
 1326 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1327 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1328 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1329 |     | <span class='neutral'>                mockLensModuleImpl.setPythWrapperAddress.selector,</span>
 1330 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1331 |     | <span class='neutral'>            )</span>
 1332 |     | <span class='neutral'>        );</span>
 1333 |     | <span class='unexecuted'>        assert(success);</span>
 1334 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1335 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1336 |     | <span class='neutral'>                router.addFunctionAndImplementation.selector,</span>
 1337 |     | <span class='neutral'>                mockLensModuleImpl.getPythWrapperAddress.selector,</span>
 1338 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1339 |     | <span class='neutral'>            )</span>
 1340 |     | <span class='neutral'>        );</span>
 1341 |     | <span class='unexecuted'>        assert(success);</span>
 1342 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1343 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1344 |     | <span class='unexecuted'>                router.addFunctionAndImplementation.selector,</span>
 1345 |     | <span class='neutral'>                mockLensModuleImpl.getCollateralTypes.selector,</span>
 1346 |     | <span class='unexecuted'>                address(mockLensModuleImpl)</span>
 1347 |     | <span class='neutral'>            )</span>
 1348 |     | <span class='neutral'>        );</span>
 1349 |     | <span class='neutral'>        assert(success);</span>
 1350 |     | <span class='neutral'>    }</span>
 1351 |     | <span class='neutral'></span>
 1352 |     | <span class='unexecuted'>    function enableAllFeatureFlags() private {</span>
 1353 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1354 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1355 |     | <span class='neutral'>                featureFlagModuleImpl.setFeatureFlagAllowAll.selector,</span>
 1356 |     | <span class='neutral'>                Flags.PERPS_SYSTEM,</span>
 1357 |     | <span class='neutral'>                true</span>
 1358 |     | <span class='neutral'>            )</span>
 1359 |     | <span class='neutral'>        );</span>
 1360 |     | <span class='unexecuted'>        assert(success);</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1363 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1364 |     | <span class='unexecuted'>                featureFlagModuleImpl.setFeatureFlagAllowAll.selector,</span>
 1365 |     | <span class='neutral'>                Flags.CREATE_MARKET,</span>
 1366 |     | <span class='neutral'>                true</span>
 1367 |     | <span class='neutral'>            )</span>
 1368 |     | <span class='neutral'>        );</span>
 1369 |     | <span class='neutral'>        assert(success);</span>
 1370 |     | <span class='neutral'>    }</span>
 1371 |     | <span class='neutral'></span>
 1372 |     | <span class='unexecuted'>    function addWETHSettlementStrategy() private {</span>
 1373 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1374 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1375 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.addSettlementStrategy.selector,</span>
 1376 |     | <span class='neutral'>                1, // marketId</span>
 1377 |     | <span class='unexecuted'>                SettlementStrategy.Data({</span>
 1378 |     | <span class='neutral'>                    strategyType: WETH_SETTLEMENT_STRATEGY_TYPE,</span>
 1379 |     | <span class='neutral'>                    settlementDelay: WETH_SETTLEMENT_DELAY,</span>
 1380 |     | <span class='neutral'>                    settlementWindowDuration: WETH_SETTLEMENT_WINDOW_DURATION,</span>
 1381 |     | <span class='unexecuted'>                    priceVerificationContract: address(pythWrapper),</span>
 1382 |     | <span class='neutral'>                    feedId: WETH_FEED_ID,</span>
 1383 |     | <span class='neutral'>                    settlementReward: WETH_SETTLEMENT_REWARD,</span>
 1384 |     | <span class='neutral'>                    disabled: WETH_DISABLED,</span>
 1385 |     | <span class='neutral'>                    commitmentPriceDelay: WETH_COMMITMENT_PRICE_DELAY</span>
 1386 |     | <span class='neutral'>                })</span>
 1387 |     | <span class='neutral'>            )</span>
 1388 |     | <span class='neutral'>        );</span>
 1389 |     | <span class='neutral'>        assert(success);</span>
 1390 |     | <span class='neutral'>    }</span>
 1391 |     | <span class='neutral'></span>
 1392 |     | <span class='unexecuted'>    function addWBTCSettlementStrategy() private {</span>
 1393 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1394 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1395 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.addSettlementStrategy.selector,</span>
 1396 |     | <span class='unexecuted'>                2, // marketId</span>
 1397 |     | <span class='unexecuted'>                SettlementStrategy.Data({</span>
 1398 |     | <span class='neutral'>                    strategyType: WBTC_SETTLEMENT_STRATEGY_TYPE,</span>
 1399 |     | <span class='neutral'>                    settlementDelay: WBTC_SETTLEMENT_DELAY,</span>
 1400 |     | <span class='neutral'>                    settlementWindowDuration: WBTC_SETTLEMENT_WINDOW_DURATION,</span>
 1401 |     | <span class='unexecuted'>                    priceVerificationContract: address(pythWrapper),</span>
 1402 |     | <span class='neutral'>                    feedId: WBTC_FEED_ID,</span>
 1403 |     | <span class='neutral'>                    settlementReward: WBTC_SETTLEMENT_REWARD,</span>
 1404 |     | <span class='neutral'>                    disabled: WBTC_DISABLED,</span>
 1405 |     | <span class='neutral'>                    commitmentPriceDelay: WBTC_COMMITMENT_PRICE_DELAY</span>
 1406 |     | <span class='neutral'>                })</span>
 1407 |     | <span class='neutral'>            )</span>
 1408 |     | <span class='neutral'>        );</span>
 1409 |     | <span class='neutral'>        assert(success);</span>
 1410 |     | <span class='neutral'>    }</span>
 1411 |     | <span class='unexecuted'>    function addHUGESettlementStrategy() private {</span>
 1412 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1413 |     | <span class='neutral'>            abi.encodeWithSelector(</span>
 1414 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.addSettlementStrategy.selector,</span>
 1415 |     | <span class='unexecuted'>                3, // marketId</span>
 1416 |     | <span class='unexecuted'>                SettlementStrategy.Data({</span>
 1417 |     | <span class='neutral'>                    strategyType: HUGE_SETTLEMENT_STRATEGY_TYPE,</span>
 1418 |     | <span class='neutral'>                    settlementDelay: HUGE_SETTLEMENT_DELAY,</span>
 1419 |     | <span class='neutral'>                    settlementWindowDuration: HUGE_SETTLEMENT_WINDOW_DURATION,</span>
 1420 |     | <span class='neutral'>                    priceVerificationContract: address(pythWrapper),</span>
 1421 |     | <span class='neutral'>                    feedId: HUGE_FEED_ID,</span>
 1422 |     | <span class='neutral'>                    settlementReward: HUGE_SETTLEMENT_REWARD,</span>
 1423 |     | <span class='neutral'>                    disabled: HUGE_DISABLED,</span>
 1424 |     | <span class='neutral'>                    commitmentPriceDelay: HUGE_COMMITMENT_PRICE_DELAY</span>
 1425 |     | <span class='neutral'>                })</span>
 1426 |     | <span class='neutral'>            )</span>
 1427 |     | <span class='neutral'>        );</span>
 1428 |     | <span class='neutral'>        assert(success);</span>
 1429 |     | <span class='neutral'>    }</span>
 1430 |     | <span class='neutral'></span>
 1431 |     | <span class='unexecuted'>    function initializePerpsMarketFactory() private {</span>
 1432 |     | <span class='neutral'>        (</span>
 1433 |     | <span class='unexecuted'>            bool success, //returns supermarket id</span>
 1434 |     | <span class='neutral'></span>
 1435 |     | <span class='unexecuted'>        ) = perps.call(</span>
 1436 |     | <span class='unexecuted'>                abi.encodeWithSelector(</span>
 1437 |     | <span class='unexecuted'>                    perpsMarketFactoryModuleImpl.initializeFactory.selector,</span>
 1438 |     | <span class='unexecuted'>                    address(v3Mock),</span>
 1439 |     | <span class='unexecuted'>                    address(spot) //TODO: reckeck</span>
 1440 |     | <span class='neutral'>                )</span>
 1441 |     | <span class='neutral'>            );</span>
 1442 |     | <span class='neutral'>        assert(success);</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='unexecuted'>    function createKeeperCostNode() private {</span>
 1446 |     | <span class='unexecuted'>        mockGasPriceNode = new MockGasPriceNode();</span>
 1447 |     | <span class='neutral'></span>
 1448 |     | <span class='neutral'>        (bool success, ) = address(mockGasPriceNode).call(</span>
 1449 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1450 |     | <span class='unexecuted'>                mockGasPriceNode.setCosts.selector,</span>
 1451 |     | <span class='neutral'>                KEEPER_SETTLEMENT_COST,</span>
 1452 |     | <span class='neutral'>                KEEPER_FLAG_COST,</span>
 1453 |     | <span class='neutral'>                KEEPER_LIQUIDATE_COST</span>
 1454 |     | <span class='neutral'>            )</span>
 1455 |     | <span class='neutral'>        );</span>
 1456 |     | <span class='neutral'>        assert(success);</span>
 1457 |     | <span class='neutral'>    }</span>
 1458 |     | <span class='unexecuted'>    function updateKeeperCostNodeId() private {</span>
 1459 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1460 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1461 |     | <span class='unexecuted'>                globalPerpsMarketModuleImpl.updateKeeperCostNodeId.selector,</span>
 1462 |     | <span class='neutral'>                KEEPER_NODE_ID</span>
 1463 |     | <span class='neutral'>            )</span>
 1464 |     | <span class='neutral'>        );</span>
 1465 |     | <span class='neutral'>        assert(success);</span>
 1466 |     | <span class='neutral'>    }</span>
 1467 |     | <span class='neutral'></span>
 1468 |     | <span class='unexecuted'>    function setSnxUSDCollateralConfiguration() private {</span>
 1469 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1470 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1471 |     | <span class='unexecuted'>                collateralConfigurationModuleImpl</span>
 1472 |     | <span class='neutral'>                    .setCollateralConfiguration</span>
 1473 |     | <span class='neutral'>                    .selector,</span>
 1474 |     | <span class='neutral'>                SNX_USD_COLLATERAL_ID,</span>
 1475 |     | <span class='neutral'>                SNX_USD_MAX_COLLATERAL_AMOUNT,</span>
 1476 |     | <span class='neutral'>                SNX_USD_UPPER_LIMIT_DISCOUNT,</span>
 1477 |     | <span class='neutral'>                SNX_USD_LOWER_LIMIT_DISCOUNT,</span>
 1478 |     | <span class='neutral'>                SNX_USD_DISCOUNT_SCALAR</span>
 1479 |     | <span class='neutral'>            )</span>
 1480 |     | <span class='neutral'>        );</span>
 1481 |     | <span class='neutral'>        assert(success);</span>
 1482 |     | <span class='neutral'>    }</span>
 1483 |     | <span class='neutral'></span>
 1484 |     | <span class='unexecuted'>    function setWETHCollateralConfiguration() private {</span>
 1485 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1486 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1487 |     | <span class='unexecuted'>                collateralConfigurationModuleImpl</span>
 1488 |     | <span class='neutral'>                    .setCollateralConfiguration</span>
 1489 |     | <span class='neutral'>                    .selector,</span>
 1490 |     | <span class='neutral'>                WETH_COLLATERAL_ID,</span>
 1491 |     | <span class='neutral'>                WETH_MAX_COLLATERAL_AMOUNT,</span>
 1492 |     | <span class='neutral'>                WETH_UPPER_LIMIT_DISCOUNT,</span>
 1493 |     | <span class='neutral'>                WETH_LOWER_LIMIT_DISCOUNT,</span>
 1494 |     | <span class='neutral'>                WETH_DISCOUNT_SCALAR</span>
 1495 |     | <span class='neutral'>            )</span>
 1496 |     | <span class='neutral'>        );</span>
 1497 |     | <span class='neutral'>        assert(success);</span>
 1498 |     | <span class='neutral'>    }</span>
 1499 |     | <span class='neutral'></span>
 1500 |     | <span class='unexecuted'>    function setWBTCCollateralConfiguration() private {</span>
 1501 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1502 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1503 |     | <span class='unexecuted'>                collateralConfigurationModuleImpl</span>
 1504 |     | <span class='neutral'>                    .setCollateralConfiguration</span>
 1505 |     | <span class='neutral'>                    .selector,</span>
 1506 |     | <span class='neutral'>                WBTC_COLLATERAL_ID,</span>
 1507 |     | <span class='neutral'>                WBTC_MAX_COLLATERAL_AMOUNT,</span>
 1508 |     | <span class='neutral'>                WBTC_UPPER_LIMIT_DISCOUNT,</span>
 1509 |     | <span class='neutral'>                WBTC_LOWER_LIMIT_DISCOUNT,</span>
 1510 |     | <span class='neutral'>                WBTC_DISCOUNT_SCALAR</span>
 1511 |     | <span class='neutral'>            )</span>
 1512 |     | <span class='neutral'>        );</span>
 1513 |     | <span class='neutral'>        assert(success);</span>
 1514 |     | <span class='neutral'>    }</span>
 1515 |     | <span class='neutral'></span>
 1516 |     | <span class='unexecuted'>    function setHUGECollateralConfiguration() private {</span>
 1517 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1518 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1519 |     | <span class='unexecuted'>                collateralConfigurationModuleImpl</span>
 1520 |     | <span class='neutral'>                    .setCollateralConfiguration</span>
 1521 |     | <span class='neutral'>                    .selector,</span>
 1522 |     | <span class='neutral'>                HUGE_COLLATERAL_ID,</span>
 1523 |     | <span class='neutral'>                HUGE_MAX_COLLATERAL_AMOUNT,</span>
 1524 |     | <span class='neutral'>                HUGE_UPPER_LIMIT_DISCOUNT,</span>
 1525 |     | <span class='neutral'>                HUGE_LOWER_LIMIT_DISCOUNT,</span>
 1526 |     | <span class='neutral'>                HUGE_DISCOUNT_SCALAR</span>
 1527 |     | <span class='neutral'>            )</span>
 1528 |     | <span class='neutral'>        );</span>
 1529 |     | <span class='neutral'>        assert(success);</span>
 1530 |     | <span class='neutral'>    }</span>
 1531 |     | <span class='neutral'></span>
 1532 |     | <span class='unexecuted'>    function registerWETHDistributor() private {</span>
 1533 |     | <span class='unexecuted'>        address[] memory poolDelegatedCollateralTypes = new address[](1);</span>
 1534 |     | <span class='unexecuted'>        poolDelegatedCollateralTypes[0] = address(wethTokenMock);</span>
 1535 |     | <span class='neutral'></span>
 1536 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1537 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1538 |     | <span class='unexecuted'>                collateralConfigurationModuleImpl.registerDistributor.selector,</span>
 1539 |     | <span class='unexecuted'>                address(wethTokenMock),</span>
 1540 |     | <span class='unexecuted'>                address(rewardWETHDistributorMock),</span>
 1541 |     | <span class='neutral'>                1, // collateralId WETH</span>
 1542 |     | <span class='unexecuted'>                poolDelegatedCollateralTypes</span>
 1543 |     | <span class='neutral'>            )</span>
 1544 |     | <span class='neutral'>        );</span>
 1545 |     | <span class='unexecuted'>        assert(success);</span>
 1546 |     | <span class='neutral'>    }</span>
 1547 |     | <span class='neutral'></span>
 1548 |     | <span class='unexecuted'>    function registerWBTCDistributor() private {</span>
 1549 |     | <span class='unexecuted'>        address[] memory poolDelegatedCollateralTypes = new address[](1);</span>
 1550 |     | <span class='unexecuted'>        poolDelegatedCollateralTypes[0] = address(wbtcTokenMock);</span>
 1551 |     | <span class='neutral'></span>
 1552 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1553 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1554 |     | <span class='unexecuted'>                collateralConfigurationModuleImpl.registerDistributor.selector,</span>
 1555 |     | <span class='unexecuted'>                address(wbtcTokenMock),</span>
 1556 |     | <span class='unexecuted'>                address(rewardWBTCDistributorMock),</span>
 1557 |     | <span class='unexecuted'>                2, // collateralId WBTC</span>
 1558 |     | <span class='unexecuted'>                poolDelegatedCollateralTypes</span>
 1559 |     | <span class='neutral'>            )</span>
 1560 |     | <span class='neutral'>        );</span>
 1561 |     | <span class='neutral'>        assert(success);</span>
 1562 |     | <span class='neutral'>    }</span>
 1563 |     | <span class='neutral'></span>
 1564 |     | <span class='unexecuted'>    function registerHugeDistributor() private {</span>
 1565 |     | <span class='unexecuted'>        address[] memory poolDelegatedCollateralTypes = new address[](1);</span>
 1566 |     | <span class='unexecuted'>        poolDelegatedCollateralTypes[0] = address(hugePrecisionTokenMock);</span>
 1567 |     | <span class='neutral'></span>
 1568 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1569 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1570 |     | <span class='unexecuted'>                collateralConfigurationModuleImpl.registerDistributor.selector,</span>
 1571 |     | <span class='unexecuted'>                address(hugePrecisionTokenMock),</span>
 1572 |     | <span class='unexecuted'>                address(rewardHUGEDistributorMock),</span>
 1573 |     | <span class='unexecuted'>                3, // collateralId HUGE</span>
 1574 |     | <span class='unexecuted'>                poolDelegatedCollateralTypes</span>
 1575 |     | <span class='neutral'>            )</span>
 1576 |     | <span class='neutral'>        );</span>
 1577 |     | <span class='neutral'>        assert(success);</span>
 1578 |     | <span class='neutral'>    }</span>
 1579 |     | <span class='neutral'></span>
 1580 |     | <span class='unexecuted'>    function setSynthMaketIdAndAddresses() private {</span>
 1581 |     | <span class='unexecuted'>        uint[] memory synthIds = new uint[](3);</span>
 1582 |     | <span class='unexecuted'>        synthIds[0] = 1; //starting from 1 (typical dev comment :)</span>
 1583 |     | <span class='unexecuted'>        synthIds[1] = 2;</span>
 1584 |     | <span class='unexecuted'>        synthIds[2] = 3;</span>
 1585 |     | <span class='neutral'></span>
 1586 |     | <span class='unexecuted'>        address[] memory synthAddresses = new address[](3);</span>
 1587 |     | <span class='unexecuted'>        synthAddresses[0] = address(wethTokenMock);</span>
 1588 |     | <span class='unexecuted'>        synthAddresses[1] = address(wbtcTokenMock);</span>
 1589 |     | <span class='unexecuted'>        synthAddresses[2] = address(hugePrecisionTokenMock);</span>
 1590 |     | <span class='neutral'></span>
 1591 |     | <span class='unexecuted'>        (bool success, ) = address(spot).call(</span>
 1592 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1593 |     | <span class='unexecuted'>                spot.setSynthForMarketId.selector,</span>
 1594 |     | <span class='unexecuted'>                synthIds,</span>
 1595 |     | <span class='unexecuted'>                synthAddresses</span>
 1596 |     | <span class='neutral'>            )</span>
 1597 |     | <span class='neutral'>        );</span>
 1598 |     | <span class='unexecuted'>        assert(success);</span>
 1599 |     | <span class='neutral'>    }</span>
 1600 |     | <span class='neutral'></span>
 1601 |     | <span class='unexecuted'>    function addToFeatureFlagAllowlist() private {</span>
 1602 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1603 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1604 |     | <span class='unexecuted'>                featureFlagModuleImpl.addToFeatureFlagAllowlist.selector,</span>
 1605 |     | <span class='neutral'>                bytes32(&quot;createPool&quot;),</span>
 1606 |     | <span class='unexecuted'>                address(this)</span>
 1607 |     | <span class='neutral'>            )</span>
 1608 |     | <span class='neutral'>        );</span>
 1609 |     | <span class='neutral'>        assert(success);</span>
 1610 |     | <span class='neutral'>    }</span>
 1611 |     | <span class='neutral'></span>
 1612 |     | <span class='unexecuted'>    function createAccounts() private {</span>
 1613 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1614 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1615 |     | <span class='neutral'>                mockModuleImpl.createAccount.selector,</span>
 1616 |     | <span class='neutral'>                uint128(1),</span>
 1617 |     | <span class='neutral'>                USER1</span>
 1618 |     | <span class='neutral'>            )</span>
 1619 |     | <span class='neutral'>        );</span>
 1620 |     | <span class='unexecuted'>        assert(success);</span>
 1621 |     | <span class='neutral'></span>
 1622 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1623 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1624 |     | <span class='neutral'>                mockModuleImpl.createAccount.selector,</span>
 1625 |     | <span class='unexecuted'>                uint128(2),</span>
 1626 |     | <span class='neutral'>                USER2</span>
 1627 |     | <span class='neutral'>            )</span>
 1628 |     | <span class='neutral'>        );</span>
 1629 |     | <span class='unexecuted'>        assert(success);</span>
 1630 |     | <span class='neutral'></span>
 1631 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1632 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1633 |     | <span class='unexecuted'>                mockModuleImpl.createAccount.selector,</span>
 1634 |     | <span class='unexecuted'>                uint128(3),</span>
 1635 |     | <span class='neutral'>                USER3</span>
 1636 |     | <span class='neutral'>            )</span>
 1637 |     | <span class='neutral'>        );</span>
 1638 |     | <span class='neutral'>        assert(success);</span>
 1639 |     | <span class='neutral'>    }</span>
 1640 |     | <span class='neutral'>    event MsgSender(address sender);</span>
 1641 |     | <span class='unexecuted'>    function grantAccountPermissions() private {</span>
 1642 |     | <span class='unexecuted'>        vm.prank(USER1);</span>
 1643 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1644 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1645 |     | <span class='neutral'>                mockModuleImpl.grantPermission.selector,</span>
 1646 |     | <span class='neutral'>                uint128(1),</span>
 1647 |     | <span class='neutral'>                AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION,</span>
 1648 |     | <span class='neutral'>                USER1</span>
 1649 |     | <span class='neutral'>            )</span>
 1650 |     | <span class='neutral'>        );</span>
 1651 |     | <span class='unexecuted'>        assert(success);</span>
 1652 |     | <span class='neutral'></span>
 1653 |     | <span class='unexecuted'>        vm.prank(USER2);</span>
 1654 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1655 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1656 |     | <span class='neutral'>                mockModuleImpl.grantPermission.selector,</span>
 1657 |     | <span class='unexecuted'>                uint128(2),</span>
 1658 |     | <span class='neutral'>                AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION,</span>
 1659 |     | <span class='neutral'>                USER2</span>
 1660 |     | <span class='neutral'>            )</span>
 1661 |     | <span class='neutral'>        );</span>
 1662 |     | <span class='unexecuted'>        assert(success);</span>
 1663 |     | <span class='neutral'></span>
 1664 |     | <span class='unexecuted'>        vm.prank(USER3);</span>
 1665 |     | <span class='unexecuted'>        console2.log(&quot;Msg sender in setup&quot;, msg.sender);</span>
 1666 |     | <span class='unexecuted'>        (success, ) = perps.call(</span>
 1667 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1668 |     | <span class='unexecuted'>                mockModuleImpl.grantPermission.selector,</span>
 1669 |     | <span class='unexecuted'>                uint128(3),</span>
 1670 |     | <span class='neutral'>                AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION,</span>
 1671 |     | <span class='neutral'>                USER3</span>
 1672 |     | <span class='neutral'>            )</span>
 1673 |     | <span class='neutral'>        );</span>
 1674 |     | <span class='neutral'>        assert(success);</span>
 1675 |     | <span class='neutral'>    }</span>
 1676 |     | <span class='neutral'></span>
 1677 |     | <span class='unexecuted'>    function setMaxCollateralsPerAccount() private {</span>
 1678 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = perps.call(</span>
 1679 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1680 |     | <span class='unexecuted'>                globalPerpsMarketModuleImpl.setPerAccountCaps.selector,</span>
 1681 |     | <span class='neutral'>                MAX_POSITIONS_PER_ACCOUNT,</span>
 1682 |     | <span class='neutral'>                MAX_COLLATERALS_PER_ACCOUNT</span>
 1683 |     | <span class='neutral'>            )</span>
 1684 |     | <span class='neutral'>        );</span>
 1685 |     | <span class='unexecuted'>        assert(success);</span>
 1686 |     | <span class='neutral'>    }</span>
 1687 |     | <span class='neutral'></span>
 1688 |     | <span class='unexecuted'>    function setupActors() internal {</span>
 1689 |     | <span class='unexecuted'>        setupAccountIds();</span>
 1690 |     | <span class='neutral'></span>
 1691 |     | <span class='unexecuted'>        bool success;</span>
 1692 |     | <span class='unexecuted'>        address[] memory targets = new address[](2);</span>
 1693 |     | <span class='unexecuted'>        targets[0] = address(perps);</span>
 1694 |     | <span class='unexecuted'>        targets[1] = address(v3Mock);</span>
 1695 |     | <span class='neutral'></span>
 1696 |     | <span class='unexecuted'>        tokens.push(sUSDTokenMock);</span>
 1697 |     | <span class='unexecuted'>        tokens.push(wethTokenMock);</span>
 1698 |     | <span class='unexecuted'>        tokens.push(wbtcTokenMock);</span>
 1699 |     | <span class='unexecuted'>        tokens.push(hugePrecisionTokenMock);</span>
 1700 |     | <span class='neutral'></span>
 1701 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt; USERS.length; i++) {</span>
 1702 |     | <span class='unexecuted'>            address user = USERS[i];</span>
 1703 |     | <span class='unexecuted'>            (success, ) = address(user).call{value: INITIAL_BALANCE}(&quot;&quot;);</span>
 1704 |     | <span class='unexecuted'>            assert(success);</span>
 1705 |     | <span class='neutral'></span>
 1706 |     | <span class='unexecuted'>            for (uint8 j = 0; j &lt; tokens.length; j++) {</span>
 1707 |     | <span class='unexecuted'>                tokens[j].mint(</span>
 1708 |     | <span class='unexecuted'>                    user,</span>
 1709 |     | <span class='unexecuted'>                    INITIAL_TOKEN_BALANCE * (10 ** tokens[j].decimals())</span>
 1710 |     | <span class='neutral'>                );</span>
 1711 |     | <span class='unexecuted'>                for (uint8 k = 0; k &lt; targets.length; k++) {</span>
 1712 |     | <span class='unexecuted'>                    vm.prank(user);</span>
 1713 |     | <span class='unexecuted'>                    tokens[j].approve(targets[k], type(uint128).max);</span>
 1714 |     | <span class='neutral'>                }</span>
 1715 |     | <span class='neutral'>            }</span>
 1716 |     | <span class='neutral'>        }</span>
 1717 |     | <span class='neutral'></span>
 1718 |     | <span class='unexecuted'>        _depositInitialAmounts(1, 0, 10_000e18);</span>
 1719 |     | <span class='neutral'>    }</span>
 1720 |     | <span class='neutral'></span>
 1721 |     | <span class='unexecuted'>    function setupAccountIds() internal {</span>
 1722 |     | <span class='unexecuted'>        userToAccountIds[USER1] = uint128(1);</span>
 1723 |     | <span class='unexecuted'>        userToAccountIds[USER2] = uint128(2);</span>
 1724 |     | <span class='unexecuted'>        userToAccountIds[USER3] = uint128(3);</span>
 1725 |     | <span class='unexecuted'>        accountIdToUser[uint128(1)] = USER1;</span>
 1726 |     | <span class='unexecuted'>        accountIdToUser[uint128(2)] = USER2;</span>
 1727 |     | <span class='unexecuted'>        accountIdToUser[uint128(3)] = USER3;</span>
 1728 |     | <span class='neutral'>    }</span>
 1729 |     | <span class='neutral'></span>
 1730 |     | <span class='unexecuted'>    function setPythPriceFeed() private {</span>
 1731 |     | <span class='neutral'>        // Add price feeds</span>
 1732 |     | <span class='unexecuted'>        addPriceFeed(</span>
 1733 |     | <span class='neutral'>            WETH_PYTH_PRICE_FEED_ID,</span>
 1734 |     | <span class='neutral'>            WETH_STARTING_PRICE,</span>
 1735 |     | <span class='neutral'>            WETH_STARTING_CONF,</span>
 1736 |     | <span class='neutral'>            WETH_STARTING_EXPO</span>
 1737 |     | <span class='neutral'>        );</span>
 1738 |     | <span class='unexecuted'>        addPriceFeed(</span>
 1739 |     | <span class='neutral'>            WBTC_PYTH_PRICE_FEED_ID,</span>
 1740 |     | <span class='neutral'>            WBTC_STARTING_PRICE,</span>
 1741 |     | <span class='neutral'>            WBTC_STARTING_CONF,</span>
 1742 |     | <span class='neutral'>            WBTC_STARTING_EXPO</span>
 1743 |     | <span class='neutral'>        );</span>
 1744 |     | <span class='unexecuted'>        addPriceFeed(</span>
 1745 |     | <span class='neutral'>            HUGE_PYTH_PRICE_FEED_ID,</span>
 1746 |     | <span class='neutral'>            HUGE_STARTING_PRICE,</span>
 1747 |     | <span class='neutral'>            HUGE_STARTING_CONF,</span>
 1748 |     | <span class='neutral'>            HUGE_STARTING_EXPO</span>
 1749 |     | <span class='neutral'>        );</span>
 1750 |     | <span class='neutral'></span>
 1751 |     | <span class='neutral'>        // Set oracle nodes</span>
 1752 |     | <span class='unexecuted'>        oracleNodes[WETH_ORACLE_NODE_ID] = WETH_PYTH_PRICE_FEED_ID;</span>
 1753 |     | <span class='unexecuted'>        oracleNodes[WBTC_ORACLE_NODE_ID] = WBTC_PYTH_PRICE_FEED_ID;</span>
 1754 |     | <span class='neutral'>        oracleNodes[HUGE_ORACLE_NODE_ID] = HUGE_PYTH_PRICE_FEED_ID;</span>
 1755 |     | <span class='neutral'></span>
 1756 |     | <span class='neutral'>        oracleNodes[WETH_PYTH_PRICE_FEED_ID] = WETH_ORACLE_NODE_ID;</span>
 1757 |     | <span class='unexecuted'>        oracleNodes[WBTC_ORACLE_NODE_ID] = WBTC_ORACLE_NODE_ID;</span>
 1758 |     | <span class='neutral'>        oracleNodes[HUGE_ORACLE_NODE_ID] = HUGE_ORACLE_NODE_ID;</span>
 1759 |     | <span class='neutral'>    }</span>
 1760 |     | <span class='neutral'></span>
 1761 |     | <span class='unexecuted'>    function addPriceFeed(</span>
 1762 |     | <span class='neutral'>        bytes32 id,</span>
 1763 |     | <span class='neutral'>        int64 startingPrice,</span>
 1764 |     | <span class='neutral'>        uint64 startingConf,</span>
 1765 |     | <span class='neutral'>        int32 startingExpo</span>
 1766 |     | <span class='unexecuted'>    ) private {</span>
 1767 |     | <span class='unexecuted'>        (bool success, ) = address(mockPyth).call(</span>
 1768 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1769 |     | <span class='neutral'>                mockPyth.addPriceFeed.selector,</span>
 1770 |     | <span class='neutral'>                id,</span>
 1771 |     | <span class='neutral'>                startingPrice,</span>
 1772 |     | <span class='neutral'>                startingConf,</span>
 1773 |     | <span class='neutral'>                startingExpo</span>
 1774 |     | <span class='neutral'>            )</span>
 1775 |     | <span class='neutral'>        );</span>
 1776 |     | <span class='unexecuted'>        assert(success);</span>
 1777 |     | <span class='neutral'>    }</span>
 1778 |     | <span class='neutral'></span>
 1779 |     | <span class='neutral'>    function setPythRequiredFee() private {</span>
 1780 |     | <span class='neutral'>        mockPyth.setRequiredFee(100);</span>
 1781 |     | <span class='neutral'>    }</span>
 1782 |     | <span class='neutral'></span>
 1783 |     | <span class='unexecuted'>    function setUpdatePriceDataWETH() private {</span>
 1784 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1785 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1786 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.updatePriceData.selector,</span>
 1787 |     | <span class='neutral'>                1,</span>
 1788 |     | <span class='neutral'>                WETH_PYTH_PRICE_FEED_ID,</span>
 1789 |     | <span class='neutral'>                STRICT_PRICE_TOLERANCE</span>
 1790 |     | <span class='neutral'>            )</span>
 1791 |     | <span class='neutral'>        );</span>
 1792 |     | <span class='neutral'>        assert(success);</span>
 1793 |     | <span class='neutral'>    }</span>
 1794 |     | <span class='neutral'></span>
 1795 |     | <span class='unexecuted'>    function setUpdatePriceDataWBTC() private {</span>
 1796 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1797 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1798 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.updatePriceData.selector,</span>
 1799 |     | <span class='unexecuted'>                2,</span>
 1800 |     | <span class='neutral'>                WBTC_PYTH_PRICE_FEED_ID,</span>
 1801 |     | <span class='neutral'>                STRICT_PRICE_TOLERANCE</span>
 1802 |     | <span class='neutral'>            )</span>
 1803 |     | <span class='neutral'>        );</span>
 1804 |     | <span class='neutral'>        assert(success);</span>
 1805 |     | <span class='neutral'>    }</span>
 1806 |     | <span class='neutral'></span>
 1807 |     | <span class='unexecuted'>    function setUpdatePriceDataHUGE() private {</span>
 1808 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1809 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1810 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.updatePriceData.selector,</span>
 1811 |     | <span class='unexecuted'>                3,</span>
 1812 |     | <span class='neutral'>                HUGE_PYTH_PRICE_FEED_ID,</span>
 1813 |     | <span class='neutral'>                STRICT_PRICE_TOLERANCE</span>
 1814 |     | <span class='neutral'>            )</span>
 1815 |     | <span class='neutral'>        );</span>
 1816 |     | <span class='neutral'>        assert(success);</span>
 1817 |     | <span class='neutral'>    }</span>
 1818 |     | <span class='neutral'>    //from test/integration/bootstrap/bootstrapPerpsMarkets.ts</span>
 1819 |     | <span class='unexecuted'>    function setFundingParametersWETH() private {</span>
 1820 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1821 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1822 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setFundingParameters.selector,</span>
 1823 |     | <span class='neutral'>                1,</span>
 1824 |     | <span class='neutral'>                WETH_SKEW_SCALE,</span>
 1825 |     | <span class='neutral'>                WETH_MAX_FUNDING_VELOCITY</span>
 1826 |     | <span class='neutral'>            )</span>
 1827 |     | <span class='neutral'>        );</span>
 1828 |     | <span class='neutral'>        assert(success);</span>
 1829 |     | <span class='neutral'>    }</span>
 1830 |     | <span class='neutral'></span>
 1831 |     | <span class='unexecuted'>    function setFundingParametersWBTC() private {</span>
 1832 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1833 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1834 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setFundingParameters.selector,</span>
 1835 |     | <span class='unexecuted'>                2,</span>
 1836 |     | <span class='neutral'>                WBTC_SKEW_SCALE,</span>
 1837 |     | <span class='neutral'>                WBTC_MAX_FUNDING_VELOCITY</span>
 1838 |     | <span class='neutral'>            )</span>
 1839 |     | <span class='neutral'>        );</span>
 1840 |     | <span class='neutral'>        assert(success);</span>
 1841 |     | <span class='neutral'>    }</span>
 1842 |     | <span class='neutral'></span>
 1843 |     | <span class='unexecuted'>    function setFundingParametersHUGE() private {</span>
 1844 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1845 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1846 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setFundingParameters.selector,</span>
 1847 |     | <span class='unexecuted'>                3,</span>
 1848 |     | <span class='neutral'>                HUGE_SKEW_SCALE,</span>
 1849 |     | <span class='neutral'>                HUGE_MAX_FUNDING_VELOCITY</span>
 1850 |     | <span class='neutral'>            )</span>
 1851 |     | <span class='neutral'>        );</span>
 1852 |     | <span class='neutral'>        assert(success);</span>
 1853 |     | <span class='neutral'>    }</span>
 1854 |     | <span class='neutral'></span>
 1855 |     | <span class='unexecuted'>    function setMaxMarketSizeWETH() private {</span>
 1856 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1857 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1858 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setMaxMarketSize.selector,</span>
 1859 |     | <span class='neutral'>                1, // WETH market ID hardcoded</span>
 1860 |     | <span class='neutral'>                WETH_MAX_MARKET_SIZE</span>
 1861 |     | <span class='neutral'>            )</span>
 1862 |     | <span class='neutral'>        );</span>
 1863 |     | <span class='neutral'>        assert(success);</span>
 1864 |     | <span class='neutral'>    }</span>
 1865 |     | <span class='unexecuted'>    function setMaxMarketSizeWBTC() private {</span>
 1866 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1867 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1868 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setMaxMarketSize.selector,</span>
 1869 |     | <span class='unexecuted'>                2, // WBTC market ID hardcoded</span>
 1870 |     | <span class='neutral'>                WBTC_MAX_MARKET_SIZE</span>
 1871 |     | <span class='neutral'>            )</span>
 1872 |     | <span class='neutral'>        );</span>
 1873 |     | <span class='neutral'>        assert(success);</span>
 1874 |     | <span class='neutral'>    }</span>
 1875 |     | <span class='unexecuted'>    function setMaxMarketSizeHUGE() private {</span>
 1876 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1877 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1878 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setMaxMarketSize.selector,</span>
 1879 |     | <span class='unexecuted'>                3, // WBTC market ID hardcoded</span>
 1880 |     | <span class='neutral'>                HUGE_MAX_MARKET_SIZE</span>
 1881 |     | <span class='neutral'>            )</span>
 1882 |     | <span class='neutral'>        );</span>
 1883 |     | <span class='neutral'>        assert(success);</span>
 1884 |     | <span class='neutral'>    }</span>
 1885 |     | <span class='neutral'></span>
 1886 |     | <span class='unexecuted'>    function setMaxMarketValueWETH() private {</span>
 1887 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1888 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1889 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setMaxMarketValue.selector,</span>
 1890 |     | <span class='neutral'>                1, // WETH market ID hardcoded</span>
 1891 |     | <span class='neutral'>                WETH_MAX_MARKET_VALUE</span>
 1892 |     | <span class='neutral'>            )</span>
 1893 |     | <span class='neutral'>        );</span>
 1894 |     | <span class='neutral'>        assert(success);</span>
 1895 |     | <span class='neutral'>    }</span>
 1896 |     | <span class='neutral'></span>
 1897 |     | <span class='unexecuted'>    function setMaxMarketValueWBTC() private {</span>
 1898 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1899 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1900 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setMaxMarketValue.selector,</span>
 1901 |     | <span class='unexecuted'>                2, // WBTC market ID hardcoded</span>
 1902 |     | <span class='neutral'>                WBTC_MAX_MARKET_VALUE</span>
 1903 |     | <span class='neutral'>            )</span>
 1904 |     | <span class='neutral'>        );</span>
 1905 |     | <span class='neutral'>        assert(success);</span>
 1906 |     | <span class='neutral'>    }</span>
 1907 |     | <span class='neutral'></span>
 1908 |     | <span class='unexecuted'>    function setMaxMarketValueHUGE() private {</span>
 1909 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1910 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1911 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setMaxMarketValue.selector,</span>
 1912 |     | <span class='unexecuted'>                3, // WBTC market ID hardcoded</span>
 1913 |     | <span class='neutral'>                HUGE_MAX_MARKET_VALUE</span>
 1914 |     | <span class='neutral'>            )</span>
 1915 |     | <span class='neutral'>        );</span>
 1916 |     | <span class='neutral'>        assert(success);</span>
 1917 |     | <span class='neutral'>    }</span>
 1918 |     | <span class='neutral'></span>
 1919 |     | <span class='unexecuted'>    function setOrderFeesWETH() private {</span>
 1920 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1921 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1922 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setOrderFees.selector,</span>
 1923 |     | <span class='neutral'>                1, // WETH market ID hardcoded</span>
 1924 |     | <span class='neutral'>                WETH_MAKER_FEE_RATIO,</span>
 1925 |     | <span class='neutral'>                WETH_TAKER_FEE_RATIO</span>
 1926 |     | <span class='neutral'>            )</span>
 1927 |     | <span class='neutral'>        );</span>
 1928 |     | <span class='neutral'>        assert(success);</span>
 1929 |     | <span class='neutral'>    }</span>
 1930 |     | <span class='neutral'></span>
 1931 |     | <span class='unexecuted'>    function setOrderFeesWBTC() private {</span>
 1932 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1933 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1934 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setOrderFees.selector,</span>
 1935 |     | <span class='unexecuted'>                2, // WBTC market ID hardcoded</span>
 1936 |     | <span class='neutral'>                WBTC_MAKER_FEE_RATIO,</span>
 1937 |     | <span class='neutral'>                WBTC_TAKER_FEE_RATIO</span>
 1938 |     | <span class='neutral'>            )</span>
 1939 |     | <span class='neutral'>        );</span>
 1940 |     | <span class='neutral'>        assert(success);</span>
 1941 |     | <span class='neutral'>    }</span>
 1942 |     | <span class='unexecuted'>    function setOrderFeesHUGE() private {</span>
 1943 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1944 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1945 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setOrderFees.selector,</span>
 1946 |     | <span class='unexecuted'>                3, // WBTC market ID hardcoded</span>
 1947 |     | <span class='neutral'>                HUGE_MAKER_FEE_RATIO,</span>
 1948 |     | <span class='neutral'>                HUGE_TAKER_FEE_RATIO</span>
 1949 |     | <span class='neutral'>            )</span>
 1950 |     | <span class='neutral'>        );</span>
 1951 |     | <span class='neutral'>        assert(success);</span>
 1952 |     | <span class='neutral'>    }</span>
 1953 |     | <span class='neutral'></span>
 1954 |     | <span class='unexecuted'>    function setLiquidationParametersWETH() private {</span>
 1955 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1956 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1957 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setLiquidationParameters.selector,</span>
 1958 |     | <span class='neutral'>                1,</span>
 1959 |     | <span class='neutral'>                WETH_INITIAL_MARGIN_FRACTION,</span>
 1960 |     | <span class='neutral'>                WETH_MINIMUM_INITIAL_MARGIN_RATIO,</span>
 1961 |     | <span class='neutral'>                WETH_MAINTENANCE_MARGIN_SCALAR,</span>
 1962 |     | <span class='neutral'>                WETH_LIQUIDATION_REWARD_RATIO,</span>
 1963 |     | <span class='neutral'>                WETH_MINIMUM_POSITION_MARGIN</span>
 1964 |     | <span class='neutral'>            )</span>
 1965 |     | <span class='neutral'>        );</span>
 1966 |     | <span class='neutral'>        assert(success);</span>
 1967 |     | <span class='neutral'>    }</span>
 1968 |     | <span class='neutral'></span>
 1969 |     | <span class='unexecuted'>    function setLiquidationParametersWBTC() private {</span>
 1970 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1971 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1972 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setLiquidationParameters.selector,</span>
 1973 |     | <span class='unexecuted'>                2,</span>
 1974 |     | <span class='neutral'>                WBTC_INITIAL_MARGIN_FRACTION,</span>
 1975 |     | <span class='neutral'>                WBTC_MINIMUM_INITIAL_MARGIN_RATIO,</span>
 1976 |     | <span class='neutral'>                WBTC_MAINTENANCE_MARGIN_SCALAR,</span>
 1977 |     | <span class='neutral'>                WBTC_LIQUIDATION_REWARD_RATIO,</span>
 1978 |     | <span class='neutral'>                WBTC_MINIMUM_POSITION_MARGIN</span>
 1979 |     | <span class='neutral'>            )</span>
 1980 |     | <span class='neutral'>        );</span>
 1981 |     | <span class='neutral'>        assert(success);</span>
 1982 |     | <span class='neutral'>    }</span>
 1983 |     | <span class='unexecuted'>    function setLiquidationParametersHUGE() private {</span>
 1984 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 1985 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1986 |     | <span class='unexecuted'>                marketConfigurationModuleImpl.setLiquidationParameters.selector,</span>
 1987 |     | <span class='unexecuted'>                3,</span>
 1988 |     | <span class='neutral'>                HUGE_INITIAL_MARGIN_FRACTION,</span>
 1989 |     | <span class='neutral'>                HUGE_MINIMUM_INITIAL_MARGIN_RATIO,</span>
 1990 |     | <span class='neutral'>                HUGE_MAINTENANCE_MARGIN_SCALAR,</span>
 1991 |     | <span class='neutral'>                HUGE_LIQUIDATION_REWARD_RATIO,</span>
 1992 |     | <span class='neutral'>                HUGE_MINIMUM_POSITION_MARGIN</span>
 1993 |     | <span class='neutral'>            )</span>
 1994 |     | <span class='neutral'>        );</span>
 1995 |     | <span class='neutral'>        assert(success);</span>
 1996 |     | <span class='neutral'>    }</span>
 1997 |     | <span class='neutral'></span>
 1998 |     | <span class='unexecuted'>    function setMaxLiquidationParametersWETH() private {</span>
 1999 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 2000 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2001 |     | <span class='unexecuted'>                marketConfigurationModuleImpl</span>
 2002 |     | <span class='neutral'>                    .setMaxLiquidationParameters</span>
 2003 |     | <span class='neutral'>                    .selector,</span>
 2004 |     | <span class='neutral'>                1,</span>
 2005 |     | <span class='neutral'>                WETH_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER,</span>
 2006 |     | <span class='neutral'>                WETH_MAX_SECONDS_IN_LIQUIDATION_WINDOW,</span>
 2007 |     | <span class='neutral'>                WETH_MAX_LIQUIDATION_PD,</span>
 2008 |     | <span class='neutral'>                WETH_ENDORSED_LIQUIDATOR</span>
 2009 |     | <span class='neutral'>            )</span>
 2010 |     | <span class='neutral'>        );</span>
 2011 |     | <span class='neutral'>        assert(success);</span>
 2012 |     | <span class='neutral'>    }</span>
 2013 |     | <span class='neutral'></span>
 2014 |     | <span class='unexecuted'>    function setMaxLiquidationParametersWBTC() private {</span>
 2015 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 2016 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2017 |     | <span class='unexecuted'>                marketConfigurationModuleImpl</span>
 2018 |     | <span class='neutral'>                    .setMaxLiquidationParameters</span>
 2019 |     | <span class='neutral'>                    .selector,</span>
 2020 |     | <span class='unexecuted'>                2,</span>
 2021 |     | <span class='neutral'>                WBTC_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER,</span>
 2022 |     | <span class='neutral'>                WBTC_MAX_SECONDS_IN_LIQUIDATION_WINDOW,</span>
 2023 |     | <span class='neutral'>                WBTC_MAX_LIQUIDATION_PD,</span>
 2024 |     | <span class='neutral'>                WBTC_ENDORSED_LIQUIDATOR</span>
 2025 |     | <span class='neutral'>            )</span>
 2026 |     | <span class='neutral'>        );</span>
 2027 |     | <span class='neutral'>        assert(success);</span>
 2028 |     | <span class='neutral'>    }</span>
 2029 |     | <span class='unexecuted'>    function setMaxLiquidationParametersHUGE() private {</span>
 2030 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 2031 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2032 |     | <span class='unexecuted'>                marketConfigurationModuleImpl</span>
 2033 |     | <span class='neutral'>                    .setMaxLiquidationParameters</span>
 2034 |     | <span class='neutral'>                    .selector,</span>
 2035 |     | <span class='unexecuted'>                3,</span>
 2036 |     | <span class='neutral'>                HUGE_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER,</span>
 2037 |     | <span class='neutral'>                HUGE_MAX_SECONDS_IN_LIQUIDATION_WINDOW,</span>
 2038 |     | <span class='neutral'>                HUGE_MAX_LIQUIDATION_PD,</span>
 2039 |     | <span class='neutral'>                HUGE_ENDORSED_LIQUIDATOR</span>
 2040 |     | <span class='neutral'>            )</span>
 2041 |     | <span class='neutral'>        );</span>
 2042 |     | <span class='neutral'>        assert(success);</span>
 2043 |     | <span class='neutral'>    }</span>
 2044 |     | <span class='unexecuted'>    function setPerpsMarketName() private {</span>
 2045 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 2046 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2047 |     | <span class='unexecuted'>                perpsMarketFactoryModuleImpl.setPerpsMarketName.selector,</span>
 2048 |     | <span class='neutral'>                &quot;SuperMarket&quot;</span>
 2049 |     | <span class='neutral'>            )</span>
 2050 |     | <span class='neutral'>        );</span>
 2051 |     | <span class='neutral'>        assert(success);</span>
 2052 |     | <span class='neutral'>    }</span>
 2053 |     | <span class='neutral'></span>
 2054 |     | <span class='unexecuted'>    function setCreateMarketWETH() private {</span>
 2055 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 2056 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2057 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.createMarket.selector,</span>
 2058 |     | <span class='neutral'>                1, //requestedMarketId</span>
 2059 |     | <span class='neutral'>                &quot;WETH/USD&quot;, //marketName</span>
 2060 |     | <span class='neutral'>                &quot;WETHUSD&quot; //marketSymbol</span>
 2061 |     | <span class='neutral'>            )</span>
 2062 |     | <span class='neutral'>        );</span>
 2063 |     | <span class='unexecuted'>        assert(success);</span>
 2064 |     | <span class='unexecuted'>        collateralToMarketId[address(wethTokenMock)] = 1;</span>
 2065 |     | <span class='neutral'>    }</span>
 2066 |     | <span class='unexecuted'>    function setPerpMarketFactoryModuleImplInVault() private {</span>
 2067 |     | <span class='unexecuted'>        vaultModuleMock.setPerpMarketFactoryModuleImpl(</span>
 2068 |     | <span class='unexecuted'>            perpsMarketFactoryModuleImpl</span>
 2069 |     | <span class='neutral'>        );</span>
 2070 |     | <span class='neutral'>    }</span>
 2071 |     | <span class='neutral'></span>
 2072 |     | <span class='unexecuted'>    function setCreateMarketWBTC() private {</span>
 2073 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 2074 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2075 |     | <span class='unexecuted'>                perpsMarketFactoryModuleImpl.createMarket.selector,</span>
 2076 |     | <span class='unexecuted'>                2, //requestedMarketId</span>
 2077 |     | <span class='neutral'>                &quot;WBTC/USD&quot;, //marketName</span>
 2078 |     | <span class='neutral'>                &quot;WBTCUSD&quot; //marketSymbol</span>
 2079 |     | <span class='neutral'>            )</span>
 2080 |     | <span class='neutral'>        );</span>
 2081 |     | <span class='unexecuted'>        assert(success);</span>
 2082 |     | <span class='unexecuted'>        collateralToMarketId[address(wbtcTokenMock)] = 2;</span>
 2083 |     | <span class='neutral'>    }</span>
 2084 |     | <span class='neutral'></span>
 2085 |     | <span class='unexecuted'>    function setCreateMarketHUGE() private {</span>
 2086 |     | <span class='unexecuted'>        (bool success, ) = perps.call(</span>
 2087 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2088 |     | <span class='unexecuted'>                perpsMarketFactoryModuleImpl.createMarket.selector,</span>
 2089 |     | <span class='unexecuted'>                3, //requestedMarketId</span>
 2090 |     | <span class='neutral'>                &quot;HUGE/USD&quot;, //marketName</span>
 2091 |     | <span class='neutral'>                &quot;HUGEUSD&quot; //marketSymbol</span>
 2092 |     | <span class='neutral'>            )</span>
 2093 |     | <span class='neutral'>        );</span>
 2094 |     | <span class='neutral'>        assert(success);</span>
 2095 |     | <span class='neutral'>        collateralToMarketId[address(wbtcTokenMock)] = 2;</span>
 2096 |     | <span class='neutral'>    }</span>
 2097 |     | <span class='neutral'></span>
 2098 | *   | <span class='executed'>    function _getRandomCollateralToken(</span>
 2099 |     | <span class='neutral'>        uint256 collateralTokenIndex</span>
 2100 | *   | <span class='executed'>    ) internal returns (address) {</span>
 2101 | *   | <span class='executed'>        (bool success, bytes memory data) = perps.call(</span>
 2102 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 2103 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.getSupportedCollaterals.selector</span>
 2104 |     | <span class='neutral'>            )</span>
 2105 |     | <span class='neutral'>        );</span>
 2106 | *   | <span class='executed'>        assert(success);</span>
 2107 | *   | <span class='executed'>        uint256[] memory supportedCollaterals = abi.decode(data, (uint256[]));</span>
 2108 |     | <span class='neutral'>        // assert(supportedCollaterals.length == 3);</span>
 2109 |     | <span class='neutral'></span>
 2110 | *   | <span class='executed'>        uint256 clampedIndex = collateralTokenIndex %</span>
 2111 | *   | <span class='executed'>            supportedCollaterals.length;</span>
 2112 | *   | <span class='executed'>        address collateral;</span>
 2113 | *   | <span class='executed'>        if (clampedIndex == 0) collateral = address(sUSDTokenMock);</span>
 2114 | *   | <span class='executed'>        else if (clampedIndex == 1) collateral = address(wethTokenMock);</span>
 2115 | *   | <span class='executed'>        else collateral = address(wbtcTokenMock);</span>
 2116 | *   | <span class='executed'>        return collateral;</span>
 2117 |     | <span class='neutral'>        // TODO: Cleanup.</span>
 2118 |     | <span class='neutral'>        // return supportedCollaterals[clampedIndex]; //== 1 ? address(wethTokenMock) : address(wbtcTokenMock);</span>
 2119 |     | <span class='neutral'>    }</span>
 2120 |     | <span class='neutral'></span>
 2121 | *   | <span class='executed'>    function _getRandomNodeId(</span>
 2122 |     | <span class='neutral'>        uint256 nodeIndex</span>
 2123 | *   | <span class='executed'>    ) internal returns (bytes32 nodeId) {</span>
 2124 |     | <span class='neutral'>        // first oracle nodeId is sUSD, ignore because its price shouldn&#39;t change</span>
 2125 | *   | <span class='executed'>        nodeIndex = (nodeIndex % mockOracleManager.getActiveNodesLength()) + 1;</span>
 2126 | *r  | <span class='executed'>        nodeId = mockOracleManager.activeNodes(nodeIndex);</span>
 2127 |     | <span class='neutral'>    }</span>
 2128 |     | <span class='neutral'></span>
 2129 |     | <span class='unexecuted'>    function _depositInitialAmounts(</span>
 2130 |     | <span class='neutral'>        uint128 accountId,</span>
 2131 |     | <span class='neutral'>        uint128 collateralId,</span>
 2132 |     | <span class='neutral'>        int delta</span>
 2133 |     | <span class='unexecuted'>    ) internal {</span>
 2134 |     | <span class='unexecuted'>        address user;</span>
 2135 |     | <span class='unexecuted'>        if (accountId == 1) {</span>
 2136 |     | <span class='neutral'>            user = USER1;</span>
 2137 |     | <span class='unexecuted'>        } else if (accountId == 2) {</span>
 2138 |     | <span class='neutral'>            user = USER2;</span>
 2139 |     | <span class='neutral'>        } else {</span>
 2140 |     | <span class='neutral'>            user = USER3;</span>
 2141 |     | <span class='neutral'>        }</span>
 2142 |     | <span class='unexecuted'>        vm.prank(user);</span>
 2143 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = perps.call(</span>
 2144 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 2145 |     | <span class='neutral'>                perpsAccountModuleImpl.modifyCollateral.selector,</span>
 2146 |     | <span class='neutral'>                accountId,</span>
 2147 |     | <span class='neutral'>                collateralId,</span>
 2148 |     | <span class='neutral'>                delta</span>
 2149 |     | <span class='neutral'>            )</span>
 2150 |     | <span class='neutral'>        );</span>
 2151 |     | <span class='unexecuted'>        if (!success) {</span>
 2152 |     | <span class='unexecuted'>            if (returnData.length &gt; 0) {</span>
 2153 |     | <span class='unexecuted'>                string memory errorMessage = abi.decode(returnData, (string));</span>
 2154 |     | <span class='unexecuted'>                revert(errorMessage);</span>
 2155 |     | <span class='neutral'>            } else {</span>
 2156 |     | <span class='unexecuted'>                revert(&quot;Call to perps contract failed&quot;);</span>
 2157 |     | <span class='neutral'>            }</span>
 2158 |     | <span class='neutral'>        }</span>
 2159 |     | <span class='neutral'>    }</span>
 2160 |     | <span class='neutral'>}</span>
 2161 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/BeforeAfter.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import &quot;../FuzzSetup.sol&quot;;</span>
    5 |     | <span class='neutral'>import {AsyncOrder} from &quot;../../storage/AsyncOrder.sol&quot;;</span>
    6 |     | <span class='neutral'>import {MathUtil} from &quot;../../utils/MathUtil.sol&quot;;</span>
    7 |     | <span class='neutral'>import {LiquidationCoverage} from &quot;./logicalCoverage/LiquidationCoverage.sol&quot;;</span>
    8 |     | <span class='neutral'>import {OrderCoverage} from &quot;./logicalCoverage/OrderCoverage.sol&quot;;</span>
    9 |     | <span class='neutral'>import {PositionCoverage} from &quot;./logicalCoverage/PositionCoverage.sol&quot;;</span>
   10 |     | <span class='neutral'>import {MarketCoverage} from &quot;./logicalCoverage/MarketCoverage.sol&quot;;</span>
   11 |     | <span class='neutral'>import {GlobalCoverage} from &quot;./logicalCoverage/GlobalCoverage.sol&quot;;</span>
   12 |     | <span class='neutral'></span>
   13 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
   14 |     | <span class='neutral'></span>
   15 |     | <span class='neutral'>abstract contract BeforeAfter is</span>
   16 |     | <span class='neutral'>    FuzzSetup,</span>
   17 |     | <span class='neutral'>    LiquidationCoverage,</span>
   18 |     | <span class='neutral'>    OrderCoverage,</span>
   19 |     | <span class='neutral'>    PositionCoverage,</span>
   20 |     | <span class='neutral'>    MarketCoverage,</span>
   21 |     | <span class='neutral'>    GlobalCoverage</span>
   22 |     | <span class='neutral'>{</span>
   23 |     | <span class='neutral'>    mapping(uint8 =&gt; State) states;</span>
   24 |     | <span class='neutral'>    mapping(uint8 =&gt; State) positionStates;</span>
   25 |     | <span class='neutral'>    mapping(uint256 =&gt; mapping(address =&gt; uint256)) liquidationCallsInBlock;</span>
   26 |     | <span class='neutral'>    uint lcov_liquidateMarginOnlyCovered;</span>
   27 |     | <span class='neutral'></span>
   28 |     | <span class='neutral'>    struct PositionVars {</span>
   29 |     | <span class='neutral'>        int256 totalPnl;</span>
   30 |     | <span class='neutral'>        int256 accruedFunding;</span>
   31 |     | <span class='neutral'>        int128 positionSize;</span>
   32 |     | <span class='neutral'>        uint256 owedInterest;</span>
   33 |     | <span class='neutral'>        uint256 maxLiquidatableAmount;</span>
   34 |     | <span class='neutral'>    }</span>
   35 |     | <span class='neutral'></span>
   36 |     | <span class='neutral'>    struct MarketVars {</span>
   37 |     | <span class='neutral'>        int256 skew;</span>
   38 |     | <span class='neutral'>        uint256 marketSize;</span>
   39 |     | <span class='neutral'>        uint256 liquidationCapacity;</span>
   40 |     | <span class='neutral'>        uint128 marketSkew;</span>
   41 |     | <span class='neutral'>        uint256 reportedDebt;</span>
   42 |     | <span class='neutral'>        uint256 debtCorrectionAccumulator;</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    struct State {</span>
   46 |     | <span class='neutral'>        mapping(uint128 =&gt; ActorStates) actorStates;</span>
   47 |     | <span class='neutral'>        MarketVars wethMarket;</span>
   48 |     | <span class='neutral'>        MarketVars wbtcMarket;</span>
   49 |     | <span class='neutral'>        MarketVars hugeMarket;</span>
   50 |     | <span class='neutral'>        uint128[] globalCollateralTypes;</span>
   51 |     | <span class='neutral'>        uint256 depositedSusdCollateral;</span>
   52 |     | <span class='neutral'>        uint256 depositedWethCollateral;</span>
   53 |     | <span class='neutral'>        uint256 depositedWbtcCollateral;</span>
   54 |     | <span class='neutral'>        int256 collateralValueAllUsersSUSDCalculated;</span>
   55 |     | <span class='neutral'>        int256 collateralValueAllUsersWETHCalculated;</span>
   56 |     | <span class='neutral'>        int256 collateralValueAllUsersWBTCCalculated;</span>
   57 |     | <span class='neutral'>        uint depositedHUGECollateral;</span>
   58 |     | <span class='neutral'>        uint256 totalCollateralValueUsd;</span>
   59 |     | <span class='neutral'>        uint256 marketSizeGhost;</span>
   60 |     | <span class='neutral'>        uint256 delegatedCollateralValueUsd;</span>
   61 |     | <span class='neutral'>        uint128 currentUtilizationAccruedComputed;</span>
   62 |     | <span class='neutral'>        uint256 utilizationRate;</span>
   63 |     | <span class='neutral'>        uint256 delegatedCollateral;</span>
   64 |     | <span class='neutral'>        uint256 lockedCredit;</span>
   65 |     | <span class='neutral'>        uint256 reportedDebtGhost;</span>
   66 |     | <span class='neutral'>        uint256 totalCollateralValueUsdGhost;</span>
   67 |     | <span class='neutral'>        uint256 minimumCredit;</span>
   68 |     | <span class='neutral'>        int128 skew;</span>
   69 |     | <span class='neutral'>        int256 totalDebtCalculated;</span>
   70 |     | <span class='neutral'>        int256 totalDebt;</span>
   71 |     | <span class='neutral'>        bool calculateFillPricePassing;</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    struct ActorStates {</span>
   75 |     | <span class='neutral'>        bool isPositionLiquidatable;</span>
   76 |     | <span class='neutral'>        bool isPositionLiquidatablePassing;</span>
   77 |     | <span class='neutral'>        bool isMarginLiquidatable;</span>
   78 |     | <span class='neutral'>        uint128 debt;</span>
   79 |     | <span class='neutral'>        uint256[] collateralIds;</span>
   80 |     | <span class='neutral'>        uint256 balanceOfSUSD;</span>
   81 |     | <span class='neutral'>        uint256 balanceOfWETH;</span>
   82 |     | <span class='neutral'>        uint256 balanceOfWBTC;</span>
   83 |     | <span class='neutral'>        uint256 collateralAmountSUSD;</span>
   84 |     | <span class='neutral'>        uint256 collateralAmountWETH;</span>
   85 |     | <span class='neutral'>        uint256 collateralAmountWBTC;</span>
   86 |     | <span class='neutral'>        uint256 collateralAmountHUGE;</span>
   87 |     | <span class='neutral'>        uint256 totalCollateralValue;</span>
   88 |     | <span class='neutral'>        int128 sizeDelta;</span>
   89 |     | <span class='neutral'>        bool isOrderExpired;</span>
   90 |     | <span class='neutral'>        uint256 fillPriceWETH;</span>
   91 |     | <span class='neutral'>        uint256 fillPriceWBTC;</span>
   92 |     | <span class='neutral'>        uint256 sUSDBalance;</span>
   93 |     | <span class='neutral'>        int256 availableMargin;</span>
   94 |     | <span class='neutral'>        uint256 requiredInitialMargin;</span>
   95 |     | <span class='neutral'>        uint256 requiredMaintenanceMargin;</span>
   96 |     | <span class='neutral'>        uint256 maxLiquidationReward;</span>
   97 |     | <span class='neutral'>        uint256 depositedWethCollateral;</span>
   98 |     | <span class='neutral'>        uint256 depositedSusdCollateral;</span>
   99 |     | <span class='neutral'>        uint128[] activeCollateralTypes;</span>
  100 |     | <span class='neutral'>        uint128[] openPositionMarketIds;</span>
  101 |     | <span class='neutral'>        PositionVars wethMarket;</span>
  102 |     | <span class='neutral'>        PositionVars wbtcMarket;</span>
  103 |     | <span class='neutral'>        bool isAccountLiquidatable;</span>
  104 |     | <span class='neutral'>        bool isPreviousPositionInLoss;</span>
  105 |     | <span class='neutral'>        int256 latestPositionPnl;</span>
  106 |     | <span class='neutral'>        bool isPreviousTradePositionInLoss;</span>
  107 |     | <span class='neutral'>        int256 previousTradePositionPnl;</span>
  108 |     | <span class='neutral'>        int256 chargedAmount;</span>
  109 |     | <span class='neutral'>    }</span>
  110 |     | <span class='neutral'></span>
  111 |     | <span class='neutral'>    // Function-specific structs</span>
  112 |     | <span class='neutral'>    struct LiquidationVars {</span>
  113 |     | <span class='neutral'>        bool isPositionLiquidatable;</span>
  114 |     | <span class='neutral'>        bool isMarginLiquidatable;</span>
  115 |     | <span class='neutral'>        uint128 debt;</span>
  116 |     | <span class='neutral'>        uint256 maxLiquidatableAmount;</span>
  117 |     | <span class='neutral'>    }</span>
  118 |     | <span class='neutral'></span>
  119 |     | <span class='neutral'>    struct CollateralVars {</span>
  120 |     | <span class='neutral'>        uint256[] collateralIds;</span>
  121 |     | <span class='neutral'>        uint256 collateralAmount;</span>
  122 |     | <span class='neutral'>        uint256 totalCollateralValue;</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    struct OrderVars {</span>
  126 |     | <span class='neutral'>        int128 sizeDelta;</span>
  127 |     | <span class='neutral'>        bool isOrderExpired;</span>
  128 |     | <span class='neutral'>        uint256 fillPrice;</span>
  129 |     | <span class='neutral'>    }</span>
  130 |     | <span class='neutral'></span>
  131 |     | <span class='neutral'>    struct PositionInfoVars {</span>
  132 |     | <span class='neutral'>        int256 totalPnl;</span>
  133 |     | <span class='neutral'>        int256 accruedFunding;</span>
  134 |     | <span class='neutral'>        int128 positionSize;</span>
  135 |     | <span class='neutral'>        uint256 owedInterest;</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    struct MarketInfoVars {</span>
  139 |     | <span class='neutral'>        uint256 liquidationCapacity;</span>
  140 |     | <span class='neutral'>        uint256 marketSize;</span>
  141 |     | <span class='neutral'>        int256 skew;</span>
  142 |     | <span class='neutral'>    }</span>
  143 |     | <span class='neutral'></span>
  144 |     | <span class='neutral'>    struct UtilizationVars {</span>
  145 |     | <span class='neutral'>        uint256 utilizationRate;</span>
  146 |     | <span class='neutral'>        uint256 delegatedCollateral;</span>
  147 |     | <span class='neutral'>        uint256 lockedCredit;</span>
  148 |     | <span class='neutral'>    }</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>    struct MarginVars {</span>
  151 |     | <span class='neutral'>        int256 availableMargin;</span>
  152 |     | <span class='neutral'>        uint256 requiredInitialMargin;</span>
  153 |     | <span class='neutral'>        uint256 requiredMaintenanceMargin;</span>
  154 |     | <span class='neutral'>    }</span>
  155 |     | <span class='neutral'></span>
  156 |     | <span class='neutral'>    struct DebtVars {</span>
  157 |     | <span class='neutral'>        int256 totalDebt;</span>
  158 |     | <span class='neutral'>        uint256 reportedDebt;</span>
  159 |     | <span class='neutral'>        uint256 debtCorrectionAccumulator;</span>
  160 |     | <span class='neutral'>    }</span>
  161 |     | <span class='neutral'></span>
  162 |     | <span class='neutral'>    event DebugSize(int size, address a, string s);</span>
  163 |     | <span class='neutral'>    event DebugSize(int size, address a, uint128 account, string s);</span>
  164 |     | <span class='neutral'></span>
  165 | *   | <span class='executed'>    function _before(address[] memory actors) internal {</span>
  166 | *   | <span class='executed'>        _setStates(0, actors);</span>
  167 |     | <span class='neutral'></span>
  168 |     | <span class='neutral'>        if (DEBUG) debugBefore(actors);</span>
  169 |     | <span class='neutral'>    }</span>
  170 |     | <span class='neutral'></span>
  171 | *   | <span class='executed'>    function _after(address[] memory actors) internal {</span>
  172 | *   | <span class='executed'>        _setStates(1, actors);</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>        if (DEBUG) debugAfter(actors);</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 | *   | <span class='executed'>    function _beforeSettlement(uint128 accountId, uint128 marketId) internal {</span>
  178 | *   | <span class='executed'>        _setStates(0, accountId, marketId);</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 | *   | <span class='executed'>    function _afterSettlement(uint128 accountId, uint128 marketId) internal {</span>
  182 | *   | <span class='executed'>        _setStates(1, accountId, marketId);</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 | *   | <span class='executed'>    function zeroOutMemory() public {</span>
  186 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; 2; i++) {</span>
  187 | *   | <span class='executed'>            delete states[i];</span>
  188 | *   | <span class='executed'>            delete positionStates[i];</span>
  189 |     | <span class='neutral'>        }</span>
  190 |     | <span class='neutral'>    }</span>
  191 |     | <span class='neutral'></span>
  192 | *   | <span class='executed'>    function _checkLCov(bool lcov) internal {</span>
  193 | *   | <span class='executed'>        lcov</span>
  194 | *   | <span class='executed'>            ? lcov_liquidateMarginOnlyCovered += 1</span>
  195 |     | <span class='neutral'>            : lcov_liquidateMarginOnlyCovered;</span>
  196 |     | <span class='neutral'>    }</span>
  197 |     | <span class='neutral'></span>
  198 | *   | <span class='executed'>    function _setStates(uint8 callNum, address[] memory actors) internal {</span>
  199 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; ACCOUNTS.length; i++) {</span>
  200 | *   | <span class='executed'>            _setActorState(callNum, ACCOUNTS[i], accountIdToUser[ACCOUNTS[i]]);</span>
  201 |     | <span class='neutral'>        }</span>
  202 |     | <span class='neutral'>    }</span>
  203 |     | <span class='neutral'></span>
  204 | *   | <span class='executed'>    function _setStates(</span>
  205 |     | <span class='neutral'>        uint8 callNum,</span>
  206 |     | <span class='neutral'>        uint128 accountId,</span>
  207 |     | <span class='neutral'>        uint128 marketId</span>
  208 |     | <span class='neutral'>    ) internal {</span>
  209 | *   | <span class='executed'>        _setActorState(</span>
  210 | *   | <span class='executed'>            callNum,</span>
  211 | *   | <span class='executed'>            accountId,</span>
  212 | *   | <span class='executed'>            marketId,</span>
  213 | *   | <span class='executed'>            accountIdToUser[accountId]</span>
  214 |     | <span class='neutral'>        );</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 | *   | <span class='executed'>    function _setActorState(</span>
  218 |     | <span class='neutral'>        uint8 callNum,</span>
  219 |     | <span class='neutral'>        uint128 accountId,</span>
  220 |     | <span class='neutral'>        address actor</span>
  221 |     | <span class='neutral'>    ) internal {</span>
  222 | *   | <span class='executed'>        console2.log(&quot;===== BeforeAfter::_setActorState START ===== &quot;);</span>
  223 |     | <span class='neutral'></span>
  224 | *   | <span class='executed'>        resetGhostVariables(callNum);</span>
  225 | *   | <span class='executed'>        getGlobalCollateralValues(callNum);</span>
  226 | *   | <span class='executed'>        getLiquidationValues(callNum, accountId);</span>
  227 | *   | <span class='executed'>        getCollateralInfo(callNum, accountId);</span>
  228 | *   | <span class='executed'>        getOrderInfo(callNum, accountId);</span>
  229 | *   | <span class='executed'>        getPositionInfo(callNum, accountId);</span>
  230 | *   | <span class='executed'>        getMarketInfo(callNum);</span>
  231 | *   | <span class='executed'>        getUtilizationInfo(callNum);</span>
  232 | *   | <span class='executed'>        getMarginInfo(callNum, accountId);</span>
  233 | *   | <span class='executed'>        getDebtInfo(callNum, accountId);</span>
  234 | *   | <span class='executed'>        getGlobalDebt(callNum);</span>
  235 | *   | <span class='executed'>        getAndCalculateCollateralValues(callNum);</span>
  236 | *   | <span class='executed'>        checkIfAccountLiquidatable(callNum, accountId);</span>
  237 | *   | <span class='executed'>        getAccountBalances(callNum, accountId);</span>
  238 | *   | <span class='executed'>        getChargedAmount(callNum, accountId);</span>
  239 | *   | <span class='executed'>        console2.log(&quot;===== BeforeAfter::_setActorState END ===== &quot;);</span>
  240 |     | <span class='neutral'>    }</span>
  241 | *   | <span class='executed'>    function _setActorState(</span>
  242 |     | <span class='neutral'>        uint8 callNum,</span>
  243 |     | <span class='neutral'>        uint128 accountId,</span>
  244 |     | <span class='neutral'>        uint128 marketId,</span>
  245 |     | <span class='neutral'>        address actor</span>
  246 |     | <span class='neutral'>    ) internal {</span>
  247 | *   | <span class='executed'>        console2.log(&quot;===== BeforeAfter::_setActorState START ===== &quot;);</span>
  248 |     | <span class='neutral'></span>
  249 | *   | <span class='executed'>        _checkIfPositionWasProifitable(callNum, accountId, marketId);</span>
  250 |     | <span class='neutral'></span>
  251 | *   | <span class='executed'>        console2.log(&quot;===== BeforeAfter::_setActorState END ===== &quot;);</span>
  252 |     | <span class='neutral'>    }</span>
  253 | *   | <span class='executed'>    function getGlobalDebt(uint8 callNum) private {</span>
  254 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  255 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  256 |     | <span class='neutral'>                mockLensModuleImpl.getGlobalTotalAccountsDebt.selector</span>
  257 |     | <span class='neutral'>            )</span>
  258 |     | <span class='neutral'>        );</span>
  259 | *   | <span class='executed'>        assert(success);</span>
  260 | *   | <span class='executed'>        states[callNum].totalDebt = abi.decode(returnData, (int256));</span>
  261 |     | <span class='neutral'>    }</span>
  262 |     | <span class='neutral'></span>
  263 | *   | <span class='executed'>    function getChargedAmount(uint8 callNum, uint128 accountId) private {</span>
  264 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  265 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  266 |     | <span class='neutral'>                mockLensModuleImpl.getChargeAmount.selector,</span>
  267 |     | <span class='neutral'>                accountId</span>
  268 |     | <span class='neutral'>            )</span>
  269 |     | <span class='neutral'>        );</span>
  270 |     | <span class='neutral'>        // assert(success);</span>
  271 | *   | <span class='executed'>        states[callNum].actorStates[accountId].chargedAmount = abi.decode(</span>
  272 | *   | <span class='executed'>            returnData,</span>
  273 |     | <span class='neutral'>            (int256)</span>
  274 |     | <span class='neutral'>        );</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 | *   | <span class='executed'>    function _incrementAndCheckLiquidationCalls(</span>
  278 |     | <span class='neutral'>        address liquidator</span>
  279 | *   | <span class='executed'>    ) internal returns (bool isFirstCall) {</span>
  280 | *   | <span class='executed'>        isFirstCall = liquidationCallsInBlock[block.number][liquidator] == 0;</span>
  281 | *   | <span class='executed'>        liquidationCallsInBlock[block.number][liquidator]++;</span>
  282 | *   | <span class='executed'>        console2.log(</span>
  283 |     | <span class='neutral'>            &quot;_incrementAndCheckLiquidationCalls::incremened to &quot;,</span>
  284 | *   | <span class='executed'>            liquidationCallsInBlock[block.number][liquidator]</span>
  285 |     | <span class='neutral'>        );</span>
  286 |     | <span class='neutral'>        return isFirstCall;</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 | *   | <span class='executed'>    function checkIfAccountLiquidatable(</span>
  290 |     | <span class='neutral'>        uint8 callNum,</span>
  291 |     | <span class='neutral'>        uint128 accountId</span>
  292 |     | <span class='neutral'>    ) private {</span>
  293 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  294 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  295 |     | <span class='neutral'>                mockLensModuleImpl.isAccountLiquidatable.selector,</span>
  296 |     | <span class='neutral'>                accountId</span>
  297 |     | <span class='neutral'>            )</span>
  298 |     | <span class='neutral'>        );</span>
  299 | *   | <span class='executed'>        assert(success);</span>
  300 | *   | <span class='executed'>        states[callNum].actorStates[accountId].isAccountLiquidatable = abi</span>
  301 | *   | <span class='executed'>            .decode(returnData, (bool));</span>
  302 |     | <span class='neutral'>    }</span>
  303 | *   | <span class='executed'>    function resetGhostVariables(uint8 callNum) private {</span>
  304 | *   | <span class='executed'>        states[callNum].totalCollateralValueUsdGhost = 0;</span>
  305 | *   | <span class='executed'>        states[callNum].reportedDebtGhost = 0;</span>
  306 | *   | <span class='executed'>        states[callNum].marketSizeGhost = 0;</span>
  307 | *   | <span class='executed'>        states[callNum].totalDebtCalculated = 0;</span>
  308 |     | <span class='neutral'>    }</span>
  309 |     | <span class='neutral'></span>
  310 | *   | <span class='executed'>    function getGlobalCollateralValues(uint8 callNum) private {</span>
  311 | *   | <span class='executed'>        getGlobalCollateralValue(callNum, 0);</span>
  312 | *   | <span class='executed'>        getGlobalCollateralValue(callNum, 1);</span>
  313 | *   | <span class='executed'>        getGlobalCollateralValue(callNum, 2);</span>
  314 |     | <span class='neutral'></span>
  315 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  316 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  317 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.totalGlobalCollateralValue.selector</span>
  318 |     | <span class='neutral'>            )</span>
  319 |     | <span class='neutral'>        );</span>
  320 | *   | <span class='executed'>        assert(success);</span>
  321 | *   | <span class='executed'>        uint256 totalCollateralValue = abi.decode(returnData, (uint256));</span>
  322 | *   | <span class='executed'>        states[callNum].totalCollateralValueUsd = totalCollateralValue;</span>
  323 |     | <span class='neutral'></span>
  324 | *   | <span class='executed'>        _logGlobalCollateralValuesCoverage(</span>
  325 | *   | <span class='executed'>            states[callNum].depositedSusdCollateral,</span>
  326 | *   | <span class='executed'>            states[callNum].depositedWethCollateral,</span>
  327 | *   | <span class='executed'>            states[callNum].depositedWbtcCollateral,</span>
  328 |     | <span class='neutral'>            // states[callNum].depositedHUGECollateral,</span>
  329 |     | <span class='neutral'>            states[callNum].totalCollateralValueUsd,</span>
  330 | *   | <span class='executed'>            states[callNum].totalCollateralValueUsdGhost,</span>
  331 | *   | <span class='executed'>            states[callNum].skew</span>
  332 |     | <span class='neutral'>        );</span>
  333 |     | <span class='neutral'>    }</span>
  334 |     | <span class='neutral'></span>
  335 | *   | <span class='executed'>    function getGlobalCollateralValue(</span>
  336 |     | <span class='neutral'>        uint8 callNum,</span>
  337 |     | <span class='neutral'>        uint256 collateralId</span>
  338 | *   | <span class='executed'>    ) private {</span>
  339 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  340 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  341 |     | <span class='neutral'>                globalPerpsMarketModuleImpl.globalCollateralValue.selector,</span>
  342 |     | <span class='neutral'>                collateralId</span>
  343 |     | <span class='neutral'>            )</span>
  344 |     | <span class='neutral'>        );</span>
  345 | *   | <span class='executed'>        assert(success);</span>
  346 | *   | <span class='executed'>        uint256 collateralValue = abi.decode(returnData, (uint256));</span>
  347 | *   | <span class='executed'>        if (collateralId == 0) {</span>
  348 | *   | <span class='executed'>            states[callNum].depositedSusdCollateral = collateralValue;</span>
  349 | *   | <span class='executed'>        } else if (collateralId == 1) {</span>
  350 | *   | <span class='executed'>            states[callNum].depositedWethCollateral = collateralValue;</span>
  351 | *   | <span class='executed'>        } else if (collateralId == 2) {</span>
  352 | *   | <span class='executed'>            states[callNum].depositedWbtcCollateral = collateralValue;</span>
  353 |     | <span class='neutral'>        }</span>
  354 |     | <span class='neutral'>    }</span>
  355 |     | <span class='neutral'></span>
  356 | *   | <span class='executed'>    function getAccountBalances(uint8 callNum, uint128 accountId) private {</span>
  357 | *   | <span class='executed'>        states[callNum].actorStates[accountId].balanceOfWETH = wethTokenMock</span>
  358 | *   | <span class='executed'>            .balanceOf(accountIdToUser[accountId]);</span>
  359 | *   | <span class='executed'>        states[callNum].actorStates[accountId].balanceOfSUSD = sUSDTokenMock</span>
  360 | *   | <span class='executed'>            .balanceOf(accountIdToUser[accountId]);</span>
  361 | *   | <span class='executed'>        states[callNum].actorStates[accountId].balanceOfWBTC = wbtcTokenMock</span>
  362 | *   | <span class='executed'>            .balanceOf(accountIdToUser[accountId]);</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 | *   | <span class='executed'>    function getLiquidationValues(uint8 callNum, uint128 accountId) private {</span>
  366 |     | <span class='neutral'>        LiquidationVars memory vars;</span>
  367 |     | <span class='neutral'></span>
  368 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  369 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  370 |     | <span class='neutral'>                liquidationModuleImpl.canLiquidate.selector,</span>
  371 |     | <span class='neutral'>                accountId</span>
  372 |     | <span class='neutral'>            )</span>
  373 |     | <span class='neutral'>        );</span>
  374 | *   | <span class='executed'>        states[callNum]</span>
  375 |     | <span class='neutral'>            .actorStates[accountId]</span>
  376 |     | <span class='neutral'>            .isPositionLiquidatablePassing = success;</span>
  377 | *   | <span class='executed'>        vars.isPositionLiquidatable = abi.decode(returnData, (bool));</span>
  378 |     | <span class='neutral'></span>
  379 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  380 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  381 |     | <span class='neutral'>                liquidationModuleImpl.canLiquidateMarginOnly.selector,</span>
  382 |     | <span class='neutral'>                accountId</span>
  383 |     | <span class='neutral'>            )</span>
  384 |     | <span class='neutral'>        );</span>
  385 | *   | <span class='executed'>        assert(success);</span>
  386 | *   | <span class='executed'>        vars.isMarginLiquidatable = abi.decode(returnData, (bool));</span>
  387 |     | <span class='neutral'></span>
  388 | *   | <span class='executed'>        states[callNum].actorStates[accountId].isPositionLiquidatable = vars</span>
  389 |     | <span class='neutral'>            .isPositionLiquidatable;</span>
  390 | *   | <span class='executed'>        states[callNum].actorStates[accountId].isMarginLiquidatable = vars</span>
  391 |     | <span class='neutral'>            .isMarginLiquidatable;</span>
  392 |     | <span class='neutral'></span>
  393 | *   | <span class='executed'>        _logLiquidatableCoverage(</span>
  394 | *   | <span class='executed'>            vars.isPositionLiquidatable,</span>
  395 |     | <span class='neutral'>            vars.isMarginLiquidatable</span>
  396 |     | <span class='neutral'>        );</span>
  397 |     | <span class='neutral'></span>
  398 | *   | <span class='executed'>        _logLiquidateMarginOnlyCoverage(lcov_liquidateMarginOnlyCovered);</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 | *   | <span class='executed'>    function getCollateralInfo(uint8 callNum, uint128 accountId) private {</span>
  402 | *   | <span class='executed'>        CollateralVars memory vars;</span>
  403 |     | <span class='neutral'></span>
  404 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  405 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  406 |     | <span class='neutral'>                perpsAccountModuleImpl.getAccountCollateralIds.selector,</span>
  407 |     | <span class='neutral'>                accountId</span>
  408 |     | <span class='neutral'>            )</span>
  409 |     | <span class='neutral'>        );</span>
  410 | *   | <span class='executed'>        assert(success);</span>
  411 | *   | <span class='executed'>        vars.collateralIds = abi.decode(returnData, (uint256[]));</span>
  412 |     | <span class='neutral'></span>
  413 | *   | <span class='executed'>        states[callNum].actorStates[accountId].collateralIds = vars</span>
  414 |     | <span class='neutral'>            .collateralIds;</span>
  415 |     | <span class='neutral'></span>
  416 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 4; i++) {</span>
  417 | *   | <span class='executed'>            getCollateralAmount(callNum, accountId, i);</span>
  418 |     | <span class='neutral'>        }</span>
  419 |     | <span class='neutral'></span>
  420 | *   | <span class='executed'>        vars.totalCollateralValue = getTotalCollateralValue(accountId);</span>
  421 | *   | <span class='executed'>        states[callNum].actorStates[accountId].totalCollateralValue = vars</span>
  422 |     | <span class='neutral'>            .totalCollateralValue;</span>
  423 |     | <span class='neutral'></span>
  424 | *   | <span class='executed'>        _logCollateralIdsCoverage(vars.collateralIds);</span>
  425 | *   | <span class='executed'>        _logCollateralAmountsCoverage(</span>
  426 | *   | <span class='executed'>            states[callNum].actorStates[accountId].collateralAmountSUSD,</span>
  427 | *   | <span class='executed'>            states[callNum].actorStates[accountId].collateralAmountWETH,</span>
  428 | *   | <span class='executed'>            states[callNum].actorStates[accountId].collateralAmountWBTC,</span>
  429 | *   | <span class='executed'>            vars.totalCollateralValue</span>
  430 |     | <span class='neutral'>        );</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 | *   | <span class='executed'>    function getCollateralAmount(</span>
  434 |     | <span class='neutral'>        uint8 callNum,</span>
  435 |     | <span class='neutral'>        uint128 accountId,</span>
  436 |     | <span class='neutral'>        uint256 collateralId</span>
  437 | *   | <span class='executed'>    ) private {</span>
  438 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  439 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  440 |     | <span class='neutral'>                perpsAccountModuleImpl.getCollateralAmount.selector,</span>
  441 |     | <span class='neutral'>                accountId,</span>
  442 |     | <span class='neutral'>                collateralId</span>
  443 |     | <span class='neutral'>            )</span>
  444 |     | <span class='neutral'>        );</span>
  445 | *   | <span class='executed'>        assert(success);</span>
  446 | *   | <span class='executed'>        uint256 amount = abi.decode(returnData, (uint256));</span>
  447 |     | <span class='neutral'></span>
  448 | *   | <span class='executed'>        if (collateralId == 0) {</span>
  449 | *   | <span class='executed'>            states[callNum]</span>
  450 |     | <span class='neutral'>                .actorStates[accountId]</span>
  451 |     | <span class='neutral'>                .collateralAmountSUSD = amount;</span>
  452 | *   | <span class='executed'>        } else if (collateralId == 1) {</span>
  453 | *   | <span class='executed'>            states[callNum]</span>
  454 |     | <span class='neutral'>                .actorStates[accountId]</span>
  455 |     | <span class='neutral'>                .collateralAmountWETH = amount;</span>
  456 | *   | <span class='executed'>        } else if (collateralId == 2) {</span>
  457 | *   | <span class='executed'>            states[callNum]</span>
  458 |     | <span class='neutral'>                .actorStates[accountId]</span>
  459 |     | <span class='neutral'>                .collateralAmountWBTC = amount;</span>
  460 | *   | <span class='executed'>        } else if (collateralId == 3) {</span>
  461 | *   | <span class='executed'>            states[callNum]</span>
  462 |     | <span class='neutral'>                .actorStates[accountId]</span>
  463 |     | <span class='neutral'>                .collateralAmountHUGE = amount;</span>
  464 |     | <span class='neutral'>        }</span>
  465 |     | <span class='neutral'>    }</span>
  466 |     | <span class='neutral'></span>
  467 | *   | <span class='executed'>    function getTotalCollateralValue(</span>
  468 |     | <span class='neutral'>        uint128 accountId</span>
  469 | *   | <span class='executed'>    ) internal returns (uint256 totalCollateralValue) {</span>
  470 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  471 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  472 |     | <span class='neutral'>                perpsAccountModuleImpl.totalCollateralValue.selector,</span>
  473 |     | <span class='neutral'>                accountId</span>
  474 |     | <span class='neutral'>            )</span>
  475 |     | <span class='neutral'>        );</span>
  476 | *   | <span class='executed'>        assert(success);</span>
  477 | *   | <span class='executed'>        totalCollateralValue = abi.decode(returnData, (uint256));</span>
  478 |     | <span class='neutral'>    }</span>
  479 |     | <span class='neutral'></span>
  480 | *   | <span class='executed'>    function getOrderInfo(uint8 callNum, uint128 accountId) private {</span>
  481 |     | <span class='neutral'>        OrderVars memory vars;</span>
  482 |     | <span class='neutral'></span>
  483 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  484 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  485 |     | <span class='neutral'>                perpsAccountModuleImpl.debt.selector,</span>
  486 |     | <span class='neutral'>                accountId</span>
  487 |     | <span class='neutral'>            )</span>
  488 |     | <span class='neutral'>        );</span>
  489 | *   | <span class='executed'>        assert(success);</span>
  490 | *   | <span class='executed'>        states[callNum].actorStates[accountId].debt = abi.decode(</span>
  491 | *   | <span class='executed'>            returnData,</span>
  492 |     | <span class='neutral'>            (uint128)</span>
  493 |     | <span class='neutral'>        );</span>
  494 |     | <span class='neutral'></span>
  495 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  496 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  497 |     | <span class='neutral'>                asyncOrderModuleImpl.getOrder.selector,</span>
  498 |     | <span class='neutral'>                accountId</span>
  499 |     | <span class='neutral'>            )</span>
  500 |     | <span class='neutral'>        );</span>
  501 | *   | <span class='executed'>        assert(success);</span>
  502 | *   | <span class='executed'>        AsyncOrder.Data memory order = abi.decode(</span>
  503 | *   | <span class='executed'>            returnData,</span>
  504 |     | <span class='neutral'>            (AsyncOrder.Data)</span>
  505 |     | <span class='neutral'>        );</span>
  506 | *   | <span class='executed'>        vars.sizeDelta = order.request.sizeDelta;</span>
  507 |     | <span class='neutral'></span>
  508 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  509 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  510 |     | <span class='neutral'>                mockLensModuleImpl.isOrderExpired.selector,</span>
  511 |     | <span class='neutral'>                accountId</span>
  512 |     | <span class='neutral'>            )</span>
  513 |     | <span class='neutral'>        );</span>
  514 | *   | <span class='executed'>        assert(success);</span>
  515 | *   | <span class='executed'>        vars.isOrderExpired = abi.decode(returnData, (bool));</span>
  516 |     | <span class='neutral'></span>
  517 | *   | <span class='executed'>        states[callNum].actorStates[accountId].sizeDelta = vars.sizeDelta;</span>
  518 | *   | <span class='executed'>        states[callNum].actorStates[accountId].isOrderExpired = vars</span>
  519 |     | <span class='neutral'>            .isOrderExpired;</span>
  520 |     | <span class='neutral'></span>
  521 | *   | <span class='executed'>        getOrderFees(callNum, accountId, 1, WETH_PYTH_PRICE_FEED_ID);</span>
  522 | *   | <span class='executed'>        getOrderFees(callNum, accountId, 2, WBTC_PYTH_PRICE_FEED_ID);</span>
  523 |     | <span class='neutral'></span>
  524 | *   | <span class='executed'>        states[callNum].actorStates[accountId].sUSDBalance = sUSDTokenMock</span>
  525 | *   | <span class='executed'>            .balanceOf(accountIdToUser[accountId]);</span>
  526 |     | <span class='neutral'></span>
  527 | *   | <span class='executed'>        _logOrderInfoCoverage(</span>
  528 | *   | <span class='executed'>            states[callNum].actorStates[accountId].debt,</span>
  529 | *   | <span class='executed'>            vars.sizeDelta,</span>
  530 | *   | <span class='executed'>            vars.isOrderExpired,</span>
  531 | *   | <span class='executed'>            states[callNum].actorStates[accountId].fillPriceWETH,</span>
  532 | *   | <span class='executed'>            states[callNum].actorStates[accountId].fillPriceWBTC,</span>
  533 |     | <span class='neutral'>            states[callNum].actorStates[accountId].sUSDBalance</span>
  534 |     | <span class='neutral'>        );</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 | *   | <span class='executed'>    function getOrderFees(</span>
  538 |     | <span class='neutral'>        uint8 callNum,</span>
  539 |     | <span class='neutral'>        uint128 accountId,</span>
  540 |     | <span class='neutral'>        uint256 marketId,</span>
  541 |     | <span class='neutral'>        bytes32 priceFeedId</span>
  542 | *   | <span class='executed'>    ) private {</span>
  543 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  544 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  545 | *   | <span class='executed'>                asyncOrderModuleImpl.computeOrderFeesWithPrice.selector,</span>
  546 | *   | <span class='executed'>                marketId,</span>
  547 | *   | <span class='executed'>                states[callNum].actorStates[accountId].sizeDelta,</span>
  548 | *   | <span class='executed'>                pythWrapper.getBenchmarkPrice(priceFeedId, 0)</span>
  549 |     | <span class='neutral'>            )</span>
  550 |     | <span class='neutral'>        );</span>
  551 | *   | <span class='executed'>        if (!success) {</span>
  552 |     | <span class='unexecuted'>            fl.log(</span>
  553 |     | <span class='neutral'>                &quot;computeOrderFeesWithPrice reverts&quot;,</span>
  554 |     | <span class='unexecuted'>                abi.decode(returnData, (string))</span>
  555 |     | <span class='neutral'>            );</span>
  556 |     | <span class='unexecuted'>            fl.t(</span>
  557 |     | <span class='neutral'>                success,</span>
  558 |     | <span class='neutral'>                &quot;ORD-23: AsyncOrder.calculateFillPrice() should never revert&quot;</span>
  559 |     | <span class='neutral'>            );</span>
  560 |     | <span class='neutral'>        }</span>
  561 | *   | <span class='executed'>        states[callNum].calculateFillPricePassing = success;</span>
  562 | *   | <span class='executed'>        (uint256 orderFees, uint256 fillPrice) = abi.decode(</span>
  563 |     | <span class='neutral'>            returnData,</span>
  564 |     | <span class='neutral'>            (uint256, uint256)</span>
  565 |     | <span class='neutral'>        );</span>
  566 |     | <span class='neutral'></span>
  567 | *   | <span class='executed'>        if (marketId == 1) {</span>
  568 | *   | <span class='executed'>            states[callNum].actorStates[accountId].fillPriceWETH = fillPrice;</span>
  569 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
  570 | *   | <span class='executed'>            states[callNum].actorStates[accountId].fillPriceWBTC = fillPrice;</span>
  571 |     | <span class='neutral'>        }</span>
  572 |     | <span class='neutral'>    }</span>
  573 |     | <span class='neutral'></span>
  574 | *   | <span class='executed'>    function getPositionInfo(uint8 callNum, uint128 accountId) private {</span>
  575 | *   | <span class='executed'>        PositionInfoVars memory vars;</span>
  576 |     | <span class='neutral'></span>
  577 | *   | <span class='executed'>        getOpenPosition(callNum, accountId, 1);</span>
  578 | *   | <span class='executed'>        getOpenPosition(callNum, accountId, 2);</span>
  579 |     | <span class='neutral'></span>
  580 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  581 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  582 |     | <span class='neutral'>                mockLensModuleImpl.getOpenPositionMarketIds.selector,</span>
  583 |     | <span class='neutral'>                accountId</span>
  584 |     | <span class='neutral'>            )</span>
  585 |     | <span class='neutral'>        );</span>
  586 | *   | <span class='executed'>        assert(success);</span>
  587 | *   | <span class='executed'>        states[callNum].actorStates[accountId].openPositionMarketIds = abi</span>
  588 | *   | <span class='executed'>            .decode(returnData, (uint128[]));</span>
  589 |     | <span class='neutral'></span>
  590 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  591 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  592 |     | <span class='neutral'>                mockLensModuleImpl.getCollateralTypes.selector,</span>
  593 |     | <span class='neutral'>                accountId</span>
  594 |     | <span class='neutral'>            )</span>
  595 |     | <span class='neutral'>        );</span>
  596 | *   | <span class='executed'>        assert(success);</span>
  597 | *   | <span class='executed'>        states[callNum].actorStates[accountId].activeCollateralTypes = abi</span>
  598 | *   | <span class='executed'>            .decode(returnData, (uint128[]));</span>
  599 |     | <span class='neutral'></span>
  600 | *   | <span class='executed'>        fl.log(</span>
  601 |     | <span class='neutral'>            &quot;User activeCollateralTypes&quot;,</span>
  602 | *   | <span class='executed'>            states[callNum].actorStates[accountId].activeCollateralTypes.length</span>
  603 |     | <span class='neutral'>        );</span>
  604 |     | <span class='neutral'></span>
  605 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  606 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  607 |     | <span class='neutral'>                mockLensModuleImpl.getGlobalCollateralTypes.selector</span>
  608 |     | <span class='neutral'>            )</span>
  609 |     | <span class='neutral'>        );</span>
  610 | *   | <span class='executed'>        assert(success);</span>
  611 | *   | <span class='executed'>        states[callNum].globalCollateralTypes = abi.decode(</span>
  612 | *   | <span class='executed'>            returnData,</span>
  613 |     | <span class='neutral'>            (uint128[])</span>
  614 |     | <span class='neutral'>        );</span>
  615 | *   | <span class='executed'>        fl.log(</span>
  616 |     | <span class='neutral'>            &quot;Global activeCollateralTypes&quot;,</span>
  617 | *   | <span class='executed'>            states[callNum].globalCollateralTypes.length</span>
  618 |     | <span class='neutral'>        );</span>
  619 | *   | <span class='executed'>        if (</span>
  620 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wethMarket.positionSize != 0</span>
  621 |     | <span class='neutral'>        ) {</span>
  622 | *   | <span class='executed'>            states[callNum]</span>
  623 |     | <span class='neutral'>                .actorStates[accountId]</span>
  624 |     | <span class='neutral'>                .wethMarket</span>
  625 | *   | <span class='executed'>                .maxLiquidatableAmount = getMaxLiquidatableAmount(</span>
  626 | *   | <span class='executed'>                1,</span>
  627 | *   | <span class='executed'>                states[callNum].actorStates[accountId].wethMarket.positionSize</span>
  628 |     | <span class='neutral'>            );</span>
  629 |     | <span class='neutral'>        }</span>
  630 | *   | <span class='executed'>        if (</span>
  631 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wbtcMarket.positionSize != 0</span>
  632 |     | <span class='neutral'>        ) {</span>
  633 | *   | <span class='executed'>            states[callNum]</span>
  634 |     | <span class='neutral'>                .actorStates[accountId]</span>
  635 |     | <span class='neutral'>                .wbtcMarket</span>
  636 | *   | <span class='executed'>                .maxLiquidatableAmount = getMaxLiquidatableAmount(</span>
  637 | *   | <span class='executed'>                2,</span>
  638 | *   | <span class='executed'>                states[callNum].actorStates[accountId].wbtcMarket.positionSize</span>
  639 |     | <span class='neutral'>            );</span>
  640 |     | <span class='neutral'>        }</span>
  641 |     | <span class='neutral'></span>
  642 | *   | <span class='executed'>        _logPositionInfoCoverage(</span>
  643 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wethMarket.totalPnl,</span>
  644 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wethMarket.accruedFunding,</span>
  645 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wethMarket.positionSize,</span>
  646 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wethMarket.owedInterest,</span>
  647 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wbtcMarket.totalPnl,</span>
  648 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wbtcMarket.accruedFunding,</span>
  649 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wbtcMarket.positionSize,</span>
  650 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wbtcMarket.owedInterest</span>
  651 |     | <span class='neutral'>        );</span>
  652 |     | <span class='neutral'>    }</span>
  653 |     | <span class='neutral'></span>
  654 | *   | <span class='executed'>    function getOpenPosition(</span>
  655 |     | <span class='neutral'>        uint8 callNum,</span>
  656 |     | <span class='neutral'>        uint128 accountId,</span>
  657 |     | <span class='neutral'>        uint128 marketId</span>
  658 |     | <span class='neutral'>    ) private {</span>
  659 | *   | <span class='executed'>        PositionInfoVars memory vars;</span>
  660 |     | <span class='neutral'></span>
  661 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  662 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  663 |     | <span class='neutral'>                perpsAccountModuleImpl.getOpenPosition.selector,</span>
  664 |     | <span class='neutral'>                accountId,</span>
  665 |     | <span class='neutral'>                marketId</span>
  666 |     | <span class='neutral'>            )</span>
  667 |     | <span class='neutral'>        );</span>
  668 | *   | <span class='executed'>        assert(success);</span>
  669 | *   | <span class='executed'>        (</span>
  670 |     | <span class='neutral'>            vars.totalPnl,</span>
  671 | *   | <span class='executed'>            vars.accruedFunding,</span>
  672 | *   | <span class='executed'>            vars.positionSize,</span>
  673 | *   | <span class='executed'>            vars.owedInterest</span>
  674 | *   | <span class='executed'>        ) = abi.decode(returnData, (int256, int256, int128, uint256));</span>
  675 |     | <span class='neutral'></span>
  676 | *   | <span class='executed'>        if (marketId == 1) {</span>
  677 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wethMarket.totalPnl = vars</span>
  678 |     | <span class='neutral'>                .totalPnl;</span>
  679 | *   | <span class='executed'>            states[callNum]</span>
  680 |     | <span class='neutral'>                .actorStates[accountId]</span>
  681 |     | <span class='neutral'>                .wethMarket</span>
  682 | *   | <span class='executed'>                .accruedFunding = vars.accruedFunding;</span>
  683 | *   | <span class='executed'>            states[callNum]</span>
  684 |     | <span class='neutral'>                .actorStates[accountId]</span>
  685 |     | <span class='neutral'>                .wethMarket</span>
  686 | *   | <span class='executed'>                .positionSize = vars.positionSize;</span>
  687 | *   | <span class='executed'>            states[callNum]</span>
  688 |     | <span class='neutral'>                .actorStates[accountId]</span>
  689 |     | <span class='neutral'>                .wethMarket</span>
  690 | *   | <span class='executed'>                .owedInterest = vars.owedInterest;</span>
  691 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
  692 | *   | <span class='executed'>            states[callNum].actorStates[accountId].wbtcMarket.totalPnl = vars</span>
  693 |     | <span class='neutral'>                .totalPnl;</span>
  694 | *   | <span class='executed'>            states[callNum]</span>
  695 |     | <span class='neutral'>                .actorStates[accountId]</span>
  696 |     | <span class='neutral'>                .wbtcMarket</span>
  697 | *   | <span class='executed'>                .accruedFunding = vars.accruedFunding;</span>
  698 | *   | <span class='executed'>            states[callNum]</span>
  699 |     | <span class='neutral'>                .actorStates[accountId]</span>
  700 |     | <span class='neutral'>                .wbtcMarket</span>
  701 | *   | <span class='executed'>                .positionSize = vars.positionSize;</span>
  702 | *   | <span class='executed'>            states[callNum]</span>
  703 |     | <span class='neutral'>                .actorStates[accountId]</span>
  704 |     | <span class='neutral'>                .wbtcMarket</span>
  705 | *   | <span class='executed'>                .owedInterest = vars.owedInterest;</span>
  706 |     | <span class='neutral'>        }</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 | *   | <span class='executed'>    function getMaxLiquidatableAmount(</span>
  710 |     | <span class='neutral'>        uint128 marketId,</span>
  711 |     | <span class='neutral'>        int128 positionSize</span>
  712 | *   | <span class='executed'>    ) private returns (uint128) {</span>
  713 | *   | <span class='executed'>        if (positionSize &lt; 0) {</span>
  714 | *   | <span class='executed'>            positionSize = positionSize * -1;</span>
  715 |     | <span class='neutral'>        }</span>
  716 |     | <span class='neutral'>        uint128 absPositionSize = uint128(positionSize);</span>
  717 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  718 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  719 |     | <span class='neutral'>                mockLensModuleImpl.getMaxLiquidatableAmount.selector,</span>
  720 |     | <span class='neutral'>                marketId,</span>
  721 |     | <span class='neutral'>                positionSize</span>
  722 |     | <span class='neutral'>            )</span>
  723 |     | <span class='neutral'>        );</span>
  724 | *   | <span class='executed'>        assert(success);</span>
  725 | *   | <span class='executed'>        return abi.decode(returnData, (uint128));</span>
  726 |     | <span class='neutral'>    }</span>
  727 |     | <span class='neutral'></span>
  728 | *   | <span class='executed'>    function getMarketInfo(uint8 callNum) private {</span>
  729 | *   | <span class='executed'>        MarketInfoVars memory vars;</span>
  730 |     | <span class='neutral'></span>
  731 | *   | <span class='executed'>        getLiquidationCapacity(callNum, 1);</span>
  732 | *   | <span class='executed'>        getLiquidationCapacity(callNum, 2);</span>
  733 | *   | <span class='executed'>        getLiquidationCapacity(callNum, 3);</span>
  734 |     | <span class='neutral'></span>
  735 | *   | <span class='executed'>        getMarketSize(callNum, 1);</span>
  736 | *   | <span class='executed'>        getMarketSize(callNum, 2);</span>
  737 | *   | <span class='executed'>        getMarketSize(callNum, 3);</span>
  738 |     | <span class='neutral'></span>
  739 | *   | <span class='executed'>        getMarketSkew(callNum, 1);</span>
  740 | *   | <span class='executed'>        getMarketSkew(callNum, 2);</span>
  741 | *   | <span class='executed'>        getMarketSkew(callNum, 3);</span>
  742 |     | <span class='neutral'></span>
  743 | *   | <span class='executed'>        _logMarketInfoCoverage(</span>
  744 | *   | <span class='executed'>            states[callNum].wethMarket.liquidationCapacity,</span>
  745 | *   | <span class='executed'>            states[callNum].wbtcMarket.liquidationCapacity,</span>
  746 | *   | <span class='executed'>            states[callNum].wethMarket.marketSize,</span>
  747 | *   | <span class='executed'>            states[callNum].wbtcMarket.marketSize</span>
  748 |     | <span class='neutral'>        );</span>
  749 |     | <span class='neutral'>    }</span>
  750 |     | <span class='neutral'></span>
  751 | *   | <span class='executed'>    function getLiquidationCapacity(uint8 callNum, uint256 marketId) private {</span>
  752 | *   | <span class='executed'>        MarketInfoVars memory vars;</span>
  753 |     | <span class='neutral'></span>
  754 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  755 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  756 |     | <span class='neutral'>                liquidationModuleImpl.liquidationCapacity.selector,</span>
  757 |     | <span class='neutral'>                marketId</span>
  758 |     | <span class='neutral'>            )</span>
  759 |     | <span class='neutral'>        );</span>
  760 | *   | <span class='executed'>        assert(success);</span>
  761 | *   | <span class='executed'>        (vars.liquidationCapacity, , ) = abi.decode(</span>
  762 | *   | <span class='executed'>            returnData,</span>
  763 |     | <span class='neutral'>            (uint256, uint256, uint256)</span>
  764 |     | <span class='neutral'>        );</span>
  765 | *   | <span class='executed'>        if (marketId == 1) {</span>
  766 | *   | <span class='executed'>            states[callNum].wethMarket.liquidationCapacity = vars</span>
  767 |     | <span class='neutral'>                .liquidationCapacity;</span>
  768 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
  769 | *   | <span class='executed'>            states[callNum].wbtcMarket.liquidationCapacity = vars</span>
  770 |     | <span class='neutral'>                .liquidationCapacity;</span>
  771 |     | <span class='neutral'>        }</span>
  772 |     | <span class='neutral'>    }</span>
  773 |     | <span class='neutral'></span>
  774 | *   | <span class='executed'>    function getMarketSize(uint8 callNum, uint256 marketId) private {</span>
  775 | *   | <span class='executed'>        MarketInfoVars memory vars;</span>
  776 |     | <span class='neutral'></span>
  777 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  778 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  779 |     | <span class='neutral'>                perpsMarketModuleImpl.size.selector,</span>
  780 |     | <span class='neutral'>                marketId</span>
  781 |     | <span class='neutral'>            )</span>
  782 |     | <span class='neutral'>        );</span>
  783 | *   | <span class='executed'>        assert(success);</span>
  784 | *   | <span class='executed'>        vars.marketSize = abi.decode(returnData, (uint256));</span>
  785 | *   | <span class='executed'>        if (marketId == 1) {</span>
  786 | *   | <span class='executed'>            states[callNum].wethMarket.marketSize = vars.marketSize;</span>
  787 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
  788 | *   | <span class='executed'>            states[callNum].wbtcMarket.marketSize = vars.marketSize;</span>
  789 |     | <span class='neutral'>        }</span>
  790 |     | <span class='neutral'>    }</span>
  791 |     | <span class='neutral'></span>
  792 | *   | <span class='executed'>    function getMarketSkew(uint8 callNum, uint256 marketId) private {</span>
  793 | *   | <span class='executed'>        MarketInfoVars memory vars;</span>
  794 |     | <span class='neutral'></span>
  795 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  796 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  797 |     | <span class='neutral'>                perpsMarketModuleImpl.skew.selector,</span>
  798 |     | <span class='neutral'>                marketId</span>
  799 |     | <span class='neutral'>            )</span>
  800 |     | <span class='neutral'>        );</span>
  801 | *   | <span class='executed'>        assert(success);</span>
  802 | *   | <span class='executed'>        vars.skew = abi.decode(returnData, (int256));</span>
  803 | *   | <span class='executed'>        if (marketId == 1) {</span>
  804 | *   | <span class='executed'>            states[callNum].wethMarket.skew = vars.skew;</span>
  805 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
  806 | *   | <span class='executed'>            states[callNum].wbtcMarket.skew = vars.skew;</span>
  807 | *   | <span class='executed'>        } else if (marketId == 3) {</span>
  808 | *   | <span class='executed'>            states[callNum].hugeMarket.skew = vars.skew;</span>
  809 |     | <span class='neutral'>        }</span>
  810 |     | <span class='neutral'>    }</span>
  811 |     | <span class='neutral'>    // struct CollateralData {</span>
  812 |     | <span class='neutral'>    //     uint256 susdValue;</span>
  813 |     | <span class='neutral'>    //     uint256 wethValue;</span>
  814 |     | <span class='neutral'>    //     uint256 wbtcValue;</span>
  815 |     | <span class='neutral'>    //     uint256 totalValue;</span>
  816 |     | <span class='neutral'>    // }</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='neutral'>    // function getAndCalculateCollateralValues(uint8 callNum) private {</span>
  819 |     | <span class='neutral'>    //     CollateralData memory globalData;</span>
  820 |     | <span class='neutral'>    //     CollateralData memory userTotalData;</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    //     // Get global collateral values from the perps contract</span>
  823 |     | <span class='neutral'>    //     (bool success, bytes memory returnData) = perps.call(</span>
  824 |     | <span class='neutral'>    //         abi.encodeWithSelector(</span>
  825 |     | <span class='neutral'>    //             globalPerpsMarketModuleImpl.globalCollateralValue.selector,</span>
  826 |     | <span class='neutral'>    //             0</span>
  827 |     | <span class='neutral'>    //         )</span>
  828 |     | <span class='neutral'>    //     );</span>
  829 |     | <span class='neutral'>    //     assert(success);</span>
  830 |     | <span class='neutral'>    //     globalData.susdValue = abi.decode(returnData, (uint256));</span>
  831 |     | <span class='neutral'></span>
  832 |     | <span class='neutral'>    //     (success, returnData) = perps.call(</span>
  833 |     | <span class='neutral'>    //         abi.encodeWithSelector(</span>
  834 |     | <span class='neutral'>    //             globalPerpsMarketModuleImpl.globalCollateralValue.selector,</span>
  835 |     | <span class='neutral'>    //             1</span>
  836 |     | <span class='neutral'>    //         )</span>
  837 |     | <span class='neutral'>    //     );</span>
  838 |     | <span class='neutral'>    //     assert(success);</span>
  839 |     | <span class='neutral'>    //     globalData.wethValue = abi.decode(returnData, (uint256));</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    //     (success, returnData) = perps.call(</span>
  842 |     | <span class='neutral'>    //         abi.encodeWithSelector(</span>
  843 |     | <span class='neutral'>    //             globalPerpsMarketModuleImpl.globalCollateralValue.selector,</span>
  844 |     | <span class='neutral'>    //             2</span>
  845 |     | <span class='neutral'>    //         )</span>
  846 |     | <span class='neutral'>    //     );</span>
  847 |     | <span class='neutral'>    //     assert(success);</span>
  848 |     | <span class='neutral'>    //     globalData.wbtcValue = abi.decode(returnData, (uint256));</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    //     (success, returnData) = perps.call(</span>
  851 |     | <span class='neutral'>    //         abi.encodeWithSelector(</span>
  852 |     | <span class='neutral'>    //             globalPerpsMarketModuleImpl.totalGlobalCollateralValue.selector</span>
  853 |     | <span class='neutral'>    //         )</span>
  854 |     | <span class='neutral'>    //     );</span>
  855 |     | <span class='neutral'>    //     assert(success);</span>
  856 |     | <span class='neutral'>    //     globalData.totalValue = abi.decode(returnData, (uint256));</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    //     // Calculate user totals</span>
  859 |     | <span class='neutral'>    //     int256 wethPrice = mockOracleManager.process(WETH_ORACLE_NODE_ID).price;</span>
  860 |     | <span class='neutral'>    //     int256 wbtcPrice = mockOracleManager.process(WBTC_ORACLE_NODE_ID).price;</span>
  861 |     | <span class='neutral'></span>
  862 |     | <span class='neutral'>    //     for (uint256 i = 0; i &lt; USERS.length; i++) {</span>
  863 |     | <span class='neutral'>    //         uint128 accountId = userToAccountIds[USERS[i]];</span>
  864 |     | <span class='neutral'>    //         userTotalData.susdValue += states[callNum]</span>
  865 |     | <span class='neutral'>    //             .actorStates[accountId]</span>
  866 |     | <span class='neutral'>    //             .collateralAmountSUSD;</span>
  867 |     | <span class='neutral'>    //         userTotalData.wethValue += states[callNum]</span>
  868 |     | <span class='neutral'>    //             .actorStates[accountId]</span>
  869 |     | <span class='neutral'>    //             .collateralAmountWETH;</span>
  870 |     | <span class='neutral'>    //         userTotalData.wbtcValue += states[callNum]</span>
  871 |     | <span class='neutral'>    //             .actorStates[accountId]</span>
  872 |     | <span class='neutral'>    //             .collateralAmountWBTC;</span>
  873 |     | <span class='neutral'>    //     }</span>
  874 |     | <span class='neutral'></span>
  875 |     | <span class='neutral'>    //     userTotalData.totalValue =</span>
  876 |     | <span class='neutral'>    //         userTotalData.susdValue +</span>
  877 |     | <span class='neutral'>    //         ((uint256(wethPrice) * userTotalData.wethValue) / 1e18) +</span>
  878 |     | <span class='neutral'>    //         ((uint256(wbtcPrice) * userTotalData.wbtcValue) / 1e18);</span>
  879 |     | <span class='neutral'></span>
  880 |     | <span class='neutral'>    //     // Store results</span>
  881 |     | <span class='neutral'>    //     states[callNum].depositedSusdCollateral = globalData.susdValue;</span>
  882 |     | <span class='neutral'>    //     states[callNum].depositedWethCollateral = globalData.wethValue;</span>
  883 |     | <span class='neutral'>    //     states[callNum].depositedWbtcCollateral = globalData.wbtcValue;</span>
  884 |     | <span class='neutral'>    //     states[callNum].totalCollateralValueUsd = globalData.totalValue;</span>
  885 |     | <span class='neutral'>    //     states[callNum].totalCollateralValueUsdGhost = userTotalData.totalValue;</span>
  886 |     | <span class='neutral'></span>
  887 |     | <span class='neutral'>    //     states[callNum].collateralValueAllUsersSUSDCalculated = int256(</span>
  888 |     | <span class='neutral'>    //         userTotalData.susdValue</span>
  889 |     | <span class='neutral'>    //     );</span>
  890 |     | <span class='neutral'>    //     states[callNum].collateralValueAllUsersWETHCalculated = int256(</span>
  891 |     | <span class='neutral'>    //         userTotalData.wethValue</span>
  892 |     | <span class='neutral'>    //     );</span>
  893 |     | <span class='neutral'>    //     states[callNum].collateralValueAllUsersWBTCCalculated = int256(</span>
  894 |     | <span class='neutral'>    //         userTotalData.wbtcValue</span>
  895 |     | <span class='neutral'>    //     );</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    //     // Logging</span>
  898 |     | <span class='neutral'>    //     console2.log(&quot;Global SUSD Collateral:&quot;, globalData.susdValue);</span>
  899 |     | <span class='neutral'>    //     console2.log(&quot;Global WETH Collateral:&quot;, globalData.wethValue);</span>
  900 |     | <span class='neutral'>    //     console2.log(&quot;Global WBTC Collateral:&quot;, globalData.wbtcValue);</span>
  901 |     | <span class='neutral'>    //     console2.log(&quot;Total Global Collateral Value:&quot;, globalData.totalValue);</span>
  902 |     | <span class='neutral'>    //     console2.log(&quot;Total User Collateral Value:&quot;, userTotalData.totalValue);</span>
  903 |     | <span class='neutral'></span>
  904 |     | <span class='neutral'>    //     _logGlobalCollateralValuesCoverage(</span>
  905 |     | <span class='neutral'>    //         globalData.susdValue,</span>
  906 |     | <span class='neutral'>    //         globalData.wethValue,</span>
  907 |     | <span class='neutral'>    //         globalData.wbtcValue,</span>
  908 |     | <span class='neutral'>    //         globalData.totalValue,</span>
  909 |     | <span class='neutral'>    //         userTotalData.totalValue,</span>
  910 |     | <span class='neutral'>    //         states[callNum].skew</span>
  911 |     | <span class='neutral'>    //     );</span>
  912 |     | <span class='neutral'>    // }</span>
  913 |     | <span class='neutral'></span>
  914 | *   | <span class='executed'>    function getAndCalculateCollateralValues(uint8 callNum) private {</span>
  915 |     | <span class='neutral'>        // User collateral values</span>
  916 | *   | <span class='executed'>        uint256 userTotalSusdValue = states[callNum]</span>
  917 | *   | <span class='executed'>            .actorStates[ACCOUNTS[0]]</span>
  918 |     | <span class='neutral'>            .collateralAmountSUSD +</span>
  919 | *   | <span class='executed'>            states[callNum].actorStates[ACCOUNTS[1]].collateralAmountSUSD +</span>
  920 | *   | <span class='executed'>            states[callNum].actorStates[ACCOUNTS[2]].collateralAmountSUSD;</span>
  921 |     | <span class='neutral'></span>
  922 | *   | <span class='executed'>        uint256 userTotalWethValue = states[callNum]</span>
  923 | *   | <span class='executed'>            .actorStates[ACCOUNTS[0]]</span>
  924 |     | <span class='neutral'>            .collateralAmountWETH +</span>
  925 | *   | <span class='executed'>            states[callNum].actorStates[ACCOUNTS[1]].collateralAmountWETH +</span>
  926 | *   | <span class='executed'>            states[callNum].actorStates[ACCOUNTS[2]].collateralAmountWETH;</span>
  927 |     | <span class='neutral'></span>
  928 | *   | <span class='executed'>        uint256 userTotalWbtcValue = states[callNum]</span>
  929 | *   | <span class='executed'>            .actorStates[ACCOUNTS[0]]</span>
  930 |     | <span class='neutral'>            .collateralAmountWBTC +</span>
  931 | *   | <span class='executed'>            states[callNum].actorStates[ACCOUNTS[1]].collateralAmountWBTC +</span>
  932 | *   | <span class='executed'>            states[callNum].actorStates[ACCOUNTS[2]].collateralAmountWBTC;</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>        // Get prices</span>
  935 | *   | <span class='executed'>        int256 wethPrice = mockOracleManager.getPrice(WETH_ORACLE_NODE_ID);</span>
  936 | *   | <span class='executed'>        int256 wbtcPrice = mockOracleManager.getPrice(WBTC_ORACLE_NODE_ID);</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>        // Calculate total user collateral value</span>
  939 | *   | <span class='executed'>        uint256 userTotalValue = userTotalSusdValue +</span>
  940 | *   | <span class='executed'>            ((uint256(wethPrice) * userTotalWethValue) / 1e18) +</span>
  941 | *   | <span class='executed'>            ((uint256(wbtcPrice) * userTotalWbtcValue) / 1e18);</span>
  942 |     | <span class='neutral'></span>
  943 | *   | <span class='executed'>        states[callNum].totalCollateralValueUsdGhost = userTotalValue;</span>
  944 |     | <span class='neutral'></span>
  945 | *   | <span class='executed'>        states[callNum].collateralValueAllUsersSUSDCalculated = int256(</span>
  946 |     | <span class='neutral'>            userTotalSusdValue</span>
  947 |     | <span class='neutral'>        );</span>
  948 | *   | <span class='executed'>        states[callNum].collateralValueAllUsersWETHCalculated = int256(</span>
  949 |     | <span class='neutral'>            userTotalWethValue</span>
  950 |     | <span class='neutral'>        );</span>
  951 | *   | <span class='executed'>        states[callNum].collateralValueAllUsersWBTCCalculated = int256(</span>
  952 |     | <span class='neutral'>            userTotalWbtcValue</span>
  953 |     | <span class='neutral'>        );</span>
  954 |     | <span class='neutral'>    }</span>
  955 | *   | <span class='executed'>    function getUtilizationInfo(uint8 callNum) private {</span>
  956 | *   | <span class='executed'>        UtilizationVars memory vars;</span>
  957 |     | <span class='neutral'></span>
  958 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
  959 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  960 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.minimumCredit.selector,</span>
  961 |     | <span class='neutral'>                1</span>
  962 |     | <span class='neutral'>            )</span>
  963 |     | <span class='neutral'>        );</span>
  964 | *   | <span class='executed'>        assert(success);</span>
  965 | *   | <span class='executed'>        states[callNum].minimumCredit = abi.decode(returnData, (uint256));</span>
  966 |     | <span class='neutral'></span>
  967 | *   | <span class='executed'>        (success, returnData) = perps.staticcall(</span>
  968 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  969 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.utilizationRate.selector</span>
  970 |     | <span class='neutral'>            )</span>
  971 |     | <span class='neutral'>        );</span>
  972 | *   | <span class='executed'>        assert(success);</span>
  973 | *   | <span class='executed'>        (</span>
  974 | *   | <span class='executed'>            vars.utilizationRate,</span>
  975 | *   | <span class='executed'>            vars.delegatedCollateral,</span>
  976 | *   | <span class='executed'>            vars.lockedCredit</span>
  977 | *   | <span class='executed'>        ) = abi.decode(returnData, (uint256, uint256, uint256));</span>
  978 | *   | <span class='executed'>        states[callNum].utilizationRate = vars.utilizationRate;</span>
  979 | *   | <span class='executed'>        states[callNum].delegatedCollateral = vars.delegatedCollateral;</span>
  980 | *   | <span class='executed'>        states[callNum].lockedCredit = vars.lockedCredit;</span>
  981 |     | <span class='neutral'></span>
  982 | *   | <span class='executed'>        _logUtilizationInfoCoverage(</span>
  983 | *   | <span class='executed'>            states[callNum].minimumCredit,</span>
  984 | *   | <span class='executed'>            vars.utilizationRate,</span>
  985 |     | <span class='neutral'>            vars.delegatedCollateral,</span>
  986 |     | <span class='neutral'>            vars.lockedCredit</span>
  987 |     | <span class='neutral'>        );</span>
  988 |     | <span class='neutral'>    }</span>
  989 |     | <span class='neutral'></span>
  990 | *   | <span class='executed'>    function getMarginInfo(uint8 callNum, uint128 accountId) private {</span>
  991 | *   | <span class='executed'>        MarginVars memory vars;</span>
  992 |     | <span class='neutral'></span>
  993 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.staticcall(</span>
  994 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  995 |     | <span class='neutral'>                perpsAccountModuleImpl.getAvailableMargin.selector,</span>
  996 |     | <span class='neutral'>                accountId</span>
  997 |     | <span class='neutral'>            )</span>
  998 |     | <span class='neutral'>        );</span>
  999 | *   | <span class='executed'>        assert(success);</span>
 1000 | *   | <span class='executed'>        vars.availableMargin = abi.decode(returnData, (int256));</span>
 1001 | *   | <span class='executed'>        states[callNum].actorStates[accountId].availableMargin = vars</span>
 1002 |     | <span class='neutral'>            .availableMargin;</span>
 1003 |     | <span class='neutral'></span>
 1004 | *   | <span class='executed'>        (success, returnData) = perps.staticcall(</span>
 1005 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 1006 |     | <span class='neutral'>                perpsAccountModuleImpl.getRequiredMargins.selector,</span>
 1007 |     | <span class='neutral'>                accountId</span>
 1008 |     | <span class='neutral'>            )</span>
 1009 |     | <span class='neutral'>        );</span>
 1010 | *   | <span class='executed'>        assert(success);</span>
 1011 | *   | <span class='executed'>        (vars.requiredInitialMargin, vars.requiredMaintenanceMargin, ) = abi</span>
 1012 | *   | <span class='executed'>            .decode(returnData, (uint256, uint256, uint256));</span>
 1013 | *   | <span class='executed'>        states[callNum].actorStates[accountId].requiredInitialMargin = vars</span>
 1014 |     | <span class='neutral'>            .requiredInitialMargin;</span>
 1015 | *   | <span class='executed'>        states[callNum].actorStates[accountId].requiredMaintenanceMargin = vars</span>
 1016 |     | <span class='neutral'>            .requiredMaintenanceMargin;</span>
 1017 |     | <span class='neutral'></span>
 1018 | *   | <span class='executed'>        _logMarginInfoCoverage(</span>
 1019 | *   | <span class='executed'>            vars.availableMargin,</span>
 1020 | *   | <span class='executed'>            vars.requiredInitialMargin,</span>
 1021 |     | <span class='neutral'>            vars.requiredMaintenanceMargin,</span>
 1022 | *   | <span class='executed'>            states[callNum].actorStates[accountId].maxLiquidationReward</span>
 1023 |     | <span class='neutral'>        );</span>
 1024 |     | <span class='neutral'>    }</span>
 1025 |     | <span class='neutral'></span>
 1026 | *   | <span class='executed'>    function getDebtInfo(uint8 callNum, uint128 accountId) private {</span>
 1027 | *   | <span class='executed'>        DebtVars memory vars;</span>
 1028 |     | <span class='neutral'></span>
 1029 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
 1030 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 1031 |     | <span class='neutral'>                mockLensModuleImpl.getGlobalTotalAccountsDebt.selector</span>
 1032 |     | <span class='neutral'>            )</span>
 1033 |     | <span class='neutral'>        );</span>
 1034 | *   | <span class='executed'>        assert(success);</span>
 1035 | *   | <span class='executed'>        vars.totalDebt = abi.decode(returnData, (int256));</span>
 1036 | *   | <span class='executed'>        states[callNum].totalDebt = vars.totalDebt;</span>
 1037 |     | <span class='neutral'></span>
 1038 | *   | <span class='executed'>        getReportedDebt(callNum, 1);</span>
 1039 | *   | <span class='executed'>        getReportedDebt(callNum, 2);</span>
 1040 | *   | <span class='executed'>        getMarketDebtCorrectionAccumulator(callNum, 1);</span>
 1041 | *   | <span class='executed'>        getMarketDebtCorrectionAccumulator(callNum, 2);</span>
 1042 |     | <span class='neutral'>    }</span>
 1043 |     | <span class='neutral'></span>
 1044 | *   | <span class='executed'>    function getReportedDebt(uint8 callNum, uint128 marketId) private {</span>
 1045 | *   | <span class='executed'>        DebtVars memory vars;</span>
 1046 |     | <span class='neutral'></span>
 1047 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
 1048 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 1049 |     | <span class='neutral'>                perpsMarketFactoryModuleImpl.reportedDebt.selector,</span>
 1050 |     | <span class='neutral'>                marketId</span>
 1051 |     | <span class='neutral'>            )</span>
 1052 |     | <span class='neutral'>        );</span>
 1053 | *   | <span class='executed'>        assert(success);</span>
 1054 | *   | <span class='executed'>        vars.reportedDebt = abi.decode(returnData, (uint256));</span>
 1055 |     | <span class='neutral'></span>
 1056 | *   | <span class='executed'>        if (marketId == 1) {</span>
 1057 | *   | <span class='executed'>            states[callNum].wethMarket.reportedDebt = vars.reportedDebt;</span>
 1058 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
 1059 | *   | <span class='executed'>            states[callNum].wbtcMarket.reportedDebt = vars.reportedDebt;</span>
 1060 |     | <span class='neutral'>        }</span>
 1061 |     | <span class='neutral'>    }</span>
 1062 |     | <span class='neutral'></span>
 1063 | *   | <span class='executed'>    function getMarketDebtCorrectionAccumulator(</span>
 1064 |     | <span class='neutral'>        uint8 callNum,</span>
 1065 |     | <span class='neutral'>        uint128 marketId</span>
 1066 | *   | <span class='executed'>    ) private {</span>
 1067 | *   | <span class='executed'>        DebtVars memory vars;</span>
 1068 |     | <span class='neutral'></span>
 1069 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
 1070 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 1071 |     | <span class='neutral'>                mockLensModuleImpl.getDebtCorrectionAccumulator.selector,</span>
 1072 |     | <span class='neutral'>                marketId</span>
 1073 |     | <span class='neutral'>            )</span>
 1074 |     | <span class='neutral'>        );</span>
 1075 | *   | <span class='executed'>        assert(success);</span>
 1076 | *   | <span class='executed'>        vars.debtCorrectionAccumulator = abi.decode(returnData, (uint256));</span>
 1077 |     | <span class='neutral'></span>
 1078 | *   | <span class='executed'>        if (marketId == 1) {</span>
 1079 | *   | <span class='executed'>            states[callNum].wethMarket.debtCorrectionAccumulator = vars</span>
 1080 |     | <span class='neutral'>                .debtCorrectionAccumulator;</span>
 1081 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
 1082 | *   | <span class='executed'>            states[callNum].wbtcMarket.debtCorrectionAccumulator = vars</span>
 1083 |     | <span class='neutral'>                .debtCorrectionAccumulator;</span>
 1084 |     | <span class='neutral'>        }</span>
 1085 |     | <span class='neutral'>    }</span>
 1086 |     | <span class='neutral'></span>
 1087 | *   | <span class='executed'>    function _checkIfPositionWasProifitable(</span>
 1088 |     | <span class='neutral'>        uint8 callNum,</span>
 1089 |     | <span class='neutral'>        uint128 accountId,</span>
 1090 |     | <span class='neutral'>        uint128 marketId</span>
 1091 |     | <span class='neutral'>    ) internal {</span>
 1092 | *   | <span class='executed'>        console2.log(&quot;checkIfPositionWasProifitable::accountId&quot;, accountId);</span>
 1093 | *   | <span class='executed'>        console2.log(&quot;checkIfPositionWasProifitable::marketId&quot;, marketId);</span>
 1094 | *   | <span class='executed'>        PositionInfoVars memory vars;</span>
 1095 |     | <span class='neutral'></span>
 1096 | *   | <span class='executed'>        (bool success, bytes memory returnData) = perps.call(</span>
 1097 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 1098 |     | <span class='neutral'>                perpsAccountModuleImpl.getOpenPosition.selector,</span>
 1099 |     | <span class='neutral'>                accountId,</span>
 1100 |     | <span class='neutral'>                marketId</span>
 1101 |     | <span class='neutral'>            )</span>
 1102 |     | <span class='neutral'>        );</span>
 1103 | *   | <span class='executed'>        assert(success);</span>
 1104 | *   | <span class='executed'>        (</span>
 1105 |     | <span class='neutral'>            vars.totalPnl,</span>
 1106 | *   | <span class='executed'>            vars.accruedFunding,</span>
 1107 | *   | <span class='executed'>            vars.positionSize,</span>
 1108 | *   | <span class='executed'>            vars.owedInterest</span>
 1109 | *   | <span class='executed'>        ) = abi.decode(returnData, (int256, int256, int128, uint256));</span>
 1110 |     | <span class='neutral'></span>
 1111 | *   | <span class='executed'>        if (marketId == 1) {</span>
 1112 | *   | <span class='executed'>            console2.log(&quot;Market: WETH&quot;);</span>
 1113 | *   | <span class='executed'>            positionStates[callNum]</span>
 1114 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1115 | *   | <span class='executed'>                .previousTradePositionPnl = positionStates[callNum]</span>
 1116 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1117 |     | <span class='neutral'>                .wethMarket</span>
 1118 |     | <span class='neutral'>                .totalPnl;</span>
 1119 | *   | <span class='executed'>            positionStates[callNum]</span>
 1120 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1121 |     | <span class='neutral'>                .wethMarket</span>
 1122 | *   | <span class='executed'>                .totalPnl = vars.totalPnl;</span>
 1123 | *   | <span class='executed'>            positionStates[callNum]</span>
 1124 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1125 |     | <span class='neutral'>                .wethMarket</span>
 1126 | *   | <span class='executed'>                .positionSize = vars.positionSize;</span>
 1127 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
 1128 | *   | <span class='executed'>            console2.log(&quot;Market: WBTC&quot;);</span>
 1129 | *   | <span class='executed'>            positionStates[callNum]</span>
 1130 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1131 | *   | <span class='executed'>                .previousTradePositionPnl = positionStates[callNum]</span>
 1132 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1133 |     | <span class='neutral'>                .wbtcMarket</span>
 1134 |     | <span class='neutral'>                .totalPnl;</span>
 1135 | *   | <span class='executed'>            positionStates[callNum]</span>
 1136 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1137 |     | <span class='neutral'>                .wbtcMarket</span>
 1138 | *   | <span class='executed'>                .totalPnl = vars.totalPnl;</span>
 1139 | *   | <span class='executed'>            positionStates[callNum]</span>
 1140 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1141 |     | <span class='neutral'>                .wbtcMarket</span>
 1142 | *   | <span class='executed'>                .positionSize = vars.positionSize;</span>
 1143 |     | <span class='neutral'>        } else {</span>
 1144 |     | <span class='unexecuted'>            console2.log(&quot;Invalid marketId&quot;, marketId);</span>
 1145 |     | <span class='unexecuted'>            revert(&quot;Invalid marketId&quot;);</span>
 1146 |     | <span class='neutral'>        }</span>
 1147 |     | <span class='neutral'></span>
 1148 | *   | <span class='executed'>        positionStates[callNum]</span>
 1149 |     | <span class='neutral'>            .actorStates[accountId]</span>
 1150 | *   | <span class='executed'>            .isPreviousPositionInLoss = vars.totalPnl &lt; 0;</span>
 1151 | *   | <span class='executed'>        positionStates[callNum]</span>
 1152 |     | <span class='neutral'>            .actorStates[accountId]</span>
 1153 |     | <span class='neutral'>            .isPreviousTradePositionInLoss =</span>
 1154 | *   | <span class='executed'>            positionStates[callNum]</span>
 1155 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1156 |     | <span class='neutral'>                .previousTradePositionPnl &lt;</span>
 1157 |     | <span class='neutral'>            0;</span>
 1158 | *   | <span class='executed'>        positionStates[callNum].actorStates[accountId].latestPositionPnl = vars</span>
 1159 |     | <span class='neutral'>            .totalPnl;</span>
 1160 |     | <span class='neutral'></span>
 1161 | *   | <span class='executed'>        console2.log(</span>
 1162 |     | <span class='neutral'>            &quot;checkIfPositionWasProifitable::isPreviousPositionInLoss&quot;,</span>
 1163 | *   | <span class='executed'>            positionStates[callNum]</span>
 1164 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1165 |     | <span class='neutral'>                .isPreviousPositionInLoss</span>
 1166 |     | <span class='neutral'>        );</span>
 1167 | *   | <span class='executed'>        console2.log(</span>
 1168 |     | <span class='neutral'>            &quot;checkIfPositionWasProifitable::isPreviousTradePositionInLoss&quot;,</span>
 1169 | *   | <span class='executed'>            positionStates[callNum]</span>
 1170 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1171 |     | <span class='neutral'>                .isPreviousTradePositionInLoss</span>
 1172 |     | <span class='neutral'>        );</span>
 1173 | *   | <span class='executed'>        console2.log(</span>
 1174 |     | <span class='neutral'>            &quot;checkIfPositionWasProifitable::previousTradePositionPnl&quot;,</span>
 1175 | *   | <span class='executed'>            positionStates[callNum]</span>
 1176 |     | <span class='neutral'>                .actorStates[accountId]</span>
 1177 |     | <span class='neutral'>                .previousTradePositionPnl</span>
 1178 |     | <span class='neutral'>        );</span>
 1179 | *   | <span class='executed'>        console2.log(</span>
 1180 |     | <span class='neutral'>            &quot;checkIfPositionWasProifitable::latestPositionPnl&quot;,</span>
 1181 | *   | <span class='executed'>            positionStates[callNum].actorStates[accountId].latestPositionPnl</span>
 1182 |     | <span class='neutral'>        );</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function debugBefore(address[] memory actors) internal {</span>
 1186 |     | <span class='neutral'>        debugState(0, actors);</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function debugAfter(address[] memory actors) internal {</span>
 1190 |     | <span class='neutral'>        debugState(1, actors);</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function debugState(uint8 callNum, address[] memory actors) internal {</span>
 1194 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 1195 |     | <span class='unexecuted'>            debugActorState(callNum, actors[i]);</span>
 1196 |     | <span class='neutral'>        }</span>
 1197 |     | <span class='neutral'>    }</span>
 1198 |     | <span class='neutral'></span>
 1199 |     | <span class='unexecuted'>    function debugActorState(uint8 callNum, address actor) internal {</span>
 1200 |     | <span class='unexecuted'>        fl.log(&quot;Actor: &quot;, actor);</span>
 1201 |     | <span class='neutral'>    }</span>
 1202 |     | <span class='neutral'>}</span>
 1203 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/FuzzStorageVariables.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../util/FuzzConstants.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../util/CheckCaller.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import {MockRouter} from &quot;../mocks/MockRouter.sol&quot;;</span>
   9 |     | <span class='neutral'>import {MockSynthetixV3} from &quot;../mocks/MockSynthetixV3.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Proxy} from &quot;../../Proxy.sol&quot;;</span>
  11 |     | <span class='neutral'>import {MockOracleManager} from &quot;../mocks/MockOracleManager.sol&quot;;</span>
  12 |     | <span class='neutral'>import {MockERC20} from &quot;../mocks/MockERC20.sol&quot;;</span>
  13 |     | <span class='neutral'>import {MockOracleManager} from &quot;../mocks/MockOracleManager.sol&quot;;</span>
  14 |     | <span class='neutral'>import {CoreModule} from &quot;../../modules/CoreModule.sol&quot;;</span>
  15 |     | <span class='neutral'>import {AsyncOrderCancelModule} from &quot;../../modules/AsyncOrderCancelModule.sol&quot;;</span>
  16 |     | <span class='neutral'>import {AsyncOrderModule} from &quot;../../modules/AsyncOrderModule.sol&quot;;</span>
  17 |     | <span class='neutral'>import {AsyncOrderSettlementPythModule} from &quot;../../modules/AsyncOrderSettlementPythModule.sol&quot;;</span>
  18 |     | <span class='neutral'>import {CollateralConfigurationModule} from &quot;../../modules/CollateralConfigurationModule.sol&quot;;</span>
  19 |     | <span class='neutral'>import {FeatureFlagModule} from &quot;../../modules/FeatureFlagModule.sol&quot;;</span>
  20 |     | <span class='neutral'>import {GlobalPerpsMarketModule} from &quot;../../modules/GlobalPerpsMarketModule.sol&quot;;</span>
  21 |     | <span class='neutral'>import {LiquidationModule} from &quot;../../modules/LiquidationModule.sol&quot;;</span>
  22 |     | <span class='neutral'>import {MarketConfigurationModule} from &quot;../../modules/MarketConfigurationModule.sol&quot;;</span>
  23 |     | <span class='neutral'>import {PerpsAccountModule} from &quot;../../modules/PerpsAccountModule.sol&quot;;</span>
  24 |     | <span class='neutral'>import {PerpsMarketFactoryModule} from &quot;../../modules/PerpsMarketFactoryModule.sol&quot;;</span>
  25 |     | <span class='neutral'>import {PerpsMarketModule} from &quot;../../modules/PerpsMarketModule.sol&quot;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>import {MockModule} from &quot;../mocks/MockModule.sol&quot;;</span>
  28 |     | <span class='neutral'>import {MockPyth} from &quot;../mocks/MockPyth.sol&quot;;</span>
  29 |     | <span class='neutral'>import {MockPythERC7412Wrapper} from &quot;../../mocks/MockPythERC7412Wrapper.sol&quot;;</span>
  30 |     | <span class='neutral'>import {MockRewardDistributor} from &quot;../mocks/MockRewardDistributor.sol&quot;;</span>
  31 |     | <span class='neutral'>import {MockSpotMarket} from &quot;../mocks/MockSpotMarket.sol&quot;;</span>
  32 |     | <span class='neutral'>import {MockVaultModule} from &quot;../mocks/MockVaultModule.sol&quot;;</span>
  33 |     | <span class='neutral'>import {MockLensModule} from &quot;../mocks/MockLensModule.sol&quot;;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>import {MockGasPriceNode} from &quot;../../mocks/MockGasPriceNode.sol&quot;;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>import &quot;lib/forge-std/src/Test.sol&quot;;</span>
  38 |     | <span class='neutral'>// import &quot;@perimetersec/fuzzlib/src/IHEVM.sol&quot;;</span>
  39 |     | <span class='neutral'>//NOTE: uncomment this and comment out Test.sol import and inheritance to get rid of forundry</span>
  40 |     | <span class='unexecuted'>contract FuzzStorageVariables is FuzzConstants, Test {</span>
  41 |     | <span class='neutral'>    //Foundry compatibility</span>
  42 |     | <span class='neutral'>    bool isFoundry;</span>
  43 |     | <span class='neutral'>    bool guidedDone;</span>
  44 |     | <span class='neutral'>    CheckCaller checkCaller;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // Echidna settings</span>
  47 |     | <span class='neutral'>    address internal currentActor;</span>
  48 |     | <span class='unexecuted'>    bool internal _setActor = true;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    // user =&gt; accountId</span>
  51 |     | <span class='neutral'>    mapping(address =&gt; uint128) userToAccountIds;</span>
  52 |     | <span class='neutral'>    mapping(uint128 =&gt; address) accountIdToUser;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    // pythNodeId =&gt; chainlinkNodeId, chainlinkNodeId =&gt; pythNodeId</span>
  55 |     | <span class='neutral'>    mapping(bytes32 node1 =&gt; bytes32 node2) oracleNodes;</span>
  56 |     | <span class='neutral'>    // collateralToken =&gt; chainlink nodeId</span>
  57 |     | <span class='neutral'>    mapping(address collateralToken =&gt; bytes32 nodeId) tokenChainlinkNode;</span>
  58 | *   | <span class='executed'>    mapping(address =&gt; uint256) public collateralToMarketId;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    MockERC20[] internal tokens;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    // All of the deployed contracts</span>
  63 |     | <span class='neutral'>    address internal perps;</span>
  64 |     | <span class='neutral'>    MockRouter internal router;</span>
  65 |     | <span class='neutral'>    MockSpotMarket internal spot;</span>
  66 |     | <span class='neutral'>    MockSynthetixV3 internal v3Mock;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    CoreModule internal coreModuleImpl;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    AsyncOrderCancelModule internal asyncOrderCancelModuleImpl;</span>
  71 |     | <span class='neutral'>    AsyncOrderModule internal asyncOrderModuleImpl;</span>
  72 |     | <span class='neutral'>    AsyncOrderSettlementPythModule internal asyncOrderSettlementPythModuleImpl;</span>
  73 |     | <span class='neutral'>    CollateralConfigurationModule internal collateralConfigurationModuleImpl;</span>
  74 |     | <span class='neutral'>    FeatureFlagModule internal featureFlagModuleImpl;</span>
  75 |     | <span class='neutral'>    GlobalPerpsMarketModule internal globalPerpsMarketModuleImpl;</span>
  76 |     | <span class='neutral'>    LiquidationModule internal liquidationModuleImpl;</span>
  77 |     | <span class='neutral'>    MarketConfigurationModule internal marketConfigurationModuleImpl;</span>
  78 |     | <span class='neutral'>    PerpsAccountModule internal perpsAccountModuleImpl;</span>
  79 |     | <span class='neutral'>    PerpsMarketFactoryModule internal perpsMarketFactoryModuleImpl;</span>
  80 |     | <span class='neutral'>    PerpsMarketModule internal perpsMarketModuleImpl;</span>
  81 |     | <span class='neutral'>    // PoolModule internal poolModuleImpl;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    MockModule internal mockModuleImpl;</span>
  84 |     | <span class='neutral'>    MockOracleManager internal mockOracleManager;</span>
  85 |     | <span class='neutral'>    MockERC20 internal sUSDTokenMock;</span>
  86 |     | <span class='neutral'>    MockERC20 internal wethTokenMock;</span>
  87 |     | <span class='neutral'>    MockERC20 internal wbtcTokenMock;</span>
  88 |     | <span class='neutral'>    MockERC20 internal hugePrecisionTokenMock;</span>
  89 |     | <span class='neutral'>    MockPyth internal mockPyth;</span>
  90 |     | <span class='neutral'>    MockPythERC7412Wrapper internal pythWrapper;</span>
  91 |     | <span class='neutral'>    MockRewardDistributor internal rewardWETHDistributorMock;</span>
  92 |     | <span class='neutral'>    MockRewardDistributor internal rewardWBTCDistributorMock;</span>
  93 |     | <span class='neutral'>    MockRewardDistributor internal rewardHUGEDistributorMock;</span>
  94 |     | <span class='neutral'>    MockGasPriceNode internal mockGasPriceNode;</span>
  95 |     | <span class='neutral'>    MockVaultModule internal vaultModuleMock;</span>
  96 |     | <span class='neutral'>    MockLensModule internal mockLensModuleImpl;</span>
  97 |     | <span class='neutral'>    // bool modifyCalled;</span>
  98 |     | <span class='neutral'>    // bool commitCalled;</span>
  99 |     | <span class='neutral'>    // address commitCaller;</span>
 100 |     | <span class='unexecuted'>    uint128 latestAvailableId = 4;</span>
 101 |     | <span class='neutral'>}</span>
 102 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/GlobalCoverage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='unexecuted'>contract GlobalCoverage is FuzzBase {</span>
   6 | *   | <span class='executed'>    function _logGlobalCollateralValuesCoverage(</span>
   7 |     | <span class='neutral'>        uint256 depositedSusdCollateral,</span>
   8 |     | <span class='neutral'>        uint256 depositedWethCollateral,</span>
   9 |     | <span class='neutral'>        uint256 depositedWbtcCollateral,</span>
  10 |     | <span class='neutral'>        uint256 totalCollateralValueUsd,</span>
  11 |     | <span class='neutral'>        uint256 totalCollateralValueUsdGhost,</span>
  12 |     | <span class='neutral'>        int128 skew</span>
  13 |     | <span class='neutral'>    ) internal {</span>
  14 | *   | <span class='executed'>        _logSusdCollateralCoverage(depositedSusdCollateral);</span>
  15 | *   | <span class='executed'>        _logWethCollateralCoverage(depositedWethCollateral);</span>
  16 | *   | <span class='executed'>        _logWbtcCollateralCoverage(depositedWbtcCollateral);</span>
  17 | *   | <span class='executed'>        _logTotalCollateralValueCoverage(</span>
  18 | *   | <span class='executed'>            totalCollateralValueUsd,</span>
  19 | *   | <span class='executed'>            totalCollateralValueUsdGhost</span>
  20 |     | <span class='neutral'>        );</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>    function _logSusdCollateralCoverage(</span>
  24 |     | <span class='neutral'>        uint256 depositedSusdCollateral</span>
  25 |     | <span class='neutral'>    ) internal {</span>
  26 | *   | <span class='executed'>        if (depositedSusdCollateral == 0) {</span>
  27 | *   | <span class='executed'>            fl.log(&quot;No SUSD collateral deposited&quot;);</span>
  28 | *   | <span class='executed'>        } else if (depositedSusdCollateral &lt;= 1000e18) {</span>
  29 | *   | <span class='executed'>            fl.log(&quot;Low SUSD collateral (0-1000)&quot;);</span>
  30 | *   | <span class='executed'>        } else if (depositedSusdCollateral &lt;= 10000e18) {</span>
  31 | *   | <span class='executed'>            fl.log(&quot;Medium SUSD collateral (1000-10000)&quot;);</span>
  32 | *   | <span class='executed'>        } else if (depositedSusdCollateral &lt;= 100000e18) {</span>
  33 | *   | <span class='executed'>            fl.log(&quot;High SUSD collateral (10000-100000)&quot;);</span>
  34 |     | <span class='neutral'>        } else {</span>
  35 | *   | <span class='executed'>            fl.log(&quot;Very high SUSD collateral (&gt;100000)&quot;);</span>
  36 |     | <span class='neutral'>        }</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>    function _logWethCollateralCoverage(</span>
  40 |     | <span class='neutral'>        uint256 depositedWethCollateral</span>
  41 |     | <span class='neutral'>    ) internal {</span>
  42 | *   | <span class='executed'>        if (depositedWethCollateral == 0) {</span>
  43 | *   | <span class='executed'>            fl.log(&quot;No WETH collateral deposited&quot;);</span>
  44 | *   | <span class='executed'>        } else if (depositedWethCollateral &lt;= 10e18) {</span>
  45 | *   | <span class='executed'>            fl.log(&quot;Low WETH collateral (0-10)&quot;);</span>
  46 | *   | <span class='executed'>        } else if (depositedWethCollateral &lt;= 100e18) {</span>
  47 | *   | <span class='executed'>            fl.log(&quot;Medium WETH collateral (10-100)&quot;);</span>
  48 | *   | <span class='executed'>        } else if (depositedWethCollateral &lt;= 1000e18) {</span>
  49 | *   | <span class='executed'>            fl.log(&quot;High WETH collateral (100-1000)&quot;);</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 | *   | <span class='executed'>            fl.log(&quot;Very high WETH collateral (&gt;1000)&quot;);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 | *   | <span class='executed'>    function _logWbtcCollateralCoverage(</span>
  56 |     | <span class='neutral'>        uint256 depositedWbtcCollateral</span>
  57 |     | <span class='neutral'>    ) internal {</span>
  58 | *   | <span class='executed'>        if (depositedWbtcCollateral == 0) {</span>
  59 | *   | <span class='executed'>            fl.log(&quot;No WBTC collateral deposited&quot;);</span>
  60 | *   | <span class='executed'>        } else if (depositedWbtcCollateral &lt;= 1e8) {</span>
  61 | *   | <span class='executed'>            fl.log(&quot;Low WBTC collateral (0-1)&quot;);</span>
  62 | *   | <span class='executed'>        } else if (depositedWbtcCollateral &lt;= 10e8) {</span>
  63 |     | <span class='unexecuted'>            fl.log(&quot;Medium WBTC collateral (1-10)&quot;);</span>
  64 | *   | <span class='executed'>        } else if (depositedWbtcCollateral &lt;= 100e8) {</span>
  65 | *   | <span class='executed'>            fl.log(&quot;High WBTC collateral (10-100)&quot;);</span>
  66 |     | <span class='neutral'>        } else {</span>
  67 | *   | <span class='executed'>            fl.log(&quot;Very high WBTC collateral (&gt;100)&quot;);</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>    function _logTotalCollateralValueCoverage(</span>
  72 |     | <span class='neutral'>        uint256 totalCollateralValueUsd,</span>
  73 |     | <span class='neutral'>        uint256 totalCollateralValueUsdGhost</span>
  74 |     | <span class='neutral'>    ) internal {</span>
  75 | *   | <span class='executed'>        if (totalCollateralValueUsd == 0) {</span>
  76 | *   | <span class='executed'>            fl.log(&quot;No total collateral value&quot;);</span>
  77 | *   | <span class='executed'>        } else if (totalCollateralValueUsd &lt;= 10000e18) {</span>
  78 | *   | <span class='executed'>            fl.log(&quot;Low total collateral value (0-10000)&quot;);</span>
  79 | *   | <span class='executed'>        } else if (totalCollateralValueUsd &lt;= 100000e18) {</span>
  80 | *   | <span class='executed'>            fl.log(&quot;Medium total collateral value (10000-100000)&quot;);</span>
  81 | *   | <span class='executed'>        } else if (totalCollateralValueUsd &lt;= 1000000e18) {</span>
  82 | *   | <span class='executed'>            fl.log(&quot;High total collateral value (100000-1000000)&quot;);</span>
  83 |     | <span class='neutral'>        } else {</span>
  84 | *   | <span class='executed'>            fl.log(&quot;Very high total collateral value (&gt;1000000)&quot;);</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>        if (totalCollateralValueUsd == totalCollateralValueUsdGhost) {</span>
  88 | *   | <span class='executed'>            fl.log(&quot;Total collateral value matches ghost value&quot;);</span>
  89 | *   | <span class='executed'>        } else if (totalCollateralValueUsd &gt; totalCollateralValueUsdGhost) {</span>
  90 | *   | <span class='executed'>            fl.log(&quot;Total collateral value higher than ghost value&quot;);</span>
  91 |     | <span class='neutral'>        } else {</span>
  92 |     | <span class='unexecuted'>            fl.log(&quot;Total collateral value lower than ghost value&quot;);</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>    function _logUtilizationInfoCoverage(</span>
  97 |     | <span class='neutral'>        uint256 minimumCredit,</span>
  98 |     | <span class='neutral'>        uint256 utilizationRate,</span>
  99 |     | <span class='neutral'>        uint256 delegatedCollateral,</span>
 100 |     | <span class='neutral'>        uint256 lockedCredit</span>
 101 |     | <span class='neutral'>    ) internal {</span>
 102 |     | <span class='neutral'>        // Minimum Credit Coverage</span>
 103 | *   | <span class='executed'>        if (minimumCredit == 0) {</span>
 104 | *   | <span class='executed'>            fl.log(&quot;No minimum credit set&quot;);</span>
 105 | *   | <span class='executed'>        } else if (minimumCredit &lt;= 1000e18) {</span>
 106 | *   | <span class='executed'>            fl.log(&quot;Low minimum credit (0-1000)&quot;);</span>
 107 | *   | <span class='executed'>        } else if (minimumCredit &lt;= 10000e18) {</span>
 108 | *   | <span class='executed'>            fl.log(&quot;Medium minimum credit (1000-10000)&quot;);</span>
 109 |     | <span class='neutral'>        } else {</span>
 110 | *   | <span class='executed'>            fl.log(&quot;High minimum credit (&gt;10000)&quot;);</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // Utilization Rate Coverage</span>
 114 | *   | <span class='executed'>        if (utilizationRate == 0) {</span>
 115 | *   | <span class='executed'>            fl.log(&quot;No utilization&quot;);</span>
 116 | *   | <span class='executed'>        } else if (utilizationRate &lt;= 2000) {</span>
 117 |     | <span class='neutral'>            // Assuming utilization rate is in basis points (0.01% = 1)</span>
 118 | *   | <span class='executed'>            fl.log(&quot;Low utilization rate (0-20%)&quot;);</span>
 119 | *   | <span class='executed'>        } else if (utilizationRate &lt;= 5000) {</span>
 120 | *   | <span class='executed'>            fl.log(&quot;Medium utilization rate (20-50%)&quot;);</span>
 121 | *   | <span class='executed'>        } else if (utilizationRate &lt;= 8000) {</span>
 122 | *   | <span class='executed'>            fl.log(&quot;High utilization rate (50-80%)&quot;);</span>
 123 |     | <span class='neutral'>        } else {</span>
 124 | *   | <span class='executed'>            fl.log(&quot;Very high utilization rate (&gt;80%)&quot;);</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Delegated Collateral Coverage</span>
 128 | *   | <span class='executed'>        if (delegatedCollateral == 0) {</span>
 129 | *   | <span class='executed'>            fl.log(&quot;No delegated collateral&quot;);</span>
 130 | *   | <span class='executed'>        } else if (delegatedCollateral &lt;= 1000e18) {</span>
 131 | *   | <span class='executed'>            fl.log(&quot;Low delegated collateral (0-1000)&quot;);</span>
 132 | *   | <span class='executed'>        } else if (delegatedCollateral &lt;= 10000e18) {</span>
 133 | *   | <span class='executed'>            fl.log(&quot;Medium delegated collateral (1000-10000)&quot;);</span>
 134 |     | <span class='neutral'>        } else {</span>
 135 | *   | <span class='executed'>            fl.log(&quot;High delegated collateral (&gt;10000)&quot;);</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // Locked Credit Coverage</span>
 139 | *   | <span class='executed'>        if (lockedCredit == 0) {</span>
 140 | *   | <span class='executed'>            fl.log(&quot;No locked credit&quot;);</span>
 141 | *   | <span class='executed'>        } else if (lockedCredit &lt;= 1000e18) {</span>
 142 | *   | <span class='executed'>            fl.log(&quot;Low locked credit (0-1000)&quot;);</span>
 143 | *   | <span class='executed'>        } else if (lockedCredit &lt;= 10000e18) {</span>
 144 | *   | <span class='executed'>            fl.log(&quot;Medium locked credit (1000-10000)&quot;);</span>
 145 |     | <span class='neutral'>        } else {</span>
 146 | *   | <span class='executed'>            fl.log(&quot;High locked credit (&gt;10000)&quot;);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // Relationship between delegated collateral and locked credit</span>
 150 | *   | <span class='executed'>        if (delegatedCollateral &gt; lockedCredit) {</span>
 151 | *   | <span class='executed'>            fl.log(&quot;Delegated collateral exceeds locked credit&quot;);</span>
 152 | *   | <span class='executed'>        } else if (delegatedCollateral &lt; lockedCredit) {</span>
 153 | *   | <span class='executed'>            fl.log(&quot;Locked credit exceeds delegated collateral&quot;);</span>
 154 |     | <span class='neutral'>        } else {</span>
 155 |     | <span class='unexecuted'>            fl.log(&quot;Delegated collateral equals locked credit&quot;);</span>
 156 |     | <span class='neutral'>        }</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 | *   | <span class='executed'>    function _logMarginInfoCoverage(</span>
 160 |     | <span class='neutral'>        int256 availableMargin,</span>
 161 |     | <span class='neutral'>        uint256 requiredInitialMargin,</span>
 162 |     | <span class='neutral'>        uint256 requiredMaintenanceMargin,</span>
 163 |     | <span class='neutral'>        uint256 maxLiquidationReward</span>
 164 |     | <span class='neutral'>    ) internal {</span>
 165 |     | <span class='neutral'>        // Available Margin Coverage</span>
 166 | *   | <span class='executed'>        if (availableMargin &lt; 0) {</span>
 167 | *   | <span class='executed'>            fl.log(&quot;Negative available margin&quot;);</span>
 168 | *   | <span class='executed'>        } else if (availableMargin == 0) {</span>
 169 | *   | <span class='executed'>            fl.log(&quot;Zero available margin&quot;);</span>
 170 | *   | <span class='executed'>        } else if (availableMargin &lt;= 1000e18) {</span>
 171 | *   | <span class='executed'>            fl.log(&quot;Low available margin (0-1000)&quot;);</span>
 172 | *   | <span class='executed'>        } else if (availableMargin &lt;= 10000e18) {</span>
 173 | *   | <span class='executed'>            fl.log(&quot;Medium available margin (1000-10000)&quot;);</span>
 174 |     | <span class='neutral'>        } else {</span>
 175 | *   | <span class='executed'>            fl.log(&quot;High available margin (&gt;10000)&quot;);</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        // Required Initial Margin Coverage</span>
 179 | *   | <span class='executed'>        if (requiredInitialMargin == 0) {</span>
 180 | *   | <span class='executed'>            fl.log(&quot;No required initial margin&quot;);</span>
 181 | *   | <span class='executed'>        } else if (requiredInitialMargin &lt;= 1000e18) {</span>
 182 |     | <span class='unexecuted'>            fl.log(&quot;Low required initial margin (0-1000)&quot;);</span>
 183 | *   | <span class='executed'>        } else if (requiredInitialMargin &lt;= 10000e18) {</span>
 184 | *   | <span class='executed'>            fl.log(&quot;Medium required initial margin (1000-10000)&quot;);</span>
 185 |     | <span class='neutral'>        } else {</span>
 186 | *   | <span class='executed'>            fl.log(&quot;High required initial margin (&gt;10000)&quot;);</span>
 187 |     | <span class='neutral'>        }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        // Required Maintenance Margin Coverage</span>
 190 | *   | <span class='executed'>        if (requiredMaintenanceMargin == 0) {</span>
 191 | *   | <span class='executed'>            fl.log(&quot;No required maintenance margin&quot;);</span>
 192 | *   | <span class='executed'>        } else if (requiredMaintenanceMargin &lt;= 500e18) {</span>
 193 |     | <span class='unexecuted'>            fl.log(&quot;Low required maintenance margin (0-500)&quot;);</span>
 194 | *   | <span class='executed'>        } else if (requiredMaintenanceMargin &lt;= 5000e18) {</span>
 195 | *   | <span class='executed'>            fl.log(&quot;Medium required maintenance margin (500-5000)&quot;);</span>
 196 |     | <span class='neutral'>        } else {</span>
 197 | *   | <span class='executed'>            fl.log(&quot;High required maintenance margin (&gt;5000)&quot;);</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>        // Max Liquidation Reward Coverage</span>
 201 | *   | <span class='executed'>        if (maxLiquidationReward == 0) {</span>
 202 | *   | <span class='executed'>            fl.log(&quot;No max liquidation reward&quot;);</span>
 203 |     | <span class='unexecuted'>        } else if (maxLiquidationReward &lt;= 10e18) {</span>
 204 |     | <span class='unexecuted'>            fl.log(&quot;Low max liquidation reward (0-10)&quot;);</span>
 205 | *   | <span class='executed'>        } else if (maxLiquidationReward &lt;= 100e18) {</span>
 206 |     | <span class='unexecuted'>            fl.log(&quot;Medium max liquidation reward (10-100)&quot;);</span>
 207 |     | <span class='neutral'>        } else {</span>
 208 |     | <span class='unexecuted'>            fl.log(&quot;High max liquidation reward (&gt;100)&quot;);</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>        // Relationship between margins</span>
 212 | *   | <span class='executed'>        if (int256(requiredInitialMargin) &gt; availableMargin) {</span>
 213 | *   | <span class='executed'>            fl.log(&quot;Available margin below required initial margin&quot;);</span>
 214 | *   | <span class='executed'>        } else if (int256(requiredMaintenanceMargin) &gt; availableMargin) {</span>
 215 |     | <span class='unexecuted'>            fl.log(&quot;Available margin below required maintenance margin&quot;);</span>
 216 |     | <span class='neutral'>        } else {</span>
 217 | *   | <span class='executed'>            fl.log(&quot;Available margin above both required margins&quot;);</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    function _logReportedDebtGhostCoverage(</span>
 222 |     | <span class='neutral'>        int256 reportedDebtGhost,</span>
 223 |     | <span class='neutral'>        uint256 marketSizeGhost</span>
 224 |     | <span class='neutral'>    ) internal {</span>
 225 |     | <span class='neutral'>        // Reported Debt Ghost Coverage</span>
 226 |     | <span class='neutral'>        if (reportedDebtGhost == 0) {</span>
 227 |     | <span class='neutral'>            fl.log(&quot;No reported debt ghost&quot;);</span>
 228 |     | <span class='neutral'>        } else if (reportedDebtGhost &gt; 0) {</span>
 229 |     | <span class='neutral'>            if (reportedDebtGhost &lt;= 1000e18) {</span>
 230 |     | <span class='neutral'>                fl.log(&quot;Low positive reported debt ghost (0-1000)&quot;);</span>
 231 |     | <span class='neutral'>            } else if (reportedDebtGhost &lt;= 10000e18) {</span>
 232 |     | <span class='neutral'>                fl.log(&quot;Medium positive reported debt ghost (1000-10000)&quot;);</span>
 233 |     | <span class='neutral'>            } else {</span>
 234 |     | <span class='neutral'>                fl.log(&quot;High positive reported debt ghost (&gt;10000)&quot;);</span>
 235 |     | <span class='neutral'>            }</span>
 236 |     | <span class='neutral'>        } else {</span>
 237 |     | <span class='neutral'>            if (reportedDebtGhost &gt;= -1000e18) {</span>
 238 |     | <span class='neutral'>                fl.log(&quot;Low negative reported debt ghost (0 to -1000)&quot;);</span>
 239 |     | <span class='neutral'>            } else if (reportedDebtGhost &gt;= -10000e18) {</span>
 240 |     | <span class='neutral'>                fl.log(&quot;Medium negative reported debt ghost (-1000 to -10000)&quot;);</span>
 241 |     | <span class='neutral'>            } else {</span>
 242 |     | <span class='neutral'>                fl.log(&quot;High negative reported debt ghost (&lt;-10000)&quot;);</span>
 243 |     | <span class='neutral'>            }</span>
 244 |     | <span class='neutral'>        }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>        // Market Size Ghost Coverage</span>
 247 |     | <span class='neutral'>        if (marketSizeGhost == 0) {</span>
 248 |     | <span class='neutral'>            fl.log(&quot;No market size ghost&quot;);</span>
 249 |     | <span class='neutral'>        } else if (marketSizeGhost &lt;= 1000e18) {</span>
 250 |     | <span class='neutral'>            fl.log(&quot;Low market size ghost (0-1000)&quot;);</span>
 251 |     | <span class='neutral'>        } else if (marketSizeGhost &lt;= 10000e18) {</span>
 252 |     | <span class='neutral'>            fl.log(&quot;Medium market size ghost (1000-10000)&quot;);</span>
 253 |     | <span class='neutral'>        } else {</span>
 254 |     | <span class='neutral'>            fl.log(&quot;High market size ghost (&gt;10000)&quot;);</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>        // Relationship between reported debt ghost and market size ghost</span>
 258 |     | <span class='neutral'>        if (abs(reportedDebtGhost) &gt; int256(marketSizeGhost)) {</span>
 259 |     | <span class='neutral'>            fl.log(&quot;Absolute reported debt ghost exceeds market size ghost&quot;);</span>
 260 |     | <span class='neutral'>        } else {</span>
 261 |     | <span class='neutral'>            fl.log(</span>
 262 |     | <span class='neutral'>                &quot;Market size ghost exceeds or equals absolute reported debt ghost&quot;</span>
 263 |     | <span class='neutral'>            );</span>
 264 |     | <span class='neutral'>        }</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'>    // Helper function to get absolute value of int256</span>
 267 |     | <span class='neutral'>    function abs(int256 x) private pure returns (int256) {</span>
 268 |     | <span class='neutral'>        return x &gt;= 0 ? x : -x;</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'>}</span>
 271 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/LiquidationCoverage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='unexecuted'>contract LiquidationCoverage is FuzzBase {</span>
   6 | *   | <span class='executed'>    function _logLiquidateMarginOnlyCoverage(</span>
   7 |     | <span class='neutral'>        uint lcov_liquidateMarginOnlyCovered</span>
   8 |     | <span class='neutral'>    ) internal {</span>
   9 | *   | <span class='executed'>        if (lcov_liquidateMarginOnlyCovered == 1) {</span>
  10 | *   | <span class='executed'>            fl.log(&quot;Hit MarginOnly once&quot;);</span>
  11 | *   | <span class='executed'>        } else if (</span>
  12 | *   | <span class='executed'>            lcov_liquidateMarginOnlyCovered &gt; 1 &amp;&amp;</span>
  13 | *   | <span class='executed'>            lcov_liquidateMarginOnlyCovered &lt; 10</span>
  14 |     | <span class='neutral'>        ) {</span>
  15 | *   | <span class='executed'>            fl.log(&quot;Hit MarginOnly up to 10 times&quot;);</span>
  16 | *   | <span class='executed'>        } else if (lcov_liquidateMarginOnlyCovered &gt; 10) {</span>
  17 |     | <span class='unexecuted'>            fl.log(&quot;Hit MarginOnly more than 10 times&quot;);</span>
  18 |     | <span class='neutral'>        }</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 | *   | <span class='executed'>    function _logLiquidatableCoverage(</span>
  22 |     | <span class='neutral'>        bool isPositionLiquidatable,</span>
  23 |     | <span class='neutral'>        bool isMarginLiquidatable</span>
  24 |     | <span class='neutral'>    ) internal {</span>
  25 | *   | <span class='executed'>        if (isPositionLiquidatable &amp;&amp; isMarginLiquidatable) {</span>
  26 | *   | <span class='executed'>            fl.log(&quot;Both position and margin are liquidatable&quot;);</span>
  27 | *   | <span class='executed'>        } else if (isPositionLiquidatable) {</span>
  28 | *   | <span class='executed'>            fl.log(&quot;Only position is liquidatable&quot;);</span>
  29 | *   | <span class='executed'>        } else if (isMarginLiquidatable) {</span>
  30 |     | <span class='unexecuted'>            fl.log(&quot;Only margin is liquidatable&quot;);</span>
  31 |     | <span class='neutral'>        } else {</span>
  32 | *   | <span class='executed'>            fl.log(&quot;Neither position nor margin is liquidatable&quot;);</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 | *   | <span class='executed'>    function _logCollateralIdsCoverage(</span>
  37 |     | <span class='neutral'>        uint256[] memory collateralIds</span>
  38 |     | <span class='neutral'>    ) internal {</span>
  39 | *   | <span class='executed'>        if (collateralIds.length == 0) {</span>
  40 | *   | <span class='executed'>            fl.log(&quot;No collateral IDs&quot;);</span>
  41 | *   | <span class='executed'>        } else if (collateralIds.length == 1) {</span>
  42 | *   | <span class='executed'>            fl.log(&quot;One collateral ID&quot;);</span>
  43 | *   | <span class='executed'>        } else if (collateralIds.length == 2) {</span>
  44 | *   | <span class='executed'>            fl.log(&quot;Two collateral IDs&quot;);</span>
  45 | *   | <span class='executed'>        } else if (collateralIds.length == 3) {</span>
  46 | *   | <span class='executed'>            fl.log(&quot;Three collateral IDs&quot;);</span>
  47 |     | <span class='neutral'>        } else {</span>
  48 |     | <span class='unexecuted'>            fl.log(&quot;More than three collateral IDs&quot;);</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'></span>
  51 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; collateralIds.length; i++) {</span>
  52 | *   | <span class='executed'>            if (collateralIds[i] == 0) {</span>
  53 | *   | <span class='executed'>                fl.log(&quot;Collateral ID 0 (SUSD) present&quot;);</span>
  54 | *   | <span class='executed'>            } else if (collateralIds[i] == 1) {</span>
  55 | *   | <span class='executed'>                fl.log(&quot;Collateral ID 1 (WETH) present&quot;);</span>
  56 | *   | <span class='executed'>            } else if (collateralIds[i] == 2) {</span>
  57 | *   | <span class='executed'>                fl.log(&quot;Collateral ID 2 (WBTC) present&quot;);</span>
  58 |     | <span class='neutral'>            } else {</span>
  59 |     | <span class='unexecuted'>                fl.log(&quot;Unknown collateral ID present&quot;);</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 | *   | <span class='executed'>    function _logCollateralAmountsCoverage(</span>
  65 |     | <span class='neutral'>        uint256 susdAmount,</span>
  66 |     | <span class='neutral'>        uint256 wethAmount,</span>
  67 |     | <span class='neutral'>        uint256 wbtcAmount,</span>
  68 |     | <span class='neutral'>        uint256 totalValue</span>
  69 |     | <span class='neutral'>    ) internal {</span>
  70 |     | <span class='neutral'>        // SUSD coverage</span>
  71 | *   | <span class='executed'>        if (susdAmount == 0) {</span>
  72 | *   | <span class='executed'>            fl.log(&quot;No SUSD collateral&quot;);</span>
  73 | *   | <span class='executed'>        } else if (susdAmount &gt; 0 &amp;&amp; susdAmount &lt;= 100e18) {</span>
  74 | *   | <span class='executed'>            fl.log(&quot;SUSD collateral between 0 and 100&quot;);</span>
  75 | *   | <span class='executed'>        } else if (susdAmount &gt; 100e18 &amp;&amp; susdAmount &lt;= 1000e18) {</span>
  76 | *   | <span class='executed'>            fl.log(&quot;SUSD collateral between 100 and 1,000&quot;);</span>
  77 | *   | <span class='executed'>        } else if (susdAmount &gt; 1000e18 &amp;&amp; susdAmount &lt;= 10000e18) {</span>
  78 | *   | <span class='executed'>            fl.log(&quot;SUSD collateral between 1,000 and 10,000&quot;);</span>
  79 |     | <span class='neutral'>        } else {</span>
  80 | *   | <span class='executed'>            fl.log(&quot;SUSD collateral greater than 10,000&quot;);</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // WETH coverage</span>
  84 | *   | <span class='executed'>        if (wethAmount == 0) {</span>
  85 | *   | <span class='executed'>            fl.log(&quot;No WETH collateral&quot;);</span>
  86 | *   | <span class='executed'>        } else if (wethAmount &gt; 0 &amp;&amp; wethAmount &lt;= 1e18) {</span>
  87 | *   | <span class='executed'>            fl.log(&quot;WETH collateral between 0 and 1&quot;);</span>
  88 | *   | <span class='executed'>        } else if (wethAmount &gt; 1e18 &amp;&amp; wethAmount &lt;= 10e18) {</span>
  89 | *   | <span class='executed'>            fl.log(&quot;WETH collateral between 1 and 10&quot;);</span>
  90 | *   | <span class='executed'>        } else if (wethAmount &gt; 10e18 &amp;&amp; wethAmount &lt;= 100e18) {</span>
  91 | *   | <span class='executed'>            fl.log(&quot;WETH collateral between 10 and 100&quot;);</span>
  92 |     | <span class='neutral'>        } else {</span>
  93 | *   | <span class='executed'>            fl.log(&quot;WETH collateral greater than 100&quot;);</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        // WBTC coverage (assuming 8 decimal places)</span>
  97 | *   | <span class='executed'>        if (wbtcAmount == 0) {</span>
  98 | *   | <span class='executed'>            fl.log(&quot;No WBTC collateral&quot;);</span>
  99 | *   | <span class='executed'>        } else if (wbtcAmount &gt; 0 &amp;&amp; wbtcAmount &lt;= 1e8) {</span>
 100 | *   | <span class='executed'>            fl.log(&quot;WBTC collateral between 0 and 1&quot;);</span>
 101 | *   | <span class='executed'>        } else if (wbtcAmount &gt; 1e8 &amp;&amp; wbtcAmount &lt;= 10e8) {</span>
 102 | *   | <span class='executed'>            fl.log(&quot;WBTC collateral between 1 and 10&quot;);</span>
 103 | *   | <span class='executed'>        } else if (wbtcAmount &gt; 10e8 &amp;&amp; wbtcAmount &lt;= 100e8) {</span>
 104 | *   | <span class='executed'>            fl.log(&quot;WBTC collateral between 10 and 100&quot;);</span>
 105 |     | <span class='neutral'>        } else {</span>
 106 | *   | <span class='executed'>            fl.log(&quot;WBTC collateral greater than 100&quot;);</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Total collateral value coverage</span>
 110 | *   | <span class='executed'>        if (totalValue == 0) {</span>
 111 | *   | <span class='executed'>            fl.log(&quot;Total collateral value is zero&quot;);</span>
 112 | *   | <span class='executed'>        } else if (totalValue &gt; 0 &amp;&amp; totalValue &lt;= 100e18) {</span>
 113 | *   | <span class='executed'>            fl.log(&quot;Total collateral value between 0 and 100 ETH&quot;);</span>
 114 | *   | <span class='executed'>        } else if (totalValue &gt; 100e18 &amp;&amp; totalValue &lt;= 1000e18) {</span>
 115 | *   | <span class='executed'>            fl.log(&quot;Total collateral value between 100 and 1,000 ETH&quot;);</span>
 116 | *   | <span class='executed'>        } else if (totalValue &gt; 1000e18 &amp;&amp; totalValue &lt;= 10000e18) {</span>
 117 | *   | <span class='executed'>            fl.log(&quot;Total collateral value between 1,000 and 10,000 ETH&quot;);</span>
 118 | *   | <span class='executed'>        } else if (totalValue &gt; 10000e18 &amp;&amp; totalValue &lt;= 100000e18) {</span>
 119 | *   | <span class='executed'>            fl.log(&quot;Total collateral value between 10,000 and 100,000 ETH&quot;);</span>
 120 |     | <span class='neutral'>        } else {</span>
 121 | *   | <span class='executed'>            fl.log(&quot;Total collateral value greater than 100,000 ETH&quot;);</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>        // Composition coverage</span>
 125 | *   | <span class='executed'>        if (susdAmount &gt; 0 &amp;&amp; wethAmount &gt; 0 &amp;&amp; wbtcAmount &gt; 0) {</span>
 126 | *   | <span class='executed'>            fl.log(&quot;All three collateral types present&quot;);</span>
 127 | *   | <span class='executed'>        } else if (susdAmount &gt; 0 &amp;&amp; wethAmount &gt; 0) {</span>
 128 | *   | <span class='executed'>            fl.log(&quot;SUSD and WETH collateral present&quot;);</span>
 129 | *   | <span class='executed'>        } else if (susdAmount &gt; 0 &amp;&amp; wbtcAmount &gt; 0) {</span>
 130 | *   | <span class='executed'>            fl.log(&quot;SUSD and WBTC collateral present&quot;);</span>
 131 | *   | <span class='executed'>        } else if (wethAmount &gt; 0 &amp;&amp; wbtcAmount &gt; 0) {</span>
 132 | *   | <span class='executed'>            fl.log(&quot;WETH and WBTC collateral present&quot;);</span>
 133 | *   | <span class='executed'>        } else if (susdAmount &gt; 0) {</span>
 134 | *   | <span class='executed'>            fl.log(&quot;Only SUSD collateral present&quot;);</span>
 135 | *   | <span class='executed'>        } else if (wethAmount &gt; 0) {</span>
 136 | *   | <span class='executed'>            fl.log(&quot;Only WETH collateral present&quot;);</span>
 137 | *   | <span class='executed'>        } else if (wbtcAmount &gt; 0) {</span>
 138 | *   | <span class='executed'>            fl.log(&quot;Only WBTC collateral present&quot;);</span>
 139 |     | <span class='neutral'>        } else {</span>
 140 | *   | <span class='executed'>            fl.log(&quot;No collateral present&quot;);</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // Dominant collateral type</span>
 144 | *   | <span class='executed'>        if (susdAmount &gt; wethAmount &amp;&amp; susdAmount &gt; wbtcAmount) {</span>
 145 | *   | <span class='executed'>            fl.log(&quot;SUSD is the dominant collateral type&quot;);</span>
 146 | *   | <span class='executed'>        } else if (wethAmount &gt; susdAmount &amp;&amp; wethAmount &gt; wbtcAmount) {</span>
 147 | *   | <span class='executed'>            fl.log(&quot;WETH is the dominant collateral type&quot;);</span>
 148 | *   | <span class='executed'>        } else if (wbtcAmount &gt; susdAmount &amp;&amp; wbtcAmount &gt; wethAmount) {</span>
 149 | *   | <span class='executed'>            fl.log(&quot;WBTC is the dominant collateral type&quot;);</span>
 150 |     | <span class='neutral'>        } else {</span>
 151 | *   | <span class='executed'>            fl.log(&quot;No single dominant collateral type&quot;);</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'>}</span>
 155 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/MarketCoverage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='unexecuted'>contract MarketCoverage is FuzzBase {</span>
   6 | *   | <span class='executed'>    function _logMarketInfoCoverage(</span>
   7 |     | <span class='neutral'>        uint256 wethLiquidationCapacity,</span>
   8 |     | <span class='neutral'>        uint256 wbtcLiquidationCapacity,</span>
   9 |     | <span class='neutral'>        uint256 wethMarketSize,</span>
  10 |     | <span class='neutral'>        uint256 wbtcMarketSize</span>
  11 |     | <span class='neutral'>    ) internal {</span>
  12 | *   | <span class='executed'>        _logWETHMarketCoverage(wethLiquidationCapacity, wethMarketSize);</span>
  13 |     | <span class='neutral'></span>
  14 | *   | <span class='executed'>        _logWBTCMarketCoverage(wbtcLiquidationCapacity, wbtcMarketSize);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>        // Combined Market Analysis</span>
  17 | *   | <span class='executed'>        _logCombinedMarketAnalysis(</span>
  18 | *   | <span class='executed'>            wethLiquidationCapacity,</span>
  19 | *   | <span class='executed'>            wbtcLiquidationCapacity,</span>
  20 | *   | <span class='executed'>            wethMarketSize,</span>
  21 | *   | <span class='executed'>            wbtcMarketSize</span>
  22 |     | <span class='neutral'>        );</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 | *   | <span class='executed'>    function _logWETHMarketCoverage(</span>
  26 |     | <span class='neutral'>        uint256 liquidationCapacity,</span>
  27 |     | <span class='neutral'>        uint256 marketSize</span>
  28 |     | <span class='neutral'>    ) internal {</span>
  29 |     | <span class='neutral'>        // Liquidation Capacity Coverage for WETH</span>
  30 | *   | <span class='executed'>        if (liquidationCapacity == 0) {</span>
  31 | *   | <span class='executed'>            fl.log(&quot;WETH market: No liquidation capacity&quot;);</span>
  32 | *   | <span class='executed'>        } else if (liquidationCapacity &lt;= 1e18) {</span>
  33 | *   | <span class='executed'>            fl.log(&quot;WETH market: Low liquidation capacity (0-1)&quot;);</span>
  34 | *   | <span class='executed'>        } else if (liquidationCapacity &lt;= 10e18) {</span>
  35 | *   | <span class='executed'>            fl.log(&quot;WETH market: Medium liquidation capacity (1-10)&quot;);</span>
  36 | *   | <span class='executed'>        } else if (liquidationCapacity &lt;= 100e18) {</span>
  37 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: High liquidation capacity (10-100)&quot;);</span>
  38 |     | <span class='neutral'>        } else {</span>
  39 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: Very high liquidation capacity (&gt;100)&quot;);</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // Market Size Coverage for WETH</span>
  43 | *   | <span class='executed'>        if (marketSize == 0) {</span>
  44 | *   | <span class='executed'>            fl.log(&quot;WETH market: Empty market&quot;);</span>
  45 | *   | <span class='executed'>        } else if (marketSize &lt;= 1000e18) {</span>
  46 | *   | <span class='executed'>            fl.log(&quot;WETH market: Small market size (0-1000)&quot;);</span>
  47 | *   | <span class='executed'>        } else if (marketSize &lt;= 10000e18) {</span>
  48 | *   | <span class='executed'>            fl.log(&quot;WETH market: Medium market size (1000-10000)&quot;);</span>
  49 | *   | <span class='executed'>        } else if (marketSize &lt;= 100000e18) {</span>
  50 | *   | <span class='executed'>            fl.log(&quot;WETH market: Large market size (10000-100000)&quot;);</span>
  51 |     | <span class='neutral'>        } else {</span>
  52 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: Very large market size (&gt;100000)&quot;);</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 | *   | <span class='executed'>    function _logWBTCMarketCoverage(</span>
  57 |     | <span class='neutral'>        uint256 liquidationCapacity,</span>
  58 |     | <span class='neutral'>        uint256 marketSize</span>
  59 |     | <span class='neutral'>    ) internal {</span>
  60 |     | <span class='neutral'>        // Liquidation Capacity Coverage for WBTC</span>
  61 | *   | <span class='executed'>        if (liquidationCapacity == 0) {</span>
  62 | *   | <span class='executed'>            fl.log(&quot;WBTC market: No liquidation capacity&quot;);</span>
  63 | *   | <span class='executed'>        } else if (liquidationCapacity &lt;= 1e18) {</span>
  64 | *   | <span class='executed'>            fl.log(&quot;WBTC market: Low liquidation capacity (0-1)&quot;);</span>
  65 | *   | <span class='executed'>        } else if (liquidationCapacity &lt;= 10e18) {</span>
  66 | *   | <span class='executed'>            fl.log(&quot;WBTC market: Medium liquidation capacity (1-10)&quot;);</span>
  67 | *   | <span class='executed'>        } else if (liquidationCapacity &lt;= 100e18) {</span>
  68 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: High liquidation capacity (10-100)&quot;);</span>
  69 |     | <span class='neutral'>        } else {</span>
  70 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: Very high liquidation capacity (&gt;100)&quot;);</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // Market Size Coverage for WBTC</span>
  74 | *   | <span class='executed'>        if (marketSize == 0) {</span>
  75 | *   | <span class='executed'>            fl.log(&quot;WBTC market: Empty market&quot;);</span>
  76 | *   | <span class='executed'>        } else if (marketSize &lt;= 1000e18) {</span>
  77 | *   | <span class='executed'>            fl.log(&quot;WBTC market: Small market size (0-1000)&quot;);</span>
  78 | *   | <span class='executed'>        } else if (marketSize &lt;= 10000e18) {</span>
  79 | *   | <span class='executed'>            fl.log(&quot;WBTC market: Medium market size (1000-10000)&quot;);</span>
  80 | *   | <span class='executed'>        } else if (marketSize &lt;= 100000e18) {</span>
  81 | *   | <span class='executed'>            fl.log(&quot;WBTC market: Large market size (10000-100000)&quot;);</span>
  82 |     | <span class='neutral'>        } else {</span>
  83 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: Very large market size (&gt;100000)&quot;);</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>    function _logCombinedMarketAnalysis(</span>
  88 |     | <span class='neutral'>        uint256 wethLiquidationCapacity,</span>
  89 |     | <span class='neutral'>        uint256 wbtcLiquidationCapacity,</span>
  90 |     | <span class='neutral'>        uint256 wethMarketSize,</span>
  91 |     | <span class='neutral'>        uint256 wbtcMarketSize</span>
  92 |     | <span class='neutral'>    ) internal {</span>
  93 |     | <span class='neutral'>        // Compare liquidation capacities</span>
  94 | *   | <span class='executed'>        if (wethLiquidationCapacity &gt; wbtcLiquidationCapacity) {</span>
  95 | *   | <span class='executed'>            fl.log(&quot;WETH market has higher liquidation capacity&quot;);</span>
  96 | *   | <span class='executed'>        } else if (wbtcLiquidationCapacity &gt; wethLiquidationCapacity) {</span>
  97 | *   | <span class='executed'>            fl.log(&quot;WBTC market has higher liquidation capacity&quot;);</span>
  98 |     | <span class='neutral'>        } else {</span>
  99 | *   | <span class='executed'>            fl.log(&quot;Both markets have equal liquidation capacity&quot;);</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        // Compare market sizes</span>
 103 | *   | <span class='executed'>        if (wethMarketSize &gt; wbtcMarketSize) {</span>
 104 | *   | <span class='executed'>            fl.log(&quot;WETH market is larger&quot;);</span>
 105 | *   | <span class='executed'>        } else if (wbtcMarketSize &gt; wethMarketSize) {</span>
 106 | *   | <span class='executed'>            fl.log(&quot;WBTC market is larger&quot;);</span>
 107 |     | <span class='neutral'>        } else {</span>
 108 | *   | <span class='executed'>            fl.log(&quot;Both markets are of equal size&quot;);</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>        // Analyze total market size</span>
 112 | *   | <span class='executed'>        uint256 totalMarketSize = uint256(wethMarketSize) +</span>
 113 | *   | <span class='executed'>            uint256(wbtcMarketSize);</span>
 114 | *   | <span class='executed'>        if (totalMarketSize == 0) {</span>
 115 | *   | <span class='executed'>            fl.log(&quot;Both markets are empty&quot;);</span>
 116 | *   | <span class='executed'>        } else if (totalMarketSize &lt;= 10000e18) {</span>
 117 | *   | <span class='executed'>            fl.log(&quot;Small total market size across both markets&quot;);</span>
 118 | *   | <span class='executed'>        } else if (totalMarketSize &lt;= 100000e18) {</span>
 119 | *   | <span class='executed'>            fl.log(&quot;Medium total market size across both markets&quot;);</span>
 120 |     | <span class='neutral'>        } else {</span>
 121 |     | <span class='unexecuted'>            fl.log(&quot;Large total market size across both markets&quot;);</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'>}</span>
 125 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/OrderCoverage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='unexecuted'>contract OrderCoverage is FuzzBase {</span>
   6 | *   | <span class='executed'>    function _logOrderInfoCoverage(</span>
   7 |     | <span class='neutral'>        uint128 debt,</span>
   8 |     | <span class='neutral'>        int128 sizeDelta,</span>
   9 |     | <span class='neutral'>        bool isOrderExpired,</span>
  10 |     | <span class='neutral'>        uint256 fillPriceWETH,</span>
  11 |     | <span class='neutral'>        uint256 fillPriceWBTC,</span>
  12 |     | <span class='neutral'>        uint256 sUSDBalance</span>
  13 |     | <span class='neutral'>    ) internal {</span>
  14 |     | <span class='neutral'>        // Debt coverage</span>
  15 | *   | <span class='executed'>        if (debt == 0) {</span>
  16 | *   | <span class='executed'>            fl.log(&quot;No debt&quot;);</span>
  17 | *   | <span class='executed'>        } else if (debt &gt; 0 &amp;&amp; debt &lt;= 100e18) {</span>
  18 | *   | <span class='executed'>            fl.log(&quot;Debt between 0 and 100&quot;);</span>
  19 | *   | <span class='executed'>        } else if (debt &gt; 100e18 &amp;&amp; debt &lt;= 1000e18) {</span>
  20 | *   | <span class='executed'>            fl.log(&quot;Debt between 100 and 1,000&quot;);</span>
  21 | *   | <span class='executed'>        } else if (debt &gt; 1000e18 &amp;&amp; debt &lt;= 10000e18) {</span>
  22 | *   | <span class='executed'>            fl.log(&quot;Debt between 1,000 and 10,000&quot;);</span>
  23 |     | <span class='neutral'>        } else {</span>
  24 | *   | <span class='executed'>            fl.log(&quot;Debt greater than 10,000&quot;);</span>
  25 |     | <span class='neutral'>        }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>        // Size delta coverage</span>
  28 | *   | <span class='executed'>        if (sizeDelta == 0) {</span>
  29 | *   | <span class='executed'>            fl.log(&quot;No size delta&quot;);</span>
  30 | *   | <span class='executed'>        } else if (sizeDelta &gt; 0) {</span>
  31 | *   | <span class='executed'>            if (sizeDelta &lt;= 1e18) {</span>
  32 | *   | <span class='executed'>                fl.log(&quot;Positive size delta between 0 and 1&quot;);</span>
  33 | *   | <span class='executed'>            } else if (sizeDelta &lt;= 10e18) {</span>
  34 | *   | <span class='executed'>                fl.log(&quot;Positive size delta between 1 and 10&quot;);</span>
  35 |     | <span class='neutral'>            } else {</span>
  36 | *   | <span class='executed'>                fl.log(&quot;Positive size delta greater than 10&quot;);</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='neutral'>        } else {</span>
  39 | *   | <span class='executed'>            if (sizeDelta &gt;= -1e18) {</span>
  40 | *   | <span class='executed'>                fl.log(&quot;Negative size delta between 0 and -1&quot;);</span>
  41 | *   | <span class='executed'>            } else if (sizeDelta &gt;= -10e18) {</span>
  42 | *   | <span class='executed'>                fl.log(&quot;Negative size delta between -1 and -10&quot;);</span>
  43 |     | <span class='neutral'>            } else {</span>
  44 | *   | <span class='executed'>                fl.log(&quot;Negative size delta less than -10&quot;);</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // Order expiration coverage</span>
  49 | *   | <span class='executed'>        if (isOrderExpired) {</span>
  50 | *   | <span class='executed'>            fl.log(&quot;Order is expired&quot;);</span>
  51 |     | <span class='neutral'>        } else {</span>
  52 | *   | <span class='executed'>            fl.log(&quot;Order is not expired&quot;);</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // Fill price WETH coverage</span>
  56 | *   | <span class='executed'>        if (fillPriceWETH == 0) {</span>
  57 | *   | <span class='executed'>            fl.log(&quot;No WETH fill price&quot;);</span>
  58 | *   | <span class='executed'>        } else if (fillPriceWETH &gt; 0 &amp;&amp; fillPriceWETH &lt;= 1000e18) {</span>
  59 | *   | <span class='executed'>            fl.log(&quot;WETH fill price between 0 and 1,000&quot;);</span>
  60 | *   | <span class='executed'>        } else if (fillPriceWETH &gt; 1000e18 &amp;&amp; fillPriceWETH &lt;= 2000e18) {</span>
  61 | *   | <span class='executed'>            fl.log(&quot;WETH fill price between 1,000 and 2,000&quot;);</span>
  62 |     | <span class='neutral'>        } else {</span>
  63 | *   | <span class='executed'>            fl.log(&quot;WETH fill price greater than 2,000&quot;);</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // Fill price WBTC coverage</span>
  67 | *   | <span class='executed'>        if (fillPriceWBTC == 0) {</span>
  68 | *   | <span class='executed'>            fl.log(&quot;No WBTC fill price&quot;);</span>
  69 | *   | <span class='executed'>        } else if (fillPriceWBTC &gt; 0 &amp;&amp; fillPriceWBTC &lt;= 10000e18) {</span>
  70 | *   | <span class='executed'>            fl.log(&quot;WBTC fill price between 0 and 10,000&quot;);</span>
  71 | *   | <span class='executed'>        } else if (fillPriceWBTC &gt; 10000e18 &amp;&amp; fillPriceWBTC &lt;= 20000e18) {</span>
  72 | *   | <span class='executed'>            fl.log(&quot;WBTC fill price between 10,000 and 20,000&quot;);</span>
  73 |     | <span class='neutral'>        } else {</span>
  74 | *   | <span class='executed'>            fl.log(&quot;WBTC fill price greater than 20,000&quot;);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // sUSD balance coverage</span>
  78 | *   | <span class='executed'>        if (sUSDBalance == 0) {</span>
  79 |     | <span class='unexecuted'>            fl.log(&quot;No sUSD balance&quot;);</span>
  80 | *   | <span class='executed'>        } else if (sUSDBalance &gt; 0 &amp;&amp; sUSDBalance &lt;= 100e18) {</span>
  81 |     | <span class='unexecuted'>            fl.log(&quot;sUSD balance between 0 and 100&quot;);</span>
  82 | *   | <span class='executed'>        } else if (sUSDBalance &gt; 100e18 &amp;&amp; sUSDBalance &lt;= 1000e18) {</span>
  83 |     | <span class='unexecuted'>            fl.log(&quot;sUSD balance between 100 and 1,000&quot;);</span>
  84 | *   | <span class='executed'>        } else if (sUSDBalance &gt; 1000e18 &amp;&amp; sUSDBalance &lt;= 10000e18) {</span>
  85 |     | <span class='unexecuted'>            fl.log(&quot;sUSD balance between 1,000 and 10,000&quot;);</span>
  86 |     | <span class='neutral'>        } else {</span>
  87 | *   | <span class='executed'>            fl.log(&quot;sUSD balance greater than 10,000&quot;);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // Order type coverage (based on sizeDelta and debt)</span>
  91 | *   | <span class='executed'>        if (sizeDelta &gt; 0 &amp;&amp; debt &gt; 0) {</span>
  92 | *   | <span class='executed'>            fl.log(&quot;Long position with debt&quot;);</span>
  93 | *   | <span class='executed'>        } else if (sizeDelta &gt; 0 &amp;&amp; debt == 0) {</span>
  94 | *   | <span class='executed'>            fl.log(&quot;Long position without debt&quot;);</span>
  95 | *   | <span class='executed'>        } else if (sizeDelta &lt; 0 &amp;&amp; debt &gt; 0) {</span>
  96 | *   | <span class='executed'>            fl.log(&quot;Short position with debt&quot;);</span>
  97 | *   | <span class='executed'>        } else if (sizeDelta &lt; 0 &amp;&amp; debt == 0) {</span>
  98 | *   | <span class='executed'>            fl.log(&quot;Short position without debt&quot;);</span>
  99 | *   | <span class='executed'>        } else if (sizeDelta == 0 &amp;&amp; debt &gt; 0) {</span>
 100 | *   | <span class='executed'>            fl.log(&quot;No position but has debt&quot;);</span>
 101 |     | <span class='neutral'>        } else {</span>
 102 | *   | <span class='executed'>            fl.log(&quot;No position and no debt&quot;);</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // Price comparison (if both prices are available)</span>
 106 | *   | <span class='executed'>        if (fillPriceWETH &gt; 0 &amp;&amp; fillPriceWBTC &gt; 0) {</span>
 107 | *   | <span class='executed'>            if (fillPriceWETH &gt; fillPriceWBTC) {</span>
 108 | *   | <span class='executed'>                fl.log(&quot;WETH fill price is higher than WBTC fill price&quot;);</span>
 109 | *   | <span class='executed'>            } else if (fillPriceWBTC &gt; fillPriceWETH) {</span>
 110 | *   | <span class='executed'>                fl.log(&quot;WBTC fill price is higher than WETH fill price&quot;);</span>
 111 |     | <span class='neutral'>            } else {</span>
 112 | *   | <span class='executed'>                fl.log(&quot;WETH and WBTC fill prices are equal&quot;);</span>
 113 |     | <span class='neutral'>            }</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/PositionCoverage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='unexecuted'>contract PositionCoverage is FuzzBase {</span>
   6 | *   | <span class='executed'>    function _logPositionInfoCoverage(</span>
   7 |     | <span class='neutral'>        int256 wethTotalPnl,</span>
   8 |     | <span class='neutral'>        int256 wethAccruedFunding,</span>
   9 |     | <span class='neutral'>        int128 wethPositionSize,</span>
  10 |     | <span class='neutral'>        uint256 wethOwedInterest,</span>
  11 |     | <span class='neutral'>        int256 wbtcTotalPnl,</span>
  12 |     | <span class='neutral'>        int256 wbtcAccruedFunding,</span>
  13 |     | <span class='neutral'>        int128 wbtcPositionSize,</span>
  14 |     | <span class='neutral'>        uint256 wbtcOwedInterest</span>
  15 |     | <span class='neutral'>    ) internal {</span>
  16 |     | <span class='neutral'>        // WETH market coverage</span>
  17 | *   | <span class='executed'>        _logWethMarketCoverage(</span>
  18 | *   | <span class='executed'>            wethTotalPnl,</span>
  19 | *   | <span class='executed'>            wethAccruedFunding,</span>
  20 | *   | <span class='executed'>            wethPositionSize,</span>
  21 | *   | <span class='executed'>            wethOwedInterest</span>
  22 |     | <span class='neutral'>        );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>        // WBTC market coverage</span>
  25 | *   | <span class='executed'>        _logWbtcMarketCoverage(</span>
  26 | *   | <span class='executed'>            wbtcTotalPnl,</span>
  27 | *   | <span class='executed'>            wbtcAccruedFunding,</span>
  28 | *   | <span class='executed'>            wbtcPositionSize,</span>
  29 | *   | <span class='executed'>            wbtcOwedInterest</span>
  30 |     | <span class='neutral'>        );</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // Combined market analysis</span>
  33 | *   | <span class='executed'>        _logCombinedMarketAnalysis(</span>
  34 | *   | <span class='executed'>            wethPositionSize,</span>
  35 | *   | <span class='executed'>            wbtcPositionSize,</span>
  36 | *   | <span class='executed'>            wethTotalPnl,</span>
  37 | *   | <span class='executed'>            wbtcTotalPnl,</span>
  38 | *   | <span class='executed'>            wethOwedInterest,</span>
  39 | *   | <span class='executed'>            wbtcOwedInterest</span>
  40 |     | <span class='neutral'>        );</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 | *   | <span class='executed'>    function _logWethMarketCoverage(</span>
  44 |     | <span class='neutral'>        int256 totalPnl,</span>
  45 |     | <span class='neutral'>        int256 accruedFunding,</span>
  46 |     | <span class='neutral'>        int128 positionSize,</span>
  47 |     | <span class='neutral'>        uint256 owedInterest</span>
  48 |     | <span class='neutral'>    ) internal {</span>
  49 |     | <span class='neutral'>        // WETH Position size coverage</span>
  50 | *   | <span class='executed'>        if (positionSize == 0) {</span>
  51 | *   | <span class='executed'>            fl.log(&quot;WETH market: No open position&quot;);</span>
  52 | *   | <span class='executed'>        } else if (positionSize &gt; 0) {</span>
  53 | *   | <span class='executed'>            if (positionSize &lt;= 0.1e18) {</span>
  54 | *   | <span class='executed'>                fl.log(&quot;WETH market: Long position between 0 and 0.1&quot;);</span>
  55 | *   | <span class='executed'>            } else if (positionSize &lt;= 1e18) {</span>
  56 |     | <span class='unexecuted'>                fl.log(&quot;WETH market: Long position between 0.1 and 1&quot;);</span>
  57 | *   | <span class='executed'>            } else if (positionSize &lt;= 10e18) {</span>
  58 | *   | <span class='executed'>                fl.log(&quot;WETH market: Long position between 1 and 10&quot;);</span>
  59 | *   | <span class='executed'>            } else if (positionSize &lt;= 100e18) {</span>
  60 | *   | <span class='executed'>                fl.log(&quot;WETH market: Long position between 10 and 100&quot;);</span>
  61 |     | <span class='neutral'>            } else {</span>
  62 | *   | <span class='executed'>                fl.log(&quot;WETH market: Long position greater than 100&quot;);</span>
  63 |     | <span class='neutral'>            }</span>
  64 |     | <span class='neutral'>        } else {</span>
  65 | *   | <span class='executed'>            if (positionSize &gt;= -0.1e18) {</span>
  66 | *   | <span class='executed'>                fl.log(&quot;WETH market: Short position between 0 and -0.1&quot;);</span>
  67 | *   | <span class='executed'>            } else if (positionSize &gt;= -1e18) {</span>
  68 | *   | <span class='executed'>                fl.log(&quot;WETH market: Short position between -0.1 and -1&quot;);</span>
  69 | *   | <span class='executed'>            } else if (positionSize &gt;= -10e18) {</span>
  70 | *   | <span class='executed'>                fl.log(&quot;WETH market: Short position between -1 and -10&quot;);</span>
  71 | *   | <span class='executed'>            } else if (positionSize &gt;= -100e18) {</span>
  72 |     | <span class='unexecuted'>                fl.log(&quot;WETH market: Short position between -10 and -100&quot;);</span>
  73 |     | <span class='neutral'>            } else {</span>
  74 | *   | <span class='executed'>                fl.log(&quot;WETH market: Short position less than -100&quot;);</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // WETH Total PnL coverage</span>
  79 | *   | <span class='executed'>        if (totalPnl == 0) {</span>
  80 | *   | <span class='executed'>            fl.log(&quot;WETH market: Zero PnL&quot;);</span>
  81 | *   | <span class='executed'>        } else if (totalPnl &gt; 0) {</span>
  82 | *   | <span class='executed'>            if (totalPnl &lt;= 0.1e18) {</span>
  83 | *   | <span class='executed'>                fl.log(&quot;WETH market: Profit between 0 and 0.1&quot;);</span>
  84 | *   | <span class='executed'>            } else if (totalPnl &lt;= 1e18) {</span>
  85 | *   | <span class='executed'>                fl.log(&quot;WETH market: Profit between 0.1 and 1&quot;);</span>
  86 | *   | <span class='executed'>            } else if (totalPnl &lt;= 10e18) {</span>
  87 | *   | <span class='executed'>                fl.log(&quot;WETH market: Profit between 1 and 10&quot;);</span>
  88 | *   | <span class='executed'>            } else if (totalPnl &lt;= 100e18) {</span>
  89 | *   | <span class='executed'>                fl.log(&quot;WETH market: Profit between 10 and 100&quot;);</span>
  90 |     | <span class='neutral'>            } else {</span>
  91 | *   | <span class='executed'>                fl.log(&quot;WETH market: Profit greater than 100&quot;);</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='neutral'>        } else {</span>
  94 | *   | <span class='executed'>            if (totalPnl &gt;= -0.1e18) {</span>
  95 | *   | <span class='executed'>                fl.log(&quot;WETH market: Loss between 0 and -0.1&quot;);</span>
  96 | *   | <span class='executed'>            } else if (totalPnl &gt;= -1e18) {</span>
  97 | *   | <span class='executed'>                fl.log(&quot;WETH market: Loss between -0.1 and -1&quot;);</span>
  98 | *   | <span class='executed'>            } else if (totalPnl &gt;= -10e18) {</span>
  99 | *   | <span class='executed'>                fl.log(&quot;WETH market: Loss between -1 and -10&quot;);</span>
 100 | *   | <span class='executed'>            } else if (totalPnl &gt;= -100e18) {</span>
 101 | *   | <span class='executed'>                fl.log(&quot;WETH market: Loss between -10 and -100&quot;);</span>
 102 |     | <span class='neutral'>            } else {</span>
 103 | *   | <span class='executed'>                fl.log(&quot;WETH market: Loss less than -100&quot;);</span>
 104 |     | <span class='neutral'>            }</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        // WETH Accrued funding coverage</span>
 108 | *   | <span class='executed'>        if (accruedFunding == 0) {</span>
 109 | *   | <span class='executed'>            fl.log(&quot;WETH market: No accrued funding&quot;);</span>
 110 |     | <span class='unexecuted'>        } else if (accruedFunding &gt; 0) {</span>
 111 |     | <span class='unexecuted'>            if (accruedFunding &lt;= 0.01e18) {</span>
 112 |     | <span class='unexecuted'>                fl.log(</span>
 113 |     | <span class='neutral'>                    &quot;WETH market: Positive accrued funding between 0 and 0.01&quot;</span>
 114 |     | <span class='neutral'>                );</span>
 115 |     | <span class='unexecuted'>            } else if (accruedFunding &lt;= 0.1e18) {</span>
 116 |     | <span class='unexecuted'>                fl.log(</span>
 117 |     | <span class='neutral'>                    &quot;WETH market: Positive accrued funding between 0.01 and 0.1&quot;</span>
 118 |     | <span class='neutral'>                );</span>
 119 |     | <span class='unexecuted'>            } else if (accruedFunding &lt;= 1e18) {</span>
 120 |     | <span class='unexecuted'>                fl.log(</span>
 121 |     | <span class='neutral'>                    &quot;WETH market: Positive accrued funding between 0.1 and 1&quot;</span>
 122 |     | <span class='neutral'>                );</span>
 123 |     | <span class='neutral'>            } else {</span>
 124 |     | <span class='unexecuted'>                fl.log(&quot;WETH market: Positive accrued funding greater than 1&quot;);</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='neutral'>        } else {</span>
 127 |     | <span class='unexecuted'>            if (accruedFunding &gt;= -0.01e18) {</span>
 128 |     | <span class='unexecuted'>                fl.log(</span>
 129 |     | <span class='neutral'>                    &quot;WETH market: Negative accrued funding between 0 and -0.01&quot;</span>
 130 |     | <span class='neutral'>                );</span>
 131 |     | <span class='unexecuted'>            } else if (accruedFunding &gt;= -0.1e18) {</span>
 132 |     | <span class='unexecuted'>                fl.log(</span>
 133 |     | <span class='neutral'>                    &quot;WETH market: Negative accrued funding between -0.01 and -0.1&quot;</span>
 134 |     | <span class='neutral'>                );</span>
 135 | *   | <span class='executed'>            } else if (accruedFunding &gt;= -1e18) {</span>
 136 |     | <span class='unexecuted'>                fl.log(</span>
 137 |     | <span class='neutral'>                    &quot;WETH market: Negative accrued funding between -0.1 and -1&quot;</span>
 138 |     | <span class='neutral'>                );</span>
 139 |     | <span class='neutral'>            } else {</span>
 140 |     | <span class='unexecuted'>                fl.log(&quot;WETH market: Negative accrued funding less than -1&quot;);</span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>        // WETH Owed interest coverage</span>
 145 | *   | <span class='executed'>        if (owedInterest == 0) {</span>
 146 | *   | <span class='executed'>            fl.log(&quot;WETH market: No owed interest&quot;);</span>
 147 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 0.01e18) {</span>
 148 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: Owed interest between 0 and 0.01&quot;);</span>
 149 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 0.1e18) {</span>
 150 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: Owed interest between 0.01 and 0.1&quot;);</span>
 151 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 1e18) {</span>
 152 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: Owed interest between 0.1 and 1&quot;);</span>
 153 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 10e18) {</span>
 154 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: Owed interest between 1 and 10&quot;);</span>
 155 |     | <span class='neutral'>        } else {</span>
 156 |     | <span class='unexecuted'>            fl.log(&quot;WETH market: Owed interest greater than 10&quot;);</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>    function _logWbtcMarketCoverage(</span>
 161 |     | <span class='neutral'>        int256 totalPnl,</span>
 162 |     | <span class='neutral'>        int256 accruedFunding,</span>
 163 |     | <span class='neutral'>        int128 positionSize,</span>
 164 |     | <span class='neutral'>        uint256 owedInterest</span>
 165 |     | <span class='neutral'>    ) internal {</span>
 166 |     | <span class='neutral'>        // WBTC Position size coverage</span>
 167 | *   | <span class='executed'>        if (positionSize == 0) {</span>
 168 | *   | <span class='executed'>            fl.log(&quot;WBTC market: No open position&quot;);</span>
 169 | *   | <span class='executed'>        } else if (positionSize &gt; 0) {</span>
 170 | *   | <span class='executed'>            if (positionSize &lt;= 0.01e8) {</span>
 171 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Long position between 0 and 0.01&quot;);</span>
 172 | *   | <span class='executed'>            } else if (positionSize &lt;= 0.1e8) {</span>
 173 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Long position between 0.01 and 0.1&quot;);</span>
 174 | *   | <span class='executed'>            } else if (positionSize &lt;= 1e8) {</span>
 175 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Long position between 0.1 and 1&quot;);</span>
 176 | *   | <span class='executed'>            } else if (positionSize &lt;= 10e8) {</span>
 177 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Long position between 1 and 10&quot;);</span>
 178 |     | <span class='neutral'>            } else {</span>
 179 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Long position greater than 10&quot;);</span>
 180 |     | <span class='neutral'>            }</span>
 181 |     | <span class='neutral'>        } else {</span>
 182 | *   | <span class='executed'>            if (positionSize &gt;= -0.01e8) {</span>
 183 |     | <span class='unexecuted'>                fl.log(&quot;WBTC market: Short position between 0 and -0.01&quot;);</span>
 184 | *   | <span class='executed'>            } else if (positionSize &gt;= -0.1e8) {</span>
 185 |     | <span class='unexecuted'>                fl.log(&quot;WBTC market: Short position between -0.01 and -0.1&quot;);</span>
 186 | *   | <span class='executed'>            } else if (positionSize &gt;= -1e8) {</span>
 187 |     | <span class='unexecuted'>                fl.log(&quot;WBTC market: Short position between -0.1 and -1&quot;);</span>
 188 | *   | <span class='executed'>            } else if (positionSize &gt;= -10e8) {</span>
 189 |     | <span class='unexecuted'>                fl.log(&quot;WBTC market: Short position between -1 and -10&quot;);</span>
 190 |     | <span class='neutral'>            } else {</span>
 191 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Short position less than -10&quot;);</span>
 192 |     | <span class='neutral'>            }</span>
 193 |     | <span class='neutral'>        }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        // WBTC Total PnL coverage</span>
 196 | *   | <span class='executed'>        if (totalPnl == 0) {</span>
 197 | *   | <span class='executed'>            fl.log(&quot;WBTC market: Zero PnL&quot;);</span>
 198 | *   | <span class='executed'>        } else if (totalPnl &gt; 0) {</span>
 199 | *   | <span class='executed'>            if (totalPnl &lt;= 0.01e8) {</span>
 200 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Profit between 0 and 0.01&quot;);</span>
 201 | *   | <span class='executed'>            } else if (totalPnl &lt;= 0.1e8) {</span>
 202 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Profit between 0.01 and 0.1&quot;);</span>
 203 | *   | <span class='executed'>            } else if (totalPnl &lt;= 1e8) {</span>
 204 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Profit between 0.1 and 1&quot;);</span>
 205 | *   | <span class='executed'>            } else if (totalPnl &lt;= 10e8) {</span>
 206 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Profit between 1 and 10&quot;);</span>
 207 |     | <span class='neutral'>            } else {</span>
 208 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Profit greater than 10&quot;);</span>
 209 |     | <span class='neutral'>            }</span>
 210 |     | <span class='neutral'>        } else {</span>
 211 | *   | <span class='executed'>            if (totalPnl &gt;= -0.01e8) {</span>
 212 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Loss between 0 and -0.01&quot;);</span>
 213 | *   | <span class='executed'>            } else if (totalPnl &gt;= -0.1e8) {</span>
 214 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Loss between -0.01 and -0.1&quot;);</span>
 215 | *   | <span class='executed'>            } else if (totalPnl &gt;= -1e8) {</span>
 216 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Loss between -0.1 and -1&quot;);</span>
 217 | *   | <span class='executed'>            } else if (totalPnl &gt;= -10e8) {</span>
 218 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Loss between -1 and -10&quot;);</span>
 219 |     | <span class='neutral'>            } else {</span>
 220 | *   | <span class='executed'>                fl.log(&quot;WBTC market: Loss less than -10&quot;);</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='neutral'>        }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // WBTC Accrued funding coverage</span>
 225 | *   | <span class='executed'>        if (accruedFunding == 0) {</span>
 226 | *   | <span class='executed'>            fl.log(&quot;WBTC market: No accrued funding&quot;);</span>
 227 |     | <span class='unexecuted'>        } else if (accruedFunding &gt; 0) {</span>
 228 |     | <span class='unexecuted'>            if (accruedFunding &lt;= 0.001e8) {</span>
 229 |     | <span class='unexecuted'>                fl.log(</span>
 230 |     | <span class='neutral'>                    &quot;WBTC market: Positive accrued funding between 0 and 0.001&quot;</span>
 231 |     | <span class='neutral'>                );</span>
 232 |     | <span class='unexecuted'>            } else if (accruedFunding &lt;= 0.01e8) {</span>
 233 |     | <span class='unexecuted'>                fl.log(</span>
 234 |     | <span class='neutral'>                    &quot;WBTC market: Positive accrued funding between 0.001 and 0.01&quot;</span>
 235 |     | <span class='neutral'>                );</span>
 236 |     | <span class='unexecuted'>            } else if (accruedFunding &lt;= 0.1e8) {</span>
 237 |     | <span class='unexecuted'>                fl.log(</span>
 238 |     | <span class='neutral'>                    &quot;WBTC market: Positive accrued funding between 0.01 and 0.1&quot;</span>
 239 |     | <span class='neutral'>                );</span>
 240 |     | <span class='neutral'>            } else {</span>
 241 |     | <span class='unexecuted'>                fl.log(</span>
 242 |     | <span class='neutral'>                    &quot;WBTC market: Positive accrued funding greater than 0.1&quot;</span>
 243 |     | <span class='neutral'>                );</span>
 244 |     | <span class='neutral'>            }</span>
 245 |     | <span class='neutral'>        } else {</span>
 246 |     | <span class='unexecuted'>            if (accruedFunding &gt;= -0.001e8) {</span>
 247 |     | <span class='unexecuted'>                fl.log(</span>
 248 |     | <span class='neutral'>                    &quot;WBTC market: Negative accrued funding between 0 and -0.001&quot;</span>
 249 |     | <span class='neutral'>                );</span>
 250 |     | <span class='unexecuted'>            } else if (accruedFunding &gt;= -0.01e8) {</span>
 251 |     | <span class='unexecuted'>                fl.log(</span>
 252 |     | <span class='neutral'>                    &quot;WBTC market: Negative accrued funding between -0.001 and -0.01&quot;</span>
 253 |     | <span class='neutral'>                );</span>
 254 | *   | <span class='executed'>            } else if (accruedFunding &gt;= -0.1e8) {</span>
 255 |     | <span class='unexecuted'>                fl.log(</span>
 256 |     | <span class='neutral'>                    &quot;WBTC market: Negative accrued funding between -0.01 and -0.1&quot;</span>
 257 |     | <span class='neutral'>                );</span>
 258 |     | <span class='neutral'>            } else {</span>
 259 |     | <span class='unexecuted'>                fl.log(&quot;WBTC market: Negative accrued funding less than -0.1&quot;);</span>
 260 |     | <span class='neutral'>            }</span>
 261 |     | <span class='neutral'>        }</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        // WBTC Owed interest coverage</span>
 264 | *   | <span class='executed'>        if (owedInterest == 0) {</span>
 265 | *   | <span class='executed'>            fl.log(&quot;WBTC market: No owed interest&quot;);</span>
 266 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 0.001e8) {</span>
 267 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: Owed interest between 0 and 0.001&quot;);</span>
 268 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 0.01e8) {</span>
 269 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: Owed interest between 0.001 and 0.01&quot;);</span>
 270 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 0.1e8) {</span>
 271 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: Owed interest between 0.01 and 0.1&quot;);</span>
 272 |     | <span class='unexecuted'>        } else if (owedInterest &lt;= 1e8) {</span>
 273 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: Owed interest between 0.1 and 1&quot;);</span>
 274 |     | <span class='neutral'>        } else {</span>
 275 |     | <span class='unexecuted'>            fl.log(&quot;WBTC market: Owed interest greater than 1&quot;);</span>
 276 |     | <span class='neutral'>        }</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 | *   | <span class='executed'>    function _logCombinedMarketAnalysis(</span>
 280 |     | <span class='neutral'>        int128 wethPositionSize,</span>
 281 |     | <span class='neutral'>        int128 wbtcPositionSize,</span>
 282 |     | <span class='neutral'>        int256 wethTotalPnl,</span>
 283 |     | <span class='neutral'>        int256 wbtcTotalPnl,</span>
 284 |     | <span class='neutral'>        uint256 wethOwedInterest,</span>
 285 |     | <span class='neutral'>        uint256 wbtcOwedInterest</span>
 286 |     | <span class='unexecuted'>    ) internal {</span>
 287 | *   | <span class='executed'>        if (wethPositionSize != 0 &amp;&amp; wbtcPositionSize != 0) {</span>
 288 | *   | <span class='executed'>            fl.log(&quot;Positions open in both WETH and WBTC markets&quot;);</span>
 289 | *   | <span class='executed'>            if (</span>
 290 | *   | <span class='executed'>                (wethPositionSize &gt; 0 &amp;&amp; wbtcPositionSize &gt; 0) ||</span>
 291 | *   | <span class='executed'>                (wethPositionSize &lt; 0 &amp;&amp; wbtcPositionSize &lt; 0)</span>
 292 |     | <span class='neutral'>            ) {</span>
 293 | *   | <span class='executed'>                fl.log(&quot;Both positions are in the same direction&quot;);</span>
 294 |     | <span class='neutral'>            } else {</span>
 295 | *   | <span class='executed'>                fl.log(&quot;Positions are in opposite directions&quot;);</span>
 296 |     | <span class='neutral'>            }</span>
 297 | *   | <span class='executed'>        } else if (wethPositionSize != 0) {</span>
 298 | *   | <span class='executed'>            fl.log(&quot;Position open only in WETH market&quot;);</span>
 299 | *   | <span class='executed'>        } else if (wbtcPositionSize != 0) {</span>
 300 | *   | <span class='executed'>            fl.log(&quot;Position open only in WBTC market&quot;);</span>
 301 |     | <span class='neutral'>        } else {</span>
 302 | *   | <span class='executed'>            fl.log(&quot;No open positions in either market&quot;);</span>
 303 |     | <span class='neutral'>        }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        // Total PnL analysis</span>
 306 | *   | <span class='executed'>        int256 totalPnl = wethTotalPnl + wbtcTotalPnl;</span>
 307 | *   | <span class='executed'>        if (totalPnl &gt; 0) {</span>
 308 | *   | <span class='executed'>            fl.log(&quot;Overall position is profitable&quot;);</span>
 309 | *   | <span class='executed'>            if (wethTotalPnl &gt; 0 &amp;&amp; wbtcTotalPnl &gt; 0) {</span>
 310 | *   | <span class='executed'>                fl.log(&quot;Both markets are profitable&quot;);</span>
 311 |     | <span class='neutral'>            } else {</span>
 312 | *   | <span class='executed'>                fl.log(&quot;One market is profitable, the other is at a loss&quot;);</span>
 313 |     | <span class='neutral'>            }</span>
 314 | *   | <span class='executed'>        } else if (totalPnl &lt; 0) {</span>
 315 | *   | <span class='executed'>            fl.log(&quot;Overall position is at a loss&quot;);</span>
 316 | *   | <span class='executed'>            if (wethTotalPnl &lt; 0 &amp;&amp; wbtcTotalPnl &lt; 0) {</span>
 317 | *   | <span class='executed'>                fl.log(&quot;Both markets are at a loss&quot;);</span>
 318 |     | <span class='neutral'>            } else {</span>
 319 | *   | <span class='executed'>                fl.log(&quot;One market is at a loss, the other is profitable&quot;);</span>
 320 |     | <span class='neutral'>            }</span>
 321 |     | <span class='neutral'>        } else {</span>
 322 | *   | <span class='executed'>            fl.log(&quot;Overall position has zero PnL&quot;);</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        // Total owed interest analysis</span>
 326 |     | <span class='neutral'>        // Total owed interest analysis</span>
 327 | *   | <span class='executed'>        uint256 totalOwedInterest = wethOwedInterest + wbtcOwedInterest;</span>
 328 | *   | <span class='executed'>        if (totalOwedInterest == 0) {</span>
 329 | *   | <span class='executed'>            fl.log(&quot;No owed interest in either market&quot;);</span>
 330 |     | <span class='neutral'>        } else {</span>
 331 |     | <span class='unexecuted'>            fl.log(&quot;Owed interest present&quot;);</span>
 332 |     | <span class='unexecuted'>            if (wethOwedInterest &gt; 0 &amp;&amp; wbtcOwedInterest &gt; 0) {</span>
 333 |     | <span class='unexecuted'>                fl.log(&quot;Both markets have owed interest&quot;);</span>
 334 |     | <span class='unexecuted'>            } else if (wethOwedInterest &gt; 0) {</span>
 335 |     | <span class='unexecuted'>                fl.log(&quot;Only WETH market has owed interest&quot;);</span>
 336 |     | <span class='neutral'>            } else {</span>
 337 |     | <span class='unexecuted'>                fl.log(&quot;Only WBTC market has owed interest&quot;);</span>
 338 |     | <span class='neutral'>            }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>            if (totalOwedInterest &lt;= 0.01e18) {</span>
 341 |     | <span class='unexecuted'>                fl.log(&quot;Total owed interest between 0 and 0.01&quot;);</span>
 342 |     | <span class='unexecuted'>            } else if (totalOwedInterest &lt;= 0.1e18) {</span>
 343 |     | <span class='unexecuted'>                fl.log(&quot;Total owed interest between 0.01 and 0.1&quot;);</span>
 344 |     | <span class='unexecuted'>            } else if (totalOwedInterest &lt;= 1e18) {</span>
 345 |     | <span class='unexecuted'>                fl.log(&quot;Total owed interest between 0.1 and 1&quot;);</span>
 346 |     | <span class='unexecuted'>            } else if (totalOwedInterest &lt;= 10e18) {</span>
 347 |     | <span class='unexecuted'>                fl.log(&quot;Total owed interest between 1 and 10&quot;);</span>
 348 |     | <span class='neutral'>            } else {</span>
 349 |     | <span class='unexecuted'>                fl.log(&quot;Total owed interest greater than 10&quot;);</span>
 350 |     | <span class='neutral'>            }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='unexecuted'>            if (wethOwedInterest &gt; wbtcOwedInterest) {</span>
 353 |     | <span class='unexecuted'>                fl.log(&quot;WETH market has higher owed interest&quot;);</span>
 354 | *   | <span class='executed'>            } else if (wbtcOwedInterest &gt; wethOwedInterest) {</span>
 355 |     | <span class='unexecuted'>                fl.log(&quot;WBTC market has higher owed interest&quot;);</span>
 356 |     | <span class='neutral'>            } else {</span>
 357 |     | <span class='unexecuted'>                fl.log(&quot;Both markets have equal owed interest&quot;);</span>
 358 |     | <span class='neutral'>            }</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>        // Position size comparison</span>
 362 | *   | <span class='executed'>        if (wethPositionSize != 0 &amp;&amp; wbtcPositionSize != 0) {</span>
 363 | *   | <span class='executed'>            if (abs(wethPositionSize) &gt; abs(wbtcPositionSize)) {</span>
 364 | *   | <span class='executed'>                fl.log(&quot;WETH position size is larger&quot;);</span>
 365 | *   | <span class='executed'>            } else if (abs(wbtcPositionSize) &gt; abs(wethPositionSize)) {</span>
 366 | *   | <span class='executed'>                fl.log(&quot;WBTC position size is larger&quot;);</span>
 367 |     | <span class='neutral'>            } else {</span>
 368 | *   | <span class='executed'>                fl.log(&quot;Both positions have equal size&quot;);</span>
 369 |     | <span class='neutral'>            }</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>        // PnL comparison</span>
 373 | *   | <span class='executed'>        if (wethTotalPnl != 0 || wbtcTotalPnl != 0) {</span>
 374 | *   | <span class='executed'>            if (wethTotalPnl &gt; wbtcTotalPnl) {</span>
 375 | *   | <span class='executed'>                fl.log(&quot;WETH market has higher PnL&quot;);</span>
 376 | *   | <span class='executed'>            } else if (wbtcTotalPnl &gt; wethTotalPnl) {</span>
 377 | *   | <span class='executed'>                fl.log(&quot;WBTC market has higher PnL&quot;);</span>
 378 |     | <span class='neutral'>            } else {</span>
 379 |     | <span class='unexecuted'>                fl.log(&quot;Both markets have equal PnL&quot;);</span>
 380 |     | <span class='neutral'>            }</span>
 381 |     | <span class='neutral'>        }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>        // Overall market status</span>
 384 | *   | <span class='executed'>        if (</span>
 385 | *   | <span class='executed'>            wethPositionSize == 0 &amp;&amp;</span>
 386 | *   | <span class='executed'>            wbtcPositionSize == 0 &amp;&amp;</span>
 387 | *   | <span class='executed'>            totalOwedInterest == 0</span>
 388 |     | <span class='neutral'>        ) {</span>
 389 | *   | <span class='executed'>            fl.log(&quot;No active positions or owed interest in either market&quot;);</span>
 390 | *   | <span class='executed'>        } else if (wethPositionSize != 0 || wbtcPositionSize != 0) {</span>
 391 | *   | <span class='executed'>            if (totalPnl &gt; 0 &amp;&amp; totalOwedInterest == 0) {</span>
 392 | *   | <span class='executed'>                fl.log(&quot;Profitable position(s) with no owed interest&quot;);</span>
 393 | *   | <span class='executed'>            } else if (totalPnl &gt; 0 &amp;&amp; totalOwedInterest &gt; 0) {</span>
 394 |     | <span class='unexecuted'>                fl.log(&quot;Profitable position(s) with owed interest&quot;);</span>
 395 | *   | <span class='executed'>            } else if (totalPnl &lt; 0 &amp;&amp; totalOwedInterest == 0) {</span>
 396 | *   | <span class='executed'>                fl.log(&quot;Loss-making position(s) with no owed interest&quot;);</span>
 397 | *   | <span class='executed'>            } else if (totalPnl &lt; 0 &amp;&amp; totalOwedInterest &gt; 0) {</span>
 398 |     | <span class='unexecuted'>                fl.log(&quot;Loss-making position(s) with owed interest&quot;);</span>
 399 | *   | <span class='executed'>            } else if (totalPnl == 0 &amp;&amp; totalOwedInterest &gt; 0) {</span>
 400 |     | <span class='unexecuted'>                fl.log(&quot;Neutral position(s) with owed interest&quot;);</span>
 401 |     | <span class='neutral'>            } else {</span>
 402 | *   | <span class='executed'>                fl.log(&quot;Neutral position(s) with no owed interest&quot;);</span>
 403 |     | <span class='neutral'>            }</span>
 404 |     | <span class='neutral'>        } else {</span>
 405 |     | <span class='unexecuted'>            fl.log(&quot;No active positions but owed interest present&quot;);</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    // Helper function to get absolute value of int128</span>
 410 | *   | <span class='executed'>    function abs(int128 x) private pure returns (int128) {</span>
 411 | *   | <span class='executed'>        return x &gt;= 0 ? x : -x;</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'>}</span>
 414 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsAdmin.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PostconditionsBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract PostconditionsAdmin is PostconditionsBase {</span>
  7 |     | <span class='neutral'>    /// NOTE: changes chainlink price to correspond to pyth price</span>
  8 | *   | <span class='executed'>    function changePythPricePostconditions(</span>
  9 |     | <span class='neutral'>        bytes32 nodeId,</span>
 10 |     | <span class='neutral'>        int256 newPrice</span>
 11 | *   | <span class='executed'>    ) internal {</span>
 12 | *   | <span class='executed'>        int256 newPriceWithPrecision = int256(newPrice); //TODO: recheck //* 1e10; // account for 1e18 precision in chainlink oracle</span>
 13 | *   | <span class='executed'>        bytes32 chainlinkNodeId = oracleNodes[nodeId];</span>
 14 |     | <span class='neutral'></span>
 15 | *   | <span class='executed'>        bool isIncrease = newPrice % 2 == 0;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        // only change the chainlink oracle price for index tokens</span>
 18 | *   | <span class='executed'>        if (chainlinkNodeId != bytes32(0)) {</span>
 19 | *   | <span class='executed'>            int256 newPriceWithVariance;</span>
 20 | *   | <span class='executed'>            int256 priceDivergenceBps = fl.clamp(</span>
 21 |     | <span class='neutral'>                newPrice,</span>
 22 |     | <span class='neutral'>                0,</span>
 23 |     | <span class='neutral'>                PRICE_DIVERGENCE_BPS_256</span>
 24 |     | <span class='neutral'>            );</span>
 25 | *   | <span class='executed'>            if (isIncrease) {</span>
 26 | *   | <span class='executed'>                newPriceWithVariance =</span>
 27 | *   | <span class='executed'>                    (newPrice * (priceDivergenceBps + INT_ONE_HUNDRED_BP)) /</span>
 28 |     | <span class='neutral'>                    INT_ONE_HUNDRED_BP;</span>
 29 |     | <span class='neutral'>            } else {</span>
 30 | *   | <span class='executed'>                newPriceWithVariance =</span>
 31 | *   | <span class='executed'>                    (newPrice * (INT_ONE_HUNDRED_BP - priceDivergenceBps)) /</span>
 32 |     | <span class='neutral'>                    INT_ONE_HUNDRED_BP;</span>
 33 |     | <span class='neutral'>            }</span>
 34 | *   | <span class='executed'>            mockOracleManager.changePrice(</span>
 35 |     | <span class='neutral'>                chainlinkNodeId,</span>
 36 |     | <span class='neutral'>                newPriceWithVariance</span>
 37 |     | <span class='neutral'>            );</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice changes pyth price to correspond to chainlink price</span>
 42 | *   | <span class='executed'>    function changeOracleManagerPricePostconditions(</span>
 43 |     | <span class='neutral'>        bytes32 nodeId,</span>
 44 |     | <span class='neutral'>        int256 newPrice</span>
 45 | *   | <span class='executed'>    ) internal {</span>
 46 | *   | <span class='executed'>        bytes32 pythNodeId = oracleNodes[nodeId];</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>        bool isIncrease = newPrice % 2 == 0;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>        // only change the pyth oracle price for index tokens</span>
 51 | *   | <span class='executed'>        if (pythNodeId != bytes32(0)) {</span>
 52 | *   | <span class='executed'>            int256 newPriceWithVariance;</span>
 53 | *   | <span class='executed'>            int256 priceDivergenceBps = fl.clamp(</span>
 54 |     | <span class='neutral'>                newPrice,</span>
 55 |     | <span class='neutral'>                0,</span>
 56 |     | <span class='neutral'>                PRICE_DIVERGENCE_BPS_256</span>
 57 |     | <span class='neutral'>            );</span>
 58 | *   | <span class='executed'>            if (isIncrease) {</span>
 59 | *   | <span class='executed'>                newPriceWithVariance =</span>
 60 | *   | <span class='executed'>                    (newPrice * (priceDivergenceBps + INT_ONE_HUNDRED_BP)) /</span>
 61 |     | <span class='neutral'>                    INT_ONE_HUNDRED_BP;</span>
 62 |     | <span class='neutral'>            } else {</span>
 63 | *   | <span class='executed'>                newPriceWithVariance =</span>
 64 | *   | <span class='executed'>                    (newPrice * (INT_ONE_HUNDRED_BP - priceDivergenceBps)) /</span>
 65 |     | <span class='neutral'>                    INT_ONE_HUNDRED_BP;</span>
 66 |     | <span class='neutral'>            }</span>
 67 | *   | <span class='executed'>            mockPyth.changePrice(pythNodeId, int64(newPriceWithVariance));</span>
 68 | *   | <span class='executed'>            pythWrapper.setBenchmarkPrice(pythNodeId, newPriceWithVariance);</span>
 69 |     | <span class='neutral'>        }</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'>}</span>
 72 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../properties/Properties.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract PostconditionsBase is Properties {</span>
  7 | *   | <span class='executed'>    function onSuccessInvariantsGeneral(</span>
  8 |     | <span class='neutral'>        bytes memory returnData,</span>
  9 |     | <span class='neutral'>        uint128 account</span>
 10 |     | <span class='neutral'>    ) internal {</span>
 11 | *   | <span class='executed'>        fl.log(&quot;&gt;&gt;ACCOUNT FOR onSuccessInvariantsGeneral&quot;, account);</span>
 12 | *   | <span class='executed'>        invariant_LIQ_01(account);</span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>        invariant_MGN_08();</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>        // @audit Fails with payDebt.</span>
 17 |     | <span class='neutral'>        // invariant_ORD_20();</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>        invariant_LIQ_18(account);</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>        zeroOutMemory();</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function onFailInvariantsGeneral(bytes memory returnData) internal {}</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsLiquidationModule.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PostconditionsBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract PostconditionsLiquidationModule is PostconditionsBase {</span>
   7 | *   | <span class='executed'>    function liquidatePositionPostconditions(</span>
   8 |     | <span class='neutral'>        bool success,</span>
   9 |     | <span class='neutral'>        bytes memory returnData,</span>
  10 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  11 |     | <span class='neutral'>        address flaggedUser,</span>
  12 |     | <span class='neutral'>        address liquidator,</span>
  13 |     | <span class='neutral'>        uint128 accountIds</span>
  14 |     | <span class='neutral'>    ) internal {</span>
  15 | *   | <span class='executed'>        if (success) {</span>
  16 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
  17 |     | <span class='neutral'></span>
  18 | *   | <span class='executed'>            invariant_LIQ_03();</span>
  19 |     | <span class='neutral'>            // @audit-ok This assertion is supposed to fail to show a user can be liquidated in such a scenario.</span>
  20 |     | <span class='neutral'>            // invariant_LIQ_08();</span>
  21 | *   | <span class='executed'>            invariant_LIQ_09(accountIds);</span>
  22 | *   | <span class='executed'>            invariant_LIQ_11(accountIds);</span>
  23 | *   | <span class='executed'>            invariant_LIQ_16();</span>
  24 | *   | <span class='executed'>            invariant_LIQ_17(accountIds);</span>
  25 | *   | <span class='executed'>            invariant_MGN_16();</span>
  26 | *   | <span class='executed'>            invariant_LIQ_19(</span>
  27 | *   | <span class='executed'>                _incrementAndCheckLiquidationCalls(actorsToUpdate[0]),</span>
  28 | *   | <span class='executed'>                actorsToUpdate[0]</span>
  29 |     | <span class='neutral'>            ); //liquidator</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>            onSuccessInvariantsGeneral(returnData, accountIds);</span>
  32 |     | <span class='neutral'>        } else {</span>
  33 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>    function liquidateMarginOnlyPostconditions(</span>
  38 |     | <span class='neutral'>        bool success,</span>
  39 |     | <span class='neutral'>        bytes memory returnData,</span>
  40 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  41 |     | <span class='neutral'>        address flaggedUser,</span>
  42 |     | <span class='neutral'>        uint128 accountId</span>
  43 |     | <span class='neutral'>    ) internal {</span>
  44 | *   | <span class='executed'>        if (success) {</span>
  45 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
  46 | *   | <span class='executed'>            _checkLCov(true);</span>
  47 |     | <span class='neutral'></span>
  48 | *   | <span class='executed'>            invariant_MGN_16();</span>
  49 | *   | <span class='executed'>            onSuccessInvariantsGeneral(returnData, accountId);</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 | *   | <span class='executed'>    function liquidateFlaggedPostconditions(</span>
  56 |     | <span class='neutral'>        bool success,</span>
  57 |     | <span class='neutral'>        bytes memory returnData,</span>
  58 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  59 |     | <span class='neutral'>        uint[] memory flaggedAccounts</span>
  60 |     | <span class='neutral'>    ) internal {</span>
  61 | *   | <span class='executed'>        if (success) {</span>
  62 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
  63 | *   | <span class='executed'>            for (uint i = 0; i &lt; flaggedAccounts.length; i++) {</span>
  64 | *   | <span class='executed'>                invariant_MGN_16();</span>
  65 | *   | <span class='executed'>                onSuccessInvariantsGeneral(</span>
  66 | *   | <span class='executed'>                    returnData,</span>
  67 | *   | <span class='executed'>                    uint128(flaggedAccounts[i])</span>
  68 |     | <span class='neutral'>                );</span>
  69 |     | <span class='neutral'>            }</span>
  70 |     | <span class='neutral'>        } else {</span>
  71 | *   | <span class='executed'>            onFailInvariantsGeneral(returnData);</span>
  72 |     | <span class='neutral'>        }</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>    function luquidateFlaggedAccountsPostconditions(</span>
  76 |     | <span class='neutral'>        bool success,</span>
  77 |     | <span class='neutral'>        bytes memory returnData,</span>
  78 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
  79 |     | <span class='neutral'>        uint[] memory flaggedAccounts</span>
  80 |     | <span class='neutral'>    ) internal {</span>
  81 | *   | <span class='executed'>        if (success) {</span>
  82 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
  83 | *   | <span class='executed'>            for (uint i = 0; i &lt; flaggedAccounts.length; i++) {</span>
  84 |     | <span class='neutral'>                //@audit currently fails</span>
  85 | *   | <span class='executed'>                invariant_MGN_16();</span>
  86 | *   | <span class='executed'>                onSuccessInvariantsGeneral(</span>
  87 | *   | <span class='executed'>                    returnData,</span>
  88 | *   | <span class='executed'>                    uint128(flaggedAccounts[i])</span>
  89 |     | <span class='neutral'>                );</span>
  90 |     | <span class='neutral'>            }</span>
  91 |     | <span class='neutral'>        } else {</span>
  92 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>    function liquidatePositionPostconditionsAndICheckAfterPriceMove(</span>
  97 |     | <span class='neutral'>        bool success,</span>
  98 |     | <span class='neutral'>        bytes memory returnData,</span>
  99 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 100 |     | <span class='neutral'>        address flaggedUser,</span>
 101 |     | <span class='neutral'>        address liquidator,</span>
 102 |     | <span class='neutral'>        uint128 accountIds</span>
 103 |     | <span class='neutral'>    ) internal {</span>
 104 | *   | <span class='executed'>        if (success) {</span>
 105 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>            onSuccessInvariantsGeneral(returnData, accountIds);</span>
 108 |     | <span class='neutral'>        } else {</span>
 109 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'>}</span>
 113 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsOrderModule.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PostconditionsBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract PostconditionsOrderModule is PostconditionsBase {</span>
  7 | *   | <span class='executed'>    function commitOrderPostconditions(</span>
  8 |     | <span class='neutral'>        bool success,</span>
  9 |     | <span class='neutral'>        bytes memory returnData,</span>
 10 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 11 |     | <span class='neutral'>        uint128 accountId,</span>
 12 |     | <span class='neutral'>        uint128 commitOrderPostconditions</span>
 13 |     | <span class='neutral'>    ) internal {</span>
 14 | *   | <span class='executed'>        if (success) {</span>
 15 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
 16 | *   | <span class='executed'>            invariant_ORD_01(accountId);</span>
 17 | *   | <span class='executed'>            invariant_ORD_15(accountId);</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>            onSuccessInvariantsGeneral(returnData, accountId);</span>
 20 |     | <span class='neutral'>        } else {</span>
 21 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 22 |     | <span class='neutral'>        }</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    //TODO: after settle</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function settleOrderPostconditions(</span>
 28 |     | <span class='neutral'>        bool success,</span>
 29 |     | <span class='neutral'>        bytes memory returnData,</span>
 30 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 31 |     | <span class='neutral'>        address settleUser,</span>
 32 |     | <span class='neutral'>        uint128 accountId,</span>
 33 |     | <span class='neutral'>        uint128 marketId</span>
 34 |     | <span class='neutral'>    ) internal {</span>
 35 | *   | <span class='executed'>        if (success) {</span>
 36 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
 37 | *   | <span class='executed'>            _afterSettlement(accountId, marketId);</span>
 38 |     | <span class='neutral'></span>
 39 | *   | <span class='executed'>            invariant_ORD_02(accountId);</span>
 40 | *   | <span class='executed'>            invariant_ORD_03(accountId);</span>
 41 |     | <span class='neutral'>            // TODO: This assertion was failing due to Foundry using default sender. Default sender 0x18 did not have an account, so balance was always 0.</span>
 42 |     | <span class='neutral'>            // modifier setCurrentActor was modified, but should be given another look to prevent Foundry override.</span>
 43 |     | <span class='neutral'>            // fl.log(&quot;CURRENT ACTOR ACCOUNT ID SETTLE:&quot;, userToAccountIds[currentActor]);</span>
 44 |     | <span class='neutral'>            // fl.log(&quot;CURRENT ACTOR SETTLE:&quot;, currentActor);</span>
 45 | *   | <span class='executed'>            invariant_ORD_04(userToAccountIds[currentActor]);</span>
 46 |     | <span class='neutral'>            // @audit ORD-06 assertion fails. Looks like a valid break.</span>
 47 |     | <span class='neutral'>            // invariant_ORD_06(accountId, marketId);</span>
 48 |     | <span class='neutral'>            // @audit ORD-07 assertion fails. Looks like a valid break.</span>
 49 |     | <span class='neutral'>            // invariant_ORD_07();</span>
 50 | *   | <span class='executed'>            invariant_ORD_08(accountId);</span>
 51 |     | <span class='neutral'>            // TODO: Properly handle markets for this invariant. BeforeAfter changes required.</span>
 52 | *   | <span class='executed'>            invariant_ORD_09(accountId, marketId);</span>
 53 | *   | <span class='executed'>            invariant_ORD_12(accountId);</span>
 54 |     | <span class='neutral'>            // @audit Invalid assertion formulation.</span>
 55 | *   | <span class='executed'>            invariant_ORD_18(accountId, marketId);</span>
 56 | *   | <span class='executed'>            invariant_ORD_19(accountId);</span>
 57 | *   | <span class='executed'>            fl.log(&quot;4&quot;);</span>
 58 | *   | <span class='executed'>            invariant_ORD_22(accountId);</span>
 59 | *   | <span class='executed'>            invariant_MGN_16();</span>
 60 | *   | <span class='executed'>            onSuccessInvariantsGeneral(returnData, accountId);</span>
 61 |     | <span class='neutral'>        } else {</span>
 62 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 63 |     | <span class='neutral'>        }</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 | *   | <span class='executed'>    function cancelOrderPostconditions(</span>
 67 |     | <span class='neutral'>        bool success,</span>
 68 |     | <span class='neutral'>        bytes memory returnData,</span>
 69 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 70 |     | <span class='neutral'>        address cancelUser,</span>
 71 |     | <span class='neutral'>        uint128 accountId</span>
 72 |     | <span class='neutral'>    ) internal {</span>
 73 | *   | <span class='executed'>        if (success) {</span>
 74 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
 75 | *   | <span class='executed'>            if (cancelUser != currentActor) {</span>
 76 |     | <span class='neutral'>                // @audit This assertion fails.</span>
 77 | *   | <span class='executed'>                invariant_ORD_05(userToAccountIds[currentActor]);</span>
 78 |     | <span class='neutral'>            }</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>            // @audit ORD-16 assertion fails. Looks like valid break.</span>
 81 |     | <span class='neutral'>            // invariant_ORD_16(userToAccountIds[cancelUser]);</span>
 82 |     | <span class='unexecuted'>            onSuccessInvariantsGeneral(returnData, accountId);</span>
 83 |     | <span class='neutral'>        } else {</span>
 84 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 85 |     | <span class='neutral'>        }</span>
 86 |     | <span class='neutral'>    }</span>
 87 |     | <span class='neutral'>}</span>
 88 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsPerpsAccountModule.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PostconditionsBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract PostconditionsPerpsAccountModule is PostconditionsBase {</span>
  7 |     | <span class='neutral'>    event DebugPost(string s);</span>
  8 | *   | <span class='executed'>    function modifyCollateralPostconditions(</span>
  9 |     | <span class='neutral'>        int256 amountDelta,</span>
 10 |     | <span class='neutral'>        bool success,</span>
 11 |     | <span class='neutral'>        bytes memory returnData,</span>
 12 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 13 |     | <span class='neutral'>        address collateral,</span>
 14 |     | <span class='neutral'>        uint128 accountId</span>
 15 | *   | <span class='executed'>    ) internal {</span>
 16 | *   | <span class='executed'>        uint collateralId = collateral == address(wethTokenMock)</span>
 17 | *   | <span class='executed'>            ? 1</span>
 18 | *   | <span class='executed'>            : collateral == address(wbtcTokenMock)</span>
 19 | *   | <span class='executed'>                ? 2</span>
 20 | *   | <span class='executed'>                : 0; //SUSD</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>        if (success) {</span>
 23 | *   | <span class='executed'>            emit DebugPost(&quot;modifyCollateralPostconditions HERE#1&quot;);</span>
 24 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
 25 | *   | <span class='executed'>            emit DebugPost(&quot;modifyCollateralPostconditions HERE#2&quot;);</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>            if (amountDelta &lt; 0) {</span>
 28 | *   | <span class='executed'>                invariant_MGN_01(accountId);</span>
 29 | *   | <span class='executed'>                invariant_MGN_12(accountId, collateralId);</span>
 30 | *   | <span class='executed'>                invariant_MGN_13(amountDelta, collateral);</span>
 31 |     | <span class='neutral'>            }</span>
 32 | *   | <span class='executed'>            emit DebugPost(&quot;modifyCollateralPostconditions HERE#3&quot;);</span>
 33 | *   | <span class='executed'>            invariant_MGN_03(accountId);</span>
 34 | *   | <span class='executed'>            invariant_MGN_04(accountId);</span>
 35 | *   | <span class='executed'>            invariant_MGN_05(amountDelta, collateral);</span>
 36 | *   | <span class='executed'>            invariant_MGN_06(amountDelta, collateral);</span>
 37 | *   | <span class='executed'>            invariant_MGN_13(amountDelta, collateral);</span>
 38 |     | <span class='neutral'>            // @audit Fails.</span>
 39 | *   | <span class='executed'>            invariant_MGN_14(accountId);</span>
 40 | *   | <span class='executed'>            invariant_MGN_16();</span>
 41 | *   | <span class='executed'>            emit DebugPost(&quot;modifyCollateralPostconditions HERE#MGN_13&quot;);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>            // invariant_MGN_07();</span>
 44 |     | <span class='neutral'></span>
 45 | *   | <span class='executed'>            onSuccessInvariantsGeneral(returnData, accountId);</span>
 46 | *   | <span class='executed'>            emit DebugPost(&quot;modifyCollateralPostconditions HERE#4&quot;);</span>
 47 |     | <span class='neutral'>        } else {</span>
 48 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 | *   | <span class='executed'>    function payDebtPostconditions(</span>
 53 |     | <span class='neutral'>        bool success,</span>
 54 |     | <span class='neutral'>        bytes memory returnData,</span>
 55 |     | <span class='neutral'>        address[] memory actorsToUpdate,</span>
 56 |     | <span class='neutral'>        uint128 accountId</span>
 57 |     | <span class='neutral'>    ) internal {</span>
 58 | *   | <span class='executed'>        if (success) {</span>
 59 | *   | <span class='executed'>            _after(actorsToUpdate);</span>
 60 | *   | <span class='executed'>            invariant_MGN_15(accountId);</span>
 61 |     | <span class='neutral'>            //@audit fails</span>
 62 |     | <span class='neutral'>            // invariant_MGN_07();</span>
 63 | *   | <span class='executed'>            invariant_MGN_16();</span>
 64 | *   | <span class='executed'>            onSuccessInvariantsGeneral(returnData, accountId);</span>
 65 |     | <span class='neutral'>        } else {</span>
 66 |     | <span class='neutral'>            onFailInvariantsGeneral(returnData);</span>
 67 |     | <span class='neutral'>        }</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'>}</span>
 70 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsAdmin.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PreconditionsBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract PreconditionsAdmin is PreconditionsBase {</span>
   7 |     | <span class='neutral'>    struct ChangePythPriceParams {</span>
   8 |     | <span class='neutral'>        int256 newPrice;</span>
   9 |     | <span class='neutral'>        bytes32 id;</span>
  10 |     | <span class='neutral'>    }</span>
  11 | *   | <span class='executed'>    function mintUSDToSynthetixPreconditions(uint256 amount) internal returns (uint256) {</span>
  12 | *   | <span class='executed'>        uint256 currentBalance = sUSDTokenMock.balanceOf(address(v3Mock));</span>
  13 | *   | <span class='executed'>        if (currentBalance == 0) return amount;</span>
  14 |     | <span class='neutral'>        return</span>
  15 | *   | <span class='executed'>            fl.clamp(</span>
  16 | *   | <span class='executed'>                amount,</span>
  17 |     | <span class='neutral'>                1,</span>
  18 | *   | <span class='executed'>                (currentBalance * UINT_MAX_SYNTHETIX_USD_CHANGE_BP) / UINT_ONE_HUNDRED_BP</span>
  19 |     | <span class='neutral'>            );</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>    function burnUSDFromSynthetixPreconditions(uint256 amount) internal returns (uint256) {</span>
  23 | *   | <span class='executed'>        uint256 currentBalance = sUSDTokenMock.balanceOf(address(v3Mock));</span>
  24 | *   | <span class='executed'>        return</span>
  25 | *r  | <span class='executed'>            fl.clamp(</span>
  26 | *   | <span class='executed'>                amount,</span>
  27 |     | <span class='neutral'>                1,</span>
  28 | *   | <span class='executed'>                (currentBalance * UINT_MAX_SYNTHETIX_USD_CHANGE_BP) / UINT_ONE_HUNDRED_BP</span>
  29 |     | <span class='neutral'>            );</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'>    event DebugPricePre(int256 p, string s);</span>
  32 |     | <span class='neutral'></span>
  33 | *   | <span class='executed'>    function changeOracleManagerPricePreconditions(</span>
  34 |     | <span class='neutral'>        uint256 nodeIndex,</span>
  35 |     | <span class='neutral'>        int256 newPrice</span>
  36 | *   | <span class='executed'>    ) internal returns (int256 clampedPrice, bytes32 nodeId) {</span>
  37 |     | <span class='neutral'>        // clamp nodeId to one of the active collaterals, ignores sUSD node to keep it constant</span>
  38 | *   | <span class='executed'>        nodeId = _getRandomNodeId(nodeIndex);</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>        int256 currentPrice = mockOracleManager.process(nodeId).price;</span>
  41 |     | <span class='neutral'></span>
  42 | *   | <span class='executed'>        int256 minBound = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /</span>
  43 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP; // -20%</span>
  44 | *   | <span class='executed'>        int256 maxBound = (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) /</span>
  45 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP; // +20%</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>        if (minBound &lt; 500e18) {</span>
  48 | *   | <span class='executed'>            minBound = 500e18; // min ETH price $500</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'></span>
  51 | *   | <span class='executed'>        if (maxBound &lt; minBound) {</span>
  52 | *   | <span class='executed'>            maxBound = minBound;</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'></span>
  55 | *r  | <span class='executed'>        clampedPrice = fl.clamp(newPrice, minBound, maxBound);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 | *   | <span class='executed'>    function changeWETHPythPricePreconditions(</span>
  59 |     | <span class='neutral'>        int64 newPrice</span>
  60 |     | <span class='neutral'>    ) internal returns (ChangePythPriceParams memory) {</span>
  61 | *   | <span class='executed'>        int256 currentPrice = pythWrapper.getBenchmarkPrice(</span>
  62 |     | <span class='neutral'>            WETH_FEED_ID,</span>
  63 |     | <span class='neutral'>            0 //uint64 requestedTime, irrelevant for mock</span>
  64 |     | <span class='neutral'>        );</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>        int256 minBound = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /</span>
  67 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP; // -20%</span>
  68 | *   | <span class='executed'>        int256 maxBound = (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) /</span>
  69 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP; // +20%</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>        if (minBound &lt; 500e18) {</span>
  72 | *   | <span class='executed'>            minBound = 500e18; // min ETH price $500</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>        if (maxBound &lt; minBound) {</span>
  76 |     | <span class='unexecuted'>            maxBound = minBound;</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'></span>
  79 | *   | <span class='executed'>        int clampedPrice = fl.clamp(newPrice, minBound, maxBound);</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>        fl.log(&quot;changeWETHPythPricePreconditions::newPrice&quot;, clampedPrice);</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>        return ChangePythPriceParams({newPrice: clampedPrice, id: WETH_FEED_ID});</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 | *   | <span class='executed'>    function changeWBTCPythPricePreconditions(</span>
  87 |     | <span class='neutral'>        int64 newPrice</span>
  88 |     | <span class='neutral'>    ) internal returns (ChangePythPriceParams memory) {</span>
  89 | *   | <span class='executed'>        int256 currentPrice = pythWrapper.getBenchmarkPrice(WBTC_FEED_ID, 0);</span>
  90 | *   | <span class='executed'>        emit DebugPricing(currentPrice, &quot;CURRENT PRICE&quot;);</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>        int256 minBound = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /</span>
  93 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP; // -20%</span>
  94 | *   | <span class='executed'>        int256 maxBound = (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) /</span>
  95 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP; // +20%</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>        if (minBound &lt; 500e18) {</span>
  98 | *   | <span class='executed'>            minBound = 500e18; // min WBTC price $500</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'></span>
 101 | *   | <span class='executed'>        if (maxBound &lt; minBound) {</span>
 102 |     | <span class='unexecuted'>            maxBound = minBound;</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>        int clampedPrice = fl.clamp(newPrice, minBound, maxBound);</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>        fl.log(&quot;changeWBTCPythPricePreconditions::newPrice&quot;, clampedPrice);</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>        return ChangePythPriceParams({newPrice: clampedPrice, id: WBTC_FEED_ID});</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>    function crashWETHPythPricePreconditions() internal returns (ChangePythPriceParams memory) {</span>
 113 | *   | <span class='executed'>        int256 currentPrice = pythWrapper.getBenchmarkPrice(WETH_FEED_ID, 0);</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>        int256 newPrice = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /</span>
 116 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP;</span>
 117 | *   | <span class='executed'>        int256 clampedPrice = newPrice &lt; int(500e18) ? int(500e18) : newPrice;</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>        return ChangePythPriceParams({newPrice: clampedPrice, id: WETH_FEED_ID});</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>    function pumpWETHPythPricePreconditions() internal returns (ChangePythPriceParams memory) {</span>
 123 | *   | <span class='executed'>        int256 currentPrice = pythWrapper.getBenchmarkPrice(</span>
 124 |     | <span class='neutral'>            WETH_FEED_ID,</span>
 125 |     | <span class='neutral'>            0 //uint64 requestedTime, irrelevant for mock</span>
 126 |     | <span class='neutral'>        );</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>        return</span>
 129 | *   | <span class='executed'>            ChangePythPriceParams({</span>
 130 |     | <span class='neutral'>                newPrice: int256(</span>
 131 | *   | <span class='executed'>                    (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) / INT_ONE_HUNDRED_BP</span>
 132 |     | <span class='neutral'>                ),</span>
 133 |     | <span class='neutral'>                id: WETH_FEED_ID</span>
 134 |     | <span class='neutral'>            });</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    event DebugPricing(int256 p, string s);</span>
 138 | *   | <span class='executed'>    function crashWBTCPythPricePreconditions() internal returns (ChangePythPriceParams memory) {</span>
 139 | *   | <span class='executed'>        int256 currentPrice = pythWrapper.getBenchmarkPrice(WBTC_FEED_ID, 0);</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>        int256 newPrice = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /</span>
 142 |     | <span class='neutral'>            INT_ONE_HUNDRED_BP;</span>
 143 | *   | <span class='executed'>        int256 clampedPrice = newPrice &lt; int(500e18) ? int(500e18) : newPrice;</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>        return ChangePythPriceParams({newPrice: clampedPrice, id: WBTC_FEED_ID});</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 | *   | <span class='executed'>    function pumpWBTCPythPricePreconditions() internal returns (ChangePythPriceParams memory) {</span>
 149 | *   | <span class='executed'>        int256 currentPrice = pythWrapper.getBenchmarkPrice(</span>
 150 |     | <span class='neutral'>            WBTC_FEED_ID,</span>
 151 |     | <span class='neutral'>            0 //uint64 requestedTime, irrelevant for mock</span>
 152 |     | <span class='neutral'>        );</span>
 153 |     | <span class='neutral'></span>
 154 | *   | <span class='executed'>        return</span>
 155 | *   | <span class='executed'>            ChangePythPriceParams({</span>
 156 |     | <span class='neutral'>                newPrice: int256(</span>
 157 | *   | <span class='executed'>                    (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) / INT_ONE_HUNDRED_BP</span>
 158 |     | <span class='neutral'>                ),</span>
 159 |     | <span class='neutral'>                id: WBTC_FEED_ID</span>
 160 |     | <span class='neutral'>            });</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 | *   | <span class='executed'>    function delegateCollateralPreconditions(</span>
 164 |     | <span class='neutral'>        uint256 newCollateralAmountD18,</span>
 165 |     | <span class='neutral'>        uint256 collateralTokenIndex</span>
 166 |     | <span class='neutral'>    )</span>
 167 |     | <span class='neutral'>        internal</span>
 168 | *   | <span class='executed'>        returns (uint256 clampedNewCollateralAmountD18, address collateralToken, uint128 marketId)</span>
 169 |     | <span class='neutral'>    {</span>
 170 | *   | <span class='executed'>        clampedNewCollateralAmountD18 = fl.clamp(newCollateralAmountD18, 1, 100_000_000);</span>
 171 | *   | <span class='executed'>        collateralToken = _getRandomCollateralToken(collateralTokenIndex);</span>
 172 | *   | <span class='executed'>        marketId = collateralTokenIndex % 2 == 0 ? 1 : 2;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    function max(int256 x, int256 y) internal pure returns (int256) {</span>
 176 |     | <span class='neutral'>        return x &lt; y ? y : x;</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    function max(uint256 x, uint256 y) internal pure returns (uint256) {</span>
 180 |     | <span class='neutral'>        return x &lt; y ? y : x;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'>}</span>
 183 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../util/FunctionCalls.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../BeforeAfter.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract PreconditionsBase is FunctionCalls, BeforeAfter {</span>
  8 |     | <span class='neutral'>    modifier setCurrentActor() {</span>
  9 |     | <span class='neutral'>        // if (_setActor) {</span>
 10 |     | <span class='neutral'>        //     currentActor = checkCaller.checkCaller();</span>
 11 |     | <span class='neutral'>        // }</span>
 12 |     | <span class='neutral'>        // if (isFoundry) {</span>
 13 |     | <span class='neutral'>        //     // fl.log(&quot;IS FOUNDRY&quot;); &lt;--this emit break vm.prank()</span>
 14 |     | <span class='neutral'>        //     if (_setActor) {</span>
 15 |     | <span class='neutral'>        //         currentActor = checkCaller.checkCaller();</span>
 16 |     | <span class='neutral'>        //     }</span>
 17 |     | <span class='neutral'>        // } else {</span>
 18 |     | <span class='neutral'>        //     fl.log(&quot;NOT IS FOUNDRY&quot;);</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>        if (_setActor) {</span>
 21 |     | <span class='neutral'>            // require(guidedDone);</span>
 22 | *   | <span class='executed'>            currentActor = USERS[block.timestamp % (USERS.length)];</span>
 23 |     | <span class='neutral'>            // currentActor = msg.sender;</span>
 24 |     | <span class='neutral'></span>
 25 | *   | <span class='executed'>            vm.prank(currentActor);</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='neutral'>        // }</span>
 28 |     | <span class='neutral'>        _;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsLiquidationModule.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PreconditionsBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract PreconditionsLiquidationModule is PreconditionsBase {</span>
   7 |     | <span class='neutral'>    struct LiquidateMarginOnlyParams {</span>
   8 |     | <span class='neutral'>        address user;</span>
   9 |     | <span class='neutral'>        uint128 accountId;</span>
  10 |     | <span class='neutral'>    }</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct LiquidatePositionParams {</span>
  13 |     | <span class='neutral'>        address user;</span>
  14 |     | <span class='neutral'>        uint128 accountId;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct LiquidateFlaggedParams {</span>
  18 |     | <span class='neutral'>        uint numberOfAccounts;</span>
  19 |     | <span class='neutral'>        uint[] flaggedAccounts;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>    function liquidatePositionPreconditions()</span>
  23 |     | <span class='neutral'>        internal</span>
  24 |     | <span class='neutral'>        returns (LiquidatePositionParams memory)</span>
  25 |     | <span class='neutral'>    {</span>
  26 | *   | <span class='executed'>        address userToLiquidate;</span>
  27 | *   | <span class='executed'>        uint128 accountToLiquidate;</span>
  28 |     | <span class='neutral'>        // search users array for one is eligible for liquidation</span>
  29 | *   | <span class='executed'>        for (uint128 i; i &lt; USERS.length; i++) {</span>
  30 | *   | <span class='executed'>            console2.log(&quot;Checking account:&quot;, userToAccountIds[USERS[i]]);</span>
  31 |     | <span class='neutral'></span>
  32 | *   | <span class='executed'>            (bool success, bytes memory returnData) = perps.call(</span>
  33 | *   | <span class='executed'>                abi.encodeWithSelector(</span>
  34 | *   | <span class='executed'>                    liquidationModuleImpl.canLiquidate.selector,</span>
  35 | *   | <span class='executed'>                    userToAccountIds[USERS[i]]</span>
  36 |     | <span class='neutral'>                )</span>
  37 |     | <span class='neutral'>            );</span>
  38 | *   | <span class='executed'>            assert(success);</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>            bool isEligible = abi.decode(returnData, (bool));</span>
  41 |     | <span class='neutral'></span>
  42 | *   | <span class='executed'>            if (isEligible) {</span>
  43 | *   | <span class='executed'>                accountToLiquidate = userToAccountIds[USERS[i]];</span>
  44 | *   | <span class='executed'>                break;</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>            if (i == USERS.length - 1) {</span>
  48 | *   | <span class='executed'>                require(false, &quot;no flagged users to liquidate&quot;);</span>
  49 |     | <span class='neutral'>            }</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        return</span>
  53 | *   | <span class='executed'>            LiquidatePositionParams({</span>
  54 | *   | <span class='executed'>                user: accountIdToUser[accountToLiquidate],</span>
  55 |     | <span class='neutral'>                accountId: accountToLiquidate</span>
  56 |     | <span class='neutral'>            });</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 | *   | <span class='executed'>    function liquidateMarginOnlyPreconditions()</span>
  60 |     | <span class='neutral'>        internal</span>
  61 |     | <span class='neutral'>        returns (LiquidateMarginOnlyParams memory)</span>
  62 |     | <span class='neutral'>    {</span>
  63 | *   | <span class='executed'>        uint128 accountToLiquidate;</span>
  64 | *   | <span class='executed'>        for (uint128 i; i &lt; USERS.length; i++) {</span>
  65 | *   | <span class='executed'>            console2.log(&quot;Checking account for margin-only liquidation:&quot;, i);</span>
  66 |     | <span class='neutral'></span>
  67 | *   | <span class='executed'>            (bool success, bytes memory returnData) = perps.call(</span>
  68 | *   | <span class='executed'>                abi.encodeWithSelector(</span>
  69 | *   | <span class='executed'>                    liquidationModuleImpl.canLiquidateMarginOnly.selector,</span>
  70 | *   | <span class='executed'>                    userToAccountIds[USERS[i]]</span>
  71 |     | <span class='neutral'>                )</span>
  72 |     | <span class='neutral'>            );</span>
  73 | *   | <span class='executed'>            assert(success);</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>            bool isEligible = abi.decode(returnData, (bool));</span>
  76 |     | <span class='neutral'></span>
  77 | *   | <span class='executed'>            if (isEligible) {</span>
  78 | *   | <span class='executed'>                accountToLiquidate = userToAccountIds[USERS[i]];</span>
  79 | *   | <span class='executed'>                break;</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='neutral'></span>
  82 | *   | <span class='executed'>            if (i == USERS.length - 1) {</span>
  83 | *   | <span class='executed'>                require(false, &quot;no flagged users to liquidate margin-only&quot;);</span>
  84 |     | <span class='neutral'>            }</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        return</span>
  88 | *   | <span class='executed'>            LiquidateMarginOnlyParams({</span>
  89 | *   | <span class='executed'>                user: accountIdToUser[accountToLiquidate],</span>
  90 |     | <span class='neutral'>                accountId: accountToLiquidate</span>
  91 |     | <span class='neutral'>            });</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>    function liquidateFlaggedPreconditions(</span>
  95 |     | <span class='neutral'>        uint8 maxNumberOfAccounts</span>
  96 |     | <span class='neutral'>    ) internal returns (LiquidateFlaggedParams memory) {</span>
  97 | *   | <span class='executed'>        uint numberOfAccounts = fl.clamp(</span>
  98 | *   | <span class='executed'>            maxNumberOfAccounts,</span>
  99 |     | <span class='neutral'>            0,</span>
 100 | *   | <span class='executed'>            (USERS.length - 1)</span>
 101 |     | <span class='neutral'>        );</span>
 102 | *   | <span class='executed'>        uint256 liquidatableAccountsCount = 0;</span>
 103 | *   | <span class='executed'>        uint256[] memory liquidatableAccounts = new uint256[](USERS.length);</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>        for (uint128 i; i &lt; USERS.length; i++) {</span>
 106 | *   | <span class='executed'>            console2.log(&quot;Checking account:&quot;, userToAccountIds[USERS[i]]);</span>
 107 |     | <span class='neutral'></span>
 108 | *   | <span class='executed'>            (bool success, bytes memory returnData) = perps.call(</span>
 109 | *   | <span class='executed'>                abi.encodeWithSelector(</span>
 110 | *   | <span class='executed'>                    liquidationModuleImpl.canLiquidate.selector,</span>
 111 | *   | <span class='executed'>                    userToAccountIds[USERS[i]]</span>
 112 |     | <span class='neutral'>                )</span>
 113 |     | <span class='neutral'>            );</span>
 114 | *   | <span class='executed'>            assert(success);</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>            bool isEligible = abi.decode(returnData, (bool));</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>            if (isEligible) {</span>
 119 | *   | <span class='executed'>                liquidatableAccounts[</span>
 120 | *   | <span class='executed'>                    liquidatableAccountsCount</span>
 121 | *   | <span class='executed'>                ] = userToAccountIds[USERS[i]];</span>
 122 | *   | <span class='executed'>                liquidatableAccountsCount++;</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'></span>
 126 | *   | <span class='executed'>        require(liquidatableAccountsCount &gt; 0, &quot;No accounts to liquidate&quot;);</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>        uint256[] memory finalLiquidatableAccounts = new uint256[](</span>
 129 | *   | <span class='executed'>            liquidatableAccountsCount</span>
 130 |     | <span class='neutral'>        );</span>
 131 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; liquidatableAccountsCount; i++) {</span>
 132 | *   | <span class='executed'>            finalLiquidatableAccounts[i] = liquidatableAccounts[i];</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'></span>
 135 | *   | <span class='executed'>        return</span>
 136 | *   | <span class='executed'>            LiquidateFlaggedParams({</span>
 137 |     | <span class='neutral'>                numberOfAccounts: uint128(</span>
 138 | *   | <span class='executed'>                    fl.min(numberOfAccounts, liquidatableAccountsCount)</span>
 139 |     | <span class='neutral'>                ),</span>
 140 |     | <span class='neutral'>                flaggedAccounts: finalLiquidatableAccounts</span>
 141 |     | <span class='neutral'>            });</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsOrderModule.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {AsyncOrder} from &quot;../../../storage/AsyncOrder.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./PreconditionsBase.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>abstract contract PreconditionsOrderModule is PreconditionsBase {</span>
   9 |     | <span class='neutral'>    struct CommitOrderParams {</span>
  10 |     | <span class='neutral'>        uint128 accountId;</span>
  11 |     | <span class='neutral'>        uint128 marketId;</span>
  12 |     | <span class='neutral'>        int128 sizeDelta;</span>
  13 |     | <span class='neutral'>        uint256 acceptablePrice;</span>
  14 |     | <span class='neutral'>        uint128 settlementStrategyId;</span>
  15 |     | <span class='neutral'>        bytes32 trackingCode;</span>
  16 |     | <span class='neutral'>        address referrer;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct SettleOrderParams {</span>
  20 |     | <span class='neutral'>        address settleUser;</span>
  21 |     | <span class='neutral'>        uint128 accountId;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct CancelOrderParams {</span>
  25 |     | <span class='neutral'>        address cancelUser;</span>
  26 |     | <span class='neutral'>        uint128 accountId;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 | *   | <span class='executed'>    function commitOrderPreconditions(</span>
  30 |     | <span class='neutral'>        int128 sizeDelta,</span>
  31 |     | <span class='neutral'>        uint256 acceptablePrice,</span>
  32 |     | <span class='neutral'>        bytes32 trackingCode,</span>
  33 |     | <span class='neutral'>        address referrer</span>
  34 |     | <span class='neutral'>    ) internal returns (CommitOrderParams memory) {</span>
  35 | *   | <span class='executed'>        console2.log(</span>
  36 |     | <span class='neutral'>            &quot;===== PreconditionsOrderModule:commitOrderPreconditions START =====&quot;</span>
  37 |     | <span class='neutral'>        );</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>        uint128 settlementStrategyId = 0; //@coverage:limiter currently employing only one settlement strategy</span>
  40 | *   | <span class='executed'>        console2.log(&quot;===== uint128 account  START =====&quot;);</span>
  41 | *   | <span class='executed'>        console2.log(&quot;currentActor&quot;, currentActor);</span>
  42 | *   | <span class='executed'>        console2.log(&quot;current msg.sender&quot;, msg.sender);</span>
  43 |     | <span class='neutral'></span>
  44 | *   | <span class='executed'>        console2.log(&quot;acceptablePrice&quot;, acceptablePrice);</span>
  45 |     | <span class='neutral'></span>
  46 | *   | <span class='executed'>        uint128 accountIds = userToAccountIds[currentActor];</span>
  47 |     | <span class='neutral'>        uint128 account = userToAccountIds[currentActor];</span>
  48 | *   | <span class='executed'>        console2.log(&quot;===== uint128 account  END =====&quot;);</span>
  49 |     | <span class='neutral'></span>
  50 | *   | <span class='executed'>        uint128 marketId = acceptablePrice % 2 == 0 ? 1 : 2;</span>
  51 | *   | <span class='executed'>        console2.log(&quot;===== Constructing CommitOrderParams START =====&quot;);</span>
  52 |     | <span class='neutral'></span>
  53 | *   | <span class='executed'>        console2.log(&quot;account&quot;, account);</span>
  54 | *   | <span class='executed'>        console2.log(&quot;marketId&quot;, marketId);</span>
  55 |     | <span class='neutral'></span>
  56 | *   | <span class='executed'>        int128 clampedSizeDelta = int128(</span>
  57 | *   | <span class='executed'>            fl.clamp(</span>
  58 | *   | <span class='executed'>                sizeDelta,</span>
  59 | *   | <span class='executed'>                -int128(</span>
  60 | *   | <span class='executed'>                    marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE</span>
  61 |     | <span class='neutral'>                ),</span>
  62 |     | <span class='neutral'>                int128(</span>
  63 | *   | <span class='executed'>                    marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE</span>
  64 |     | <span class='neutral'>                )</span>
  65 |     | <span class='neutral'>            )</span>
  66 |     | <span class='neutral'>        );</span>
  67 | *   | <span class='executed'>        console2.log(&quot;clampedSizeDelta&quot;, clampedSizeDelta);</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>        console2.log(&quot;WETH_MAX_MARKET_SIZE&quot;, WETH_MAX_MARKET_SIZE);</span>
  70 | *   | <span class='executed'>        console2.log(&quot;WBTC_MAX_MARKET_SIZE&quot;, WBTC_MAX_MARKET_SIZE);</span>
  71 |     | <span class='neutral'></span>
  72 | *   | <span class='executed'>        console2.log(&quot;acceptablePrice&quot;, acceptablePrice);</span>
  73 | *   | <span class='executed'>        console2.log(&quot;===== Constructing CommitOrderParams END =====&quot;);</span>
  74 | *   | <span class='executed'>        sizeDelta = int128(</span>
  75 | *   | <span class='executed'>            fl.clamp(</span>
  76 | *   | <span class='executed'>                sizeDelta,</span>
  77 | *   | <span class='executed'>                -int128(</span>
  78 | *   | <span class='executed'>                    marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE</span>
  79 |     | <span class='neutral'>                ),</span>
  80 |     | <span class='neutral'>                int128(</span>
  81 | *   | <span class='executed'>                    marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE</span>
  82 |     | <span class='neutral'>                )</span>
  83 |     | <span class='neutral'>            )</span>
  84 |     | <span class='neutral'>        );</span>
  85 | *   | <span class='executed'>        console2.log(&quot;Commit size delta&quot;, sizeDelta);</span>
  86 | *   | <span class='executed'>        console2.log(</span>
  87 |     | <span class='neutral'>            &quot;Commit acceptable price&quot;,</span>
  88 | *   | <span class='executed'>            sizeDelta &gt; 0 ? acceptablePrice = type(uint256).max : 0</span>
  89 |     | <span class='neutral'>        );</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>        return</span>
  92 | *   | <span class='executed'>            CommitOrderParams({</span>
  93 | *   | <span class='executed'>                accountId: account,</span>
  94 | *   | <span class='executed'>                marketId: marketId,</span>
  95 | *   | <span class='executed'>                sizeDelta: sizeDelta,</span>
  96 | *   | <span class='executed'>                acceptablePrice: sizeDelta &gt; 0</span>
  97 | *   | <span class='executed'>                    ? acceptablePrice = type(uint256).max</span>
  98 | *   | <span class='executed'>                    : 0,</span>
  99 | *   | <span class='executed'>                settlementStrategyId: settlementStrategyId,</span>
 100 | *   | <span class='executed'>                trackingCode: trackingCode,</span>
 101 | *   | <span class='executed'>                referrer: referrer</span>
 102 |     | <span class='neutral'>            });</span>
 103 |     | <span class='neutral'>        console2.log(</span>
 104 |     | <span class='neutral'>            &quot;===== PreconditionsOrderModule:commitOrderPreconditions END =====&quot;</span>
 105 |     | <span class='neutral'>        );</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 | *   | <span class='executed'>    function settleOrderPreconditions()</span>
 109 |     | <span class='neutral'>        internal</span>
 110 |     | <span class='neutral'>        returns (SettleOrderParams memory)</span>
 111 |     | <span class='neutral'>    {</span>
 112 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; USERS.length; i++) {</span>
 113 | *   | <span class='executed'>            address settelUser = USERS[i];</span>
 114 | *   | <span class='executed'>            uint128 account = userToAccountIds[settelUser];</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>            (bool success, bytes memory returnData) = perps.call(</span>
 117 | *   | <span class='executed'>                abi.encodeWithSelector(</span>
 118 |     | <span class='neutral'>                    asyncOrderModuleImpl.getOrder.selector,</span>
 119 |     | <span class='neutral'>                    account</span>
 120 |     | <span class='neutral'>                )</span>
 121 |     | <span class='neutral'>            );</span>
 122 | *   | <span class='executed'>            assert(success);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>            AsyncOrder.Data memory order = abi.decode(</span>
 125 | *   | <span class='executed'>                returnData,</span>
 126 |     | <span class='neutral'>                (AsyncOrder.Data)</span>
 127 |     | <span class='neutral'>            );</span>
 128 | *   | <span class='executed'>            if (order.commitmentTime != 0) {</span>
 129 |     | <span class='neutral'>                return</span>
 130 | *   | <span class='executed'>                    SettleOrderParams({</span>
 131 |     | <span class='neutral'>                        settleUser: settelUser,</span>
 132 |     | <span class='neutral'>                        accountId: account</span>
 133 |     | <span class='neutral'>                    });</span>
 134 |     | <span class='neutral'>            }</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>        require(false, &quot;No valid order found&quot;);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 | *   | <span class='executed'>    function cancelOrderPreconditions(</span>
 141 |     | <span class='neutral'>        uint8 cancelUser</span>
 142 |     | <span class='neutral'>    ) internal view returns (CancelOrderParams memory) {</span>
 143 | *   | <span class='executed'>        address user = USERS[cancelUser % (USERS.length - 1)];</span>
 144 | *   | <span class='executed'>        uint128 account = userToAccountIds[user];</span>
 145 | *   | <span class='executed'>        uint128 marketId = cancelUser % 2 == 0 ? 1 : 2;</span>
 146 |     | <span class='neutral'></span>
 147 | *   | <span class='executed'>        return</span>
 148 | *   | <span class='executed'>            CancelOrderParams({</span>
 149 | *   | <span class='executed'>                cancelUser: USERS[cancelUser % (USERS.length - 1)],</span>
 150 |     | <span class='neutral'>                accountId: account</span>
 151 |     | <span class='neutral'>            });</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'>}</span>
 154 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsPerpsAccountModule.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./PreconditionsBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract PreconditionsPerpsAccountModule is PreconditionsBase {</span>
  7 |     | <span class='neutral'>    struct ModifyCollateralParams {</span>
  8 |     | <span class='neutral'>        uint128 accountId;</span>
  9 |     | <span class='neutral'>        uint128 marketId;</span>
 10 |     | <span class='neutral'>        address collateralAddress;</span>
 11 |     | <span class='neutral'>        uint128 collateralId;</span>
 12 |     | <span class='neutral'>        int256 amountDelta;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    struct PayDebtParams {</span>
 16 |     | <span class='neutral'>        uint128 accountId;</span>
 17 |     | <span class='neutral'>        uint128 marketId;</span>
 18 |     | <span class='neutral'>        uint128 amount;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>    function modifyCollateralPreconditions(</span>
 22 |     | <span class='neutral'>        int256 amountDelta,</span>
 23 |     | <span class='neutral'>        uint256 collateralTokenIndex</span>
 24 |     | <span class='neutral'>    ) internal returns (ModifyCollateralParams memory) {</span>
 25 | *   | <span class='executed'>        address collateralToken = _getRandomCollateralToken(collateralTokenIndex);</span>
 26 | *   | <span class='executed'>        uint128 account = userToAccountIds[currentActor];</span>
 27 |     | <span class='neutral'></span>
 28 | *   | <span class='executed'>        uint128 marketId = collateralTokenIndex % 2 == 0 ? 1 : 2;</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>        uint128 collateralId;</span>
 31 | *   | <span class='executed'>        if (collateralToken == address(sUSDTokenMock)) collateralId = 0;</span>
 32 | *   | <span class='executed'>        else if (collateralToken == address(wethTokenMock)) collateralId = 1;</span>
 33 | *   | <span class='executed'>        else if (collateralToken == address(wbtcTokenMock)) collateralId = 2;</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>        return</span>
 36 | *   | <span class='executed'>            ModifyCollateralParams({</span>
 37 |     | <span class='neutral'>                accountId: account,</span>
 38 |     | <span class='neutral'>                marketId: marketId,</span>
 39 |     | <span class='neutral'>                collateralAddress: collateralToken,</span>
 40 |     | <span class='neutral'>                collateralId: collateralId,</span>
 41 | *r  | <span class='executed'>                amountDelta: fl.clamp(amountDelta, -int128(MAX_ALLOWABLE), int128(MAX_ALLOWABLE))</span>
 42 |     | <span class='neutral'>            });</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 | *   | <span class='executed'>    function payDebtPreconditions(uint128 amount) internal view returns (PayDebtParams memory) {</span>
 46 | *   | <span class='executed'>        uint128 account = userToAccountIds[currentActor];</span>
 47 | *   | <span class='executed'>        uint128 marketId = amount % 2 == 0 ? 1 : 2;</span>
 48 |     | <span class='neutral'></span>
 49 | *   | <span class='executed'>        return PayDebtParams({accountId: account, marketId: marketId, amount: amount});</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'>import {ERC20} from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 | *   | <span class='executed'>contract MockERC20 is ERC20 {</span>
  6 |     | <span class='neutral'>    uint8 private _decimals;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>    constructor(string memory name, string memory symbol, uint8 dec) ERC20(name, symbol) {</span>
  9 |     | <span class='unexecuted'>        _decimals = dec;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function decimals() public view virtual override(ERC20) returns (uint8) {</span>
 13 |     | <span class='unexecuted'>        return _decimals;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 | *   | <span class='executed'>    function mint(address account, uint256 amount) external {</span>
 17 | *   | <span class='executed'>        _mint(account, amount);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    function burn(address account, uint256 amount) external {</span>
 21 | *   | <span class='executed'>        _burn(account, amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockLensModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {AsyncOrder} from &quot;../../storage/AsyncOrder.sol&quot;;</span>
   5 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;../../storage/PerpsMarketConfiguration.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../../storage/SettlementStrategy.sol&quot;;</span>
   7 |     | <span class='neutral'>import {PerpsAccount} from &quot;../../storage/PerpsAccount.sol&quot;;</span>
   8 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../../storage/GlobalPerpsMarket.sol&quot;;</span>
   9 |     | <span class='neutral'>import {PerpsMarket} from &quot;../../storage/PerpsMarket.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsPrice} from &quot;../../storage/PerpsPrice.sol&quot;;</span>
  11 |     | <span class='neutral'>import {Position} from &quot;../../storage/Position.sol&quot;;</span>
  12 |     | <span class='neutral'>import {MockPythERC7412Wrapper} from &quot;../../mocks/MockPythERC7412Wrapper.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/IHEVM.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>// import {IAsyncOrderSettlementPythModule} from &quot;../../interfaces/IAsyncOrderSettlementPythModule.sol&quot;; //TODO: delete</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  18 |     | <span class='neutral'>import {SafeCastI256, SafeCastU256, SafeCastU128} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>contract MockLensModule {</span>
  23 |     | <span class='neutral'>    using AsyncOrder for AsyncOrder.Data;</span>
  24 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
  25 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  26 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  27 |     | <span class='neutral'>    using Position for Position.Data;</span>
  28 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  29 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  30 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  31 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  32 |     | <span class='unexecuted'>    MockPythERC7412Wrapper public pythWrapper;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    struct StackCache {</span>
  35 |     | <span class='neutral'>        uint256 currentPrice;</span>
  36 |     | <span class='neutral'>        uint256 notionalValue;</span>
  37 |     | <span class='neutral'>        int256 totalPnl;</span>
  38 |     | <span class='neutral'>        int256 pricePnl;</span>
  39 |     | <span class='neutral'>        uint256 chargedInterest;</span>
  40 |     | <span class='neutral'>        int256 accruedFunding;</span>
  41 |     | <span class='neutral'>        int256 netFundingPerUnit;</span>
  42 |     | <span class='neutral'>        int256 nextFunding;</span>
  43 |     | <span class='neutral'>        int128 positionSize;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'>    struct SettleOrderRuntime {</span>
  46 |     | <span class='neutral'>        uint128 marketId;</span>
  47 |     | <span class='neutral'>        uint128 accountId;</span>
  48 |     | <span class='neutral'>        int128 sizeDelta;</span>
  49 |     | <span class='neutral'>        int256 pnl;</span>
  50 |     | <span class='neutral'>        uint256 chargedInterest;</span>
  51 |     | <span class='neutral'>        int256 accruedFunding;</span>
  52 |     | <span class='neutral'>        uint256 settlementReward;</span>
  53 |     | <span class='neutral'>        uint256 fillPrice;</span>
  54 |     | <span class='neutral'>        uint256 totalFees;</span>
  55 |     | <span class='neutral'>        uint256 referralFees;</span>
  56 |     | <span class='neutral'>        uint256 feeCollectorFees;</span>
  57 |     | <span class='neutral'>        Position.Data newPosition;</span>
  58 |     | <span class='neutral'>        uint256 synthDeductionIterator;</span>
  59 |     | <span class='neutral'>        uint128[] deductedSynthIds;</span>
  60 |     | <span class='neutral'>        uint256[] deductedAmount;</span>
  61 |     | <span class='neutral'>        int256 chargedAmount;</span>
  62 |     | <span class='neutral'>        uint256 newAccountDebt;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function getPythWrapperAddress() public view returns (address) {</span>
  66 |     | <span class='unexecuted'>        return address(pythWrapper);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function setPythWrapperAddress(address _pythWrapper) public {</span>
  70 |     | <span class='neutral'>        bool done;</span>
  71 |     | <span class='neutral'>        require(!done); //only once</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        pythWrapper = MockPythERC7412Wrapper(_pythWrapper);</span>
  74 |     | <span class='neutral'>        done = true;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 | *   | <span class='executed'>    function getChargeAmount(</span>
  78 |     | <span class='neutral'>        uint128 accountId</span>
  79 | *   | <span class='executed'>    ) external returns (int256 chargedAmount) {</span>
  80 | *   | <span class='executed'>        SettleOrderRuntime memory runtime;</span>
  81 |     | <span class='neutral'>        // runtime.accountId = asyncOrder.request.accountId;</span>
  82 |     | <span class='neutral'>        // runtime.marketId = asyncOrder.request.marketId;</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        AsyncOrder.Data storage asyncOrder = AsyncOrder.load(accountId);</span>
  85 | *   | <span class='executed'>        console2.log(</span>
  86 |     | <span class='neutral'>            &quot;MockLens::isOrderExpired::order.request.marketId&quot;,</span>
  87 | *   | <span class='executed'>            asyncOrder.request.marketId</span>
  88 |     | <span class='neutral'>        );</span>
  89 | *   | <span class='executed'>        console2.log(</span>
  90 |     | <span class='neutral'>            &quot;MockLens::isasyncOrderExpired::asyncOrder.request.sizeDelta&quot;,</span>
  91 | *   | <span class='executed'>            asyncOrder.request.sizeDelta</span>
  92 |     | <span class='neutral'>        );</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        if (asyncOrder.request.sizeDelta != 0) {</span>
  95 | *   | <span class='executed'>            SettlementStrategy.Data</span>
  96 | *   | <span class='executed'>                storage settlementStrategy = PerpsMarketConfiguration</span>
  97 | *   | <span class='executed'>                    .load(asyncOrder.request.marketId)</span>
  98 |     | <span class='neutral'>                    .settlementStrategies[</span>
  99 | *   | <span class='executed'>                        asyncOrder.request.settlementStrategyId</span>
 100 |     | <span class='neutral'>                    ];</span>
 101 | *   | <span class='executed'>            console2.log(&quot;PythWrapper in MockLens&quot;, address(pythWrapper));</span>
 102 | *   | <span class='executed'>            int256 offchainPrice = pythWrapper.getBenchmarkPrice(</span>
 103 | *   | <span class='executed'>                settlementStrategy.feedId,</span>
 104 |     | <span class='neutral'>                0</span>
 105 |     | <span class='neutral'>            );</span>
 106 | *   | <span class='executed'>            console2.log(&quot;After pythWrapper.getBenchmarkPrice&quot;);</span>
 107 | *   | <span class='executed'>            console2.log(&quot;offchainPrice:&quot;, offchainPrice);</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>            uint256 price = offchainPrice.toUint();</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>            Position.Data storage oldPosition;</span>
 112 | *   | <span class='executed'>            console2.log(&quot;Before asyncOrder.validateRequest&quot;);</span>
 113 | *   | <span class='executed'>            (</span>
 114 | *   | <span class='executed'>                runtime.newPosition,</span>
 115 | *   | <span class='executed'>                runtime.totalFees,</span>
 116 | *   | <span class='executed'>                runtime.fillPrice,</span>
 117 |     | <span class='neutral'>                oldPosition</span>
 118 | *   | <span class='executed'>            ) = asyncOrder.validateRequest(settlementStrategy, price);</span>
 119 | *   | <span class='executed'>            console2.log(&quot;After asyncOrder.validateRequest&quot;);</span>
 120 | *   | <span class='executed'>            console2.log(&quot;runtime.totalFees:&quot;, runtime.totalFees);</span>
 121 | *   | <span class='executed'>            console2.log(&quot;runtime.fillPrice:&quot;, runtime.fillPrice);</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>            console2.log(&quot;Before asyncOrder.validateAcceptablePrice&quot;);</span>
 124 | *   | <span class='executed'>            asyncOrder.validateAcceptablePrice(runtime.fillPrice);</span>
 125 | *   | <span class='executed'>            console2.log(&quot;After asyncOrder.validateAcceptablePrice&quot;);</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>            console2.log(&quot;Before oldPosition.getPnl&quot;);</span>
 128 | *   | <span class='executed'>            (</span>
 129 | *   | <span class='executed'>                runtime.pnl,</span>
 130 |     | <span class='neutral'>                ,</span>
 131 | *   | <span class='executed'>                runtime.chargedInterest,</span>
 132 | *   | <span class='executed'>                runtime.accruedFunding,</span>
 133 |     | <span class='neutral'>                ,</span>
 134 |     | <span class='neutral'></span>
 135 | *   | <span class='executed'>            ) = oldPosition.getPnl(runtime.fillPrice);</span>
 136 | *   | <span class='executed'>            console2.log(&quot;After oldPosition.getPnl&quot;);</span>
 137 | *   | <span class='executed'>            console2.log(&quot;runtime.pnl:&quot;, runtime.pnl);</span>
 138 | *   | <span class='executed'>            console2.log(&quot;runtime.chargedInterest:&quot;, runtime.chargedInterest);</span>
 139 | *   | <span class='executed'>            console2.log(&quot;runtime.accruedFunding:&quot;, runtime.accruedFunding);</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>            chargedAmount = runtime.pnl - runtime.totalFees.toInt();</span>
 142 | *   | <span class='executed'>            console2.log(&quot;chargedAmount:&quot;, chargedAmount);</span>
 143 |     | <span class='neutral'>        } else {</span>
 144 | *   | <span class='executed'>            console2.log(&quot;getChargedAmount skipped, no order found&quot;);</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>    }</span>
 147 | *   | <span class='executed'>    function isAccountLiquidatable(</span>
 148 |     | <span class='neutral'>        uint128 accountId</span>
 149 | *   | <span class='executed'>    ) external view returns (bool) {</span>
 150 | *   | <span class='executed'>        GlobalPerpsMarket.Data storage globalMarketData = GlobalPerpsMarket</span>
 151 |     | <span class='neutral'>            .load();</span>
 152 | *   | <span class='executed'>        return globalMarketData.liquidatableAccounts.contains(accountId);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>    function getPositionData(</span>
 156 |     | <span class='neutral'>        uint128 accountId,</span>
 157 |     | <span class='neutral'>        uint128 marketId</span>
 158 |     | <span class='neutral'>    )</span>
 159 |     | <span class='neutral'>        external</span>
 160 |     | <span class='neutral'>        view</span>
 161 |     | <span class='neutral'>        returns (</span>
 162 |     | <span class='unexecuted'>            uint256 notionalValue,</span>
 163 |     | <span class='unexecuted'>            int256 totalPnl,</span>
 164 |     | <span class='unexecuted'>            int256 pricePnl,</span>
 165 |     | <span class='unexecuted'>            uint256 chargedInterest,</span>
 166 |     | <span class='unexecuted'>            int256 accruedFunding,</span>
 167 |     | <span class='unexecuted'>            int256 netFundingPerUnit,</span>
 168 |     | <span class='unexecuted'>            int256 nextFunding,</span>
 169 |     | <span class='unexecuted'>            int128 positionSize</span>
 170 |     | <span class='neutral'>        )</span>
 171 |     | <span class='neutral'>    {</span>
 172 |     | <span class='unexecuted'>        StackCache memory cache;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>        Position.Data storage position = PerpsMarket.load(marketId).positions[</span>
 175 |     | <span class='unexecuted'>            accountId</span>
 176 |     | <span class='neutral'>        ];</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        cache.currentPrice = PerpsPrice.getCurrentPrice(</span>
 179 |     | <span class='unexecuted'>            marketId,</span>
 180 |     | <span class='unexecuted'>            PerpsPrice.Tolerance.DEFAULT</span>
 181 |     | <span class='neutral'>        );</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        (</span>
 184 |     | <span class='unexecuted'>            cache.notionalValue,</span>
 185 |     | <span class='unexecuted'>            cache.totalPnl,</span>
 186 |     | <span class='unexecuted'>            cache.pricePnl,</span>
 187 |     | <span class='unexecuted'>            cache.chargedInterest,</span>
 188 |     | <span class='unexecuted'>            cache.accruedFunding,</span>
 189 |     | <span class='unexecuted'>            cache.netFundingPerUnit,</span>
 190 |     | <span class='unexecuted'>            cache.nextFunding</span>
 191 |     | <span class='unexecuted'>        ) = Position.getPositionData(position, cache.currentPrice);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        cache.positionSize = position.size;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        return (</span>
 196 |     | <span class='neutral'>            cache.notionalValue,</span>
 197 |     | <span class='neutral'>            cache.totalPnl,</span>
 198 |     | <span class='neutral'>            cache.pricePnl,</span>
 199 |     | <span class='neutral'>            cache.chargedInterest,</span>
 200 |     | <span class='neutral'>            cache.accruedFunding,</span>
 201 |     | <span class='neutral'>            cache.netFundingPerUnit,</span>
 202 |     | <span class='neutral'>            cache.nextFunding,</span>
 203 |     | <span class='neutral'>            cache.positionSize</span>
 204 |     | <span class='neutral'>        );</span>
 205 |     | <span class='neutral'>    }</span>
 206 | *   | <span class='executed'>    function getDebtCorrectionAccumulator(</span>
 207 |     | <span class='neutral'>        uint128 marketId</span>
 208 | *   | <span class='executed'>    ) external returns (int256) {</span>
 209 | *   | <span class='executed'>        PerpsMarket.Data storage perpsMarketData = PerpsMarket.load(marketId);</span>
 210 | *   | <span class='executed'>        return perpsMarketData.debtCorrectionAccumulator;</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 | *   | <span class='executed'>    function getOpenPositionMarketIds(</span>
 214 |     | <span class='neutral'>        uint128 accountId</span>
 215 | *   | <span class='executed'>    ) external returns (uint128[] memory) {</span>
 216 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 217 | *   | <span class='executed'>        uint256 length = account.openPositionMarketIds.length();</span>
 218 | *   | <span class='executed'>        uint128[] memory marketIds = new uint128[](length);</span>
 219 |     | <span class='neutral'></span>
 220 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= length; i++) {</span>
 221 |     | <span class='neutral'>            //1 based index</span>
 222 | *   | <span class='executed'>            marketIds[i - 1] = account.openPositionMarketIds.valueAt(i).to128();</span>
 223 |     | <span class='neutral'>        }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>        return marketIds;</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>    function getCollateralTypes(</span>
 229 |     | <span class='neutral'>        uint128 accountId</span>
 230 | *   | <span class='executed'>    ) external returns (uint128[] memory) {</span>
 231 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 232 | *   | <span class='executed'>        uint256 length = account.activeCollateralTypes.length();</span>
 233 | *   | <span class='executed'>        uint128[] memory collateralTypes = new uint128[](length);</span>
 234 |     | <span class='neutral'></span>
 235 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= length; i++) {</span>
 236 |     | <span class='neutral'>            //1 based index</span>
 237 | *   | <span class='executed'>            collateralTypes[i - 1] = account</span>
 238 |     | <span class='neutral'>                .activeCollateralTypes</span>
 239 | *   | <span class='executed'>                .valueAt(i)</span>
 240 |     | <span class='neutral'>                .to128();</span>
 241 |     | <span class='neutral'>        }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>        return collateralTypes;</span>
 244 |     | <span class='neutral'>    }</span>
 245 | *   | <span class='executed'>    function getGlobalCollateralTypes()</span>
 246 |     | <span class='neutral'>        external</span>
 247 |     | <span class='neutral'>        view</span>
 248 | *   | <span class='executed'>        returns (uint128[] memory)</span>
 249 |     | <span class='neutral'>    {</span>
 250 | *   | <span class='executed'>        GlobalPerpsMarket.Data storage globalMarketData = GlobalPerpsMarket</span>
 251 |     | <span class='neutral'>            .load();</span>
 252 | *   | <span class='executed'>        SetUtil.UintSet storage activeCollateralTypes = globalMarketData</span>
 253 |     | <span class='neutral'>            .activeCollateralTypes;</span>
 254 | *   | <span class='executed'>        uint256 activeCollateralLength = activeCollateralTypes.length();</span>
 255 | *   | <span class='executed'>        uint128[] memory globalCollateralTypes = new uint128[](</span>
 256 | *   | <span class='executed'>            activeCollateralLength</span>
 257 |     | <span class='neutral'>        );</span>
 258 |     | <span class='neutral'></span>
 259 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= activeCollateralLength; i++) {</span>
 260 | *   | <span class='executed'>            globalCollateralTypes[i - 1] = uint128(</span>
 261 | *   | <span class='executed'>                activeCollateralTypes.valueAt(i)</span>
 262 |     | <span class='neutral'>            );</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'></span>
 265 | *   | <span class='executed'>        return globalCollateralTypes;</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 | *   | <span class='executed'>    function getGlobalTotalAccountsDebt() external view returns (uint256) {</span>
 269 | *   | <span class='executed'>        GlobalPerpsMarket.Data storage globalMarketData = GlobalPerpsMarket</span>
 270 |     | <span class='neutral'>            .load();</span>
 271 |     | <span class='neutral'></span>
 272 | *   | <span class='executed'>        return globalMarketData.totalAccountsDebt;</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 | *   | <span class='executed'>    function isOrderExpired(uint128 accountId) external view returns (bool) {</span>
 276 | *   | <span class='executed'>        AsyncOrder.Data storage order = AsyncOrder.load(accountId);</span>
 277 | *   | <span class='executed'>        console2.log(</span>
 278 |     | <span class='neutral'>            &quot;MockLens::isOrderExpired::order.request.marketId&quot;,</span>
 279 | *   | <span class='executed'>            order.request.marketId</span>
 280 |     | <span class='neutral'>        );</span>
 281 | *   | <span class='executed'>        console2.log(</span>
 282 |     | <span class='neutral'>            &quot;MockLens::isOrderExpired::order.request.sizeDelta&quot;,</span>
 283 | *   | <span class='executed'>            order.request.sizeDelta</span>
 284 |     | <span class='neutral'>        );</span>
 285 | *   | <span class='executed'>        if (order.request.sizeDelta != 0) {</span>
 286 | *   | <span class='executed'>            SettlementStrategy.Data storage strategy = PerpsMarketConfiguration</span>
 287 | *   | <span class='executed'>                .load(order.request.marketId)</span>
 288 | *   | <span class='executed'>                .settlementStrategies[order.request.settlementStrategyId];</span>
 289 |     | <span class='neutral'></span>
 290 | *   | <span class='executed'>            return AsyncOrder.expired(order, strategy);</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'></span>
 293 | *   | <span class='executed'>        return false;</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 | *   | <span class='executed'>    function getOrder(</span>
 297 |     | <span class='neutral'>        uint128 accountId</span>
 298 | *   | <span class='executed'>    ) external view returns (AsyncOrder.Data memory) {</span>
 299 | *   | <span class='executed'>        return AsyncOrder.load(accountId);</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 | *   | <span class='executed'>    function getSettlementRewardCost(</span>
 303 |     | <span class='neutral'>        uint128 marketId,</span>
 304 |     | <span class='neutral'>        uint128 settlementStrategyId</span>
 305 |     | <span class='unexecuted'>    ) external view returns (uint256) {</span>
 306 |     | <span class='unexecuted'>        SettlementStrategy.Data storage strategy = PerpsMarketConfiguration</span>
 307 |     | <span class='unexecuted'>            .loadValidSettlementStrategy(marketId, settlementStrategyId);</span>
 308 |     | <span class='unexecuted'>        return AsyncOrder.settlementRewardCost(strategy);</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 | *   | <span class='executed'>    function calculateFillPrice(</span>
 312 |     | <span class='neutral'>        int256 skew,</span>
 313 |     | <span class='neutral'>        uint256 skewScale,</span>
 314 |     | <span class='neutral'>        int128 sizeDelta,</span>
 315 |     | <span class='neutral'>        uint256 price</span>
 316 |     | <span class='unexecuted'>    ) external pure returns (uint256) {</span>
 317 | *   | <span class='executed'>        return AsyncOrder.calculateFillPrice(skew, skewScale, sizeDelta, price);</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 | *   | <span class='executed'>    function getMaxLiquidatableAmount(</span>
 321 |     | <span class='neutral'>        uint128 marketId,</span>
 322 |     | <span class='neutral'>        uint128 requestedLiquidationAmount</span>
 323 | *   | <span class='executed'>    ) external returns (uint128 liquidatableAmount) {</span>
 324 | *   | <span class='executed'>        PerpsMarket.Data storage market = PerpsMarket.load(marketId);</span>
 325 |     | <span class='neutral'></span>
 326 | *   | <span class='executed'>        liquidatableAmount = PerpsMarket.maxLiquidatableAmount(</span>
 327 | *   | <span class='executed'>            market,</span>
 328 | *   | <span class='executed'>            requestedLiquidationAmount</span>
 329 |     | <span class='neutral'>        );</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'>}</span>
 332 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Account, AccountRBAC} from &quot;@synthetixio/main/contracts/storage/Account.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
  7 |     | <span class='unexecuted'>contract MockModule {</span>
  8 |     | <span class='unexecuted'>    function createAccount(uint128 id, address owner) external {</span>
  9 |     | <span class='unexecuted'>        Account.create(id, owner);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function grantPermission(uint128 accountId, bytes32 permission, address user) external {</span>
 13 |     | <span class='unexecuted'>        Account.Data storage account = Account.load(accountId);</span>
 14 |     | <span class='unexecuted'>        AccountRBAC.grantPermission(account.rbac, permission, user);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockOracleManager.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Account, AccountRBAC} from &quot;@synthetixio/main/contracts/storage/Account.sol&quot;;</span>
  5 |     | <span class='neutral'>import {INodeModule, NodeOutput} from &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
  6 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  7 |     | <span class='neutral'>interface IMockOracleManager {</span>
  8 |     | <span class='neutral'>    function changePrice(bytes32 nodeId, int256 newPrice) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function process(</span>
 11 |     | <span class='neutral'>        bytes32 nodeId</span>
 12 |     | <span class='neutral'>    ) external returns (NodeOutput.Data memory node);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
 16 | *   | <span class='executed'>contract MockOracleManager {</span>
 17 |     | <span class='neutral'>    mapping(bytes32 nodeId =&gt; NodeOutput.Data) nodes;</span>
 18 | *   | <span class='executed'>    bytes32[] public activeNodes;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    constructor(bytes32[] memory nodeIds, int256[] memory prices) {</span>
 21 |     | <span class='neutral'>        // initialize price for the nodeIds passed in</span>
 22 |     | <span class='unexecuted'>        for (uint256 i; i &lt; nodeIds.length; i++) {</span>
 23 |     | <span class='unexecuted'>            nodes[nodeIds[i]] = NodeOutput.Data({</span>
 24 |     | <span class='unexecuted'>                price: prices[i],</span>
 25 |     | <span class='unexecuted'>                timestamp: block.timestamp,</span>
 26 |     | <span class='unexecuted'>                __slotAvailableForFutureUse1: 0,</span>
 27 |     | <span class='unexecuted'>                __slotAvailableForFutureUse2: 0</span>
 28 |     | <span class='neutral'>            });</span>
 29 |     | <span class='unexecuted'>            activeNodes.push(nodeIds[i]);</span>
 30 |     | <span class='neutral'>        }</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function getActiveNodesLength() public view returns (uint256) {</span>
 34 | *   | <span class='executed'>        return activeNodes.length;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 | *   | <span class='executed'>    function changePrice(bytes32 nodeId, int256 newPrice) external {</span>
 38 | *   | <span class='executed'>        nodes[nodeId].price = newPrice;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 | *   | <span class='executed'>    function process(</span>
 42 |     | <span class='neutral'>        bytes32 nodeId</span>
 43 | *   | <span class='executed'>    ) external view returns (NodeOutput.Data memory node) {</span>
 44 | *   | <span class='executed'>        return nodes[nodeId];</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 | *   | <span class='executed'>    function getPrice(bytes32 nodeId) external view returns (int256 price) {</span>
 48 | *   | <span class='executed'>        return nodes[nodeId].price;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 | *   | <span class='executed'>    function processWithRuntime(</span>
 52 |     | <span class='neutral'>        bytes32 nodeId,</span>
 53 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 54 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 55 | *   | <span class='executed'>    ) external view returns (NodeOutput.Data memory node) {</span>
 56 | *   | <span class='executed'>        return nodes[nodeId];</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'>}</span>
 59 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockPyth.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Apache-2.0</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 | *   | <span class='executed'>contract MockPyth {</span>
  5 |     | <span class='neutral'>    struct Price {</span>
  6 |     | <span class='neutral'>        // Price</span>
  7 |     | <span class='neutral'>        int64 price;</span>
  8 |     | <span class='neutral'>        // Confidence interval around the price</span>
  9 |     | <span class='neutral'>        uint64 conf;</span>
 10 |     | <span class='neutral'>        // Price exponent</span>
 11 |     | <span class='neutral'>        int32 expo;</span>
 12 |     | <span class='neutral'>        // Unix timestamp describing when the price was published</span>
 13 |     | <span class='neutral'>        uint256 publishTime;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // PriceFeed represents a current aggregate price from pyth publisher feeds.</span>
 17 |     | <span class='neutral'>    struct PriceFeed {</span>
 18 |     | <span class='neutral'>        // The price ID.</span>
 19 |     | <span class='neutral'>        bytes32 id;</span>
 20 |     | <span class='neutral'>        // Latest available price</span>
 21 |     | <span class='neutral'>        Price price;</span>
 22 |     | <span class='neutral'>        // Latest available exponentially-weighted moving average price</span>
 23 |     | <span class='neutral'>        Price emaPrice;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    error InsufficientFee();</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    mapping(bytes32 =&gt; PriceFeed[]) priceFeeds;</span>
 29 |     | <span class='neutral'>    bytes32[] activeFeeds;</span>
 30 |     | <span class='neutral'>    uint256 requiredFee;</span>
 31 |     | <span class='neutral'></span>
 32 | *   | <span class='executed'>    function addPriceFeed(</span>
 33 |     | <span class='neutral'>        bytes32 id,</span>
 34 |     | <span class='neutral'>        int64 startingPrice,</span>
 35 |     | <span class='neutral'>        uint64 startingConf,</span>
 36 |     | <span class='neutral'>        int32 startingExpo</span>
 37 |     | <span class='neutral'>    ) external {</span>
 38 |     | <span class='unexecuted'>        priceFeeds[id].push(</span>
 39 |     | <span class='unexecuted'>            PriceFeed({</span>
 40 |     | <span class='unexecuted'>                id: id,</span>
 41 |     | <span class='unexecuted'>                price: Price({</span>
 42 |     | <span class='unexecuted'>                    price: startingPrice,</span>
 43 |     | <span class='unexecuted'>                    conf: startingConf,</span>
 44 |     | <span class='unexecuted'>                    expo: startingExpo,</span>
 45 |     | <span class='unexecuted'>                    publishTime: block.timestamp</span>
 46 |     | <span class='neutral'>                }),</span>
 47 |     | <span class='unexecuted'>                emaPrice: Price({</span>
 48 |     | <span class='unexecuted'>                    price: startingPrice,</span>
 49 |     | <span class='unexecuted'>                    conf: startingConf,</span>
 50 |     | <span class='unexecuted'>                    expo: startingExpo,</span>
 51 |     | <span class='unexecuted'>                    publishTime: block.timestamp</span>
 52 |     | <span class='neutral'>                })</span>
 53 |     | <span class='neutral'>            })</span>
 54 |     | <span class='neutral'>        );</span>
 55 |     | <span class='unexecuted'>        activeFeeds.push(id);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>    function setRequiredFee(uint256 newFee) external {</span>
 59 |     | <span class='unexecuted'>        requiredFee = newFee;</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 | *   | <span class='executed'>    function changePrice(bytes32 id, int64 newPrice) external {</span>
 63 | *   | <span class='executed'>        priceFeeds[id][0].price.price = newPrice;</span>
 64 | *   | <span class='executed'>        priceFeeds[id][0].price.publishTime = block.timestamp;</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function parsePriceFeedUpdatesUnique(</span>
 68 |     | <span class='neutral'>        bytes[] calldata updateData,</span>
 69 |     | <span class='neutral'>        bytes32[] calldata priceIds,</span>
 70 |     | <span class='neutral'>        uint64 minPublishTime,</span>
 71 |     | <span class='neutral'>        uint64 maxPublishTime</span>
 72 |     | <span class='unexecuted'>    ) external payable returns (PriceFeed[] memory feeds) {</span>
 73 |     | <span class='unexecuted'>        if (msg.value &lt; requiredFee) revert InsufficientFee();</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>        return priceFeeds[priceIds[0]];</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>    function getCurrentPrice(bytes32 id) external returns (int64) {</span>
 79 |     | <span class='unexecuted'>        return priceFeeds[id][0].price.price;</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'>}</span>
 82 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockRewardDistributor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IRewardDistributor} from &quot;@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IERC165} from &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./MockSynthetixV3.sol&quot;;</span>
   7 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 | *   | <span class='executed'>contract MockRewardDistributor {</span>
  10 |     | <span class='neutral'>    MockSynthetixV3 v3Mock;</span>
  11 | *   | <span class='executed'>    uint128 public poolId;</span>
  12 |     | <span class='unexecuted'>    uint public collateralId;</span>
  13 |     | <span class='unexecuted'>    constructor(MockSynthetixV3 _v3Mock, uint128 _poolId, uint _collateralId) {</span>
  14 |     | <span class='unexecuted'>        v3Mock = _v3Mock;</span>
  15 |     | <span class='unexecuted'>        poolId = _poolId;</span>
  16 |     | <span class='unexecuted'>        collateralId = _collateralId;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 | *   | <span class='executed'>    function getPoolId() external view returns (uint128) {</span>
  20 |     | <span class='unexecuted'>        return poolId;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>    function getPoolCollateralTypes() external view returns (address[] memory) {</span>
  24 | *   | <span class='executed'>        return v3Mock.getCollateralTypes();</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 | *   | <span class='executed'>    function distributeRewards(</span>
  28 |     | <span class='neutral'>        uint128 poolId_,</span>
  29 |     | <span class='neutral'>        address collateralType_,</span>
  30 |     | <span class='neutral'>        uint256 amount_,</span>
  31 |     | <span class='neutral'>        uint64 start_,</span>
  32 |     | <span class='neutral'>        uint32 duration_</span>
  33 |     | <span class='neutral'>    ) external {</span>
  34 |     | <span class='neutral'>        // distribute a portion of debt rewards to different vaults</span>
  35 |     | <span class='neutral'>        // TODO: commenting out temporarily to resolve issues in LiquidationModule coverage</span>
  36 |     | <span class='neutral'>        // v3Mock.updateRewardDistribution(collateralType, amount);</span>
  37 | *   | <span class='executed'>        console2.log(</span>
  38 |     | <span class='neutral'>            &quot;====== MockRewardDistributor::distributeRewards END ======&quot;</span>
  39 |     | <span class='neutral'>        );</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>        Below are required for passing safeSupportsInterface when calling MarginModule::setMarginCollateralConfiguration</span>
  44 |     | <span class='neutral'>    */</span>
  45 |     | <span class='unexecuted'>    function name() external view returns (string memory) {</span>
  46 |     | <span class='unexecuted'>        return &quot;MockRewardDistributor&quot;;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function payout(</span>
  50 |     | <span class='neutral'>        uint128 accountId,</span>
  51 |     | <span class='neutral'>        uint128 poolId,</span>
  52 |     | <span class='neutral'>        address collateralType,</span>
  53 |     | <span class='neutral'>        address sender,</span>
  54 |     | <span class='neutral'>        uint256 amount</span>
  55 |     | <span class='unexecuted'>    ) external returns (bool) {</span>
  56 |     | <span class='neutral'>        // check if user is actually deposited into the vault and has shares</span>
  57 |     | <span class='unexecuted'>        require(v3Mock.getShares(sender, collateralType));</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // calculate how much a user is owed based on their share of the vault</span>
  60 |     | <span class='neutral'>        // each user&#39;s deposit in a vault is 1 share for simplification</span>
  61 |     | <span class='unexecuted'>        (, , , uint256 rewardAmount, uint256 totalShares) = v3Mock.vaults(</span>
  62 |     | <span class='neutral'>            collateralType</span>
  63 |     | <span class='neutral'>        );</span>
  64 |     | <span class='unexecuted'>        uint256 percentOfVault = (1 * 1e18) / (totalShares * 1e18);</span>
  65 |     | <span class='unexecuted'>        uint256 amountOfRewards = percentOfVault * rewardAmount;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        if (amount &lt;= amountOfRewards) {</span>
  68 |     | <span class='unexecuted'>            MockERC20(collateralType).transfer(sender, amount);</span>
  69 |     | <span class='unexecuted'>            return true;</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        return false;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function onPositionUpdated(</span>
  76 |     | <span class='neutral'>        uint128 accountId,</span>
  77 |     | <span class='neutral'>        uint128 poolId,</span>
  78 |     | <span class='neutral'>        address collateralType,</span>
  79 |     | <span class='neutral'>        uint256 newShares</span>
  80 |     | <span class='neutral'>    ) external {}</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /// @notice Address to ERC-20 token distributed by this distributor, for display purposes only</span>
  83 |     | <span class='neutral'>    /// @dev Return address(0) if providing non ERC-20 rewards</span>
  84 | *   | <span class='executed'>    function token() external view returns (address) {</span>
  85 |     | <span class='neutral'>        return</span>
  86 | *   | <span class='executed'>            collateralId == 1</span>
  87 | *   | <span class='executed'>                ? v3Mock.wETH()</span>
  88 | *   | <span class='executed'>                : collateralId == 2</span>
  89 | *   | <span class='executed'>                    ? v3Mock.wBTC()</span>
  90 | *   | <span class='executed'>                    : v3Mock.huge();</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 | *   | <span class='executed'>    function supportsInterface(</span>
  94 |     | <span class='neutral'>        bytes4 interfaceId</span>
  95 |     | <span class='unexecuted'>    ) public view virtual returns (bool) {</span>
  96 |     | <span class='unexecuted'>        return</span>
  97 |     | <span class='unexecuted'>            interfaceId == type(IRewardDistributor).interfaceId ||</span>
  98 |     | <span class='unexecuted'>            interfaceId == this.supportsInterface.selector;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'>}</span>
 101 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 | *   | <span class='executed'>contract MockRouter {</span>
  5 |     | <span class='neutral'>    event AddedFunctionAndImplementation(bytes4 selector, address implementation);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    error UnknownSelector(bytes4 sel);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    // selector =&gt; implementation address</span>
 10 |     | <span class='neutral'>    mapping(bytes4 =&gt; address) implementations;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function addFunctionAndImplementation(bytes4 selector, address implementation) external {</span>
 13 |     | <span class='unexecuted'>        implementations[selector] = implementation;</span>
 14 |     | <span class='unexecuted'>        emit AddedFunctionAndImplementation(selector, implementation);</span>
 15 |     | <span class='unexecuted'>        if (implementation == address(0)) {</span>
 16 |     | <span class='unexecuted'>            revert();</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    fallback() external payable {</span>
 21 |     | <span class='neutral'>        // Lookup table: Function selector =&gt; implementation contract</span>
 22 | *   | <span class='executed'>        bytes4 selector = msg.sig;</span>
 23 | *   | <span class='executed'>        address implementation = implementations[selector];</span>
 24 |     | <span class='neutral'></span>
 25 | *   | <span class='executed'>        if (implementation == address(0)) {</span>
 26 |     | <span class='unexecuted'>            revert UnknownSelector(selector);</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>        // Delegatecall to the implementation contract</span>
 30 |     | <span class='neutral'>        assembly {</span>
 31 | *   | <span class='executed'>            calldatacopy(0, 0, calldatasize())</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 34 | *   | <span class='executed'>            returndatacopy(0, 0, returndatasize())</span>
 35 |     | <span class='neutral'></span>
 36 | *   | <span class='executed'>            switch result</span>
 37 | *   | <span class='executed'>            case 0 {</span>
 38 | *   | <span class='executed'>                revert(0, returndatasize())</span>
 39 |     | <span class='neutral'>            }</span>
 40 |     | <span class='neutral'>            default {</span>
 41 | *   | <span class='executed'>                return(0, returndatasize())</span>
 42 |     | <span class='neutral'>            }</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockSpotMarket.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'>import &quot;./MockSynthetixV3.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./MockOracleManager.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 | *   | <span class='executed'>contract MockSpotMarket {</span>
   9 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    enum TransactionType {</span>
  12 |     | <span class='neutral'>        NULL, // reserved for 0 (default value)</span>
  13 |     | <span class='neutral'>        BUY,</span>
  14 |     | <span class='neutral'>        SELL,</span>
  15 |     | <span class='neutral'>        ASYNC_BUY,</span>
  16 |     | <span class='neutral'>        ASYNC_SELL,</span>
  17 |     | <span class='neutral'>        WRAP,</span>
  18 |     | <span class='neutral'>        UNWRAP</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    enum PriceTolerance {</span>
  22 |     | <span class='neutral'>        DEFAULT,</span>
  23 |     | <span class='neutral'>        STRICT</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    MockSynthetixV3 v3Mock;</span>
  27 |     | <span class='neutral'>    MockOracleManager mockOracleManager;</span>
  28 |     | <span class='neutral'>    address wethTokenMock;</span>
  29 |     | <span class='neutral'>    address wbtcTokenMock;</span>
  30 |     | <span class='neutral'>    address hugeTokenMock;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    bytes32 WETH_ORACLE_NODE_ID;</span>
  33 |     | <span class='neutral'>    bytes32 WBTC_ORACLE_NODE_ID;</span>
  34 |     | <span class='neutral'>    bytes32 HUGE_ORACLE_NODE_ID;</span>
  35 |     | <span class='neutral'>    uint WETH_MARKET_SKEW_SCALE;</span>
  36 |     | <span class='neutral'>    uint WBTC_MARKET_SKEW_SCALE;</span>
  37 |     | <span class='neutral'>    uint HUGE_MARKET_SKEW_SCALE;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    constructor(</span>
  40 |     | <span class='neutral'>        MockSynthetixV3 _v3Mock,</span>
  41 |     | <span class='neutral'>        MockOracleManager _mockOracleManager,</span>
  42 |     | <span class='neutral'>        address _weth,</span>
  43 |     | <span class='neutral'>        uint _wethMarketSkewScale,</span>
  44 |     | <span class='neutral'>        address _wbtc,</span>
  45 |     | <span class='neutral'>        uint _wbtcMarketSkewScale,</span>
  46 |     | <span class='neutral'>        address _huge,</span>
  47 |     | <span class='neutral'>        uint _hugeMarketSkewScale,</span>
  48 |     | <span class='neutral'>        bytes32 _wethOracleNodeId,</span>
  49 |     | <span class='neutral'>        bytes32 _wbtcOracleNodeId,</span>
  50 |     | <span class='neutral'>        bytes32 _hugeOracleNodeId</span>
  51 |     | <span class='neutral'>    ) {</span>
  52 |     | <span class='unexecuted'>        v3Mock = _v3Mock;</span>
  53 |     | <span class='unexecuted'>        mockOracleManager = _mockOracleManager;</span>
  54 |     | <span class='unexecuted'>        wethTokenMock = _weth;</span>
  55 |     | <span class='unexecuted'>        WETH_MARKET_SKEW_SCALE = _wethMarketSkewScale;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        wbtcTokenMock = _wbtc;</span>
  58 |     | <span class='unexecuted'>        WBTC_MARKET_SKEW_SCALE = _wbtcMarketSkewScale;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        hugeTokenMock = _huge;</span>
  61 |     | <span class='unexecuted'>        HUGE_MARKET_SKEW_SCALE = _hugeMarketSkewScale;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        WETH_ORACLE_NODE_ID = _wethOracleNodeId;</span>
  64 |     | <span class='unexecuted'>        WBTC_ORACLE_NODE_ID = _wbtcOracleNodeId;</span>
  65 |     | <span class='unexecuted'>        HUGE_ORACLE_NODE_ID = _hugeOracleNodeId;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    mapping(uint128 marketId =&gt; address synthAddress) public synth;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function setSynthForMarketId(</span>
  71 |     | <span class='neutral'>        uint128[] memory marketIds,</span>
  72 |     | <span class='neutral'>        address[] memory synthAddresses</span>
  73 |     | <span class='neutral'>    ) public {</span>
  74 |     | <span class='unexecuted'>        require(</span>
  75 |     | <span class='unexecuted'>            marketIds.length == synthAddresses.length,</span>
  76 |     | <span class='neutral'>            &quot;Input arrays must have the same length&quot;</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; marketIds.length; i++) {</span>
  79 |     | <span class='unexecuted'>            synth[marketIds[i]] = synthAddresses[i];</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function getSynth(</span>
  84 |     | <span class='neutral'>        uint128 marketId</span>
  85 | *   | <span class='executed'>    ) public view returns (address synthAddress) {</span>
  86 | *   | <span class='executed'>        return synth[marketId];</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function getMarketSkewScale(</span>
  90 |     | <span class='neutral'>        uint128 synthMarketId</span>
  91 | *   | <span class='executed'>    ) external view returns (uint128 skewScale) {</span>
  92 | *   | <span class='executed'>        if (getSynth(synthMarketId) == address(wethTokenMock)) {</span>
  93 | *   | <span class='executed'>            return uint128(WETH_MARKET_SKEW_SCALE);</span>
  94 |     | <span class='neutral'>        }</span>
  95 | *   | <span class='executed'>        if (getSynth(synthMarketId) == address(wbtcTokenMock)) {</span>
  96 | *   | <span class='executed'>            return uint128(WBTC_MARKET_SKEW_SCALE);</span>
  97 |     | <span class='neutral'>        }</span>
  98 | *   | <span class='executed'>        if (getSynth(synthMarketId) == address(hugeTokenMock)) {</span>
  99 |     | <span class='unexecuted'>            return uint128(HUGE_MARKET_SKEW_SCALE);</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>    function indexPrice(</span>
 104 |     | <span class='neutral'>        uint128 marketId,</span>
 105 |     | <span class='neutral'>        uint128 transactionType,</span>
 106 |     | <span class='neutral'>        PriceTolerance priceTolerance</span>
 107 | *   | <span class='executed'>    ) public returns (uint256) {</span>
 108 | *   | <span class='executed'>        bytes32 nodeid;</span>
 109 |     | <span class='neutral'></span>
 110 | *   | <span class='executed'>        require(marketId &lt;= 3, &quot;Only 3 markets was implemented&quot;);</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>        TransactionType txnType = loadValidTransactionType(transactionType);</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>        if (marketId == 1) {</span>
 115 | *   | <span class='executed'>            nodeid = WETH_ORACLE_NODE_ID;</span>
 116 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
 117 | *   | <span class='executed'>            nodeid = WBTC_ORACLE_NODE_ID;</span>
 118 | *   | <span class='executed'>        } else if (marketId == 3) {</span>
 119 |     | <span class='unexecuted'>            nodeid = HUGE_ORACLE_NODE_ID;</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        return mockOracleManager.process(nodeid).price.toUint();</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 | *   | <span class='executed'>    function loadValidTransactionType(</span>
 126 |     | <span class='neutral'>        uint128 txnType</span>
 127 | *   | <span class='executed'>    ) internal pure returns (TransactionType) {</span>
 128 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
 129 | *   | <span class='executed'>        uint128 txnTypeMax = uint128(TransactionType.UNWRAP);</span>
 130 | *   | <span class='executed'>        if (txnType &gt; txnTypeMax) {</span>
 131 |     | <span class='unexecuted'>            revert(&quot;Invalid transaction type&quot;);</span>
 132 |     | <span class='neutral'>        }</span>
 133 | *   | <span class='executed'>        return TransactionType(txnType);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockSynthetixV3.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {INodeModule, NodeOutput} from &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   6 |     | <span class='neutral'>import {MockERC20} from &quot;./MockERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MockOracleManager} from &quot;./MockOracleManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MathUtil} from &quot;../../utils/MathUtil.sol&quot;;</span>
   9 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>struct Vault {</span>
  12 |     | <span class='neutral'>    address collateralToken;</span>
  13 |     | <span class='neutral'>    bytes32 nodeId; // the nodeId used in oracleManager to return the price for a give collateral type</span>
  14 |     | <span class='neutral'>    uint256 collateralAmount; // the amount of a given collateral held in SynthetixV3</span>
  15 |     | <span class='neutral'>    uint256 rewardAmount; // reward amount accumulated for a debt distribution during a liquidation event</span>
  16 |     | <span class='neutral'>    uint256 totalShares; // the total amount of shares that exist in the vault</span>
  17 |     | <span class='neutral'>}</span>
  18 |     | <span class='neutral'>struct Cache {</span>
  19 |     | <span class='neutral'>    uint256 sUSDBalance;</span>
  20 |     | <span class='neutral'>    uint256 wETHBalance;</span>
  21 |     | <span class='neutral'>    uint256 wBTCBalance;</span>
  22 |     | <span class='neutral'>    uint256 hugeBalance;</span>
  23 |     | <span class='neutral'>    bytes32 sUSDNodeId;</span>
  24 |     | <span class='neutral'>    bytes32 wETHNodeId;</span>
  25 |     | <span class='neutral'>    bytes32 wBTCNodeId;</span>
  26 |     | <span class='neutral'>    bytes32 hugeNodeId;</span>
  27 |     | <span class='neutral'>    NodeOutput.Data sUSDNode;</span>
  28 |     | <span class='neutral'>    NodeOutput.Data wETHNode;</span>
  29 |     | <span class='neutral'>    NodeOutput.Data wBTCNode;</span>
  30 |     | <span class='neutral'>    NodeOutput.Data hugeNode;</span>
  31 |     | <span class='neutral'>    uint256 valueSUSD;</span>
  32 |     | <span class='neutral'>    uint256 valueWETH;</span>
  33 |     | <span class='neutral'>    uint256 valuewBTC;</span>
  34 |     | <span class='neutral'>    uint256 valuehuge;</span>
  35 |     | <span class='neutral'>}</span>
  36 | *   | <span class='executed'>contract MockSynthetixV3 {</span>
  37 |     | <span class='neutral'>    address oracleManager;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    address public sUSD;</span>
  40 | *   | <span class='executed'>    address public wETH;</span>
  41 | *   | <span class='executed'>    address public wBTC;</span>
  42 |     | <span class='unexecuted'>    address public huge;</span>
  43 |     | <span class='unexecuted'>    uint256 public withdrawableUSD;</span>
  44 | *   | <span class='executed'>    uint256 public creditCapacity;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    mapping(address collateralToken =&gt; Vault) public vaults;</span>
  47 |     | <span class='unexecuted'>    mapping(address user =&gt; mapping(address collateralToken =&gt; bool deposited))</span>
  48 |     | <span class='neutral'>        public shares; // mock implementation of vault shares where each user gets 1 share of the vault they&#39;re depositing into, independent of deposit size for simplicity, since each user gets one share, just need to know if they&#39;re deposited into a vault</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    event DepositMarketUsd(uint128 marketId, address msgSender, uint256 amount);</span>
  51 |     | <span class='neutral'>    event DepositMarketUsdAfter(</span>
  52 |     | <span class='neutral'>        uint128 marketId,</span>
  53 |     | <span class='neutral'>        address msgSender,</span>
  54 |     | <span class='neutral'>        uint256 amount</span>
  55 |     | <span class='neutral'>    );</span>
  56 |     | <span class='neutral'></span>
  57 | *   | <span class='executed'>    uint256 constant FEE_PERCENT = 0.01e18;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>        Getters</span>
  61 |     | <span class='neutral'>    */</span>
  62 | *   | <span class='executed'>    function getUsdToken() external view returns (address) {</span>
  63 |     | <span class='unexecuted'>        return sUSD;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function getAssociatedSystem(</span>
  67 |     | <span class='neutral'>        bytes32 id</span>
  68 |     | <span class='unexecuted'>    ) external returns (address, bytes32) {</span>
  69 |     | <span class='unexecuted'>        if (id == vaults[sUSD].nodeId) {</span>
  70 |     | <span class='unexecuted'>            return (vaults[sUSD].collateralToken, &quot;&quot;);</span>
  71 |     | <span class='unexecuted'>        } else if (id == vaults[wETH].nodeId) {</span>
  72 |     | <span class='unexecuted'>            return (vaults[wETH].collateralToken, &quot;&quot;);</span>
  73 |     | <span class='unexecuted'>        } else if (id == vaults[wBTC].nodeId) {</span>
  74 |     | <span class='unexecuted'>            return (vaults[wBTC].collateralToken, &quot;&quot;);</span>
  75 |     | <span class='unexecuted'>        } else if (id == vaults[huge].nodeId) {</span>
  76 |     | <span class='unexecuted'>            return (vaults[huge].collateralToken, &quot;&quot;);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function getOracleManager() external returns (address) {</span>
  81 |     | <span class='unexecuted'>        return oracleManager;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>    function getWithdrawableMarketUsd(</span>
  85 |     | <span class='neutral'>        uint128 marketId</span>
  86 | *   | <span class='executed'>    ) external view returns (uint256 withdrawableUsd) {</span>
  87 | *   | <span class='executed'>        console2.log(</span>
  88 |     | <span class='neutral'>            &quot;===== MockSynthetixV3::getWithdrawableMarketUsd START =====&quot;</span>
  89 |     | <span class='neutral'>        );</span>
  90 | *   | <span class='executed'>        console2.log(&quot;marketId&quot;, marketId);</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>        Cache memory cache;</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        cache.sUSDBalance = MockERC20(sUSD).balanceOf(address(this));</span>
  95 | *   | <span class='executed'>        console2.log(&quot;sUSDBalance&quot;, cache.sUSDBalance);</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>        cache.wETHBalance = MockERC20(wETH).balanceOf(address(this));</span>
  98 | *   | <span class='executed'>        console2.log(&quot;wETHBalance&quot;, cache.wETHBalance);</span>
  99 |     | <span class='neutral'></span>
 100 | *   | <span class='executed'>        cache.wBTCBalance = MockERC20(wBTC).balanceOf(address(this));</span>
 101 | *   | <span class='executed'>        console2.log(&quot;wBTCBalance&quot;, cache.wBTCBalance);</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>        cache.hugeBalance = MockERC20(huge).balanceOf(address(this));</span>
 104 | *   | <span class='executed'>        console2.log(&quot;hugeBalance&quot;, cache.hugeBalance);</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>        cache.sUSDNodeId = vaults[sUSD].nodeId;</span>
 107 | *   | <span class='executed'>        console2.log(&quot;sUSDNodeId&quot;);</span>
 108 | *   | <span class='executed'>        console2.logBytes32(cache.sUSDNodeId);</span>
 109 |     | <span class='neutral'></span>
 110 | *   | <span class='executed'>        cache.wETHNodeId = vaults[wETH].nodeId;</span>
 111 | *   | <span class='executed'>        console2.log(&quot;wETHNodeId&quot;);</span>
 112 | *   | <span class='executed'>        console2.logBytes32(cache.wETHNodeId);</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>        cache.wBTCNodeId = vaults[wBTC].nodeId;</span>
 115 | *   | <span class='executed'>        console2.log(&quot;wBTCNodeId&quot;);</span>
 116 | *   | <span class='executed'>        console2.logBytes32(cache.wBTCNodeId);</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>        cache.hugeNodeId = vaults[huge].nodeId;</span>
 119 | *   | <span class='executed'>        console2.log(&quot;hugeNodeId&quot;);</span>
 120 | *   | <span class='executed'>        console2.logBytes32(cache.hugeNodeId);</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        cache.sUSDNode = MockOracleManager(oracleManager).process(</span>
 123 | *   | <span class='executed'>            cache.sUSDNodeId</span>
 124 |     | <span class='neutral'>        );</span>
 125 | *   | <span class='executed'>        console2.log(&quot;sUSDNode.price&quot;, cache.sUSDNode.price);</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>        cache.wETHNode = MockOracleManager(oracleManager).process(</span>
 128 | *   | <span class='executed'>            cache.wETHNodeId</span>
 129 |     | <span class='neutral'>        );</span>
 130 | *   | <span class='executed'>        console2.log(&quot;wETHNode.price&quot;, cache.wETHNode.price);</span>
 131 |     | <span class='neutral'></span>
 132 | *   | <span class='executed'>        cache.wBTCNode = MockOracleManager(oracleManager).process(</span>
 133 | *   | <span class='executed'>            cache.wBTCNodeId</span>
 134 |     | <span class='neutral'>        );</span>
 135 | *   | <span class='executed'>        console2.log(&quot;wBTCNode.price&quot;, cache.wBTCNode.price);</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>        cache.hugeNode = MockOracleManager(oracleManager).process(</span>
 138 | *   | <span class='executed'>            cache.hugeNodeId</span>
 139 |     | <span class='neutral'>        );</span>
 140 | *   | <span class='executed'>        console2.log(&quot;hugeNode.price&quot;, cache.hugeNode.price);</span>
 141 |     | <span class='neutral'></span>
 142 | *   | <span class='executed'>        cache.valueSUSD = uint256(int256(cache.sUSDBalance));</span>
 143 | *   | <span class='executed'>        console2.log(&quot;valueSUSD&quot;, cache.valueSUSD);</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>        cache.valueWETH = uint256(</span>
 146 | *   | <span class='executed'>            (int256(cache.wETHBalance) * cache.wETHNode.price) / 1e18</span>
 147 |     | <span class='neutral'>        );</span>
 148 | *   | <span class='executed'>        console2.log(&quot;valueWETH&quot;, cache.valueWETH);</span>
 149 |     | <span class='neutral'></span>
 150 | *   | <span class='executed'>        cache.valuewBTC = uint256(</span>
 151 | *   | <span class='executed'>            (int256(cache.wBTCBalance) * cache.wBTCNode.price) / 1e18</span>
 152 |     | <span class='neutral'>        );</span>
 153 | *   | <span class='executed'>        console2.log(&quot;valuewBTC&quot;, cache.valuewBTC);</span>
 154 |     | <span class='neutral'></span>
 155 | *   | <span class='executed'>        cache.valuehuge = uint256(</span>
 156 | *   | <span class='executed'>            (int256(cache.hugeBalance) * cache.hugeNode.price) / 1e18</span>
 157 |     | <span class='neutral'>        );</span>
 158 | *   | <span class='executed'>        console2.log(&quot;valuehuge&quot;, cache.valuehuge);</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>        withdrawableUsd = MathUtil.min(</span>
 161 | *   | <span class='executed'>            creditCapacity +</span>
 162 | *   | <span class='executed'>                (cache.valueSUSD +</span>
 163 | *   | <span class='executed'>                    cache.valueWETH +</span>
 164 | *   | <span class='executed'>                    cache.valuewBTC +</span>
 165 | *   | <span class='executed'>                    cache.valuehuge),</span>
 166 |     | <span class='neutral'>            type(uint128).max</span>
 167 |     | <span class='neutral'>        );</span>
 168 | *   | <span class='executed'>        console2.log(&quot;withdrawableUsd&quot;, withdrawableUsd);</span>
 169 |     | <span class='neutral'></span>
 170 | *   | <span class='executed'>        console2.log(</span>
 171 |     | <span class='neutral'>            &quot;===== MockSynthetixV3::getWithdrawableMarketUsd END =====&quot;</span>
 172 |     | <span class='neutral'>        );</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    event Debug(string s);</span>
 176 |     | <span class='neutral'>    event DebugValue(int256 val);</span>
 177 | *   | <span class='executed'>    function getVaultCollateral(</span>
 178 |     | <span class='neutral'>        uint128 poolId,</span>
 179 |     | <span class='neutral'>        address collateralType</span>
 180 | *   | <span class='executed'>    ) public returns (uint256 amount, uint256 value) {</span>
 181 | *   | <span class='executed'>        amount = vaults[collateralType].collateralAmount;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>        // poolId is irrelevant because assuming only one pool exists so just query using the collateralType id here</span>
 184 | *   | <span class='executed'>        bytes32 nodeId = vaults[collateralType].nodeId;</span>
 185 |     | <span class='neutral'>        // NodeOutput.Data memory node = MockOracleManager(oracleManager).process(nodeId);</span>
 186 |     | <span class='neutral'>        // emit DebugValue(node.price);</span>
 187 |     | <span class='neutral'>        // value = uint256(int256(amount) * node.price);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        // TODO: temporary fix to work around StateChangeWhileStatic error</span>
 190 |     | <span class='neutral'>        // assumes price of 1</span>
 191 | *   | <span class='executed'>        value = amount * 1;</span>
 192 |     | <span class='neutral'>        // emit Debug(&quot;getVaultCollateral&quot;);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /// @notice assumes that there&#39;s only one pool in the system</span>
 196 |     | <span class='neutral'>    /// @dev added to simplify fetching collaterals for MockRewardDistributor</span>
 197 |     | <span class='unexecuted'>    function getCollateralTypes() external view returns (address[] memory) {</span>
 198 |     | <span class='unexecuted'>        address[] memory collateralTypes = new address[](4);</span>
 199 |     | <span class='unexecuted'>        collateralTypes[0] = sUSD;</span>
 200 |     | <span class='unexecuted'>        collateralTypes[1] = wETH;</span>
 201 |     | <span class='unexecuted'>        collateralTypes[2] = wBTC;</span>
 202 |     | <span class='unexecuted'>        collateralTypes[3] = huge;</span>
 203 |     | <span class='unexecuted'>        return collateralTypes;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 | *   | <span class='executed'>    function getShares(</span>
 207 |     | <span class='neutral'>        address user,</span>
 208 |     | <span class='neutral'>        address collateral</span>
 209 |     | <span class='unexecuted'>    ) external view returns (bool) {</span>
 210 |     | <span class='unexecuted'>        return shares[user][collateral];</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /** </span>
 214 |     | <span class='neutral'>        Admin</span>
 215 |     | <span class='neutral'>    */</span>
 216 |     | <span class='unexecuted'>    function setUSDToken(address _usdToken, bytes32 _nodeId) external {</span>
 217 |     | <span class='unexecuted'>        sUSD = _usdToken;</span>
 218 |     | <span class='unexecuted'>        vaults[_usdToken].nodeId = _nodeId;</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>    function setWethToken(address _wethToken, bytes32 _nodeId) external {</span>
 222 |     | <span class='unexecuted'>        wETH = _wethToken;</span>
 223 |     | <span class='unexecuted'>        vaults[_wethToken].nodeId = _nodeId;</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>    function setWbtcToken(address _wbtcToken, bytes32 _nodeId) external {</span>
 227 |     | <span class='unexecuted'>        wBTC = _wbtcToken;</span>
 228 |     | <span class='unexecuted'>        vaults[_wbtcToken].nodeId = _nodeId;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 | *   | <span class='executed'>    function setHugeToken(address _hugeToken, bytes32 _nodeId) external {</span>
 232 |     | <span class='unexecuted'>        huge = _hugeToken;</span>
 233 |     | <span class='unexecuted'>        vaults[_hugeToken].nodeId = _nodeId;</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>    function setOracleManager(address _oracleManager) external {</span>
 237 |     | <span class='unexecuted'>        oracleManager = _oracleManager;</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>    function registerMarket(address market) external returns (uint128) {</span>
 241 |     | <span class='unexecuted'>        return 1;</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>    function setCollateralPrice(</span>
 245 |     | <span class='neutral'>        address collateralType,</span>
 246 |     | <span class='neutral'>        uint256 newPrice</span>
 247 |     | <span class='unexecuted'>    ) external {</span>
 248 |     | <span class='unexecuted'>        bytes32 nodeId = vaults[collateralType].nodeId;</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>        // this needs to use the MockOracleManager to set the price for a given collateral type</span>
 251 |     | <span class='unexecuted'>        MockOracleManager(oracleManager).changePrice(nodeId, int256(newPrice));</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /// @notice only used by MockRewardDistributor to simulate distributing reward shares</span>
 255 |     | <span class='unexecuted'>    function updateRewardDistribution(</span>
 256 |     | <span class='neutral'>        address collateralToken,</span>
 257 |     | <span class='neutral'>        uint256 amount</span>
 258 |     | <span class='neutral'>    ) external {</span>
 259 |     | <span class='unexecuted'>        vaults[collateralToken].rewardAmount += amount;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 | *   | <span class='executed'>    function updateCreditCapacity(uint256 amount, bool increase) external {</span>
 263 | *   | <span class='executed'>        if (increase) {</span>
 264 |     | <span class='unexecuted'>            creditCapacity += amount;</span>
 265 |     | <span class='neutral'>        } else {</span>
 266 | *   | <span class='executed'>            creditCapacity -= amount;</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    /**</span>
 271 |     | <span class='neutral'>        User Actions</span>
 272 |     | <span class='neutral'>    */</span>
 273 | *   | <span class='executed'>    function mintUSDToSynthetix(uint256 toMint) external {</span>
 274 | *   | <span class='executed'>        MockERC20(sUSD).mint(address(this), toMint);</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 | *   | <span class='executed'>    function burnUSDFromSynthetix(uint256 toBurn) external {</span>
 278 | *   | <span class='executed'>        MockERC20(sUSD).burn(address(this), toBurn);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 | *   | <span class='executed'>    function depositMarketUsd(</span>
 282 |     | <span class='neutral'>        uint128 marketId,</span>
 283 |     | <span class='neutral'>        address msgSender,</span>
 284 |     | <span class='neutral'>        uint256 amount</span>
 285 | *   | <span class='executed'>    ) external returns (uint256) {</span>
 286 | *   | <span class='executed'>        MockERC20(sUSD).burn(msgSender, amount);</span>
 287 | *   | <span class='executed'>        MockERC20(sUSD).mint(address(1), (amount * FEE_PERCENT) / 1e18);</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>        // accounting for user shares for handling rewards that get distributed in a liquidation event</span>
 290 | *   | <span class='executed'>        vaults[sUSD].totalShares += 1;</span>
 291 | *   | <span class='executed'>        shares[msgSender][sUSD] = true;</span>
 292 | *   | <span class='executed'>        creditCapacity += (amount - (amount * FEE_PERCENT) / 1e18);</span>
 293 |     | <span class='neutral'></span>
 294 | *   | <span class='executed'>        return (amount * FEE_PERCENT) / 1e18;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    // function withdrawMarketUsd(</span>
 298 |     | <span class='neutral'>    //     uint128 marketId,</span>
 299 |     | <span class='neutral'>    //     address target,</span>
 300 |     | <span class='neutral'>    //     uint256 amount</span>
 301 |     | <span class='neutral'>    // ) external returns (uint256) {</span>
 302 |     | <span class='neutral'>    //     MockERC20(sUSD).mint(target, amount);</span>
 303 |     | <span class='neutral'>    //     MockERC20(sUSD).mint(address(1), (amount * FEE_PERCENT) / 1e18);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    //     // accounting for user shares for handling rewards that get distributed in a liquidation event</span>
 306 |     | <span class='neutral'>    //     // if the user has shares in the vault, then they should be decremented</span>
 307 |     | <span class='neutral'>    //     if (shares[msg.sender][sUSD]) {</span>
 308 |     | <span class='neutral'>    //         vaults[sUSD].totalShares -= 1;</span>
 309 |     | <span class='neutral'>    //         shares[msg.sender][sUSD] = false;</span>
 310 |     | <span class='neutral'>    //     }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    //     creditCapacity -= (amount + (amount * FEE_PERCENT) / 1e18);</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    //     return (amount * FEE_PERCENT) / 1e18;</span>
 315 |     | <span class='neutral'>    // }</span>
 316 | *   | <span class='executed'>    function withdrawMarketUsd(</span>
 317 |     | <span class='neutral'>        uint128 marketId,</span>
 318 |     | <span class='neutral'>        address target,</span>
 319 |     | <span class='neutral'>        uint256 amount</span>
 320 | *   | <span class='executed'>    ) external returns (uint256) {</span>
 321 | *   | <span class='executed'>        console2.log(&quot;marketId&quot;, marketId);</span>
 322 | *   | <span class='executed'>        console2.log(&quot;target&quot;, target);</span>
 323 | *   | <span class='executed'>        console2.log(&quot;amount&quot;, amount);</span>
 324 |     | <span class='neutral'></span>
 325 | *   | <span class='executed'>        MockERC20(sUSD).mint(target, amount);</span>
 326 | *   | <span class='executed'>        console2.log(&quot;Minted to target&quot;, amount);</span>
 327 |     | <span class='neutral'></span>
 328 | *   | <span class='executed'>        uint256 feeAmount = (amount * FEE_PERCENT) / 1e18;</span>
 329 | *   | <span class='executed'>        console2.log(&quot;feeAmount&quot;, feeAmount);</span>
 330 |     | <span class='neutral'></span>
 331 | *   | <span class='executed'>        MockERC20(sUSD).mint(address(1), feeAmount);</span>
 332 | *   | <span class='executed'>        console2.log(&quot;Minted fee to address(1)&quot;, feeAmount);</span>
 333 |     | <span class='neutral'></span>
 334 | *   | <span class='executed'>        console2.log(&quot;msg.sender&quot;, msg.sender);</span>
 335 | *   | <span class='executed'>        console2.log(</span>
 336 |     | <span class='neutral'>            &quot;shares[msg.sender][sUSD] before&quot;,</span>
 337 | *   | <span class='executed'>            shares[msg.sender][sUSD]</span>
 338 |     | <span class='neutral'>        );</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>        // accounting for user shares for handling rewards that get distributed in a liquidation event</span>
 341 |     | <span class='neutral'>        // if the user has shares in the vault, then they should be decremented</span>
 342 | *   | <span class='executed'>        if (shares[msg.sender][sUSD]) {</span>
 343 |     | <span class='unexecuted'>            console2.log(</span>
 344 |     | <span class='neutral'>                &quot;vaults[sUSD].totalShares before&quot;,</span>
 345 |     | <span class='unexecuted'>                vaults[sUSD].totalShares</span>
 346 |     | <span class='neutral'>            );</span>
 347 |     | <span class='unexecuted'>            vaults[sUSD].totalShares -= 1;</span>
 348 |     | <span class='unexecuted'>            console2.log(</span>
 349 |     | <span class='neutral'>                &quot;vaults[sUSD].totalShares after&quot;,</span>
 350 |     | <span class='unexecuted'>                vaults[sUSD].totalShares</span>
 351 |     | <span class='neutral'>            );</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>            shares[msg.sender][sUSD] = false;</span>
 354 | *   | <span class='executed'>            console2.log(</span>
 355 |     | <span class='neutral'>                &quot;shares[msg.sender][sUSD] after&quot;,</span>
 356 |     | <span class='unexecuted'>                shares[msg.sender][sUSD]</span>
 357 |     | <span class='neutral'>            );</span>
 358 |     | <span class='neutral'>        }</span>
 359 |     | <span class='neutral'></span>
 360 | *   | <span class='executed'>        console2.log(&quot;creditCapacity before&quot;, creditCapacity);</span>
 361 | *   | <span class='executed'>        creditCapacity -= (amount + feeAmount);</span>
 362 | *   | <span class='executed'>        console2.log(&quot;creditCapacity after&quot;, creditCapacity);</span>
 363 |     | <span class='neutral'></span>
 364 | *   | <span class='executed'>        console2.log(&quot;Returning feeAmount&quot;, feeAmount);</span>
 365 |     | <span class='neutral'>        return feeAmount;</span>
 366 |     | <span class='neutral'>    }</span>
 367 |     | <span class='neutral'>    /// @notice allows a market to deposit collateral</span>
 368 |     | <span class='neutral'>    /// @dev assumes collateral types with 18 decimals</span>
 369 | *   | <span class='executed'>    function depositMarketCollateral(</span>
 370 |     | <span class='neutral'>        uint128 marketId,</span>
 371 |     | <span class='neutral'>        address collateralType,</span>
 372 |     | <span class='neutral'>        uint256 tokenAmount</span>
 373 |     | <span class='neutral'>    ) external {</span>
 374 |     | <span class='neutral'>        // NOTE: no fees accounted for in this deposit function, unlike in depositMarketUsd</span>
 375 |     | <span class='neutral'>        // account for token being deposited into a vault</span>
 376 | *   | <span class='executed'>        vaults[collateralType].collateralAmount += tokenAmount;</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>        // accounting for user shares for handling rewards that get distributed in a liquidation event</span>
 379 | *   | <span class='executed'>        vaults[collateralType].totalShares += 1;</span>
 380 | *   | <span class='executed'>        shares[msg.sender][collateralType] = true;</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        // transfer collateral token</span>
 383 | *   | <span class='executed'>        MockERC20(collateralType).transferFrom(</span>
 384 |     | <span class='neutral'>            msg.sender,</span>
 385 | *   | <span class='executed'>            address(this),</span>
 386 |     | <span class='neutral'>            tokenAmount</span>
 387 |     | <span class='neutral'>        );</span>
 388 |     | <span class='neutral'>    }</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>    /// @notice allows a market to withdraw collateral that it has previously deposited.</span>
 391 |     | <span class='neutral'>    /// @dev marketId is irrelevant because this just mocks total accounting into and out of system</span>
 392 | *   | <span class='executed'>    function withdrawMarketCollateral(</span>
 393 |     | <span class='neutral'>        uint128 marketId,</span>
 394 |     | <span class='neutral'>        address collateralType,</span>
 395 |     | <span class='neutral'>        uint256 tokenAmount</span>
 396 |     | <span class='neutral'>    ) external {</span>
 397 |     | <span class='neutral'>        // account for token being removed from a vault</span>
 398 | *   | <span class='executed'>        vaults[collateralType].collateralAmount -= tokenAmount;</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>        // accounting for user shares for handling rewards that get distributed in a liquidation event</span>
 401 |     | <span class='neutral'>        // vaults[collateralType].totalShares -= 1;</span>
 402 |     | <span class='neutral'>        // shares[msg.sender][collateralType] = false;</span>
 403 |     | <span class='neutral'></span>
 404 | *   | <span class='executed'>        MockERC20(collateralType).transfer(</span>
 405 | *   | <span class='executed'>            ERC2771Context._msgSender(),</span>
 406 |     | <span class='neutral'>            tokenAmount</span>
 407 |     | <span class='neutral'>        );</span>
 408 | *   | <span class='executed'>        emit Debug(&quot;withdraw&quot;);</span>
 409 |     | <span class='neutral'>    }</span>
 410 |     | <span class='neutral'>}</span>
 411 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockVaultModule.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MockSynthetixV3} from &quot;./MockSynthetixV3.sol&quot;;</span>
  5 |     | <span class='neutral'>import {PerpsMarketFactoryModule} from &quot;../../modules/PerpsMarketFactoryModule.sol&quot;;</span>
  6 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 | *   | <span class='executed'>contract MockVaultModule {</span>
  9 |     | <span class='neutral'>    MockSynthetixV3 internal v3Mock;</span>
 10 |     | <span class='neutral'>    PerpsMarketFactoryModule internal perpMarketFactoryModuleImpl;</span>
 11 |     | <span class='neutral'>    address internal perps;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    constructor(MockSynthetixV3 _v3Mock, address _perps) {</span>
 14 |     | <span class='unexecuted'>        v3Mock = _v3Mock;</span>
 15 |     | <span class='unexecuted'>        perps = _perps;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function setPerpMarketFactoryModuleImpl(</span>
 19 |     | <span class='neutral'>        PerpsMarketFactoryModule _perpMarketFactoryModuleImpl</span>
 20 |     | <span class='neutral'>    ) external {</span>
 21 |     | <span class='unexecuted'>        perpMarketFactoryModuleImpl = _perpMarketFactoryModuleImpl;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 | *   | <span class='executed'>    function delegateCollateral(</span>
 25 |     | <span class='neutral'>        uint128 accountId,</span>
 26 |     | <span class='neutral'>        uint128 poolId,</span>
 27 |     | <span class='neutral'>        address collateralType,</span>
 28 |     | <span class='neutral'>        uint256 newCollateralAmountD18,</span>
 29 |     | <span class='neutral'>        uint256 leverage,</span>
 30 |     | <span class='neutral'>        uint128 marketId</span>
 31 | *   | <span class='executed'>    ) external {</span>
 32 | *   | <span class='executed'>        uint256 currentCreditCapacity = v3Mock.creditCapacity();</span>
 33 | *   | <span class='executed'>        newCollateralAmountD18 = newCollateralAmountD18 % 10_000_000 ether;</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>        bool increase;</span>
 36 |     | <span class='neutral'>        // simplifying collateral delegation system from vault by increasing if adding more than current credit capacity and decreasing if less</span>
 37 | *   | <span class='executed'>        if (newCollateralAmountD18 &gt; currentCreditCapacity) {</span>
 38 |     | <span class='unexecuted'>            increase = true;</span>
 39 |     | <span class='unexecuted'>            v3Mock.updateCreditCapacity(newCollateralAmountD18, increase);</span>
 40 | *   | <span class='executed'>        } else {</span>
 41 |     | <span class='neutral'>            // if market is below minimumCredit, LPs are blocked from withdrawals</span>
 42 | *   | <span class='executed'>            (bool success, bytes memory returnData) = perps.call(</span>
 43 | *   | <span class='executed'>                abi.encodeWithSelector(perpMarketFactoryModuleImpl.minimumCredit.selector, marketId)</span>
 44 |     | <span class='neutral'>            );</span>
 45 | *   | <span class='executed'>            assert(success);</span>
 46 | *   | <span class='executed'>            uint128 minimumMarketCreditCapacity = abi.decode(returnData, (uint128));</span>
 47 | *   | <span class='executed'>            console2.log(</span>
 48 |     | <span class='neutral'>                &quot;delegateCollateral::minimumMarketCreditCapacity&quot;,</span>
 49 | *   | <span class='executed'>                minimumMarketCreditCapacity</span>
 50 |     | <span class='neutral'>            );</span>
 51 | *   | <span class='executed'>            require(currentCreditCapacity &gt; minimumMarketCreditCapacity, &quot;isCapacityLocked&quot;);</span>
 52 |     | <span class='neutral'></span>
 53 | *   | <span class='executed'>            increase = false;</span>
 54 | *   | <span class='executed'>            v3Mock.updateCreditCapacity(newCollateralAmountD18, increase);</span>
 55 |     | <span class='neutral'>        }</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./Properties_ORD.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./Properties_LIQ.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./Properties_MGN.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract Properties is Properties_ORD, Properties_MGN, Properties_LIQ {}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/PropertiesBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./PropertiesDescriptions.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../helper/BeforeAfter.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract PropertiesBase is</span>
 10 |     | <span class='neutral'>    FuzzBase,</span>
 11 |     | <span class='neutral'>    BeforeAfter,</span>
 12 |     | <span class='neutral'>    PropertiesDescriptions</span>
 13 |     | <span class='neutral'>{</span>
 14 | *   | <span class='executed'>    function eqWithTolerance(</span>
 15 |     | <span class='neutral'>        uint256 a,</span>
 16 |     | <span class='neutral'>        uint256 b,</span>
 17 |     | <span class='neutral'>        uint256 maxPercentDiff,</span>
 18 |     | <span class='neutral'>        string memory reason</span>
 19 |     | <span class='unexecuted'>    ) internal {</span>
 20 | *   | <span class='executed'>        uint256 percentDiff;</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>        if (a == b) return;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>        if (a &gt; b) {</span>
 25 |     | <span class='unexecuted'>            percentDiff = ((a - b) * 1e18) / ((a + b) / 2);</span>
 26 |     | <span class='neutral'>        } else {</span>
 27 |     | <span class='unexecuted'>            percentDiff = ((b - a) * 1e18) / ((a + b) / 2);</span>
 28 |     | <span class='neutral'>        }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        if (percentDiff &gt; maxPercentDiff) {</span>
 31 |     | <span class='unexecuted'>            fl.log(&quot;a&gt;b, a: &quot;, a);</span>
 32 |     | <span class='unexecuted'>            fl.log(&quot;a&gt;b, b:&quot;, b);</span>
 33 |     | <span class='unexecuted'>            fl.log(</span>
 34 |     | <span class='neutral'>                &quot;Percentage difference is bigger than expected&quot;,</span>
 35 |     | <span class='neutral'>                percentDiff</span>
 36 |     | <span class='neutral'>            );</span>
 37 |     | <span class='unexecuted'>            fl.t(false, reason);</span>
 38 |     | <span class='neutral'>        } else {</span>
 39 |     | <span class='unexecuted'>            fl.t(true, &quot;Invariant ok, ckeched for: &quot;);</span>
 40 |     | <span class='unexecuted'>            fl.log(reason);</span>
 41 |     | <span class='unexecuted'>            fl.log(&quot;Percentage difference: &quot;, percentDiff);</span>
 42 |     | <span class='neutral'>        }</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 | *   | <span class='executed'>    function eqWithToleranceWei(</span>
 46 |     | <span class='neutral'>        uint256 a,</span>
 47 |     | <span class='neutral'>        uint256 b,</span>
 48 |     | <span class='neutral'>        uint256 maxWeiDiff,</span>
 49 |     | <span class='neutral'>        string memory reason</span>
 50 |     | <span class='unexecuted'>    ) internal {</span>
 51 | *   | <span class='executed'>        if (a == b) return;</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        uint256 diff;</span>
 54 |     | <span class='unexecuted'>        if (a &gt; b) {</span>
 55 |     | <span class='unexecuted'>            diff = a - b;</span>
 56 |     | <span class='neutral'>        } else {</span>
 57 |     | <span class='unexecuted'>            diff = b - a;</span>
 58 |     | <span class='neutral'>        }</span>
 59 |     | <span class='neutral'></span>
 60 | *   | <span class='executed'>        if (diff &gt; maxWeiDiff) {</span>
 61 |     | <span class='unexecuted'>            fl.log(&quot;a: &quot;, a);</span>
 62 |     | <span class='unexecuted'>            fl.log(&quot;b: &quot;, b);</span>
 63 |     | <span class='unexecuted'>            fl.log(&quot;Difference in wei is bigger than expected&quot;, diff);</span>
 64 | *   | <span class='executed'>            fl.t(false, reason);</span>
 65 |     | <span class='neutral'>        } else {</span>
 66 |     | <span class='unexecuted'>            fl.t(true, &quot;Invariant ok, checked for: &quot;);</span>
 67 |     | <span class='unexecuted'>            fl.log(reason);</span>
 68 |     | <span class='unexecuted'>            fl.log(&quot;Difference in wei: &quot;, diff);</span>
 69 |     | <span class='neutral'>        }</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'>}</span>
 72 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/PropertiesDescriptions.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='unexecuted'>contract PropertiesDescriptions {</span>
   4 |     | <span class='neutral'>    string constant MGN_01 =</span>
   5 |     | <span class='neutral'>        &quot;MGN-01: Position is never liquidatable after a successful margin withdraw&quot;;</span>
   6 |     | <span class='neutral'>    // no flagged in perps</span>
   7 |     | <span class='neutral'>    // string constant MGN_02 =</span>
   8 |     | <span class='neutral'>    //     &quot;MGN-02: A modify collateral call will always revert for an account with a flagged position&quot;;</span>
   9 |     | <span class='neutral'>    string constant MGN_03 =</span>
  10 |     | <span class='neutral'>        &quot;MGN-03: A modify collateral call will always revert for an account that has a pending order&quot;;</span>
  11 |     | <span class='neutral'>    string constant MGN_04 =</span>
  12 |     | <span class='neutral'>        &quot;MGN-04: If an account&#39;s collateral is 0, then the account&#39;s debt must also be 0&quot;;</span>
  13 |     | <span class='neutral'>    string constant MGN_05 =</span>
  14 |     | <span class='neutral'>        &quot;MGN-05: depositedCollaterals array should be adjusted by amount of collateral modified&quot;;</span>
  15 |     | <span class='neutral'>    string constant MGN_06 =</span>
  16 |     | <span class='neutral'>        &quot;MGN-06: If sUSD collateral modified, minimumCredit should be updated by that amount&quot;;</span>
  17 |     | <span class='neutral'>    string constant MGN_07 =</span>
  18 |     | <span class='neutral'>        &quot;MGN-07: There should be no reportedDebt if all collateral has been withdrawn and skew=0&quot;;</span>
  19 |     | <span class='neutral'>    string constant MGN_08 =</span>
  20 |     | <span class='neutral'>        &quot;MGN-08: Sum of collateral token values should be the totalCollateralValueUsd stored in the market&quot;;</span>
  21 |     | <span class='neutral'>    //no withaw all function</span>
  22 |     | <span class='neutral'>    // string constant MGN_09 =</span>
  23 |     | <span class='neutral'>    //     &quot;MGN-09: After call to withdrawAllCollateral actor account margin debt should be 0&quot;;</span>
  24 |     | <span class='neutral'>    // string constant MGN_10 =</span>
  25 |     | <span class='neutral'>    //     &quot;MGN-10: All accountMargin.collaterals should be 0 after call to withdrawAllCollateral()&quot;;</span>
  26 |     | <span class='neutral'>    // string constant MGN_11 =</span>
  27 |     | <span class='neutral'>    //     &quot;MGN-11: Market collateral should decrease by amount of collateral user had deposited before withdrawing all collateral&quot;;</span>
  28 |     | <span class='neutral'>    string constant MGN_12 =</span>
  29 |     | <span class='neutral'>        &quot;MGN-12: User cannot withdraw more non-susd collateral than they deposited&quot;;</span>
  30 |     | <span class='neutral'>    string constant MGN_13 =</span>
  31 |     | <span class='neutral'>        &quot;MGN-13: activeCollateralTypesIt should never happen that a user has an amount of collateral deposited with a token &gt; 18 decimals precision and withdrawing lead to precision loss.&quot;;</span>
  32 |     | <span class='neutral'>    string constant MGN_14 =</span>
  33 |     | <span class='neutral'>        &quot;MGN-14:  After modifying collateral, a trader should not be immediately liquidatable.&quot;;</span>
  34 |     | <span class='neutral'>    string constant MGN_15 =</span>
  35 |     | <span class='neutral'>        &quot;MGN-15:  After paying debt, a trader should not be immediately liquidatable.&quot;;</span>
  36 |     | <span class='neutral'>    string constant MGN_16 =</span>
  37 |     | <span class='neutral'>        &quot;MGN-16:  The sum of collateral amounts from all accounts should always equal the global collateral amount.&quot;;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    string constant LIQ_01 = &quot;LIQ-01: isPositionLiquidatable never reverts&quot;;</span>
  40 |     | <span class='neutral'>    string constant LIQ_02 =</span>
  41 |     | <span class='neutral'>        &quot;LIQ-02: If a position is flagged for liquidation before any function call, the position after is always either flagged for liquidation, or no longer exists&quot;;</span>
  42 |     | <span class='neutral'>    string constant LIQ_03 =</span>
  43 |     | <span class='neutral'>        &quot;LIQ-03: remainingLiquidatableSizeCapacity is strictly decreasing immediately after a successful liquidation&quot;;</span>
  44 |     | <span class='neutral'>    string constant LIQ_04 =</span>
  45 |     | <span class='neutral'>        &quot;LIQ-04: If a user gets successfully flagged, their collateral will always be 0&quot;;</span>
  46 |     | <span class='neutral'>    string constant LIQ_05 =</span>
  47 |     | <span class='neutral'>        &quot;LIQ-05: The sUSD balance of a user that successfully flags a position is strictly increasing&quot;;</span>
  48 |     | <span class='neutral'>    string constant LIQ_06 =</span>
  49 |     | <span class='neutral'>        &quot;LIQ-06: The sUSD balance of a user that successfully flags a position increases less or equal to maxKeeperFee&quot;;</span>
  50 |     | <span class='neutral'>    string constant LIQ_07 =</span>
  51 |     | <span class='neutral'>        &quot;LIQ-07:  User should not be able to gain more in keeper fees than collateral lost in liquidatePosition&quot;;</span>
  52 |     | <span class='neutral'>    string constant LIQ_08 =</span>
  53 |     | <span class='neutral'>        &quot;LIQ-08: A user can be liquidated if minimum credit is not met&quot;;</span>
  54 |     | <span class='neutral'>    string constant LIQ_09 =</span>
  55 |     | <span class='neutral'>        &quot;LIQ-09: All account margin collateral should be removed after full liquidation&quot;;</span>
  56 |     | <span class='neutral'>    string constant LIQ_10 =</span>
  57 |     | <span class='neutral'>        &quot;LIQ-10: Flagged positions should be liquidated even if they have a health factor &gt; 1&quot;;</span>
  58 |     | <span class='neutral'>    string constant LIQ_11 =</span>
  59 |     | <span class='neutral'>        &quot;LIQ-11: Market deposited collateral should decrease after full liquidation by the account collaterla that was liquidated&quot;;</span>
  60 |     | <span class='neutral'>    string constant LIQ_12 =</span>
  61 |     | <span class='neutral'>        &quot;LIQ-12: If a position has position.size == 0, flagger should be set to address(0)&quot;;</span>
  62 |     | <span class='neutral'>    string constant LIQ_13 =</span>
  63 |     | <span class='neutral'>        &quot;LIQ-13: After user position flagged, user should have 0 collateral value&quot;;</span>
  64 |     | <span class='neutral'>    string constant LIQ_14 =</span>
  65 |     | <span class='neutral'>        &quot;LIQ-14: After user is flagged, market collateral should decreases by user collateral amount&quot;;</span>
  66 |     | <span class='neutral'>    string constant LIQ_15 =</span>
  67 |     | <span class='neutral'>        &quot;LIQ-15: User should not be able to gain more in keeper fees than collateral lost in liquidateMarginOnly&quot;;</span>
  68 |     | <span class='neutral'>    string constant LIQ_16 =</span>
  69 |     | <span class='neutral'>        &quot;LIQ-16: After liquidation, debtCorrectionAccumulator and reportedDebt is strictly decreasing in one of the markets&quot;;</span>
  70 |     | <span class='neutral'>    string constant LIQ_17 =</span>
  71 |     | <span class='neutral'>        &quot;LIQ-17: If an account is flagged for liquidations the account is not allowed to have collateral or debt.&quot;;</span>
  72 |     | <span class='neutral'>    string constant LIQ_18 =</span>
  73 |     | <span class='neutral'>        &quot;LIQ-18: maxLiquidatableAmount can never return a value greater than requestedLiquidationAmount.&quot;;</span>
  74 |     | <span class='neutral'>    string constant LIQ_19 =</span>
  75 |     | <span class='neutral'>        &quot;LIQ-19: Calling LiquidationModule.liquidate after it has been previously called in the same block should not increase the balance of the caller.&quot;;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    string constant ORD_01 =</span>
  78 |     | <span class='neutral'>        &quot;ORD-01: If an account has an order commited that is unexpired, a subsequent commit order call will always revert&quot;;</span>
  79 |     | <span class='neutral'>    string constant ORD_02 =</span>
  80 |     | <span class='neutral'>        &quot;ORD-02: The sizeDelta of an order is always 0 after a successful settle order call&quot;;</span>
  81 |     | <span class='neutral'>    string constant ORD_03 =</span>
  82 |     | <span class='neutral'>        &quot;ORD-03: An order immediately after a successful settle order call, is never liquidatable&quot;;</span>
  83 |     | <span class='neutral'>    string constant ORD_04 =</span>
  84 |     | <span class='neutral'>        &quot;ORD-04: If a user successfully settles an order, their sUSD balance is strictly increasing&quot;;</span>
  85 |     | <span class='neutral'>    string constant ORD_05 =</span>
  86 |     | <span class='neutral'>        &quot;ORD-05: The sUSD balance of a user that successfully cancels an order for another user is strictly increasing&quot;;</span>
  87 |     | <span class='neutral'>    string constant ORD_06_WETH =</span>
  88 |     | <span class='neutral'>        &quot;ORD-06_WETH: The minimum credit requirement must be met after increase order settlement&quot;;</span>
  89 |     | <span class='neutral'>    string constant ORD_06_WBTC =</span>
  90 |     | <span class='neutral'>        &quot;ORD-06_WBTC: The minimum credit requirement must be met after increase order settlement&quot;;</span>
  91 |     | <span class='neutral'>    string constant ORD_07 =</span>
  92 |     | <span class='neutral'>        &quot;ORD-07: Utilization is between 0% and 100% before and after order settlement&quot;;</span>
  93 |     | <span class='neutral'>    string constant ORD_08_WETH =</span>
  94 |     | <span class='neutral'>        &quot;ORD_08_WETH: non-SUSD collateral should stay the same after profitably settling order&quot;;</span>
  95 |     | <span class='neutral'>    string constant ORD_08_WBTC =</span>
  96 |     | <span class='neutral'>        &quot;ORD_08_WBTC: non-SUSD collateral should stay the same after profitably settling order&quot;;</span>
  97 |     | <span class='neutral'>    string constant ORD_09 =</span>
  98 |     | <span class='neutral'>        &quot;ORD-09: Should always give premium when increasing skew and discount when decreasing skew&quot;;</span>
  99 |     | <span class='neutral'>    string constant ORD_10 =</span>
 100 |     | <span class='neutral'>        &quot;ORD-10: market.currentUtilizationAccruedComputed decreases&quot;;</span>
 101 |     | <span class='neutral'>    string constant ORD_11 =</span>
 102 |     | <span class='neutral'>        &quot;ORD-11: market.reportedDebt != positions.sum(p.collateralUsd + p.pricePnL + p.pendingFunding - p.pendingUtilization - p.debtUsd)&quot;;</span>
 103 |     | <span class='neutral'>    string constant ORD_12 =</span>
 104 |     | <span class='neutral'>        &quot;ORD-12: An account should not be liquidatable by margin only after order settlement&quot;;</span>
 105 |     | <span class='neutral'>    string constant ORD_13 =</span>
 106 |     | <span class='neutral'>        &quot;ORD-13: An account should not be liquidatable by margin only after order cancelled&quot;;</span>
 107 |     | <span class='neutral'>    string constant ORD_14 =</span>
 108 |     | <span class='neutral'>        &quot;ORD-14: Market size should always be the sum of individual position sizes&quot;;</span>
 109 |     | <span class='neutral'>    string constant ORD_15 =</span>
 110 |     | <span class='neutral'>        &quot;ORD-15: Position should no be liquidatable after committing an order&quot;;</span>
 111 |     | <span class='neutral'>    string constant ORD_16 =</span>
 112 |     | <span class='neutral'>        &quot;ORD-16: Position should no be liquidatable after cancelling an order&quot;;</span>
 113 |     | <span class='neutral'>    string constant ORD_17 =</span>
 114 |     | <span class='neutral'>        &quot;ORD-17: Position should no be liquidatable after cancelling a stale order&quot;;</span>
 115 |     | <span class='neutral'>    string constant ORD_18 =</span>
 116 |     | <span class='neutral'>        &quot;ORD-18:  Open positions should always be added / removed from the openPositionMarketIds array.&quot;;</span>
 117 |     | <span class='neutral'>    string constant ORD_19 =</span>
 118 |     | <span class='neutral'>        &quot;ORD-19:  All tokens in the activeCollateralTypes array from individual accounts should be included in the global activeCollateralTypes array.&quot;;</span>
 119 |     | <span class='neutral'>    string constant ORD_20 =</span>
 120 |     | <span class='neutral'>        &quot;ORD-20:  Sum of the debt of all accounts == global debt..&quot;;</span>
 121 |     | <span class='neutral'>    string constant ORD_21 =</span>
 122 |     | <span class='neutral'>        &quot;ORD-21: ReportedDebt == traders&#39; collateral + traders&#39; PnL.&quot;;</span>
 123 |     | <span class='neutral'>    string constant ORD_22 =</span>
 124 |     | <span class='neutral'>        &quot;ORD-22: Debt should not vanish after settle another order.&quot;;</span>
 125 |     | <span class='neutral'>    string constant ORD_23 =</span>
 126 |     | <span class='neutral'>        &quot;ORD-23: AsyncOrder.calculateFillPrice() should never revert.&quot;;</span>
 127 |     | <span class='neutral'>}</span>
 128 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties_LIQ.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PropertiesBase.sol&quot;;</span>
   5 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
   6 |     | <span class='neutral'>import {MathUtil} from &quot;../../utils/MathUtil.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>abstract contract Properties_LIQ is PropertiesBase {</span>
   9 | *   | <span class='executed'>    function invariant_LIQ_01(uint128 account) internal {</span>
  10 | *   | <span class='executed'>        fl.log(&quot;ACCOUNT LIQ_01:&quot;, account);</span>
  11 | *   | <span class='executed'>        fl.t(</span>
  12 | *   | <span class='executed'>            states[0].actorStates[account].isPositionLiquidatablePassing,</span>
  13 | *   | <span class='executed'>            LIQ_01</span>
  14 |     | <span class='neutral'>        );</span>
  15 | *   | <span class='executed'>        fl.t(</span>
  16 | *   | <span class='executed'>            states[1].actorStates[account].isPositionLiquidatablePassing,</span>
  17 | *   | <span class='executed'>            LIQ_01</span>
  18 |     | <span class='neutral'>        );</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    //LIQ_02 N/A no flaggedBy</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>    function invariant_LIQ_03() internal {</span>
  24 | *   | <span class='executed'>        console2.log(</span>
  25 |     | <span class='neutral'>            &quot;WETH Liquidation Capacity (Before):&quot;,</span>
  26 | *   | <span class='executed'>            states[0].wethMarket.liquidationCapacity</span>
  27 |     | <span class='neutral'>        );</span>
  28 | *   | <span class='executed'>        console2.log(</span>
  29 |     | <span class='neutral'>            &quot;WETH Liquidation Capacity (After):&quot;,</span>
  30 | *   | <span class='executed'>            states[1].wethMarket.liquidationCapacity</span>
  31 |     | <span class='neutral'>        );</span>
  32 |     | <span class='neutral'></span>
  33 | *   | <span class='executed'>        console2.log(</span>
  34 |     | <span class='neutral'>            &quot;WBTC Liquidation Capacity (Before):&quot;,</span>
  35 | *   | <span class='executed'>            states[0].wbtcMarket.liquidationCapacity</span>
  36 |     | <span class='neutral'>        );</span>
  37 | *   | <span class='executed'>        console2.log(</span>
  38 |     | <span class='neutral'>            &quot;WBTC Liquidation Capacity (After):&quot;,</span>
  39 | *   | <span class='executed'>            states[1].wbtcMarket.liquidationCapacity</span>
  40 |     | <span class='neutral'>        );</span>
  41 | *   | <span class='executed'>        bool wethCapacityChanged = states[1].wethMarket.liquidationCapacity !=</span>
  42 | *   | <span class='executed'>            states[0].wethMarket.liquidationCapacity;</span>
  43 | *   | <span class='executed'>        bool wbtcCapacityChanged = states[1].wbtcMarket.liquidationCapacity !=</span>
  44 | *   | <span class='executed'>            states[0].wbtcMarket.liquidationCapacity;</span>
  45 |     | <span class='neutral'></span>
  46 | *   | <span class='executed'>        console2.log(&quot;WBTC Capacity Changed:&quot;, wbtcCapacityChanged);</span>
  47 | *   | <span class='executed'>        console2.log(&quot;WETH Capacity Changed:&quot;, wethCapacityChanged);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // Check if neither changed and was not zero</span>
  50 | *   | <span class='executed'>        if (!wethCapacityChanged &amp;&amp; !wbtcCapacityChanged) {</span>
  51 | *   | <span class='executed'>            fl.t(</span>
  52 | *   | <span class='executed'>                states[0].wethMarket.liquidationCapacity ==</span>
  53 | *   | <span class='executed'>                    states[1].wethMarket.liquidationCapacity &amp;&amp;</span>
  54 | *   | <span class='executed'>                    states[0].wbtcMarket.liquidationCapacity ==</span>
  55 | *   | <span class='executed'>                    states[1].wbtcMarket.liquidationCapacity,</span>
  56 |     | <span class='neutral'>                &quot;LIQ_03: At least one market should have zero initial capacity if unchanged&quot;</span>
  57 |     | <span class='neutral'>            );</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        // Check WETH market</span>
  61 | *   | <span class='executed'>        if (wethCapacityChanged) {</span>
  62 | *   | <span class='executed'>            if (states[0].wethMarket.liquidationCapacity != 0) {</span>
  63 | *   | <span class='executed'>                fl.lt(</span>
  64 | *   | <span class='executed'>                    states[1].wethMarket.liquidationCapacity,</span>
  65 | *   | <span class='executed'>                    states[0].wethMarket.liquidationCapacity,</span>
  66 |     | <span class='neutral'>                    &quot;LIQ_03: WETH capacity should decrease&quot;</span>
  67 |     | <span class='neutral'>                );</span>
  68 |     | <span class='neutral'>            } else {</span>
  69 |     | <span class='unexecuted'>                fl.eq(</span>
  70 |     | <span class='unexecuted'>                    states[1].wethMarket.liquidationCapacity,</span>
  71 |     | <span class='unexecuted'>                    states[0].wethMarket.liquidationCapacity,</span>
  72 |     | <span class='neutral'>                    &quot;LIQ_03: WETH capacity should remain zero&quot;</span>
  73 |     | <span class='neutral'>                );</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // Check WBTC market</span>
  78 | *   | <span class='executed'>        if (wbtcCapacityChanged) {</span>
  79 | *   | <span class='executed'>            if (states[0].wbtcMarket.liquidationCapacity != 0) {</span>
  80 | *   | <span class='executed'>                fl.lt(</span>
  81 | *   | <span class='executed'>                    states[1].wbtcMarket.liquidationCapacity,</span>
  82 | *   | <span class='executed'>                    states[0].wbtcMarket.liquidationCapacity,</span>
  83 |     | <span class='neutral'>                    &quot;LIQ_03: WBTC capacity should decrease&quot;</span>
  84 |     | <span class='neutral'>                );</span>
  85 |     | <span class='neutral'>            } else {</span>
  86 |     | <span class='unexecuted'>                fl.eq(</span>
  87 |     | <span class='unexecuted'>                    states[1].wbtcMarket.liquidationCapacity,</span>
  88 |     | <span class='unexecuted'>                    states[0].wbtcMarket.liquidationCapacity,</span>
  89 |     | <span class='neutral'>                    &quot;LIQ_03: WBTC capacity should remain zero&quot;</span>
  90 |     | <span class='neutral'>                );</span>
  91 |     | <span class='neutral'>            }</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    //LIQ_04 N/A no flaggedBy</span>
  96 |     | <span class='neutral'>    //LIQ_05 N/A no flaggedBy</span>
  97 |     | <span class='neutral'>    //LIQ_06 N/A no flaggedBy</span>
  98 |     | <span class='neutral'>    //LIQ_07 N/A no flaggedBy</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function invariant_LIQ_08() internal {</span>
 101 |     | <span class='neutral'>        fl.t(</span>
 102 |     | <span class='neutral'>            states[0].delegatedCollateralValueUsd &gt;= states[0].minimumCredit,</span>
 103 |     | <span class='neutral'>            LIQ_08</span>
 104 |     | <span class='neutral'>        );</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>    function invariant_LIQ_09(uint128 account) internal {</span>
 108 | *   | <span class='executed'>        if (</span>
 109 | *   | <span class='executed'>            states[1].actorStates[account].wethMarket.positionSize == 0 &amp;&amp;</span>
 110 | *   | <span class='executed'>            states[1].actorStates[account].wbtcMarket.positionSize == 0</span>
 111 |     | <span class='neutral'>        ) {</span>
 112 | *   | <span class='executed'>            fl.t(states[1].actorStates[account].availableMargin == 0, LIQ_09);</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    //LIQ_10 N/A no flaggedBy</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>    function invariant_LIQ_11(uint128 account) internal {</span>
 119 | *   | <span class='executed'>        if (</span>
 120 | *   | <span class='executed'>            states[1].actorStates[account].wethMarket.positionSize == 0 &amp;&amp;</span>
 121 | *   | <span class='executed'>            states[1].actorStates[account].wbtcMarket.positionSize == 0</span>
 122 |     | <span class='neutral'>        ) {</span>
 123 | *   | <span class='executed'>            fl.log(</span>
 124 |     | <span class='neutral'>                &quot;Margin before:&quot;,</span>
 125 | *   | <span class='executed'>                states[0].actorStates[account].availableMargin</span>
 126 |     | <span class='neutral'>            );</span>
 127 | *   | <span class='executed'>            fl.log(</span>
 128 |     | <span class='neutral'>                &quot;Margin after:&quot;,</span>
 129 | *   | <span class='executed'>                states[1].actorStates[account].availableMargin</span>
 130 |     | <span class='neutral'>            );</span>
 131 |     | <span class='neutral'>            // if position was fully liquidated, market collateral should be decreased by user&#39;s margin amount</span>
 132 | *   | <span class='executed'>            eqWithToleranceWei(</span>
 133 |     | <span class='neutral'>                uint(</span>
 134 | *   | <span class='executed'>                    states[0].totalCollateralValueUsd -</span>
 135 | *   | <span class='executed'>                        states[1].totalCollateralValueUsd</span>
 136 |     | <span class='neutral'>                ),</span>
 137 |     | <span class='neutral'>                uint(</span>
 138 | *   | <span class='executed'>                    int256(states[0].actorStates[account].totalCollateralValue)</span>
 139 |     | <span class='neutral'>                ),</span>
 140 | *   | <span class='executed'>                1,</span>
 141 | *   | <span class='executed'>                LIQ_11</span>
 142 |     | <span class='neutral'>            );</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    //LIQ_12 N/A no flaggedBy</span>
 147 |     | <span class='neutral'>    //LIQ_13 N/A no flaggedBy</span>
 148 |     | <span class='neutral'>    //LIQ_14 N/A no flaggedBy</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function invariant_LIQ_15(uint128 account) internal {</span>
 151 |     | <span class='neutral'>        fl.gte(</span>
 152 |     | <span class='neutral'>            states[0].actorStates[account].totalCollateralValue -</span>
 153 |     | <span class='neutral'>                states[1].actorStates[account].totalCollateralValue,</span>
 154 |     | <span class='neutral'>            states[0].actorStates[account].maxLiquidationReward,</span>
 155 |     | <span class='neutral'>            LIQ_15</span>
 156 |     | <span class='neutral'>        );</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 | *   | <span class='executed'>    function invariant_LIQ_16() internal {</span>
 160 | *   | <span class='executed'>        fl.log(</span>
 161 |     | <span class='neutral'>            &quot;states[0].wethMarket.debtCorrectionAccumulator&quot;,</span>
 162 | *   | <span class='executed'>            states[0].wethMarket.debtCorrectionAccumulator</span>
 163 |     | <span class='neutral'>        );</span>
 164 | *   | <span class='executed'>        fl.log(</span>
 165 |     | <span class='neutral'>            &quot;states[1].wethMarket.debtCorrectionAccumulator&quot;,</span>
 166 | *   | <span class='executed'>            states[1].wethMarket.debtCorrectionAccumulator</span>
 167 |     | <span class='neutral'>        );</span>
 168 | *   | <span class='executed'>        fl.log(</span>
 169 |     | <span class='neutral'>            &quot;states[0].wethMarket.reportedDebt&quot;,</span>
 170 | *   | <span class='executed'>            states[0].wethMarket.reportedDebt</span>
 171 |     | <span class='neutral'>        );</span>
 172 | *   | <span class='executed'>        fl.log(</span>
 173 |     | <span class='neutral'>            &quot;states[1].wethMarket.reportedDebt&quot;,</span>
 174 | *   | <span class='executed'>            states[1].wethMarket.reportedDebt</span>
 175 |     | <span class='neutral'>        );</span>
 176 |     | <span class='neutral'></span>
 177 | *   | <span class='executed'>        bool wethConditionMet = (states[0]</span>
 178 |     | <span class='neutral'>            .wethMarket</span>
 179 |     | <span class='neutral'>            .debtCorrectionAccumulator &gt;=</span>
 180 | *   | <span class='executed'>            states[1].wethMarket.debtCorrectionAccumulator) &amp;&amp;</span>
 181 | *   | <span class='executed'>            (states[0].wethMarket.reportedDebt &gt;=</span>
 182 | *   | <span class='executed'>                states[1].wethMarket.reportedDebt);</span>
 183 |     | <span class='neutral'></span>
 184 | *   | <span class='executed'>        fl.log(</span>
 185 |     | <span class='neutral'>            &quot;states[0].wbtcMarket.debtCorrectionAccumulator&quot;,</span>
 186 | *   | <span class='executed'>            states[0].wbtcMarket.debtCorrectionAccumulator</span>
 187 |     | <span class='neutral'>        );</span>
 188 | *   | <span class='executed'>        fl.log(</span>
 189 |     | <span class='neutral'>            &quot;states[1].wbtcMarket.debtCorrectionAccumulator&quot;,</span>
 190 | *   | <span class='executed'>            states[1].wbtcMarket.debtCorrectionAccumulator</span>
 191 |     | <span class='neutral'>        );</span>
 192 | *   | <span class='executed'>        fl.log(</span>
 193 |     | <span class='neutral'>            &quot;states[0].wbtcMarket.reportedDebt&quot;,</span>
 194 | *   | <span class='executed'>            states[0].wbtcMarket.reportedDebt</span>
 195 |     | <span class='neutral'>        );</span>
 196 | *   | <span class='executed'>        fl.log(</span>
 197 |     | <span class='neutral'>            &quot;states[1].wbtcMarket.reportedDebt&quot;,</span>
 198 | *   | <span class='executed'>            states[1].wbtcMarket.reportedDebt</span>
 199 |     | <span class='neutral'>        );</span>
 200 |     | <span class='neutral'></span>
 201 | *   | <span class='executed'>        bool wbtcConditionMet = (states[0]</span>
 202 |     | <span class='neutral'>            .wbtcMarket</span>
 203 |     | <span class='neutral'>            .debtCorrectionAccumulator &gt;=</span>
 204 | *   | <span class='executed'>            states[1].wbtcMarket.debtCorrectionAccumulator) &amp;&amp;</span>
 205 | *   | <span class='executed'>            (states[0].wbtcMarket.reportedDebt &gt;=</span>
 206 | *   | <span class='executed'>                states[1].wbtcMarket.reportedDebt);</span>
 207 |     | <span class='neutral'></span>
 208 | *   | <span class='executed'>        fl.t(</span>
 209 | *   | <span class='executed'>            (wethConditionMet || wbtcConditionMet) ||</span>
 210 | *   | <span class='executed'>                (wethConditionMet &amp;&amp; wbtcConditionMet),</span>
 211 | *   | <span class='executed'>            LIQ_16</span>
 212 |     | <span class='neutral'>        );</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 | *   | <span class='executed'>    function invariant_LIQ_17(uint128 account) internal {</span>
 216 | *   | <span class='executed'>        if (states[0].actorStates[account].isAccountLiquidatable) {</span>
 217 | *   | <span class='executed'>            fl.eq(</span>
 218 | *   | <span class='executed'>                states[0].actorStates[account].totalCollateralValue,</span>
 219 |     | <span class='neutral'>                0,</span>
 220 | *   | <span class='executed'>                LIQ_17</span>
 221 |     | <span class='neutral'>            );</span>
 222 | *   | <span class='executed'>            fl.eq(states[0].actorStates[account].debt, 0, LIQ_17);</span>
 223 |     | <span class='neutral'>        }</span>
 224 | *   | <span class='executed'>        if (states[1].actorStates[account].isAccountLiquidatable) {</span>
 225 | *   | <span class='executed'>            fl.eq(</span>
 226 | *   | <span class='executed'>                states[1].actorStates[account].totalCollateralValue,</span>
 227 |     | <span class='neutral'>                0,</span>
 228 | *   | <span class='executed'>                LIQ_17</span>
 229 |     | <span class='neutral'>            );</span>
 230 | *   | <span class='executed'>            fl.eq(states[1].actorStates[account].debt, 0, LIQ_17);</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 | *   | <span class='executed'>    function invariant_LIQ_18(uint128 account) internal {</span>
 235 | *   | <span class='executed'>        console2.log(&quot;account&quot;, account);</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        if (states[0].actorStates[account].wethMarket.positionSize &gt; 0) {</span>
 238 | *   | <span class='executed'>            console2.log(</span>
 239 |     | <span class='neutral'>                &quot;states[0].actorStates[account].wethMarket.maxLiquidatableAmount&quot;,</span>
 240 | *   | <span class='executed'>                states[0].actorStates[account].wethMarket.maxLiquidatableAmount</span>
 241 |     | <span class='neutral'>            );</span>
 242 | *   | <span class='executed'>            console2.log(</span>
 243 |     | <span class='neutral'>                &quot;states[0].actorStates[account].wethMarket.positionSize&quot;,</span>
 244 | *   | <span class='executed'>                states[0].actorStates[account].wethMarket.positionSize</span>
 245 |     | <span class='neutral'>            );</span>
 246 | *   | <span class='executed'>            fl.lte(</span>
 247 | *   | <span class='executed'>                states[0].actorStates[account].wethMarket.maxLiquidatableAmount,</span>
 248 |     | <span class='neutral'>                uint256(</span>
 249 | *   | <span class='executed'>                    MathUtil.abs(</span>
 250 | *   | <span class='executed'>                        states[0].actorStates[account].wethMarket.positionSize</span>
 251 |     | <span class='neutral'>                    )</span>
 252 |     | <span class='neutral'>                ),</span>
 253 | *   | <span class='executed'>                LIQ_18</span>
 254 |     | <span class='neutral'>            );</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'></span>
 257 | *   | <span class='executed'>        if (states[1].actorStates[account].wethMarket.positionSize &gt; 0) {</span>
 258 | *   | <span class='executed'>            console2.log(</span>
 259 |     | <span class='neutral'>                &quot;states[1].actorStates[account].wethMarket.maxLiquidatableAmount&quot;,</span>
 260 | *   | <span class='executed'>                states[1].actorStates[account].wethMarket.maxLiquidatableAmount</span>
 261 |     | <span class='neutral'>            );</span>
 262 | *   | <span class='executed'>            console2.log(</span>
 263 |     | <span class='neutral'>                &quot;states[1].actorStates[account].wethMarket.positionSize&quot;,</span>
 264 | *   | <span class='executed'>                states[1].actorStates[account].wethMarket.positionSize</span>
 265 |     | <span class='neutral'>            );</span>
 266 | *   | <span class='executed'>            fl.lte(</span>
 267 | *   | <span class='executed'>                states[1].actorStates[account].wethMarket.maxLiquidatableAmount,</span>
 268 |     | <span class='neutral'>                uint256(</span>
 269 | *   | <span class='executed'>                    MathUtil.abs(</span>
 270 | *   | <span class='executed'>                        states[1].actorStates[account].wethMarket.positionSize</span>
 271 |     | <span class='neutral'>                    )</span>
 272 |     | <span class='neutral'>                ),</span>
 273 | *   | <span class='executed'>                LIQ_18</span>
 274 |     | <span class='neutral'>            );</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='neutral'></span>
 277 | *   | <span class='executed'>        if (states[0].actorStates[account].wbtcMarket.positionSize &gt; 0) {</span>
 278 | *   | <span class='executed'>            console2.log(</span>
 279 |     | <span class='neutral'>                &quot;states[0].actorStates[account].wbtcMarket.maxLiquidatableAmount&quot;,</span>
 280 | *   | <span class='executed'>                states[0].actorStates[account].wbtcMarket.maxLiquidatableAmount</span>
 281 |     | <span class='neutral'>            );</span>
 282 | *   | <span class='executed'>            console2.log(</span>
 283 |     | <span class='neutral'>                &quot;states[0].actorStates[account].wbtcMarket.positionSize&quot;,</span>
 284 | *   | <span class='executed'>                states[0].actorStates[account].wbtcMarket.positionSize</span>
 285 |     | <span class='neutral'>            );</span>
 286 | *   | <span class='executed'>            fl.lte(</span>
 287 | *   | <span class='executed'>                states[0].actorStates[account].wbtcMarket.maxLiquidatableAmount,</span>
 288 |     | <span class='neutral'>                uint256(</span>
 289 | *   | <span class='executed'>                    MathUtil.abs(</span>
 290 | *   | <span class='executed'>                        states[0].actorStates[account].wbtcMarket.positionSize</span>
 291 |     | <span class='neutral'>                    )</span>
 292 |     | <span class='neutral'>                ),</span>
 293 | *   | <span class='executed'>                LIQ_18</span>
 294 |     | <span class='neutral'>            );</span>
 295 |     | <span class='neutral'>        }</span>
 296 |     | <span class='neutral'></span>
 297 | *   | <span class='executed'>        if (states[1].actorStates[account].wbtcMarket.positionSize &gt; 0) {</span>
 298 | *   | <span class='executed'>            console2.log(</span>
 299 |     | <span class='neutral'>                &quot;states[1].actorStates[account].wbtcMarket.maxLiquidatableAmount&quot;,</span>
 300 | *   | <span class='executed'>                states[1].actorStates[account].wbtcMarket.maxLiquidatableAmount</span>
 301 |     | <span class='neutral'>            );</span>
 302 | *   | <span class='executed'>            console2.log(</span>
 303 |     | <span class='neutral'>                &quot;states[1].actorStates[account].wbtcMarket.positionSize&quot;,</span>
 304 | *   | <span class='executed'>                states[1].actorStates[account].wbtcMarket.positionSize</span>
 305 |     | <span class='neutral'>            );</span>
 306 | *   | <span class='executed'>            fl.lte(</span>
 307 | *   | <span class='executed'>                states[1].actorStates[account].wbtcMarket.maxLiquidatableAmount,</span>
 308 |     | <span class='neutral'>                uint256(</span>
 309 | *   | <span class='executed'>                    MathUtil.abs(</span>
 310 | *   | <span class='executed'>                        states[1].actorStates[account].wbtcMarket.positionSize</span>
 311 |     | <span class='neutral'>                    )</span>
 312 |     | <span class='neutral'>                ),</span>
 313 | *   | <span class='executed'>                LIQ_18</span>
 314 |     | <span class='neutral'>            );</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 | *   | <span class='executed'>    function invariant_LIQ_19(</span>
 319 |     | <span class='neutral'>        bool firstLiquidationAttempt,</span>
 320 |     | <span class='neutral'>        address liquidator</span>
 321 |     | <span class='neutral'>    ) internal {</span>
 322 | *   | <span class='executed'>        if (!firstLiquidationAttempt) {</span>
 323 | *   | <span class='executed'>            console2.log(</span>
 324 |     | <span class='neutral'>                &quot;Invariant liq 19 user debug&quot;,</span>
 325 | *   | <span class='executed'>                userToAccountIds[liquidator]</span>
 326 |     | <span class='neutral'>            );</span>
 327 | *   | <span class='executed'>            fl.eq(</span>
 328 | *   | <span class='executed'>                states[0]</span>
 329 | *   | <span class='executed'>                    .actorStates[userToAccountIds[liquidator]]</span>
 330 |     | <span class='neutral'>                    .balanceOfSUSD,</span>
 331 | *   | <span class='executed'>                states[1]</span>
 332 |     | <span class='neutral'>                    .actorStates[userToAccountIds[liquidator]]</span>
 333 |     | <span class='neutral'>                    .balanceOfSUSD,</span>
 334 | *   | <span class='executed'>                LIQ_19</span>
 335 |     | <span class='neutral'>            );</span>
 336 | *   | <span class='executed'>            fl.eq(</span>
 337 | *   | <span class='executed'>                states[0]</span>
 338 | *   | <span class='executed'>                    .actorStates[userToAccountIds[liquidator]]</span>
 339 |     | <span class='neutral'>                    .balanceOfWETH,</span>
 340 | *   | <span class='executed'>                states[1]</span>
 341 |     | <span class='neutral'>                    .actorStates[userToAccountIds[liquidator]]</span>
 342 |     | <span class='neutral'>                    .balanceOfWETH,</span>
 343 | *   | <span class='executed'>                LIQ_19</span>
 344 |     | <span class='neutral'>            );</span>
 345 | *   | <span class='executed'>            fl.eq(</span>
 346 | *   | <span class='executed'>                states[0]</span>
 347 | *   | <span class='executed'>                    .actorStates[userToAccountIds[liquidator]]</span>
 348 |     | <span class='neutral'>                    .balanceOfWBTC,</span>
 349 | *   | <span class='executed'>                states[1]</span>
 350 |     | <span class='neutral'>                    .actorStates[userToAccountIds[liquidator]]</span>
 351 |     | <span class='neutral'>                    .balanceOfWBTC,</span>
 352 | *   | <span class='executed'>                LIQ_19</span>
 353 |     | <span class='neutral'>            );</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'>}</span>
 357 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties_MGN.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PropertiesBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract Properties_MGN is PropertiesBase {</span>
   7 | *   | <span class='executed'>    function invariant_MGN_01(uint128 accountId) internal {</span>
   8 | *   | <span class='executed'>        fl.t(!states[1].actorStates[accountId].isPositionLiquidatable, MGN_01);</span>
   9 |     | <span class='neutral'>    }</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    //MGN_02 FlaggedBy is N/A</span>
  12 |     | <span class='neutral'></span>
  13 | *   | <span class='executed'>    function invariant_MGN_03(uint128 accountId) internal {</span>
  14 | *   | <span class='executed'>        fl.t(</span>
  15 | *   | <span class='executed'>            states[0].actorStates[accountId].sizeDelta == 0 ||</span>
  16 | *   | <span class='executed'>                states[0].actorStates[accountId].isOrderExpired,</span>
  17 | *   | <span class='executed'>            MGN_03</span>
  18 |     | <span class='neutral'>        );</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 | *   | <span class='executed'>    function invariant_MGN_04(uint128 accountId) internal {</span>
  22 |     | <span class='neutral'>        //here is a total collateral value of speecific account</span>
  23 | *   | <span class='executed'>        if (states[1].actorStates[accountId].totalCollateralValue == 0) {</span>
  24 |     | <span class='unexecuted'>            fl.eq(states[1].actorStates[accountId].debt, 0, MGN_04);</span>
  25 |     | <span class='neutral'>        }</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function invariant_MGN_05(int256 amountDelta, address collateral) internal {</span>
  29 |     | <span class='neutral'>        if (amountDelta != 0 &amp;&amp; collateral == address(wethTokenMock)) {</span>
  30 |     | <span class='neutral'>            fl.eq(</span>
  31 |     | <span class='neutral'>                int256(states[1].depositedWethCollateral),</span>
  32 |     | <span class='neutral'>                int256(states[0].depositedWethCollateral) + amountDelta,</span>
  33 |     | <span class='neutral'>                MGN_05</span>
  34 |     | <span class='neutral'>            );</span>
  35 |     | <span class='neutral'>        }</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // &quot;./perps-market/contracts/modules/PerpsMarketFactoryModule.sol::minimumCredit&quot;</span>
  39 | *   | <span class='executed'>    function invariant_MGN_06(int256 amountDelta, address collateral) internal {</span>
  40 | *   | <span class='executed'>        if (amountDelta != 0 &amp;&amp; collateral == address(sUSDTokenMock)) {</span>
  41 | *   | <span class='executed'>            fl.eq(</span>
  42 | *   | <span class='executed'>                int256(states[1].minimumCredit),</span>
  43 | *   | <span class='executed'>                int256(states[0].minimumCredit) + amountDelta,</span>
  44 | *   | <span class='executed'>                MGN_06</span>
  45 |     | <span class='neutral'>            );</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='neutral'>    }</span>
  48 | *   | <span class='executed'>    function invariant_MGN_13(int256 amountDelta, address collateral) internal {</span>
  49 | *   | <span class='executed'>        if (amountDelta != 0 &amp;&amp; collateral == address(wbtcTokenMock)) {</span>
  50 | *   | <span class='executed'>            fl.eq(</span>
  51 | *   | <span class='executed'>                int256(states[1].depositedWbtcCollateral),</span>
  52 | *   | <span class='executed'>                int256(states[0].depositedWbtcCollateral) + amountDelta,</span>
  53 | *   | <span class='executed'>                MGN_05</span>
  54 |     | <span class='neutral'>            );</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'></span>
  57 | *   | <span class='executed'>        if (amountDelta != 0 &amp;&amp; collateral == address(wethTokenMock)) {</span>
  58 | *   | <span class='executed'>            fl.eq(</span>
  59 | *   | <span class='executed'>                int256(states[1].depositedWethCollateral),</span>
  60 | *   | <span class='executed'>                int256(states[0].depositedWethCollateral) + amountDelta,</span>
  61 | *   | <span class='executed'>                MGN_05</span>
  62 |     | <span class='neutral'>            );</span>
  63 |     | <span class='neutral'>        }</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    //N/A for perps</span>
  67 |     | <span class='neutral'>    // function invariant_MGN_07() internal {</span>
  68 |     | <span class='neutral'>    //     // TODO: DG review</span>
  69 |     | <span class='neutral'>    //     //Q1</span>
  70 |     | <span class='neutral'>    //     //totalCollateralValueUsd is a total for all markets</span>
  71 |     | <span class='neutral'>    //     // skew is a value that was taken from PerpsMarket::Data::skew</span>
  72 |     | <span class='neutral'>    //     // so skew is different for every market</span>
  73 |     | <span class='neutral'>    //     //Q2 or is it skew for SuperMarket</span>
  74 |     | <span class='neutral'>    //     //Q3 this skew value in logs is always zero, something with config</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    //     if (states[1].totalCollateralValueUsd == 0 &amp;&amp; states[1].skew == 0)</span>
  77 |     | <span class='neutral'>    //         fl.eq(states[1].reportedDebt, 0, MGN_07);</span>
  78 |     | <span class='neutral'>    // }</span>
  79 |     | <span class='neutral'></span>
  80 | *   | <span class='executed'>    function invariant_MGN_08() internal {</span>
  81 | *   | <span class='executed'>        console2.log(</span>
  82 |     | <span class='neutral'>            &quot;states[1].totalCollateralValueUsd&quot;,</span>
  83 | *   | <span class='executed'>            states[1].totalCollateralValueUsd</span>
  84 |     | <span class='neutral'>        );</span>
  85 | *   | <span class='executed'>        console2.log(</span>
  86 |     | <span class='neutral'>            &quot;states[1].totalCollateralValueUsdGhost&quot;,</span>
  87 | *   | <span class='executed'>            states[1].totalCollateralValueUsdGhost</span>
  88 |     | <span class='neutral'>        );</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>        eqWithTolerance(</span>
  91 | *   | <span class='executed'>            states[1].totalCollateralValueUsd,</span>
  92 | *   | <span class='executed'>            states[1].totalCollateralValueUsdGhost,</span>
  93 | *   | <span class='executed'>            0.01e18,</span>
  94 | *   | <span class='executed'>            MGN_08</span>
  95 |     | <span class='neutral'>        );</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    //MGN_09 is N/A now WithdrawAll function</span>
  99 |     | <span class='neutral'>    //MGN_10 is N/A now WithdrawAll function</span>
 100 |     | <span class='neutral'>    //MGN_11 is N/A now WithdrawAll function</span>
 101 |     | <span class='neutral'></span>
 102 | *   | <span class='executed'>    function invariant_MGN_12(uint128 accountId, uint collateralId) internal {</span>
 103 |     | <span class='neutral'>        // market collateral can only decrease by up to user&#39;s deposited weth amount value on withdrawal</span>
 104 | *   | <span class='executed'>        if (collateralId == 0) {</span>
 105 | *   | <span class='executed'>            fl.lte(</span>
 106 | *   | <span class='executed'>                states[0].depositedSusdCollateral -</span>
 107 | *   | <span class='executed'>                    states[1].depositedSusdCollateral,</span>
 108 | *   | <span class='executed'>                states[0].actorStates[accountId].collateralAmountSUSD,</span>
 109 | *   | <span class='executed'>                MGN_12</span>
 110 |     | <span class='neutral'>            );</span>
 111 |     | <span class='neutral'>        }</span>
 112 | *   | <span class='executed'>        if (collateralId == 1) {</span>
 113 | *   | <span class='executed'>            fl.lte(</span>
 114 | *   | <span class='executed'>                states[0].depositedWethCollateral -</span>
 115 | *   | <span class='executed'>                    states[1].depositedWethCollateral,</span>
 116 | *   | <span class='executed'>                states[0].actorStates[accountId].collateralAmountWETH,</span>
 117 | *   | <span class='executed'>                MGN_12</span>
 118 |     | <span class='neutral'>            );</span>
 119 |     | <span class='neutral'>        }</span>
 120 | *   | <span class='executed'>        if (collateralId == 2) {</span>
 121 | *   | <span class='executed'>            fl.lte(</span>
 122 | *   | <span class='executed'>                states[0].depositedWbtcCollateral -</span>
 123 | *   | <span class='executed'>                    states[1].depositedWbtcCollateral,</span>
 124 | *   | <span class='executed'>                states[0].actorStates[accountId].collateralAmountWBTC,</span>
 125 | *   | <span class='executed'>                MGN_12</span>
 126 |     | <span class='neutral'>            );</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function invariant_MGN_13(uint128 accountId, uint collateralId) internal {</span>
 131 |     | <span class='neutral'>        if (collateralId == 3) {</span>
 132 |     | <span class='neutral'>            fl.eq(</span>
 133 |     | <span class='neutral'>                states[1].actorStates[accountId].collateralAmountHUGE %</span>
 134 |     | <span class='neutral'>                    (10 ** (hugePrecisionTokenMock.decimals() - 18)),</span>
 135 |     | <span class='neutral'>                0,</span>
 136 |     | <span class='neutral'>                MGN_13</span>
 137 |     | <span class='neutral'>            );</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>    function invariant_MGN_14(uint128 accountId) internal {</span>
 142 | *   | <span class='executed'>        if (!states[0].actorStates[accountId].isPositionLiquidatable) {</span>
 143 | *   | <span class='executed'>            fl.t(</span>
 144 | *   | <span class='executed'>                !states[1].actorStates[accountId].isPositionLiquidatable,</span>
 145 | *   | <span class='executed'>                MGN_14</span>
 146 |     | <span class='neutral'>            );</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 | *   | <span class='executed'>    function invariant_MGN_15(uint128 accountId) internal {</span>
 151 | *   | <span class='executed'>        if (!states[0].actorStates[accountId].isPositionLiquidatable) {</span>
 152 | *   | <span class='executed'>            fl.t(</span>
 153 | *   | <span class='executed'>                !states[1].actorStates[accountId].isPositionLiquidatable,</span>
 154 | *   | <span class='executed'>                MGN_15</span>
 155 |     | <span class='neutral'>            );</span>
 156 |     | <span class='neutral'>        }</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 | *   | <span class='executed'>    function invariant_MGN_16() internal {</span>
 160 | *   | <span class='executed'>        fl.eq(</span>
 161 | *   | <span class='executed'>            states[1].depositedSusdCollateral,</span>
 162 | *   | <span class='executed'>            uint(states[1].collateralValueAllUsersSUSDCalculated),</span>
 163 | *   | <span class='executed'>            MGN_16</span>
 164 |     | <span class='neutral'>        );</span>
 165 |     | <span class='neutral'></span>
 166 | *   | <span class='executed'>        fl.eq(</span>
 167 | *   | <span class='executed'>            states[1].depositedWethCollateral,</span>
 168 | *   | <span class='executed'>            uint(states[1].collateralValueAllUsersWETHCalculated),</span>
 169 | *   | <span class='executed'>            MGN_16</span>
 170 |     | <span class='neutral'>        );</span>
 171 |     | <span class='neutral'></span>
 172 | *   | <span class='executed'>        fl.eq(</span>
 173 | *   | <span class='executed'>            states[1].depositedWbtcCollateral,</span>
 174 | *   | <span class='executed'>            uint(states[1].collateralValueAllUsersWBTCCalculated),</span>
 175 | *   | <span class='executed'>            MGN_16</span>
 176 |     | <span class='neutral'>        );</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'>}</span>
 179 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties_ORD.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./PropertiesBase.sol&quot;;</span>
   5 |     | <span class='neutral'>import {MathUtil} from &quot;../../utils/MathUtil.sol&quot;;</span>
   6 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>abstract contract Properties_ORD is PropertiesBase {</span>
   9 | *   | <span class='executed'>    function invariant_ORD_01(uint128 account) internal {</span>
  10 | *   | <span class='executed'>        fl.t(</span>
  11 | *   | <span class='executed'>            states[0].actorStates[account].sizeDelta == 0 ||</span>
  12 | *   | <span class='executed'>                states[0].actorStates[account].isOrderExpired,</span>
  13 | *   | <span class='executed'>            ORD_01</span>
  14 |     | <span class='neutral'>        );</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 | *   | <span class='executed'>    function invariant_ORD_02(uint128 account) internal {</span>
  18 | *   | <span class='executed'>        fl.eq(states[1].actorStates[account].sizeDelta, 0, ORD_02);</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 | *   | <span class='executed'>    function invariant_ORD_03(uint128 account) internal {</span>
  22 | *   | <span class='executed'>        fl.t(!states[1].actorStates[account].isPositionLiquidatable, ORD_03);</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 | *   | <span class='executed'>    function invariant_ORD_04(uint128 account) internal {</span>
  26 | *   | <span class='executed'>        fl.gt(</span>
  27 | *   | <span class='executed'>            states[1].actorStates[account].sUSDBalance,</span>
  28 | *   | <span class='executed'>            states[0].actorStates[account].sUSDBalance,</span>
  29 | *   | <span class='executed'>            ORD_04</span>
  30 |     | <span class='neutral'>        );</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 | *   | <span class='executed'>    function invariant_ORD_05(uint128 account) internal {</span>
  34 | *   | <span class='executed'>        fl.gt(</span>
  35 | *   | <span class='executed'>            states[1].actorStates[account].sUSDBalance,</span>
  36 | *   | <span class='executed'>            states[0].actorStates[account].sUSDBalance,</span>
  37 | *   | <span class='executed'>            ORD_05</span>
  38 |     | <span class='neutral'>        );</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    function invariant_ORD_06(uint128 account, uint128 marketId) internal {</span>
  42 |     | <span class='neutral'>        if (marketId == 1) {</span>
  43 |     | <span class='neutral'>            bool positionDecreasing = MathUtil.sameSide(</span>
  44 |     | <span class='neutral'>                states[0].actorStates[account].wethMarket.positionSize,</span>
  45 |     | <span class='neutral'>                states[1].actorStates[account].wethMarket.positionSize</span>
  46 |     | <span class='neutral'>            ) &amp;&amp;</span>
  47 |     | <span class='neutral'>                MathUtil.abs(</span>
  48 |     | <span class='neutral'>                    states[1].actorStates[account].wethMarket.positionSize</span>
  49 |     | <span class='neutral'>                ) &lt; //wethMarket.positionSize</span>
  50 |     | <span class='neutral'>                MathUtil.abs(</span>
  51 |     | <span class='neutral'>                    states[0].actorStates[account].wethMarket.positionSize</span>
  52 |     | <span class='neutral'>                );</span>
  53 |     | <span class='neutral'>            if (!positionDecreasing) {</span>
  54 |     | <span class='neutral'>                // TODO: DG review same Q abt min credit. Is it general value or per market.</span>
  55 |     | <span class='neutral'>                fl.t(</span>
  56 |     | <span class='neutral'>                    states[1].minimumCredit &lt;=</span>
  57 |     | <span class='neutral'>                        states[1].delegatedCollateralValueUsd,</span>
  58 |     | <span class='neutral'>                    ORD_06_WETH</span>
  59 |     | <span class='neutral'>                );</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>        } else if (marketId == 2) {</span>
  62 |     | <span class='neutral'>            bool positionDecreasing = MathUtil.sameSide(</span>
  63 |     | <span class='neutral'>                states[0].actorStates[account].wbtcMarket.positionSize,</span>
  64 |     | <span class='neutral'>                states[1].actorStates[account].wbtcMarket.positionSize</span>
  65 |     | <span class='neutral'>            ) &amp;&amp;</span>
  66 |     | <span class='neutral'>                MathUtil.abs(</span>
  67 |     | <span class='neutral'>                    states[1].actorStates[account].wbtcMarket.positionSize</span>
  68 |     | <span class='neutral'>                ) &lt; //wethMarket.positionSize</span>
  69 |     | <span class='neutral'>                MathUtil.abs(</span>
  70 |     | <span class='neutral'>                    states[0].actorStates[account].wbtcMarket.positionSize</span>
  71 |     | <span class='neutral'>                );</span>
  72 |     | <span class='neutral'>            if (!positionDecreasing) {</span>
  73 |     | <span class='neutral'>                fl.t(</span>
  74 |     | <span class='neutral'>                    states[1].minimumCredit &lt;= states[1].delegatedCollateral,</span>
  75 |     | <span class='neutral'>                    ORD_06_WBTC</span>
  76 |     | <span class='neutral'>                );</span>
  77 |     | <span class='neutral'>            }</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function invariant_ORD_07() internal {</span>
  82 |     | <span class='neutral'>        uint256 utilizationBefore = states[0].utilizationRate;</span>
  83 |     | <span class='neutral'>        uint256 utilizationAfter = states[1].utilizationRate;</span>
  84 |     | <span class='neutral'>        fl.log(&quot;Utilization before:&quot;, utilizationBefore);</span>
  85 |     | <span class='neutral'>        fl.log(&quot;Utilization after:&quot;, utilizationAfter);</span>
  86 |     | <span class='neutral'>        fl.t(utilizationBefore &gt;= 0 &amp;&amp; utilizationBefore &lt;= 1e18, ORD_07);</span>
  87 |     | <span class='neutral'>        fl.t(utilizationAfter &gt;= 0 &amp;&amp; utilizationAfter &lt;= 1e18, ORD_07);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>    function invariant_ORD_08(uint128 account) internal {</span>
  91 |     | <span class='neutral'>        // TODO: introduce markets</span>
  92 | *   | <span class='executed'>        if (</span>
  93 | *   | <span class='executed'>            states[1].actorStates[account].collateralAmountSUSD &gt;=</span>
  94 | *   | <span class='executed'>            states[0].actorStates[account].collateralAmountSUSD</span>
  95 |     | <span class='neutral'>        ) {</span>
  96 | *   | <span class='executed'>            fl.eq(</span>
  97 | *   | <span class='executed'>                states[0].actorStates[account].collateralAmountWETH,</span>
  98 | *   | <span class='executed'>                states[1].actorStates[account].collateralAmountWETH,</span>
  99 | *   | <span class='executed'>                ORD_08_WETH</span>
 100 |     | <span class='neutral'>            );</span>
 101 | *   | <span class='executed'>            fl.eq(</span>
 102 | *   | <span class='executed'>                states[0].actorStates[account].collateralAmountWBTC,</span>
 103 | *   | <span class='executed'>                states[1].actorStates[account].collateralAmountWBTC,</span>
 104 | *   | <span class='executed'>                ORD_08_WBTC</span>
 105 |     | <span class='neutral'>            );</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    event DebugSkeww(int256 a, string s);</span>
 110 |     | <span class='neutral'>    event DebugUint(uint256 a, string s);</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>    function invariant_ORD_09(uint128 account, uint128 marketId) internal {</span>
 113 |     | <span class='neutral'>        // Upscale price to account for -8 exponent.</span>
 114 |     | <span class='neutral'>        //TODO: introduce markets</span>
 115 | *   | <span class='executed'>        bool isLong = states[0].actorStates[account].sizeDelta &gt; 0;</span>
 116 |     | <span class='neutral'>        // Trader gets better price than Pyth price if skew is decreased.</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>        if (marketId == 1) {</span>
 119 | *   | <span class='executed'>            uint256 oraclePrice = uint256(</span>
 120 | *   | <span class='executed'>                pythWrapper.getBenchmarkPrice(WETH_PYTH_PRICE_FEED_ID, 0)</span>
 121 |     | <span class='neutral'>            );</span>
 122 | *   | <span class='executed'>            console2.log(&quot;weth pyth oracle price&quot;, oraclePrice);</span>
 123 | *   | <span class='executed'>            console2.log(&quot;after skew&quot;);</span>
 124 | *   | <span class='executed'>            console2.logInt(states[1].wethMarket.skew);</span>
 125 | *   | <span class='executed'>            console2.log(&quot;after size&quot;, states[1].wethMarket.marketSize);</span>
 126 | *   | <span class='executed'>            console2.log(&quot;before skew&quot;);</span>
 127 | *   | <span class='executed'>            console2.logInt(states[0].wethMarket.skew);</span>
 128 | *   | <span class='executed'>            console2.log(&quot;before size&quot;, states[0].wethMarket.marketSize);</span>
 129 | *   | <span class='executed'>            if (</span>
 130 | *   | <span class='executed'>                MathUtil.abs(states[1].wethMarket.skew) &lt;</span>
 131 | *   | <span class='executed'>                MathUtil.abs(states[0].wethMarket.skew)</span>
 132 |     | <span class='neutral'>            ) {</span>
 133 | *   | <span class='executed'>                if (isLong) {</span>
 134 | *   | <span class='executed'>                    fl.lte(</span>
 135 | *   | <span class='executed'>                        states[0].actorStates[account].fillPriceWETH,</span>
 136 | *   | <span class='executed'>                        oraclePrice,</span>
 137 | *   | <span class='executed'>                        ORD_09</span>
 138 |     | <span class='neutral'>                    );</span>
 139 |     | <span class='neutral'>                } else {</span>
 140 | *   | <span class='executed'>                    fl.gte(</span>
 141 | *   | <span class='executed'>                        states[0].actorStates[account].fillPriceWETH,</span>
 142 | *   | <span class='executed'>                        oraclePrice,</span>
 143 | *   | <span class='executed'>                        ORD_09</span>
 144 |     | <span class='neutral'>                    );</span>
 145 |     | <span class='neutral'>                }</span>
 146 |     | <span class='neutral'>            }</span>
 147 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
 148 | *   | <span class='executed'>            uint256 oraclePrice = uint256(</span>
 149 | *   | <span class='executed'>                pythWrapper.getBenchmarkPrice(WBTC_PYTH_PRICE_FEED_ID, 0)</span>
 150 |     | <span class='neutral'>            );</span>
 151 | *   | <span class='executed'>            console2.log(&quot;wbtc pyth oracle price&quot;, oraclePrice);</span>
 152 | *   | <span class='executed'>            console2.log(&quot;after skew&quot;);</span>
 153 | *   | <span class='executed'>            console2.logInt(states[1].wbtcMarket.skew);</span>
 154 | *   | <span class='executed'>            console2.log(&quot;before skew&quot;);</span>
 155 | *   | <span class='executed'>            console2.logInt(states[0].wbtcMarket.skew);</span>
 156 | *   | <span class='executed'>            if (</span>
 157 | *   | <span class='executed'>                MathUtil.abs(states[1].wbtcMarket.skew) &lt;</span>
 158 | *   | <span class='executed'>                MathUtil.abs(states[0].wbtcMarket.skew)</span>
 159 |     | <span class='neutral'>            ) {</span>
 160 | *   | <span class='executed'>                if (isLong) {</span>
 161 | *   | <span class='executed'>                    fl.lte(</span>
 162 | *   | <span class='executed'>                        states[0].actorStates[account].fillPriceWBTC,</span>
 163 | *   | <span class='executed'>                        oraclePrice,</span>
 164 | *   | <span class='executed'>                        ORD_09</span>
 165 |     | <span class='neutral'>                    );</span>
 166 |     | <span class='neutral'>                } else {</span>
 167 | *   | <span class='executed'>                    fl.gte(</span>
 168 | *   | <span class='executed'>                        states[0].actorStates[account].fillPriceWBTC,</span>
 169 | *   | <span class='executed'>                        oraclePrice,</span>
 170 | *   | <span class='executed'>                        ORD_09</span>
 171 |     | <span class='neutral'>                    );</span>
 172 |     | <span class='neutral'>                }</span>
 173 |     | <span class='neutral'>            }</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    function invariant_ORD_10() internal {</span>
 178 |     | <span class='neutral'>        // utilization rate is always between 0 and 100%</span>
 179 |     | <span class='neutral'>        fl.lte(states[1].utilizationRate, 1e18, ORD_10);</span>
 180 |     | <span class='neutral'>        fl.gte(states[1].utilizationRate, 0, ORD_10);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    // function invariant_ORD_11() internal {</span>
 184 |     | <span class='neutral'>    //     if (</span>
 185 |     | <span class='neutral'>    //         MathUtil.abs(states[1].reportedDebt - states[1].reportedDebtGhost) &gt;</span>
 186 |     | <span class='neutral'>    //         1000</span>
 187 |     | <span class='neutral'>    //     ) {</span>
 188 |     | <span class='neutral'>    //         fl.eq(states[1].reportedDebt, states[1].reportedDebtGhost, ORD_11);</span>
 189 |     | <span class='neutral'>    //     }</span>
 190 |     | <span class='neutral'>    // }</span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>    function invariant_ORD_12(uint128 account) internal {</span>
 193 | *   | <span class='executed'>        fl.t(!states[1].actorStates[account].isMarginLiquidatable, ORD_12);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function invariant_ORD_13(uint128 account) internal {</span>
 197 |     | <span class='neutral'>        fl.t(!states[1].actorStates[account].isMarginLiquidatable, ORD_13);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function invariant_ORD_14() internal {</span>
 201 |     | <span class='neutral'>        fl.eq(</span>
 202 |     | <span class='neutral'>            states[1].wbtcMarket.marketSize + states[1].wethMarket.marketSize,</span>
 203 |     | <span class='neutral'>            states[1].marketSizeGhost,</span>
 204 |     | <span class='neutral'>            ORD_14</span>
 205 |     | <span class='neutral'>        );</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 | *   | <span class='executed'>    function invariant_ORD_15(uint128 account) internal {</span>
 209 | *   | <span class='executed'>        fl.t(!states[1].actorStates[account].isPositionLiquidatable, ORD_15);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function invariant_ORD_16(uint128 account) internal {</span>
 213 |     | <span class='neutral'>        fl.t(!states[1].actorStates[account].isPositionLiquidatable, ORD_16);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    //ORD_17 N/A no stale orders here</span>
 217 |     | <span class='neutral'></span>
 218 | *   | <span class='executed'>    function invariant_ORD_18(uint128 account, uint128 marketId) internal {</span>
 219 | *   | <span class='executed'>        bool shouldContain;</span>
 220 | *   | <span class='executed'>        if (marketId == 1) {</span>
 221 |     | <span class='neutral'>            shouldContain =</span>
 222 | *   | <span class='executed'>                states[1].actorStates[account].wethMarket.positionSize != 0;</span>
 223 | *   | <span class='executed'>        } else if (marketId == 2) {</span>
 224 |     | <span class='neutral'>            shouldContain =</span>
 225 | *   | <span class='executed'>                states[1].actorStates[account].wbtcMarket.positionSize != 0;</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        bool containsMarketId = false;</span>
 229 | *   | <span class='executed'>        for (</span>
 230 | *   | <span class='executed'>            uint i = 0;</span>
 231 | *   | <span class='executed'>            i &lt; states[1].actorStates[account].openPositionMarketIds.length;</span>
 232 | *   | <span class='executed'>            i++</span>
 233 |     | <span class='neutral'>        ) {</span>
 234 | *   | <span class='executed'>            if (</span>
 235 | *   | <span class='executed'>                states[1].actorStates[account].openPositionMarketIds[i] ==</span>
 236 |     | <span class='neutral'>                marketId</span>
 237 |     | <span class='neutral'>            ) {</span>
 238 | *   | <span class='executed'>                containsMarketId = true;</span>
 239 | *   | <span class='executed'>                break;</span>
 240 |     | <span class='neutral'>            }</span>
 241 |     | <span class='neutral'>        }</span>
 242 | *   | <span class='executed'>        fl.t(shouldContain == containsMarketId, ORD_18);</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 | *   | <span class='executed'>    function invariant_ORD_19(uint128 account) internal {</span>
 246 | *   | <span class='executed'>        uint128[] memory accountCollateralTypes = states[1]</span>
 247 |     | <span class='neutral'>            .actorStates[account]</span>
 248 |     | <span class='neutral'>            .activeCollateralTypes;</span>
 249 | *   | <span class='executed'>        uint128[] memory globalCollateralTypes = states[1]</span>
 250 |     | <span class='neutral'>            .globalCollateralTypes;</span>
 251 |     | <span class='neutral'></span>
 252 | *   | <span class='executed'>        if (accountCollateralTypes.length != 0) {</span>
 253 | *   | <span class='executed'>            for (uint i = 0; i &lt; accountCollateralTypes.length; i++) {</span>
 254 | *   | <span class='executed'>                uint128 collateralType = accountCollateralTypes[i];</span>
 255 | *   | <span class='executed'>                fl.log(&quot;accountCollateralTypes[i]&quot;, accountCollateralTypes[i]);</span>
 256 | *   | <span class='executed'>                bool found = false;</span>
 257 |     | <span class='neutral'></span>
 258 | *   | <span class='executed'>                for (uint j = 0; j &lt; globalCollateralTypes.length; j++) {</span>
 259 | *   | <span class='executed'>                    fl.log(</span>
 260 |     | <span class='neutral'>                        &quot;globalCollateralTypes[j]&quot;,</span>
 261 | *   | <span class='executed'>                        globalCollateralTypes[j]</span>
 262 |     | <span class='neutral'>                    );</span>
 263 |     | <span class='neutral'></span>
 264 | *   | <span class='executed'>                    if (collateralType == globalCollateralTypes[j]) {</span>
 265 | *   | <span class='executed'>                        fl.log(</span>
 266 |     | <span class='neutral'>                            &quot;globalCollateralTypes[j]&quot;,</span>
 267 | *   | <span class='executed'>                            globalCollateralTypes[j]</span>
 268 |     | <span class='neutral'>                        );</span>
 269 |     | <span class='neutral'></span>
 270 | *   | <span class='executed'>                        found = true;</span>
 271 | *   | <span class='executed'>                        break;</span>
 272 |     | <span class='neutral'>                    }</span>
 273 |     | <span class='neutral'>                }</span>
 274 |     | <span class='neutral'></span>
 275 | *   | <span class='executed'>                fl.t(found, ORD_19);</span>
 276 |     | <span class='neutral'>            }</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function invariant_ORD_20() internal {</span>
 281 |     | <span class='neutral'>        eqWithTolerance(</span>
 282 |     | <span class='neutral'>            MathUtil.abs(states[1].totalDebtCalculated),</span>
 283 |     | <span class='neutral'>            MathUtil.abs(states[1].totalDebt),</span>
 284 |     | <span class='neutral'>            0.000001e18,</span>
 285 |     | <span class='neutral'>            ORD_20</span>
 286 |     | <span class='neutral'>        );</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    function invariant_ORD_21() internal {</span>
 290 |     | <span class='neutral'>        eqWithTolerance(</span>
 291 |     | <span class='neutral'>            states[1].wethMarket.reportedDebt +</span>
 292 |     | <span class='neutral'>                states[1].wbtcMarket.reportedDebt,</span>
 293 |     | <span class='neutral'>            states[1].reportedDebtGhost,</span>
 294 |     | <span class='neutral'>            0.01e18, //1%</span>
 295 |     | <span class='neutral'>            ORD_21</span>
 296 |     | <span class='neutral'>        );</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 | *   | <span class='executed'>    function invariant_ORD_22(uint128 accountId) internal {</span>
 300 |     | <span class='neutral'>        // Prior debt should not be zero and if existing position prior to settlement was in loss, debt should stay non zero</span>
 301 |     | <span class='neutral'></span>
 302 | *   | <span class='executed'>        console2.log(</span>
 303 |     | <span class='neutral'>            &quot;states[0].actorStates[accountId].debt&quot;,</span>
 304 | *   | <span class='executed'>            states[0].actorStates[accountId].debt</span>
 305 |     | <span class='neutral'>        );</span>
 306 | *   | <span class='executed'>        console2.log(</span>
 307 |     | <span class='neutral'>            &quot;  states[0].actorStates[accountId].chargedAmount &quot;,</span>
 308 | *   | <span class='executed'>            states[0].actorStates[accountId].chargedAmount</span>
 309 |     | <span class='neutral'>        );</span>
 310 |     | <span class='neutral'></span>
 311 | *   | <span class='executed'>        if (</span>
 312 | *   | <span class='executed'>            states[0].actorStates[accountId].debt != 0 &amp;&amp;</span>
 313 | *   | <span class='executed'>            states[0].actorStates[accountId].chargedAmount &lt; 0</span>
 314 |     | <span class='neutral'>        ) {</span>
 315 | *   | <span class='executed'>            console2.log(&quot;entered ord 22 condition&quot;);</span>
 316 | *   | <span class='executed'>            console2.log(</span>
 317 |     | <span class='neutral'>                &quot;states[1].actorStates[accountId].debt&quot;,</span>
 318 | *   | <span class='executed'>                states[1].actorStates[accountId].debt</span>
 319 |     | <span class='neutral'>            );</span>
 320 | *   | <span class='executed'>            fl.t(states[1].actorStates[accountId].debt != 0, ORD_22);</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'>}</span>
 324 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/util/CheckCaller.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>contract CheckCaller {</span>
  5 |     | <span class='unexecuted'>    function checkCaller() public returns (address) {</span>
  6 |     | <span class='unexecuted'>        console2.log(&quot;CheckCaller::msg.sender&quot;, msg.sender);</span>
  7 |     | <span class='unexecuted'>        console2.log(&quot;CheckCaller::tx.origin&quot;, tx.origin);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>        return msg.sender;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/util/FunctionCalls.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@perimetersec/fuzzlib/src/FuzzBase.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../helper/FuzzStorageVariables.sol&quot;;</span>
   6 |     | <span class='neutral'>import {AsyncOrder} from &quot;../../storage/AsyncOrder.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract FunctionCalls is FuzzBase, FuzzStorageVariables {</span>
   9 |     | <span class='neutral'>    event ModifyCollateralCall(</span>
  10 |     | <span class='neutral'>        uint128 accountId,</span>
  11 |     | <span class='neutral'>        uint128 collateralId,</span>
  12 |     | <span class='neutral'>        int256 amountDelta</span>
  13 |     | <span class='neutral'>    );</span>
  14 |     | <span class='neutral'>    event PayDebtCall(uint128 accountId, uint128 amount);</span>
  15 |     | <span class='neutral'>    event SettleOrderCall(address settleUser, uint128 accountId);</span>
  16 |     | <span class='neutral'>    event CancelOrderCall(address settleUser, uint128 accountId);</span>
  17 |     | <span class='neutral'>    event CommitOrderCall(</span>
  18 |     | <span class='neutral'>        uint128 accountId,</span>
  19 |     | <span class='neutral'>        uint128 marketId,</span>
  20 |     | <span class='neutral'>        int128 sizeDelta,</span>
  21 |     | <span class='neutral'>        uint256 acceptablePrice,</span>
  22 |     | <span class='neutral'>        uint128 settlementStrategyId,</span>
  23 |     | <span class='neutral'>        bytes32 trackingCode,</span>
  24 |     | <span class='neutral'>        address referrer</span>
  25 |     | <span class='neutral'>    );</span>
  26 |     | <span class='neutral'>    event LiquidatePositionCall(uint128 accountId);</span>
  27 |     | <span class='neutral'>    event LiquidateMarginOnlyCall(uint128 accountId);</span>
  28 |     | <span class='neutral'>    event LiquidateFlaggedAccountsCall(uint[] flaggedAccounts);</span>
  29 |     | <span class='neutral'>    event LiquidateFlaggedCall(uint maxNumberOfAccounts);</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    function _modifyCollateralCall(</span>
  32 |     | <span class='neutral'>        uint128 accountId,</span>
  33 |     | <span class='neutral'>        uint128 collateralId,</span>
  34 |     | <span class='neutral'>        int256 amountDelta</span>
  35 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
  36 | *   | <span class='executed'>        emit ModifyCollateralCall(accountId, collateralId, amountDelta);</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>        vm.prank(currentActor);</span>
  39 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  40 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  41 |     | <span class='neutral'>                perpsAccountModuleImpl.modifyCollateral.selector,</span>
  42 |     | <span class='neutral'>                accountId,</span>
  43 |     | <span class='neutral'>                collateralId,</span>
  44 |     | <span class='neutral'>                amountDelta</span>
  45 |     | <span class='neutral'>            )</span>
  46 |     | <span class='neutral'>        );</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>    function _payDebtCall(</span>
  50 |     | <span class='neutral'>        uint128 accountId,</span>
  51 |     | <span class='neutral'>        uint128 amount</span>
  52 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
  53 | *   | <span class='executed'>        emit PayDebtCall(accountId, amount);</span>
  54 |     | <span class='neutral'></span>
  55 | *   | <span class='executed'>        vm.prank(currentActor);</span>
  56 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  57 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  58 | *   | <span class='executed'>                perpsAccountModuleImpl.payDebt.selector,</span>
  59 |     | <span class='neutral'>                accountId,</span>
  60 |     | <span class='neutral'>                amount</span>
  61 |     | <span class='neutral'>            )</span>
  62 |     | <span class='neutral'>        );</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 | *   | <span class='executed'>    function _commitOrderCall(</span>
  66 |     | <span class='neutral'>        uint128 accountId,</span>
  67 |     | <span class='neutral'>        uint128 marketId,</span>
  68 |     | <span class='neutral'>        int128 sizeDelta,</span>
  69 |     | <span class='neutral'>        uint256 acceptablePrice,</span>
  70 |     | <span class='neutral'>        uint128 settlementStrategyId,</span>
  71 |     | <span class='neutral'>        bytes32 trackingCode,</span>
  72 |     | <span class='neutral'>        address referrer</span>
  73 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
  74 | *   | <span class='executed'>        emit CommitOrderCall(</span>
  75 | *   | <span class='executed'>            accountId,</span>
  76 | *   | <span class='executed'>            marketId,</span>
  77 | *   | <span class='executed'>            sizeDelta,</span>
  78 | *   | <span class='executed'>            acceptablePrice,</span>
  79 | *   | <span class='executed'>            settlementStrategyId,</span>
  80 | *   | <span class='executed'>            trackingCode,</span>
  81 | *   | <span class='executed'>            referrer</span>
  82 |     | <span class='neutral'>        );</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        AsyncOrder.OrderCommitmentRequest memory commitment = AsyncOrder</span>
  85 |     | <span class='neutral'>            .OrderCommitmentRequest({</span>
  86 |     | <span class='neutral'>                marketId: marketId,</span>
  87 |     | <span class='neutral'>                accountId: accountId,</span>
  88 |     | <span class='neutral'>                sizeDelta: sizeDelta,</span>
  89 |     | <span class='neutral'>                settlementStrategyId: settlementStrategyId,</span>
  90 |     | <span class='neutral'>                acceptablePrice: acceptablePrice,</span>
  91 |     | <span class='neutral'>                trackingCode: trackingCode,</span>
  92 |     | <span class='neutral'>                referrer: referrer</span>
  93 |     | <span class='neutral'>            });</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>        vm.prank(currentActor);</span>
  96 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
  97 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  98 |     | <span class='neutral'>                asyncOrderModuleImpl.commitOrder.selector,</span>
  99 |     | <span class='neutral'>                commitment</span>
 100 |     | <span class='neutral'>            )</span>
 101 |     | <span class='neutral'>        );</span>
 102 |     | <span class='neutral'>    }</span>
 103 | *   | <span class='executed'>    function _settleOrderCall(</span>
 104 |     | <span class='neutral'>        address settleUser,</span>
 105 |     | <span class='neutral'>        uint128 accountId</span>
 106 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 107 | *   | <span class='executed'>        emit SettleOrderCall(settleUser, accountId);</span>
 108 | *   | <span class='executed'>        vm.warp(block.timestamp + 6);</span>
 109 |     | <span class='neutral'></span>
 110 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 111 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
 112 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 113 | *   | <span class='executed'>                asyncOrderSettlementPythModuleImpl.settleOrder.selector,</span>
 114 |     | <span class='neutral'>                accountId</span>
 115 |     | <span class='neutral'>            )</span>
 116 |     | <span class='neutral'>        );</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>    function _cancelOrderCall(</span>
 120 |     | <span class='neutral'>        address settleUser,</span>
 121 |     | <span class='neutral'>        uint128 accountId</span>
 122 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 123 | *   | <span class='executed'>        emit CancelOrderCall(settleUser, accountId);</span>
 124 | *   | <span class='executed'>        vm.warp(block.timestamp + 6);</span>
 125 |     | <span class='neutral'></span>
 126 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 127 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
 128 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 129 | *   | <span class='executed'>                asyncOrderCancelModuleImpl.cancelOrder.selector,</span>
 130 |     | <span class='neutral'>                accountId</span>
 131 |     | <span class='neutral'>            )</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 | *   | <span class='executed'>    function _liquidatePositionCall(</span>
 136 |     | <span class='neutral'>        uint128 accountId</span>
 137 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 138 | *   | <span class='executed'>        emit LiquidatePositionCall(accountId);</span>
 139 |     | <span class='neutral'></span>
 140 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 141 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
 142 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 143 | *   | <span class='executed'>                liquidationModuleImpl.liquidate.selector,</span>
 144 |     | <span class='neutral'>                accountId</span>
 145 |     | <span class='neutral'>            )</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 | *   | <span class='executed'>    function _liquidateMarginOnlyCall(</span>
 150 |     | <span class='neutral'>        uint128 accountId</span>
 151 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 152 | *   | <span class='executed'>        emit LiquidateMarginOnlyCall(accountId);</span>
 153 |     | <span class='neutral'></span>
 154 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 155 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
 156 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 157 | *   | <span class='executed'>                liquidationModuleImpl.liquidateMarginOnly.selector,</span>
 158 |     | <span class='neutral'>                accountId</span>
 159 |     | <span class='neutral'>            )</span>
 160 |     | <span class='neutral'>        );</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 | *   | <span class='executed'>    function _liquidateFlaggedCall(</span>
 164 |     | <span class='neutral'>        uint256 maxNumberOfAccounts</span>
 165 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 166 | *   | <span class='executed'>        emit LiquidateFlaggedCall(maxNumberOfAccounts);</span>
 167 |     | <span class='neutral'></span>
 168 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 169 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
 170 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 171 | *   | <span class='executed'>                liquidationModuleImpl.liquidateFlagged.selector,</span>
 172 |     | <span class='neutral'>                maxNumberOfAccounts</span>
 173 |     | <span class='neutral'>            )</span>
 174 |     | <span class='neutral'>        );</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 | *   | <span class='executed'>    function _liquidateFlaggedAccountsCall(</span>
 178 |     | <span class='neutral'>        uint[] memory flaggedAccounts</span>
 179 | *   | <span class='executed'>    ) internal returns (bool success, bytes memory returnData) {</span>
 180 | *   | <span class='executed'>        emit LiquidateFlaggedAccountsCall(flaggedAccounts);</span>
 181 |     | <span class='neutral'></span>
 182 | *   | <span class='executed'>        vm.prank(currentActor);</span>
 183 | *   | <span class='executed'>        (success, returnData) = perps.call(</span>
 184 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
 185 | *   | <span class='executed'>                liquidationModuleImpl.liquidateFlaggedAccounts.selector,</span>
 186 | *   | <span class='executed'>                flaggedAccounts</span>
 187 |     | <span class='neutral'>            )</span>
 188 |     | <span class='neutral'>        );</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'>}</span>
 191 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/util/FuzzConstants.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../../storage/SettlementStrategy.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>abstract contract FuzzConstants {</span>
   6 |     | <span class='neutral'>    bool internal constant DEBUG = false;</span>
   7 |     | <span class='neutral'></span>
   8 | *   | <span class='executed'>    address internal constant USER1 = address(0x10000);</span>
   9 | *   | <span class='executed'>    address internal constant USER2 = address(0x20000);</span>
  10 | *   | <span class='executed'>    address internal constant USER3 = address(0x30000);</span>
  11 |     | <span class='unexecuted'>    address[] internal USERS = [USER1, USER2, USER3];</span>
  12 |     | <span class='unexecuted'>    uint128[] internal ACCOUNTS = [1, 2, 3];</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    uint256 internal constant INITIAL_BALANCE = 500_000 ether; // 1 Billion USD worth of ETH at $2000/ETH</span>
  15 |     | <span class='unexecuted'>    uint256 internal constant INITIAL_TOKEN_BALANCE = 5_000_000_000; // 5 Billion tokens, to be multiplied by decimals in setup</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    int256 internal constant INT_MAX_ETH_CHANGE_BP = 2000; // 20% is the max change for 1 transaction</span>
  18 |     | <span class='neutral'>    uint256 internal constant UINT_MAX_ETH_CHANGE_BP = 2000; // 20% is the max change for 1 transaction</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    bytes32 internal constant SUSD_ORACLE_NODE_ID = &quot;1&quot;;</span>
  21 |     | <span class='neutral'>    bytes32 internal constant WETH_ORACLE_NODE_ID = &quot;2&quot;;</span>
  22 |     | <span class='neutral'>    bytes32 internal constant WBTC_ORACLE_NODE_ID = &quot;3&quot;;</span>
  23 |     | <span class='neutral'>    bytes32 internal constant HUGE_ORACLE_NODE_ID = &quot;3&quot;;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    bytes32 internal constant KEEPER_NODE_ID = &quot;5&quot;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    bytes32 internal constant WETH_PYTH_PRICE_FEED_ID = &quot;2&quot;;</span>
  28 |     | <span class='neutral'>    bytes32 internal constant WBTC_PYTH_PRICE_FEED_ID = &quot;3&quot;;</span>
  29 |     | <span class='neutral'>    bytes32 internal constant HUGE_PYTH_PRICE_FEED_ID = &quot;3&quot;;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    int64 internal constant WETH_STARTING_PRICE = 3_000 * 1e8;</span>
  32 |     | <span class='unexecuted'>    uint64 internal constant WETH_STARTING_CONF = 1;</span>
  33 |     | <span class='neutral'>    int32 internal constant WETH_STARTING_EXPO = -8;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    int64 internal constant WBTC_STARTING_PRICE = 10_000 * 1e8;</span>
  36 |     | <span class='unexecuted'>    uint64 internal constant WBTC_STARTING_CONF = 1;</span>
  37 |     | <span class='neutral'>    int32 internal constant WBTC_STARTING_EXPO = -8;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    int64 internal constant HUGE_STARTING_PRICE = 1_111 * 1e8;</span>
  40 |     | <span class='unexecuted'>    uint64 internal constant HUGE_STARTING_CONF = 1;</span>
  41 |     | <span class='neutral'>    int32 internal constant HUGE_STARTING_EXPO = -8;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint128 internal constant REWARD_DISTRIBUTOR_WETH_POOL_ID = 1;</span>
  44 |     | <span class='unexecuted'>    uint128 internal constant REWARD_DISTRIBUTOR_WBTC_POOL_ID = 2;</span>
  45 |     | <span class='unexecuted'>    uint128 internal constant REWARD_DISTRIBUTOR_HUGE_POOL_ID = 3;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    bytes32 internal constant KEEPER_SETTLEMENT_COST = 0;</span>
  48 |     | <span class='neutral'>    bytes32 internal constant KEEPER_FLAG_COST = 0;</span>
  49 |     | <span class='neutral'>    bytes32 internal constant KEEPER_LIQUIDATE_COST = 0;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    uint internal constant STRICT_PRICE_TOLERANCE = 60;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    uint internal constant POOL_ID_1 = 1;</span>
  54 |     | <span class='neutral'>    uint internal constant POOL_ID_2 = 2;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    //markets/perps-market/test/integration/Account/Margins.test.ts</span>
  57 |     | <span class='neutral'>    //synthetix/perps-v3-fuzzing-fresh/markets/spot-market/test/AtomicOrderModule.buy.test.ts</span>
  58 |     | <span class='unexecuted'>    uint128 internal constant WETH_MARKET_SKEW_SCALE = 100e18;</span>
  59 |     | <span class='unexecuted'>    uint128 internal constant WBTC_MARKET_SKEW_SCALE = 10000e18;</span>
  60 |     | <span class='neutral'>    uint128 internal constant HUGE_MARKET_SKEW_SCALE = 10000e18;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    // Settlement strategy WETH</span>
  63 |     | <span class='neutral'>    SettlementStrategy.Type internal constant WETH_SETTLEMENT_STRATEGY_TYPE =</span>
  64 |     | <span class='neutral'>        SettlementStrategy.Type.PYTH;</span>
  65 |     | <span class='unexecuted'>    uint256 internal constant WETH_SETTLEMENT_DELAY = 5;</span>
  66 |     | <span class='unexecuted'>    uint256 internal constant WETH_SETTLEMENT_WINDOW_DURATION = 120;</span>
  67 |     | <span class='neutral'>    bytes32 internal constant WETH_FEED_ID = &quot;2&quot;;</span>
  68 |     | <span class='unexecuted'>    uint256 internal constant WETH_SETTLEMENT_REWARD = 5e18;</span>
  69 |     | <span class='neutral'>    bool internal constant WETH_DISABLED = false;</span>
  70 |     | <span class='unexecuted'>    uint256 internal constant WETH_COMMITMENT_PRICE_DELAY = 2;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    // Settlement strategy WBTC</span>
  73 |     | <span class='neutral'>    SettlementStrategy.Type internal constant WBTC_SETTLEMENT_STRATEGY_TYPE =</span>
  74 |     | <span class='neutral'>        SettlementStrategy.Type.PYTH;</span>
  75 |     | <span class='unexecuted'>    uint256 internal constant WBTC_SETTLEMENT_DELAY = 5;</span>
  76 |     | <span class='unexecuted'>    uint256 internal constant WBTC_SETTLEMENT_WINDOW_DURATION = 120;</span>
  77 |     | <span class='neutral'>    bytes32 internal constant WBTC_FEED_ID = &quot;3&quot;;</span>
  78 |     | <span class='unexecuted'>    uint256 internal constant WBTC_SETTLEMENT_REWARD = 5e18;</span>
  79 |     | <span class='neutral'>    bool internal constant WBTC_DISABLED = false;</span>
  80 |     | <span class='unexecuted'>    uint256 internal constant WBTC_COMMITMENT_PRICE_DELAY = 2;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    // Settlement strategy HUGE</span>
  83 |     | <span class='neutral'>    SettlementStrategy.Type internal constant HUGE_SETTLEMENT_STRATEGY_TYPE =</span>
  84 |     | <span class='neutral'>        SettlementStrategy.Type.PYTH;</span>
  85 |     | <span class='neutral'>    uint256 internal constant HUGE_SETTLEMENT_DELAY = 5;</span>
  86 |     | <span class='neutral'>    uint256 internal constant HUGE_SETTLEMENT_WINDOW_DURATION = 120;</span>
  87 |     | <span class='neutral'>    bytes32 internal constant HUGE_FEED_ID = &quot;3&quot;;</span>
  88 |     | <span class='neutral'>    uint256 internal constant HUGE_SETTLEMENT_REWARD = 5e18;</span>
  89 |     | <span class='neutral'>    bool internal constant HUGE_DISABLED = false;</span>
  90 |     | <span class='neutral'>    uint256 internal constant HUGE_COMMITMENT_PRICE_DELAY = 2;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    // SNX USD Collateral Configuration</span>
  93 |     | <span class='neutral'>    uint256 internal constant SNX_USD_COLLATERAL_ID = 0;</span>
  94 |     | <span class='neutral'>    uint256 internal constant SNX_USD_MAX_COLLATERAL_AMOUNT = type(uint256).max;</span>
  95 |     | <span class='neutral'>    uint256 internal constant SNX_USD_UPPER_LIMIT_DISCOUNT = 0;</span>
  96 |     | <span class='neutral'>    uint256 internal constant SNX_USD_LOWER_LIMIT_DISCOUNT = 0;</span>
  97 |     | <span class='neutral'>    uint256 internal constant SNX_USD_DISCOUNT_SCALAR = 0;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    // WETH Collateral Configuration</span>
 100 |     | <span class='neutral'>    uint256 internal constant WETH_COLLATERAL_ID = 1;</span>
 101 |     | <span class='neutral'>    uint256 internal constant WETH_MAX_COLLATERAL_AMOUNT = type(uint256).max;</span>
 102 |     | <span class='neutral'>    uint256 internal constant WETH_UPPER_LIMIT_DISCOUNT = 0;</span>
 103 |     | <span class='neutral'>    uint256 internal constant WETH_LOWER_LIMIT_DISCOUNT = 0;</span>
 104 |     | <span class='neutral'>    uint256 internal constant WETH_DISCOUNT_SCALAR = 0;</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    // WBTC Collateral Configuration</span>
 107 |     | <span class='unexecuted'>    uint256 internal constant WBTC_COLLATERAL_ID = 2;</span>
 108 |     | <span class='neutral'>    uint256 internal constant WBTC_MAX_COLLATERAL_AMOUNT = type(uint256).max;</span>
 109 |     | <span class='neutral'>    uint256 internal constant WBTC_UPPER_LIMIT_DISCOUNT = 0;</span>
 110 |     | <span class='neutral'>    uint256 internal constant WBTC_LOWER_LIMIT_DISCOUNT = 0;</span>
 111 |     | <span class='neutral'>    uint256 internal constant WBTC_DISCOUNT_SCALAR = 0;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    // HUGE Collateral Configuration</span>
 114 |     | <span class='unexecuted'>    uint256 internal constant HUGE_COLLATERAL_ID = 3;</span>
 115 |     | <span class='neutral'>    uint256 internal constant HUGE_MAX_COLLATERAL_AMOUNT = type(uint256).max;</span>
 116 |     | <span class='neutral'>    uint256 internal constant HUGE_UPPER_LIMIT_DISCOUNT = 0;</span>
 117 |     | <span class='neutral'>    uint256 internal constant HUGE_LOWER_LIMIT_DISCOUNT = 0;</span>
 118 |     | <span class='neutral'>    uint256 internal constant HUGE_DISCOUNT_SCALAR = 0;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    // Max Positions and Collaterals Per Account Configuration</span>
 121 |     | <span class='unexecuted'>    uint128 internal constant MAX_POSITIONS_PER_ACCOUNT = 100000;</span>
 122 |     | <span class='neutral'>    uint128 internal constant MAX_COLLATERALS_PER_ACCOUNT = 100000;</span>
 123 |     | <span class='neutral'>    uint128 internal constant HUGE_COLLATERALS_PER_ACCOUNT = 100000;</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    // WETH Funding Parameters</span>
 126 |     | <span class='unexecuted'>    uint128 internal constant WETH_SKEW_SCALE = 1_000_000e18;</span>
 127 |     | <span class='neutral'>    uint256 internal constant WETH_MAX_FUNDING_VELOCITY = 0;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    // WBTC Funding Parameters</span>
 130 |     | <span class='unexecuted'>    uint128 internal constant WBTC_SKEW_SCALE = 1_000_000e18;</span>
 131 |     | <span class='neutral'>    uint256 internal constant WBTC_MAX_FUNDING_VELOCITY = 0;</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    // HUGE Funding Parameters</span>
 134 |     | <span class='unexecuted'>    uint128 internal constant HUGE_SKEW_SCALE = 1_000_000e18;</span>
 135 |     | <span class='neutral'>    uint256 internal constant HUGE_MAX_FUNDING_VELOCITY = 0;</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    // Max Market Sizes</span>
 138 | *   | <span class='executed'>    uint128 internal constant WETH_MAX_MARKET_SIZE = 27_000 * 1e18; //10_000_000;</span>
 139 | *   | <span class='executed'>    uint128 internal constant WBTC_MAX_MARKET_SIZE = 27_000 * 1e18; //10_000_000;</span>
 140 |     | <span class='unexecuted'>    uint128 internal constant HUGE_MAX_MARKET_SIZE = 27_000 * 1e18; //10_000_000;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    // Max Market Values</span>
 143 |     | <span class='neutral'>    uint256 internal constant WETH_MAX_MARKET_VALUE = 0;</span>
 144 |     | <span class='neutral'>    uint256 internal constant WBTC_MAX_MARKET_VALUE = 0;</span>
 145 |     | <span class='neutral'>    uint256 internal constant HUGE_MAX_MARKET_VALUE = 0;</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    // Order Fee Ratios</span>
 148 |     | <span class='unexecuted'>    uint256 internal constant WETH_MAKER_FEE_RATIO = 0.003e18;</span>
 149 |     | <span class='unexecuted'>    uint256 internal constant WETH_TAKER_FEE_RATIO = 0.006e18;</span>
 150 |     | <span class='unexecuted'>    uint256 internal constant WBTC_MAKER_FEE_RATIO = 0.003e18;</span>
 151 |     | <span class='unexecuted'>    uint256 internal constant WBTC_TAKER_FEE_RATIO = 0.006e18;</span>
 152 |     | <span class='unexecuted'>    uint256 internal constant HUGE_MAKER_FEE_RATIO = 0.003e18;</span>
 153 |     | <span class='unexecuted'>    uint256 internal constant HUGE_TAKER_FEE_RATIO = 0.006e18;</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    // WETH Liquidation Parameters</span>
 156 |     | <span class='unexecuted'>    uint256 internal constant WETH_INITIAL_MARGIN_FRACTION = 2e18;</span>
 157 |     | <span class='unexecuted'>    uint256 internal constant WETH_MINIMUM_INITIAL_MARGIN_RATIO = 0.01e18;</span>
 158 |     | <span class='unexecuted'>    uint256 internal constant WETH_MAINTENANCE_MARGIN_SCALAR = 0.5e18;</span>
 159 |     | <span class='unexecuted'>    uint256 internal constant WETH_LIQUIDATION_REWARD_RATIO = 0.05e18;</span>
 160 |     | <span class='unexecuted'>    uint256 internal constant WETH_MINIMUM_POSITION_MARGIN = 1000e18;</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    // WBTC Liquidation Parameters</span>
 163 |     | <span class='unexecuted'>    uint256 internal constant WBTC_INITIAL_MARGIN_FRACTION = 2e18;</span>
 164 |     | <span class='unexecuted'>    uint256 internal constant WBTC_MINIMUM_INITIAL_MARGIN_RATIO = 0.01e18;</span>
 165 |     | <span class='unexecuted'>    uint256 internal constant WBTC_MAINTENANCE_MARGIN_SCALAR = 0.5e18;</span>
 166 |     | <span class='unexecuted'>    uint256 internal constant WBTC_LIQUIDATION_REWARD_RATIO = 0.05e18;</span>
 167 |     | <span class='unexecuted'>    uint256 internal constant WBTC_MINIMUM_POSITION_MARGIN = 1000e18;</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    // WBTC Liquidation Parameters</span>
 170 |     | <span class='unexecuted'>    uint256 internal constant HUGE_INITIAL_MARGIN_FRACTION = 2e18;</span>
 171 |     | <span class='unexecuted'>    uint256 internal constant HUGE_MINIMUM_INITIAL_MARGIN_RATIO = 0.01e18;</span>
 172 |     | <span class='unexecuted'>    uint256 internal constant HUGE_MAINTENANCE_MARGIN_SCALAR = 0.5e18;</span>
 173 |     | <span class='unexecuted'>    uint256 internal constant HUGE_LIQUIDATION_REWARD_RATIO = 0.05e18;</span>
 174 |     | <span class='unexecuted'>    uint256 internal constant HUGE_MINIMUM_POSITION_MARGIN = 1000e18;</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    // WETH Max Liquidation Parameters</span>
 177 |     | <span class='neutral'>    uint256</span>
 178 |     | <span class='neutral'>        internal constant WETH_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER =</span>
 179 |     | <span class='unexecuted'>        0.00001e18;</span>
 180 |     | <span class='unexecuted'>    uint256 internal constant WETH_MAX_SECONDS_IN_LIQUIDATION_WINDOW = 60;</span>
 181 |     | <span class='neutral'>    uint256 internal constant WETH_MAX_LIQUIDATION_PD = 0;</span>
 182 |     | <span class='neutral'>    address internal constant WETH_ENDORSED_LIQUIDATOR = address(0);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    // WBTC Max Liquidation Parameters</span>
 185 |     | <span class='neutral'>    uint256</span>
 186 |     | <span class='neutral'>        internal constant WBTC_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER =</span>
 187 |     | <span class='unexecuted'>        0.00001e18;</span>
 188 |     | <span class='unexecuted'>    uint256 internal constant WBTC_MAX_SECONDS_IN_LIQUIDATION_WINDOW = 60;</span>
 189 |     | <span class='neutral'>    uint256 internal constant WBTC_MAX_LIQUIDATION_PD = 0;</span>
 190 |     | <span class='neutral'>    address internal constant WBTC_ENDORSED_LIQUIDATOR = address(0);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    // HUGE Max Liquidation Parameters</span>
 193 |     | <span class='neutral'>    uint256</span>
 194 |     | <span class='neutral'>        internal constant HUGE_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER =</span>
 195 |     | <span class='unexecuted'>        0.00001e18;</span>
 196 |     | <span class='unexecuted'>    uint256 internal constant HUGE_MAX_SECONDS_IN_LIQUIDATION_WINDOW = 60;</span>
 197 |     | <span class='neutral'>    uint256 internal constant HUGE_MAX_LIQUIDATION_PD = 0;</span>
 198 |     | <span class='neutral'>    address internal constant HUGE_ENDORSED_LIQUIDATOR = address(0);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    //Pyth settings</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    int256 internal constant INT_MAX_SYNTHETIX_USD_CHANGE_BP = 2000; // 20% is the max change for 1 transaction</span>
 203 | *   | <span class='executed'>    int256 internal constant INT_ONE_HUNDRED_BP = 10000;</span>
 204 |     | <span class='neutral'>    int64 internal constant INT_ONE_HUNDRED_BP_64 = 10000;</span>
 205 |     | <span class='neutral'></span>
 206 | *   | <span class='executed'>    uint256 internal constant UINT_MAX_SYNTHETIX_USD_CHANGE_BP = 2000; // 20% is the max change for 1 transaction</span>
 207 | *   | <span class='executed'>    uint256 internal constant UINT_ONE_HUNDRED_BP = 10000;</span>
 208 |     | <span class='neutral'></span>
 209 | *   | <span class='executed'>    int256 internal constant INT_MAX_CHANGE_BP = 2000; // 20% is the max change for 1 transaction</span>
 210 |     | <span class='neutral'>    uint256 internal constant UINT_MAX_CHANGE_BP = 2000; //  2000; // 20% is the max change for 1 transaction</span>
 211 |     | <span class='neutral'></span>
 212 | *   | <span class='executed'>    uint128 internal constant MAX_ALLOWABLE = 10_000_000 * 1e18;</span>
 213 | *   | <span class='executed'>    int256 internal constant PRICE_DIVERGENCE_BPS_256 = 100;</span>
 214 |     | <span class='neutral'>    int64 internal constant PRICE_DIVERGENCE_BPS_64 = 100;</span>
 215 |     | <span class='neutral'>}</span>
 216 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAccountEvents.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Account events used on several places in the system.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='neutral'>interface IAccountEvents {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @notice Gets fired anytime an account is charged with fees, paying settlement rewards.</span>
 10 |     | <span class='neutral'>     * @param accountId Id of the account being deducted.</span>
 11 |     | <span class='neutral'>     * @param amount Amount of synth market deducted from the account.</span>
 12 |     | <span class='neutral'>     * @param accountDebt current debt of the account after charged amount.</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='neutral'>    event AccountCharged(uint128 accountId, int256 amount, uint256 accountDebt);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAsyncOrderCancelModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
  4 |     | <span class='neutral'>import {Position} from &quot;../storage/Position.sol&quot;;</span>
  5 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
  6 |     | <span class='neutral'>import {MarketUpdate} from &quot;../storage/MarketUpdate.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IAsyncOrderCancelModule {</span>
  9 |     | <span class='neutral'>    /**</span>
 10 |     | <span class='neutral'>     * @notice Gets fired when an order is cancelled.</span>
 11 |     | <span class='neutral'>     * @param marketId Id of the market used for the trade.</span>
 12 |     | <span class='neutral'>     * @param accountId Id of the account used for the trade.</span>
 13 |     | <span class='neutral'>     * @param desiredPrice Price at which the order was cancelled.</span>
 14 |     | <span class='neutral'>     * @param fillPrice Price at which the order was cancelled.</span>
 15 |     | <span class='neutral'>     * @param sizeDelta Size delta from order.</span>
 16 |     | <span class='neutral'>     * @param settlementReward Amount of fees collected by the settler.</span>
 17 |     | <span class='neutral'>     * @param trackingCode Optional code for integrator tracking purposes.</span>
 18 |     | <span class='neutral'>     * @param settler address of the settler of the order.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    event OrderCancelled(</span>
 21 |     | <span class='neutral'>        uint128 indexed marketId,</span>
 22 |     | <span class='neutral'>        uint128 indexed accountId,</span>
 23 |     | <span class='neutral'>        uint256 desiredPrice,</span>
 24 |     | <span class='neutral'>        uint256 fillPrice,</span>
 25 |     | <span class='neutral'>        int128 sizeDelta,</span>
 26 |     | <span class='neutral'>        uint256 settlementReward,</span>
 27 |     | <span class='neutral'>        bytes32 indexed trackingCode,</span>
 28 |     | <span class='neutral'>        address settler</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // only used due to stack too deep during settlement</span>
 32 |     | <span class='neutral'>    struct CancelOrderRuntime {</span>
 33 |     | <span class='neutral'>        uint128 marketId;</span>
 34 |     | <span class='neutral'>        uint128 accountId;</span>
 35 |     | <span class='neutral'>        int128 sizeDelta;</span>
 36 |     | <span class='neutral'>        uint256 settlementReward;</span>
 37 |     | <span class='neutral'>        uint256 fillPrice;</span>
 38 |     | <span class='neutral'>        uint256 acceptablePrice;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @notice Cancels an order when price exceeds the acceptable price. Uses the onchain benchmark price at commitment time.</span>
 43 |     | <span class='neutral'>     * @param accountId Id of the account used for the trade.</span>
 44 |     | <span class='neutral'>     */</span>
 45 |     | <span class='neutral'>    function cancelOrder(uint128 accountId) external;</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAsyncOrderModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {AsyncOrder} from &quot;../storage/AsyncOrder.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title Module for committing and settling async orders.</span>
   9 |     | <span class='neutral'> */</span>
  10 |     | <span class='neutral'>interface IAsyncOrderModule {</span>
  11 |     | <span class='neutral'>    /**</span>
  12 |     | <span class='neutral'>     * @notice Gets fired when a new order is committed.</span>
  13 |     | <span class='neutral'>     * @param marketId Id of the market used for the trade.</span>
  14 |     | <span class='neutral'>     * @param accountId Id of the account used for the trade.</span>
  15 |     | <span class='neutral'>     * @param orderType Should send 0 (at time of writing) that correlates to the transaction type enum defined in SettlementStrategy.Type.</span>
  16 |     | <span class='neutral'>     * @param sizeDelta requested change in size of the order sent by the user.</span>
  17 |     | <span class='neutral'>     * @param acceptablePrice maximum or minimum, depending on the sizeDelta direction, accepted price to settle the order, set by the user.</span>
  18 |     | <span class='neutral'>     * @param commitmentTime Time at which the order was committed.</span>
  19 |     | <span class='neutral'>     * @param settlementTime start time of the settlement window.</span>
  20 |     | <span class='neutral'>     * @param expirationTime Time at which the order expired.</span>
  21 |     | <span class='neutral'>     * @param trackingCode Optional code for integrator tracking purposes.</span>
  22 |     | <span class='neutral'>     * @param sender address of the sender of the order. Authorized to commit by account owner.</span>
  23 |     | <span class='neutral'>     */</span>
  24 |     | <span class='neutral'>    event OrderCommitted(</span>
  25 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  26 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  27 |     | <span class='neutral'>        SettlementStrategy.Type orderType,</span>
  28 |     | <span class='neutral'>        int128 sizeDelta,</span>
  29 |     | <span class='neutral'>        uint256 acceptablePrice,</span>
  30 |     | <span class='neutral'>        uint256 commitmentTime,</span>
  31 |     | <span class='neutral'>        uint256 expectedPriceTime,</span>
  32 |     | <span class='neutral'>        uint256 settlementTime,</span>
  33 |     | <span class='neutral'>        uint256 expirationTime,</span>
  34 |     | <span class='neutral'>        bytes32 indexed trackingCode,</span>
  35 |     | <span class='neutral'>        address sender</span>
  36 |     | <span class='neutral'>    );</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @notice Gets fired when a new order is committed while a previous one was expired.</span>
  40 |     | <span class='neutral'>     * @param marketId Id of the market used for the trade.</span>
  41 |     | <span class='neutral'>     * @param accountId Id of the account used for the trade.</span>
  42 |     | <span class='neutral'>     * @param sizeDelta requested change in size of the order sent by the user.</span>
  43 |     | <span class='neutral'>     * @param acceptablePrice maximum or minimum, depending on the sizeDelta direction, accepted price to settle the order, set by the user.</span>
  44 |     | <span class='neutral'>     * @param commitmentTime Time at which the order was committed.</span>
  45 |     | <span class='neutral'>     * @param trackingCode Optional code for integrator tracking purposes.</span>
  46 |     | <span class='neutral'>     */</span>
  47 |     | <span class='neutral'>    event PreviousOrderExpired(</span>
  48 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  49 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  50 |     | <span class='neutral'>        int128 sizeDelta,</span>
  51 |     | <span class='neutral'>        uint256 acceptablePrice,</span>
  52 |     | <span class='neutral'>        uint256 commitmentTime,</span>
  53 |     | <span class='neutral'>        bytes32 indexed trackingCode</span>
  54 |     | <span class='neutral'>    );</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @notice Commit an async order via this function</span>
  58 |     | <span class='neutral'>     * @param commitment Order commitment data (see AsyncOrder.OrderCommitmentRequest struct).</span>
  59 |     | <span class='neutral'>     * @return retOrder order details (see AsyncOrder.Data struct).</span>
  60 |     | <span class='neutral'>     * @return fees order fees (protocol + settler)</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function commitOrder(</span>
  63 |     | <span class='neutral'>        AsyncOrder.OrderCommitmentRequest memory commitment</span>
  64 |     | <span class='neutral'>    ) external returns (AsyncOrder.Data memory retOrder, uint256 fees);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @notice Get async order claim details</span>
  68 |     | <span class='neutral'>     * @param accountId id of the account.</span>
  69 |     | <span class='neutral'>     * @return order async order claim details (see AsyncOrder.Data struct).</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='neutral'>    function getOrder(uint128 accountId) external view returns (AsyncOrder.Data memory order);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>     * @notice Simulates what the order fee would be for the given market with the specified size.</span>
  75 |     | <span class='neutral'>     * @dev    Note that this does not include the settlement reward fee, which is based on the strategy type used</span>
  76 |     | <span class='neutral'>     * @param marketId id of the market.</span>
  77 |     | <span class='neutral'>     * @param sizeDelta size of position.</span>
  78 |     | <span class='neutral'>     * @return orderFees incurred fees.</span>
  79 |     | <span class='neutral'>     * @return fillPrice price at which the order would be filled.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function computeOrderFees(</span>
  82 |     | <span class='neutral'>        uint128 marketId,</span>
  83 |     | <span class='neutral'>        int128 sizeDelta</span>
  84 |     | <span class='neutral'>    ) external view returns (uint256 orderFees, uint256 fillPrice);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @notice Simulates what the order fee would be for the given market with the specified size.</span>
  88 |     | <span class='neutral'>     * @dev    Note that this does not include the settlement reward fee, which is based on the strategy type used</span>
  89 |     | <span class='neutral'>     * @param marketId id of the market.</span>
  90 |     | <span class='neutral'>     * @param sizeDelta size of position.</span>
  91 |     | <span class='neutral'>     * @param price price of the market.</span>
  92 |     | <span class='neutral'>     * @return orderFees incurred fees.</span>
  93 |     | <span class='neutral'>     * @return fillPrice price at which the order would be filled.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function computeOrderFeesWithPrice(</span>
  96 |     | <span class='neutral'>        uint128 marketId,</span>
  97 |     | <span class='neutral'>        int128 sizeDelta,</span>
  98 |     | <span class='neutral'>        uint256 price</span>
  99 |     | <span class='neutral'>    ) external view returns (uint256 orderFees, uint256 fillPrice);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @notice Gets the settlement cost including keeper rewards and keeper costs.</span>
 103 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
 104 |     | <span class='neutral'>     * @param settlementStrategyId Order size.</span>
 105 |     | <span class='neutral'>     * @return settlement cost.</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function getSettlementRewardCost(</span>
 108 |     | <span class='neutral'>        uint128 marketId,</span>
 109 |     | <span class='neutral'>        uint128 settlementStrategyId</span>
 110 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @notice For a given market, account id, and a position size, returns the required total account margin for this order to succeed</span>
 114 |     | <span class='neutral'>     * @dev    Useful for integrators to determine if an order will succeed or fail</span>
 115 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 116 |     | <span class='neutral'>     * @param accountId id of the trader account.</span>
 117 |     | <span class='neutral'>     * @param sizeDelta size of position.</span>
 118 |     | <span class='neutral'>     * @return requiredMargin margin required for the order to succeed.</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='neutral'>    function requiredMarginForOrder(</span>
 121 |     | <span class='neutral'>        uint128 marketId,</span>
 122 |     | <span class='neutral'>        uint128 accountId,</span>
 123 |     | <span class='neutral'>        int128 sizeDelta</span>
 124 |     | <span class='neutral'>    ) external view returns (uint256 requiredMargin);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @notice For a given market, account id, and a position size, and expected price returns the required total account margin for this order to succeed</span>
 128 |     | <span class='neutral'>     * @dev    Useful for integrators to determine if an order will succeed or fail faking different price scenarios</span>
 129 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 130 |     | <span class='neutral'>     * @param accountId id of the trader account.</span>
 131 |     | <span class='neutral'>     * @param sizeDelta size of position.</span>
 132 |     | <span class='neutral'>     * @param price price of the market.</span>
 133 |     | <span class='neutral'>     * @return requiredMargin margin required for the order to succeed.</span>
 134 |     | <span class='neutral'>     */</span>
 135 |     | <span class='neutral'>    function requiredMarginForOrderWithPrice(</span>
 136 |     | <span class='neutral'>        uint128 marketId,</span>
 137 |     | <span class='neutral'>        uint128 accountId,</span>
 138 |     | <span class='neutral'>        int128 sizeDelta,</span>
 139 |     | <span class='neutral'>        uint256 price</span>
 140 |     | <span class='neutral'>    ) external view returns (uint256 requiredMargin);</span>
 141 |     | <span class='neutral'>}</span>
 142 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAsyncOrderSettlementPythModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Position} from &quot;../storage/Position.sol&quot;;</span>
  5 |     | <span class='neutral'>import {MarketUpdate} from &quot;../storage/MarketUpdate.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IAsyncOrderSettlementPythModule {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @notice Gets fired when a new order is settled.</span>
 10 |     | <span class='neutral'>     * @param marketId Id of the market used for the trade.</span>
 11 |     | <span class='neutral'>     * @param accountId Id of the account used for the trade.</span>
 12 |     | <span class='neutral'>     * @param fillPrice Price at which the order was settled.</span>
 13 |     | <span class='neutral'>     * @param pnl Pnl of the previous closed position.</span>
 14 |     | <span class='neutral'>     * @param accruedFunding Accrued funding of the previous closed position.</span>
 15 |     | <span class='neutral'>     * @param sizeDelta Size delta from order.</span>
 16 |     | <span class='neutral'>     * @param newSize New size of the position after settlement.</span>
 17 |     | <span class='neutral'>     * @param totalFees Amount of fees collected by the protocol.</span>
 18 |     | <span class='neutral'>     * @param referralFees Amount of fees collected by the referrer.</span>
 19 |     | <span class='neutral'>     * @param collectedFees Amount of fees collected by fee collector.</span>
 20 |     | <span class='neutral'>     * @param settlementReward reward to sender for settling order.</span>
 21 |     | <span class='neutral'>     * @param trackingCode Optional code for integrator tracking purposes.</span>
 22 |     | <span class='neutral'>     * @param settler address of the settler of the order.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    event OrderSettled(</span>
 25 |     | <span class='neutral'>        uint128 indexed marketId,</span>
 26 |     | <span class='neutral'>        uint128 indexed accountId,</span>
 27 |     | <span class='neutral'>        uint256 fillPrice,</span>
 28 |     | <span class='neutral'>        int256 pnl,</span>
 29 |     | <span class='neutral'>        int256 accruedFunding,</span>
 30 |     | <span class='neutral'>        int128 sizeDelta,</span>
 31 |     | <span class='neutral'>        int128 newSize,</span>
 32 |     | <span class='neutral'>        uint256 totalFees,</span>
 33 |     | <span class='neutral'>        uint256 referralFees,</span>
 34 |     | <span class='neutral'>        uint256 collectedFees,</span>
 35 |     | <span class='neutral'>        uint256 settlementReward,</span>
 36 |     | <span class='neutral'>        bytes32 indexed trackingCode,</span>
 37 |     | <span class='neutral'>        address settler</span>
 38 |     | <span class='neutral'>    );</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @notice Gets fired after order settles and includes the interest charged to the account.</span>
 42 |     | <span class='neutral'>     * @param accountId Id of the account used for the trade.</span>
 43 |     | <span class='neutral'>     * @param interest interest charges</span>
 44 |     | <span class='neutral'>     */</span>
 45 |     | <span class='neutral'>    event InterestCharged(uint128 indexed accountId, uint256 interest);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    // only used due to stack too deep during settlement</span>
 48 |     | <span class='neutral'>    struct SettleOrderRuntime {</span>
 49 |     | <span class='neutral'>        uint128 marketId;</span>
 50 |     | <span class='neutral'>        uint128 accountId;</span>
 51 |     | <span class='neutral'>        int128 sizeDelta;</span>
 52 |     | <span class='neutral'>        int256 pnl;</span>
 53 |     | <span class='neutral'>        uint256 chargedInterest;</span>
 54 |     | <span class='neutral'>        int256 accruedFunding;</span>
 55 |     | <span class='neutral'>        uint256 settlementReward;</span>
 56 |     | <span class='neutral'>        uint256 fillPrice;</span>
 57 |     | <span class='neutral'>        uint256 totalFees;</span>
 58 |     | <span class='neutral'>        uint256 referralFees;</span>
 59 |     | <span class='neutral'>        uint256 feeCollectorFees;</span>
 60 |     | <span class='neutral'>        Position.Data newPosition;</span>
 61 |     | <span class='neutral'>        MarketUpdate.Data updateData;</span>
 62 |     | <span class='neutral'>        uint256 synthDeductionIterator;</span>
 63 |     | <span class='neutral'>        uint128[] deductedSynthIds;</span>
 64 |     | <span class='neutral'>        uint256[] deductedAmount;</span>
 65 |     | <span class='neutral'>        int256 chargedAmount;</span>
 66 |     | <span class='neutral'>        uint256 newAccountDebt;</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    /**</span>
 70 |     | <span class='neutral'>     * @notice Settles an offchain order using the offchain retrieved data from pyth.</span>
 71 |     | <span class='neutral'>     * @param accountId The account id to settle the order</span>
 72 |     | <span class='neutral'>     */</span>
 73 |     | <span class='neutral'>    function settleOrder(uint128 accountId) external;</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/ICollateralConfigurationModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Collateral configuration module.</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface ICollateralConfigurationModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Gets fired when max collateral amount for synth for all the markets is set by owner.</span>
  10 |     | <span class='neutral'>     * @param collateralId Synth market id to use as collateral, 0 for snxUSD.</span>
  11 |     | <span class='neutral'>     * @param maxCollateralAmount max amount that was set for the synth</span>
  12 |     | <span class='neutral'>     * @param upperLimitDiscount upper limit discount that was set for the synth</span>
  13 |     | <span class='neutral'>     * @param lowerLimitDiscount lower limit discount that was set for the synth</span>
  14 |     | <span class='neutral'>     * @param discountScalar discount scalar that was set for the synth</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    event CollateralConfigurationSet(</span>
  17 |     | <span class='neutral'>        uint128 indexed collateralId,</span>
  18 |     | <span class='neutral'>        uint256 maxCollateralAmount,</span>
  19 |     | <span class='neutral'>        uint256 upperLimitDiscount,</span>
  20 |     | <span class='neutral'>        uint256 lowerLimitDiscount,</span>
  21 |     | <span class='neutral'>        uint256 discountScalar</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @notice Gets fired when the collateral liquidation reward ratio is updated.</span>
  26 |     | <span class='neutral'>     * @param collateralLiquidateRewardRatioD18 new collateral liquidation reward ratio.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    event CollateralLiquidateRewardRatioSet(uint128 collateralLiquidateRewardRatioD18);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @notice Gets fired when a new reward distributor is registered.</span>
  32 |     | <span class='neutral'>     * @param distributor the new distributor address.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    event RewardDistributorRegistered(address distributor);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @notice Sets the max collateral amount for a specific synth market.</span>
  38 |     | <span class='neutral'>     * @param collateralId Synth market id to use as collateral, 0 for snxUSD.</span>
  39 |     | <span class='neutral'>     * @param maxCollateralAmount Max collateral amount to set for the synth market id.</span>
  40 |     | <span class='neutral'>     * @param upperLimitDiscount Collateral value is discounted and capped at this value.  In % units.</span>
  41 |     | <span class='neutral'>     * @param lowerLimitDiscount Collateral value is discounted and at minimum, this value.  In % units.</span>
  42 |     | <span class='neutral'>     * @param discountScalar This value is used to scale the impactOnSkew of the collateral.</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='neutral'>    function setCollateralConfiguration(</span>
  45 |     | <span class='neutral'>        uint128 collateralId,</span>
  46 |     | <span class='neutral'>        uint256 maxCollateralAmount,</span>
  47 |     | <span class='neutral'>        uint256 upperLimitDiscount,</span>
  48 |     | <span class='neutral'>        uint256 lowerLimitDiscount,</span>
  49 |     | <span class='neutral'>        uint256 discountScalar</span>
  50 |     | <span class='neutral'>    ) external;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @notice Gets the max collateral amount for a specific synth market.</span>
  54 |     | <span class='neutral'>     * @param collateralId Synth market id, 0 for snxUSD.</span>
  55 |     | <span class='neutral'>     * @return maxCollateralAmount max collateral amount of the specified synth market id</span>
  56 |     | <span class='neutral'>     */</span>
  57 |     | <span class='neutral'>    function getCollateralConfiguration(</span>
  58 |     | <span class='neutral'>        uint128 collateralId</span>
  59 |     | <span class='neutral'>    ) external view returns (uint256 maxCollateralAmount);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @notice Gets the full configuration for collateral.  The above function exists for backwards compatibility; encourage all integrators to use this function</span>
  63 |     | <span class='neutral'>     * @param collateralId Synth market id, 0 for snxUSD.</span>
  64 |     | <span class='neutral'>     * @return maxCollateralAmount max collateral amount of the specified synth market id</span>
  65 |     | <span class='neutral'>     * @return upperLimitDiscount upper bound for max discount on a collateral</span>
  66 |     | <span class='neutral'>     * @return lowerLimitDiscount lower bound for min discount on a collateral</span>
  67 |     | <span class='neutral'>     * @return discountScalar scaling value on the impactOnSkew of the collateral (via spot market)</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function getCollateralConfigurationFull(</span>
  70 |     | <span class='neutral'>        uint128 collateralId</span>
  71 |     | <span class='neutral'>    )</span>
  72 |     | <span class='neutral'>        external</span>
  73 |     | <span class='neutral'>        view</span>
  74 |     | <span class='neutral'>        returns (</span>
  75 |     | <span class='neutral'>            uint256 maxCollateralAmount,</span>
  76 |     | <span class='neutral'>            uint256 upperLimitDiscount,</span>
  77 |     | <span class='neutral'>            uint256 lowerLimitDiscount,</span>
  78 |     | <span class='neutral'>            uint256 discountScalar</span>
  79 |     | <span class='neutral'>        );</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @notice Sets the collateral liquidation reward ratio.</span>
  83 |     | <span class='neutral'>     * @param collateralLiquidateRewardRatioD18 the new collateral liquidation reward ratio.</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    function setCollateralLiquidateRewardRatio(uint128 collateralLiquidateRewardRatioD18) external;</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @notice Gets the collateral liquidation reward ratio.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function getCollateralLiquidateRewardRatio()</span>
  91 |     | <span class='neutral'>        external</span>
  92 |     | <span class='neutral'>        view</span>
  93 |     | <span class='neutral'>        returns (uint128 collateralLiquidateRewardRatioD18);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /**</span>
  96 |     | <span class='neutral'>     * @notice Registers a new reward distributor.</span>
  97 |     | <span class='neutral'>     * @param token the collateral token address.</span>
  98 |     | <span class='neutral'>     * @param distributor the previous distributor address if there was one. Set it to address(0) if first distributor, or need to create a new clone.</span>
  99 |     | <span class='neutral'>     * @param collateralId the collateral id.</span>
 100 |     | <span class='neutral'>     * @param poolDelegatedCollateralTypes the pool delegated collateral types.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function registerDistributor(</span>
 103 |     | <span class='neutral'>        address token,</span>
 104 |     | <span class='neutral'>        address distributor,</span>
 105 |     | <span class='neutral'>        uint128 collateralId,</span>
 106 |     | <span class='neutral'>        address[] calldata poolDelegatedCollateralTypes</span>
 107 |     | <span class='neutral'>    ) external;</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @notice Checks if a distributor is registered.</span>
 111 |     | <span class='neutral'>     * @param distributor the distributor address.</span>
 112 |     | <span class='neutral'>     * @return isRegistered true if the distributor is registered.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function isRegistered(address distributor) external view returns (bool);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /**</span>
 117 |     | <span class='neutral'>     * @notice Gets the registered distributor for a collateral id.</span>
 118 |     | <span class='neutral'>     * @param collateralId the collateral id.</span>
 119 |     | <span class='neutral'>     * @return distributor the distributor address.</span>
 120 |     | <span class='neutral'>     * @return poolDelegatedCollateralTypes the pool delegated collateral types.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='neutral'>    function getRegisteredDistributor(</span>
 123 |     | <span class='neutral'>        uint128 collateralId</span>
 124 |     | <span class='neutral'>    ) external view returns (address distributor, address[] memory poolDelegatedCollateralTypes);</span>
 125 |     | <span class='neutral'>}</span>
 126 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IDistributorErrors.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Distributor errors used on several places in the system.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='neutral'>interface IDistributorErrors {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @notice Thrown when attempting to use a wrong distributor</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'>    error InvalidDistributor(uint128 id, address distributor);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @notice Thrown when attempting to use a wrong contract as distributor</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    error InvalidDistributorContract(address distributor);</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IGlobalPerpsMarketModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Module for global Perps Market settings.</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface IGlobalPerpsMarketModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Gets fired when the interest rate is updated.</span>
  10 |     | <span class='neutral'>     * @param superMarketId global super market id</span>
  11 |     | <span class='neutral'>     * @param interestRate new computed interest rate</span>
  12 |     | <span class='neutral'>     */</span>
  13 |     | <span class='neutral'>    event InterestRateUpdated(uint128 indexed superMarketId, uint128 interestRate);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @notice Gets fired when keeper reward guard is set or updated.</span>
  17 |     | <span class='neutral'>     * @param minKeeperRewardUsd Minimum keeper reward expressed as USD value.</span>
  18 |     | <span class='neutral'>     * @param minKeeperProfitRatioD18 Minimum keeper profit ratio used together with minKeeperRewardUsd to calculate the minimum.</span>
  19 |     | <span class='neutral'>     * @param maxKeeperRewardUsd Maximum keeper reward expressed as USD value.</span>
  20 |     | <span class='neutral'>     * @param maxKeeperScalingRatioD18 Scaling used to calculate the Maximum keeper reward together with maxKeeperRewardUsd.</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    event KeeperRewardGuardsSet(</span>
  23 |     | <span class='neutral'>        uint256 minKeeperRewardUsd,</span>
  24 |     | <span class='neutral'>        uint256 minKeeperProfitRatioD18,</span>
  25 |     | <span class='neutral'>        uint256 maxKeeperRewardUsd,</span>
  26 |     | <span class='neutral'>        uint256 maxKeeperScalingRatioD18</span>
  27 |     | <span class='neutral'>    );</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /**</span>
  30 |     | <span class='neutral'>     * @notice emitted when custom fee collector is set</span>
  31 |     | <span class='neutral'>     * @param feeCollector the address of the fee collector to set.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    event FeeCollectorSet(address feeCollector);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @notice Emitted when the share percentage for a referrer address has been updated.</span>
  37 |     | <span class='neutral'>     * @param referrer The address of the referrer</span>
  38 |     | <span class='neutral'>     * @param shareRatioD18 The new share ratio for the referrer</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    event ReferrerShareUpdated(address referrer, uint256 shareRatioD18);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @notice Emitted when interest rate parameters are set</span>
  44 |     | <span class='neutral'>     * @param lowUtilizationInterestRateGradient interest rate gradient applied to utilization prior to hitting the gradient breakpoint</span>
  45 |     | <span class='neutral'>     * @param interestRateGradientBreakpoint breakpoint at which the interest rate gradient changes from low to high</span>
  46 |     | <span class='neutral'>     * @param highUtilizationInterestRateGradient interest rate gradient applied to utilization after hitting the gradient breakpoint</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    event InterestRateParametersSet(</span>
  49 |     | <span class='neutral'>        uint256 lowUtilizationInterestRateGradient,</span>
  50 |     | <span class='neutral'>        uint256 interestRateGradientBreakpoint,</span>
  51 |     | <span class='neutral'>        uint256 highUtilizationInterestRateGradient</span>
  52 |     | <span class='neutral'>    );</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @notice Gets fired when the max number of Positions and Collaterals per Account are set by owner.</span>
  56 |     | <span class='neutral'>     * @param maxPositionsPerAccount The max number of concurrent Positions per Account</span>
  57 |     | <span class='neutral'>     * @param maxCollateralsPerAccount The max number of concurrent Collaterals per Account</span>
  58 |     | <span class='neutral'>     */</span>
  59 |     | <span class='neutral'>    event PerAccountCapsSet(uint128 maxPositionsPerAccount, uint128 maxCollateralsPerAccount);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @notice Gets fired when feed id for keeper cost node id is updated.</span>
  63 |     | <span class='neutral'>     * @param keeperCostNodeId oracle node id</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    event KeeperCostNodeIdUpdated(bytes32 keeperCostNodeId);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @notice Thrown when the fee collector does not implement the IFeeCollector interface</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    error InvalidFeeCollectorInterface(address invalidFeeCollector);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @notice Thrown when a referrer share gets set to larger than 100%</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    error InvalidReferrerShareRatio(uint256 shareRatioD18);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @notice Thrown when gradient breakpoint is lower than low gradient or higher than high gradient</span>
  79 |     | <span class='neutral'>     */</span>
  80 |     | <span class='neutral'>    error InvalidInterestRateParameters(</span>
  81 |     | <span class='neutral'>        uint128 lowUtilizationInterestRateGradient,</span>
  82 |     | <span class='neutral'>        uint128 highUtilizationInterestRateGradient</span>
  83 |     | <span class='neutral'>    );</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @notice Gets the list of supported collaterals.</span>
  87 |     | <span class='neutral'>     * @return supportedCollaterals list of supported collateral ids. By supported collateral we mean a collateral which max is greater than zero</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function getSupportedCollaterals()</span>
  90 |     | <span class='neutral'>        external</span>
  91 |     | <span class='neutral'>        view</span>
  92 |     | <span class='neutral'>        returns (uint256[] memory supportedCollaterals);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @notice Sets the keeper reward guard (min and max).</span>
  96 |     | <span class='neutral'>     * @param minKeeperRewardUsd Minimum keeper reward expressed as USD value.</span>
  97 |     | <span class='neutral'>     * @param minKeeperProfitRatioD18 Minimum keeper profit ratio used together with minKeeperRewardUsd to calculate the minimum.</span>
  98 |     | <span class='neutral'>     * @param maxKeeperRewardUsd Maximum keeper reward expressed as USD value.</span>
  99 |     | <span class='neutral'>     * @param maxKeeperScalingRatioD18 Scaling used to calculate the Maximum keeper reward together with maxKeeperRewardUsd.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function setKeeperRewardGuards(</span>
 102 |     | <span class='neutral'>        uint256 minKeeperRewardUsd,</span>
 103 |     | <span class='neutral'>        uint256 minKeeperProfitRatioD18,</span>
 104 |     | <span class='neutral'>        uint256 maxKeeperRewardUsd,</span>
 105 |     | <span class='neutral'>        uint256 maxKeeperScalingRatioD18</span>
 106 |     | <span class='neutral'>    ) external;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @notice Gets the keeper reward guard (min and max).</span>
 110 |     | <span class='neutral'>     * @return minKeeperRewardUsd Minimum keeper reward expressed as USD value.</span>
 111 |     | <span class='neutral'>     * @return minKeeperProfitRatioD18 Minimum keeper profit ratio used together with minKeeperRewardUsd to calculate the minimum.</span>
 112 |     | <span class='neutral'>     * @return maxKeeperRewardUsd Maximum keeper reward expressed as USD value.</span>
 113 |     | <span class='neutral'>     * @return maxKeeperScalingRatioD18 Scaling used to calculate the Maximum keeper reward together with maxKeeperRewardUsd.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function getKeeperRewardGuards()</span>
 116 |     | <span class='neutral'>        external</span>
 117 |     | <span class='neutral'>        view</span>
 118 |     | <span class='neutral'>        returns (</span>
 119 |     | <span class='neutral'>            uint256 minKeeperRewardUsd,</span>
 120 |     | <span class='neutral'>            uint256 minKeeperProfitRatioD18,</span>
 121 |     | <span class='neutral'>            uint256 maxKeeperRewardUsd,</span>
 122 |     | <span class='neutral'>            uint256 maxKeeperScalingRatioD18</span>
 123 |     | <span class='neutral'>        );</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /**</span>
 126 |     | <span class='neutral'>     * @notice Gets the total collateral value of all deposited collateral from all traders.</span>
 127 |     | <span class='neutral'>     * @return totalCollateralValue value of all collateral</span>
 128 |     | <span class='neutral'>     */</span>
 129 |     | <span class='neutral'>    function totalGlobalCollateralValue() external view returns (uint256 totalCollateralValue);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @notice Gets the total collateral value of all deposited collateral from all traders.</span>
 133 |     | <span class='neutral'>     * @param collateralId the id of the collateral (0 for snxUSD)</span>
 134 |     | <span class='neutral'>     * @return collateralValue value of all collateral for collateral id</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function globalCollateralValue(</span>
 137 |     | <span class='neutral'>        uint128 collateralId</span>
 138 |     | <span class='neutral'>    ) external view returns (uint256 collateralValue);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @notice Sets the fee collector contract.</span>
 142 |     | <span class='neutral'>     * @dev must conform to the IFeeCollector interface</span>
 143 |     | <span class='neutral'>     * @param feeCollector address of the fee collector contract</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function setFeeCollector(address feeCollector) external;</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @notice Gets the configured feeCollector contract</span>
 149 |     | <span class='neutral'>     * @return feeCollector address of the fee collector contract</span>
 150 |     | <span class='neutral'>     */</span>
 151 |     | <span class='neutral'>    function getFeeCollector() external view returns (address feeCollector);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /**</span>
 154 |     | <span class='neutral'>     * @notice Set or update the max number of Positions and Collaterals per Account</span>
 155 |     | <span class='neutral'>     * @param maxPositionsPerAccount The max number of concurrent Positions per Account</span>
 156 |     | <span class='neutral'>     * @param maxCollateralsPerAccount The max number of concurrent Collaterals per Account</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    function setPerAccountCaps(</span>
 159 |     | <span class='neutral'>        uint128 maxPositionsPerAccount,</span>
 160 |     | <span class='neutral'>        uint128 maxCollateralsPerAccount</span>
 161 |     | <span class='neutral'>    ) external;</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @notice get the max number of Positions and Collaterals per Account</span>
 165 |     | <span class='neutral'>     * @param maxPositionsPerAccount The max number of concurrent Positions per Account</span>
 166 |     | <span class='neutral'>     * @param maxCollateralsPerAccount The max number of concurrent Collaterals per Account</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='neutral'>    function getPerAccountCaps()</span>
 169 |     | <span class='neutral'>        external</span>
 170 |     | <span class='neutral'>        returns (uint128 maxPositionsPerAccount, uint128 maxCollateralsPerAccount);</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @notice Update the referral share percentage for a referrer</span>
 174 |     | <span class='neutral'>     * @param referrer The address of the referrer</span>
 175 |     | <span class='neutral'>     * @param shareRatioD18 The new share percentage for the referrer</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='neutral'>    function updateReferrerShare(address referrer, uint256 shareRatioD18) external;</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /**</span>
 180 |     | <span class='neutral'>     * @notice get the referral share percentage for the specified referrer</span>
 181 |     | <span class='neutral'>     * @param referrer The address of the referrer</span>
 182 |     | <span class='neutral'>     * @return shareRatioD18 The configured share percentage for the referrer</span>
 183 |     | <span class='neutral'>     */</span>
 184 |     | <span class='neutral'>    function getReferrerShare(address referrer) external view returns (uint256 shareRatioD18);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /**</span>
 187 |     | <span class='neutral'>     * @notice Set node id for keeper cost</span>
 188 |     | <span class='neutral'>     * @param keeperCostNodeId the node id</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='neutral'>    function updateKeeperCostNodeId(bytes32 keeperCostNodeId) external;</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    /**</span>
 193 |     | <span class='neutral'>     * @notice Get the node id for keeper cost</span>
 194 |     | <span class='neutral'>     * @return keeperCostNodeId the node id</span>
 195 |     | <span class='neutral'>     */</span>
 196 |     | <span class='neutral'>    function getKeeperCostNodeId() external view returns (bytes32 keeperCostNodeId);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    /**</span>
 199 |     | <span class='neutral'>     * @notice get all existing market ids</span>
 200 |     | <span class='neutral'>     * @return marketIds an array of existing market ids</span>
 201 |     | <span class='neutral'>     */</span>
 202 |     | <span class='neutral'>    function getMarkets() external view returns (uint256[] memory marketIds);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /**</span>
 205 |     | <span class='neutral'>     * @notice Sets the interest rate parameters</span>
 206 |     | <span class='neutral'>     * @param lowUtilizationInterestRateGradient interest rate gradient applied to utilization prior to hitting the gradient breakpoint</span>
 207 |     | <span class='neutral'>     * @param interestRateGradientBreakpoint breakpoint at which the interest rate gradient changes from low to high</span>
 208 |     | <span class='neutral'>     * @param highUtilizationInterestRateGradient interest rate gradient applied to utilization after hitting the gradient breakpoint</span>
 209 |     | <span class='neutral'>     */</span>
 210 |     | <span class='neutral'>    function setInterestRateParameters(</span>
 211 |     | <span class='neutral'>        uint128 lowUtilizationInterestRateGradient,</span>
 212 |     | <span class='neutral'>        uint128 interestRateGradientBreakpoint,</span>
 213 |     | <span class='neutral'>        uint128 highUtilizationInterestRateGradient</span>
 214 |     | <span class='neutral'>    ) external;</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    /**</span>
 217 |     | <span class='neutral'>     * @notice Gets the interest rate parameters</span>
 218 |     | <span class='neutral'>     * @return lowUtilizationInterestRateGradient</span>
 219 |     | <span class='neutral'>     * @return interestRateGradientBreakpoint</span>
 220 |     | <span class='neutral'>     * @return highUtilizationInterestRateGradient</span>
 221 |     | <span class='neutral'>     */</span>
 222 |     | <span class='neutral'>    function getInterestRateParameters()</span>
 223 |     | <span class='neutral'>        external</span>
 224 |     | <span class='neutral'>        view</span>
 225 |     | <span class='neutral'>        returns (</span>
 226 |     | <span class='neutral'>            uint128 lowUtilizationInterestRateGradient,</span>
 227 |     | <span class='neutral'>            uint128 interestRateGradientBreakpoint,</span>
 228 |     | <span class='neutral'>            uint128 highUtilizationInterestRateGradient</span>
 229 |     | <span class='neutral'>        );</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    /**</span>
 232 |     | <span class='neutral'>     * @notice Update the market interest rate based on current utilization of the super market against backing collateral</span>
 233 |     | <span class='neutral'>     * @dev this is a convenience method to manually update interest rate if too much time has passed</span>
 234 |     | <span class='neutral'>     *      since last update.</span>
 235 |     | <span class='neutral'>     * @dev interest rate gets automatically updated when a trade is made or when a position is liquidated</span>
 236 |     | <span class='neutral'>     * @dev InterestRateUpdated event is emitted</span>
 237 |     | <span class='neutral'>     */</span>
 238 |     | <span class='neutral'>    function updateInterestRate() external;</span>
 239 |     | <span class='neutral'>}</span>
 240 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/ILiquidationModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Liquidation module</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface ILiquidationModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Thrown when attempting to liquidate an account not elegible for liquidation</span>
  10 |     | <span class='neutral'>     */</span>
  11 |     | <span class='neutral'>    error NotEligibleForLiquidation(uint128 accountId);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /**</span>
  14 |     | <span class='neutral'>     * @notice Thrown when attempting to liquidate an account&#39;s margin when not elegible for liquidation</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    error NotEligibleForMarginLiquidation(uint128 accountId);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @notice Thrown when attempting to liquidate an account&#39;s margin when it has open positions (should use normal liquidate)</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='neutral'>    error AccountHasOpenPositions(uint128 accountId);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @notice Gets fired when an account position is liquidated .</span>
  25 |     | <span class='neutral'>     * @param marketId Id of the position&#39;s market.</span>
  26 |     | <span class='neutral'>     * @param accountId Id of the account liquidated.</span>
  27 |     | <span class='neutral'>     * @param amountLiquidated amount liquidated.</span>
  28 |     | <span class='neutral'>     * @param currentPositionSize position size after liquidation.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    event PositionLiquidated(</span>
  31 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  32 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  33 |     | <span class='neutral'>        uint256 amountLiquidated,</span>
  34 |     | <span class='neutral'>        int128 currentPositionSize</span>
  35 |     | <span class='neutral'>    );</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='neutral'>     * @notice Gets fired when an account is flagged for liquidation.</span>
  39 |     | <span class='neutral'>     * @param accountId Id of the account flagged.</span>
  40 |     | <span class='neutral'>     * @param availableMargin available margin after flagging.</span>
  41 |     | <span class='neutral'>     * @param requiredMaintenanceMargin required maintenance margin which caused the flagging.</span>
  42 |     | <span class='neutral'>     * @param liquidationReward reward for fully liquidating account paid when liquidation occurs.</span>
  43 |     | <span class='neutral'>     * @param flagReward reward to keeper for flagging the account</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    event AccountFlaggedForLiquidation(</span>
  46 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  47 |     | <span class='neutral'>        int256 availableMargin,</span>
  48 |     | <span class='neutral'>        uint256 requiredMaintenanceMargin,</span>
  49 |     | <span class='neutral'>        uint256 liquidationReward,</span>
  50 |     | <span class='neutral'>        uint256 flagReward</span>
  51 |     | <span class='neutral'>    );</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @notice Gets fired when an account is liquidated.</span>
  55 |     | <span class='neutral'>     * @dev this event is fired once per liquidation tx after the each position that can be liquidated at the time was liquidated.</span>
  56 |     | <span class='neutral'>     * @param accountId Id of the account liquidated.</span>
  57 |     | <span class='neutral'>     * @param reward total reward sent to liquidator.</span>
  58 |     | <span class='neutral'>     * @param fullLiquidation flag indicating if it was a partial or full liquidation.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    event AccountLiquidationAttempt(</span>
  61 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  62 |     | <span class='neutral'>        uint256 reward,</span>
  63 |     | <span class='neutral'>        bool fullLiquidation</span>
  64 |     | <span class='neutral'>    );</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @notice Gets fired when an account margin is liquidated due to not paying down debt.</span>
  68 |     | <span class='neutral'>     * @param accountId Id of the account liquidated.</span>
  69 |     | <span class='neutral'>     * @param seizedMarginValue margin seized due to liquidation.</span>
  70 |     | <span class='neutral'>     * @param liquidationReward reward for liquidating margin account</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='neutral'>    event AccountMarginLiquidation(</span>
  73 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  74 |     | <span class='neutral'>        uint256 seizedMarginValue,</span>
  75 |     | <span class='neutral'>        uint256 liquidationReward</span>
  76 |     | <span class='neutral'>    );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @notice Liquidates an account.</span>
  80 |     | <span class='neutral'>     * @dev according to the current situation and account size it can be a partial or full liquidation.</span>
  81 |     | <span class='neutral'>     * @param accountId Id of the account to liquidate.</span>
  82 |     | <span class='neutral'>     * @return liquidationReward total reward sent to liquidator.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function liquidate(uint128 accountId) external returns (uint256 liquidationReward);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @notice Liquidates an account&#39;s margin when no other positions exist.</span>
  88 |     | <span class='neutral'>     * @dev if available margin is negative and no positions exist, then account margin can be liquidated by calling this function</span>
  89 |     | <span class='neutral'>     * @param accountId Id of the account to liquidate.</span>
  90 |     | <span class='neutral'>     * @return liquidationReward total reward sent to liquidator.</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='neutral'>    function liquidateMarginOnly(uint128 accountId) external returns (uint256 liquidationReward);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @notice Liquidates up to maxNumberOfAccounts flagged accounts.</span>
  96 |     | <span class='neutral'>     * @param maxNumberOfAccounts max number of accounts to liquidate.</span>
  97 |     | <span class='neutral'>     * @return liquidationReward total reward sent to liquidator.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    function liquidateFlagged(</span>
 100 |     | <span class='neutral'>        uint256 maxNumberOfAccounts</span>
 101 |     | <span class='neutral'>    ) external returns (uint256 liquidationReward);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @notice Liquidates the listed flagged accounts.</span>
 105 |     | <span class='neutral'>     * @dev if any of the accounts is not flagged for liquidation it will be skipped.</span>
 106 |     | <span class='neutral'>     * @param accountIds list of account ids to liquidate.</span>
 107 |     | <span class='neutral'>     * @return liquidationReward total reward sent to liquidator.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    function liquidateFlaggedAccounts(</span>
 110 |     | <span class='neutral'>        uint128[] calldata accountIds</span>
 111 |     | <span class='neutral'>    ) external returns (uint256 liquidationReward);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /**</span>
 114 |     | <span class='neutral'>     * @notice Returns the list of flagged accounts.</span>
 115 |     | <span class='neutral'>     * @return accountIds list of flagged accounts.</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'>    function flaggedAccounts() external view returns (uint256[] memory accountIds);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @notice Returns if an account is eligible for liquidation.</span>
 121 |     | <span class='neutral'>     * @return isEligible</span>
 122 |     | <span class='neutral'>     */</span>
 123 |     | <span class='neutral'>    function canLiquidate(uint128 accountId) external view returns (bool isEligible);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /**</span>
 126 |     | <span class='neutral'>     * @notice Returns if an account&#39;s margin is eligible for liquidation.</span>
 127 |     | <span class='neutral'>     * @return isEligible</span>
 128 |     | <span class='neutral'>     */</span>
 129 |     | <span class='neutral'>    function canLiquidateMarginOnly(uint128 accountId) external view returns (bool isEligible);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @notice Current liquidation capacity for the market</span>
 133 |     | <span class='neutral'>     * @return capacity market can liquidate up to this #</span>
 134 |     | <span class='neutral'>     * @return maxLiquidationInWindow max amount allowed to liquidate based on the current market configuration</span>
 135 |     | <span class='neutral'>     * @return latestLiquidationTimestamp timestamp of the last liquidation of the market</span>
 136 |     | <span class='neutral'>     */</span>
 137 |     | <span class='neutral'>    function liquidationCapacity(</span>
 138 |     | <span class='neutral'>        uint128 marketId</span>
 139 |     | <span class='neutral'>    )</span>
 140 |     | <span class='neutral'>        external</span>
 141 |     | <span class='neutral'>        view</span>
 142 |     | <span class='neutral'>        returns (</span>
 143 |     | <span class='neutral'>            uint256 capacity,</span>
 144 |     | <span class='neutral'>            uint256 maxLiquidationInWindow,</span>
 145 |     | <span class='neutral'>            uint256 latestLiquidationTimestamp</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>}</span>
 148 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IMarketConfigurationModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title Module for updating configuration in relation to async order modules.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IMarketConfigurationModule {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @notice Gets fired when new settlement strategy is added.</span>
  12 |     | <span class='neutral'>     * @param marketId adds settlement strategy to this specific market.</span>
  13 |     | <span class='neutral'>     * @param strategy the strategy configuration.</span>
  14 |     | <span class='neutral'>     * @param strategyId the newly created settlement strategy id.</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    event SettlementStrategyAdded(</span>
  17 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  18 |     | <span class='neutral'>        SettlementStrategy.Data strategy,</span>
  19 |     | <span class='neutral'>        uint256 indexed strategyId</span>
  20 |     | <span class='neutral'>    );</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @notice Gets fired when new settlement strategy is updated.</span>
  24 |     | <span class='neutral'>     * @param marketId adds settlement strategy to this specific market.</span>
  25 |     | <span class='neutral'>     * @param strategyId the newly created settlement strategy id.</span>
  26 |     | <span class='neutral'>     * @param strategy the strategy configuration.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    event SettlementStrategySet(</span>
  29 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  30 |     | <span class='neutral'>        uint256 indexed strategyId,</span>
  31 |     | <span class='neutral'>        SettlementStrategy.Data strategy</span>
  32 |     | <span class='neutral'>    );</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @notice Gets fired when feed id for perps market is updated.</span>
  36 |     | <span class='neutral'>     * @param marketId id of perps market</span>
  37 |     | <span class='neutral'>     * @param feedId oracle node id</span>
  38 |     | <span class='neutral'>     * @param strictStalenessTolerance strict price tolerance in seconds (used for liquidations primarily)</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    event MarketPriceDataUpdated(</span>
  41 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  42 |     | <span class='neutral'>        bytes32 feedId,</span>
  43 |     | <span class='neutral'>        uint256 strictStalenessTolerance</span>
  44 |     | <span class='neutral'>    );</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /**</span>
  47 |     | <span class='neutral'>     * @notice Gets fired when order fees are updated.</span>
  48 |     | <span class='neutral'>     * @param marketId udpates fees to this specific market.</span>
  49 |     | <span class='neutral'>     * @param makerFeeRatio the maker fee ratio.</span>
  50 |     | <span class='neutral'>     * @param takerFeeRatio the taker fee ratio.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    event OrderFeesSet(uint128 indexed marketId, uint256 makerFeeRatio, uint256 takerFeeRatio);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @notice Gets fired when funding parameters are updated.</span>
  56 |     | <span class='neutral'>     * @param marketId udpates funding parameters to this specific market.</span>
  57 |     | <span class='neutral'>     * @param skewScale the skew scale.</span>
  58 |     | <span class='neutral'>     * @param maxFundingVelocity the max funding velocity.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    event FundingParametersSet(</span>
  61 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  62 |     | <span class='neutral'>        uint256 skewScale,</span>
  63 |     | <span class='neutral'>        uint256 maxFundingVelocity</span>
  64 |     | <span class='neutral'>    );</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @notice Gets fired when parameters for max liquidation are set</span>
  68 |     | <span class='neutral'>     * @param marketId updates funding parameters to this specific market.</span>
  69 |     | <span class='neutral'>     * @param maxLiquidationLimitAccumulationMultiplier the max liquidation limit accumulation multiplier.</span>
  70 |     | <span class='neutral'>     * @param maxSecondsInLiquidationWindow the max seconds in liquidation window (used together with the acc multiplier to get max liquidation per window).</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='neutral'>    event MaxLiquidationParametersSet(</span>
  73 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  74 |     | <span class='neutral'>        uint256 maxLiquidationLimitAccumulationMultiplier,</span>
  75 |     | <span class='neutral'>        uint256 maxSecondsInLiquidationWindow,</span>
  76 |     | <span class='neutral'>        uint256 maxLiquidationPd,</span>
  77 |     | <span class='neutral'>        address endorsedLiquidator</span>
  78 |     | <span class='neutral'>    );</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @notice Gets fired when liquidation parameters are updated.</span>
  82 |     | <span class='neutral'>     * @param marketId udpates funding parameters to this specific market.</span>
  83 |     | <span class='neutral'>     * @param initialMarginRatioD18 the initial margin ratio (as decimal with 18 digits precision).</span>
  84 |     | <span class='neutral'>     * @param maintenanceMarginRatioD18 the maintenance margin ratio (as decimal with 18 digits precision).</span>
  85 |     | <span class='neutral'>     * @param flagRewardRatioD18 the flag reward ratio (as decimal with 18 digits precision).</span>
  86 |     | <span class='neutral'>     * @param minimumPositionMargin the minimum position margin.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    event LiquidationParametersSet(</span>
  89 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  90 |     | <span class='neutral'>        uint256 initialMarginRatioD18,</span>
  91 |     | <span class='neutral'>        uint256 maintenanceMarginRatioD18,</span>
  92 |     | <span class='neutral'>        uint256 minimumInitialMarginRatioD18,</span>
  93 |     | <span class='neutral'>        uint256 flagRewardRatioD18,</span>
  94 |     | <span class='neutral'>        uint256 minimumPositionMargin</span>
  95 |     | <span class='neutral'>    );</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @notice Gets fired when max market value is updated.</span>
  99 |     | <span class='neutral'>     * @param marketId udpates funding parameters to this specific market.</span>
 100 |     | <span class='neutral'>     * @param maxMarketSize the max market size in units.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    event MaxMarketSizeSet(uint128 indexed marketId, uint256 maxMarketSize);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /**</span>
 105 |     | <span class='neutral'>     * @notice Gets fired when max market value is updated.</span>
 106 |     | <span class='neutral'>     * @param marketId udpates funding parameters to this specific market.</span>
 107 |     | <span class='neutral'>     * @param maxMarketValue the max market value in USD.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    event MaxMarketValueSet(uint128 indexed marketId, uint256 maxMarketValue);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @notice Gets fired when locked oi ratio is updated.</span>
 113 |     | <span class='neutral'>     * @param marketId udpates funding parameters to this specific market.</span>
 114 |     | <span class='neutral'>     * @param lockedOiRatioD18 the locked OI ratio skew scale (as decimal with 18 digits precision).</span>
 115 |     | <span class='neutral'>     */</span>
 116 |     | <span class='neutral'>    event LockedOiRatioSet(uint128 indexed marketId, uint256 lockedOiRatioD18);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @notice Thrown when attempting to set settlement strategy with window duration as 0</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    error InvalidSettlementWindowDuration(uint256 duration);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @notice Add a new settlement strategy with this function.</span>
 125 |     | <span class='neutral'>     * @param marketId id of the market to add the settlement strategy.</span>
 126 |     | <span class='neutral'>     * @param strategy strategy details (see SettlementStrategy.Data struct).</span>
 127 |     | <span class='neutral'>     * @return strategyId id of the new settlement strategy.</span>
 128 |     | <span class='neutral'>     */</span>
 129 |     | <span class='neutral'>    function addSettlementStrategy(</span>
 130 |     | <span class='neutral'>        uint128 marketId,</span>
 131 |     | <span class='neutral'>        SettlementStrategy.Data memory strategy</span>
 132 |     | <span class='neutral'>    ) external returns (uint256 strategyId);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /**</span>
 135 |     | <span class='neutral'>     * @notice updates a settlement strategy for a market with this function.</span>
 136 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 137 |     | <span class='neutral'>     * @param strategyId the specific strategy id.</span>
 138 |     | <span class='neutral'>     * @param strategy strategy details (see SettlementStrategy.Data struct).</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    function setSettlementStrategy(</span>
 141 |     | <span class='neutral'>        uint128 marketId,</span>
 142 |     | <span class='neutral'>        uint256 strategyId,</span>
 143 |     | <span class='neutral'>        SettlementStrategy.Data memory strategy</span>
 144 |     | <span class='neutral'>    ) external;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /**</span>
 147 |     | <span class='neutral'>     * @notice Set order fees for a market with this function.</span>
 148 |     | <span class='neutral'>     * @param marketId id of the market to set order fees.</span>
 149 |     | <span class='neutral'>     * @param makerFeeRatio the maker fee ratio.</span>
 150 |     | <span class='neutral'>     * @param takerFeeRatio the taker fee ratio.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    function setOrderFees(uint128 marketId, uint256 makerFeeRatio, uint256 takerFeeRatio) external;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /**</span>
 155 |     | <span class='neutral'>     * @notice Set node id for perps market</span>
 156 |     | <span class='neutral'>     * @param perpsMarketId id of the market to set price feed.</span>
 157 |     | <span class='neutral'>     * @param feedId the node feed id</span>
 158 |     | <span class='neutral'>     * @param strictStalenessTolerance strict price tolerance in seconds (used for liquidations primarily)</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    function updatePriceData(</span>
 161 |     | <span class='neutral'>        uint128 perpsMarketId,</span>
 162 |     | <span class='neutral'>        bytes32 feedId,</span>
 163 |     | <span class='neutral'>        uint256 strictStalenessTolerance</span>
 164 |     | <span class='neutral'>    ) external;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /**</span>
 167 |     | <span class='neutral'>     * @notice Set funding parameters for a market with this function.</span>
 168 |     | <span class='neutral'>     * @param marketId id of the market to set funding parameters.</span>
 169 |     | <span class='neutral'>     * @param skewScale the skew scale.</span>
 170 |     | <span class='neutral'>     * @param maxFundingVelocity the max funding velocity.</span>
 171 |     | <span class='neutral'>     */</span>
 172 |     | <span class='neutral'>    function setFundingParameters(</span>
 173 |     | <span class='neutral'>        uint128 marketId,</span>
 174 |     | <span class='neutral'>        uint256 skewScale,</span>
 175 |     | <span class='neutral'>        uint256 maxFundingVelocity</span>
 176 |     | <span class='neutral'>    ) external;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    /**</span>
 179 |     | <span class='neutral'>     * @notice Set liquidation parameters for a market with this function.</span>
 180 |     | <span class='neutral'>     * @param marketId id of the market to set liquidation parameters.</span>
 181 |     | <span class='neutral'>     * @param maxLiquidationLimitAccumulationMultiplier the max liquidation limit accumulation multiplier.</span>
 182 |     | <span class='neutral'>     * @param maxSecondsInLiquidationWindow the max seconds in liquidation window (used together with the acc multiplier to get max liquidation per window).</span>
 183 |     | <span class='neutral'>     * @param maxLiquidationPd max allowed pd when calculating max liquidation amount</span>
 184 |     | <span class='neutral'>     * @param endorsedLiquidator address of the endorsed liquidator who can fully liquidate accounts without any restriction</span>
 185 |     | <span class='neutral'>     */</span>
 186 |     | <span class='neutral'>    function setMaxLiquidationParameters(</span>
 187 |     | <span class='neutral'>        uint128 marketId,</span>
 188 |     | <span class='neutral'>        uint256 maxLiquidationLimitAccumulationMultiplier,</span>
 189 |     | <span class='neutral'>        uint256 maxSecondsInLiquidationWindow,</span>
 190 |     | <span class='neutral'>        uint256 maxLiquidationPd,</span>
 191 |     | <span class='neutral'>        address endorsedLiquidator</span>
 192 |     | <span class='neutral'>    ) external;</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /**</span>
 195 |     | <span class='neutral'>     * @notice Set liquidation parameters for a market with this function.</span>
 196 |     | <span class='neutral'>     * @param marketId id of the market to set liquidation parameters.</span>
 197 |     | <span class='neutral'>     * @param initialMarginRatioD18 the initial margin ratio (as decimal with 18 digits precision).</span>
 198 |     | <span class='neutral'>     * @param minimumInitialMarginRatioD18 the minimum initial margin ratio (as decimal with 18 digits precision).</span>
 199 |     | <span class='neutral'>     * @param maintenanceMarginScalarD18 the maintenance margin scalar relative to the initial margin ratio (as decimal with 18 digits precision).</span>
 200 |     | <span class='neutral'>     * @param flagRewardRatioD18 the flag reward ratio (as decimal with 18 digits precision).</span>
 201 |     | <span class='neutral'>     * @param minimumPositionMargin the minimum position margin.</span>
 202 |     | <span class='neutral'>     */</span>
 203 |     | <span class='neutral'>    function setLiquidationParameters(</span>
 204 |     | <span class='neutral'>        uint128 marketId,</span>
 205 |     | <span class='neutral'>        uint256 initialMarginRatioD18,</span>
 206 |     | <span class='neutral'>        uint256 minimumInitialMarginRatioD18,</span>
 207 |     | <span class='neutral'>        uint256 maintenanceMarginScalarD18,</span>
 208 |     | <span class='neutral'>        uint256 flagRewardRatioD18,</span>
 209 |     | <span class='neutral'>        uint256 minimumPositionMargin</span>
 210 |     | <span class='neutral'>    ) external;</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @notice Set the max size of an specific market with this function.</span>
 214 |     | <span class='neutral'>     * @dev This controls the maximum open interest a market can have on either side (Long | Short). So the total Open Interest (with zero skew) for a market can be up to max market size * 2.</span>
 215 |     | <span class='neutral'>     * @param marketId id of the market to set the max market value.</span>
 216 |     | <span class='neutral'>     * @param maxMarketSize the max market size in market asset units.</span>
 217 |     | <span class='neutral'>     */</span>
 218 |     | <span class='neutral'>    function setMaxMarketSize(uint128 marketId, uint256 maxMarketSize) external;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /**</span>
 221 |     | <span class='neutral'>     * @notice Set the max value in USD of an specific market with this function.</span>
 222 |     | <span class='neutral'>     * @param marketId id of the market to set the max market value.</span>
 223 |     | <span class='neutral'>     * @param maxMarketValue the max market size in market USD value.</span>
 224 |     | <span class='neutral'>     */</span>
 225 |     | <span class='neutral'>    function setMaxMarketValue(uint128 marketId, uint256 maxMarketValue) external;</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    /**</span>
 228 |     | <span class='neutral'>     * @notice Set the locked OI Ratio for a market with this function.</span>
 229 |     | <span class='neutral'>     * @param marketId id of the market to set locked OI ratio.</span>
 230 |     | <span class='neutral'>     * @param lockedOiRatioD18 the locked OI ratio skew scale (as decimal with 18 digits precision).</span>
 231 |     | <span class='neutral'>     */</span>
 232 |     | <span class='neutral'>    function setLockedOiRatio(uint128 marketId, uint256 lockedOiRatioD18) external;</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    /**</span>
 235 |     | <span class='neutral'>     * @notice Enable or disable a settlement strategy for a market with this function.</span>
 236 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 237 |     | <span class='neutral'>     * @param strategyId the specific strategy.</span>
 238 |     | <span class='neutral'>     * @param enabled whether the strategy is enabled or disabled.</span>
 239 |     | <span class='neutral'>     */</span>
 240 |     | <span class='neutral'>    function setSettlementStrategyEnabled(</span>
 241 |     | <span class='neutral'>        uint128 marketId,</span>
 242 |     | <span class='neutral'>        uint256 strategyId,</span>
 243 |     | <span class='neutral'>        bool enabled</span>
 244 |     | <span class='neutral'>    ) external;</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    /**</span>
 247 |     | <span class='neutral'>     * @notice Gets the settlement strategy details.</span>
 248 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 249 |     | <span class='neutral'>     * @param strategyId id of the settlement strategy.</span>
 250 |     | <span class='neutral'>     * @return settlementStrategy strategy details (see SettlementStrategy.Data struct).</span>
 251 |     | <span class='neutral'>     */</span>
 252 |     | <span class='neutral'>    function getSettlementStrategy(</span>
 253 |     | <span class='neutral'>        uint128 marketId,</span>
 254 |     | <span class='neutral'>        uint256 strategyId</span>
 255 |     | <span class='neutral'>    ) external view returns (SettlementStrategy.Data memory settlementStrategy);</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /**</span>
 258 |     | <span class='neutral'>     * @notice Gets liquidation parameters details of a market.</span>
 259 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 260 |     | <span class='neutral'>     * @return maxLiquidationLimitAccumulationMultiplier the max liquidation limit accumulation multiplier.</span>
 261 |     | <span class='neutral'>     * @return maxSecondsInLiquidationWindow the max seconds in liquidation window (used together with the acc multiplier to get max liquidation per window).</span>
 262 |     | <span class='neutral'>     * @return maxLiquidationPd max allowed pd when calculating max liquidation amount</span>
 263 |     | <span class='neutral'>     * @return endorsedLiquidator address of the endorsed liquidator who can fully liquidate accounts without any restriction</span>
 264 |     | <span class='neutral'>     */</span>
 265 |     | <span class='neutral'>    function getMaxLiquidationParameters(</span>
 266 |     | <span class='neutral'>        uint128 marketId</span>
 267 |     | <span class='neutral'>    )</span>
 268 |     | <span class='neutral'>        external</span>
 269 |     | <span class='neutral'>        view</span>
 270 |     | <span class='neutral'>        returns (</span>
 271 |     | <span class='neutral'>            uint256 maxLiquidationLimitAccumulationMultiplier,</span>
 272 |     | <span class='neutral'>            uint256 maxSecondsInLiquidationWindow,</span>
 273 |     | <span class='neutral'>            uint256 maxLiquidationPd,</span>
 274 |     | <span class='neutral'>            address endorsedLiquidator</span>
 275 |     | <span class='neutral'>        );</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>    /**</span>
 278 |     | <span class='neutral'>     * @notice Gets liquidation parameters details of a market.</span>
 279 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 280 |     | <span class='neutral'>     * @return initialMarginRatioD18 the initial margin ratio (as decimal with 18 digits precision).</span>
 281 |     | <span class='neutral'>     * @return minimumInitialMarginRatioD18 the minimum initial margin ratio (as decimal with 18 digits precision).</span>
 282 |     | <span class='neutral'>     * @return maintenanceMarginScalarD18 the maintenance margin scalar relative to the initial margin ratio (as decimal with 18 digits precision).</span>
 283 |     | <span class='neutral'>     * @return flagRewardRatioD18 the flag reward ratio (as decimal with 18 digits precision).</span>
 284 |     | <span class='neutral'>     * @return minimumPositionMargin the minimum position margin.</span>
 285 |     | <span class='neutral'>     */</span>
 286 |     | <span class='neutral'>    function getLiquidationParameters(</span>
 287 |     | <span class='neutral'>        uint128 marketId</span>
 288 |     | <span class='neutral'>    )</span>
 289 |     | <span class='neutral'>        external</span>
 290 |     | <span class='neutral'>        view</span>
 291 |     | <span class='neutral'>        returns (</span>
 292 |     | <span class='neutral'>            uint256 initialMarginRatioD18,</span>
 293 |     | <span class='neutral'>            uint256 minimumInitialMarginRatioD18,</span>
 294 |     | <span class='neutral'>            uint256 maintenanceMarginScalarD18,</span>
 295 |     | <span class='neutral'>            uint256 flagRewardRatioD18,</span>
 296 |     | <span class='neutral'>            uint256 minimumPositionMargin</span>
 297 |     | <span class='neutral'>        );</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    /**</span>
 300 |     | <span class='neutral'>     * @notice Gets funding parameters of a market.</span>
 301 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 302 |     | <span class='neutral'>     * @return skewScale the skew scale.</span>
 303 |     | <span class='neutral'>     * @return maxFundingVelocity the max funding velocity.</span>
 304 |     | <span class='neutral'>     */</span>
 305 |     | <span class='neutral'>    function getFundingParameters(</span>
 306 |     | <span class='neutral'>        uint128 marketId</span>
 307 |     | <span class='neutral'>    ) external view returns (uint256 skewScale, uint256 maxFundingVelocity);</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    /**</span>
 310 |     | <span class='neutral'>     * @notice Gets the max size of an specific market.</span>
 311 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 312 |     | <span class='neutral'>     * @return maxMarketSize the max market size in market asset units.</span>
 313 |     | <span class='neutral'>     */</span>
 314 |     | <span class='neutral'>    function getMaxMarketSize(uint128 marketId) external view returns (uint256 maxMarketSize);</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @notice Gets the max size (in value) of an specific market.</span>
 318 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 319 |     | <span class='neutral'>     * @return maxMarketValue the max market size in market USD value.</span>
 320 |     | <span class='neutral'>     */</span>
 321 |     | <span class='neutral'>    function getMaxMarketValue(uint128 marketId) external view returns (uint256 maxMarketValue);</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>    /**</span>
 324 |     | <span class='neutral'>     * @notice Gets the order fees of a market.</span>
 325 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 326 |     | <span class='neutral'>     * @return makerFeeRatio the maker fee ratio.</span>
 327 |     | <span class='neutral'>     * @return takerFeeRatio the taker fee ratio.</span>
 328 |     | <span class='neutral'>     */</span>
 329 |     | <span class='neutral'>    function getOrderFees(</span>
 330 |     | <span class='neutral'>        uint128 marketId</span>
 331 |     | <span class='neutral'>    ) external view returns (uint256 makerFeeRatio, uint256 takerFeeRatio);</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    /**</span>
 334 |     | <span class='neutral'>     * @notice Gets the locked OI ratio of a market.</span>
 335 |     | <span class='neutral'>     * @param marketId id of the market.</span>
 336 |     | <span class='neutral'>     * @return lockedOiRatioD18 the locked OI ratio skew scale (as decimal with 18 digits precision).</span>
 337 |     | <span class='neutral'>     */</span>
 338 |     | <span class='neutral'>    function getLockedOiRatio(uint128 marketId) external view returns (uint256 lockedOiRatioD18);</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    /**</span>
 341 |     | <span class='neutral'>     * @notice Set node id for perps market</span>
 342 |     | <span class='neutral'>     * @param perpsMarketId id of the market to set price feed.</span>
 343 |     | <span class='neutral'>     * @return feedId the node feed id to get price</span>
 344 |     | <span class='neutral'>     * @param strictStalenessTolerance configured strict price tolerance in seconds</span>
 345 |     | <span class='neutral'>     */</span>
 346 |     | <span class='neutral'>    function getPriceData(</span>
 347 |     | <span class='neutral'>        uint128 perpsMarketId</span>
 348 |     | <span class='neutral'>    ) external view returns (bytes32 feedId, uint256 strictStalenessTolerance);</span>
 349 |     | <span class='neutral'>}</span>
 350 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IMarketEvents.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Market events used on several places in the system.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IMarketEvents {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @notice Gets thrown when settle order is called with invalid settlement strategy.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    error SettlementStrategyNotFound(SettlementStrategy.Type strategyType);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @notice Gets fired when the size of a market is updated by new orders or liquidations.</span>
 17 |     | <span class='neutral'>     * @param marketId Id of the market used for the trade.</span>
 18 |     | <span class='neutral'>     * @param price Price at the time of this event.</span>
 19 |     | <span class='neutral'>     * @param skew Market skew at the time of the trade. Positive values mean more longs.</span>
 20 |     | <span class='neutral'>     * @param size Size of the entire market after settlement.</span>
 21 |     | <span class='neutral'>     * @param sizeDelta Change in market size during this update.</span>
 22 |     | <span class='neutral'>     * @param currentFundingRate The current funding rate of this market (0.001 = 0.1% per day)</span>
 23 |     | <span class='neutral'>     * @param currentFundingVelocity The current rate of change of the funding rate (0.001 = +0.1% per day)</span>
 24 |     | <span class='neutral'>     * @param interestRate Current supermarket interest rate based on updated market OI.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    event MarketUpdated(</span>
 27 |     | <span class='neutral'>        uint128 marketId,</span>
 28 |     | <span class='neutral'>        uint256 price,</span>
 29 |     | <span class='neutral'>        int256 skew,</span>
 30 |     | <span class='neutral'>        uint256 size,</span>
 31 |     | <span class='neutral'>        int256 sizeDelta,</span>
 32 |     | <span class='neutral'>        int256 currentFundingRate,</span>
 33 |     | <span class='neutral'>        int256 currentFundingVelocity,</span>
 34 |     | <span class='neutral'>        uint128 interestRate</span>
 35 |     | <span class='neutral'>    );</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IPerpsAccountModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Account module</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface IPerpsAccountModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Gets fired when an account colateral is modified.</span>
  10 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  11 |     | <span class='neutral'>     * @param collateralId Id of the synth market used as collateral. Synth market id, 0 for snxUSD.</span>
  12 |     | <span class='neutral'>     * @param amountDelta requested change in amount of collateral delegated to the account.</span>
  13 |     | <span class='neutral'>     * @param sender address of the sender of the size modification. Authorized by account owner.</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    event CollateralModified(</span>
  16 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  17 |     | <span class='neutral'>        uint128 indexed collateralId,</span>
  18 |     | <span class='neutral'>        int256 amountDelta,</span>
  19 |     | <span class='neutral'>        address indexed sender</span>
  20 |     | <span class='neutral'>    );</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event DebtPaid(uint128 indexed accountId, uint256 amount, address indexed sender);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @notice Gets thrown when the amount delta is zero.</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='neutral'>    error InvalidAmountDelta(int256 amountDelta);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /**</span>
  30 |     | <span class='neutral'>     * @notice Modify the collateral delegated to the account.</span>
  31 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  32 |     | <span class='neutral'>     * @param collateralId Id of the synth market used as collateral. Synth market id, 0 for snxUSD.</span>
  33 |     | <span class='neutral'>     * @param amountDelta requested change in amount of collateral delegated to the account.</span>
  34 |     | <span class='neutral'>     */</span>
  35 |     | <span class='neutral'>    function modifyCollateral(uint128 accountId, uint128 collateralId, int256 amountDelta) external;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='neutral'>     * @notice Gets the account&#39;s collateral value for a specific collateral.</span>
  39 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  40 |     | <span class='neutral'>     * @param collateralId Id of the synth market used as collateral. Synth market id, 0 for snxUSD.</span>
  41 |     | <span class='neutral'>     * @return collateralValue collateral value of the account.</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    function getCollateralAmount(</span>
  44 |     | <span class='neutral'>        uint128 accountId,</span>
  45 |     | <span class='neutral'>        uint128 collateralId</span>
  46 |     | <span class='neutral'>    ) external view returns (uint256);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @notice Gets the account&#39;s collaterals ids</span>
  50 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    function getAccountCollateralIds(uint128 accountId) external view returns (uint256[] memory);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @notice Gets all markets that a given account id has a position in</span>
  56 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    function getAccountOpenPositions(uint128 accountId) external view returns (uint256[] memory);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @notice Gets the account&#39;s total collateral value without the discount applied.</span>
  62 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  63 |     | <span class='neutral'>     * @return collateralValue total collateral value of the account without discount. USD denominated.</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    function totalCollateralValue(uint128 accountId) external view returns (uint256);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @notice Gets the account&#39;s total open interest value.</span>
  69 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  70 |     | <span class='neutral'>     * @return openInterestValue total open interest value of the account.</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='neutral'>    function totalAccountOpenInterest(uint128 accountId) external view returns (uint256);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @notice Gets the details of an open position.</span>
  76 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  77 |     | <span class='neutral'>     * @param marketId Id of the position market.</span>
  78 |     | <span class='neutral'>     * @return totalPnl pnl of the entire position including funding.</span>
  79 |     | <span class='neutral'>     * @return accruedFunding accrued funding of the position.</span>
  80 |     | <span class='neutral'>     * @return positionSize size of the position.</span>
  81 |     | <span class='neutral'>     * @return owedInterest interest owed due to open position.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    function getOpenPosition(</span>
  84 |     | <span class='neutral'>        uint128 accountId,</span>
  85 |     | <span class='neutral'>        uint128 marketId</span>
  86 |     | <span class='neutral'>    )</span>
  87 |     | <span class='neutral'>        external</span>
  88 |     | <span class='neutral'>        view</span>
  89 |     | <span class='neutral'>        returns (int256 totalPnl, int256 accruedFunding, int128 positionSize, uint256 owedInterest);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @notice Gets an account open position data for a given account id and market id</span>
  93 |     | <span class='neutral'>     * @notice this function doesn&#39;t have any price staleness requirement</span>
  94 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
  95 |     | <span class='neutral'>     * @param marketId Id of the position market.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function getOpenPositionSize(</span>
  98 |     | <span class='neutral'>        uint128 accountId,</span>
  99 |     | <span class='neutral'>        uint128 marketId</span>
 100 |     | <span class='neutral'>    ) external view returns (int128 positionSize);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @notice Gets the available margin of an account. It can be negative due to pnl.</span>
 104 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
 105 |     | <span class='neutral'>     * @return availableMargin available margin of the position.</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function getAvailableMargin(uint128 accountId) external view returns (int256 availableMargin);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @notice Gets the exact withdrawable amount a trader has available from this account while holding the account&#39;s current positions.</span>
 111 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
 112 |     | <span class='neutral'>     * @return withdrawableMargin available margin to withdraw.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function getWithdrawableMargin(</span>
 115 |     | <span class='neutral'>        uint128 accountId</span>
 116 |     | <span class='neutral'>    ) external view returns (int256 withdrawableMargin);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @notice Gets the initial/maintenance margins across all positions that an account has open.</span>
 120 |     | <span class='neutral'>     * @dev Note that requiredInitialMargin and requiredMaintenanceMargin includes the liquidation rewards, in case you want the value without it you need to substract maxLiquidationReward.</span>
 121 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
 122 |     | <span class='neutral'>     * @return requiredInitialMargin initial margin req (used when withdrawing collateral).</span>
 123 |     | <span class='neutral'>     * @return requiredMaintenanceMargin maintenance margin req (used to determine liquidation threshold).</span>
 124 |     | <span class='neutral'>     * @return maxLiquidationReward max liquidation reward the keeper would receive if account was fully liquidated. Note here that the accumulated rewards are checked against the global max/min configured liquidation rewards.</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='neutral'>    function getRequiredMargins(</span>
 127 |     | <span class='neutral'>        uint128 accountId</span>
 128 |     | <span class='neutral'>    )</span>
 129 |     | <span class='neutral'>        external</span>
 130 |     | <span class='neutral'>        view</span>
 131 |     | <span class='neutral'>        returns (</span>
 132 |     | <span class='neutral'>            uint256 requiredInitialMargin,</span>
 133 |     | <span class='neutral'>            uint256 requiredMaintenanceMargin,</span>
 134 |     | <span class='neutral'>            uint256 maxLiquidationReward</span>
 135 |     | <span class='neutral'>        );</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /**</span>
 138 |     | <span class='neutral'>     * @notice Allows anyone to pay an account&#39;s debt</span>
 139 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
 140 |     | <span class='neutral'>     * @param amount debt amount to pay off</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='neutral'>    function payDebt(uint128 accountId, uint256 amount) external;</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /**</span>
 145 |     | <span class='neutral'>     * @notice Returns account&#39;s debt</span>
 146 |     | <span class='neutral'>     * @param accountId Id of the account.</span>
 147 |     | <span class='neutral'>     * @return accountDebt specified account id&#39;s debt</span>
 148 |     | <span class='neutral'>     */</span>
 149 |     | <span class='neutral'>    function debt(uint128 accountId) external view returns (uint256 accountDebt);</span>
 150 |     | <span class='neutral'>}</span>
 151 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IPerpsMarketFactoryModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IMarket} from &quot;@synthetixio/main/contracts/interfaces/external/IMarket.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ISynthetixSystem} from &quot;./external/ISynthetixSystem.sol&quot;;</span>
  6 |     | <span class='neutral'>import {ISpotMarketSystem} from &quot;./external/ISpotMarketSystem.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title Perps Market Factory module</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IPerpsMarketFactoryModule is IMarket {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @notice Gets fired when the factory is initialized.</span>
 14 |     | <span class='neutral'>     * @param globalPerpsMarketId the new global perps market id.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event FactoryInitialized(uint128 globalPerpsMarketId);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @notice Gets fired when a market is created.</span>
 20 |     | <span class='neutral'>     * @param perpsMarketId the newly created perps market id.</span>
 21 |     | <span class='neutral'>     * @param marketName the newly created perps market name.</span>
 22 |     | <span class='neutral'>     * @param marketSymbol the newly created perps market symbol.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    event MarketCreated(uint128 indexed perpsMarketId, string marketName, string marketSymbol);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /**</span>
 27 |     | <span class='neutral'>     * @notice Initializes the factory.</span>
 28 |     | <span class='neutral'>     * @dev this function should be called only once.</span>
 29 |     | <span class='neutral'>     * @return globalPerpsMarketId Id of the global perps market id.</span>
 30 |     | <span class='neutral'>     */</span>
 31 |     | <span class='neutral'>    function initializeFactory(</span>
 32 |     | <span class='neutral'>        ISynthetixSystem synthetix,</span>
 33 |     | <span class='neutral'>        ISpotMarketSystem spotMarket</span>
 34 |     | <span class='neutral'>    ) external returns (uint128);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /**</span>
 37 |     | <span class='neutral'>     * @notice Sets the perps market name.</span>
 38 |     | <span class='neutral'>     * @param marketName the new perps market name.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    function setPerpsMarketName(string memory marketName) external;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /**</span>
 43 |     | <span class='neutral'>     * @notice Creates a new market.</span>
 44 |     | <span class='neutral'>     * @param requestedMarketId id of the market to create.</span>
 45 |     | <span class='neutral'>     * @param marketName name of the market to create.</span>
 46 |     | <span class='neutral'>     * @param marketSymbol symbol of the market to create.</span>
 47 |     | <span class='neutral'>     * @return perpsMarketId Id of the created perps market.</span>
 48 |     | <span class='neutral'>     */</span>
 49 |     | <span class='neutral'>    function createMarket(</span>
 50 |     | <span class='neutral'>        uint128 requestedMarketId,</span>
 51 |     | <span class='neutral'>        string memory marketName,</span>
 52 |     | <span class='neutral'>        string memory marketSymbol</span>
 53 |     | <span class='neutral'>    ) external returns (uint128);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /**</span>
 56 |     | <span class='neutral'>     * @notice Returns the current market interest rate</span>
 57 |     | <span class='neutral'>     * @return rate</span>
 58 |     | <span class='neutral'>     */</span>
 59 |     | <span class='neutral'>    function interestRate() external view returns (uint128 rate);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    /**</span>
 62 |     | <span class='neutral'>     * @notice Returns the super market utilization rate</span>
 63 |     | <span class='neutral'>     * @dev The rate is the minimumCredit / delegatedCollateral available.</span>
 64 |     | <span class='neutral'>     * @dev Locked credit is the sum of all markets open interest * configured lockedOiRatio</span>
 65 |     | <span class='neutral'>     * @dev delegatedCollateral is the avaialble collateral value for markets to withdraw, delegated by LPs</span>
 66 |     | <span class='neutral'>     * @return rate</span>
 67 |     | <span class='neutral'>     * @return delegatedCollateral</span>
 68 |     | <span class='neutral'>     * @return lockedCredit credit locked based on OI &amp; lockedOiRatio</span>
 69 |     | <span class='neutral'>     */</span>
 70 |     | <span class='neutral'>    function utilizationRate()</span>
 71 |     | <span class='neutral'>        external</span>
 72 |     | <span class='neutral'>        view</span>
 73 |     | <span class='neutral'>        returns (uint256 rate, uint256 delegatedCollateral, uint256 lockedCredit);</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IPerpsMarketModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Perps market module</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface IPerpsMarketModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Market Summary structured data.</span>
  10 |     | <span class='neutral'>     */</span>
  11 |     | <span class='neutral'>    struct MarketSummary {</span>
  12 |     | <span class='neutral'>        // @dev Skew of the market in units of native asse</span>
  13 |     | <span class='neutral'>        int256 skew;</span>
  14 |     | <span class='neutral'>        // @dev Size of the market in units of native asset</span>
  15 |     | <span class='neutral'>        uint256 size;</span>
  16 |     | <span class='neutral'>        // @dev Max open interest of the market in units of native asset</span>
  17 |     | <span class='neutral'>        uint256 maxOpenInterest;</span>
  18 |     | <span class='neutral'>        // @dev Current funding rate of the market</span>
  19 |     | <span class='neutral'>        int256 currentFundingRate;</span>
  20 |     | <span class='neutral'>        // @dev Current funding velocity of the market</span>
  21 |     | <span class='neutral'>        int256 currentFundingVelocity;</span>
  22 |     | <span class='neutral'>        // @dev Index price of the market</span>
  23 |     | <span class='neutral'>        uint256 indexPrice;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /**</span>
  27 |     | <span class='neutral'>     * @notice Gets a market metadata.</span>
  28 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  29 |     | <span class='neutral'>     * @return name Name of the market.</span>
  30 |     | <span class='neutral'>     * @return symbol Symbol of the market.</span>
  31 |     | <span class='neutral'>     */</span>
  32 |     | <span class='neutral'>    function metadata(</span>
  33 |     | <span class='neutral'>        uint128 marketId</span>
  34 |     | <span class='neutral'>    ) external view returns (string memory name, string memory symbol);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @notice Gets a market&#39;s skew.</span>
  38 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  39 |     | <span class='neutral'>     * @return skew Skew of the market.</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    function skew(uint128 marketId) external view returns (int256);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @notice Gets a market&#39;s size.</span>
  45 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  46 |     | <span class='neutral'>     * @return size Size of the market.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    function size(uint128 marketId) external view returns (uint256);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Gets a market&#39;s max open interest.</span>
  52 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  53 |     | <span class='neutral'>     * @return maxOpenInterest Max open interest of the market.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function maxOpenInterest(uint128 marketId) external view returns (uint256);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @notice Gets a market&#39;s current funding rate.</span>
  59 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  60 |     | <span class='neutral'>     * @return currentFundingRate Current funding rate of the market.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function currentFundingRate(uint128 marketId) external view returns (int256);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @notice Gets a market&#39;s current funding velocity.</span>
  66 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  67 |     | <span class='neutral'>     * @return currentFundingVelocity Current funding velocity of the market.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function currentFundingVelocity(uint128 marketId) external view returns (int256);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @notice Gets a market&#39;s index price.</span>
  73 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  74 |     | <span class='neutral'>     * @return indexPrice Index price of the market.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function indexPrice(uint128 marketId) external view returns (uint256);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @notice Gets a market&#39;s fill price for a specific order size and index price.</span>
  80 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  81 |     | <span class='neutral'>     * @param orderSize Order size.</span>
  82 |     | <span class='neutral'>     * @param price Index price.</span>
  83 |     | <span class='neutral'>     * @return price Fill price.</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    function fillPrice(</span>
  86 |     | <span class='neutral'>        uint128 marketId,</span>
  87 |     | <span class='neutral'>        int128 orderSize,</span>
  88 |     | <span class='neutral'>        uint256 price</span>
  89 |     | <span class='neutral'>    ) external view returns (uint256);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @notice Given a marketId return a market&#39;s summary details in one call.</span>
  93 |     | <span class='neutral'>     * @param marketId Id of the market.</span>
  94 |     | <span class='neutral'>     * @return summary Market summary (see MarketSummary).</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='neutral'>    function getMarketSummary(</span>
  97 |     | <span class='neutral'>        uint128 marketId</span>
  98 |     | <span class='neutral'>    ) external view returns (MarketSummary memory summary);</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/IFeeCollector.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IFeeCollector is IERC165 {</span>
  7 |     | <span class='neutral'>    /**</span>
  8 |     | <span class='neutral'>     * @notice  .This function is called by the spot market proxy to get the fee amount to be collected.</span>
  9 |     | <span class='neutral'>     * @dev     .The quoted fee amount is then transferred directly to the fee collector.</span>
 10 |     | <span class='neutral'>     * @param   marketId  .synth market id value</span>
 11 |     | <span class='neutral'>     * @param   feeAmount  .max fee amount that can be collected</span>
 12 |     | <span class='neutral'>     * @param   transactor  .the trader the fee was collected from</span>
 13 |     | <span class='neutral'>     * @return  feeAmountToCollect  .quoted fee amount</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function quoteFees(</span>
 16 |     | <span class='neutral'>        uint128 marketId,</span>
 17 |     | <span class='neutral'>        uint256 feeAmount,</span>
 18 |     | <span class='neutral'>        address transactor</span>
 19 |     | <span class='neutral'>    ) external returns (uint256 feeAmountToCollect);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/IPythERC7412Wrapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IPythERC7412Wrapper {</span>
  5 |     | <span class='neutral'>    error OracleDataRequired(address oracleContract, bytes oracleQuery);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function getBenchmarkPrice(</span>
  8 |     | <span class='neutral'>        bytes32 priceId,</span>
  9 |     | <span class='neutral'>        uint64 requestedTime</span>
 10 |     | <span class='neutral'>    ) external view returns (int256);</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/ISpotMarketSystem.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAtomicOrderModule} from &quot;@synthetixio/spot-market/contracts/interfaces/IAtomicOrderModule.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ISpotMarketFactoryModule} from &quot;@synthetixio/spot-market/contracts/interfaces/ISpotMarketFactoryModule.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IMarketConfigurationModule} from &quot;@synthetixio/spot-market/contracts/interfaces/IMarketConfigurationModule.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
  9 |     | <span class='neutral'>interface ISpotMarketSystem is</span>
 10 |     | <span class='neutral'>    IAtomicOrderModule,</span>
 11 |     | <span class='neutral'>    ISpotMarketFactoryModule,</span>
 12 |     | <span class='neutral'>    IMarketConfigurationModule</span>
 13 |     | <span class='neutral'>{}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/ISynthetixSystem.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAssociatedSystemsModule} from &quot;@synthetixio/core-modules/contracts/interfaces/IAssociatedSystemsModule.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IMarketManagerModule} from &quot;@synthetixio/main/contracts/interfaces/IMarketManagerModule.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IMarketCollateralModule} from &quot;@synthetixio/main/contracts/interfaces/IMarketCollateralModule.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IUtilsModule} from &quot;@synthetixio/main/contracts/interfaces/IUtilsModule.sol&quot;;</span>
  8 |     | <span class='neutral'>import {ICollateralConfigurationModule} from &quot;@synthetixio/main/contracts/interfaces/ICollateralConfigurationModule.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IVaultModule} from &quot;@synthetixio/main/contracts/interfaces/IVaultModule.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
 12 |     | <span class='neutral'>interface ISynthetixSystem is</span>
 13 |     | <span class='neutral'>    IAssociatedSystemsModule,</span>
 14 |     | <span class='neutral'>    IMarketCollateralModule,</span>
 15 |     | <span class='neutral'>    IMarketManagerModule,</span>
 16 |     | <span class='neutral'>    IUtilsModule,</span>
 17 |     | <span class='neutral'>    ICollateralConfigurationModule,</span>
 18 |     | <span class='neutral'>    IVaultModule</span>
 19 |     | <span class='neutral'>{}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/mocks/MockGasPriceNode.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/oracle-manager/contracts/interfaces/external/IExternalNode.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract MockGasPriceNode is IExternalNode {</span>
  7 |     | <span class='neutral'>    NodeOutput.Data private output;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    uint256 public constant KIND_SETTLEMENT = 0;</span>
 10 |     | <span class='unexecuted'>    uint256 public constant KIND_FLAG = 1;</span>
 11 |     | <span class='unexecuted'>    uint256 public constant KIND_LIQUIDATE = 2;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    uint256 public settlementCost;</span>
 14 |     | <span class='unexecuted'>    uint256 public flagCost;</span>
 15 |     | <span class='unexecuted'>    uint256 public liquidateCost;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor() {}</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function setCosts(uint256 _settlementCost, uint256 _flagCost, uint256 _liquidateCost) external {</span>
 20 |     | <span class='unexecuted'>        settlementCost = _settlementCost;</span>
 21 |     | <span class='unexecuted'>        flagCost = _flagCost;</span>
 22 |     | <span class='unexecuted'>        liquidateCost = _liquidateCost;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    // solhint-disable numcast/safe-cast</span>
 26 |     | <span class='unexecuted'>    function process(</span>
 27 |     | <span class='neutral'>        NodeOutput.Data[] memory,</span>
 28 |     | <span class='neutral'>        bytes memory,</span>
 29 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 30 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 31 |     | <span class='unexecuted'>    ) external view override returns (NodeOutput.Data memory) {</span>
 32 |     | <span class='unexecuted'>        NodeOutput.Data memory theOutput = output;</span>
 33 |     | <span class='neutral'>        uint256 executionKind;</span>
 34 |     | <span class='neutral'>        uint256 numberOfUpdatedFeeds;</span>
 35 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; runtimeKeys.length; i++) {</span>
 36 |     | <span class='unexecuted'>            if (runtimeKeys[i] == &quot;executionKind&quot;) {</span>
 37 |     | <span class='unexecuted'>                executionKind = uint256(runtimeValues[i]);</span>
 38 |     | <span class='unexecuted'>                continue;</span>
 39 |     | <span class='neutral'>            }</span>
 40 |     | <span class='unexecuted'>            if (runtimeKeys[i] == &quot;numberOfUpdatedFeeds&quot;) {</span>
 41 |     | <span class='unexecuted'>                numberOfUpdatedFeeds = uint256(runtimeValues[i]);</span>
 42 |     | <span class='neutral'>                continue;</span>
 43 |     | <span class='neutral'>            }</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        if (executionKind == KIND_SETTLEMENT) {</span>
 47 |     | <span class='unexecuted'>            theOutput.price = int256(settlementCost);</span>
 48 |     | <span class='unexecuted'>        } else if (executionKind == KIND_FLAG) {</span>
 49 |     | <span class='unexecuted'>            theOutput.price = int256(flagCost * numberOfUpdatedFeeds);</span>
 50 |     | <span class='unexecuted'>        } else if (executionKind == KIND_LIQUIDATE) {</span>
 51 |     | <span class='unexecuted'>            theOutput.price = int256(liquidateCost);</span>
 52 |     | <span class='neutral'>        } else {</span>
 53 |     | <span class='unexecuted'>            revert(&quot;Invalid execution kind&quot;);</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        return theOutput;</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function isValid(</span>
 60 |     | <span class='neutral'>        NodeDefinition.Data memory nodeDefinition</span>
 61 |     | <span class='unexecuted'>    ) external pure override returns (bool) {</span>
 62 |     | <span class='unexecuted'>        return nodeDefinition.nodeType == NodeDefinition.NodeType.EXTERNAL;</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>    function supportsInterface(bytes4) public view virtual override(IERC165) returns (bool) {</span>
 66 |     | <span class='unexecuted'>        return true;</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/mocks/MockPythERC7412Wrapper.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  4 |     | <span class='neutral'>import {MockOracleManager} from &quot;../fuzzing/mocks/MockOracleManager.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract MockPythERC7412Wrapper {</span>
  7 |     | <span class='neutral'>    MockOracleManager mockOracleManager;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    bool public alwaysRevert;</span>
 10 |     | <span class='unexecuted'>    int256 public price;</span>
 11 |     | <span class='neutral'>    mapping(bytes32 =&gt; int256) feedToPrice;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    error OracleDataRequired(bytes32 priceId, uint64 requestedTime);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address _oracleManager) {</span>
 16 |     | <span class='unexecuted'>        mockOracleManager = MockOracleManager(_oracleManager);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    function setBenchmarkPrice(bytes32 priceId, int256 _price) external {</span>
 20 | *   | <span class='executed'>        feedToPrice[priceId] = _price;</span>
 21 | *   | <span class='executed'>        mockOracleManager.changePrice(priceId, _price);</span>
 22 | *   | <span class='executed'>        alwaysRevert = false;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 | *   | <span class='executed'>    function setAlwaysRevertFlag(bool _alwaysRevert) external {</span>
 26 |     | <span class='unexecuted'>        alwaysRevert = _alwaysRevert;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 | *   | <span class='executed'>    function getBenchmarkPrice(</span>
 30 |     | <span class='neutral'>        bytes32 priceId,</span>
 31 |     | <span class='neutral'>        uint64 requestedTime</span>
 32 | *   | <span class='executed'>    ) external view returns (int256) {</span>
 33 | *   | <span class='executed'>        if (alwaysRevert) {</span>
 34 |     | <span class='unexecuted'>            revert OracleDataRequired(priceId, requestedTime);</span>
 35 |     | <span class='neutral'>        }</span>
 36 |     | <span class='neutral'></span>
 37 | *   | <span class='executed'>        return feedToPrice[priceId];</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/AsyncOrderCancelModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {FeatureFlag} from &quot;@synthetixio/core-modules/contracts/storage/FeatureFlag.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IAsyncOrderCancelModule} from &quot;../interfaces/IAsyncOrderCancelModule.sol&quot;;</span>
   7 |     | <span class='neutral'>import {PerpsAccount} from &quot;../storage/PerpsAccount.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Flags} from &quot;../utils/Flags.sol&quot;;</span>
   9 |     | <span class='neutral'>import {AsyncOrder} from &quot;../storage/AsyncOrder.sol&quot;;</span>
  10 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
  11 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
  12 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;../storage/PerpsMarketFactory.sol&quot;;</span>
  13 |     | <span class='neutral'>import {IMarketEvents} from &quot;../interfaces/IMarketEvents.sol&quot;;</span>
  14 |     | <span class='neutral'>import {IAccountEvents} from &quot;../interfaces/IAccountEvents.sol&quot;;</span>
  15 |     | <span class='neutral'>import {IPythERC7412Wrapper} from &quot;../interfaces/external/IPythERC7412Wrapper.sol&quot;;</span>
  16 |     | <span class='neutral'>import {SafeCastU256, SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/**</span>
  19 |     | <span class='neutral'> * @title Module for cancelling async orders.</span>
  20 |     | <span class='neutral'> * @dev See IAsyncOrderCancelModule.</span>
  21 |     | <span class='neutral'> */</span>
  22 | *   | <span class='executed'>contract AsyncOrderCancelModule is IAsyncOrderCancelModule, IMarketEvents, IAccountEvents {</span>
  23 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  24 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  25 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
  26 |     | <span class='neutral'>    using AsyncOrder for AsyncOrder.Data;</span>
  27 |     | <span class='neutral'>    using PerpsMarketFactory for PerpsMarketFactory.Data;</span>
  28 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @inheritdoc IAsyncOrderCancelModule</span>
  32 |     | <span class='neutral'>     */</span>
  33 | *   | <span class='executed'>    function cancelOrder(uint128 accountId) external {</span>
  34 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
  35 |     | <span class='neutral'></span>
  36 | *   | <span class='executed'>        (</span>
  37 | *   | <span class='executed'>            AsyncOrder.Data storage asyncOrder,</span>
  38 | *   | <span class='executed'>            SettlementStrategy.Data storage settlementStrategy</span>
  39 | *   | <span class='executed'>        ) = AsyncOrder.loadValid(accountId);</span>
  40 |     | <span class='neutral'></span>
  41 | *   | <span class='executed'>        int256 offchainPrice = IPythERC7412Wrapper(settlementStrategy.priceVerificationContract)</span>
  42 |     | <span class='neutral'>            .getBenchmarkPrice(</span>
  43 | *   | <span class='executed'>                settlementStrategy.feedId,</span>
  44 | *   | <span class='executed'>                (asyncOrder.commitmentTime + settlementStrategy.commitmentPriceDelay).to64()</span>
  45 |     | <span class='neutral'>            );</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>        _cancelOrder(offchainPrice.toUint(), asyncOrder, settlementStrategy);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @dev used for canceling an order.</span>
  52 |     | <span class='neutral'>     */</span>
  53 | *   | <span class='executed'>    function _cancelOrder(</span>
  54 |     | <span class='neutral'>        uint256 price,</span>
  55 |     | <span class='neutral'>        AsyncOrder.Data storage asyncOrder,</span>
  56 |     | <span class='neutral'>        SettlementStrategy.Data storage settlementStrategy</span>
  57 | *   | <span class='executed'>    ) private {</span>
  58 |     | <span class='neutral'>        CancelOrderRuntime memory runtime;</span>
  59 |     | <span class='neutral'>        // Get the current data before resetting the order</span>
  60 | *   | <span class='executed'>        runtime.accountId = asyncOrder.request.accountId;</span>
  61 | *   | <span class='executed'>        runtime.marketId = asyncOrder.request.marketId;</span>
  62 | *   | <span class='executed'>        runtime.acceptablePrice = asyncOrder.request.acceptablePrice;</span>
  63 | *   | <span class='executed'>        runtime.settlementReward = settlementStrategy.settlementReward;</span>
  64 | *   | <span class='executed'>        runtime.sizeDelta = asyncOrder.request.sizeDelta;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // check if account is flagged</span>
  67 | *   | <span class='executed'>        GlobalPerpsMarket.load().checkLiquidation(runtime.accountId);</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>        runtime.fillPrice = asyncOrder.validateCancellation(settlementStrategy, price);</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>        if (runtime.settlementReward &gt; 0) {</span>
  72 |     | <span class='neutral'>            // charge account the settlement reward</span>
  73 | *   | <span class='executed'>            uint256 accountDebt = PerpsAccount.load(runtime.accountId).charge(</span>
  74 | *   | <span class='executed'>                -runtime.settlementReward.toInt()</span>
  75 |     | <span class='neutral'>            );</span>
  76 |     | <span class='neutral'></span>
  77 | *   | <span class='executed'>            emit AccountCharged(runtime.accountId, runtime.settlementReward.toInt(), accountDebt);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>            // pay keeper</span>
  80 | *   | <span class='executed'>            PerpsMarketFactory.load().withdrawMarketUsd(</span>
  81 | *   | <span class='executed'>                ERC2771Context._msgSender(),</span>
  82 | *   | <span class='executed'>                runtime.settlementReward</span>
  83 |     | <span class='neutral'>            );</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // trader can now commit a new order</span>
  87 | *   | <span class='executed'>        asyncOrder.reset();</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // emit event</span>
  90 | *   | <span class='executed'>        emit OrderCancelled(</span>
  91 | *   | <span class='executed'>            runtime.marketId,</span>
  92 | *   | <span class='executed'>            runtime.accountId,</span>
  93 | *   | <span class='executed'>            runtime.acceptablePrice,</span>
  94 | *   | <span class='executed'>            runtime.fillPrice,</span>
  95 | *   | <span class='executed'>            runtime.sizeDelta,</span>
  96 | *   | <span class='executed'>            runtime.settlementReward,</span>
  97 | *   | <span class='executed'>            asyncOrder.request.trackingCode,</span>
  98 | *   | <span class='executed'>            ERC2771Context._msgSender()</span>
  99 |     | <span class='neutral'>        );</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'>}</span>
 102 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/AsyncOrderModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   5 |     | <span class='neutral'>import {FeatureFlag} from &quot;@synthetixio/core-modules/contracts/storage/FeatureFlag.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Account} from &quot;@synthetixio/main/contracts/storage/Account.sol&quot;;</span>
   7 |     | <span class='neutral'>import {AccountRBAC} from &quot;@synthetixio/main/contracts/storage/AccountRBAC.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IAsyncOrderModule} from &quot;../interfaces/IAsyncOrderModule.sol&quot;;</span>
   9 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsAccount} from &quot;../storage/PerpsAccount.sol&quot;;</span>
  11 |     | <span class='neutral'>import {AsyncOrder} from &quot;../storage/AsyncOrder.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Position} from &quot;../storage/Position.sol&quot;;</span>
  13 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
  14 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
  15 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;../storage/PerpsMarketConfiguration.sol&quot;;</span>
  16 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
  17 |     | <span class='neutral'>import {Flags} from &quot;../utils/Flags.sol&quot;;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>/**</span>
  20 |     | <span class='neutral'> * @title Module for committing async orders.</span>
  21 |     | <span class='neutral'> * @dev See IAsyncOrderModule.</span>
  22 |     | <span class='neutral'> */</span>
  23 | *   | <span class='executed'>contract AsyncOrderModule is IAsyncOrderModule {</span>
  24 |     | <span class='neutral'>    using AsyncOrder for AsyncOrder.Data;</span>
  25 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
  26 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /**</span>
  29 |     | <span class='neutral'>     * @inheritdoc IAsyncOrderModule</span>
  30 |     | <span class='neutral'>     */</span>
  31 | *   | <span class='executed'>    function commitOrder(</span>
  32 |     | <span class='neutral'>        AsyncOrder.OrderCommitmentRequest memory commitment</span>
  33 | *   | <span class='executed'>    ) external override returns (AsyncOrder.Data memory retOrder, uint256 fees) {</span>
  34 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
  35 | *   | <span class='executed'>        PerpsMarket.loadValid(commitment.marketId);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        // Check if commitment.accountId is valid</span>
  38 | *   | <span class='executed'>        Account.exists(commitment.accountId);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>        // Check ERC2771Context._msgSender() can commit order for commitment.accountId</span>
  41 | *   | <span class='executed'>        Account.loadAccountAndValidatePermission(</span>
  42 | *   | <span class='executed'>            commitment.accountId,</span>
  43 | *   | <span class='executed'>            AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION</span>
  44 |     | <span class='neutral'>        );</span>
  45 |     | <span class='neutral'></span>
  46 | *   | <span class='executed'>        GlobalPerpsMarket.load().checkLiquidation(commitment.accountId);</span>
  47 |     | <span class='neutral'></span>
  48 | *   | <span class='executed'>        SettlementStrategy.Data storage strategy = PerpsMarketConfiguration</span>
  49 | *   | <span class='executed'>            .loadValidSettlementStrategy(commitment.marketId, commitment.settlementStrategyId);</span>
  50 |     | <span class='neutral'></span>
  51 | *   | <span class='executed'>        AsyncOrder.Data storage order = AsyncOrder.load(commitment.accountId);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>        // if order (previous) sizeDelta is not zero and didn&#39;t revert while checking, it means the previous order expired</span>
  54 | *   | <span class='executed'>        if (order.request.sizeDelta != 0) {</span>
  55 |     | <span class='neutral'>            // @notice not including the expiration time since it requires the previous settlement strategy to be loaded and enabled, otherwise loading it will revert and will prevent new orders to be committed</span>
  56 | *   | <span class='executed'>            emit PreviousOrderExpired(</span>
  57 | *   | <span class='executed'>                order.request.marketId,</span>
  58 | *   | <span class='executed'>                order.request.accountId,</span>
  59 | *   | <span class='executed'>                order.request.sizeDelta,</span>
  60 | *   | <span class='executed'>                order.request.acceptablePrice,</span>
  61 | *   | <span class='executed'>                order.commitmentTime,</span>
  62 | *   | <span class='executed'>                order.request.trackingCode</span>
  63 |     | <span class='neutral'>            );</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>        order.updateValid(commitment);</span>
  67 |     | <span class='neutral'></span>
  68 | *   | <span class='executed'>        (, uint256 feesAccrued, , ) = order.validateRequest(</span>
  69 | *   | <span class='executed'>            strategy,</span>
  70 | *   | <span class='executed'>            PerpsPrice.getCurrentPrice(commitment.marketId, PerpsPrice.Tolerance.DEFAULT)</span>
  71 |     | <span class='neutral'>        );</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>        emit OrderCommitted(</span>
  74 | *   | <span class='executed'>            commitment.marketId,</span>
  75 | *   | <span class='executed'>            commitment.accountId,</span>
  76 | *   | <span class='executed'>            strategy.strategyType,</span>
  77 | *   | <span class='executed'>            commitment.sizeDelta,</span>
  78 | *   | <span class='executed'>            commitment.acceptablePrice,</span>
  79 | *   | <span class='executed'>            order.commitmentTime,</span>
  80 | *   | <span class='executed'>            order.commitmentTime + strategy.commitmentPriceDelay,</span>
  81 | *   | <span class='executed'>            order.commitmentTime + strategy.settlementDelay,</span>
  82 | *   | <span class='executed'>            order.commitmentTime + strategy.settlementDelay + strategy.settlementWindowDuration,</span>
  83 | *   | <span class='executed'>            commitment.trackingCode,</span>
  84 | *   | <span class='executed'>            ERC2771Context._msgSender()</span>
  85 |     | <span class='neutral'>        );</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>        return (order, feesAccrued);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @inheritdoc IAsyncOrderModule</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    // solc-ignore-next-line func-mutability</span>
  94 |     | <span class='unexecuted'>    function getOrder(</span>
  95 |     | <span class='neutral'>        uint128 accountId</span>
  96 |     | <span class='unexecuted'>    ) external view override returns (AsyncOrder.Data memory order) {</span>
  97 |     | <span class='unexecuted'>        order = AsyncOrder.load(accountId);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @inheritdoc IAsyncOrderModule</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='unexecuted'>    function computeOrderFees(</span>
 104 |     | <span class='neutral'>        uint128 marketId,</span>
 105 |     | <span class='neutral'>        int128 sizeDelta</span>
 106 |     | <span class='unexecuted'>    ) external view override returns (uint256 orderFees, uint256 fillPrice) {</span>
 107 |     | <span class='unexecuted'>        (orderFees, fillPrice) = _computeOrderFees(</span>
 108 |     | <span class='unexecuted'>            marketId,</span>
 109 |     | <span class='unexecuted'>            sizeDelta,</span>
 110 |     | <span class='unexecuted'>            PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)</span>
 111 |     | <span class='neutral'>        );</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @inheritdoc IAsyncOrderModule</span>
 116 |     | <span class='neutral'>     */</span>
 117 | *   | <span class='executed'>    function computeOrderFeesWithPrice(</span>
 118 |     | <span class='neutral'>        uint128 marketId,</span>
 119 |     | <span class='neutral'>        int128 sizeDelta,</span>
 120 |     | <span class='neutral'>        uint256 price</span>
 121 | *   | <span class='executed'>    ) external view override returns (uint256 orderFees, uint256 fillPrice) {</span>
 122 | *   | <span class='executed'>        (orderFees, fillPrice) = _computeOrderFees(marketId, sizeDelta, price);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /**</span>
 126 |     | <span class='neutral'>     * @inheritdoc IAsyncOrderModule</span>
 127 |     | <span class='neutral'>     */</span>
 128 | *   | <span class='executed'>    function getSettlementRewardCost(</span>
 129 |     | <span class='neutral'>        uint128 marketId,</span>
 130 |     | <span class='neutral'>        uint128 settlementStrategyId</span>
 131 |     | <span class='unexecuted'>    ) external view override returns (uint256) {</span>
 132 | *   | <span class='executed'>        return</span>
 133 | *   | <span class='executed'>            AsyncOrder.settlementRewardCost(</span>
 134 |     | <span class='unexecuted'>                PerpsMarketConfiguration.loadValidSettlementStrategy(marketId, settlementStrategyId)</span>
 135 |     | <span class='neutral'>            );</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function requiredMarginForOrder(</span>
 139 |     | <span class='neutral'>        uint128 accountId,</span>
 140 |     | <span class='neutral'>        uint128 marketId,</span>
 141 |     | <span class='neutral'>        int128 sizeDelta</span>
 142 |     | <span class='unexecuted'>    ) external view override returns (uint256 requiredMargin) {</span>
 143 |     | <span class='neutral'>        return</span>
 144 |     | <span class='unexecuted'>            _requiredMarginForOrder(</span>
 145 |     | <span class='unexecuted'>                accountId,</span>
 146 |     | <span class='unexecuted'>                marketId,</span>
 147 |     | <span class='unexecuted'>                sizeDelta,</span>
 148 |     | <span class='unexecuted'>                PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)</span>
 149 |     | <span class='neutral'>            );</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 | *   | <span class='executed'>    function requiredMarginForOrderWithPrice(</span>
 153 |     | <span class='neutral'>        uint128 accountId,</span>
 154 |     | <span class='neutral'>        uint128 marketId,</span>
 155 |     | <span class='neutral'>        int128 sizeDelta,</span>
 156 |     | <span class='neutral'>        uint256 price</span>
 157 |     | <span class='unexecuted'>    ) external view override returns (uint256 requiredMargin) {</span>
 158 |     | <span class='unexecuted'>        return _requiredMarginForOrder(accountId, marketId, sizeDelta, price);</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function _requiredMarginForOrder(</span>
 162 |     | <span class='neutral'>        uint128 accountId,</span>
 163 |     | <span class='neutral'>        uint128 marketId,</span>
 164 |     | <span class='neutral'>        int128 sizeDelta,</span>
 165 |     | <span class='neutral'>        uint256 orderPrice</span>
 166 |     | <span class='unexecuted'>    ) internal view returns (uint256 requiredMargin) {</span>
 167 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(</span>
 168 |     | <span class='unexecuted'>            marketId</span>
 169 |     | <span class='neutral'>        );</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>        Position.Data storage oldPosition = PerpsMarket.accountPosition(marketId, accountId);</span>
 172 |     | <span class='unexecuted'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 173 |     | <span class='unexecuted'>        (uint256 currentInitialMargin, , ) = account.getAccountRequiredMargins(</span>
 174 |     | <span class='neutral'>            PerpsPrice.Tolerance.DEFAULT</span>
 175 |     | <span class='neutral'>        );</span>
 176 |     | <span class='unexecuted'>        (uint256 orderFees, uint256 fillPrice) = _computeOrderFees(marketId, sizeDelta, orderPrice);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        return</span>
 179 |     | <span class='unexecuted'>            AsyncOrder.getRequiredMarginWithNewPosition(</span>
 180 |     | <span class='unexecuted'>                account,</span>
 181 |     | <span class='unexecuted'>                marketConfig,</span>
 182 |     | <span class='unexecuted'>                marketId,</span>
 183 |     | <span class='unexecuted'>                oldPosition.size,</span>
 184 |     | <span class='unexecuted'>                oldPosition.size + sizeDelta,</span>
 185 |     | <span class='unexecuted'>                fillPrice,</span>
 186 |     | <span class='unexecuted'>                currentInitialMargin</span>
 187 |     | <span class='neutral'>            ) + orderFees;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 | *   | <span class='executed'>    function _computeOrderFees(</span>
 191 |     | <span class='neutral'>        uint128 marketId,</span>
 192 |     | <span class='neutral'>        int128 sizeDelta,</span>
 193 |     | <span class='neutral'>        uint256 orderPrice</span>
 194 | *   | <span class='executed'>    ) private view returns (uint256 orderFees, uint256 fillPrice) {</span>
 195 | *   | <span class='executed'>        int256 skew = PerpsMarket.load(marketId).skew;</span>
 196 | *   | <span class='executed'>        PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(</span>
 197 | *   | <span class='executed'>            marketId</span>
 198 |     | <span class='neutral'>        );</span>
 199 | *   | <span class='executed'>        fillPrice = AsyncOrder.calculateFillPrice(</span>
 200 | *   | <span class='executed'>            skew,</span>
 201 | *   | <span class='executed'>            marketConfig.skewScale,</span>
 202 | *   | <span class='executed'>            sizeDelta,</span>
 203 | *   | <span class='executed'>            orderPrice</span>
 204 |     | <span class='neutral'>        );</span>
 205 |     | <span class='neutral'></span>
 206 | *   | <span class='executed'>        orderFees = AsyncOrder.calculateOrderFee(</span>
 207 | *   | <span class='executed'>            sizeDelta,</span>
 208 |     | <span class='neutral'>            fillPrice,</span>
 209 | *   | <span class='executed'>            skew,</span>
 210 | *   | <span class='executed'>            marketConfig.orderFees</span>
 211 |     | <span class='neutral'>        );</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'>}</span>
 214 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/AsyncOrderSettlementPythModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   5 |     | <span class='neutral'>import {FeatureFlag} from &quot;@synthetixio/core-modules/contracts/storage/FeatureFlag.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IAsyncOrderSettlementPythModule} from &quot;../interfaces/IAsyncOrderSettlementPythModule.sol&quot;;</span>
   7 |     | <span class='neutral'>import {PerpsAccount, SNX_USD_MARKET_ID} from &quot;../storage/PerpsAccount.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Flags} from &quot;../utils/Flags.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
  11 |     | <span class='neutral'>import {AsyncOrder} from &quot;../storage/AsyncOrder.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Position} from &quot;../storage/Position.sol&quot;;</span>
  13 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
  14 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
  15 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;../storage/PerpsMarketFactory.sol&quot;;</span>
  16 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;../storage/GlobalPerpsMarketConfiguration.sol&quot;;</span>
  17 |     | <span class='neutral'>import {IMarketEvents} from &quot;../interfaces/IMarketEvents.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IAccountEvents} from &quot;../interfaces/IAccountEvents.sol&quot;;</span>
  19 |     | <span class='neutral'>import {KeeperCosts} from &quot;../storage/KeeperCosts.sol&quot;;</span>
  20 |     | <span class='neutral'>import {IPythERC7412Wrapper} from &quot;../interfaces/external/IPythERC7412Wrapper.sol&quot;;</span>
  21 |     | <span class='neutral'>import {SafeCastU256, SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>/**</span>
  24 |     | <span class='neutral'> * @title Module for settling async orders using pyth as price feed.</span>
  25 |     | <span class='neutral'> * @dev See IAsyncOrderSettlementPythModule.</span>
  26 |     | <span class='neutral'> */</span>
  27 | *   | <span class='executed'>contract AsyncOrderSettlementPythModule is</span>
  28 |     | <span class='neutral'>    IAsyncOrderSettlementPythModule,</span>
  29 |     | <span class='neutral'>    IMarketEvents,</span>
  30 |     | <span class='neutral'>    IAccountEvents</span>
  31 |     | <span class='neutral'>{</span>
  32 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  33 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  34 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
  35 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  36 |     | <span class='neutral'>    using AsyncOrder for AsyncOrder.Data;</span>
  37 |     | <span class='neutral'>    using PerpsMarketFactory for PerpsMarketFactory.Data;</span>
  38 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  39 |     | <span class='neutral'>    using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;</span>
  40 |     | <span class='neutral'>    using Position for Position.Data;</span>
  41 |     | <span class='neutral'>    using KeeperCosts for KeeperCosts.Data;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @inheritdoc IAsyncOrderSettlementPythModule</span>
  45 |     | <span class='neutral'>     */</span>
  46 | *   | <span class='executed'>    function settleOrder(uint128 accountId) external {</span>
  47 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>        (</span>
  50 | *   | <span class='executed'>            AsyncOrder.Data storage asyncOrder,</span>
  51 | *   | <span class='executed'>            SettlementStrategy.Data storage settlementStrategy</span>
  52 | *   | <span class='executed'>        ) = AsyncOrder.loadValid(accountId);</span>
  53 |     | <span class='neutral'></span>
  54 | *   | <span class='executed'>        int256 offchainPrice = IPythERC7412Wrapper(</span>
  55 | *   | <span class='executed'>            settlementStrategy.priceVerificationContract</span>
  56 |     | <span class='neutral'>        ).getBenchmarkPrice(</span>
  57 | *   | <span class='executed'>                settlementStrategy.feedId,</span>
  58 | *   | <span class='executed'>                (asyncOrder.commitmentTime +</span>
  59 | *   | <span class='executed'>                    settlementStrategy.commitmentPriceDelay).to64()</span>
  60 |     | <span class='neutral'>            );</span>
  61 |     | <span class='neutral'></span>
  62 | *   | <span class='executed'>        _settleOrder(offchainPrice.toUint(), asyncOrder, settlementStrategy);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev used for settleing an order.</span>
  67 |     | <span class='neutral'>     */</span>
  68 | *   | <span class='executed'>    function _settleOrder(</span>
  69 |     | <span class='neutral'>        uint256 price,</span>
  70 |     | <span class='neutral'>        AsyncOrder.Data storage asyncOrder,</span>
  71 |     | <span class='neutral'>        SettlementStrategy.Data storage settlementStrategy</span>
  72 | *   | <span class='executed'>    ) private {</span>
  73 | *   | <span class='executed'>        SettleOrderRuntime memory runtime;</span>
  74 | *   | <span class='executed'>        runtime.accountId = asyncOrder.request.accountId;</span>
  75 | *   | <span class='executed'>        runtime.marketId = asyncOrder.request.marketId;</span>
  76 |     | <span class='neutral'>        // check if account is flagged</span>
  77 | *   | <span class='executed'>        GlobalPerpsMarket.load().checkLiquidation(runtime.accountId);</span>
  78 |     | <span class='neutral'></span>
  79 | *   | <span class='executed'>        Position.Data storage oldPosition;</span>
  80 | *   | <span class='executed'>        (</span>
  81 | *   | <span class='executed'>            runtime.newPosition,</span>
  82 | *   | <span class='executed'>            runtime.totalFees,</span>
  83 | *   | <span class='executed'>            runtime.fillPrice,</span>
  84 |     | <span class='neutral'>            oldPosition</span>
  85 | *   | <span class='executed'>        ) = asyncOrder.validateRequest(settlementStrategy, price);</span>
  86 | *   | <span class='executed'>        asyncOrder.validateAcceptablePrice(runtime.fillPrice);</span>
  87 |     | <span class='neutral'></span>
  88 | *   | <span class='executed'>        runtime.sizeDelta = asyncOrder.request.sizeDelta;</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
  91 | *   | <span class='executed'>        PerpsAccount.Data storage perpsAccount = PerpsAccount.load(</span>
  92 | *   | <span class='executed'>            runtime.accountId</span>
  93 |     | <span class='neutral'>        );</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // use fill price to calculate realized pnl</span>
  96 | *   | <span class='executed'>        (</span>
  97 | *   | <span class='executed'>            runtime.pnl,</span>
  98 |     | <span class='neutral'>            ,</span>
  99 | *   | <span class='executed'>            runtime.chargedInterest,</span>
 100 | *   | <span class='executed'>            runtime.accruedFunding,</span>
 101 |     | <span class='neutral'>            ,</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>        ) = oldPosition.getPnl(runtime.fillPrice);</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>        runtime.chargedAmount = runtime.pnl - runtime.totalFees.toInt();</span>
 106 | *   | <span class='executed'>        perpsAccount.charge(runtime.chargedAmount);</span>
 107 | *   | <span class='executed'>        emit AccountCharged(</span>
 108 | *   | <span class='executed'>            runtime.accountId,</span>
 109 | *   | <span class='executed'>            runtime.chargedAmount,</span>
 110 | *   | <span class='executed'>            perpsAccount.debt</span>
 111 |     | <span class='neutral'>        );</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // after pnl is realized, update position</span>
 114 | *   | <span class='executed'>        runtime.updateData = PerpsMarket</span>
 115 | *   | <span class='executed'>            .loadValid(runtime.marketId)</span>
 116 | *   | <span class='executed'>            .updatePositionData(runtime.accountId, runtime.newPosition);</span>
 117 | *   | <span class='executed'>        perpsAccount.updateOpenPositions(</span>
 118 | *   | <span class='executed'>            runtime.marketId,</span>
 119 | *   | <span class='executed'>            runtime.newPosition.size</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        emit MarketUpdated(</span>
 123 | *   | <span class='executed'>            runtime.updateData.marketId,</span>
 124 | *   | <span class='executed'>            price,</span>
 125 | *   | <span class='executed'>            runtime.updateData.skew,</span>
 126 | *   | <span class='executed'>            runtime.updateData.size,</span>
 127 | *   | <span class='executed'>            runtime.sizeDelta,</span>
 128 | *   | <span class='executed'>            runtime.updateData.currentFundingRate,</span>
 129 | *   | <span class='executed'>            runtime.updateData.currentFundingVelocity,</span>
 130 | *   | <span class='executed'>            runtime.updateData.interestRate</span>
 131 |     | <span class='neutral'>        );</span>
 132 |     | <span class='neutral'></span>
 133 | *   | <span class='executed'>        runtime.settlementReward = AsyncOrder.settlementRewardCost(</span>
 134 | *   | <span class='executed'>            settlementStrategy</span>
 135 |     | <span class='neutral'>        );</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>        if (runtime.settlementReward &gt; 0) {</span>
 138 |     | <span class='neutral'>            // pay keeper</span>
 139 | *   | <span class='executed'>            factory.withdrawMarketUsd(</span>
 140 | *   | <span class='executed'>                ERC2771Context._msgSender(),</span>
 141 | *   | <span class='executed'>                runtime.settlementReward</span>
 142 |     | <span class='neutral'>            );</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>        (</span>
 146 | *   | <span class='executed'>            runtime.referralFees,</span>
 147 | *   | <span class='executed'>            runtime.feeCollectorFees</span>
 148 | *   | <span class='executed'>        ) = GlobalPerpsMarketConfiguration.load().collectFees(</span>
 149 | *   | <span class='executed'>            runtime.totalFees - runtime.settlementReward, // totalFees includes settlement reward so we remove it</span>
 150 | *   | <span class='executed'>            asyncOrder.request.referrer,</span>
 151 | *   | <span class='executed'>            factory</span>
 152 |     | <span class='neutral'>        );</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // trader can now commit a new order</span>
 155 | *   | <span class='executed'>        asyncOrder.reset();</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // Note: new event for this due to stack too deep adding it to OrderSettled event</span>
 158 | *   | <span class='executed'>        emit InterestCharged(runtime.accountId, runtime.chargedInterest);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        // emit event</span>
 161 | *   | <span class='executed'>        emit OrderSettled(</span>
 162 | *   | <span class='executed'>            runtime.marketId,</span>
 163 | *   | <span class='executed'>            runtime.accountId,</span>
 164 | *   | <span class='executed'>            runtime.fillPrice,</span>
 165 | *   | <span class='executed'>            runtime.pnl,</span>
 166 | *   | <span class='executed'>            runtime.accruedFunding,</span>
 167 | *   | <span class='executed'>            runtime.sizeDelta,</span>
 168 | *   | <span class='executed'>            runtime.newPosition.size,</span>
 169 | *   | <span class='executed'>            runtime.totalFees,</span>
 170 | *   | <span class='executed'>            runtime.referralFees,</span>
 171 | *   | <span class='executed'>            runtime.feeCollectorFees,</span>
 172 | *   | <span class='executed'>            runtime.settlementReward,</span>
 173 | *   | <span class='executed'>            asyncOrder.request.trackingCode,</span>
 174 | *   | <span class='executed'>            ERC2771Context._msgSender()</span>
 175 |     | <span class='neutral'>        );</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'>}</span>
 178 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/CollateralConfigurationModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ICollateralConfigurationModule} from &quot;../interfaces/ICollateralConfigurationModule.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   6 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;../storage/GlobalPerpsMarketConfiguration.sol&quot;;</span>
   7 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
   8 |     | <span class='neutral'>import {LiquidationAssetManager} from &quot;../storage/LiquidationAssetManager.sol&quot;;</span>
   9 |     | <span class='neutral'>import {OwnableStorage} from &quot;@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol&quot;;</span>
  10 |     | <span class='neutral'>import {AddressError} from &quot;@synthetixio/core-contracts/contracts/errors/AddressError.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsCollateralConfiguration} from &quot;../storage/PerpsCollateralConfiguration.sol&quot;;</span>
  12 |     | <span class='neutral'>import {RewardsDistributor} from &quot;@synthetixio/rewards-distributor/src/RewardsDistributor.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/**</span>
  15 |     | <span class='neutral'> * @title Module for collateral configuration setters/getters.</span>
  16 |     | <span class='neutral'> * @dev See ICollateralConfigurationModule.</span>
  17 |     | <span class='neutral'> */</span>
  18 |     | <span class='unexecuted'>contract CollateralConfigurationModule is ICollateralConfigurationModule {</span>
  19 |     | <span class='neutral'>    using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;</span>
  20 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  21 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  22 |     | <span class='neutral'>    using LiquidationAssetManager for LiquidationAssetManager.Data;</span>
  23 |     | <span class='neutral'>    using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /**</span>
  26 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='unexecuted'>    function setCollateralConfiguration(</span>
  29 |     | <span class='neutral'>        uint128 collateralId,</span>
  30 |     | <span class='neutral'>        uint256 maxCollateralAmount,</span>
  31 |     | <span class='neutral'>        uint256 upperLimitDiscount,</span>
  32 |     | <span class='neutral'>        uint256 lowerLimitDiscount,</span>
  33 |     | <span class='neutral'>        uint256 discountScalar</span>
  34 |     | <span class='unexecuted'>    ) external override {</span>
  35 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  36 |     | <span class='unexecuted'>        PerpsCollateralConfiguration.Data storage collateralConfig = PerpsCollateralConfiguration</span>
  37 |     | <span class='unexecuted'>            .load(collateralId);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        collateralConfig.setMax(collateralId, maxCollateralAmount);</span>
  40 |     | <span class='neutral'>        collateralConfig.setDiscounts(upperLimitDiscount, lowerLimitDiscount, discountScalar);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.load().updateSupportedCollaterals(</span>
  43 |     | <span class='unexecuted'>            collateralId,</span>
  44 |     | <span class='unexecuted'>            maxCollateralAmount</span>
  45 |     | <span class='neutral'>        );</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        emit CollateralConfigurationSet(</span>
  48 |     | <span class='neutral'>            collateralId,</span>
  49 |     | <span class='neutral'>            maxCollateralAmount,</span>
  50 |     | <span class='neutral'>            upperLimitDiscount,</span>
  51 |     | <span class='neutral'>            lowerLimitDiscount,</span>
  52 |     | <span class='neutral'>            discountScalar</span>
  53 |     | <span class='neutral'>        );</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
  58 |     | <span class='neutral'>     */</span>
  59 |     | <span class='unexecuted'>    function getCollateralConfiguration(</span>
  60 |     | <span class='neutral'>        uint128 collateralId</span>
  61 |     | <span class='unexecuted'>    ) external view override returns (uint256 maxCollateralAmount) {</span>
  62 |     | <span class='unexecuted'>        return PerpsCollateralConfiguration.load(collateralId).maxAmount;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
  67 |     | <span class='neutral'>     */</span>
  68 |     | <span class='unexecuted'>    function getCollateralConfigurationFull(</span>
  69 |     | <span class='neutral'>        uint128 collateralId</span>
  70 |     | <span class='neutral'>    )</span>
  71 |     | <span class='neutral'>        external</span>
  72 |     | <span class='neutral'>        view</span>
  73 |     | <span class='neutral'>        override</span>
  74 |     | <span class='neutral'>        returns (</span>
  75 |     | <span class='unexecuted'>            uint256 maxCollateralAmount,</span>
  76 |     | <span class='unexecuted'>            uint256 upperLimitDiscount,</span>
  77 |     | <span class='unexecuted'>            uint256 lowerLimitDiscount,</span>
  78 |     | <span class='unexecuted'>            uint256 discountScalar</span>
  79 |     | <span class='neutral'>        )</span>
  80 |     | <span class='neutral'>    {</span>
  81 |     | <span class='unexecuted'>        return PerpsCollateralConfiguration.load(collateralId).getConfig();</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function setCollateralLiquidateRewardRatio(</span>
  88 |     | <span class='neutral'>        uint128 collateralLiquidateRewardRatioD18</span>
  89 |     | <span class='neutral'>    ) external override {</span>
  90 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  91 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration</span>
  92 |     | <span class='neutral'>            .load()</span>
  93 |     | <span class='unexecuted'>            .collateralLiquidateRewardRatioD18 = collateralLiquidateRewardRatioD18;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        emit CollateralLiquidateRewardRatioSet(collateralLiquidateRewardRatioD18);</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='unexecuted'>    function getCollateralLiquidateRewardRatio()</span>
 102 |     | <span class='neutral'>        external</span>
 103 |     | <span class='neutral'>        view</span>
 104 |     | <span class='neutral'>        override</span>
 105 |     | <span class='unexecuted'>        returns (uint128 collateralLiquidateRewardRatioD18)</span>
 106 |     | <span class='neutral'>    {</span>
 107 |     | <span class='unexecuted'>        return GlobalPerpsMarketConfiguration.load().collateralLiquidateRewardRatioD18;</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function registerDistributor(</span>
 114 |     | <span class='neutral'>        address token,</span>
 115 |     | <span class='neutral'>        address distributor,</span>
 116 |     | <span class='neutral'>        uint128 collateralId,</span>
 117 |     | <span class='neutral'>        address[] calldata poolDelegatedCollateralTypes</span>
 118 |     | <span class='unexecuted'>    ) external override {</span>
 119 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 120 |     | <span class='neutral'>        // A reward token to distribute must exist.</span>
 121 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
 122 |     | <span class='unexecuted'>            revert AddressError.ZeroAddress();</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>        // Using loadValid here to ensure we are tying the distributor to a valid collateral.</span>
 126 |     | <span class='unexecuted'>        LiquidationAssetManager.Data storage lam = PerpsCollateralConfiguration</span>
 127 |     | <span class='unexecuted'>            .loadValid(collateralId)</span>
 128 |     | <span class='neutral'>            .lam;</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        lam.id = collateralId;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        // validate and set poolDelegatedCollateralTypes</span>
 133 |     | <span class='unexecuted'>        lam.setValidPoolDelegatedCollateralTypes(poolDelegatedCollateralTypes);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>        // reuse current or clone distributor</span>
 136 |     | <span class='unexecuted'>        lam.setValidDistributor(distributor, token);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        emit RewardDistributorRegistered(distributor);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /**</span>
 142 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='unexecuted'>    function isRegistered(address distributor) external view override returns (bool) {</span>
 145 |     | <span class='unexecuted'>        return distributor != address(0) &amp;&amp; RewardsDistributor(distributor).poolId() != 0;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @inheritdoc ICollateralConfigurationModule</span>
 150 |     | <span class='neutral'>     */</span>
 151 |     | <span class='unexecuted'>    function getRegisteredDistributor(</span>
 152 |     | <span class='neutral'>        uint128 collateralId</span>
 153 |     | <span class='neutral'>    )</span>
 154 |     | <span class='neutral'>        external</span>
 155 |     | <span class='neutral'>        view</span>
 156 |     | <span class='neutral'>        override</span>
 157 |     | <span class='unexecuted'>        returns (address distributor, address[] memory poolDelegatedCollateralTypes)</span>
 158 |     | <span class='unexecuted'>    {</span>
 159 |     | <span class='unexecuted'>        LiquidationAssetManager.Data storage lam = PerpsCollateralConfiguration.loadValidLam(</span>
 160 |     | <span class='unexecuted'>            collateralId</span>
 161 |     | <span class='neutral'>        );</span>
 162 |     | <span class='unexecuted'>        distributor = lam.distributor;</span>
 163 |     | <span class='unexecuted'>        poolDelegatedCollateralTypes = lam.poolDelegatedCollateralTypes;</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'>}</span>
 166 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/CoreModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {CoreModule as BaseCoreModule} from &quot;@synthetixio/core-modules/contracts/modules/CoreModule.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Module that defines ownership and upgradability.</span>
  8 |     | <span class='neutral'> * See core-modules/../CoreModule</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
 11 |     | <span class='unexecuted'>contract CoreModule is BaseCoreModule {</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/FeatureFlagModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {FeatureFlagModule as BaseFeatureFlagModule} from &quot;@synthetixio/core-modules/contracts/modules/FeatureFlagModule.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Module that allows disabling certain system features.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Users will not be able to interact with certain functions associated to disabled features.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
 12 |     | <span class='unexecuted'>contract FeatureFlagModule is BaseFeatureFlagModule {}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/GlobalPerpsMarketModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ERC165Helper} from &quot;@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IFeeCollector} from &quot;../interfaces/external/IFeeCollector.sol&quot;;</span>
   8 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;../storage/GlobalPerpsMarketConfiguration.sol&quot;;</span>
   9 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
  10 |     | <span class='neutral'>import {InterestRate} from &quot;../storage/InterestRate.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;../storage/PerpsMarketFactory.sol&quot;;</span>
  12 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
  13 |     | <span class='neutral'>import {IGlobalPerpsMarketModule} from &quot;../interfaces/IGlobalPerpsMarketModule.sol&quot;;</span>
  14 |     | <span class='neutral'>import {OwnableStorage} from &quot;@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol&quot;;</span>
  15 |     | <span class='neutral'>import {AddressError} from &quot;@synthetixio/core-contracts/contracts/errors/AddressError.sol&quot;;</span>
  16 |     | <span class='neutral'>import {ParameterError} from &quot;@synthetixio/core-contracts/contracts/errors/ParameterError.sol&quot;;</span>
  17 |     | <span class='neutral'>import {KeeperCosts} from &quot;../storage/KeeperCosts.sol&quot;;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>/**</span>
  20 |     | <span class='neutral'> * @title Module for global Perps Market settings.</span>
  21 |     | <span class='neutral'> * @dev See IGlobalPerpsMarketModule.</span>
  22 |     | <span class='neutral'> */</span>
  23 | *   | <span class='executed'>contract GlobalPerpsMarketModule is IGlobalPerpsMarketModule {</span>
  24 |     | <span class='neutral'>    using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;</span>
  25 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  26 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  27 |     | <span class='neutral'>    using KeeperCosts for KeeperCosts.Data;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /**</span>
  30 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
  31 |     | <span class='neutral'>     */</span>
  32 | *   | <span class='executed'>    function getSupportedCollaterals()</span>
  33 |     | <span class='neutral'>        external</span>
  34 |     | <span class='neutral'>        view</span>
  35 |     | <span class='neutral'>        override</span>
  36 | *   | <span class='executed'>        returns (uint256[] memory supportedCollaterals)</span>
  37 | *   | <span class='executed'>    {</span>
  38 | *   | <span class='executed'>        GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();</span>
  39 | *   | <span class='executed'>        supportedCollaterals = store.supportedCollateralTypes.values();</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='unexecuted'>    function setKeeperRewardGuards(</span>
  46 |     | <span class='neutral'>        uint256 minKeeperRewardUsd,</span>
  47 |     | <span class='neutral'>        uint256 minKeeperProfitRatioD18,</span>
  48 |     | <span class='neutral'>        uint256 maxKeeperRewardUsd,</span>
  49 |     | <span class='neutral'>        uint256 maxKeeperScalingRatioD18</span>
  50 |     | <span class='unexecuted'>    ) external override {</span>
  51 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  52 |     | <span class='unexecuted'>        if (minKeeperRewardUsd &gt; maxKeeperRewardUsd) {</span>
  53 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(&quot;min/maxKeeperRewardUSD&quot;, &quot;min &gt; max&quot;);</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();</span>
  57 |     | <span class='unexecuted'>        store.minKeeperRewardUsd = minKeeperRewardUsd;</span>
  58 |     | <span class='unexecuted'>        store.minKeeperProfitRatioD18 = minKeeperProfitRatioD18;</span>
  59 |     | <span class='unexecuted'>        store.maxKeeperRewardUsd = maxKeeperRewardUsd;</span>
  60 |     | <span class='unexecuted'>        store.maxKeeperScalingRatioD18 = maxKeeperScalingRatioD18;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        emit KeeperRewardGuardsSet(</span>
  63 |     | <span class='neutral'>            minKeeperRewardUsd,</span>
  64 |     | <span class='neutral'>            minKeeperProfitRatioD18,</span>
  65 |     | <span class='neutral'>            maxKeeperRewardUsd,</span>
  66 |     | <span class='neutral'>            maxKeeperScalingRatioD18</span>
  67 |     | <span class='neutral'>        );</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='unexecuted'>    function getKeeperRewardGuards()</span>
  74 |     | <span class='neutral'>        external</span>
  75 |     | <span class='neutral'>        view</span>
  76 |     | <span class='neutral'>        override</span>
  77 |     | <span class='neutral'>        returns (</span>
  78 |     | <span class='unexecuted'>            uint256 minKeeperRewardUsd,</span>
  79 |     | <span class='unexecuted'>            uint256 minKeeperProfitRatioD18,</span>
  80 |     | <span class='unexecuted'>            uint256 maxKeeperRewardUsd,</span>
  81 |     | <span class='unexecuted'>            uint256 maxKeeperScalingRatioD18</span>
  82 |     | <span class='neutral'>        )</span>
  83 |     | <span class='neutral'>    {</span>
  84 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();</span>
  85 |     | <span class='unexecuted'>        minKeeperRewardUsd = store.minKeeperRewardUsd;</span>
  86 |     | <span class='unexecuted'>        minKeeperProfitRatioD18 = store.minKeeperProfitRatioD18;</span>
  87 |     | <span class='unexecuted'>        maxKeeperRewardUsd = store.maxKeeperRewardUsd;</span>
  88 |     | <span class='unexecuted'>        maxKeeperScalingRatioD18 = store.maxKeeperScalingRatioD18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalGlobalCollateralValue()</span>
  95 |     | <span class='neutral'>        external</span>
  96 |     | <span class='neutral'>        view</span>
  97 |     | <span class='neutral'>        override</span>
  98 | *   | <span class='executed'>        returns (uint256 totalCollateralValue)</span>
  99 |     | <span class='neutral'>    {</span>
 100 | *   | <span class='executed'>        return GlobalPerpsMarket.load().totalCollateralValue();</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 105 |     | <span class='neutral'>     */</span>
 106 | *   | <span class='executed'>    function globalCollateralValue(</span>
 107 |     | <span class='neutral'>        uint128 collateralId</span>
 108 | *   | <span class='executed'>    ) external view override returns (uint256 collateralValue) {</span>
 109 | *   | <span class='executed'>        return GlobalPerpsMarket.load().collateralAmounts[collateralId];</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='unexecuted'>    function setFeeCollector(address feeCollector) external override {</span>
 116 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 117 |     | <span class='unexecuted'>        if (feeCollector != address(0)) {</span>
 118 |     | <span class='unexecuted'>            if (</span>
 119 |     | <span class='unexecuted'>                !ERC165Helper.safeSupportsInterface(feeCollector, type(IFeeCollector).interfaceId)</span>
 120 |     | <span class='neutral'>            ) {</span>
 121 |     | <span class='unexecuted'>                revert InvalidFeeCollectorInterface(feeCollector);</span>
 122 |     | <span class='neutral'>            }</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.load().feeCollector = IFeeCollector(feeCollector);</span>
 126 |     | <span class='unexecuted'>        emit FeeCollectorSet(feeCollector);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='unexecuted'>    function getFeeCollector() external view override returns (address feeCollector) {</span>
 133 |     | <span class='unexecuted'>        return address(GlobalPerpsMarketConfiguration.load().feeCollector);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /**</span>
 137 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 138 |     | <span class='neutral'>     */</span>
 139 |     | <span class='unexecuted'>    function updateKeeperCostNodeId(bytes32 keeperCostNodeId) external override {</span>
 140 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>        KeeperCosts.load().update(keeperCostNodeId);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        emit KeeperCostNodeIdUpdated(keeperCostNodeId);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 149 |     | <span class='neutral'>     */</span>
 150 | *   | <span class='executed'>    function getKeeperCostNodeId() external view override returns (bytes32 keeperCostNodeId) {</span>
 151 |     | <span class='unexecuted'>        return KeeperCosts.load().keeperCostNodeId;</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /**</span>
 155 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='unexecuted'>    function updateReferrerShare(address referrer, uint256 shareRatioD18) external override {</span>
 158 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        if (shareRatioD18 &gt; DecimalMath.UNIT) {</span>
 161 |     | <span class='unexecuted'>            revert InvalidReferrerShareRatio(shareRatioD18);</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>        if (referrer == address(0)) {</span>
 165 |     | <span class='unexecuted'>            revert AddressError.ZeroAddress();</span>
 166 |     | <span class='neutral'>        }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.load().referrerShare[referrer] = shareRatioD18;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        emit ReferrerShareUpdated(referrer, shareRatioD18);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /**</span>
 174 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 175 |     | <span class='neutral'>     */</span>
 176 |     | <span class='unexecuted'>    function getReferrerShare(</span>
 177 |     | <span class='neutral'>        address referrer</span>
 178 |     | <span class='unexecuted'>    ) external view override returns (uint256 shareRatioD18) {</span>
 179 |     | <span class='unexecuted'>        return GlobalPerpsMarketConfiguration.load().referrerShare[referrer];</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /**</span>
 183 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 184 |     | <span class='neutral'>     */</span>
 185 |     | <span class='unexecuted'>    function getMarkets() external view override returns (uint256[] memory marketIds) {</span>
 186 |     | <span class='unexecuted'>        marketIds = GlobalPerpsMarket.load().activeMarkets.values();</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 191 |     | <span class='neutral'>     */</span>
 192 |     | <span class='unexecuted'>    function setPerAccountCaps(</span>
 193 |     | <span class='neutral'>        uint128 maxPositionsPerAccount,</span>
 194 |     | <span class='neutral'>        uint128 maxCollateralsPerAccount</span>
 195 |     | <span class='unexecuted'>    ) external override {</span>
 196 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 197 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();</span>
 198 |     | <span class='unexecuted'>        store.maxPositionsPerAccount = maxPositionsPerAccount;</span>
 199 |     | <span class='unexecuted'>        store.maxCollateralsPerAccount = maxCollateralsPerAccount;</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        emit PerAccountCapsSet(maxPositionsPerAccount, maxCollateralsPerAccount);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /**</span>
 205 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 206 |     | <span class='neutral'>     */</span>
 207 |     | <span class='unexecuted'>    function getPerAccountCaps()</span>
 208 |     | <span class='neutral'>        external</span>
 209 |     | <span class='neutral'>        view</span>
 210 |     | <span class='neutral'>        override</span>
 211 |     | <span class='unexecuted'>        returns (uint128 maxPositionsPerAccount, uint128 maxCollateralsPerAccount)</span>
 212 |     | <span class='neutral'>    {</span>
 213 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();</span>
 214 |     | <span class='unexecuted'>        maxPositionsPerAccount = store.maxPositionsPerAccount;</span>
 215 |     | <span class='unexecuted'>        maxCollateralsPerAccount = store.maxCollateralsPerAccount;</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    /**</span>
 219 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 220 |     | <span class='neutral'>     */</span>
 221 |     | <span class='unexecuted'>    function setInterestRateParameters(</span>
 222 |     | <span class='neutral'>        uint128 lowUtilizationInterestRateGradient,</span>
 223 |     | <span class='neutral'>        uint128 interestRateGradientBreakpoint,</span>
 224 |     | <span class='neutral'>        uint128 highUtilizationInterestRateGradient</span>
 225 |     | <span class='unexecuted'>    ) external override {</span>
 226 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 227 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        if (lowUtilizationInterestRateGradient &gt; highUtilizationInterestRateGradient) {</span>
 230 |     | <span class='unexecuted'>            revert InvalidInterestRateParameters(</span>
 231 |     | <span class='neutral'>                lowUtilizationInterestRateGradient,</span>
 232 |     | <span class='neutral'>                highUtilizationInterestRateGradient</span>
 233 |     | <span class='neutral'>            );</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        store.lowUtilizationInterestRateGradient = lowUtilizationInterestRateGradient;</span>
 237 |     | <span class='unexecuted'>        store.interestRateGradientBreakpoint = interestRateGradientBreakpoint;</span>
 238 |     | <span class='unexecuted'>        store.highUtilizationInterestRateGradient = highUtilizationInterestRateGradient;</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>        emit InterestRateParametersSet(</span>
 241 |     | <span class='neutral'>            lowUtilizationInterestRateGradient,</span>
 242 |     | <span class='neutral'>            interestRateGradientBreakpoint,</span>
 243 |     | <span class='neutral'>            highUtilizationInterestRateGradient</span>
 244 |     | <span class='neutral'>        );</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    /**</span>
 248 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 249 |     | <span class='neutral'>     */</span>
 250 |     | <span class='unexecuted'>    function getInterestRateParameters()</span>
 251 |     | <span class='neutral'>        external</span>
 252 |     | <span class='neutral'>        view</span>
 253 |     | <span class='neutral'>        override</span>
 254 |     | <span class='neutral'>        returns (</span>
 255 |     | <span class='unexecuted'>            uint128 lowUtilizationInterestRateGradient,</span>
 256 |     | <span class='unexecuted'>            uint128 interestRateGradientBreakpoint,</span>
 257 |     | <span class='unexecuted'>            uint128 highUtilizationInterestRateGradient</span>
 258 |     | <span class='neutral'>        )</span>
 259 |     | <span class='neutral'>    {</span>
 260 |     | <span class='unexecuted'>        GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();</span>
 261 |     | <span class='unexecuted'>        lowUtilizationInterestRateGradient = store.lowUtilizationInterestRateGradient;</span>
 262 |     | <span class='unexecuted'>        interestRateGradientBreakpoint = store.interestRateGradientBreakpoint;</span>
 263 |     | <span class='unexecuted'>        highUtilizationInterestRateGradient = store.highUtilizationInterestRateGradient;</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @inheritdoc IGlobalPerpsMarketModule</span>
 268 |     | <span class='neutral'>     */</span>
 269 |     | <span class='unexecuted'>    function updateInterestRate() external override {</span>
 270 |     | <span class='unexecuted'>        (uint128 interestRate, ) = InterestRate.update(PerpsPrice.Tolerance.DEFAULT);</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>        emit InterestRateUpdated(PerpsMarketFactory.load().perpsMarketId, interestRate);</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'>}</span>
 275 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/LiquidationModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   5 |     | <span class='neutral'>import {FeatureFlag} from &quot;@synthetixio/core-modules/contracts/storage/FeatureFlag.sol&quot;;</span>
   6 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Flags} from &quot;../utils/Flags.sol&quot;;</span>
   9 |     | <span class='neutral'>import {SafeCastU256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  10 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  11 |     | <span class='neutral'>import {ILiquidationModule} from &quot;../interfaces/ILiquidationModule.sol&quot;;</span>
  12 |     | <span class='neutral'>import {PerpsAccount} from &quot;../storage/PerpsAccount.sol&quot;;</span>
  13 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
  14 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
  15 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;../storage/PerpsMarketFactory.sol&quot;;</span>
  16 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;../storage/GlobalPerpsMarketConfiguration.sol&quot;;</span>
  17 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;../storage/PerpsMarketConfiguration.sol&quot;;</span>
  18 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
  19 |     | <span class='neutral'>import {MarketUpdate} from &quot;../storage/MarketUpdate.sol&quot;;</span>
  20 |     | <span class='neutral'>import {IMarketEvents} from &quot;../interfaces/IMarketEvents.sol&quot;;</span>
  21 |     | <span class='neutral'>import {KeeperCosts} from &quot;../storage/KeeperCosts.sol&quot;;</span>
  22 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>/**</span>
  25 |     | <span class='neutral'> * @title Module for liquidating accounts.</span>
  26 |     | <span class='neutral'> * @dev See ILiquidationModule.</span>
  27 |     | <span class='neutral'> */</span>
  28 | *   | <span class='executed'>contract LiquidationModule is ILiquidationModule, IMarketEvents {</span>
  29 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  30 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  31 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  32 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
  33 |     | <span class='neutral'>    using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;</span>
  34 |     | <span class='neutral'>    using PerpsMarketFactory for PerpsMarketFactory.Data;</span>
  35 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  36 |     | <span class='neutral'>    using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;</span>
  37 |     | <span class='neutral'>    using KeeperCosts for KeeperCosts.Data;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @inheritdoc ILiquidationModule</span>
  41 |     | <span class='neutral'>     */</span>
  42 | *   | <span class='executed'>    function liquidate(</span>
  43 |     | <span class='neutral'>        uint128 accountId</span>
  44 | *   | <span class='executed'>    ) external override returns (uint256 liquidationReward) {</span>
  45 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>        SetUtil.UintSet storage liquidatableAccounts = GlobalPerpsMarket</span>
  48 |     | <span class='neutral'>            .load()</span>
  49 |     | <span class='neutral'>            .liquidatableAccounts;</span>
  50 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
  51 | *   | <span class='executed'>        if (!liquidatableAccounts.contains(accountId)) {</span>
  52 | *   | <span class='executed'>            (</span>
  53 | *   | <span class='executed'>                bool isEligible,</span>
  54 |     | <span class='neutral'>                int256 availableMargin,</span>
  55 |     | <span class='neutral'>                ,</span>
  56 |     | <span class='neutral'>                uint256 requiredMaintenaceMargin,</span>
  57 |     | <span class='neutral'>                uint256 expectedLiquidationReward</span>
  58 | *   | <span class='executed'>            ) = account.isEligibleForLiquidation(PerpsPrice.Tolerance.STRICT);</span>
  59 | *   | <span class='executed'>            console2.log(&quot;isEligible&quot;, isEligible);</span>
  60 | *   | <span class='executed'>            console2.log(&quot;availableMargin&quot;, availableMargin);</span>
  61 | *   | <span class='executed'>            console2.log(&quot;requiredMaintenanceMargin&quot;, requiredMaintenaceMargin);</span>
  62 | *   | <span class='executed'>            console2.log(</span>
  63 |     | <span class='neutral'>                &quot;expectedLiquidationReward&quot;,</span>
  64 | *   | <span class='executed'>                expectedLiquidationReward</span>
  65 |     | <span class='neutral'>            );</span>
  66 | *   | <span class='executed'>            if (isEligible) {</span>
  67 | *   | <span class='executed'>                (uint256 flagCost, uint256 seizedMarginValue) = account</span>
  68 |     | <span class='neutral'>                    .flagForLiquidation();</span>
  69 |     | <span class='neutral'></span>
  70 | *   | <span class='executed'>                emit AccountFlaggedForLiquidation(</span>
  71 |     | <span class='neutral'>                    accountId,</span>
  72 |     | <span class='neutral'>                    availableMargin,</span>
  73 |     | <span class='neutral'>                    requiredMaintenaceMargin,</span>
  74 |     | <span class='neutral'>                    expectedLiquidationReward,</span>
  75 |     | <span class='neutral'>                    flagCost</span>
  76 |     | <span class='neutral'>                );</span>
  77 |     | <span class='neutral'></span>
  78 | *   | <span class='executed'>                liquidationReward = _liquidateAccount(</span>
  79 | *   | <span class='executed'>                    account,</span>
  80 | *   | <span class='executed'>                    flagCost,</span>
  81 | *   | <span class='executed'>                    seizedMarginValue,</span>
  82 | *   | <span class='executed'>                    true</span>
  83 |     | <span class='neutral'>                );</span>
  84 |     | <span class='neutral'>            } else {</span>
  85 |     | <span class='unexecuted'>                revert NotEligibleForLiquidation(accountId);</span>
  86 |     | <span class='neutral'>            }</span>
  87 |     | <span class='neutral'>        } else {</span>
  88 | *   | <span class='executed'>            liquidationReward = _liquidateAccount(account, 0, 0, false);</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>    function liquidateMarginOnly(</span>
  93 |     | <span class='neutral'>        uint128 accountId</span>
  94 | *   | <span class='executed'>    ) external override returns (uint256 liquidationReward) {</span>
  95 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>        if (account.hasOpenPositions()) {</span>
 100 |     | <span class='unexecuted'>            revert AccountHasOpenPositions(accountId);</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>        (bool isEligible, ) = account.isEligibleForMarginLiquidation(</span>
 104 | *   | <span class='executed'>            PerpsPrice.Tolerance.STRICT</span>
 105 |     | <span class='neutral'>        );</span>
 106 | *   | <span class='executed'>        if (isEligible) {</span>
 107 |     | <span class='neutral'>            // margin is sent to liquidation rewards distributor in getMarginLiquidationCostAndSeizeMargin</span>
 108 | *   | <span class='executed'>            (uint256 marginLiquidateCost, uint256 seizedMarginValue) = account</span>
 109 |     | <span class='neutral'>                .getMarginLiquidationCostAndSeizeMargin();</span>
 110 |     | <span class='neutral'>            // keeper is rewarded in _liquidateAccount</span>
 111 | *   | <span class='executed'>            liquidationReward = _liquidateAccount(</span>
 112 | *   | <span class='executed'>                account,</span>
 113 | *   | <span class='executed'>                marginLiquidateCost,</span>
 114 | *   | <span class='executed'>                seizedMarginValue,</span>
 115 | *   | <span class='executed'>                true</span>
 116 |     | <span class='neutral'>            );</span>
 117 |     | <span class='neutral'>            // clear debt</span>
 118 | *   | <span class='executed'>            account.updateAccountDebt(-(account.debt.toInt()));</span>
 119 |     | <span class='neutral'></span>
 120 | *   | <span class='executed'>            emit AccountMarginLiquidation(</span>
 121 |     | <span class='neutral'>                accountId,</span>
 122 |     | <span class='neutral'>                seizedMarginValue,</span>
 123 |     | <span class='neutral'>                liquidationReward</span>
 124 |     | <span class='neutral'>            );</span>
 125 |     | <span class='neutral'>        } else {</span>
 126 |     | <span class='unexecuted'>            revert NotEligibleForMarginLiquidation(accountId);</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='neutral'>     * @inheritdoc ILiquidationModule</span>
 132 |     | <span class='neutral'>     */</span>
 133 | *   | <span class='executed'>    function liquidateFlagged(</span>
 134 |     | <span class='neutral'>        uint256 maxNumberOfAccounts</span>
 135 | *   | <span class='executed'>    ) external override returns (uint256 liquidationReward) {</span>
 136 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
 137 |     | <span class='neutral'></span>
 138 | *   | <span class='executed'>        uint256[] memory liquidatableAccounts = GlobalPerpsMarket</span>
 139 |     | <span class='neutral'>            .load()</span>
 140 |     | <span class='neutral'>            .liquidatableAccounts</span>
 141 |     | <span class='neutral'>            .values();</span>
 142 |     | <span class='neutral'></span>
 143 | *   | <span class='executed'>        uint256 numberOfAccountsToLiquidate = MathUtil.min(</span>
 144 | *   | <span class='executed'>            maxNumberOfAccounts,</span>
 145 | *   | <span class='executed'>            liquidatableAccounts.length</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'></span>
 148 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; numberOfAccountsToLiquidate; i++) {</span>
 149 | *   | <span class='executed'>            uint128 accountId = liquidatableAccounts[i].to128();</span>
 150 | *   | <span class='executed'>            console2.log(&quot;liquidateFlagged::accountId&quot;, accountId);</span>
 151 | *   | <span class='executed'>            liquidationReward += _liquidateAccount(</span>
 152 | *   | <span class='executed'>                PerpsAccount.load(accountId),</span>
 153 |     | <span class='neutral'>                0,</span>
 154 |     | <span class='neutral'>                0,</span>
 155 |     | <span class='neutral'>                false</span>
 156 |     | <span class='neutral'>            );</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @inheritdoc ILiquidationModule</span>
 162 |     | <span class='neutral'>     */</span>
 163 | *   | <span class='executed'>    function liquidateFlaggedAccounts(</span>
 164 |     | <span class='neutral'>        uint128[] calldata accountIds</span>
 165 | *   | <span class='executed'>    ) external override returns (uint256 liquidationReward) {</span>
 166 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
 167 |     | <span class='neutral'></span>
 168 | *   | <span class='executed'>        SetUtil.UintSet storage liquidatableAccounts = GlobalPerpsMarket</span>
 169 |     | <span class='neutral'>            .load()</span>
 170 |     | <span class='neutral'>            .liquidatableAccounts;</span>
 171 |     | <span class='neutral'></span>
 172 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; accountIds.length; i++) {</span>
 173 | *   | <span class='executed'>            uint128 accountId = accountIds[i];</span>
 174 | *   | <span class='executed'>            if (!liquidatableAccounts.contains(accountId)) {</span>
 175 | *   | <span class='executed'>                continue;</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'></span>
 178 | *   | <span class='executed'>            liquidationReward += _liquidateAccount(</span>
 179 | *   | <span class='executed'>                PerpsAccount.load(accountId),</span>
 180 | *   | <span class='executed'>                0,</span>
 181 | *   | <span class='executed'>                0,</span>
 182 | *   | <span class='executed'>                false</span>
 183 |     | <span class='neutral'>            );</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @inheritdoc ILiquidationModule</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='unexecuted'>    function flaggedAccounts()</span>
 191 |     | <span class='neutral'>        external</span>
 192 |     | <span class='neutral'>        view</span>
 193 |     | <span class='neutral'>        override</span>
 194 |     | <span class='unexecuted'>        returns (uint256[] memory accountIds)</span>
 195 |     | <span class='neutral'>    {</span>
 196 | *   | <span class='executed'>        return GlobalPerpsMarket.load().liquidatableAccounts.values();</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    /**</span>
 200 |     | <span class='neutral'>     * @inheritdoc ILiquidationModule</span>
 201 |     | <span class='neutral'>     */</span>
 202 | *   | <span class='executed'>    function canLiquidate(</span>
 203 |     | <span class='neutral'>        uint128 accountId</span>
 204 | *   | <span class='executed'>    ) external view override returns (bool isEligible) {</span>
 205 | *   | <span class='executed'>        (isEligible, , , , ) = PerpsAccount</span>
 206 | *   | <span class='executed'>            .load(accountId)</span>
 207 | *   | <span class='executed'>            .isEligibleForLiquidation(PerpsPrice.Tolerance.DEFAULT);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 | *   | <span class='executed'>    function canLiquidateMarginOnly(</span>
 211 |     | <span class='neutral'>        uint128 accountId</span>
 212 | *   | <span class='executed'>    ) external view override returns (bool isEligible) {</span>
 213 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 214 | *   | <span class='executed'>        if (account.hasOpenPositions()) {</span>
 215 | *   | <span class='executed'>            return false;</span>
 216 |     | <span class='neutral'>        } else {</span>
 217 | *   | <span class='executed'>            (isEligible, ) = account.isEligibleForMarginLiquidation(</span>
 218 | *   | <span class='executed'>                PerpsPrice.Tolerance.DEFAULT</span>
 219 |     | <span class='neutral'>            );</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /**</span>
 224 |     | <span class='neutral'>     * @inheritdoc ILiquidationModule</span>
 225 |     | <span class='neutral'>     */</span>
 226 | *   | <span class='executed'>    function liquidationCapacity(</span>
 227 |     | <span class='neutral'>        uint128 marketId</span>
 228 |     | <span class='neutral'>    )</span>
 229 |     | <span class='neutral'>        external</span>
 230 |     | <span class='neutral'>        view</span>
 231 |     | <span class='neutral'>        override</span>
 232 |     | <span class='neutral'>        returns (</span>
 233 | *   | <span class='executed'>            uint256 capacity,</span>
 234 | *   | <span class='executed'>            uint256 maxLiquidationInWindow,</span>
 235 | *   | <span class='executed'>            uint256 latestLiquidationTimestamp</span>
 236 |     | <span class='neutral'>        )</span>
 237 |     | <span class='neutral'>    {</span>
 238 | *   | <span class='executed'>        return</span>
 239 | *   | <span class='executed'>            PerpsMarket.load(marketId).currentLiquidationCapacity(</span>
 240 | *   | <span class='executed'>                PerpsMarketConfiguration.load(marketId)</span>
 241 |     | <span class='neutral'>            );</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    struct LiquidateAccountRuntime {</span>
 245 |     | <span class='neutral'>        uint128 accountId;</span>
 246 |     | <span class='neutral'>        uint256 totalFlaggingRewards;</span>
 247 |     | <span class='neutral'>        uint256 totalLiquidated;</span>
 248 |     | <span class='neutral'>        bool accountFullyLiquidated;</span>
 249 |     | <span class='neutral'>        uint256 totalLiquidationCost;</span>
 250 |     | <span class='neutral'>        uint256 price;</span>
 251 |     | <span class='neutral'>        uint128 positionMarketId;</span>
 252 |     | <span class='neutral'>        uint256 loopIterator; // stack too deep to the extreme</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    /**</span>
 256 |     | <span class='neutral'>     * @dev liquidates an account</span>
 257 |     | <span class='neutral'>     */</span>
 258 | *   | <span class='executed'>    function _liquidateAccount(</span>
 259 |     | <span class='neutral'>        PerpsAccount.Data storage account,</span>
 260 |     | <span class='neutral'>        uint256 costOfFlagExecution,</span>
 261 |     | <span class='neutral'>        uint256 totalCollateralValue,</span>
 262 |     | <span class='neutral'>        bool positionFlagged</span>
 263 | *   | <span class='executed'>    ) internal returns (uint256 keeperLiquidationReward) {</span>
 264 |     | <span class='neutral'>        LiquidateAccountRuntime memory runtime;</span>
 265 | *   | <span class='executed'>        runtime.accountId = account.id;</span>
 266 | *   | <span class='executed'>        uint256[] memory openPositionMarketIds = account</span>
 267 |     | <span class='neutral'>            .openPositionMarketIds</span>
 268 |     | <span class='neutral'>            .values();</span>
 269 |     | <span class='neutral'></span>
 270 | *   | <span class='executed'>        for (</span>
 271 | *   | <span class='executed'>            runtime.loopIterator = 0;</span>
 272 | *   | <span class='executed'>            runtime.loopIterator &lt; openPositionMarketIds.length;</span>
 273 | *   | <span class='executed'>            runtime.loopIterator++</span>
 274 | *   | <span class='executed'>        ) {</span>
 275 | *   | <span class='executed'>            runtime.positionMarketId = openPositionMarketIds[</span>
 276 | *   | <span class='executed'>                runtime.loopIterator</span>
 277 |     | <span class='neutral'>            ].to128();</span>
 278 | *   | <span class='executed'>            runtime.price = PerpsPrice.getCurrentPrice(</span>
 279 |     | <span class='neutral'>                runtime.positionMarketId,</span>
 280 | *   | <span class='executed'>                PerpsPrice.Tolerance.STRICT</span>
 281 |     | <span class='neutral'>            );</span>
 282 |     | <span class='neutral'></span>
 283 | *   | <span class='executed'>            (</span>
 284 | *   | <span class='executed'>                uint256 amountLiquidated,</span>
 285 |     | <span class='neutral'>                int128 newPositionSize,</span>
 286 |     | <span class='neutral'>                int128 sizeDelta,</span>
 287 |     | <span class='neutral'>                uint256 oldPositionAbsSize,</span>
 288 |     | <span class='neutral'>                MarketUpdate.Data memory marketUpdateData</span>
 289 | *   | <span class='executed'>            ) = account.liquidatePosition(</span>
 290 | *   | <span class='executed'>                    runtime.positionMarketId,</span>
 291 |     | <span class='neutral'>                    runtime.price</span>
 292 |     | <span class='neutral'>                );</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>            // endorsed liquidators do not get flag rewards</span>
 295 | *   | <span class='executed'>            if (</span>
 296 | *   | <span class='executed'>                ERC2771Context._msgSender() !=</span>
 297 | *   | <span class='executed'>                PerpsMarketConfiguration</span>
 298 | *   | <span class='executed'>                    .load(runtime.positionMarketId)</span>
 299 |     | <span class='neutral'>                    .endorsedLiquidator</span>
 300 |     | <span class='neutral'>            ) {</span>
 301 |     | <span class='neutral'>                // using oldPositionAbsSize to calculate flag reward</span>
 302 | *   | <span class='executed'>                runtime.totalFlaggingRewards += PerpsMarketConfiguration</span>
 303 | *   | <span class='executed'>                    .load(runtime.positionMarketId)</span>
 304 |     | <span class='neutral'>                    .calculateFlagReward(</span>
 305 | *   | <span class='executed'>                        oldPositionAbsSize.mulDecimal(runtime.price)</span>
 306 |     | <span class='neutral'>                    );</span>
 307 |     | <span class='neutral'>            }</span>
 308 |     | <span class='neutral'></span>
 309 | *   | <span class='executed'>            if (amountLiquidated == 0) {</span>
 310 | *   | <span class='executed'>                continue;</span>
 311 |     | <span class='neutral'>            }</span>
 312 |     | <span class='neutral'></span>
 313 | *   | <span class='executed'>            runtime.totalLiquidated += amountLiquidated;</span>
 314 |     | <span class='neutral'></span>
 315 | *   | <span class='executed'>            emit MarketUpdated(</span>
 316 | *   | <span class='executed'>                runtime.positionMarketId,</span>
 317 | *   | <span class='executed'>                runtime.price,</span>
 318 | *   | <span class='executed'>                marketUpdateData.skew,</span>
 319 | *   | <span class='executed'>                marketUpdateData.size,</span>
 320 |     | <span class='neutral'>                sizeDelta,</span>
 321 | *   | <span class='executed'>                marketUpdateData.currentFundingRate,</span>
 322 | *   | <span class='executed'>                marketUpdateData.currentFundingVelocity,</span>
 323 | *   | <span class='executed'>                marketUpdateData.interestRate</span>
 324 |     | <span class='neutral'>            );</span>
 325 |     | <span class='neutral'></span>
 326 | *   | <span class='executed'>            emit PositionLiquidated(</span>
 327 | *   | <span class='executed'>                runtime.accountId,</span>
 328 | *   | <span class='executed'>                runtime.positionMarketId,</span>
 329 | *   | <span class='executed'>                amountLiquidated,</span>
 330 | *   | <span class='executed'>                newPositionSize</span>
 331 |     | <span class='neutral'>            );</span>
 332 |     | <span class='neutral'>        }</span>
 333 |     | <span class='neutral'></span>
 334 | *   | <span class='executed'>        if (</span>
 335 | *   | <span class='executed'>            ERC2771Context._msgSender() !=</span>
 336 | *   | <span class='executed'>            PerpsMarketConfiguration</span>
 337 | *   | <span class='executed'>                .load(runtime.positionMarketId)</span>
 338 |     | <span class='neutral'>                .endorsedLiquidator</span>
 339 |     | <span class='neutral'>        ) {</span>
 340 |     | <span class='neutral'>            // Use max of collateral or positions flag rewards</span>
 341 | *   | <span class='executed'>            uint256 totalCollateralLiquidateRewards = GlobalPerpsMarketConfiguration</span>
 342 |     | <span class='neutral'>                    .load()</span>
 343 | *   | <span class='executed'>                    .calculateCollateralLiquidateReward(totalCollateralValue);</span>
 344 |     | <span class='neutral'></span>
 345 | *   | <span class='executed'>            runtime.totalFlaggingRewards = totalCollateralLiquidateRewards &gt;</span>
 346 | *   | <span class='executed'>                runtime.totalFlaggingRewards</span>
 347 |     | <span class='unexecuted'>                ? totalCollateralLiquidateRewards</span>
 348 | *   | <span class='executed'>                : runtime.totalFlaggingRewards;</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='neutral'></span>
 351 | *   | <span class='executed'>        runtime.totalLiquidationCost =</span>
 352 | *   | <span class='executed'>            KeeperCosts.load().getLiquidateKeeperCosts() +</span>
 353 | *   | <span class='executed'>            costOfFlagExecution;</span>
 354 | *   | <span class='executed'>        if (positionFlagged || runtime.totalLiquidated &gt; 0) {</span>
 355 | *   | <span class='executed'>            keeperLiquidationReward = _processLiquidationRewards(</span>
 356 | *   | <span class='executed'>                positionFlagged ? runtime.totalFlaggingRewards : 0,</span>
 357 | *   | <span class='executed'>                runtime.totalLiquidationCost,</span>
 358 | *   | <span class='executed'>                totalCollateralValue</span>
 359 |     | <span class='neutral'>            );</span>
 360 | *   | <span class='executed'>            runtime.accountFullyLiquidated =</span>
 361 | *   | <span class='executed'>                account.openPositionMarketIds.length() == 0;</span>
 362 | *   | <span class='executed'>            if (</span>
 363 | *   | <span class='executed'>                runtime.accountFullyLiquidated &amp;&amp;</span>
 364 | *   | <span class='executed'>                GlobalPerpsMarket.load().liquidatableAccounts.contains(</span>
 365 | *   | <span class='executed'>                    runtime.accountId</span>
 366 |     | <span class='neutral'>                )</span>
 367 |     | <span class='neutral'>            ) {</span>
 368 | *   | <span class='executed'>                GlobalPerpsMarket.load().liquidatableAccounts.remove(</span>
 369 | *   | <span class='executed'>                    runtime.accountId</span>
 370 |     | <span class='neutral'>                );</span>
 371 |     | <span class='neutral'>            }</span>
 372 |     | <span class='neutral'>        }</span>
 373 |     | <span class='neutral'></span>
 374 | *   | <span class='executed'>        emit AccountLiquidationAttempt(</span>
 375 | *   | <span class='executed'>            runtime.accountId,</span>
 376 |     | <span class='neutral'>            keeperLiquidationReward,</span>
 377 | *   | <span class='executed'>            runtime.accountFullyLiquidated</span>
 378 |     | <span class='neutral'>        );</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    /**</span>
 382 |     | <span class='neutral'>     * @dev process the accumulated liquidation rewards</span>
 383 |     | <span class='neutral'>     */</span>
 384 | *   | <span class='executed'>    function _processLiquidationRewards(</span>
 385 |     | <span class='neutral'>        uint256 keeperRewards,</span>
 386 |     | <span class='neutral'>        uint256 costOfExecutionInUsd,</span>
 387 |     | <span class='neutral'>        uint256 availableMarginInUsd</span>
 388 | *   | <span class='executed'>    ) private returns (uint256 reward) {</span>
 389 | *   | <span class='executed'>        if ((keeperRewards + costOfExecutionInUsd) == 0) {</span>
 390 |     | <span class='unexecuted'>            return 0;</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'>        // pay out liquidation rewards</span>
 393 | *   | <span class='executed'>        reward = GlobalPerpsMarketConfiguration.load().keeperReward(</span>
 394 | *   | <span class='executed'>            keeperRewards,</span>
 395 | *   | <span class='executed'>            costOfExecutionInUsd,</span>
 396 | *   | <span class='executed'>            availableMarginInUsd</span>
 397 |     | <span class='neutral'>        );</span>
 398 | *   | <span class='executed'>        if (reward &gt; 0) {</span>
 399 |     | <span class='unexecuted'>            PerpsMarketFactory.load().withdrawMarketUsd(</span>
 400 |     | <span class='unexecuted'>                ERC2771Context._msgSender(),</span>
 401 |     | <span class='unexecuted'>                reward</span>
 402 |     | <span class='neutral'>            );</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='neutral'>    }</span>
 405 |     | <span class='neutral'>}</span>
 406 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/MarketConfigurationModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {OwnableStorage} from &quot;@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IMarketConfigurationModule} from &quot;../interfaces/IMarketConfigurationModule.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SettlementStrategy} from &quot;../storage/SettlementStrategy.sol&quot;;</span>
   7 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;../storage/PerpsMarketConfiguration.sol&quot;;</span>
   8 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title Module for updating configuration in relation to async order modules.</span>
  12 |     | <span class='neutral'> * @dev See IMarketConfigurationModule.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>contract MarketConfigurationModule is IMarketConfigurationModule {</span>
  15 |     | <span class='neutral'>    using PerpsPrice for PerpsPrice.Data;</span>
  16 |     | <span class='neutral'>    using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='unexecuted'>    function addSettlementStrategy(</span>
  22 |     | <span class='neutral'>        uint128 marketId,</span>
  23 |     | <span class='neutral'>        SettlementStrategy.Data memory strategy</span>
  24 |     | <span class='unexecuted'>    ) external override returns (uint256 strategyId) {</span>
  25 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>        if (strategy.settlementWindowDuration == 0) {</span>
  28 |     | <span class='unexecuted'>            revert InvalidSettlementWindowDuration(strategy.settlementWindowDuration);</span>
  29 |     | <span class='neutral'>        }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        strategy.settlementDelay = strategy.settlementDelay == 0 ? 1 : strategy.settlementDelay;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
  34 |     | <span class='unexecuted'>        strategyId = config.settlementStrategies.length;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        config.settlementStrategies.push(strategy);</span>
  37 |     | <span class='unexecuted'>        emit SettlementStrategyAdded(marketId, strategy, strategyId);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='unexecuted'>    function setSettlementStrategy(</span>
  44 |     | <span class='neutral'>        uint128 marketId,</span>
  45 |     | <span class='neutral'>        uint256 strategyId,</span>
  46 |     | <span class='neutral'>        SettlementStrategy.Data memory strategy</span>
  47 |     | <span class='unexecuted'>    ) external override {</span>
  48 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
  51 |     | <span class='unexecuted'>        config.validateStrategyExists(strategyId);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        if (strategy.settlementWindowDuration == 0) {</span>
  54 |     | <span class='unexecuted'>            revert InvalidSettlementWindowDuration(strategy.settlementWindowDuration);</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        strategy.settlementDelay = strategy.settlementDelay == 0 ? 1 : strategy.settlementDelay;</span>
  58 |     | <span class='unexecuted'>        config.settlementStrategies[strategyId] = strategy;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        emit SettlementStrategySet(marketId, strategyId, strategy);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='unexecuted'>    function setSettlementStrategyEnabled(</span>
  67 |     | <span class='neutral'>        uint128 marketId,</span>
  68 |     | <span class='neutral'>        uint256 strategyId,</span>
  69 |     | <span class='neutral'>        bool enabled</span>
  70 |     | <span class='unexecuted'>    ) external override {</span>
  71 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
  74 |     | <span class='unexecuted'>        config.validateStrategyExists(strategyId);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        SettlementStrategy.Data storage strategy = config.settlementStrategies[strategyId];</span>
  77 |     | <span class='unexecuted'>        strategy.disabled = !enabled;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        emit SettlementStrategySet(marketId, strategyId, strategy);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='unexecuted'>    function setOrderFees(</span>
  86 |     | <span class='neutral'>        uint128 marketId,</span>
  87 |     | <span class='neutral'>        uint256 makerFeeRatio,</span>
  88 |     | <span class='neutral'>        uint256 takerFeeRatio</span>
  89 |     | <span class='neutral'>    ) external override {</span>
  90 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  91 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
  92 |     | <span class='unexecuted'>        config.orderFees.makerFee = makerFeeRatio;</span>
  93 |     | <span class='unexecuted'>        config.orderFees.takerFee = takerFeeRatio;</span>
  94 |     | <span class='unexecuted'>        emit OrderFeesSet(marketId, makerFeeRatio, takerFeeRatio);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
  99 |     | <span class='neutral'>     */</span>
 100 |     | <span class='unexecuted'>    function updatePriceData(</span>
 101 |     | <span class='neutral'>        uint128 perpsMarketId,</span>
 102 |     | <span class='neutral'>        bytes32 feedId,</span>
 103 |     | <span class='neutral'>        uint256 strictStalenessTolerance</span>
 104 |     | <span class='neutral'>    ) external override {</span>
 105 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        PerpsPrice.load(perpsMarketId).update(feedId, strictStalenessTolerance);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        emit MarketPriceDataUpdated(perpsMarketId, feedId, strictStalenessTolerance);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='unexecuted'>    function getPriceData(</span>
 116 |     | <span class='neutral'>        uint128 perpsMarketId</span>
 117 |     | <span class='unexecuted'>    ) external view returns (bytes32 feedId, uint256 strictStalenessTolerance) {</span>
 118 |     | <span class='unexecuted'>        PerpsPrice.Data storage priceData = PerpsPrice.load(perpsMarketId);</span>
 119 |     | <span class='unexecuted'>        feedId = priceData.feedId;</span>
 120 |     | <span class='unexecuted'>        strictStalenessTolerance = priceData.strictStalenessTolerance;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='unexecuted'>    function setMaxMarketSize(uint128 marketId, uint256 maxMarketSize) external override {</span>
 127 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 128 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 129 |     | <span class='unexecuted'>        config.maxMarketSize = maxMarketSize;</span>
 130 |     | <span class='unexecuted'>        emit MaxMarketSizeSet(marketId, maxMarketSize);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='unexecuted'>    function setMaxMarketValue(uint128 marketId, uint256 maxMarketValue) external override {</span>
 137 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 138 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 139 |     | <span class='unexecuted'>        config.maxMarketValue = maxMarketValue;</span>
 140 |     | <span class='unexecuted'>        emit MaxMarketValueSet(marketId, maxMarketValue);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 145 |     | <span class='neutral'>     */</span>
 146 |     | <span class='unexecuted'>    function setFundingParameters(</span>
 147 |     | <span class='neutral'>        uint128 marketId,</span>
 148 |     | <span class='neutral'>        uint256 skewScale,</span>
 149 |     | <span class='neutral'>        uint256 maxFundingVelocity</span>
 150 |     | <span class='unexecuted'>    ) external override {</span>
 151 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 152 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        config.maxFundingVelocity = maxFundingVelocity;</span>
 155 |     | <span class='unexecuted'>        config.skewScale = skewScale;</span>
 156 |     | <span class='unexecuted'>        emit FundingParametersSet(marketId, skewScale, maxFundingVelocity);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /**</span>
 160 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 161 |     | <span class='neutral'>     */</span>
 162 |     | <span class='unexecuted'>    function setMaxLiquidationParameters(</span>
 163 |     | <span class='neutral'>        uint128 marketId,</span>
 164 |     | <span class='neutral'>        uint256 maxLiquidationLimitAccumulationMultiplier,</span>
 165 |     | <span class='neutral'>        uint256 maxSecondsInLiquidationWindow,</span>
 166 |     | <span class='neutral'>        uint256 maxLiquidationPd,</span>
 167 |     | <span class='neutral'>        address endorsedLiquidator</span>
 168 |     | <span class='unexecuted'>    ) external override {</span>
 169 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 170 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>        config</span>
 173 |     | <span class='neutral'>            .maxLiquidationLimitAccumulationMultiplier = maxLiquidationLimitAccumulationMultiplier;</span>
 174 |     | <span class='unexecuted'>        config.maxLiquidationPd = maxLiquidationPd;</span>
 175 |     | <span class='unexecuted'>        config.endorsedLiquidator = endorsedLiquidator;</span>
 176 |     | <span class='unexecuted'>        config.maxSecondsInLiquidationWindow = maxSecondsInLiquidationWindow;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        emit MaxLiquidationParametersSet(</span>
 179 |     | <span class='neutral'>            marketId,</span>
 180 |     | <span class='neutral'>            maxLiquidationLimitAccumulationMultiplier,</span>
 181 |     | <span class='neutral'>            maxSecondsInLiquidationWindow,</span>
 182 |     | <span class='neutral'>            maxLiquidationPd,</span>
 183 |     | <span class='neutral'>            endorsedLiquidator</span>
 184 |     | <span class='neutral'>        );</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='unexecuted'>    function setLiquidationParameters(</span>
 191 |     | <span class='neutral'>        uint128 marketId,</span>
 192 |     | <span class='neutral'>        uint256 initialMarginRatioD18,</span>
 193 |     | <span class='neutral'>        uint256 minimumInitialMarginRatioD18,</span>
 194 |     | <span class='neutral'>        uint256 maintenanceMarginScalarD18,</span>
 195 |     | <span class='neutral'>        uint256 flagRewardRatioD18,</span>
 196 |     | <span class='neutral'>        uint256 minimumPositionMargin</span>
 197 |     | <span class='unexecuted'>    ) external override {</span>
 198 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 199 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        config.initialMarginRatioD18 = initialMarginRatioD18;</span>
 202 |     | <span class='unexecuted'>        config.maintenanceMarginScalarD18 = maintenanceMarginScalarD18;</span>
 203 |     | <span class='unexecuted'>        config.minimumInitialMarginRatioD18 = minimumInitialMarginRatioD18;</span>
 204 |     | <span class='unexecuted'>        config.flagRewardRatioD18 = flagRewardRatioD18;</span>
 205 |     | <span class='unexecuted'>        config.minimumPositionMargin = minimumPositionMargin;</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>        emit LiquidationParametersSet(</span>
 208 |     | <span class='neutral'>            marketId,</span>
 209 |     | <span class='neutral'>            initialMarginRatioD18,</span>
 210 |     | <span class='neutral'>            maintenanceMarginScalarD18,</span>
 211 |     | <span class='neutral'>            minimumInitialMarginRatioD18,</span>
 212 |     | <span class='neutral'>            flagRewardRatioD18,</span>
 213 |     | <span class='neutral'>            minimumPositionMargin</span>
 214 |     | <span class='neutral'>        );</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /**</span>
 218 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 219 |     | <span class='neutral'>     */</span>
 220 |     | <span class='unexecuted'>    function setLockedOiRatio(uint128 marketId, uint256 lockedOiRatioD18) external override {</span>
 221 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 222 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 223 |     | <span class='unexecuted'>        config.lockedOiRatioD18 = lockedOiRatioD18;</span>
 224 |     | <span class='unexecuted'>        emit LockedOiRatioSet(marketId, lockedOiRatioD18);</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    /**</span>
 228 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 229 |     | <span class='neutral'>     */</span>
 230 |     | <span class='unexecuted'>    function getSettlementStrategy(</span>
 231 |     | <span class='neutral'>        uint128 marketId,</span>
 232 |     | <span class='neutral'>        uint256 strategyId</span>
 233 |     | <span class='neutral'>    ) external view override returns (SettlementStrategy.Data memory settlementStrategy) {</span>
 234 |     | <span class='unexecuted'>        return PerpsMarketConfiguration.load(marketId).settlementStrategies[strategyId];</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 239 |     | <span class='neutral'>     */</span>
 240 |     | <span class='unexecuted'>    function getMaxLiquidationParameters(</span>
 241 |     | <span class='neutral'>        uint128 marketId</span>
 242 |     | <span class='neutral'>    )</span>
 243 |     | <span class='neutral'>        external</span>
 244 |     | <span class='neutral'>        view</span>
 245 |     | <span class='neutral'>        override</span>
 246 |     | <span class='neutral'>        returns (</span>
 247 |     | <span class='unexecuted'>            uint256 maxLiquidationLimitAccumulationMultiplier,</span>
 248 |     | <span class='unexecuted'>            uint256 maxSecondsInLiquidationWindow,</span>
 249 |     | <span class='unexecuted'>            uint256 maxLiquidationPd,</span>
 250 |     | <span class='unexecuted'>            address endorsedLiquidator</span>
 251 |     | <span class='neutral'>        )</span>
 252 |     | <span class='neutral'>    {</span>
 253 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>        maxLiquidationLimitAccumulationMultiplier = config</span>
 256 |     | <span class='neutral'>            .maxLiquidationLimitAccumulationMultiplier;</span>
 257 |     | <span class='unexecuted'>        maxSecondsInLiquidationWindow = config.maxSecondsInLiquidationWindow;</span>
 258 |     | <span class='unexecuted'>        maxLiquidationPd = config.maxLiquidationPd;</span>
 259 |     | <span class='unexecuted'>        endorsedLiquidator = config.endorsedLiquidator;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    /**</span>
 263 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 264 |     | <span class='neutral'>     */</span>
 265 |     | <span class='unexecuted'>    function getLiquidationParameters(</span>
 266 |     | <span class='neutral'>        uint128 marketId</span>
 267 |     | <span class='neutral'>    )</span>
 268 |     | <span class='neutral'>        external</span>
 269 |     | <span class='neutral'>        view</span>
 270 |     | <span class='neutral'>        override</span>
 271 |     | <span class='neutral'>        returns (</span>
 272 |     | <span class='unexecuted'>            uint256 initialMarginRatioD18,</span>
 273 |     | <span class='unexecuted'>            uint256 minimumInitialMarginRatioD18,</span>
 274 |     | <span class='unexecuted'>            uint256 maintenanceMarginScalarD18,</span>
 275 |     | <span class='unexecuted'>            uint256 flagRewardRatioD18,</span>
 276 |     | <span class='unexecuted'>            uint256 minimumPositionMargin</span>
 277 |     | <span class='neutral'>        )</span>
 278 |     | <span class='neutral'>    {</span>
 279 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>        initialMarginRatioD18 = config.initialMarginRatioD18;</span>
 282 |     | <span class='unexecuted'>        minimumInitialMarginRatioD18 = config.minimumInitialMarginRatioD18;</span>
 283 |     | <span class='unexecuted'>        maintenanceMarginScalarD18 = config.maintenanceMarginScalarD18;</span>
 284 |     | <span class='unexecuted'>        flagRewardRatioD18 = config.flagRewardRatioD18;</span>
 285 |     | <span class='unexecuted'>        minimumPositionMargin = config.minimumPositionMargin;</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    /**</span>
 289 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 290 |     | <span class='neutral'>     */</span>
 291 |     | <span class='unexecuted'>    function getFundingParameters(</span>
 292 |     | <span class='neutral'>        uint128 marketId</span>
 293 |     | <span class='unexecuted'>    ) external view override returns (uint256 skewScale, uint256 maxFundingVelocity) {</span>
 294 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='unexecuted'>        skewScale = config.skewScale;</span>
 297 |     | <span class='unexecuted'>        maxFundingVelocity = config.maxFundingVelocity;</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    /**</span>
 301 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 302 |     | <span class='neutral'>     */</span>
 303 |     | <span class='unexecuted'>    function getMaxMarketSize(</span>
 304 |     | <span class='neutral'>        uint128 marketId</span>
 305 |     | <span class='unexecuted'>    ) external view override returns (uint256 maxMarketSize) {</span>
 306 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='unexecuted'>        maxMarketSize = config.maxMarketSize;</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /**</span>
 312 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 313 |     | <span class='neutral'>     */</span>
 314 |     | <span class='unexecuted'>    function getMaxMarketValue(</span>
 315 |     | <span class='neutral'>        uint128 marketId</span>
 316 |     | <span class='unexecuted'>    ) external view override returns (uint256 maxMarketValue) {</span>
 317 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>        maxMarketValue = config.maxMarketValue;</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 324 |     | <span class='neutral'>     */</span>
 325 |     | <span class='unexecuted'>    function getOrderFees(</span>
 326 |     | <span class='neutral'>        uint128 marketId</span>
 327 |     | <span class='unexecuted'>    ) external view override returns (uint256 makerFee, uint256 takerFee) {</span>
 328 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>        makerFee = config.orderFees.makerFee;</span>
 331 |     | <span class='neutral'>        takerFee = config.orderFees.takerFee;</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @inheritdoc IMarketConfigurationModule</span>
 336 |     | <span class='neutral'>     */</span>
 337 |     | <span class='unexecuted'>    function getLockedOiRatio(uint128 marketId) external view override returns (uint256) {</span>
 338 |     | <span class='unexecuted'>        PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>        return config.lockedOiRatioD18;</span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'>}</span>
 343 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/PerpsAccountModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   5 |     | <span class='neutral'>import {FeatureFlag} from &quot;@synthetixio/core-modules/contracts/storage/FeatureFlag.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Account} from &quot;@synthetixio/main/contracts/storage/Account.sol&quot;;</span>
   7 |     | <span class='neutral'>import {AccountRBAC} from &quot;@synthetixio/main/contracts/storage/AccountRBAC.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ITokenModule} from &quot;@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;../storage/PerpsMarketFactory.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IPerpsAccountModule} from &quot;../interfaces/IPerpsAccountModule.sol&quot;;</span>
  12 |     | <span class='neutral'>import {PerpsAccount, SNX_USD_MARKET_ID} from &quot;../storage/PerpsAccount.sol&quot;;</span>
  13 |     | <span class='neutral'>import {Position} from &quot;../storage/Position.sol&quot;;</span>
  14 |     | <span class='neutral'>import {AsyncOrder} from &quot;../storage/AsyncOrder.sol&quot;;</span>
  15 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
  16 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
  17 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
  18 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
  19 |     | <span class='neutral'>import {Flags} from &quot;../utils/Flags.sol&quot;;</span>
  20 |     | <span class='neutral'>import {SafeCastU256, SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  21 |     | <span class='neutral'>import {PerpsCollateralConfiguration} from &quot;../storage/PerpsCollateralConfiguration.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>import {console2} from &quot;../../lib/forge-std/src/Test.sol&quot;;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>/**</span>
  26 |     | <span class='neutral'> * @title Module to manage accounts</span>
  27 |     | <span class='neutral'> * @dev See IPerpsAccountModule.</span>
  28 |     | <span class='neutral'> */</span>
  29 | *   | <span class='executed'>contract PerpsAccountModule is IPerpsAccountModule {</span>
  30 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  31 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
  32 |     | <span class='neutral'>    using Position for Position.Data;</span>
  33 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  34 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  35 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  36 |     | <span class='neutral'>    using PerpsMarketFactory for PerpsMarketFactory.Data;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
  40 |     | <span class='neutral'>     */</span>
  41 | *   | <span class='executed'>    function modifyCollateral(</span>
  42 |     | <span class='neutral'>        uint128 accountId,</span>
  43 |     | <span class='neutral'>        uint128 collateralId,</span>
  44 |     | <span class='neutral'>        int256 amountDelta</span>
  45 | *   | <span class='executed'>    ) external override {</span>
  46 | *   | <span class='executed'>        console2.log(&quot;===== PerpsAccountModule::modifyCollateral START =====&quot;);</span>
  47 |     | <span class='neutral'></span>
  48 | *   | <span class='executed'>        console2.log(&quot;Before ensureAccessToFeature&quot;);</span>
  49 | *   | <span class='executed'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
  50 | *   | <span class='executed'>        console2.log(&quot;After ensureAccessToFeature&quot;);</span>
  51 |     | <span class='neutral'></span>
  52 | *   | <span class='executed'>        PerpsCollateralConfiguration.validDistributorExists(collateralId);</span>
  53 |     | <span class='neutral'></span>
  54 | *   | <span class='executed'>        Account.exists(accountId);</span>
  55 | *   | <span class='executed'>        Account.loadAccountAndValidatePermission(</span>
  56 | *   | <span class='executed'>            accountId,</span>
  57 | *   | <span class='executed'>            AccountRBAC._PERPS_MODIFY_COLLATERAL_PERMISSION</span>
  58 |     | <span class='neutral'>        );</span>
  59 |     | <span class='neutral'></span>
  60 | *   | <span class='executed'>        if (amountDelta == 0) revert InvalidAmountDelta(amountDelta);</span>
  61 |     | <span class='neutral'></span>
  62 | *   | <span class='executed'>        console2.log(&quot;Before perpsMarketFactory&quot;);</span>
  63 | *   | <span class='executed'>        PerpsMarketFactory.Data storage perpsMarketFactory = PerpsMarketFactory</span>
  64 |     | <span class='neutral'>            .load();</span>
  65 | *   | <span class='executed'>        console2.log(&quot;After perpsMarketFactory&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 | *   | <span class='executed'>        console2.log(&quot;Before globalPerpsMarket&quot;);</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>        GlobalPerpsMarket.Data storage globalPerpsMarket = GlobalPerpsMarket</span>
  70 |     | <span class='neutral'>            .load();</span>
  71 | *   | <span class='executed'>        console2.log(&quot;After globalPerpsMarket&quot;);</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>        globalPerpsMarket.validateCollateralAmount(collateralId, amountDelta);</span>
  74 | *   | <span class='executed'>        globalPerpsMarket.checkLiquidation(accountId);</span>
  75 |     | <span class='neutral'></span>
  76 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.create(accountId);</span>
  77 | *   | <span class='executed'>        uint128 perpsMarketId = perpsMarketFactory.perpsMarketId;</span>
  78 |     | <span class='neutral'></span>
  79 | *   | <span class='executed'>        PerpsAccount.validateMaxCollaterals(accountId, collateralId);</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>        AsyncOrder.checkPendingOrder(account.id);</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>        if (amountDelta &gt; 0) {</span>
  84 | *   | <span class='executed'>            console2.log(&quot;DEPOSIT MARGIN&quot;);</span>
  85 | *   | <span class='executed'>            _depositMargin(</span>
  86 | *   | <span class='executed'>                perpsMarketFactory,</span>
  87 | *   | <span class='executed'>                perpsMarketId,</span>
  88 | *   | <span class='executed'>                collateralId,</span>
  89 | *   | <span class='executed'>                amountDelta.toUint()</span>
  90 |     | <span class='neutral'>            );</span>
  91 | *   | <span class='executed'>        } else {</span>
  92 | *   | <span class='executed'>            uint256 amountAbs = MathUtil.abs(amountDelta);</span>
  93 |     | <span class='neutral'>            // removing collateral</span>
  94 | *   | <span class='executed'>            account.validateWithdrawableAmount(</span>
  95 | *   | <span class='executed'>                collateralId,</span>
  96 |     | <span class='neutral'>                amountAbs,</span>
  97 | *   | <span class='executed'>                perpsMarketFactory.spotMarket</span>
  98 |     | <span class='neutral'>            );</span>
  99 | *   | <span class='executed'>            console2.log(&quot;WITHDRAW MARGIN&quot;);</span>
 100 |     | <span class='neutral'></span>
 101 | *   | <span class='executed'>            _withdrawMargin(</span>
 102 | *   | <span class='executed'>                perpsMarketFactory,</span>
 103 | *   | <span class='executed'>                perpsMarketId,</span>
 104 | *   | <span class='executed'>                collateralId,</span>
 105 | *   | <span class='executed'>                amountAbs</span>
 106 |     | <span class='neutral'>            );</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // accounting</span>
 110 | *   | <span class='executed'>        account.updateCollateralAmount(collateralId, amountDelta);</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>        emit CollateralModified(</span>
 113 | *   | <span class='executed'>            accountId,</span>
 114 | *   | <span class='executed'>            collateralId,</span>
 115 | *   | <span class='executed'>            amountDelta,</span>
 116 | *   | <span class='executed'>            ERC2771Context._msgSender()</span>
 117 |     | <span class='neutral'>        );</span>
 118 | *   | <span class='executed'>        console2.log(&quot;===== PerpsAccountModule::modifyCollateral END =====&quot;);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>    function debt(</span>
 122 |     | <span class='neutral'>        uint128 accountId</span>
 123 | *   | <span class='executed'>    ) external view override returns (uint256 accountDebt) {</span>
 124 | *   | <span class='executed'>        Account.exists(accountId);</span>
 125 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>        accountDebt = account.debt;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // 1. call depositMarketUsd and deposit amount directly to core system</span>
 131 |     | <span class='neutral'>    // 2. look up account and reduce debt by amount</span>
 132 |     | <span class='neutral'>    // 3b. quoteUnwrap() -&gt; inchQuote -&gt; returnAmount</span>
 133 | *   | <span class='executed'>    function payDebt(uint128 accountId, uint256 amount) external override {</span>
 134 | *   | <span class='executed'>        Account.exists(accountId);</span>
 135 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>        account.payDebt(amount);</span>
 138 |     | <span class='neutral'></span>
 139 | *   | <span class='executed'>        emit DebtPaid(accountId, amount, ERC2771Context._msgSender());</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 144 |     | <span class='neutral'>     */</span>
 145 | *   | <span class='executed'>    function totalCollateralValue(</span>
 146 |     | <span class='neutral'>        uint128 accountId</span>
 147 | *   | <span class='executed'>    ) external view override returns (uint256) {</span>
 148 |     | <span class='neutral'>        return</span>
 149 | *   | <span class='executed'>            PerpsAccount.load(accountId).getTotalCollateralValue(</span>
 150 | *   | <span class='executed'>                PerpsPrice.Tolerance.DEFAULT,</span>
 151 | *   | <span class='executed'>                false</span>
 152 |     | <span class='neutral'>            );</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /**</span>
 156 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='unexecuted'>    function totalAccountOpenInterest(</span>
 159 |     | <span class='neutral'>        uint128 accountId</span>
 160 |     | <span class='unexecuted'>    ) external view override returns (uint256) {</span>
 161 |     | <span class='unexecuted'>        return PerpsAccount.load(accountId).getTotalNotionalOpenInterest();</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 166 |     | <span class='neutral'>     */</span>
 167 | *   | <span class='executed'>    function getOpenPosition(</span>
 168 |     | <span class='neutral'>        uint128 accountId,</span>
 169 |     | <span class='neutral'>        uint128 marketId</span>
 170 |     | <span class='neutral'>    )</span>
 171 |     | <span class='neutral'>        external</span>
 172 |     | <span class='neutral'>        view</span>
 173 |     | <span class='neutral'>        override</span>
 174 |     | <span class='neutral'>        returns (</span>
 175 | *   | <span class='executed'>            int256 totalPnl,</span>
 176 | *   | <span class='executed'>            int256 accruedFunding,</span>
 177 | *   | <span class='executed'>            int128 positionSize,</span>
 178 | *   | <span class='executed'>            uint256 owedInterest</span>
 179 |     | <span class='neutral'>        )</span>
 180 |     | <span class='neutral'>    {</span>
 181 | *   | <span class='executed'>        PerpsMarket.Data storage perpsMarket = PerpsMarket.loadValid(marketId);</span>
 182 |     | <span class='neutral'></span>
 183 | *   | <span class='executed'>        Position.Data storage position = perpsMarket.positions[accountId];</span>
 184 |     | <span class='neutral'></span>
 185 | *   | <span class='executed'>        (</span>
 186 |     | <span class='neutral'>            ,</span>
 187 |     | <span class='neutral'>            totalPnl, //pricePnl</span>
 188 |     | <span class='neutral'>            ,</span>
 189 |     | <span class='neutral'>            owedInterest,</span>
 190 |     | <span class='neutral'>            accruedFunding,</span>
 191 |     | <span class='neutral'>            ,</span>
 192 |     | <span class='neutral'></span>
 193 | *   | <span class='executed'>        ) = position.getPositionData(</span>
 194 | *   | <span class='executed'>            PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)</span>
 195 |     | <span class='neutral'>        );</span>
 196 | *   | <span class='executed'>        console2.log(&quot;PepsAccountModule::totalPnl&quot;, totalPnl);</span>
 197 | *   | <span class='executed'>        console2.log(&quot;PepsAccountModule::owedInterest&quot;, owedInterest);</span>
 198 | *   | <span class='executed'>        console2.log(&quot;PepsAccountModule::positionSize&quot;, position.size);</span>
 199 | *   | <span class='executed'>        return (totalPnl, accruedFunding, position.size, owedInterest);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /**</span>
 203 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='unexecuted'>    function getOpenPositionSize(</span>
 206 |     | <span class='neutral'>        uint128 accountId,</span>
 207 |     | <span class='neutral'>        uint128 marketId</span>
 208 |     | <span class='unexecuted'>    ) external view override returns (int128 positionSize) {</span>
 209 |     | <span class='unexecuted'>        PerpsMarket.Data storage perpsMarket = PerpsMarket.loadValid(marketId);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>        positionSize = perpsMarket.positions[accountId].size;</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /**</span>
 215 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 216 |     | <span class='neutral'>     */</span>
 217 | *   | <span class='executed'>    function getAvailableMargin(</span>
 218 |     | <span class='neutral'>        uint128 accountId</span>
 219 | *   | <span class='executed'>    ) external view override returns (int256 availableMargin) {</span>
 220 | *   | <span class='executed'>        availableMargin = PerpsAccount.load(accountId).getAvailableMargin(</span>
 221 | *   | <span class='executed'>            PerpsPrice.Tolerance.DEFAULT</span>
 222 |     | <span class='neutral'>        );</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    /**</span>
 226 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 227 |     | <span class='neutral'>     */</span>
 228 | *   | <span class='executed'>    function getWithdrawableMargin(</span>
 229 |     | <span class='neutral'>        uint128 accountId</span>
 230 |     | <span class='unexecuted'>    ) external view override returns (int256 withdrawableMargin) {</span>
 231 |     | <span class='unexecuted'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 232 | *   | <span class='executed'>        withdrawableMargin = account.getWithdrawableMargin(</span>
 233 |     | <span class='unexecuted'>            PerpsPrice.Tolerance.DEFAULT</span>
 234 |     | <span class='neutral'>        );</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 239 |     | <span class='neutral'>     */</span>
 240 | *   | <span class='executed'>    function getRequiredMargins(</span>
 241 |     | <span class='neutral'>        uint128 accountId</span>
 242 |     | <span class='neutral'>    )</span>
 243 |     | <span class='neutral'>        external</span>
 244 |     | <span class='neutral'>        view</span>
 245 |     | <span class='neutral'>        override</span>
 246 |     | <span class='neutral'>        returns (</span>
 247 | *   | <span class='executed'>            uint256 requiredInitialMargin,</span>
 248 | *   | <span class='executed'>            uint256 requiredMaintenanceMargin,</span>
 249 | *   | <span class='executed'>            uint256 maxLiquidationReward</span>
 250 |     | <span class='neutral'>        )</span>
 251 | *   | <span class='executed'>    {</span>
 252 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 253 | *   | <span class='executed'>        if (account.openPositionMarketIds.length() == 0) {</span>
 254 | *   | <span class='executed'>            return (0, 0, 0);</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'></span>
 257 | *   | <span class='executed'>        (</span>
 258 |     | <span class='neutral'>            requiredInitialMargin,</span>
 259 |     | <span class='neutral'>            requiredMaintenanceMargin,</span>
 260 |     | <span class='neutral'>            maxLiquidationReward</span>
 261 | *   | <span class='executed'>        ) = account.getAccountRequiredMargins(PerpsPrice.Tolerance.DEFAULT);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        // Include liquidation rewards to required initial margin and required maintenance margin</span>
 264 | *   | <span class='executed'>        requiredInitialMargin += maxLiquidationReward;</span>
 265 | *   | <span class='executed'>        requiredMaintenanceMargin += maxLiquidationReward;</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    /**</span>
 269 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 270 |     | <span class='neutral'>     */</span>
 271 | *   | <span class='executed'>    function getCollateralAmount(</span>
 272 |     | <span class='neutral'>        uint128 accountId,</span>
 273 |     | <span class='neutral'>        uint128 collateralId</span>
 274 | *   | <span class='executed'>    ) external view override returns (uint256) {</span>
 275 | *   | <span class='executed'>        return PerpsAccount.load(accountId).collateralAmounts[collateralId];</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    /**</span>
 279 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 280 |     | <span class='neutral'>     */</span>
 281 | *   | <span class='executed'>    function getAccountCollateralIds(</span>
 282 |     | <span class='neutral'>        uint128 accountId</span>
 283 | *   | <span class='executed'>    ) external view override returns (uint256[] memory) {</span>
 284 | *   | <span class='executed'>        return PerpsAccount.load(accountId).activeCollateralTypes.values();</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    /**</span>
 288 |     | <span class='neutral'>     * @inheritdoc IPerpsAccountModule</span>
 289 |     | <span class='neutral'>     */</span>
 290 | *   | <span class='executed'>    function getAccountOpenPositions(</span>
 291 |     | <span class='neutral'>        uint128 accountId</span>
 292 |     | <span class='unexecuted'>    ) external view override returns (uint256[] memory) {</span>
 293 |     | <span class='unexecuted'>        return PerpsAccount.load(accountId).openPositionMarketIds.values();</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 | *   | <span class='executed'>    function _depositMargin(</span>
 297 |     | <span class='neutral'>        PerpsMarketFactory.Data storage perpsMarketFactory,</span>
 298 |     | <span class='neutral'>        uint128 perpsMarketId,</span>
 299 |     | <span class='neutral'>        uint128 collateralId,</span>
 300 |     | <span class='neutral'>        uint256 amount</span>
 301 |     | <span class='neutral'>    ) internal {</span>
 302 | *   | <span class='executed'>        if (collateralId == SNX_USD_MARKET_ID) {</span>
 303 |     | <span class='neutral'>            // depositing into the USD market</span>
 304 | *   | <span class='executed'>            perpsMarketFactory.synthetix.depositMarketUsd(</span>
 305 | *   | <span class='executed'>                perpsMarketId,</span>
 306 | *   | <span class='executed'>                ERC2771Context._msgSender(),</span>
 307 | *   | <span class='executed'>                amount</span>
 308 |     | <span class='neutral'>            );</span>
 309 |     | <span class='neutral'>        } else {</span>
 310 | *   | <span class='executed'>            ITokenModule synth = ITokenModule(</span>
 311 | *   | <span class='executed'>                perpsMarketFactory.spotMarket.getSynth(collateralId)</span>
 312 |     | <span class='neutral'>            );</span>
 313 | *   | <span class='executed'>            synth.transferFrom(</span>
 314 | *   | <span class='executed'>                ERC2771Context._msgSender(),</span>
 315 | *   | <span class='executed'>                address(this),</span>
 316 |     | <span class='neutral'>                amount</span>
 317 |     | <span class='neutral'>            );</span>
 318 |     | <span class='neutral'>            // depositing into a synth market</span>
 319 | *   | <span class='executed'>            perpsMarketFactory.depositMarketCollateral(synth, amount);</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 | *   | <span class='executed'>    function _withdrawMargin(</span>
 324 |     | <span class='neutral'>        PerpsMarketFactory.Data storage perpsMarketFactory,</span>
 325 |     | <span class='neutral'>        uint128 perpsMarketId,</span>
 326 |     | <span class='neutral'>        uint128 collateralId,</span>
 327 |     | <span class='neutral'>        uint256 amount</span>
 328 |     | <span class='neutral'>    ) internal {</span>
 329 | *   | <span class='executed'>        if (collateralId == SNX_USD_MARKET_ID) {</span>
 330 |     | <span class='neutral'>            // withdrawing from the USD market</span>
 331 | *   | <span class='executed'>            perpsMarketFactory.synthetix.withdrawMarketUsd(</span>
 332 | *   | <span class='executed'>                perpsMarketId,</span>
 333 | *   | <span class='executed'>                ERC2771Context._msgSender(),</span>
 334 |     | <span class='neutral'>                amount</span>
 335 |     | <span class='neutral'>            );</span>
 336 | *   | <span class='executed'>        } else {</span>
 337 | *   | <span class='executed'>            ITokenModule synth = ITokenModule(</span>
 338 | *   | <span class='executed'>                perpsMarketFactory.spotMarket.getSynth(collateralId)</span>
 339 |     | <span class='neutral'>            );</span>
 340 |     | <span class='neutral'>            // withdrawing from a synth market</span>
 341 | *   | <span class='executed'>            perpsMarketFactory.synthetix.withdrawMarketCollateral(</span>
 342 | *   | <span class='executed'>                perpsMarketId,</span>
 343 |     | <span class='neutral'>                address(synth),</span>
 344 | *   | <span class='executed'>                amount</span>
 345 |     | <span class='neutral'>            );</span>
 346 | *   | <span class='executed'>            synth.transfer(ERC2771Context._msgSender(), amount);</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'>}</span>
 350 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/PerpsMarketFactoryModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {OwnableStorage} from &quot;@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol&quot;;</span>
   5 |     | <span class='neutral'>import {FeatureFlag} from &quot;@synthetixio/core-modules/contracts/storage/FeatureFlag.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IERC165} from &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   8 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;../storage/PerpsMarketFactory.sol&quot;;</span>
   9 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Flags} from &quot;../utils/Flags.sol&quot;;</span>
  13 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
  14 |     | <span class='neutral'>import {InterestRate} from &quot;../storage/InterestRate.sol&quot;;</span>
  15 |     | <span class='neutral'>import {IPerpsMarketFactoryModule} from &quot;../interfaces/IPerpsMarketFactoryModule.sol&quot;;</span>
  16 |     | <span class='neutral'>import {ISpotMarketSystem} from &quot;../interfaces/external/ISpotMarketSystem.sol&quot;;</span>
  17 |     | <span class='neutral'>import {ISynthetixSystem} from &quot;../interfaces/external/ISynthetixSystem.sol&quot;;</span>
  18 |     | <span class='neutral'>import {ParameterError} from &quot;@synthetixio/core-contracts/contracts/errors/ParameterError.sol&quot;;</span>
  19 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;../storage/PerpsMarketConfiguration.sol&quot;;</span>
  20 |     | <span class='neutral'>import {IMarket} from &quot;@synthetixio/main/contracts/interfaces/external/IMarket.sol&quot;;</span>
  21 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  22 |     | <span class='neutral'>import {SafeCastU256, SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>/**</span>
  25 |     | <span class='neutral'> * @title Module for registering perpetual futures markets. The factory tracks all markets in the system and consolidates implementation.</span>
  26 |     | <span class='neutral'> * @dev See IPerpsMarketFactoryModule.</span>
  27 |     | <span class='neutral'> */</span>
  28 | *   | <span class='executed'>contract PerpsMarketFactoryModule is IPerpsMarketFactoryModule {</span>
  29 |     | <span class='neutral'>    using PerpsMarketFactory for PerpsMarketFactory.Data;</span>
  30 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  31 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  32 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  33 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  34 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  35 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    bytes32 private constant _ACCOUNT_TOKEN_SYSTEM = &quot;accountNft&quot;;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketFactoryModule</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='unexecuted'>    function initializeFactory(</span>
  43 |     | <span class='neutral'>        ISynthetixSystem synthetix,</span>
  44 |     | <span class='neutral'>        ISpotMarketSystem spotMarket</span>
  45 |     | <span class='unexecuted'>    ) external override returns (uint128) {</span>
  46 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        uint128 perpsMarketId;</span>
  51 |     | <span class='unexecuted'>        if (factory.perpsMarketId == 0) {</span>
  52 |     | <span class='unexecuted'>            perpsMarketId = factory.initialize(synthetix, spotMarket);</span>
  53 |     | <span class='neutral'>        } else {</span>
  54 |     | <span class='unexecuted'>            perpsMarketId = factory.perpsMarketId;</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        emit FactoryInitialized(perpsMarketId);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        return perpsMarketId;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketFactoryModule</span>
  64 |     | <span class='neutral'>     */</span>
  65 | *   | <span class='executed'>    function setPerpsMarketName(string memory marketName) external override {</span>
  66 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  67 | *   | <span class='executed'>        PerpsMarketFactory.load().name = marketName;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketFactoryModule</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='unexecuted'>    function createMarket(</span>
  74 |     | <span class='neutral'>        uint128 requestedMarketId,</span>
  75 |     | <span class='neutral'>        string memory marketName,</span>
  76 |     | <span class='neutral'>        string memory marketSymbol</span>
  77 |     | <span class='unexecuted'>    ) external override returns (uint128) {</span>
  78 |     | <span class='unexecuted'>        FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);</span>
  79 |     | <span class='unexecuted'>        FeatureFlag.ensureAccessToFeature(Flags.CREATE_MARKET);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  82 |     | <span class='unexecuted'>        PerpsMarketFactory.load().onlyIfInitialized();</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        if (requestedMarketId == 0) {</span>
  85 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(&quot;requestedMarketId&quot;, &quot;cannot be 0&quot;);</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        PerpsMarket.createValid(requestedMarketId, marketName, marketSymbol);</span>
  89 |     | <span class='unexecuted'>        GlobalPerpsMarket.load().addMarket(requestedMarketId);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        emit MarketCreated(requestedMarketId, marketName, marketSymbol);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        return requestedMarketId;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @inheritdoc IMarket</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    // solc-ignore-next-line func-mutability</span>
 100 |     | <span class='unexecuted'>    function name(uint128 perpsMarketId) external view override returns (string memory) {</span>
 101 |     | <span class='unexecuted'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        if (factory.perpsMarketId == perpsMarketId) {</span>
 104 |     | <span class='unexecuted'>            return string.concat(factory.name, &quot; Perps Market&quot;);</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        return &quot;&quot;;</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @inheritdoc IMarket</span>
 112 |     | <span class='neutral'>     */</span>
 113 | *   | <span class='executed'>    function reportedDebt(uint128 perpsMarketId) external view override returns (uint256) {</span>
 114 | *   | <span class='executed'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>        if (factory.perpsMarketId == perpsMarketId) {</span>
 117 |     | <span class='neutral'>            // debt is the total debt of all markets</span>
 118 |     | <span class='neutral'>            // can be computed as total collateral value - sum_each_market( debt )</span>
 119 | *   | <span class='executed'>            GlobalPerpsMarket.Data storage globalMarket = GlobalPerpsMarket.load();</span>
 120 | *   | <span class='executed'>            uint256 collateralValue = globalMarket.totalCollateralValue();</span>
 121 | *   | <span class='executed'>            int256 totalMarketDebt;</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>            SetUtil.UintSet storage activeMarkets = globalMarket.activeMarkets;</span>
 124 | *   | <span class='executed'>            uint256 activeMarketsLength = activeMarkets.length();</span>
 125 | *   | <span class='executed'>            for (uint256 i = 1; i &lt;= activeMarketsLength; i++) {</span>
 126 | *   | <span class='executed'>                uint128 marketId = activeMarkets.valueAt(i).to128();</span>
 127 | *   | <span class='executed'>                totalMarketDebt += PerpsMarket.load(marketId).marketDebt(</span>
 128 | *   | <span class='executed'>                    PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)</span>
 129 |     | <span class='neutral'>                );</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'></span>
 132 | *   | <span class='executed'>            int256 totalDebt = collateralValue.toInt() +</span>
 133 | *   | <span class='executed'>                totalMarketDebt -</span>
 134 | *   | <span class='executed'>                globalMarket.totalAccountsDebt.toInt();</span>
 135 | *   | <span class='executed'>            return MathUtil.max(0, totalDebt).toUint();</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'></span>
 138 | *   | <span class='executed'>        return 0;</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /**</span>
 142 |     | <span class='neutral'>     * @inheritdoc IMarket</span>
 143 |     | <span class='neutral'>     */</span>
 144 | *   | <span class='executed'>    function minimumCredit(uint128 perpsMarketId) external view override returns (uint256) {</span>
 145 | *   | <span class='executed'>        if (PerpsMarketFactory.load().perpsMarketId == perpsMarketId) {</span>
 146 | *   | <span class='executed'>            return GlobalPerpsMarket.load().minimumCredit(PerpsPrice.Tolerance.DEFAULT);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'></span>
 149 | *   | <span class='executed'>        return 0;</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /**</span>
 153 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketFactoryModule</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='unexecuted'>    function interestRate() external view override returns (uint128) {</span>
 156 |     | <span class='unexecuted'>        return InterestRate.load().interestRate;</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /**</span>
 160 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketFactoryModule</span>
 161 |     | <span class='neutral'>     */</span>
 162 | *   | <span class='executed'>    function utilizationRate()</span>
 163 |     | <span class='neutral'>        external</span>
 164 |     | <span class='neutral'>        view</span>
 165 |     | <span class='neutral'>        override</span>
 166 | *   | <span class='executed'>        returns (uint256 rate, uint256 delegatedCollateral, uint256 lockedCredit)</span>
 167 |     | <span class='neutral'>    {</span>
 168 | *   | <span class='executed'>        return GlobalPerpsMarket.load().utilizationRate(PerpsPrice.Tolerance.ONE_MONTH);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    /**</span>
 172 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 173 |     | <span class='neutral'>     */</span>
 174 | *   | <span class='executed'>    function supportsInterface(</span>
 175 |     | <span class='neutral'>        bytes4 interfaceId</span>
 176 |     | <span class='unexecuted'>    ) public view virtual override(IERC165) returns (bool) {</span>
 177 | *   | <span class='executed'>        return</span>
 178 | *   | <span class='executed'>            interfaceId == type(IMarket).interfaceId ||</span>
 179 |     | <span class='unexecuted'>            interfaceId == this.supportsInterface.selector;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'>}</span>
 182 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/PerpsMarketModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
   5 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;../storage/PerpsMarketConfiguration.sol&quot;;</span>
   6 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
   7 |     | <span class='neutral'>import {AsyncOrder} from &quot;../storage/AsyncOrder.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IPerpsMarketModule} from &quot;../interfaces/IPerpsMarketModule.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title Module for getting perps market information.</span>
  12 |     | <span class='neutral'> * @dev See IPerpsMarketModule.</span>
  13 |     | <span class='neutral'> */</span>
  14 | *   | <span class='executed'>contract PerpsMarketModule is IPerpsMarketModule {</span>
  15 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='unexecuted'>    function metadata(</span>
  21 |     | <span class='neutral'>        uint128 marketId</span>
  22 |     | <span class='unexecuted'>    ) external view override returns (string memory name, string memory symbol) {</span>
  23 |     | <span class='unexecuted'>        PerpsMarket.Data storage market = PerpsMarket.load(marketId);</span>
  24 |     | <span class='unexecuted'>        return (market.name, market.symbol);</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  29 |     | <span class='neutral'>     */</span>
  30 | *   | <span class='executed'>    function skew(uint128 marketId) external view override returns (int256) {</span>
  31 | *   | <span class='executed'>        return PerpsMarket.load(marketId).skew;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  36 |     | <span class='neutral'>     */</span>
  37 | *   | <span class='executed'>    function size(uint128 marketId) external view override returns (uint256) {</span>
  38 | *   | <span class='executed'>        return PerpsMarket.load(marketId).size;</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  43 |     | <span class='neutral'>     */</span>
  44 | *   | <span class='executed'>    function maxOpenInterest(uint128 marketId) external view override returns (uint256) {</span>
  45 | *   | <span class='executed'>        return PerpsMarketConfiguration.load(marketId).maxMarketSize;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='unexecuted'>    function currentFundingRate(uint128 marketId) external view override returns (int256) {</span>
  52 |     | <span class='unexecuted'>        return PerpsMarket.load(marketId).currentFundingRate();</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='unexecuted'>    function currentFundingVelocity(uint128 marketId) external view override returns (int256) {</span>
  59 |     | <span class='unexecuted'>        return PerpsMarket.load(marketId).currentFundingVelocity();</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='unexecuted'>    function indexPrice(uint128 marketId) external view override returns (uint256) {</span>
  66 |     | <span class='unexecuted'>        return PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='unexecuted'>    function fillPrice(</span>
  73 |     | <span class='neutral'>        uint128 marketId,</span>
  74 |     | <span class='neutral'>        int128 orderSize,</span>
  75 |     | <span class='neutral'>        uint256 price</span>
  76 |     | <span class='unexecuted'>    ) external view override returns (uint256) {</span>
  77 |     | <span class='unexecuted'>        return</span>
  78 |     | <span class='unexecuted'>            AsyncOrder.calculateFillPrice(</span>
  79 |     | <span class='unexecuted'>                PerpsMarket.load(marketId).skew,</span>
  80 |     | <span class='unexecuted'>                PerpsMarketConfiguration.load(marketId).skewScale,</span>
  81 |     | <span class='unexecuted'>                orderSize,</span>
  82 |     | <span class='unexecuted'>                price</span>
  83 |     | <span class='neutral'>            );</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @inheritdoc IPerpsMarketModule</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='unexecuted'>    function getMarketSummary(</span>
  90 |     | <span class='neutral'>        uint128 marketId</span>
  91 |     | <span class='unexecuted'>    ) external view override returns (MarketSummary memory summary) {</span>
  92 |     | <span class='unexecuted'>        PerpsMarket.Data storage market = PerpsMarket.load(marketId);</span>
  93 |     | <span class='unexecuted'>        return</span>
  94 |     | <span class='unexecuted'>            MarketSummary({</span>
  95 |     | <span class='unexecuted'>                skew: market.skew,</span>
  96 |     | <span class='unexecuted'>                size: market.size,</span>
  97 |     | <span class='unexecuted'>                maxOpenInterest: this.maxOpenInterest(marketId),</span>
  98 |     | <span class='unexecuted'>                currentFundingRate: market.currentFundingRate(),</span>
  99 |     | <span class='unexecuted'>                currentFundingVelocity: market.currentFundingVelocity(),</span>
 100 |     | <span class='unexecuted'>                indexPrice: this.indexPrice(marketId)</span>
 101 |     | <span class='neutral'>            });</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/AsyncOrder.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SafeCastI256, SafeCastU256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SettlementStrategy} from &quot;./SettlementStrategy.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Position} from &quot;./Position.sol&quot;;</span>
   8 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;./PerpsMarketConfiguration.sol&quot;;</span>
   9 |     | <span class='neutral'>import {PerpsMarket} from &quot;./PerpsMarket.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsPrice} from &quot;./PerpsPrice.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsAccount} from &quot;./PerpsAccount.sol&quot;;</span>
  12 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
  13 |     | <span class='neutral'>import {OrderFee} from &quot;./OrderFee.sol&quot;;</span>
  14 |     | <span class='neutral'>import {KeeperCosts} from &quot;./KeeperCosts.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/**</span>
  17 |     | <span class='neutral'> * @title Async order top level data storage</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library AsyncOrder {</span>
  20 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  21 |     | <span class='neutral'>    using DecimalMath for int128;</span>
  22 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  23 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  24 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  25 |     | <span class='neutral'>    using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;</span>
  26 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  27 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
  28 |     | <span class='neutral'>    using KeeperCosts for KeeperCosts.Data;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @notice Thrown when settlement window is not open yet.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    error SettlementWindowNotOpen(uint256 timestamp, uint256 settlementTime);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @notice Thrown when attempting to settle an expired order.</span>
  37 |     | <span class='neutral'>     */</span>
  38 |     | <span class='neutral'>    error SettlementWindowExpired(</span>
  39 |     | <span class='neutral'>        uint256 timestamp,</span>
  40 |     | <span class='neutral'>        uint256 settlementTime,</span>
  41 |     | <span class='neutral'>        uint256 settlementExpiration</span>
  42 |     | <span class='neutral'>    );</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @notice Thrown when order does not exist.</span>
  46 |     | <span class='neutral'>     * @dev Order does not exist if the order sizeDelta is 0.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    error OrderNotValid();</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Thrown when fill price exceeds the acceptable price set at submission.</span>
  52 |     | <span class='neutral'>     */</span>
  53 |     | <span class='neutral'>    error AcceptablePriceExceeded(uint256 fillPrice, uint256 acceptablePrice);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @notice Gets thrown when attempting to cancel an order and price does not exceeds acceptable price.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    error AcceptablePriceNotExceeded(uint256 fillPrice, uint256 acceptablePrice);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @notice Gets thrown when pending orders exist and attempts to modify collateral.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    error PendingOrderExists();</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @notice Thrown when commiting an order with sizeDelta is zero.</span>
  67 |     | <span class='neutral'>     * @dev Size delta 0 is used to flag a non-valid order since it&#39;s a non-update order.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    error ZeroSizeOrder();</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @notice Thrown when there&#39;s not enough margin to cover the order and settlement costs associated.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='neutral'>    error InsufficientMargin(int256 availableMargin, uint256 minMargin);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    struct Data {</span>
  77 |     | <span class='neutral'>        /**</span>
  78 |     | <span class='neutral'>         * @dev Time at which the order was committed.</span>
  79 |     | <span class='neutral'>         */</span>
  80 |     | <span class='neutral'>        uint256 commitmentTime;</span>
  81 |     | <span class='neutral'>        /**</span>
  82 |     | <span class='neutral'>         * @dev Order request details.</span>
  83 |     | <span class='neutral'>         */</span>
  84 |     | <span class='neutral'>        OrderCommitmentRequest request;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    struct OrderCommitmentRequest {</span>
  88 |     | <span class='neutral'>        /**</span>
  89 |     | <span class='neutral'>         * @dev Order market id.</span>
  90 |     | <span class='neutral'>         */</span>
  91 |     | <span class='neutral'>        uint128 marketId;</span>
  92 |     | <span class='neutral'>        /**</span>
  93 |     | <span class='neutral'>         * @dev Order account id.</span>
  94 |     | <span class='neutral'>         */</span>
  95 |     | <span class='neutral'>        uint128 accountId;</span>
  96 |     | <span class='neutral'>        /**</span>
  97 |     | <span class='neutral'>         * @dev Order size delta (of asset units expressed in decimal 18 digits). It can be positive or negative.</span>
  98 |     | <span class='neutral'>         */</span>
  99 |     | <span class='neutral'>        int128 sizeDelta;</span>
 100 |     | <span class='neutral'>        /**</span>
 101 |     | <span class='neutral'>         * @dev Settlement strategy used for the order.</span>
 102 |     | <span class='neutral'>         */</span>
 103 |     | <span class='neutral'>        uint128 settlementStrategyId;</span>
 104 |     | <span class='neutral'>        /**</span>
 105 |     | <span class='neutral'>         * @dev Acceptable price set at submission.</span>
 106 |     | <span class='neutral'>         */</span>
 107 |     | <span class='neutral'>        uint256 acceptablePrice;</span>
 108 |     | <span class='neutral'>        /**</span>
 109 |     | <span class='neutral'>         * @dev An optional code provided by frontends to assist with tracking the source of volume and fees.</span>
 110 |     | <span class='neutral'>         */</span>
 111 |     | <span class='neutral'>        bytes32 trackingCode;</span>
 112 |     | <span class='neutral'>        /**</span>
 113 |     | <span class='neutral'>         * @dev Referrer address to send the referrer fees to.</span>
 114 |     | <span class='neutral'>         */</span>
 115 |     | <span class='neutral'>        address referrer;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @notice Updates the order with the commitment request data and settlement time.</span>
 120 |     | <span class='neutral'>     */</span>
 121 | *   | <span class='executed'>    function load(uint128 accountId) internal pure returns (Data storage order) {</span>
 122 | *   | <span class='executed'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.perps-market.AsyncOrder&quot;, accountId));</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>        assembly {</span>
 125 |     | <span class='neutral'>            order.slot := s</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Reverts if order was not committed by checking the sizeDelta.</span>
 131 |     | <span class='neutral'>     * @dev Reverts if order is not in the settlement window.</span>
 132 |     | <span class='neutral'>     */</span>
 133 | *   | <span class='executed'>    function loadValid(</span>
 134 |     | <span class='neutral'>        uint128 accountId</span>
 135 | *   | <span class='executed'>    ) internal view returns (Data storage order, SettlementStrategy.Data storage strategy) {</span>
 136 | *   | <span class='executed'>        order = load(accountId);</span>
 137 | *   | <span class='executed'>        if (order.request.sizeDelta == 0) {</span>
 138 | *   | <span class='executed'>            revert OrderNotValid();</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>        strategy = PerpsMarketConfiguration.loadValidSettlementStrategy(</span>
 142 | *   | <span class='executed'>            order.request.marketId,</span>
 143 | *   | <span class='executed'>            order.request.settlementStrategyId</span>
 144 |     | <span class='neutral'>        );</span>
 145 | *   | <span class='executed'>        checkWithinSettlementWindow(order, strategy);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Updates the order with the new commitment request data and settlement time.</span>
 150 |     | <span class='neutral'>     * @dev Reverts if there&#39;s a pending order.</span>
 151 |     | <span class='neutral'>     * @dev Reverts if accont cannot open a new position (due to max allowed reached).</span>
 152 |     | <span class='neutral'>     */</span>
 153 | *   | <span class='executed'>    function updateValid(Data storage self, OrderCommitmentRequest memory newRequest) internal {</span>
 154 | *   | <span class='executed'>        checkPendingOrder(newRequest.accountId);</span>
 155 |     | <span class='neutral'></span>
 156 | *   | <span class='executed'>        PerpsAccount.validateMaxPositions(newRequest.accountId, newRequest.marketId);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>        // Replace previous (or empty) order with the commitment request</span>
 159 | *   | <span class='executed'>        self.commitmentTime = block.timestamp;</span>
 160 | *   | <span class='executed'>        self.request = newRequest;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @dev Reverts if there is a pending order.</span>
 165 |     | <span class='neutral'>     * @dev A pending order is one that has a sizeDelta and isn&#39;t expired yet.</span>
 166 |     | <span class='neutral'>     */</span>
 167 | *   | <span class='executed'>    function checkPendingOrder(uint128 accountId) internal view returns (Data storage order) {</span>
 168 | *   | <span class='executed'>        order = load(accountId);</span>
 169 |     | <span class='neutral'></span>
 170 | *   | <span class='executed'>        if (order.request.sizeDelta != 0) {</span>
 171 | *   | <span class='executed'>            SettlementStrategy.Data storage strategy = PerpsMarketConfiguration</span>
 172 | *   | <span class='executed'>                .load(order.request.marketId)</span>
 173 | *   | <span class='executed'>                .settlementStrategies[order.request.settlementStrategyId];</span>
 174 |     | <span class='neutral'></span>
 175 | *   | <span class='executed'>            if (!expired(order, strategy)) {</span>
 176 | *   | <span class='executed'>                revert PendingOrderExists();</span>
 177 |     | <span class='neutral'>            }</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    /**</span>
 182 |     | <span class='neutral'>     * @notice Resets the order.</span>
 183 |     | <span class='neutral'>     * @dev This function is called after the order is settled.</span>
 184 |     | <span class='neutral'>     * @dev Just setting the sizeDelta to 0 is enough, since is the value checked to identify an active order at settlement time.</span>
 185 |     | <span class='neutral'>     * @dev The rest of the fields will be updated on the next commitment. Not doing it here is more gas efficient.</span>
 186 |     | <span class='neutral'>     */</span>
 187 | *   | <span class='executed'>    function reset(Data storage self) internal {</span>
 188 | *   | <span class='executed'>        self.request.sizeDelta = 0;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /**</span>
 192 |     | <span class='neutral'>     * @notice Checks if the order window settlement is opened and expired.</span>
 193 |     | <span class='neutral'>     * @dev Reverts if block.timestamp is &lt; settlementTime (not &lt;=, so even if the settlementDelay is set to zero, it will require at least 1 second waiting time)</span>
 194 |     | <span class='neutral'>     * @dev Reverts if block.timestamp is &gt; settlementTime + settlementWindowDuration</span>
 195 |     | <span class='neutral'>     */</span>
 196 | *   | <span class='executed'>    function checkWithinSettlementWindow(</span>
 197 |     | <span class='neutral'>        Data storage self,</span>
 198 |     | <span class='neutral'>        SettlementStrategy.Data storage settlementStrategy</span>
 199 |     | <span class='neutral'>    ) internal view {</span>
 200 | *   | <span class='executed'>        uint256 settlementTime = self.commitmentTime + settlementStrategy.settlementDelay;</span>
 201 | *   | <span class='executed'>        uint256 settlementExpiration = settlementTime + settlementStrategy.settlementWindowDuration;</span>
 202 |     | <span class='neutral'></span>
 203 | *   | <span class='executed'>        if (block.timestamp &lt; settlementTime) {</span>
 204 |     | <span class='unexecuted'>            revert SettlementWindowNotOpen(block.timestamp, settlementTime);</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'></span>
 207 | *   | <span class='executed'>        if (block.timestamp &gt; settlementExpiration) {</span>
 208 | *   | <span class='executed'>            revert SettlementWindowExpired(block.timestamp, settlementTime, settlementExpiration);</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @notice Returns if order is expired or not</span>
 214 |     | <span class='neutral'>     */</span>
 215 | *   | <span class='executed'>    function expired(</span>
 216 |     | <span class='neutral'>        Data storage self,</span>
 217 |     | <span class='neutral'>        SettlementStrategy.Data storage settlementStrategy</span>
 218 | *   | <span class='executed'>    ) internal view returns (bool) {</span>
 219 | *   | <span class='executed'>        uint256 settlementExpiration = self.commitmentTime +</span>
 220 | *   | <span class='executed'>            settlementStrategy.settlementDelay +</span>
 221 | *   | <span class='executed'>            settlementStrategy.settlementWindowDuration;</span>
 222 | *   | <span class='executed'>        return block.timestamp &gt; settlementExpiration;</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    /**</span>
 226 |     | <span class='neutral'>     * @dev Struct used internally in validateOrder() to prevent stack too deep error.</span>
 227 |     | <span class='neutral'>     */</span>
 228 |     | <span class='neutral'>    struct SimulateDataRuntime {</span>
 229 |     | <span class='neutral'>        bool isEligible;</span>
 230 |     | <span class='neutral'>        int128 sizeDelta;</span>
 231 |     | <span class='neutral'>        uint128 accountId;</span>
 232 |     | <span class='neutral'>        uint128 marketId;</span>
 233 |     | <span class='neutral'>        uint256 fillPrice;</span>
 234 |     | <span class='neutral'>        uint256 orderFees;</span>
 235 |     | <span class='neutral'>        uint256 availableMargin;</span>
 236 |     | <span class='neutral'>        uint256 currentLiquidationMargin;</span>
 237 |     | <span class='neutral'>        uint256 accumulatedLiquidationRewards;</span>
 238 |     | <span class='neutral'>        uint256 currentLiquidationReward;</span>
 239 |     | <span class='neutral'>        int128 newPositionSize;</span>
 240 |     | <span class='neutral'>        uint256 newNotionalValue;</span>
 241 |     | <span class='neutral'>        int256 currentAvailableMargin;</span>
 242 |     | <span class='neutral'>        uint256 requiredInitialMargin;</span>
 243 |     | <span class='neutral'>        uint256 initialRequiredMargin;</span>
 244 |     | <span class='neutral'>        uint256 totalRequiredMargin;</span>
 245 |     | <span class='neutral'>        Position.Data newPosition;</span>
 246 |     | <span class='neutral'>        bytes32 trackingCode;</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>    /**</span>
 250 |     | <span class='neutral'>     * @notice Checks if the order request can be settled.</span>
 251 |     | <span class='neutral'>     * @dev it recomputes market funding rate, calculates fill price and fees for the order</span>
 252 |     | <span class='neutral'>     * @dev and with that data it checks that:</span>
 253 |     | <span class='neutral'>     * @dev - the account is eligible for liquidation</span>
 254 |     | <span class='neutral'>     * @dev - the fill price is within the acceptable price range</span>
 255 |     | <span class='neutral'>     * @dev - the position size doesn&#39;t exceed market configured limits</span>
 256 |     | <span class='neutral'>     * @dev - the account has enough margin to cover for the fees</span>
 257 |     | <span class='neutral'>     * @dev - the account has enough margin to not be liquidable immediately after the order is settled</span>
 258 |     | <span class='neutral'>     * @dev if the order can be executed, it returns (newPosition, orderFees, fillPrice, oldPosition)</span>
 259 |     | <span class='neutral'>     */</span>
 260 | *   | <span class='executed'>    function validateRequest(</span>
 261 |     | <span class='neutral'>        Data storage order,</span>
 262 |     | <span class='neutral'>        SettlementStrategy.Data storage strategy,</span>
 263 |     | <span class='neutral'>        uint256 orderPrice</span>
 264 |     | <span class='neutral'>    ) internal returns (Position.Data memory, uint256, uint256, Position.Data storage oldPosition) {</span>
 265 | *   | <span class='executed'>        SimulateDataRuntime memory runtime;</span>
 266 | *   | <span class='executed'>        runtime.sizeDelta = order.request.sizeDelta;</span>
 267 | *   | <span class='executed'>        runtime.accountId = order.request.accountId;</span>
 268 | *   | <span class='executed'>        runtime.marketId = order.request.marketId;</span>
 269 |     | <span class='neutral'></span>
 270 | *   | <span class='executed'>        if (runtime.sizeDelta == 0) {</span>
 271 |     | <span class='unexecuted'>            revert ZeroSizeOrder();</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'></span>
 274 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(runtime.accountId);</span>
 275 |     | <span class='neutral'></span>
 276 | *   | <span class='executed'>        (</span>
 277 |     | <span class='neutral'>            runtime.isEligible,</span>
 278 | *   | <span class='executed'>            runtime.currentAvailableMargin,</span>
 279 | *   | <span class='executed'>            runtime.requiredInitialMargin,</span>
 280 |     | <span class='neutral'>            ,</span>
 281 | *   | <span class='executed'>            runtime.currentLiquidationReward</span>
 282 | *   | <span class='executed'>        ) = account.isEligibleForLiquidation(PerpsPrice.Tolerance.DEFAULT);</span>
 283 |     | <span class='neutral'></span>
 284 | *   | <span class='executed'>        if (runtime.isEligible) {</span>
 285 | *   | <span class='executed'>            revert PerpsAccount.AccountLiquidatable(runtime.accountId);</span>
 286 |     | <span class='neutral'>        }</span>
 287 |     | <span class='neutral'></span>
 288 | *   | <span class='executed'>        PerpsMarket.Data storage perpsMarketData = PerpsMarket.load(runtime.marketId);</span>
 289 | *   | <span class='executed'>        perpsMarketData.recomputeFunding(orderPrice);</span>
 290 |     | <span class='neutral'></span>
 291 | *   | <span class='executed'>        PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(</span>
 292 | *   | <span class='executed'>            runtime.marketId</span>
 293 |     | <span class='neutral'>        );</span>
 294 |     | <span class='neutral'></span>
 295 | *   | <span class='executed'>        runtime.fillPrice = calculateFillPrice(</span>
 296 | *   | <span class='executed'>            perpsMarketData.skew,</span>
 297 | *   | <span class='executed'>            marketConfig.skewScale,</span>
 298 | *   | <span class='executed'>            runtime.sizeDelta,</span>
 299 | *   | <span class='executed'>            orderPrice</span>
 300 |     | <span class='neutral'>        );</span>
 301 |     | <span class='neutral'></span>
 302 | *   | <span class='executed'>        runtime.orderFees =</span>
 303 | *   | <span class='executed'>            calculateOrderFee(</span>
 304 | *   | <span class='executed'>                runtime.sizeDelta,</span>
 305 | *   | <span class='executed'>                runtime.fillPrice,</span>
 306 | *   | <span class='executed'>                perpsMarketData.skew,</span>
 307 | *   | <span class='executed'>                marketConfig.orderFees</span>
 308 |     | <span class='neutral'>            ) +</span>
 309 | *   | <span class='executed'>            settlementRewardCost(strategy);</span>
 310 |     | <span class='neutral'></span>
 311 | *   | <span class='executed'>        oldPosition = PerpsMarket.accountPosition(runtime.marketId, runtime.accountId);</span>
 312 | *   | <span class='executed'>        runtime.newPositionSize = oldPosition.size + runtime.sizeDelta;</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>        // only account for negative pnl</span>
 315 | *   | <span class='executed'>        runtime.currentAvailableMargin += MathUtil.min(</span>
 316 | *   | <span class='executed'>            calculateStartingPnl(runtime.fillPrice, orderPrice, runtime.newPositionSize),</span>
 317 | *   | <span class='executed'>            0</span>
 318 |     | <span class='neutral'>        );</span>
 319 |     | <span class='neutral'></span>
 320 | *   | <span class='executed'>        if (runtime.currentAvailableMargin &lt; runtime.orderFees.toInt()) {</span>
 321 | *   | <span class='executed'>            revert InsufficientMargin(runtime.currentAvailableMargin, runtime.orderFees);</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='neutral'></span>
 324 | *   | <span class='executed'>        PerpsMarket.validatePositionSize(</span>
 325 | *   | <span class='executed'>            perpsMarketData,</span>
 326 | *   | <span class='executed'>            marketConfig.maxMarketSize,</span>
 327 | *   | <span class='executed'>            marketConfig.maxMarketValue,</span>
 328 | *   | <span class='executed'>            orderPrice,</span>
 329 | *   | <span class='executed'>            oldPosition.size,</span>
 330 | *   | <span class='executed'>            runtime.newPositionSize</span>
 331 |     | <span class='neutral'>        );</span>
 332 |     | <span class='neutral'></span>
 333 | *   | <span class='executed'>        runtime.totalRequiredMargin =</span>
 334 | *   | <span class='executed'>            getRequiredMarginWithNewPosition(</span>
 335 | *   | <span class='executed'>                account,</span>
 336 | *   | <span class='executed'>                marketConfig,</span>
 337 | *   | <span class='executed'>                runtime.marketId,</span>
 338 | *   | <span class='executed'>                oldPosition.size,</span>
 339 | *   | <span class='executed'>                runtime.newPositionSize,</span>
 340 | *   | <span class='executed'>                runtime.fillPrice,</span>
 341 | *   | <span class='executed'>                runtime.requiredInitialMargin</span>
 342 |     | <span class='neutral'>            ) +</span>
 343 | *   | <span class='executed'>            runtime.orderFees;</span>
 344 |     | <span class='neutral'></span>
 345 | *   | <span class='executed'>        if (runtime.currentAvailableMargin &lt; runtime.totalRequiredMargin.toInt()) {</span>
 346 | *   | <span class='executed'>            revert InsufficientMargin(runtime.currentAvailableMargin, runtime.totalRequiredMargin);</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'></span>
 349 | *   | <span class='executed'>        runtime.newPosition = Position.Data({</span>
 350 | *   | <span class='executed'>            marketId: runtime.marketId,</span>
 351 | *   | <span class='executed'>            latestInteractionPrice: runtime.fillPrice.to128(),</span>
 352 | *   | <span class='executed'>            latestInteractionFunding: perpsMarketData.lastFundingValue.to128(),</span>
 353 | *   | <span class='executed'>            latestInterestAccrued: 0,</span>
 354 | *   | <span class='executed'>            size: runtime.newPositionSize</span>
 355 |     | <span class='neutral'>        });</span>
 356 | *   | <span class='executed'>        return (runtime.newPosition, runtime.orderFees, runtime.fillPrice, oldPosition);</span>
 357 |     | <span class='neutral'>    }</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>    /**</span>
 360 |     | <span class='neutral'>     * @notice Checks if the order request can be cancelled.</span>
 361 |     | <span class='neutral'>     * @notice This function doesn&#39;t check for liquidation or available margin since the fees to be paid are small and we did that check at commitment less than the settlement window time.</span>
 362 |     | <span class='neutral'>     * @notice it won&#39;t check if the order exists since it was already checked when loading the order (loadValid)</span>
 363 |     | <span class='neutral'>     * @dev it calculates fill price the order</span>
 364 |     | <span class='neutral'>     * @dev and with that data it checks that:</span>
 365 |     | <span class='neutral'>     * @dev - settlement window is open</span>
 366 |     | <span class='neutral'>     * @dev - the fill price is outside the acceptable price range</span>
 367 |     | <span class='neutral'>     * @dev if the order can be cancelled, it returns the fillPrice</span>
 368 |     | <span class='neutral'>     */</span>
 369 | *   | <span class='executed'>    function validateCancellation(</span>
 370 |     | <span class='neutral'>        Data storage order,</span>
 371 |     | <span class='neutral'>        SettlementStrategy.Data storage strategy,</span>
 372 |     | <span class='neutral'>        uint256 orderPrice</span>
 373 | *   | <span class='executed'>    ) internal view returns (uint256 fillPrice) {</span>
 374 | *   | <span class='executed'>        checkWithinSettlementWindow(order, strategy);</span>
 375 |     | <span class='neutral'></span>
 376 | *   | <span class='executed'>        PerpsMarket.Data storage perpsMarketData = PerpsMarket.load(order.request.marketId);</span>
 377 |     | <span class='neutral'></span>
 378 | *   | <span class='executed'>        PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(</span>
 379 | *   | <span class='executed'>            order.request.marketId</span>
 380 |     | <span class='neutral'>        );</span>
 381 |     | <span class='neutral'></span>
 382 | *   | <span class='executed'>        fillPrice = calculateFillPrice(</span>
 383 | *   | <span class='executed'>            perpsMarketData.skew,</span>
 384 | *   | <span class='executed'>            marketConfig.skewScale,</span>
 385 | *   | <span class='executed'>            order.request.sizeDelta,</span>
 386 | *   | <span class='executed'>            orderPrice</span>
 387 |     | <span class='neutral'>        );</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>        // check if fill price exceeded acceptable price</span>
 390 | *   | <span class='executed'>        if (!acceptablePriceExceeded(order, fillPrice)) {</span>
 391 | *   | <span class='executed'>            revert AcceptablePriceNotExceeded(fillPrice, order.request.acceptablePrice);</span>
 392 |     | <span class='neutral'>        }</span>
 393 |     | <span class='neutral'>    }</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    /**</span>
 396 |     | <span class='neutral'>     * @notice Calculates the settlement rewards.</span>
 397 |     | <span class='neutral'>     */</span>
 398 | *   | <span class='executed'>    function settlementRewardCost(</span>
 399 |     | <span class='neutral'>        SettlementStrategy.Data storage strategy</span>
 400 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 401 | *   | <span class='executed'>        return KeeperCosts.load().getSettlementKeeperCosts() + strategy.settlementReward;</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    /**</span>
 405 |     | <span class='neutral'>     * @notice Calculates the order fees.</span>
 406 |     | <span class='neutral'>     */</span>
 407 | *   | <span class='executed'>    function calculateOrderFee(</span>
 408 |     | <span class='neutral'>        int128 sizeDelta,</span>
 409 |     | <span class='neutral'>        uint256 fillPrice,</span>
 410 |     | <span class='neutral'>        int256 marketSkew,</span>
 411 |     | <span class='neutral'>        OrderFee.Data storage orderFeeData</span>
 412 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 413 | *   | <span class='executed'>        int256 notionalDiff = sizeDelta.mulDecimal(fillPrice.toInt());</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='neutral'>        // does this trade keep the skew on one side?</span>
 416 | *   | <span class='executed'>        if (MathUtil.sameSide(marketSkew + sizeDelta, marketSkew)) {</span>
 417 |     | <span class='neutral'>            // use a flat maker/taker fee for the entire size depending on whether the skew is increased or reduced.</span>
 418 |     | <span class='neutral'>            //</span>
 419 |     | <span class='neutral'>            // if the order is submitted on the same side as the skew (increasing it) - the taker fee is charged.</span>
 420 |     | <span class='neutral'>            // otherwise if the order is opposite to the skew, the maker fee is charged.</span>
 421 |     | <span class='neutral'></span>
 422 | *   | <span class='executed'>            uint256 staticRate = MathUtil.sameSide(notionalDiff, marketSkew)</span>
 423 | *   | <span class='executed'>                ? orderFeeData.takerFee</span>
 424 | *   | <span class='executed'>                : orderFeeData.makerFee;</span>
 425 | *   | <span class='executed'>            return MathUtil.abs(notionalDiff.mulDecimal(staticRate.toInt()));</span>
 426 |     | <span class='neutral'>        }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>        // this trade flips the skew.</span>
 429 |     | <span class='neutral'>        //</span>
 430 |     | <span class='neutral'>        // the proportion of size that moves in the direction after the flip should not be considered</span>
 431 |     | <span class='neutral'>        // as a maker (reducing skew) as it&#39;s now taking (increasing skew) in the opposite direction. hence,</span>
 432 |     | <span class='neutral'>        // a different fee is applied on the proportion increasing the skew.</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>        // The proportions are computed as follows:</span>
 435 |     | <span class='neutral'>        // makerSize = abs(marketSkew) =&gt; since we are reversing the skew, the maker size is the current skew</span>
 436 |     | <span class='neutral'>        // takerSize = abs(marketSkew + sizeDelta) =&gt; since we are reversing the skew, the taker size is the new skew</span>
 437 |     | <span class='neutral'>        //</span>
 438 |     | <span class='neutral'>        // we then multiply the sizes by the fill price to get the notional value of each side, and that times the fee rate for each side</span>
 439 |     | <span class='neutral'></span>
 440 | *   | <span class='executed'>        uint256 makerFee = MathUtil.abs(marketSkew).mulDecimal(fillPrice).mulDecimal(</span>
 441 | *   | <span class='executed'>            orderFeeData.makerFee</span>
 442 |     | <span class='neutral'>        );</span>
 443 |     | <span class='neutral'></span>
 444 | *   | <span class='executed'>        uint256 takerFee = MathUtil.abs(marketSkew + sizeDelta).mulDecimal(fillPrice).mulDecimal(</span>
 445 | *   | <span class='executed'>            orderFeeData.takerFee</span>
 446 |     | <span class='neutral'>        );</span>
 447 |     | <span class='neutral'></span>
 448 | *   | <span class='executed'>        return takerFee + makerFee;</span>
 449 |     | <span class='neutral'>    }</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='neutral'>    /**</span>
 452 |     | <span class='neutral'>     * @notice Calculates the fill price for an order.</span>
 453 |     | <span class='neutral'>     */</span>
 454 | *   | <span class='executed'>    function calculateFillPrice(</span>
 455 |     | <span class='neutral'>        int256 skew,</span>
 456 |     | <span class='neutral'>        uint256 skewScale,</span>
 457 |     | <span class='neutral'>        int128 size,</span>
 458 |     | <span class='neutral'>        uint256 price</span>
 459 | *   | <span class='executed'>    ) internal pure returns (uint256) {</span>
 460 |     | <span class='neutral'>        // How is the p/d-adjusted price calculated using an example:</span>
 461 |     | <span class='neutral'>        //</span>
 462 |     | <span class='neutral'>        // price      = $1200 USD (oracle)</span>
 463 |     | <span class='neutral'>        // size       = 100</span>
 464 |     | <span class='neutral'>        // skew       = 0</span>
 465 |     | <span class='neutral'>        // skew_scale = 1,000,000 (1M)</span>
 466 |     | <span class='neutral'>        //</span>
 467 |     | <span class='neutral'>        // Then,</span>
 468 |     | <span class='neutral'>        //</span>
 469 |     | <span class='neutral'>        // pd_before = 0 / 1,000,000</span>
 470 |     | <span class='neutral'>        //           = 0</span>
 471 |     | <span class='neutral'>        // pd_after  = (0 + 100) / 1,000,000</span>
 472 |     | <span class='neutral'>        //           = 100 / 1,000,000</span>
 473 |     | <span class='neutral'>        //           = 0.0001</span>
 474 |     | <span class='neutral'>        //</span>
 475 |     | <span class='neutral'>        // price_before = 1200 * (1 + pd_before)</span>
 476 |     | <span class='neutral'>        //              = 1200 * (1 + 0)</span>
 477 |     | <span class='neutral'>        //              = 1200</span>
 478 |     | <span class='neutral'>        // price_after  = 1200 * (1 + pd_after)</span>
 479 |     | <span class='neutral'>        //              = 1200 * (1 + 0.0001)</span>
 480 |     | <span class='neutral'>        //              = 1200 * (1.0001)</span>
 481 |     | <span class='neutral'>        //              = 1200.12</span>
 482 |     | <span class='neutral'>        // Finally,</span>
 483 |     | <span class='neutral'>        //</span>
 484 |     | <span class='neutral'>        // fill_price = (price_before + price_after) / 2</span>
 485 |     | <span class='neutral'>        //            = (1200 + 1200.12) / 2</span>
 486 |     | <span class='neutral'>        //            = 1200.06</span>
 487 | *   | <span class='executed'>        if (skewScale == 0) {</span>
 488 |     | <span class='unexecuted'>            return price;</span>
 489 |     | <span class='neutral'>        }</span>
 490 |     | <span class='neutral'>        // calculate pd (premium/discount) before and after trade</span>
 491 | *   | <span class='executed'>        int256 pdBefore = skew.divDecimal(skewScale.toInt());</span>
 492 | *   | <span class='executed'>        int256 newSkew = skew + size;</span>
 493 | *   | <span class='executed'>        int256 pdAfter = newSkew.divDecimal(skewScale.toInt());</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>        // calculate price before and after trade with pd applied</span>
 496 | *   | <span class='executed'>        int256 priceBefore = price.toInt() + (price.toInt().mulDecimal(pdBefore));</span>
 497 | *   | <span class='executed'>        int256 priceAfter = price.toInt() + (price.toInt().mulDecimal(pdAfter));</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>        // the fill price is the average of those prices</span>
 500 | *   | <span class='executed'>        return (priceBefore + priceAfter).toUint().divDecimal(DecimalMath.UNIT * 2);</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>    struct RequiredMarginWithNewPositionRuntime {</span>
 504 |     | <span class='neutral'>        uint256 newRequiredMargin;</span>
 505 |     | <span class='neutral'>        uint256 oldRequiredMargin;</span>
 506 |     | <span class='neutral'>        uint256 requiredMarginForNewPosition;</span>
 507 |     | <span class='neutral'>        uint256 accumulatedLiquidationRewards;</span>
 508 |     | <span class='neutral'>        uint256 maxNumberOfWindows;</span>
 509 |     | <span class='neutral'>        uint256 numberOfWindows;</span>
 510 |     | <span class='neutral'>        uint256 requiredRewardMargin;</span>
 511 |     | <span class='neutral'>    }</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='neutral'>    /**</span>
 514 |     | <span class='neutral'>     * @notice Initial pnl of a position after it&#39;s opened due to p/d fill price delta.</span>
 515 |     | <span class='neutral'>     */</span>
 516 | *   | <span class='executed'>    function calculateStartingPnl(</span>
 517 |     | <span class='neutral'>        uint256 fillPrice,</span>
 518 |     | <span class='neutral'>        uint256 marketPrice,</span>
 519 |     | <span class='neutral'>        int128 size</span>
 520 | *   | <span class='executed'>    ) internal pure returns (int256) {</span>
 521 | *   | <span class='executed'>        return size.mulDecimal(marketPrice.toInt() - fillPrice.toInt());</span>
 522 |     | <span class='neutral'>    }</span>
 523 |     | <span class='neutral'></span>
 524 |     | <span class='neutral'>    /**</span>
 525 |     | <span class='neutral'>     * @notice After the required margins are calculated with the old position, this function replaces the</span>
 526 |     | <span class='neutral'>     * old position initial margin with the new position initial margin requirements and returns them.</span>
 527 |     | <span class='neutral'>     * @dev SIP-359: If the position is being reduced, required margin is 0.</span>
 528 |     | <span class='neutral'>     */</span>
 529 | *   | <span class='executed'>    function getRequiredMarginWithNewPosition(</span>
 530 |     | <span class='neutral'>        PerpsAccount.Data storage account,</span>
 531 |     | <span class='neutral'>        PerpsMarketConfiguration.Data storage marketConfig,</span>
 532 |     | <span class='neutral'>        uint128 marketId,</span>
 533 |     | <span class='neutral'>        int128 oldPositionSize,</span>
 534 |     | <span class='neutral'>        int128 newPositionSize,</span>
 535 |     | <span class='neutral'>        uint256 fillPrice,</span>
 536 |     | <span class='neutral'>        uint256 currentTotalInitialMargin</span>
 537 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 538 | *   | <span class='executed'>        RequiredMarginWithNewPositionRuntime memory runtime;</span>
 539 |     | <span class='neutral'></span>
 540 | *   | <span class='executed'>        if (MathUtil.isSameSideReducing(oldPositionSize, newPositionSize)) {</span>
 541 | *   | <span class='executed'>            return 0;</span>
 542 |     | <span class='neutral'>        }</span>
 543 |     | <span class='neutral'></span>
 544 |     | <span class='neutral'>        // get initial margin requirement for the new position</span>
 545 | *   | <span class='executed'>        (, , runtime.newRequiredMargin, ) = marketConfig.calculateRequiredMargins(</span>
 546 | *   | <span class='executed'>            newPositionSize,</span>
 547 | *   | <span class='executed'>            fillPrice</span>
 548 |     | <span class='neutral'>        );</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='neutral'>        // get initial margin of old position</span>
 551 | *   | <span class='executed'>        (, , runtime.oldRequiredMargin, ) = marketConfig.calculateRequiredMargins(</span>
 552 | *   | <span class='executed'>            oldPositionSize,</span>
 553 | *   | <span class='executed'>            PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)</span>
 554 |     | <span class='neutral'>        );</span>
 555 |     | <span class='neutral'></span>
 556 |     | <span class='neutral'>        // remove the old initial margin and add the new initial margin requirement</span>
 557 |     | <span class='neutral'>        // this gets us our total required margin for new position</span>
 558 | *   | <span class='executed'>        runtime.requiredMarginForNewPosition =</span>
 559 | *   | <span class='executed'>            currentTotalInitialMargin +</span>
 560 | *   | <span class='executed'>            runtime.newRequiredMargin -</span>
 561 |     | <span class='neutral'>            runtime.oldRequiredMargin;</span>
 562 |     | <span class='neutral'></span>
 563 | *   | <span class='executed'>        (runtime.accumulatedLiquidationRewards, runtime.maxNumberOfWindows) = account</span>
 564 | *   | <span class='executed'>            .getKeeperRewardsAndCosts(marketId);</span>
 565 | *   | <span class='executed'>        runtime.accumulatedLiquidationRewards += marketConfig.calculateFlagReward(</span>
 566 | *   | <span class='executed'>            MathUtil.abs(newPositionSize).mulDecimal(fillPrice)</span>
 567 |     | <span class='neutral'>        );</span>
 568 | *   | <span class='executed'>        runtime.numberOfWindows = marketConfig.numberOfLiquidationWindows(</span>
 569 | *   | <span class='executed'>            MathUtil.abs(newPositionSize)</span>
 570 |     | <span class='neutral'>        );</span>
 571 | *   | <span class='executed'>        runtime.maxNumberOfWindows = MathUtil.max(</span>
 572 |     | <span class='neutral'>            runtime.numberOfWindows,</span>
 573 | *   | <span class='executed'>            runtime.maxNumberOfWindows</span>
 574 |     | <span class='neutral'>        );</span>
 575 |     | <span class='neutral'></span>
 576 | *   | <span class='executed'>        runtime.requiredRewardMargin = account.getPossibleLiquidationReward(</span>
 577 | *   | <span class='executed'>            runtime.accumulatedLiquidationRewards,</span>
 578 |     | <span class='neutral'>            runtime.maxNumberOfWindows</span>
 579 |     | <span class='neutral'>        );</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='neutral'>        // this is the required margin for the new position (minus any order fees)</span>
 582 | *   | <span class='executed'>        return runtime.requiredMarginForNewPosition + runtime.requiredRewardMargin;</span>
 583 |     | <span class='neutral'>    }</span>
 584 |     | <span class='neutral'></span>
 585 | *   | <span class='executed'>    function validateAcceptablePrice(Data storage order, uint256 fillPrice) internal view {</span>
 586 | *   | <span class='executed'>        if (acceptablePriceExceeded(order, fillPrice)) {</span>
 587 | *   | <span class='executed'>            revert AcceptablePriceExceeded(fillPrice, order.request.acceptablePrice);</span>
 588 |     | <span class='neutral'>        }</span>
 589 |     | <span class='neutral'>    }</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='neutral'>    /**</span>
 592 |     | <span class='neutral'>     * @notice Checks if the fill price exceeds the acceptable price set at submission.</span>
 593 |     | <span class='neutral'>     */</span>
 594 | *   | <span class='executed'>    function acceptablePriceExceeded(</span>
 595 |     | <span class='neutral'>        Data storage order,</span>
 596 |     | <span class='neutral'>        uint256 fillPrice</span>
 597 | *   | <span class='executed'>    ) internal view returns (bool exceeded) {</span>
 598 |     | <span class='neutral'>        return</span>
 599 | *   | <span class='executed'>            (order.request.sizeDelta &gt; 0 &amp;&amp; fillPrice &gt; order.request.acceptablePrice) ||</span>
 600 | *   | <span class='executed'>            (order.request.sizeDelta &lt; 0 &amp;&amp; fillPrice &lt; order.request.acceptablePrice);</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'>}</span>
 603 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/GlobalPerpsMarket.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ISpotMarketSystem} from &quot;../interfaces/external/ISpotMarketSystem.sol&quot;;</span>
   5 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
   8 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;./GlobalPerpsMarketConfiguration.sol&quot;;</span>
   9 |     | <span class='neutral'>import {SafeCastU256, SafeCastI256, SafeCastU128} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsAccount, SNX_USD_MARKET_ID} from &quot;./PerpsAccount.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsMarket} from &quot;./PerpsMarket.sol&quot;;</span>
  12 |     | <span class='neutral'>import {PerpsPrice} from &quot;./PerpsPrice.sol&quot;;</span>
  13 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;./PerpsMarketFactory.sol&quot;;</span>
  14 |     | <span class='neutral'>import {PerpsCollateralConfiguration} from &quot;./PerpsCollateralConfiguration.sol&quot;;</span>
  15 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  16 |     | <span class='neutral'>/**</span>
  17 |     | <span class='neutral'> * @title This library contains all global perps market data</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library GlobalPerpsMarket {</span>
  20 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  21 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  22 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  23 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  24 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  25 |     | <span class='neutral'>    using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET =</span>
  28 | *   | <span class='executed'>        keccak256(abi.encode(&quot;io.synthetix.perps-market.GlobalPerpsMarket&quot;));</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @notice Thrown when attempting to deposit more than enabled collateral.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    error MaxCollateralExceeded(</span>
  34 |     | <span class='neutral'>        uint128 collateralId,</span>
  35 |     | <span class='neutral'>        uint256 maxAmount,</span>
  36 |     | <span class='neutral'>        uint256 collateralAmount,</span>
  37 |     | <span class='neutral'>        uint256 depositAmount</span>
  38 |     | <span class='neutral'>    );</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @notice Thrown when attempting to use a synth that is not enabled as collateral.</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    error SynthNotEnabledForCollateral(uint128 collateralId);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @notice Thrown when attempting to withdraw more collateral than is available.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    error InsufficientCollateral(</span>
  49 |     | <span class='neutral'>        uint128 collateralId,</span>
  50 |     | <span class='neutral'>        uint256 collateralAmount,</span>
  51 |     | <span class='neutral'>        uint256 withdrawAmount</span>
  52 |     | <span class='neutral'>    );</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    struct Data {</span>
  55 |     | <span class='neutral'>        /**</span>
  56 |     | <span class='neutral'>         * @dev Set of liquidatable account ids.</span>
  57 |     | <span class='neutral'>         */</span>
  58 |     | <span class='neutral'>        SetUtil.UintSet liquidatableAccounts;</span>
  59 |     | <span class='neutral'>        /**</span>
  60 |     | <span class='neutral'>         * @dev Collateral amounts running total, by collateral synth market id.</span>
  61 |     | <span class='neutral'>         */</span>
  62 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) collateralAmounts;</span>
  63 |     | <span class='neutral'>        SetUtil.UintSet activeCollateralTypes;</span>
  64 |     | <span class='neutral'>        SetUtil.UintSet activeMarkets;</span>
  65 |     | <span class='neutral'>        /**</span>
  66 |     | <span class='neutral'>         * @dev Total debt that hasn&#39;t been paid across all accounts.</span>
  67 |     | <span class='neutral'>         */</span>
  68 |     | <span class='neutral'>        uint256 totalAccountsDebt;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>    function load() internal pure returns (Data storage marketData) {</span>
  72 | *   | <span class='executed'>        bytes32 s = _SLOT_GLOBAL_PERPS_MARKET;</span>
  73 |     | <span class='neutral'>        assembly {</span>
  74 |     | <span class='neutral'>            marketData.slot := s</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 | *   | <span class='executed'>    function utilizationRate(</span>
  79 |     | <span class='neutral'>        Data storage self,</span>
  80 |     | <span class='neutral'>        PerpsPrice.Tolerance minCreditPriceTolerance</span>
  81 | *   | <span class='executed'>    ) internal view returns (uint128 rate, uint256 delegatedCollateralValue, uint256 lockedCredit) {</span>
  82 | *   | <span class='executed'>        console2.log(&quot;===== GlobalPerpsMarket::utilizationRate START =====&quot;);</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        uint256 withdrawableUsd = PerpsMarketFactory.totalWithdrawableUsd();</span>
  85 | *   | <span class='executed'>        console2.log(&quot;withdrawableUsd&quot;, withdrawableUsd);</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>        int256 delegatedCollateralValueInt = withdrawableUsd.toInt() -</span>
  88 | *   | <span class='executed'>            totalCollateralValue(self).toInt();</span>
  89 | *   | <span class='executed'>        console2.log(&quot;delegatedCollateralValueInt&quot;, delegatedCollateralValueInt);</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>        lockedCredit = minimumCredit(self, minCreditPriceTolerance);</span>
  92 | *   | <span class='executed'>        console2.log(&quot;lockedCredit&quot;, lockedCredit);</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        if (delegatedCollateralValueInt &lt;= 0) {</span>
  95 | *   | <span class='executed'>            console2.log(&quot;delegatedCollateralValueInt &lt;= 0, returning UNIT_UINT128&quot;);</span>
  96 | *   | <span class='executed'>            console2.log(&quot;rate&quot;, DecimalMath.UNIT_UINT128);</span>
  97 |     | <span class='neutral'></span>
  98 | *   | <span class='executed'>            console2.log(&quot;lockedCredit&quot;, lockedCredit);</span>
  99 | *   | <span class='executed'>            console2.log(&quot;===== utilizationRate END =====&quot;);</span>
 100 | *   | <span class='executed'>            return (DecimalMath.UNIT_UINT128, 0, lockedCredit);</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>        delegatedCollateralValue = delegatedCollateralValueInt.toUint();</span>
 104 | *   | <span class='executed'>        console2.log(&quot;delegatedCollateralValue&quot;, delegatedCollateralValue);</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>        rate = lockedCredit.divDecimal(delegatedCollateralValue).to128();</span>
 107 | *   | <span class='executed'>        console2.log(&quot;rate&quot;, rate);</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>        console2.log(&quot;===== GlobalPerpsMarket::utilizationRate END =====&quot;);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>    function minimumCredit(</span>
 113 |     | <span class='neutral'>        Data storage self,</span>
 114 |     | <span class='neutral'>        PerpsPrice.Tolerance priceTolerance</span>
 115 | *   | <span class='executed'>    ) internal view returns (uint256 accumulatedMinimumCredit) {</span>
 116 | *   | <span class='executed'>        console2.log(&quot;===== GlobalPerpsMarket::minimumCredit START =====&quot;);</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>        uint256 activeMarketsLength = self.activeMarkets.length();</span>
 119 | *   | <span class='executed'>        console2.log(&quot;activeMarketsLength&quot;, activeMarketsLength);</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>        accumulatedMinimumCredit = 0;</span>
 122 | *   | <span class='executed'>        console2.log(&quot;Initial accumulatedMinimumCredit&quot;, accumulatedMinimumCredit);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= activeMarketsLength; i++) {</span>
 125 | *   | <span class='executed'>            uint128 marketId = self.activeMarkets.valueAt(i).to128();</span>
 126 | *   | <span class='executed'>            console2.log(&quot;Loop iteration&quot;, i);</span>
 127 | *   | <span class='executed'>            console2.log(&quot;marketId&quot;, marketId);</span>
 128 |     | <span class='neutral'></span>
 129 | *   | <span class='executed'>            uint256 requiredCreditForMarket = PerpsMarket.requiredCredit(marketId, priceTolerance);</span>
 130 | *   | <span class='executed'>            console2.log(&quot;requiredCreditForMarket&quot;, requiredCreditForMarket);</span>
 131 |     | <span class='neutral'></span>
 132 | *   | <span class='executed'>            accumulatedMinimumCredit += requiredCreditForMarket;</span>
 133 | *   | <span class='executed'>            console2.log(&quot;Updated accumulatedMinimumCredit&quot;, accumulatedMinimumCredit);</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>        uint256 sUSDCollateralValue = self.collateralAmounts[SNX_USD_MARKET_ID];</span>
 137 | *   | <span class='executed'>        console2.log(&quot;sUSDCollateralValue&quot;, sUSDCollateralValue);</span>
 138 |     | <span class='neutral'></span>
 139 | *   | <span class='executed'>        accumulatedMinimumCredit += sUSDCollateralValue;</span>
 140 | *   | <span class='executed'>        console2.log(&quot;Final accumulatedMinimumCredit&quot;, accumulatedMinimumCredit);</span>
 141 |     | <span class='neutral'></span>
 142 | *   | <span class='executed'>        console2.log(&quot;===== GlobalPerpsMarket::minimumCredit END =====&quot;);</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>    function totalCollateralValue(Data storage self) internal view returns (uint256 total) {</span>
 146 | *   | <span class='executed'>        ISpotMarketSystem spotMarket = PerpsMarketFactory.load().spotMarket;</span>
 147 | *   | <span class='executed'>        SetUtil.UintSet storage activeCollateralTypes = self.activeCollateralTypes;</span>
 148 | *   | <span class='executed'>        uint256 activeCollateralLength = activeCollateralTypes.length();</span>
 149 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= activeCollateralLength; i++) {</span>
 150 | *   | <span class='executed'>            uint128 collateralId = activeCollateralTypes.valueAt(i).to128();</span>
 151 |     | <span class='neutral'></span>
 152 | *   | <span class='executed'>            if (collateralId == SNX_USD_MARKET_ID) {</span>
 153 | *   | <span class='executed'>                total += self.collateralAmounts[collateralId];</span>
 154 | *   | <span class='executed'>            } else {</span>
 155 | *   | <span class='executed'>                (uint256 collateralValue, ) = PerpsCollateralConfiguration</span>
 156 |     | <span class='neutral'>                    .load(collateralId)</span>
 157 |     | <span class='neutral'>                    .valueInUsd(</span>
 158 | *   | <span class='executed'>                        self.collateralAmounts[collateralId],</span>
 159 | *   | <span class='executed'>                        spotMarket,</span>
 160 |     | <span class='neutral'>                        PerpsPrice.Tolerance.DEFAULT,</span>
 161 |     | <span class='neutral'>                        false</span>
 162 |     | <span class='neutral'>                    );</span>
 163 | *   | <span class='executed'>                total += collateralValue;</span>
 164 |     | <span class='neutral'>            }</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 | *   | <span class='executed'>    function updateCollateralAmount(</span>
 169 |     | <span class='neutral'>        Data storage self,</span>
 170 |     | <span class='neutral'>        uint128 collateralId,</span>
 171 |     | <span class='neutral'>        int256 amountDelta</span>
 172 | *   | <span class='executed'>    ) internal returns (uint256 collateralAmount) {</span>
 173 | *   | <span class='executed'>        collateralAmount = (self.collateralAmounts[collateralId].toInt() + amountDelta).toUint();</span>
 174 | *   | <span class='executed'>        self.collateralAmounts[collateralId] = collateralAmount;</span>
 175 |     | <span class='neutral'></span>
 176 | *   | <span class='executed'>        bool isActiveCollateral = self.activeCollateralTypes.contains(collateralId);</span>
 177 | *   | <span class='executed'>        if (collateralAmount &gt; 0 &amp;&amp; !isActiveCollateral) {</span>
 178 | *   | <span class='executed'>            self.activeCollateralTypes.add(collateralId.to256());</span>
 179 | *   | <span class='executed'>        } else if (collateralAmount == 0 &amp;&amp; isActiveCollateral) {</span>
 180 | *   | <span class='executed'>            self.activeCollateralTypes.remove(collateralId.to256());</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 | *   | <span class='executed'>    function updateDebt(Data storage self, int256 debtDelta) internal {</span>
 185 | *   | <span class='executed'>        int256 newTotalAccountsDebt = self.totalAccountsDebt.toInt() + debtDelta;</span>
 186 | *   | <span class='executed'>        self.totalAccountsDebt = newTotalAccountsDebt &lt; 0 ? 0 : newTotalAccountsDebt.toUint();</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @notice Check if the account is set as liquidatable.</span>
 191 |     | <span class='neutral'>     */</span>
 192 | *   | <span class='executed'>    function checkLiquidation(Data storage self, uint128 accountId) internal view {</span>
 193 | *   | <span class='executed'>        if (self.liquidatableAccounts.contains(accountId)) {</span>
 194 | *   | <span class='executed'>            revert PerpsAccount.AccountLiquidatable(accountId);</span>
 195 |     | <span class='neutral'>        }</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    /**</span>
 199 |     | <span class='neutral'>     * @notice Check the collateral is enabled and amount acceptable and adjusts accounting.</span>
 200 |     | <span class='neutral'>     * @dev called when the account is modifying collateral.</span>
 201 |     | <span class='neutral'>     * @dev 1. checks to ensure max cap isn&#39;t hit</span>
 202 |     | <span class='neutral'>     * @dev 2. adjusts accounting for collateral amounts</span>
 203 |     | <span class='neutral'>     */</span>
 204 | *   | <span class='executed'>    function validateCollateralAmount(</span>
 205 |     | <span class='neutral'>        Data storage self,</span>
 206 |     | <span class='neutral'>        uint128 collateralId,</span>
 207 |     | <span class='neutral'>        int256 synthAmount</span>
 208 | *   | <span class='executed'>    ) internal view {</span>
 209 | *   | <span class='executed'>        uint256 collateralAmount = self.collateralAmounts[collateralId];</span>
 210 | *   | <span class='executed'>        if (synthAmount &gt; 0) {</span>
 211 | *   | <span class='executed'>            uint256 maxAmount = PerpsCollateralConfiguration.load(collateralId).maxAmount;</span>
 212 | *   | <span class='executed'>            if (maxAmount == 0) {</span>
 213 |     | <span class='unexecuted'>                revert SynthNotEnabledForCollateral(collateralId);</span>
 214 |     | <span class='neutral'>            }</span>
 215 | *   | <span class='executed'>            uint256 newCollateralAmount = collateralAmount + synthAmount.toUint();</span>
 216 | *   | <span class='executed'>            if (newCollateralAmount &gt; maxAmount) {</span>
 217 |     | <span class='unexecuted'>                revert MaxCollateralExceeded(</span>
 218 |     | <span class='unexecuted'>                    collateralId,</span>
 219 |     | <span class='unexecuted'>                    maxAmount,</span>
 220 |     | <span class='unexecuted'>                    collateralAmount,</span>
 221 |     | <span class='unexecuted'>                    synthAmount.toUint()</span>
 222 |     | <span class='neutral'>                );</span>
 223 |     | <span class='neutral'>            }</span>
 224 | *   | <span class='executed'>        } else {</span>
 225 | *   | <span class='executed'>            uint256 synthAmountAbs = MathUtil.abs(synthAmount);</span>
 226 | *   | <span class='executed'>            if (collateralAmount &lt; synthAmountAbs) {</span>
 227 | *   | <span class='executed'>                revert InsufficientCollateral(collateralId, collateralAmount, synthAmountAbs);</span>
 228 |     | <span class='neutral'>            }</span>
 229 |     | <span class='neutral'>        }</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>    function addMarket(Data storage self, uint128 marketId) internal {</span>
 233 |     | <span class='unexecuted'>        self.activeMarkets.add(marketId.to256());</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'>}</span>
 236 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/GlobalPerpsMarketConfiguration.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SafeCastU128} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   7 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IFeeCollector} from &quot;../interfaces/external/IFeeCollector.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;./PerpsMarketFactory.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsCollateralConfiguration} from &quot;./PerpsCollateralConfiguration.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/**</span>
  14 |     | <span class='neutral'> * @title This library contains all global perps market configuration data</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='unexecuted'>library GlobalPerpsMarketConfiguration {</span>
  17 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  18 |     | <span class='neutral'>    using PerpsMarketFactory for PerpsMarketFactory.Data;</span>
  19 |     | <span class='neutral'>    using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;</span>
  20 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  21 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION =</span>
  24 | *   | <span class='executed'>        keccak256(abi.encode(&quot;io.synthetix.perps-market.GlobalPerpsMarketConfiguration&quot;));</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    struct Data {</span>
  27 |     | <span class='neutral'>        /**</span>
  28 |     | <span class='neutral'>         * @dev fee collector contract</span>
  29 |     | <span class='neutral'>         * @dev portion or all of the order fees are sent to fee collector contract based on quote.</span>
  30 |     | <span class='neutral'>         */</span>
  31 |     | <span class='neutral'>        IFeeCollector feeCollector;</span>
  32 |     | <span class='neutral'>        /**</span>
  33 |     | <span class='neutral'>         * @dev Percentage share of fees for each referrer address</span>
  34 |     | <span class='neutral'>         */</span>
  35 |     | <span class='neutral'>        mapping(address =&gt; uint256) referrerShare;</span>
  36 |     | <span class='neutral'>        /**</span>
  37 |     | <span class='neutral'>         * @dev previously maxCollateralAmounts[collateralId] was used in storage slot</span>
  38 |     | <span class='neutral'>         */</span>
  39 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
  40 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) __unused_1;</span>
  41 |     | <span class='neutral'>        /**</span>
  42 |     | <span class='neutral'>         * @dev previously synth deduction priority</span>
  43 |     | <span class='neutral'>         */</span>
  44 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
  45 |     | <span class='neutral'>        uint128[] __unused_2;</span>
  46 |     | <span class='neutral'>        /**</span>
  47 |     | <span class='neutral'>         * @dev minimum configured keeper reward for the sender who liquidates the account</span>
  48 |     | <span class='neutral'>         */</span>
  49 |     | <span class='neutral'>        uint256 minKeeperRewardUsd;</span>
  50 |     | <span class='neutral'>        /**</span>
  51 |     | <span class='neutral'>         * @dev maximum configured keeper reward for the sender who liquidates the account</span>
  52 |     | <span class='neutral'>         */</span>
  53 |     | <span class='neutral'>        uint256 maxKeeperRewardUsd;</span>
  54 |     | <span class='neutral'>        /**</span>
  55 |     | <span class='neutral'>         * @dev maximum configured number of concurrent positions per account.</span>
  56 |     | <span class='neutral'>         * @notice If set to zero it means no new positions can be opened, but existing positions can be increased or decreased.</span>
  57 |     | <span class='neutral'>         * @notice If set to a larger number (larger than number of markets created) it means is unlimited.</span>
  58 |     | <span class='neutral'>         */</span>
  59 |     | <span class='neutral'>        uint128 maxPositionsPerAccount;</span>
  60 |     | <span class='neutral'>        /**</span>
  61 |     | <span class='neutral'>         * @dev maximum configured number of concurrent collaterals per account.</span>
  62 |     | <span class='neutral'>         * @notice If set to zero it means no new collaterals can be added accounts, but existing collaterals can be increased or decreased.</span>
  63 |     | <span class='neutral'>         * @notice If set to a larger number (larger than number of collaterals enabled) it means is unlimited.</span>
  64 |     | <span class='neutral'>         */</span>
  65 |     | <span class='neutral'>        uint128 maxCollateralsPerAccount;</span>
  66 |     | <span class='neutral'>        /**</span>
  67 |     | <span class='neutral'>         * @dev used together with minKeeperRewardUsd to get the minumum keeper reward for the sender who settles, or liquidates the account</span>
  68 |     | <span class='neutral'>         */</span>
  69 |     | <span class='neutral'>        uint256 minKeeperProfitRatioD18;</span>
  70 |     | <span class='neutral'>        /**</span>
  71 |     | <span class='neutral'>         * @dev used together with maxKeeperRewardUsd to get the maximum keeper reward for the sender who settles, or liquidates the account</span>
  72 |     | <span class='neutral'>         */</span>
  73 |     | <span class='neutral'>        uint256 maxKeeperScalingRatioD18;</span>
  74 |     | <span class='neutral'>        /**</span>
  75 |     | <span class='neutral'>         * @dev set of supported collateral types. By supported we mean collateral types that have a maxCollateralAmount &gt; 0</span>
  76 |     | <span class='neutral'>         */</span>
  77 |     | <span class='neutral'>        SetUtil.UintSet supportedCollateralTypes;</span>
  78 |     | <span class='neutral'>        /**</span>
  79 |     | <span class='neutral'>         * @dev interest rate gradient applied to utilization prior to hitting the gradient breakpoint</span>
  80 |     | <span class='neutral'>         */</span>
  81 |     | <span class='neutral'>        uint128 lowUtilizationInterestRateGradient;</span>
  82 |     | <span class='neutral'>        /**</span>
  83 |     | <span class='neutral'>         * @dev breakpoint at which the interest rate gradient changes from low to high</span>
  84 |     | <span class='neutral'>         */</span>
  85 |     | <span class='neutral'>        uint128 interestRateGradientBreakpoint;</span>
  86 |     | <span class='neutral'>        /**</span>
  87 |     | <span class='neutral'>         * @dev interest rate gradient applied to utilization after hitting the gradient breakpoint</span>
  88 |     | <span class='neutral'>         */</span>
  89 |     | <span class='neutral'>        uint128 highUtilizationInterestRateGradient;</span>
  90 |     | <span class='neutral'>        /**</span>
  91 |     | <span class='neutral'>         * @dev ratio of the collateral liquidation reward. 1e18 is 100%.</span>
  92 |     | <span class='neutral'>         */</span>
  93 |     | <span class='neutral'>        uint128 collateralLiquidateRewardRatioD18;</span>
  94 |     | <span class='neutral'>        /**</span>
  95 |     | <span class='neutral'>         * @dev reward distributor implementation. This is used as a base to be cloned to distribute rewards to the liquidator.</span>
  96 |     | <span class='neutral'>         */</span>
  97 |     | <span class='neutral'>        address rewardDistributorImplementation;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 | *   | <span class='executed'>    function load() internal pure returns (Data storage globalMarketConfig) {</span>
 101 | *   | <span class='executed'>        bytes32 s = _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION;</span>
 102 |     | <span class='neutral'>        assembly {</span>
 103 |     | <span class='neutral'>            globalMarketConfig.slot := s</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>    function loadInterestRateParameters() internal view returns (uint128, uint128, uint128) {</span>
 108 | *   | <span class='executed'>        Data storage self = load();</span>
 109 |     | <span class='neutral'>        return (</span>
 110 | *   | <span class='executed'>            self.lowUtilizationInterestRateGradient,</span>
 111 | *   | <span class='executed'>            self.interestRateGradientBreakpoint,</span>
 112 | *   | <span class='executed'>            self.highUtilizationInterestRateGradient</span>
 113 |     | <span class='neutral'>        );</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>    function minimumKeeperRewardCap(</span>
 117 |     | <span class='neutral'>        Data storage self,</span>
 118 |     | <span class='neutral'>        uint256 costOfExecutionInUsd</span>
 119 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 120 |     | <span class='neutral'>        return</span>
 121 | *   | <span class='executed'>            MathUtil.max(</span>
 122 | *   | <span class='executed'>                costOfExecutionInUsd + self.minKeeperRewardUsd,</span>
 123 | *   | <span class='executed'>                costOfExecutionInUsd.mulDecimal(self.minKeeperProfitRatioD18 + DecimalMath.UNIT)</span>
 124 |     | <span class='neutral'>            );</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>    function maximumKeeperRewardCap(</span>
 128 |     | <span class='neutral'>        Data storage self,</span>
 129 |     | <span class='neutral'>        uint256 availableMarginInUsd</span>
 130 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 131 |     | <span class='neutral'>        // Note: if availableMarginInUsd is zero, it means the account was flagged, so the maximumKeeperRewardCap will just be maxKeeperRewardUsd</span>
 132 | *   | <span class='executed'>        if (availableMarginInUsd == 0) {</span>
 133 | *   | <span class='executed'>            return self.maxKeeperRewardUsd;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        return</span>
 137 | *   | <span class='executed'>            MathUtil.min(</span>
 138 | *   | <span class='executed'>                availableMarginInUsd.mulDecimal(self.maxKeeperScalingRatioD18),</span>
 139 | *   | <span class='executed'>                self.maxKeeperRewardUsd</span>
 140 |     | <span class='neutral'>            );</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @dev returns the keeper reward based on total keeper rewards from all markets compared against min/max</span>
 145 |     | <span class='neutral'>     */</span>
 146 | *   | <span class='executed'>    function keeperReward(</span>
 147 |     | <span class='neutral'>        Data storage self,</span>
 148 |     | <span class='neutral'>        uint256 keeperRewards,</span>
 149 |     | <span class='neutral'>        uint256 costOfExecutionInUsd,</span>
 150 |     | <span class='neutral'>        uint256 availableMarginInUsd</span>
 151 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 152 | *   | <span class='executed'>        uint256 minCap = minimumKeeperRewardCap(self, costOfExecutionInUsd);</span>
 153 | *   | <span class='executed'>        uint256 maxCap = maximumKeeperRewardCap(self, availableMarginInUsd);</span>
 154 | *   | <span class='executed'>        return MathUtil.min(MathUtil.max(minCap, keeperRewards + costOfExecutionInUsd), maxCap);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 | *   | <span class='executed'>    function collectFees(</span>
 158 |     | <span class='neutral'>        Data storage self,</span>
 159 |     | <span class='neutral'>        uint256 orderFees,</span>
 160 |     | <span class='neutral'>        address referrer,</span>
 161 |     | <span class='neutral'>        PerpsMarketFactory.Data storage factory</span>
 162 | *   | <span class='executed'>    ) internal returns (uint256 referralFees, uint256 feeCollectorFees) {</span>
 163 | *   | <span class='executed'>        referralFees = _collectReferrerFees(self, orderFees, referrer, factory);</span>
 164 | *   | <span class='executed'>        uint256 remainingFees = orderFees - referralFees;</span>
 165 |     | <span class='neutral'></span>
 166 | *   | <span class='executed'>        if (remainingFees == 0 || self.feeCollector == IFeeCollector(address(0))) {</span>
 167 | *   | <span class='executed'>            return (referralFees, 0);</span>
 168 |     | <span class='neutral'>        }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        uint256 feeCollectorQuote = self.feeCollector.quoteFees(</span>
 171 |     | <span class='unexecuted'>            factory.perpsMarketId,</span>
 172 |     | <span class='unexecuted'>            remainingFees,</span>
 173 |     | <span class='unexecuted'>            ERC2771Context._msgSender()</span>
 174 |     | <span class='neutral'>        );</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        if (feeCollectorQuote == 0) {</span>
 177 |     | <span class='unexecuted'>            return (referralFees, 0);</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>        if (feeCollectorQuote &gt; remainingFees) {</span>
 181 |     | <span class='unexecuted'>            feeCollectorQuote = remainingFees;</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>        factory.withdrawMarketUsd(address(self.feeCollector), feeCollectorQuote);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>        return (referralFees, feeCollectorQuote);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 | *   | <span class='executed'>    function calculateCollateralLiquidateReward(</span>
 190 |     | <span class='neutral'>        Data storage self,</span>
 191 |     | <span class='neutral'>        uint256 notionalValue</span>
 192 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 193 | *   | <span class='executed'>        return notionalValue.mulDecimal(self.collateralLiquidateRewardRatioD18);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>    function updateSupportedCollaterals(</span>
 197 |     | <span class='neutral'>        Data storage self,</span>
 198 |     | <span class='neutral'>        uint128 collateralId,</span>
 199 |     | <span class='neutral'>        uint256 maxCollateralAmount</span>
 200 |     | <span class='unexecuted'>    ) internal {</span>
 201 |     | <span class='unexecuted'>        bool isSupportedCollateral = self.supportedCollateralTypes.contains(collateralId);</span>
 202 |     | <span class='unexecuted'>        if (maxCollateralAmount &gt; 0 &amp;&amp; !isSupportedCollateral) {</span>
 203 |     | <span class='unexecuted'>            self.supportedCollateralTypes.add(collateralId.to256());</span>
 204 |     | <span class='unexecuted'>        } else if (maxCollateralAmount == 0 &amp;&amp; isSupportedCollateral) {</span>
 205 |     | <span class='unexecuted'>            self.supportedCollateralTypes.remove(collateralId.to256());</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 | *   | <span class='executed'>    function _collectReferrerFees(</span>
 210 |     | <span class='neutral'>        Data storage self,</span>
 211 |     | <span class='neutral'>        uint256 fees,</span>
 212 |     | <span class='neutral'>        address referrer,</span>
 213 |     | <span class='neutral'>        PerpsMarketFactory.Data storage factory</span>
 214 | *   | <span class='executed'>    ) private returns (uint256 referralFeesSent) {</span>
 215 | *   | <span class='executed'>        if (fees == 0 || referrer == address(0)) {</span>
 216 | *   | <span class='executed'>            return 0;</span>
 217 |     | <span class='neutral'>        }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>        uint256 referrerShareRatio = self.referrerShare[referrer];</span>
 220 |     | <span class='unexecuted'>        if (referrerShareRatio &gt; 0) {</span>
 221 |     | <span class='unexecuted'>            referralFeesSent = fees.mulDecimal(referrerShareRatio);</span>
 222 |     | <span class='unexecuted'>            factory.withdrawMarketUsd(referrer, referralFeesSent);</span>
 223 |     | <span class='neutral'>        }</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'>}</span>
 226 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/InterestRate.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {SafeCastU256, SafeCastU128, SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;./GlobalPerpsMarket.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Position} from &quot;./Position.sol&quot;;</span>
   8 |     | <span class='neutral'>import {PerpsPrice} from &quot;./PerpsPrice.sol&quot;;</span>
   9 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;../storage/GlobalPerpsMarketConfiguration.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library InterestRate {</span>
  12 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  13 |     | <span class='neutral'>    using DecimalMath for uint128;</span>
  14 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  15 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  16 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  17 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  18 |     | <span class='neutral'>    using Position for Position.Data;</span>
  19 |     | <span class='neutral'>    // 4 year average which includes leap</span>
  20 | *   | <span class='executed'>    uint256 private constant AVERAGE_SECONDS_PER_YEAR = 31557600;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    bytes32 private constant _SLOT_INTEREST_RATE =</span>
  23 | *   | <span class='executed'>        keccak256(abi.encode(&quot;io.synthetix.perps-market.InterestRate&quot;));</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct Data {</span>
  26 |     | <span class='neutral'>        uint256 interestAccrued; // per $1 of OI</span>
  27 |     | <span class='neutral'>        uint128 interestRate;</span>
  28 |     | <span class='neutral'>        uint256 lastTimestamp;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    function load() internal pure returns (Data storage interestRate) {</span>
  32 | *   | <span class='executed'>        bytes32 s = _SLOT_INTEREST_RATE;</span>
  33 |     | <span class='neutral'>        assembly {</span>
  34 |     | <span class='neutral'>            interestRate.slot := s</span>
  35 |     | <span class='neutral'>        }</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>    function update(</span>
  39 |     | <span class='neutral'>        PerpsPrice.Tolerance priceTolerance</span>
  40 | *   | <span class='executed'>    ) internal returns (uint128 newInterestRate, uint256 currentInterestAccrued) {</span>
  41 | *   | <span class='executed'>        Data storage self = load();</span>
  42 |     | <span class='neutral'></span>
  43 | *   | <span class='executed'>        (</span>
  44 | *   | <span class='executed'>            uint128 lowUtilizationInterestRateGradient,</span>
  45 | *   | <span class='executed'>            uint128 interestRateGradientBreakpoint,</span>
  46 | *   | <span class='executed'>            uint128 highUtilizationInterestRateGradient</span>
  47 | *   | <span class='executed'>        ) = GlobalPerpsMarketConfiguration.loadInterestRateParameters();</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // if no interest parameters are set, interest rate is 0 and the interest accrued stays the same</span>
  50 | *   | <span class='executed'>        if (</span>
  51 | *   | <span class='executed'>            lowUtilizationInterestRateGradient == 0 &amp;&amp;</span>
  52 | *   | <span class='executed'>            interestRateGradientBreakpoint == 0 &amp;&amp;</span>
  53 | *   | <span class='executed'>            highUtilizationInterestRateGradient == 0</span>
  54 |     | <span class='neutral'>        ) {</span>
  55 | *   | <span class='executed'>            self.interestRate = 0;</span>
  56 | *   | <span class='executed'>            return (0, self.interestAccrued);</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        (uint128 currentUtilizationRate, , ) = GlobalPerpsMarket.load().utilizationRate(</span>
  60 |     | <span class='unexecuted'>            priceTolerance</span>
  61 |     | <span class='neutral'>        );</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        self.interestAccrued = calculateNextInterest(self);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        self.interestRate = currentInterestRate(</span>
  66 |     | <span class='unexecuted'>            currentUtilizationRate,</span>
  67 |     | <span class='unexecuted'>            lowUtilizationInterestRateGradient,</span>
  68 |     | <span class='unexecuted'>            interestRateGradientBreakpoint,</span>
  69 |     | <span class='unexecuted'>            highUtilizationInterestRateGradient</span>
  70 |     | <span class='neutral'>        );</span>
  71 |     | <span class='unexecuted'>        self.lastTimestamp = block.timestamp;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        return (self.interestRate, self.interestAccrued);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 | *   | <span class='executed'>    function proportionalElapsed(Data storage self) internal view returns (uint128) {</span>
  77 |     | <span class='neutral'>        // even though timestamps here are not D18, divDecimal multiplies by 1e18 to preserve decimals into D18</span>
  78 | *   | <span class='executed'>        return (block.timestamp - self.lastTimestamp).divDecimal(AVERAGE_SECONDS_PER_YEAR).to128();</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>    function calculateNextInterest(Data storage self) internal view returns (uint256) {</span>
  82 | *   | <span class='executed'>        return self.interestAccrued + unrecordedInterest(self);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 | *   | <span class='executed'>    function unrecordedInterest(Data storage self) internal view returns (uint256) {</span>
  86 | *   | <span class='executed'>        return self.interestRate.mulDecimalUint128(proportionalElapsed(self)).to256();</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function currentInterestRate(</span>
  90 |     | <span class='neutral'>        uint128 currentUtilizationRate,</span>
  91 |     | <span class='neutral'>        uint128 lowUtilizationInterestRateGradient,</span>
  92 |     | <span class='neutral'>        uint128 interestRateGradientBreakpoint,</span>
  93 |     | <span class='neutral'>        uint128 highUtilizationInterestRateGradient</span>
  94 |     | <span class='unexecuted'>    ) internal pure returns (uint128 rate) {</span>
  95 |     | <span class='neutral'>        // if utilization rate is below breakpoint, multiply low utilization * # of percentage points of utilizationRate</span>
  96 |     | <span class='neutral'>        // otherwise multiply low utilization until breakpoint, then use high utilization gradient for the rest</span>
  97 |     | <span class='unexecuted'>        if (currentUtilizationRate &lt; interestRateGradientBreakpoint) {</span>
  98 |     | <span class='unexecuted'>            rate =</span>
  99 |     | <span class='unexecuted'>                lowUtilizationInterestRateGradient.mulDecimalUint128(currentUtilizationRate) *</span>
 100 |     | <span class='unexecuted'>                100;</span>
 101 |     | <span class='unexecuted'>        } else {</span>
 102 |     | <span class='unexecuted'>            uint128 highUtilizationRate = currentUtilizationRate - interestRateGradientBreakpoint;</span>
 103 |     | <span class='unexecuted'>            uint128 highUtilizationRateInterest = highUtilizationInterestRateGradient</span>
 104 |     | <span class='unexecuted'>                .mulDecimalUint128(highUtilizationRate) * 100;</span>
 105 |     | <span class='unexecuted'>            uint128 lowUtilizationRateInterest = lowUtilizationInterestRateGradient</span>
 106 |     | <span class='unexecuted'>                .mulDecimalUint128(interestRateGradientBreakpoint) * 100;</span>
 107 |     | <span class='unexecuted'>            rate = highUtilizationRateInterest + lowUtilizationRateInterest;</span>
 108 |     | <span class='neutral'>        }</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'>}</span>
 111 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/KeeperCosts.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  5 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  6 |     | <span class='neutral'>import {INodeModule} from &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
  7 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;./PerpsMarketFactory.sol&quot;;</span>
  8 |     | <span class='neutral'>import {PerpsAccount} from &quot;./PerpsAccount.sol&quot;;</span>
  9 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;./PerpsMarketConfiguration.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>uint128 constant SNX_USD_MARKET_ID = 0;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>/**</span>
 14 |     | <span class='neutral'> * @title Keeper txn execution costs for rewards calculation based on gas price</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='unexecuted'>library KeeperCosts {</span>
 17 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
 18 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
 19 |     | <span class='neutral'>    using PerpsAccount for PerpsAccount.Data;</span>
 20 |     | <span class='neutral'>    using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>    uint256 private constant KIND_SETTLEMENT = 0;</span>
 23 | *   | <span class='executed'>    uint256 private constant KIND_FLAG = 1;</span>
 24 | *   | <span class='executed'>    uint256 private constant KIND_LIQUIDATE = 2;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    struct Data {</span>
 27 |     | <span class='neutral'>        bytes32 keeperCostNodeId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>    function load() internal pure returns (Data storage price) {</span>
 31 | *   | <span class='executed'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.perps-market.KeeperCosts&quot;));</span>
 32 |     | <span class='neutral'>        assembly {</span>
 33 |     | <span class='neutral'>            price.slot := s</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function update(Data storage self, bytes32 keeperCostNodeId) internal {</span>
 38 |     | <span class='unexecuted'>        self.keeperCostNodeId = keeperCostNodeId;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 | *   | <span class='executed'>    function getSettlementKeeperCosts(Data storage self) internal view returns (uint256 sUSDCost) {</span>
 42 | *   | <span class='executed'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
 43 |     | <span class='neutral'></span>
 44 | *   | <span class='executed'>        sUSDCost = _processWithRuntime(self.keeperCostNodeId, factory, 0, KIND_SETTLEMENT);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 | *   | <span class='executed'>    function getFlagKeeperCosts(</span>
 48 |     | <span class='neutral'>        Data storage self,</span>
 49 |     | <span class='neutral'>        uint128 accountId</span>
 50 | *   | <span class='executed'>    ) internal view returns (uint256 sUSDCost) {</span>
 51 | *   | <span class='executed'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
 52 |     | <span class='neutral'></span>
 53 | *   | <span class='executed'>        PerpsAccount.Data storage account = PerpsAccount.load(accountId);</span>
 54 | *   | <span class='executed'>        uint256 numberOfCollateralFeeds = account.activeCollateralTypes.contains(SNX_USD_MARKET_ID)</span>
 55 | *   | <span class='executed'>            ? account.activeCollateralTypes.length() - 1</span>
 56 | *   | <span class='executed'>            : account.activeCollateralTypes.length();</span>
 57 | *   | <span class='executed'>        uint256 numberOfUpdatedFeeds = numberOfCollateralFeeds +</span>
 58 | *   | <span class='executed'>            account.openPositionMarketIds.length();</span>
 59 |     | <span class='neutral'></span>
 60 | *   | <span class='executed'>        sUSDCost = _processWithRuntime(</span>
 61 | *   | <span class='executed'>            self.keeperCostNodeId,</span>
 62 | *   | <span class='executed'>            factory,</span>
 63 | *   | <span class='executed'>            numberOfUpdatedFeeds,</span>
 64 |     | <span class='neutral'>            KIND_FLAG</span>
 65 |     | <span class='neutral'>        );</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'></span>
 68 | *   | <span class='executed'>    function getLiquidateKeeperCosts(Data storage self) internal view returns (uint256 sUSDCost) {</span>
 69 | *   | <span class='executed'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
 70 |     | <span class='neutral'></span>
 71 | *   | <span class='executed'>        sUSDCost = _processWithRuntime(self.keeperCostNodeId, factory, 0, KIND_LIQUIDATE);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 | *   | <span class='executed'>    function _processWithRuntime(</span>
 75 |     | <span class='neutral'>        bytes32 keeperCostNodeId,</span>
 76 |     | <span class='neutral'>        PerpsMarketFactory.Data storage factory,</span>
 77 |     | <span class='neutral'>        uint256 numberOfUpdatedFeeds,</span>
 78 |     | <span class='neutral'>        uint256 executionKind</span>
 79 | *   | <span class='executed'>    ) private view returns (uint256 sUSDCost) {</span>
 80 | *   | <span class='executed'>        bytes32[] memory runtimeKeys = new bytes32[](4);</span>
 81 | *   | <span class='executed'>        bytes32[] memory runtimeValues = new bytes32[](4);</span>
 82 | *   | <span class='executed'>        runtimeKeys[0] = bytes32(&quot;numberOfUpdatedFeeds&quot;);</span>
 83 | *   | <span class='executed'>        runtimeKeys[1] = bytes32(&quot;executionKind&quot;);</span>
 84 | *   | <span class='executed'>        runtimeValues[0] = bytes32(numberOfUpdatedFeeds);</span>
 85 | *   | <span class='executed'>        runtimeValues[1] = bytes32(executionKind);</span>
 86 |     | <span class='neutral'></span>
 87 | *   | <span class='executed'>        sUSDCost = INodeModule(factory.oracle)</span>
 88 | *   | <span class='executed'>            .processWithRuntime(keeperCostNodeId, runtimeKeys, runtimeValues)</span>
 89 |     | <span class='neutral'>            .price</span>
 90 |     | <span class='neutral'>            .toUint();</span>
 91 |     | <span class='neutral'>    }</span>
 92 |     | <span class='neutral'>}</span>
 93 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/Liquidation.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Liquidation data used for determining max liquidation amounts</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library Liquidation {</span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        /**</span>
 10 |     | <span class='neutral'>         * @dev Accumulated amount for this corresponding timestamp</span>
 11 |     | <span class='neutral'>         */</span>
 12 |     | <span class='neutral'>        uint128 amount;</span>
 13 |     | <span class='neutral'>        /**</span>
 14 |     | <span class='neutral'>         * @dev timestamp of the accumulated liqudation amount</span>
 15 |     | <span class='neutral'>         */</span>
 16 |     | <span class='neutral'>        uint256 timestamp;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/LiquidationAssetManager.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC165Helper} from &quot;@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ITokenModule} from &quot;@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol&quot;;</span>
   6 |     | <span class='neutral'>import {RewardsDistributor} from &quot;@synthetixio/rewards-distributor/src/RewardsDistributor.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IRewardDistributor} from &quot;@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ISynthetixSystem} from &quot;../interfaces/external/ISynthetixSystem.sol&quot;;</span>
   9 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;./GlobalPerpsMarketConfiguration.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;./PerpsMarketFactory.sol&quot;;</span>
  11 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
  12 |     | <span class='neutral'>import {AddressUtil} from &quot;@synthetixio/core-contracts/contracts/utils/AddressUtil.sol&quot;;</span>
  13 |     | <span class='neutral'>import {AddressError} from &quot;@synthetixio/core-contracts/contracts/errors/AddressError.sol&quot;;</span>
  14 |     | <span class='neutral'>import {ParameterError} from &quot;@synthetixio/core-contracts/contracts/errors/ParameterError.sol&quot;;</span>
  15 |     | <span class='neutral'>import {IDistributorErrors} from &quot;../interfaces/IDistributorErrors.sol&quot;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>/**</span>
  18 |     | <span class='neutral'> * @title LiquidationAssetManager send liquidity to the reward distributor according to each collateral type</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='unexecuted'>library LiquidationAssetManager {</span>
  21 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    struct Data {</span>
  24 |     | <span class='neutral'>        /**</span>
  25 |     | <span class='neutral'>         * @dev Collateral Id (same as synth id)</span>
  26 |     | <span class='neutral'>         */</span>
  27 |     | <span class='neutral'>        uint128 id;</span>
  28 |     | <span class='neutral'>        /**</span>
  29 |     | <span class='neutral'>         * @dev Distributor address used for reward distribution. If address is 0x0, a new distributor will be created.</span>
  30 |     | <span class='neutral'>         */</span>
  31 |     | <span class='neutral'>        address distributor;</span>
  32 |     | <span class='neutral'>        /**</span>
  33 |     | <span class='neutral'>         * @dev Addresses of collateral types delegated to the pool. Used to distribute rewards.</span>
  34 |     | <span class='neutral'>         * @dev Needs to be manually maintained in synch with pool configuration to distribute proportionally to all LPs.</span>
  35 |     | <span class='neutral'>         */</span>
  36 |     | <span class='neutral'>        address[] poolDelegatedCollateralTypes;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function setValidPoolDelegatedCollateralTypes(</span>
  40 |     | <span class='neutral'>        Data storage self,</span>
  41 |     | <span class='neutral'>        address[] calldata poolDelegatedCollateralTypes</span>
  42 |     | <span class='unexecuted'>    ) internal {</span>
  43 |     | <span class='unexecuted'>        self.poolDelegatedCollateralTypes = poolDelegatedCollateralTypes;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        // Collaterals in a V3 pool can be delegated to a specific market. `collateralTypes` are the pool collateral</span>
  46 |     | <span class='neutral'>        // addresses delegated to this market. They&#39;re tracked here so downstream operations post creation can infer</span>
  47 |     | <span class='neutral'>        // pct of `token` to distribute amongst delegated collaterals. For example, during liquidation we calc to total</span>
  48 |     | <span class='neutral'>        // dollar value of delegated collateral and distribute the reward token proportionally to each collateral.</span>
  49 |     | <span class='neutral'>        //</span>
  50 |     | <span class='neutral'>        // There must be at least one pool collateral type available otherwise this reward distribute cannot distribute.</span>
  51 |     | <span class='unexecuted'>        uint256 collateralTypesLength = self.poolDelegatedCollateralTypes.length;</span>
  52 |     | <span class='unexecuted'>        if (collateralTypesLength == 0) {</span>
  53 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(&quot;collateralTypes&quot;, &quot;must not be empty&quot;);</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; collateralTypesLength; ) {</span>
  56 |     | <span class='unexecuted'>            if (self.poolDelegatedCollateralTypes[i] == address(0)) {</span>
  57 |     | <span class='unexecuted'>                revert AddressError.ZeroAddress();</span>
  58 |     | <span class='neutral'>            }</span>
  59 |     | <span class='neutral'>            unchecked {</span>
  60 |     | <span class='unexecuted'>                ++i;</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function setValidDistributor(</span>
  66 |     | <span class='neutral'>        Data storage self,</span>
  67 |     | <span class='neutral'>        address distributor,</span>
  68 |     | <span class='neutral'>        address tokenAddress</span>
  69 |     | <span class='neutral'>    ) internal {</span>
  70 |     | <span class='unexecuted'>        if (distributor == address(0)) {</span>
  71 |     | <span class='unexecuted'>            revert AddressError.ZeroAddress();</span>
  72 |     | <span class='neutral'>        }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>        if (</span>
  75 |     | <span class='unexecuted'>            !ERC165Helper.safeSupportsInterface(distributor, type(IRewardDistributor).interfaceId)</span>
  76 |     | <span class='neutral'>        ) {</span>
  77 |     | <span class='unexecuted'>            revert IDistributorErrors.InvalidDistributorContract(distributor);</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        if (RewardsDistributor(distributor).token() != tokenAddress) {</span>
  81 |     | <span class='unexecuted'>            revert IDistributorErrors.InvalidDistributor(self.id, tokenAddress);</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        self.distributor = distributor;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>    function distributeCollateral(</span>
  88 |     | <span class='neutral'>        Data storage self,</span>
  89 |     | <span class='neutral'>        address tokenAddress,</span>
  90 |     | <span class='neutral'>        uint256 amount</span>
  91 | *   | <span class='executed'>    ) internal {</span>
  92 | *   | <span class='executed'>        RewardsDistributor distributor = RewardsDistributor(self.distributor);</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        if (distributor.token() != tokenAddress) {</span>
  95 |     | <span class='unexecuted'>            revert IDistributorErrors.InvalidDistributor(self.id, tokenAddress);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'></span>
  98 | *   | <span class='executed'>        uint256 poolCollateralTypesLength = self.poolDelegatedCollateralTypes.length;</span>
  99 | *   | <span class='executed'>        ISynthetixSystem synthetix = PerpsMarketFactory.load().synthetix;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // Transfer collateral to the distributor</span>
 102 | *   | <span class='executed'>        ITokenModule(tokenAddress).transfer(self.distributor, amount);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        // Calculate the USD value of each collateral delegated to pool.</span>
 105 | *   | <span class='executed'>        uint128 poolId = distributor.poolId();</span>
 106 | *   | <span class='executed'>        uint256[] memory collateralValuesUsd = new uint256[](poolCollateralTypesLength);</span>
 107 | *   | <span class='executed'>        uint256 totalCollateralValueUsd;</span>
 108 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; poolCollateralTypesLength; ) {</span>
 109 | *   | <span class='executed'>            (, uint256 collateralValueUsd) = synthetix.getVaultCollateral(</span>
 110 | *   | <span class='executed'>                poolId,</span>
 111 | *   | <span class='executed'>                self.poolDelegatedCollateralTypes[i]</span>
 112 |     | <span class='neutral'>            );</span>
 113 | *   | <span class='executed'>            totalCollateralValueUsd += collateralValueUsd;</span>
 114 | *   | <span class='executed'>            collateralValuesUsd[i] = collateralValueUsd;</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>            unchecked {</span>
 117 | *   | <span class='executed'>                ++i;</span>
 118 |     | <span class='neutral'>            }</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        // Infer the ratio of size to distribute, proportional to value of each delegated collateral.</span>
 122 | *   | <span class='executed'>        uint256 remainingAmountToDistribute = amount;</span>
 123 | *   | <span class='executed'>        for (uint256 j = 0; j &lt; poolCollateralTypesLength; ) {</span>
 124 |     | <span class='neutral'>            // Ensure total amounts fully distributed, the last collateral receives the remainder.</span>
 125 | *   | <span class='executed'>            if (j == poolCollateralTypesLength - 1) {</span>
 126 | *   | <span class='executed'>                distributor.distributeRewards(</span>
 127 | *   | <span class='executed'>                    poolId,</span>
 128 | *   | <span class='executed'>                    self.poolDelegatedCollateralTypes[j],</span>
 129 | *   | <span class='executed'>                    remainingAmountToDistribute,</span>
 130 | *   | <span class='executed'>                    uint64(block.timestamp), // solhint-disable-line numcast/safe-cast</span>
 131 |     | <span class='neutral'>                    0</span>
 132 |     | <span class='neutral'>                );</span>
 133 |     | <span class='unexecuted'>            } else {</span>
 134 |     | <span class='unexecuted'>                uint256 amountToDistribute = amount.mulDecimal(</span>
 135 |     | <span class='unexecuted'>                    collateralValuesUsd[j].divDecimal(totalCollateralValueUsd)</span>
 136 |     | <span class='neutral'>                );</span>
 137 |     | <span class='unexecuted'>                remainingAmountToDistribute -= amountToDistribute;</span>
 138 |     | <span class='unexecuted'>                distributor.distributeRewards(</span>
 139 |     | <span class='unexecuted'>                    poolId,</span>
 140 |     | <span class='unexecuted'>                    self.poolDelegatedCollateralTypes[j],</span>
 141 |     | <span class='unexecuted'>                    amountToDistribute,</span>
 142 |     | <span class='unexecuted'>                    uint64(block.timestamp), // solhint-disable-line numcast/safe-cast</span>
 143 |     | <span class='neutral'>                    0</span>
 144 |     | <span class='neutral'>                );</span>
 145 |     | <span class='neutral'>            }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>            unchecked {</span>
 148 | *   | <span class='executed'>                ++j;</span>
 149 |     | <span class='neutral'>            }</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'>}</span>
 153 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/MarketUpdate.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title MarketUpdateData</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library MarketUpdate {</span>
  8 |     | <span class='neutral'>    // this data struct returns the data required to emit a MarketUpdated event</span>
  9 |     | <span class='neutral'>    struct Data {</span>
 10 |     | <span class='neutral'>        uint128 marketId;</span>
 11 |     | <span class='neutral'>        uint128 interestRate;</span>
 12 |     | <span class='neutral'>        int256 skew;</span>
 13 |     | <span class='neutral'>        uint256 size;</span>
 14 |     | <span class='neutral'>        int256 currentFundingRate;</span>
 15 |     | <span class='neutral'>        int256 currentFundingVelocity;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/OrderFee.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Orders Fee data</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library OrderFee {</span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        /**</span>
 10 |     | <span class='neutral'>         * @dev Maker fee. Applied when order (or partial order) is reducing skew.</span>
 11 |     | <span class='neutral'>         */</span>
 12 |     | <span class='neutral'>        uint256 makerFee;</span>
 13 |     | <span class='neutral'>        /**</span>
 14 |     | <span class='neutral'>         * @dev Taker fee. Applied when order (or partial order) is increasing skew.</span>
 15 |     | <span class='neutral'>         */</span>
 16 |     | <span class='neutral'>        uint256 takerFee;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsAccount.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Price} from &quot;@synthetixio/spot-market/contracts/storage/Price.sol&quot;;</span>
   6 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import {SafeCastI256, SafeCastU256, SafeCastU128} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ISpotMarketSystem} from &quot;../interfaces/external/ISpotMarketSystem.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Position} from &quot;./Position.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsMarket} from &quot;./PerpsMarket.sol&quot;;</span>
  12 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
  13 |     | <span class='neutral'>import {PerpsPrice} from &quot;./PerpsPrice.sol&quot;;</span>
  14 |     | <span class='neutral'>import {MarketUpdate} from &quot;./MarketUpdate.sol&quot;;</span>
  15 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;./PerpsMarketFactory.sol&quot;;</span>
  16 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;./GlobalPerpsMarket.sol&quot;;</span>
  17 |     | <span class='neutral'>import {GlobalPerpsMarketConfiguration} from &quot;./GlobalPerpsMarketConfiguration.sol&quot;;</span>
  18 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;./PerpsMarketConfiguration.sol&quot;;</span>
  19 |     | <span class='neutral'>import {KeeperCosts} from &quot;../storage/KeeperCosts.sol&quot;;</span>
  20 |     | <span class='neutral'>import {AsyncOrder} from &quot;../storage/AsyncOrder.sol&quot;;</span>
  21 |     | <span class='neutral'>import {PerpsCollateralConfiguration} from &quot;./PerpsCollateralConfiguration.sol&quot;;</span>
  22 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  23 |     | <span class='neutral'></span>
  24 | *   | <span class='executed'>uint128 constant SNX_USD_MARKET_ID = 0;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>/**</span>
  27 |     | <span class='neutral'> * @title Data for a single perps market</span>
  28 |     | <span class='neutral'> */</span>
  29 |     | <span class='unexecuted'>library PerpsAccount {</span>
  30 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  31 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  32 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  33 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  34 |     | <span class='neutral'>    using Position for Position.Data;</span>
  35 |     | <span class='neutral'>    using PerpsPrice for PerpsPrice.Data;</span>
  36 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  37 |     | <span class='neutral'>    using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;</span>
  38 |     | <span class='neutral'>    using PerpsMarketFactory for PerpsMarketFactory.Data;</span>
  39 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  40 |     | <span class='neutral'>    using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;</span>
  41 |     | <span class='neutral'>    using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;</span>
  42 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  43 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  44 |     | <span class='neutral'>    using KeeperCosts for KeeperCosts.Data;</span>
  45 |     | <span class='neutral'>    using AsyncOrder for AsyncOrder.Data;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    struct Data {</span>
  48 |     | <span class='neutral'>        // @dev synth marketId =&gt; amount</span>
  49 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) collateralAmounts;</span>
  50 |     | <span class='neutral'>        // @dev account Id</span>
  51 |     | <span class='neutral'>        uint128 id;</span>
  52 |     | <span class='neutral'>        // @dev set of active collateral types. By active we mean collateral types that have a non-zero amount</span>
  53 |     | <span class='neutral'>        SetUtil.UintSet activeCollateralTypes;</span>
  54 |     | <span class='neutral'>        // @dev set of open position market ids</span>
  55 |     | <span class='neutral'>        SetUtil.UintSet openPositionMarketIds;</span>
  56 |     | <span class='neutral'>        // @dev account&#39;s debt accrued from previous positions</span>
  57 |     | <span class='neutral'>        // @dev please use updateAccountDebt() to update this value which will update global debt also</span>
  58 |     | <span class='neutral'>        uint256 debt;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    error InsufficientCollateralAvailableForWithdraw(</span>
  62 |     | <span class='neutral'>        int256 withdrawableMarginUsd,</span>
  63 |     | <span class='neutral'>        uint256 requestedMarginUsd</span>
  64 |     | <span class='neutral'>    );</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    error InsufficientSynthCollateral(</span>
  67 |     | <span class='neutral'>        uint128 collateralId,</span>
  68 |     | <span class='neutral'>        uint256 collateralAmount,</span>
  69 |     | <span class='neutral'>        uint256 withdrawAmount</span>
  70 |     | <span class='neutral'>    );</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    error InsufficientAccountMargin(uint256 leftover);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    error AccountLiquidatable(uint128 accountId);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    error AccountMarginLiquidatable(uint128 accountId);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    error MaxPositionsPerAccountReached(uint128 maxPositionsPerAccount);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    error MaxCollateralsPerAccountReached(uint128 maxCollateralsPerAccount);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    error NonexistentDebt(uint128 accountId);</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>    function load(uint128 id) internal pure returns (Data storage account) {</span>
  85 | *   | <span class='executed'>        bytes32 s = keccak256(</span>
  86 | *   | <span class='executed'>            abi.encode(&quot;io.synthetix.perps-market.Account&quot;, id)</span>
  87 |     | <span class='neutral'>        );</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        assembly {</span>
  90 |     | <span class='neutral'>            account.slot := s</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>        @notice allows us to update the account id in case it needs to be</span>
  96 |     | <span class='neutral'>     */</span>
  97 | *   | <span class='executed'>    function create(uint128 id) internal returns (Data storage account) {</span>
  98 | *   | <span class='executed'>        account = load(id);</span>
  99 | *   | <span class='executed'>        if (account.id == 0) {</span>
 100 | *   | <span class='executed'>            account.id = id;</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>    function validateMaxPositions(</span>
 105 |     | <span class='neutral'>        uint128 accountId,</span>
 106 |     | <span class='neutral'>        uint128 marketId</span>
 107 |     | <span class='neutral'>    ) internal view {</span>
 108 | *   | <span class='executed'>        if (PerpsMarket.accountPosition(marketId, accountId).size == 0) {</span>
 109 | *   | <span class='executed'>            uint128 maxPositionsPerAccount = GlobalPerpsMarketConfiguration</span>
 110 |     | <span class='neutral'>                .load()</span>
 111 |     | <span class='neutral'>                .maxPositionsPerAccount;</span>
 112 | *   | <span class='executed'>            if (</span>
 113 | *   | <span class='executed'>                maxPositionsPerAccount &lt;=</span>
 114 | *   | <span class='executed'>                load(accountId).openPositionMarketIds.length()</span>
 115 |     | <span class='neutral'>            ) {</span>
 116 |     | <span class='unexecuted'>                revert MaxPositionsPerAccountReached(maxPositionsPerAccount);</span>
 117 |     | <span class='neutral'>            }</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>    function validateMaxCollaterals(</span>
 122 |     | <span class='neutral'>        uint128 accountId,</span>
 123 |     | <span class='neutral'>        uint128 collateralId</span>
 124 |     | <span class='neutral'>    ) internal view {</span>
 125 | *   | <span class='executed'>        Data storage account = load(accountId);</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>        if (account.collateralAmounts[collateralId] == 0) {</span>
 128 | *   | <span class='executed'>            uint128 maxCollateralsPerAccount = GlobalPerpsMarketConfiguration</span>
 129 |     | <span class='neutral'>                .load()</span>
 130 |     | <span class='neutral'>                .maxCollateralsPerAccount;</span>
 131 | *   | <span class='executed'>            if (</span>
 132 | *   | <span class='executed'>                maxCollateralsPerAccount &lt;=</span>
 133 | *   | <span class='executed'>                account.activeCollateralTypes.length()</span>
 134 |     | <span class='neutral'>            ) {</span>
 135 |     | <span class='unexecuted'>                revert MaxCollateralsPerAccountReached(</span>
 136 |     | <span class='neutral'>                    maxCollateralsPerAccount</span>
 137 |     | <span class='neutral'>                );</span>
 138 |     | <span class='neutral'>            }</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @notice This function charges the account the specified amount</span>
 144 |     | <span class='neutral'>     * @dev This is the only function that changes account debt.</span>
 145 |     | <span class='neutral'>     * @dev Excess credit is added to account&#39;s snxUSD amount.</span>
 146 |     | <span class='neutral'>     * @dev if the amount is positive, it is credit, if negative, it is debt.</span>
 147 |     | <span class='neutral'>     */</span>
 148 | *   | <span class='executed'>    function charge(</span>
 149 |     | <span class='neutral'>        Data storage self,</span>
 150 |     | <span class='neutral'>        int256 amount</span>
 151 | *   | <span class='executed'>    ) internal returns (uint256 debt) {</span>
 152 | *   | <span class='executed'>        uint256 newDebt;</span>
 153 | *   | <span class='executed'>        if (amount &gt; 0) {</span>
 154 | *   | <span class='executed'>            int256 leftoverDebt = self.debt.toInt() - amount;</span>
 155 | *   | <span class='executed'>            if (leftoverDebt &gt; 0) {</span>
 156 | *   | <span class='executed'>                newDebt = leftoverDebt.toUint();</span>
 157 |     | <span class='neutral'>            } else {</span>
 158 | *   | <span class='executed'>                newDebt = 0;</span>
 159 | *   | <span class='executed'>                updateCollateralAmount(self, SNX_USD_MARKET_ID, -leftoverDebt);</span>
 160 |     | <span class='neutral'>            }</span>
 161 | *   | <span class='executed'>        } else {</span>
 162 | *   | <span class='executed'>            int256 creditAvailable = self</span>
 163 |     | <span class='neutral'>                .collateralAmounts[SNX_USD_MARKET_ID]</span>
 164 |     | <span class='neutral'>                .toInt();</span>
 165 | *   | <span class='executed'>            int256 leftoverCredit = creditAvailable + amount;</span>
 166 |     | <span class='neutral'></span>
 167 | *   | <span class='executed'>            if (leftoverCredit &gt; 0) {</span>
 168 | *   | <span class='executed'>                updateCollateralAmount(self, SNX_USD_MARKET_ID, amount);</span>
 169 |     | <span class='neutral'>            } else {</span>
 170 | *   | <span class='executed'>                updateCollateralAmount(</span>
 171 | *   | <span class='executed'>                    self,</span>
 172 |     | <span class='neutral'>                    SNX_USD_MARKET_ID,</span>
 173 | *   | <span class='executed'>                    -creditAvailable</span>
 174 |     | <span class='neutral'>                );</span>
 175 | *   | <span class='executed'>                newDebt = (self.debt.toInt() - leftoverCredit).toUint();</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'></span>
 179 | *   | <span class='executed'>        return updateAccountDebt(self, newDebt.toInt() - self.debt.toInt());</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 | *   | <span class='executed'>    function updateAccountDebt(</span>
 183 |     | <span class='neutral'>        Data storage self,</span>
 184 |     | <span class='neutral'>        int256 amount</span>
 185 | *   | <span class='executed'>    ) internal returns (uint256 debt) {</span>
 186 | *   | <span class='executed'>        self.debt = (self.debt.toInt() + amount).toUint();</span>
 187 | *   | <span class='executed'>        GlobalPerpsMarket.load().updateDebt(amount);</span>
 188 |     | <span class='neutral'></span>
 189 | *   | <span class='executed'>        return self.debt;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>    function isEligibleForMarginLiquidation(</span>
 193 |     | <span class='neutral'>        Data storage self,</span>
 194 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance</span>
 195 | *   | <span class='executed'>    ) internal view returns (bool isEligible, int256 availableMargin) {</span>
 196 | *   | <span class='executed'>        availableMargin = getAvailableMargin(self, stalenessTolerance);</span>
 197 | *   | <span class='executed'>        isEligible = availableMargin &lt; 0;</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    // function isEligibleForLiquidation(</span>
 201 |     | <span class='neutral'>    //     Data storage self,</span>
 202 |     | <span class='neutral'>    //     PerpsPrice.Tolerance stalenessTolerance</span>
 203 |     | <span class='neutral'>    // )</span>
 204 |     | <span class='neutral'>    //     internal</span>
 205 |     | <span class='neutral'>    //     view</span>
 206 |     | <span class='neutral'>    //     returns (</span>
 207 |     | <span class='neutral'>    //         bool isEligible,</span>
 208 |     | <span class='neutral'>    //         int256 availableMargin,</span>
 209 |     | <span class='neutral'>    //         uint256 requiredInitialMargin,</span>
 210 |     | <span class='neutral'>    //         uint256 requiredMaintenanceMargin,</span>
 211 |     | <span class='neutral'>    //         uint256 liquidationReward</span>
 212 |     | <span class='neutral'>    //     )</span>
 213 |     | <span class='neutral'>    // {</span>
 214 |     | <span class='neutral'>    //     availableMargin = getAvailableMargin(self, stalenessTolerance);</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    //     (</span>
 217 |     | <span class='neutral'>    //         requiredInitialMargin,</span>
 218 |     | <span class='neutral'>    //         requiredMaintenanceMargin,</span>
 219 |     | <span class='neutral'>    //         liquidationReward</span>
 220 |     | <span class='neutral'>    //     ) = getAccountRequiredMargins(self, stalenessTolerance);</span>
 221 |     | <span class='neutral'>    //     isEligible = (requiredMaintenanceMargin + liquidationReward).toInt() &gt; availableMargin;</span>
 222 |     | <span class='neutral'>    // }</span>
 223 |     | <span class='neutral'></span>
 224 | *   | <span class='executed'>    function isEligibleForLiquidation(</span>
 225 |     | <span class='neutral'>        Data storage self,</span>
 226 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance</span>
 227 |     | <span class='neutral'>    )</span>
 228 |     | <span class='neutral'>        internal</span>
 229 |     | <span class='neutral'>        view</span>
 230 |     | <span class='neutral'>        returns (</span>
 231 | *   | <span class='executed'>            bool isEligible,</span>
 232 | *   | <span class='executed'>            int256 availableMargin,</span>
 233 | *   | <span class='executed'>            uint256 requiredInitialMargin,</span>
 234 | *   | <span class='executed'>            uint256 requiredMaintenanceMargin,</span>
 235 | *   | <span class='executed'>            uint256 liquidationReward</span>
 236 |     | <span class='neutral'>        )</span>
 237 |     | <span class='neutral'>    {</span>
 238 | *   | <span class='executed'>        availableMargin = getAvailableMargin(self, stalenessTolerance);</span>
 239 | *   | <span class='executed'>        console2.log(&quot;availableMargin&quot;, availableMargin);</span>
 240 |     | <span class='neutral'></span>
 241 | *   | <span class='executed'>        (</span>
 242 |     | <span class='neutral'>            requiredInitialMargin,</span>
 243 |     | <span class='neutral'>            requiredMaintenanceMargin,</span>
 244 |     | <span class='neutral'>            liquidationReward</span>
 245 | *   | <span class='executed'>        ) = getAccountRequiredMargins(self, stalenessTolerance);</span>
 246 |     | <span class='neutral'></span>
 247 | *   | <span class='executed'>        console2.log(&quot;requiredInitialMargin&quot;, requiredInitialMargin);</span>
 248 | *   | <span class='executed'>        console2.log(&quot;requiredMaintenanceMargin&quot;, requiredMaintenanceMargin);</span>
 249 | *   | <span class='executed'>        console2.log(&quot;liquidationReward&quot;, liquidationReward);</span>
 250 |     | <span class='neutral'></span>
 251 | *   | <span class='executed'>        isEligible =</span>
 252 | *   | <span class='executed'>            (requiredMaintenanceMargin + liquidationReward).toInt() &gt;</span>
 253 | *   | <span class='executed'>            availableMargin;</span>
 254 | *   | <span class='executed'>        console2.log(&quot;isEligible&quot;, isEligible);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        console2.log(</span>
 257 |     | <span class='neutral'>            &quot;(requiredMaintenanceMargin + liquidationReward).toInt()&quot;,</span>
 258 | *   | <span class='executed'>            (requiredMaintenanceMargin + liquidationReward).toInt()</span>
 259 |     | <span class='neutral'>        );</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 | *   | <span class='executed'>    function flagForLiquidation(</span>
 263 |     | <span class='neutral'>        Data storage self</span>
 264 | *   | <span class='executed'>    ) internal returns (uint256 flagKeeperCost, uint256 seizedMarginValue) {</span>
 265 | *   | <span class='executed'>        SetUtil.UintSet storage liquidatableAccounts = GlobalPerpsMarket</span>
 266 |     | <span class='neutral'>            .load()</span>
 267 |     | <span class='neutral'>            .liquidatableAccounts;</span>
 268 |     | <span class='neutral'></span>
 269 | *   | <span class='executed'>        if (!liquidatableAccounts.contains(self.id)) {</span>
 270 | *   | <span class='executed'>            flagKeeperCost = KeeperCosts.load().getFlagKeeperCosts(self.id);</span>
 271 | *   | <span class='executed'>            liquidatableAccounts.add(self.id);</span>
 272 | *   | <span class='executed'>            seizedMarginValue = transferAllCollateral(self);</span>
 273 | *   | <span class='executed'>            AsyncOrder.load(self.id).reset();</span>
 274 |     | <span class='neutral'></span>
 275 | *   | <span class='executed'>            updateAccountDebt(self, -self.debt.toInt());</span>
 276 |     | <span class='neutral'>        }</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 | *   | <span class='executed'>    function getMarginLiquidationCostAndSeizeMargin(</span>
 280 |     | <span class='neutral'>        Data storage self</span>
 281 |     | <span class='neutral'>    )</span>
 282 |     | <span class='neutral'>        internal</span>
 283 | *   | <span class='executed'>        returns (uint256 marginLiquidateCost, uint256 seizedMarginValue)</span>
 284 |     | <span class='neutral'>    {</span>
 285 |     | <span class='neutral'>        // notice: using getFlagKeeperCosts here since the logic is the same, but with no positions.</span>
 286 | *   | <span class='executed'>        marginLiquidateCost = KeeperCosts.load().getFlagKeeperCosts(self.id);</span>
 287 |     | <span class='neutral'></span>
 288 | *   | <span class='executed'>        seizedMarginValue = transferAllCollateral(self);</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 | *   | <span class='executed'>    function updateOpenPositions(</span>
 292 |     | <span class='neutral'>        Data storage self,</span>
 293 |     | <span class='neutral'>        uint256 positionMarketId,</span>
 294 |     | <span class='neutral'>        int256 size</span>
 295 |     | <span class='neutral'>    ) internal {</span>
 296 | *   | <span class='executed'>        if (</span>
 297 | *   | <span class='executed'>            size == 0 &amp;&amp; self.openPositionMarketIds.contains(positionMarketId)</span>
 298 |     | <span class='neutral'>        ) {</span>
 299 | *   | <span class='executed'>            self.openPositionMarketIds.remove(positionMarketId);</span>
 300 | *   | <span class='executed'>        } else if (!self.openPositionMarketIds.contains(positionMarketId)) {</span>
 301 | *   | <span class='executed'>            self.openPositionMarketIds.add(positionMarketId);</span>
 302 |     | <span class='neutral'>        }</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 | *   | <span class='executed'>    function updateCollateralAmount(</span>
 306 |     | <span class='neutral'>        Data storage self,</span>
 307 |     | <span class='neutral'>        uint128 collateralId,</span>
 308 |     | <span class='neutral'>        int256 amountDelta</span>
 309 | *   | <span class='executed'>    ) internal returns (uint256 collateralAmount) {</span>
 310 | *   | <span class='executed'>        collateralAmount = (self.collateralAmounts[collateralId].toInt() +</span>
 311 | *   | <span class='executed'>            amountDelta).toUint();</span>
 312 | *   | <span class='executed'>        self.collateralAmounts[collateralId] = collateralAmount;</span>
 313 |     | <span class='neutral'></span>
 314 | *   | <span class='executed'>        bool isActiveCollateral = self.activeCollateralTypes.contains(</span>
 315 |     | <span class='neutral'>            collateralId</span>
 316 |     | <span class='neutral'>        );</span>
 317 | *   | <span class='executed'>        if (collateralAmount &gt; 0 &amp;&amp; !isActiveCollateral) {</span>
 318 | *   | <span class='executed'>            self.activeCollateralTypes.add(collateralId);</span>
 319 | *   | <span class='executed'>        } else if (collateralAmount == 0 &amp;&amp; isActiveCollateral) {</span>
 320 | *   | <span class='executed'>            self.activeCollateralTypes.remove(collateralId);</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>        // always update global values when account collateral is changed</span>
 324 | *   | <span class='executed'>        GlobalPerpsMarket.load().updateCollateralAmount(</span>
 325 | *   | <span class='executed'>            collateralId,</span>
 326 | *   | <span class='executed'>            amountDelta</span>
 327 |     | <span class='neutral'>        );</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 | *   | <span class='executed'>    function payDebt(Data storage self, uint256 amount) internal {</span>
 331 | *   | <span class='executed'>        if (self.debt == 0) {</span>
 332 | *   | <span class='executed'>            revert NonexistentDebt(self.id);</span>
 333 |     | <span class='neutral'>        }</span>
 334 |     | <span class='neutral'></span>
 335 | *   | <span class='executed'>        PerpsMarketFactory.Data storage perpsMarketFactory = PerpsMarketFactory</span>
 336 |     | <span class='neutral'>            .load();</span>
 337 | *   | <span class='executed'>        perpsMarketFactory.synthetix.depositMarketUsd(</span>
 338 | *   | <span class='executed'>            perpsMarketFactory.perpsMarketId,</span>
 339 | *   | <span class='executed'>            ERC2771Context._msgSender(),</span>
 340 | *   | <span class='executed'>            amount</span>
 341 |     | <span class='neutral'>        );</span>
 342 |     | <span class='neutral'></span>
 343 | *   | <span class='executed'>        if (self.debt &lt; amount) {</span>
 344 | *   | <span class='executed'>            self.debt = 0;</span>
 345 | *   | <span class='executed'>            updateCollateralAmount(</span>
 346 |     | <span class='neutral'>                self,</span>
 347 |     | <span class='neutral'>                SNX_USD_MARKET_ID,</span>
 348 | *   | <span class='executed'>                (amount - self.debt).toInt()</span>
 349 |     | <span class='neutral'>            );</span>
 350 |     | <span class='neutral'>        } else {</span>
 351 | *   | <span class='executed'>            self.debt -= amount;</span>
 352 |     | <span class='neutral'>        }</span>
 353 |     | <span class='neutral'>    }</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='neutral'>    /**</span>
 356 |     | <span class='neutral'>     * @notice This function validates you have enough margin to withdraw without being liquidated.</span>
 357 |     | <span class='neutral'>     * @dev    This is done by checking your collateral value against your initial maintenance value.</span>
 358 |     | <span class='neutral'>     * @dev    It also checks the synth collateral for this account is enough to cover the withdrawal amount.</span>
 359 |     | <span class='neutral'>     * @dev    All price checks are not checking strict staleness tolerance.</span>
 360 |     | <span class='neutral'>     */</span>
 361 | *   | <span class='executed'>    function validateWithdrawableAmount(</span>
 362 |     | <span class='neutral'>        Data storage self,</span>
 363 |     | <span class='neutral'>        uint128 collateralId,</span>
 364 |     | <span class='neutral'>        uint256 amountToWithdraw,</span>
 365 |     | <span class='neutral'>        ISpotMarketSystem spotMarket</span>
 366 |     | <span class='neutral'>    ) internal view {</span>
 367 | *   | <span class='executed'>        uint256 collateralAmount = self.collateralAmounts[collateralId];</span>
 368 | *   | <span class='executed'>        if (collateralAmount &lt; amountToWithdraw) {</span>
 369 | *   | <span class='executed'>            revert InsufficientSynthCollateral(</span>
 370 |     | <span class='neutral'>                collateralId,</span>
 371 |     | <span class='neutral'>                collateralAmount,</span>
 372 |     | <span class='neutral'>                amountToWithdraw</span>
 373 |     | <span class='neutral'>            );</span>
 374 |     | <span class='neutral'>        }</span>
 375 |     | <span class='neutral'></span>
 376 | *   | <span class='executed'>        int256 withdrawableMarginUsd = getWithdrawableMargin(</span>
 377 | *   | <span class='executed'>            self,</span>
 378 | *   | <span class='executed'>            PerpsPrice.Tolerance.STRICT</span>
 379 |     | <span class='neutral'>        );</span>
 380 |     | <span class='neutral'>        // Note: this can only happen if account is liquidatable</span>
 381 | *   | <span class='executed'>        if (withdrawableMarginUsd &lt; 0) {</span>
 382 | *   | <span class='executed'>            revert AccountLiquidatable(self.id);</span>
 383 |     | <span class='neutral'>        }</span>
 384 |     | <span class='neutral'></span>
 385 | *   | <span class='executed'>        uint256 amountToWithdrawUsd;</span>
 386 | *   | <span class='executed'>        if (collateralId == SNX_USD_MARKET_ID) {</span>
 387 | *   | <span class='executed'>            amountToWithdrawUsd = amountToWithdraw;</span>
 388 |     | <span class='neutral'>        } else {</span>
 389 | *   | <span class='executed'>            (amountToWithdrawUsd, ) = PerpsCollateralConfiguration</span>
 390 | *   | <span class='executed'>                .load(collateralId)</span>
 391 |     | <span class='neutral'>                .valueInUsd(</span>
 392 | *   | <span class='executed'>                    amountToWithdraw,</span>
 393 | *   | <span class='executed'>                    spotMarket,</span>
 394 | *   | <span class='executed'>                    PerpsPrice.Tolerance.STRICT,</span>
 395 | *   | <span class='executed'>                    false</span>
 396 |     | <span class='neutral'>                );</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'></span>
 399 | *   | <span class='executed'>        if (amountToWithdrawUsd.toInt() &gt; withdrawableMarginUsd) {</span>
 400 | *   | <span class='executed'>            revert InsufficientCollateralAvailableForWithdraw(</span>
 401 |     | <span class='neutral'>                withdrawableMarginUsd,</span>
 402 |     | <span class='neutral'>                amountToWithdrawUsd</span>
 403 |     | <span class='neutral'>            );</span>
 404 |     | <span class='neutral'>        }</span>
 405 |     | <span class='neutral'>    }</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'>    /**</span>
 408 |     | <span class='neutral'>     * @notice Withdrawable amount depends on if the account has active positions or not</span>
 409 |     | <span class='neutral'>     * @dev    If the account has no active positions and no debt, the withdrawable margin is the total collateral value</span>
 410 |     | <span class='neutral'>     * @dev    If the account has no active positions but has debt, the withdrawable margin is the available margin (which is debt reduced)</span>
 411 |     | <span class='neutral'>     * @dev    If the account has active positions, the withdrawable margin is the available margin - required margin - potential liquidation reward</span>
 412 |     | <span class='neutral'>     */</span>
 413 | *   | <span class='executed'>    function getWithdrawableMargin(</span>
 414 |     | <span class='neutral'>        Data storage self,</span>
 415 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance</span>
 416 | *   | <span class='executed'>    ) internal view returns (int256 withdrawableMargin) {</span>
 417 | *   | <span class='executed'>        bool hasActivePositions = hasOpenPositions(self);</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>        // not allowed to withdraw until debt is paid off fully.</span>
 420 | *   | <span class='executed'>        if (self.debt &gt; 0) return 0;</span>
 421 |     | <span class='neutral'></span>
 422 | *   | <span class='executed'>        if (hasActivePositions) {</span>
 423 | *   | <span class='executed'>            (</span>
 424 | *   | <span class='executed'>                uint256 requiredInitialMargin,</span>
 425 |     | <span class='neutral'>                ,</span>
 426 | *   | <span class='executed'>                uint256 liquidationReward</span>
 427 | *   | <span class='executed'>            ) = getAccountRequiredMargins(self, stalenessTolerance);</span>
 428 | *   | <span class='executed'>            uint256 requiredMargin = requiredInitialMargin + liquidationReward;</span>
 429 | *   | <span class='executed'>            withdrawableMargin =</span>
 430 | *   | <span class='executed'>                getAvailableMargin(self, stalenessTolerance) -</span>
 431 | *   | <span class='executed'>                requiredMargin.toInt();</span>
 432 |     | <span class='neutral'>        } else {</span>
 433 | *   | <span class='executed'>            withdrawableMargin = getTotalCollateralValue(</span>
 434 | *   | <span class='executed'>                self,</span>
 435 | *   | <span class='executed'>                stalenessTolerance,</span>
 436 | *   | <span class='executed'>                false</span>
 437 |     | <span class='neutral'>            ).toInt();</span>
 438 |     | <span class='neutral'>        }</span>
 439 |     | <span class='neutral'>    }</span>
 440 |     | <span class='neutral'></span>
 441 | *   | <span class='executed'>    function getTotalCollateralValue(</span>
 442 |     | <span class='neutral'>        Data storage self,</span>
 443 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance,</span>
 444 |     | <span class='neutral'>        bool useDiscountedValue</span>
 445 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 446 | *   | <span class='executed'>        uint256 totalCollateralValue;</span>
 447 | *   | <span class='executed'>        ISpotMarketSystem spotMarket = PerpsMarketFactory.load().spotMarket;</span>
 448 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= self.activeCollateralTypes.length(); i++) {</span>
 449 | *   | <span class='executed'>            uint128 collateralId = self</span>
 450 |     | <span class='neutral'>                .activeCollateralTypes</span>
 451 | *   | <span class='executed'>                .valueAt(i)</span>
 452 |     | <span class='neutral'>                .to128();</span>
 453 | *   | <span class='executed'>            uint256 amount = self.collateralAmounts[collateralId];</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>            uint256 amountToAdd;</span>
 456 | *   | <span class='executed'>            if (collateralId == SNX_USD_MARKET_ID) {</span>
 457 | *   | <span class='executed'>                amountToAdd = amount;</span>
 458 |     | <span class='neutral'>            } else {</span>
 459 | *   | <span class='executed'>                (amountToAdd, ) = PerpsCollateralConfiguration</span>
 460 | *   | <span class='executed'>                    .load(collateralId)</span>
 461 |     | <span class='neutral'>                    .valueInUsd(</span>
 462 | *   | <span class='executed'>                        amount,</span>
 463 | *   | <span class='executed'>                        spotMarket,</span>
 464 | *   | <span class='executed'>                        stalenessTolerance,</span>
 465 | *   | <span class='executed'>                        useDiscountedValue</span>
 466 |     | <span class='neutral'>                    );</span>
 467 |     | <span class='neutral'>            }</span>
 468 | *   | <span class='executed'>            totalCollateralValue += amountToAdd;</span>
 469 |     | <span class='neutral'>        }</span>
 470 | *   | <span class='executed'>        return totalCollateralValue;</span>
 471 |     | <span class='neutral'>    }</span>
 472 |     | <span class='neutral'></span>
 473 | *   | <span class='executed'>    function getAccountPnl(</span>
 474 |     | <span class='neutral'>        Data storage self,</span>
 475 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance</span>
 476 | *   | <span class='executed'>    ) internal view returns (int256 totalPnl) {</span>
 477 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= self.openPositionMarketIds.length(); i++) {</span>
 478 | *   | <span class='executed'>            uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();</span>
 479 | *   | <span class='executed'>            Position.Data storage position = PerpsMarket</span>
 480 | *   | <span class='executed'>                .load(marketId)</span>
 481 | *   | <span class='executed'>                .positions[self.id];</span>
 482 | *   | <span class='executed'>            (int256 pnl, , , , , ) = position.getPnl(</span>
 483 | *   | <span class='executed'>                PerpsPrice.getCurrentPrice(marketId, stalenessTolerance)</span>
 484 |     | <span class='neutral'>            );</span>
 485 | *   | <span class='executed'>            totalPnl += pnl;</span>
 486 |     | <span class='neutral'>        }</span>
 487 |     | <span class='neutral'>    }</span>
 488 |     | <span class='neutral'></span>
 489 |     | <span class='neutral'>    /**</span>
 490 |     | <span class='neutral'>     * @notice This function returns the available margin for an account (this is not withdrawable margin which takes into account, margin requirements for open positions)</span>
 491 |     | <span class='neutral'>     * @dev    The available margin is the total collateral value + account pnl - account debt</span>
 492 |     | <span class='neutral'>     * @dev    The total collateral value is always based on the discounted value of the collateral</span>
 493 |     | <span class='neutral'>     */</span>
 494 | *   | <span class='executed'>    function getAvailableMargin(</span>
 495 |     | <span class='neutral'>        Data storage self,</span>
 496 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance</span>
 497 | *   | <span class='executed'>    ) internal view returns (int256) {</span>
 498 | *   | <span class='executed'>        int256 totalCollateralValue = getTotalCollateralValue(</span>
 499 | *   | <span class='executed'>            self,</span>
 500 | *   | <span class='executed'>            stalenessTolerance,</span>
 501 | *   | <span class='executed'>            true</span>
 502 |     | <span class='neutral'>        ).toInt();</span>
 503 | *   | <span class='executed'>        int256 accountPnl = getAccountPnl(self, stalenessTolerance);</span>
 504 |     | <span class='neutral'></span>
 505 | *   | <span class='executed'>        return totalCollateralValue + accountPnl - self.debt.toInt();</span>
 506 |     | <span class='neutral'>    }</span>
 507 |     | <span class='neutral'></span>
 508 | *   | <span class='executed'>    function getTotalNotionalOpenInterest(</span>
 509 |     | <span class='neutral'>        Data storage self</span>
 510 |     | <span class='unexecuted'>    ) internal view returns (uint256 totalAccountOpenInterest) {</span>
 511 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= self.openPositionMarketIds.length(); i++) {</span>
 512 | *   | <span class='executed'>            uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='unexecuted'>            Position.Data storage position = PerpsMarket</span>
 515 |     | <span class='unexecuted'>                .load(marketId)</span>
 516 |     | <span class='unexecuted'>                .positions[self.id];</span>
 517 |     | <span class='unexecuted'>            uint256 openInterest = position.getNotionalValue(</span>
 518 |     | <span class='unexecuted'>                PerpsPrice.getCurrentPrice(</span>
 519 |     | <span class='unexecuted'>                    marketId,</span>
 520 |     | <span class='neutral'>                    PerpsPrice.Tolerance.DEFAULT</span>
 521 |     | <span class='neutral'>                )</span>
 522 |     | <span class='neutral'>            );</span>
 523 |     | <span class='unexecuted'>            totalAccountOpenInterest += openInterest;</span>
 524 |     | <span class='neutral'>        }</span>
 525 |     | <span class='neutral'>    }</span>
 526 |     | <span class='neutral'></span>
 527 |     | <span class='neutral'>    /**</span>
 528 |     | <span class='neutral'>     * @notice  This function returns the required margins for an account</span>
 529 |     | <span class='neutral'>     * @dev The initial required margin is used to determine withdrawal amount and when opening positions</span>
 530 |     | <span class='neutral'>     * @dev The maintenance margin is used to determine when to liquidate a position</span>
 531 |     | <span class='neutral'>     */</span>
 532 |     | <span class='neutral'>    // function getAccountRequiredMargins(</span>
 533 |     | <span class='neutral'>    //     Data storage self,</span>
 534 |     | <span class='neutral'>    //     PerpsPrice.Tolerance stalenessTolerance</span>
 535 |     | <span class='neutral'>    // )</span>
 536 |     | <span class='neutral'>    //     internal</span>
 537 |     | <span class='neutral'>    //     view</span>
 538 |     | <span class='neutral'>    //     returns (</span>
 539 |     | <span class='neutral'>    //         uint256 initialMargin,</span>
 540 |     | <span class='neutral'>    //         uint256 maintenanceMargin,</span>
 541 |     | <span class='neutral'>    //         uint256 possibleLiquidationReward</span>
 542 |     | <span class='neutral'>    //     )</span>
 543 |     | <span class='neutral'>    // {</span>
 544 |     | <span class='neutral'>    //     uint256 openPositionMarketIdsLength = self</span>
 545 |     | <span class='neutral'>    //         .openPositionMarketIds</span>
 546 |     | <span class='neutral'>    //         .length();</span>
 547 |     | <span class='neutral'>    //     if (openPositionMarketIdsLength == 0) {</span>
 548 |     | <span class='neutral'>    //         return (0, 0, 0);</span>
 549 |     | <span class='neutral'>    //     }</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='neutral'>    //     // use separate accounting for liquidation rewards so we can compare against global min/max liquidation reward values</span>
 552 |     | <span class='neutral'>    //     for (uint256 i = 1; i &lt;= openPositionMarketIdsLength; i++) {</span>
 553 |     | <span class='neutral'>    //         uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();</span>
 554 |     | <span class='neutral'>    //         Position.Data storage position = PerpsMarket</span>
 555 |     | <span class='neutral'>    //             .load(marketId)</span>
 556 |     | <span class='neutral'>    //             .positions[self.id];</span>
 557 |     | <span class='neutral'>    //         PerpsMarketConfiguration.Data</span>
 558 |     | <span class='neutral'>    //             storage marketConfig = PerpsMarketConfiguration.load(marketId);</span>
 559 |     | <span class='neutral'>    //         (</span>
 560 |     | <span class='neutral'>    //             ,</span>
 561 |     | <span class='neutral'>    //             ,</span>
 562 |     | <span class='neutral'>    //             uint256 positionInitialMargin,</span>
 563 |     | <span class='neutral'>    //             uint256 positionMaintenanceMargin</span>
 564 |     | <span class='neutral'>    //         ) = marketConfig.calculateRequiredMargins(</span>
 565 |     | <span class='neutral'>    //                 position.size,</span>
 566 |     | <span class='neutral'>    //                 PerpsPrice.getCurrentPrice(marketId, stalenessTolerance)</span>
 567 |     | <span class='neutral'>    //             );</span>
 568 |     | <span class='neutral'></span>
 569 |     | <span class='neutral'>    //         maintenanceMargin += positionMaintenanceMargin;</span>
 570 |     | <span class='neutral'>    //         initialMargin += positionInitialMargin;</span>
 571 |     | <span class='neutral'>    //     }</span>
 572 |     | <span class='neutral'></span>
 573 |     | <span class='neutral'>    //     (</span>
 574 |     | <span class='neutral'>    //         uint256 accumulatedLiquidationRewards,</span>
 575 |     | <span class='neutral'>    //         uint256 maxNumberOfWindows</span>
 576 |     | <span class='neutral'>    //     ) = getKeeperRewardsAndCosts(self, 0);</span>
 577 |     | <span class='neutral'>    //     possibleLiquidationReward = getPossibleLiquidationReward(</span>
 578 |     | <span class='neutral'>    //         self,</span>
 579 |     | <span class='neutral'>    //         accumulatedLiquidationRewards,</span>
 580 |     | <span class='neutral'>    //         maxNumberOfWindows</span>
 581 |     | <span class='neutral'>    //     );</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='neutral'>    //     return (initialMargin, maintenanceMargin, possibleLiquidationReward);</span>
 584 |     | <span class='neutral'>    // }</span>
 585 |     | <span class='neutral'></span>
 586 | *   | <span class='executed'>    function getAccountRequiredMargins(</span>
 587 |     | <span class='neutral'>        Data storage self,</span>
 588 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance</span>
 589 |     | <span class='neutral'>    )</span>
 590 |     | <span class='neutral'>        internal</span>
 591 |     | <span class='neutral'>        view</span>
 592 |     | <span class='neutral'>        returns (</span>
 593 | *   | <span class='executed'>            uint256 initialMargin,</span>
 594 | *   | <span class='executed'>            uint256 maintenanceMargin,</span>
 595 | *   | <span class='executed'>            uint256 possibleLiquidationReward</span>
 596 |     | <span class='neutral'>        )</span>
 597 |     | <span class='neutral'>    {</span>
 598 | *   | <span class='executed'>        uint256 openPositionMarketIdsLength = self</span>
 599 |     | <span class='neutral'>            .openPositionMarketIds</span>
 600 |     | <span class='neutral'>            .length();</span>
 601 | *   | <span class='executed'>        console2.log(</span>
 602 |     | <span class='neutral'>            &quot;openPositionMarketIdsLength&quot;,</span>
 603 | *   | <span class='executed'>            openPositionMarketIdsLength</span>
 604 |     | <span class='neutral'>        );</span>
 605 |     | <span class='neutral'></span>
 606 | *   | <span class='executed'>        if (openPositionMarketIdsLength == 0) {</span>
 607 | *   | <span class='executed'>            console2.log(&quot;openPositionMarketIdsLength == 0&quot;);</span>
 608 | *   | <span class='executed'>            return (0, 0, 0);</span>
 609 |     | <span class='neutral'>        }</span>
 610 |     | <span class='neutral'></span>
 611 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= openPositionMarketIdsLength; i++) {</span>
 612 | *   | <span class='executed'>            console2.log(&quot;Loop iteration&quot;, i);</span>
 613 |     | <span class='neutral'></span>
 614 | *   | <span class='executed'>            uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();</span>
 615 | *   | <span class='executed'>            console2.log(&quot;marketId&quot;, marketId);</span>
 616 |     | <span class='neutral'></span>
 617 | *   | <span class='executed'>            Position.Data storage position = PerpsMarket</span>
 618 | *   | <span class='executed'>                .load(marketId)</span>
 619 | *   | <span class='executed'>                .positions[self.id];</span>
 620 | *   | <span class='executed'>            console2.log(&quot;position.size&quot;, position.size);</span>
 621 |     | <span class='neutral'></span>
 622 | *   | <span class='executed'>            PerpsMarketConfiguration.Data</span>
 623 | *   | <span class='executed'>                storage marketConfig = PerpsMarketConfiguration.load(marketId);</span>
 624 |     | <span class='neutral'></span>
 625 | *   | <span class='executed'>            (</span>
 626 |     | <span class='neutral'>                ,</span>
 627 |     | <span class='neutral'>                ,</span>
 628 | *   | <span class='executed'>                uint256 positionInitialMargin,</span>
 629 |     | <span class='neutral'>                uint256 positionMaintenanceMargin</span>
 630 | *   | <span class='executed'>            ) = marketConfig.calculateRequiredMargins(</span>
 631 | *   | <span class='executed'>                    position.size,</span>
 632 | *   | <span class='executed'>                    PerpsPrice.getCurrentPrice(marketId, stalenessTolerance)</span>
 633 |     | <span class='neutral'>                );</span>
 634 |     | <span class='neutral'></span>
 635 | *   | <span class='executed'>            console2.log(&quot;positionInitialMargin&quot;, positionInitialMargin);</span>
 636 | *   | <span class='executed'>            console2.log(</span>
 637 |     | <span class='neutral'>                &quot;positionMaintenanceMargin&quot;,</span>
 638 | *   | <span class='executed'>                positionMaintenanceMargin</span>
 639 |     | <span class='neutral'>            );</span>
 640 |     | <span class='neutral'></span>
 641 | *   | <span class='executed'>            maintenanceMargin += positionMaintenanceMargin;</span>
 642 | *   | <span class='executed'>            initialMargin += positionInitialMargin;</span>
 643 |     | <span class='neutral'></span>
 644 | *   | <span class='executed'>            console2.log(&quot;Running total maintenanceMargin&quot;, maintenanceMargin);</span>
 645 | *   | <span class='executed'>            console2.log(&quot;Running total initialMargin&quot;, initialMargin);</span>
 646 |     | <span class='neutral'>        }</span>
 647 |     | <span class='neutral'></span>
 648 | *   | <span class='executed'>        (</span>
 649 | *   | <span class='executed'>            uint256 accumulatedLiquidationRewards,</span>
 650 | *   | <span class='executed'>            uint256 maxNumberOfWindows</span>
 651 | *   | <span class='executed'>        ) = getKeeperRewardsAndCosts(self, 0);</span>
 652 |     | <span class='neutral'></span>
 653 | *   | <span class='executed'>        console2.log(</span>
 654 |     | <span class='neutral'>            &quot;accumulatedLiquidationRewards&quot;,</span>
 655 | *   | <span class='executed'>            accumulatedLiquidationRewards</span>
 656 |     | <span class='neutral'>        );</span>
 657 | *   | <span class='executed'>        console2.log(&quot;maxNumberOfWindows&quot;, maxNumberOfWindows);</span>
 658 |     | <span class='neutral'></span>
 659 | *   | <span class='executed'>        possibleLiquidationReward = getPossibleLiquidationReward(</span>
 660 | *   | <span class='executed'>            self,</span>
 661 | *   | <span class='executed'>            accumulatedLiquidationRewards,</span>
 662 | *   | <span class='executed'>            maxNumberOfWindows</span>
 663 |     | <span class='neutral'>        );</span>
 664 |     | <span class='neutral'></span>
 665 | *   | <span class='executed'>        console2.log(&quot;possibleLiquidationReward&quot;, possibleLiquidationReward);</span>
 666 |     | <span class='neutral'></span>
 667 | *   | <span class='executed'>        console2.log(&quot;Final initialMargin&quot;, initialMargin);</span>
 668 | *   | <span class='executed'>        console2.log(&quot;Final maintenanceMargin&quot;, maintenanceMargin);</span>
 669 | *   | <span class='executed'>        console2.log(</span>
 670 |     | <span class='neutral'>            &quot;Final possibleLiquidationReward&quot;,</span>
 671 | *   | <span class='executed'>            possibleLiquidationReward</span>
 672 |     | <span class='neutral'>        );</span>
 673 |     | <span class='neutral'></span>
 674 | *   | <span class='executed'>        return (initialMargin, maintenanceMargin, possibleLiquidationReward);</span>
 675 |     | <span class='neutral'>    }</span>
 676 | *   | <span class='executed'>    function getKeeperRewardsAndCosts(</span>
 677 |     | <span class='neutral'>        Data storage self,</span>
 678 |     | <span class='neutral'>        uint128 skipMarketId</span>
 679 |     | <span class='neutral'>    )</span>
 680 |     | <span class='neutral'>        internal</span>
 681 |     | <span class='neutral'>        view</span>
 682 |     | <span class='neutral'>        returns (</span>
 683 | *   | <span class='executed'>            uint256 accumulatedLiquidationRewards,</span>
 684 |     | <span class='neutral'>            uint256 maxNumberOfWindows</span>
 685 |     | <span class='neutral'>        )</span>
 686 |     | <span class='neutral'>    {</span>
 687 |     | <span class='neutral'>        // use separate accounting for liquidation rewards so we can compare against global min/max liquidation reward values</span>
 688 | *   | <span class='executed'>        for (uint256 i = 1; i &lt;= self.openPositionMarketIds.length(); i++) {</span>
 689 | *   | <span class='executed'>            uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();</span>
 690 | *   | <span class='executed'>            if (marketId == skipMarketId) continue;</span>
 691 | *   | <span class='executed'>            Position.Data storage position = PerpsMarket</span>
 692 | *   | <span class='executed'>                .load(marketId)</span>
 693 | *   | <span class='executed'>                .positions[self.id];</span>
 694 | *   | <span class='executed'>            PerpsMarketConfiguration.Data</span>
 695 | *   | <span class='executed'>                storage marketConfig = PerpsMarketConfiguration.load(marketId);</span>
 696 |     | <span class='neutral'></span>
 697 | *   | <span class='executed'>            uint256 numberOfWindows = marketConfig.numberOfLiquidationWindows(</span>
 698 | *   | <span class='executed'>                MathUtil.abs(position.size)</span>
 699 |     | <span class='neutral'>            );</span>
 700 |     | <span class='neutral'></span>
 701 | *   | <span class='executed'>            uint256 flagReward = marketConfig.calculateFlagReward(</span>
 702 | *   | <span class='executed'>                MathUtil.abs(position.size).mulDecimal(</span>
 703 | *   | <span class='executed'>                    PerpsPrice.getCurrentPrice(</span>
 704 | *   | <span class='executed'>                        marketId,</span>
 705 | *   | <span class='executed'>                        PerpsPrice.Tolerance.DEFAULT</span>
 706 |     | <span class='neutral'>                    )</span>
 707 |     | <span class='neutral'>                )</span>
 708 |     | <span class='neutral'>            );</span>
 709 | *   | <span class='executed'>            accumulatedLiquidationRewards += flagReward;</span>
 710 |     | <span class='neutral'></span>
 711 | *   | <span class='executed'>            maxNumberOfWindows = MathUtil.max(</span>
 712 | *   | <span class='executed'>                numberOfWindows,</span>
 713 | *   | <span class='executed'>                maxNumberOfWindows</span>
 714 |     | <span class='neutral'>            );</span>
 715 |     | <span class='neutral'>        }</span>
 716 |     | <span class='neutral'>    }</span>
 717 |     | <span class='neutral'></span>
 718 |     | <span class='neutral'>    // function getPossibleLiquidationReward(</span>
 719 |     | <span class='neutral'>    //     Data storage self,</span>
 720 |     | <span class='neutral'>    //     uint256 accumulatedLiquidationRewards,</span>
 721 |     | <span class='neutral'>    //     uint256 numOfWindows</span>
 722 |     | <span class='neutral'>    // ) internal view returns (uint256 possibleLiquidationReward) {</span>
 723 |     | <span class='neutral'>    //     GlobalPerpsMarketConfiguration.Data</span>
 724 |     | <span class='neutral'>    //         storage globalConfig = GlobalPerpsMarketConfiguration.load();</span>
 725 |     | <span class='neutral'>    //     KeeperCosts.Data storage keeperCosts = KeeperCosts.load();</span>
 726 |     | <span class='neutral'>    //     uint256 costOfFlagging = keeperCosts.getFlagKeeperCosts(self.id);</span>
 727 |     | <span class='neutral'>    //     uint256 costOfLiquidation = keeperCosts.getLiquidateKeeperCosts();</span>
 728 |     | <span class='neutral'>    //     uint256 liquidateAndFlagCost = globalConfig.keeperReward(</span>
 729 |     | <span class='neutral'>    //         accumulatedLiquidationRewards,</span>
 730 |     | <span class='neutral'>    //         costOfFlagging,</span>
 731 |     | <span class='neutral'>    //         getTotalCollateralValue(self, PerpsPrice.Tolerance.DEFAULT, false)</span>
 732 |     | <span class='neutral'>    //     );</span>
 733 |     | <span class='neutral'>    //     uint256 liquidateWindowsCosts = numOfWindows == 0</span>
 734 |     | <span class='neutral'>    //         ? 0</span>
 735 |     | <span class='neutral'>    //         : globalConfig.keeperReward(0, costOfLiquidation, 0) *</span>
 736 |     | <span class='neutral'>    //             (numOfWindows - 1);</span>
 737 |     | <span class='neutral'></span>
 738 |     | <span class='neutral'>    //     possibleLiquidationReward =</span>
 739 |     | <span class='neutral'>    //         liquidateAndFlagCost +</span>
 740 |     | <span class='neutral'>    //         liquidateWindowsCosts;</span>
 741 |     | <span class='neutral'>    // }</span>
 742 |     | <span class='neutral'></span>
 743 | *   | <span class='executed'>    function getPossibleLiquidationReward(</span>
 744 |     | <span class='neutral'>        Data storage self,</span>
 745 |     | <span class='neutral'>        uint256 accumulatedLiquidationRewards,</span>
 746 |     | <span class='neutral'>        uint256 numOfWindows</span>
 747 | *   | <span class='executed'>    ) internal view returns (uint256 possibleLiquidationReward) {</span>
 748 | *   | <span class='executed'>        console2.log(</span>
 749 |     | <span class='neutral'>            &quot;accumulatedLiquidationRewards&quot;,</span>
 750 | *   | <span class='executed'>            accumulatedLiquidationRewards</span>
 751 |     | <span class='neutral'>        );</span>
 752 | *   | <span class='executed'>        console2.log(&quot;numOfWindows&quot;, numOfWindows);</span>
 753 |     | <span class='neutral'></span>
 754 | *   | <span class='executed'>        GlobalPerpsMarketConfiguration.Data</span>
 755 | *   | <span class='executed'>            storage globalConfig = GlobalPerpsMarketConfiguration.load();</span>
 756 |     | <span class='neutral'></span>
 757 | *   | <span class='executed'>        KeeperCosts.Data storage keeperCosts = KeeperCosts.load();</span>
 758 |     | <span class='neutral'></span>
 759 | *   | <span class='executed'>        uint256 costOfFlagging = keeperCosts.getFlagKeeperCosts(self.id);</span>
 760 | *   | <span class='executed'>        console2.log(&quot;costOfFlagging&quot;, costOfFlagging);</span>
 761 |     | <span class='neutral'></span>
 762 | *   | <span class='executed'>        uint256 costOfLiquidation = keeperCosts.getLiquidateKeeperCosts();</span>
 763 | *   | <span class='executed'>        console2.log(&quot;costOfLiquidation&quot;, costOfLiquidation);</span>
 764 |     | <span class='neutral'></span>
 765 | *   | <span class='executed'>        uint256 totalCollateralValue = getTotalCollateralValue(</span>
 766 | *   | <span class='executed'>            self,</span>
 767 | *   | <span class='executed'>            PerpsPrice.Tolerance.DEFAULT,</span>
 768 | *   | <span class='executed'>            false</span>
 769 |     | <span class='neutral'>        );</span>
 770 | *   | <span class='executed'>        console2.log(&quot;totalCollateralValue&quot;, totalCollateralValue);</span>
 771 |     | <span class='neutral'></span>
 772 | *   | <span class='executed'>        uint256 liquidateAndFlagCost = globalConfig.keeperReward(</span>
 773 | *   | <span class='executed'>            accumulatedLiquidationRewards,</span>
 774 | *   | <span class='executed'>            costOfFlagging,</span>
 775 | *   | <span class='executed'>            totalCollateralValue</span>
 776 |     | <span class='neutral'>        );</span>
 777 | *   | <span class='executed'>        console2.log(&quot;liquidateAndFlagCost&quot;, liquidateAndFlagCost);</span>
 778 |     | <span class='neutral'></span>
 779 | *   | <span class='executed'>        uint256 liquidateWindowsCosts = numOfWindows == 0</span>
 780 |     | <span class='unexecuted'>            ? 0</span>
 781 | *   | <span class='executed'>            : globalConfig.keeperReward(0, costOfLiquidation, 0) *</span>
 782 | *   | <span class='executed'>                (numOfWindows - 1);</span>
 783 | *   | <span class='executed'>        console2.log(&quot;liquidateWindowsCosts&quot;, liquidateWindowsCosts);</span>
 784 |     | <span class='neutral'></span>
 785 | *   | <span class='executed'>        possibleLiquidationReward =</span>
 786 | *   | <span class='executed'>            liquidateAndFlagCost +</span>
 787 | *   | <span class='executed'>            liquidateWindowsCosts;</span>
 788 | *   | <span class='executed'>        console2.log(&quot;possibleLiquidationReward&quot;, possibleLiquidationReward);</span>
 789 |     | <span class='neutral'></span>
 790 | *   | <span class='executed'>        return possibleLiquidationReward;</span>
 791 |     | <span class='neutral'>    }</span>
 792 |     | <span class='neutral'></span>
 793 | *   | <span class='executed'>    function transferAllCollateral(</span>
 794 |     | <span class='neutral'>        Data storage self</span>
 795 | *   | <span class='executed'>    ) internal returns (uint256 seizedCollateralValue) {</span>
 796 | *   | <span class='executed'>        uint256[] memory activeCollateralTypes = self</span>
 797 |     | <span class='neutral'>            .activeCollateralTypes</span>
 798 |     | <span class='neutral'>            .values();</span>
 799 |     | <span class='neutral'></span>
 800 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; activeCollateralTypes.length; i++) {</span>
 801 | *   | <span class='executed'>            uint128 collateralId = activeCollateralTypes[i].to128();</span>
 802 | *   | <span class='executed'>            if (collateralId == SNX_USD_MARKET_ID) {</span>
 803 | *   | <span class='executed'>                seizedCollateralValue += self.collateralAmounts[collateralId];</span>
 804 |     | <span class='neutral'>            } else {</span>
 805 |     | <span class='neutral'>                // transfer to liquidation asset manager</span>
 806 | *   | <span class='executed'>                seizedCollateralValue += PerpsMarketFactory</span>
 807 |     | <span class='neutral'>                    .load()</span>
 808 |     | <span class='neutral'>                    .transferLiquidatedSynth(</span>
 809 | *   | <span class='executed'>                        collateralId,</span>
 810 | *   | <span class='executed'>                        self.collateralAmounts[collateralId]</span>
 811 |     | <span class='neutral'>                    );</span>
 812 |     | <span class='neutral'>            }</span>
 813 |     | <span class='neutral'></span>
 814 | *   | <span class='executed'>            updateCollateralAmount(</span>
 815 | *   | <span class='executed'>                self,</span>
 816 | *   | <span class='executed'>                collateralId,</span>
 817 | *   | <span class='executed'>                -(self.collateralAmounts[collateralId].toInt())</span>
 818 |     | <span class='neutral'>            );</span>
 819 |     | <span class='neutral'>        }</span>
 820 |     | <span class='neutral'>    }</span>
 821 |     | <span class='neutral'></span>
 822 | *   | <span class='executed'>    function liquidatePosition(</span>
 823 |     | <span class='neutral'>        Data storage self,</span>
 824 |     | <span class='neutral'>        uint128 marketId,</span>
 825 |     | <span class='neutral'>        uint256 price</span>
 826 |     | <span class='neutral'>    )</span>
 827 |     | <span class='neutral'>        internal</span>
 828 |     | <span class='neutral'>        returns (</span>
 829 | *   | <span class='executed'>            uint128 amountToLiquidate,</span>
 830 | *   | <span class='executed'>            int128 newPositionSize,</span>
 831 | *   | <span class='executed'>            int128 sizeDelta,</span>
 832 | *   | <span class='executed'>            uint128 oldPositionAbsSize,</span>
 833 | *   | <span class='executed'>            MarketUpdate.Data memory marketUpdateData</span>
 834 |     | <span class='neutral'>        )</span>
 835 |     | <span class='neutral'>    {</span>
 836 | *   | <span class='executed'>        PerpsMarket.Data storage perpsMarket = PerpsMarket.load(marketId);</span>
 837 | *   | <span class='executed'>        Position.Data storage position = perpsMarket.positions[self.id];</span>
 838 |     | <span class='neutral'></span>
 839 | *   | <span class='executed'>        perpsMarket.recomputeFunding(price);</span>
 840 |     | <span class='neutral'></span>
 841 | *   | <span class='executed'>        int128 oldPositionSize = position.size;</span>
 842 | *   | <span class='executed'>        oldPositionAbsSize = MathUtil.abs128(oldPositionSize);</span>
 843 | *   | <span class='executed'>        amountToLiquidate = perpsMarket.maxLiquidatableAmount(</span>
 844 |     | <span class='neutral'>            oldPositionAbsSize</span>
 845 |     | <span class='neutral'>        );</span>
 846 |     | <span class='neutral'></span>
 847 | *   | <span class='executed'>        if (amountToLiquidate == 0) {</span>
 848 | *   | <span class='executed'>            return (</span>
 849 | *   | <span class='executed'>                0,</span>
 850 | *   | <span class='executed'>                oldPositionSize,</span>
 851 |     | <span class='neutral'>                0,</span>
 852 |     | <span class='neutral'>                oldPositionAbsSize,</span>
 853 |     | <span class='neutral'>                marketUpdateData</span>
 854 |     | <span class='neutral'>            );</span>
 855 |     | <span class='neutral'>        }</span>
 856 |     | <span class='neutral'></span>
 857 | *   | <span class='executed'>        int128 amtToLiquidationInt = amountToLiquidate.toInt();</span>
 858 |     | <span class='neutral'>        // reduce position size</span>
 859 | *   | <span class='executed'>        newPositionSize = oldPositionSize &gt; 0</span>
 860 | *   | <span class='executed'>            ? oldPositionSize - amtToLiquidationInt</span>
 861 | *   | <span class='executed'>            : oldPositionSize + amtToLiquidationInt;</span>
 862 |     | <span class='neutral'></span>
 863 |     | <span class='neutral'>        // create new position in case of partial liquidation</span>
 864 |     | <span class='neutral'>        Position.Data memory newPosition;</span>
 865 | *   | <span class='executed'>        if (newPositionSize != 0) {</span>
 866 | *   | <span class='executed'>            newPosition = Position.Data({</span>
 867 | *   | <span class='executed'>                marketId: marketId,</span>
 868 | *   | <span class='executed'>                latestInteractionPrice: price.to128(),</span>
 869 | *   | <span class='executed'>                latestInteractionFunding: perpsMarket.lastFundingValue.to128(),</span>
 870 | *   | <span class='executed'>                latestInterestAccrued: 0,</span>
 871 | *   | <span class='executed'>                size: newPositionSize</span>
 872 |     | <span class='neutral'>            });</span>
 873 |     | <span class='neutral'>        }</span>
 874 |     | <span class='neutral'></span>
 875 |     | <span class='neutral'>        // update position markets</span>
 876 | *   | <span class='executed'>        updateOpenPositions(self, marketId, newPositionSize);</span>
 877 |     | <span class='neutral'></span>
 878 |     | <span class='neutral'>        // update market data</span>
 879 | *   | <span class='executed'>        marketUpdateData = perpsMarket.updatePositionData(self.id, newPosition);</span>
 880 | *   | <span class='executed'>        sizeDelta = newPositionSize - oldPositionSize;</span>
 881 |     | <span class='neutral'></span>
 882 | *   | <span class='executed'>        return (</span>
 883 |     | <span class='neutral'>            amountToLiquidate,</span>
 884 |     | <span class='neutral'>            newPositionSize,</span>
 885 |     | <span class='neutral'>            sizeDelta,</span>
 886 |     | <span class='neutral'>            oldPositionAbsSize,</span>
 887 |     | <span class='neutral'>            marketUpdateData</span>
 888 |     | <span class='neutral'>        );</span>
 889 |     | <span class='neutral'>    }</span>
 890 |     | <span class='neutral'></span>
 891 | *   | <span class='executed'>    function hasOpenPositions(Data storage self) internal view returns (bool) {</span>
 892 | *   | <span class='executed'>        return self.openPositionMarketIds.length() &gt; 0;</span>
 893 |     | <span class='neutral'>    }</span>
 894 |     | <span class='neutral'>}</span>
 895 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsCollateralConfiguration.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
   6 |     | <span class='neutral'>import {PerpsPrice} from &quot;./PerpsPrice.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Price} from &quot;@synthetixio/spot-market/contracts/storage/Price.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ISpotMarketSystem} from &quot;../interfaces/external/ISpotMarketSystem.sol&quot;;</span>
   9 |     | <span class='neutral'>import {LiquidationAssetManager} from &quot;./LiquidationAssetManager.sol&quot;;</span>
  10 |     | <span class='neutral'>import {SNX_USD_MARKET_ID} from &quot;./PerpsAccount.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @title Configuration of all multi collateral assets used for trader margin</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='unexecuted'>library PerpsCollateralConfiguration {</span>
  16 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @notice Thrown when attempting to access a not registered id</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='neutral'>    error InvalidId(uint128 id);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    struct Data {</span>
  24 |     | <span class='neutral'>        /**</span>
  25 |     | <span class='neutral'>         * @dev Collateral Id</span>
  26 |     | <span class='neutral'>         */</span>
  27 |     | <span class='neutral'>        uint128 id;</span>
  28 |     | <span class='neutral'>        /**</span>
  29 |     | <span class='neutral'>         * @dev Max amount of collateral that can be used for margin</span>
  30 |     | <span class='neutral'>         */</span>
  31 |     | <span class='neutral'>        uint256 maxAmount;</span>
  32 |     | <span class='neutral'>        /**</span>
  33 |     | <span class='neutral'>         * @dev Collateral value is discounted and capped at this value.  In % units.</span>
  34 |     | <span class='neutral'>         */</span>
  35 |     | <span class='neutral'>        uint256 upperLimitDiscount;</span>
  36 |     | <span class='neutral'>        /**</span>
  37 |     | <span class='neutral'>         * @dev Collateral value is discounted and at minimum, this value.  In % units.</span>
  38 |     | <span class='neutral'>         */</span>
  39 |     | <span class='neutral'>        uint256 lowerLimitDiscount;</span>
  40 |     | <span class='neutral'>        /**</span>
  41 |     | <span class='neutral'>         * @dev This value is used to scale the impactOnSkew of the collateral.</span>
  42 |     | <span class='neutral'>         */</span>
  43 |     | <span class='neutral'>        uint256 discountScalar;</span>
  44 |     | <span class='neutral'>        /**</span>
  45 |     | <span class='neutral'>         * @dev Liquidation Asset Manager data. (see LiquidationAssetManager.Data struct).</span>
  46 |     | <span class='neutral'>         */</span>
  47 |     | <span class='neutral'>        LiquidationAssetManager.Data lam;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @dev Load the collateral configuration data using collateral/synth id</span>
  52 |     | <span class='neutral'>     */</span>
  53 | *   | <span class='executed'>    function load(uint128 collateralId) internal pure returns (Data storage collateralConfig) {</span>
  54 | *   | <span class='executed'>        bytes32 s = keccak256(</span>
  55 | *   | <span class='executed'>            abi.encode(&quot;io.synthetix.perps-market.CollateralConfiguration&quot;, collateralId)</span>
  56 |     | <span class='neutral'>        );</span>
  57 |     | <span class='neutral'>        assembly {</span>
  58 |     | <span class='neutral'>            collateralConfig.slot := s</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Load a valid collateral configuration data using collateral/synth id</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='unexecuted'>    function loadValid(uint128 collateralId) internal view returns (Data storage collateralConfig) {</span>
  66 |     | <span class='unexecuted'>        collateralConfig = load(collateralId);</span>
  67 |     | <span class='unexecuted'>        if (collateralConfig.id == 0) {</span>
  68 |     | <span class='unexecuted'>            revert InvalidId(collateralId);</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Load a valid  collateral LiquidationAssetManager configuration data using collateral/synth id</span>
  74 |     | <span class='neutral'>     */</span>
  75 | *   | <span class='executed'>    function loadValidLam(</span>
  76 |     | <span class='neutral'>        uint128 collateralId</span>
  77 | *   | <span class='executed'>    ) internal view returns (LiquidationAssetManager.Data storage collateralLAMConfig) {</span>
  78 | *   | <span class='executed'>        collateralLAMConfig = load(collateralId).lam;</span>
  79 | *   | <span class='executed'>        if (collateralLAMConfig.id == 0) {</span>
  80 |     | <span class='unexecuted'>            revert InvalidId(collateralId);</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>    function validDistributorExists(uint128 collateralId) internal view returns (bool) {</span>
  85 | *   | <span class='executed'>        return</span>
  86 | *   | <span class='executed'>            (collateralId == SNX_USD_MARKET_ID) ||</span>
  87 | *   | <span class='executed'>            (loadValidLam(collateralId).distributor != address(0));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function setMax(Data storage self, uint128 collateralId, uint256 maxAmount) internal {</span>
  91 |     | <span class='unexecuted'>        if (self.id == 0) self.id = collateralId;</span>
  92 |     | <span class='unexecuted'>        self.maxAmount = maxAmount;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function setDiscounts(</span>
  96 |     | <span class='neutral'>        Data storage self,</span>
  97 |     | <span class='neutral'>        uint256 upperLimitDiscount,</span>
  98 |     | <span class='neutral'>        uint256 lowerLimitDiscount,</span>
  99 |     | <span class='neutral'>        uint256 discountScalar</span>
 100 |     | <span class='neutral'>    ) internal {</span>
 101 |     | <span class='unexecuted'>        self.upperLimitDiscount = upperLimitDiscount;</span>
 102 |     | <span class='unexecuted'>        self.lowerLimitDiscount = lowerLimitDiscount;</span>
 103 |     | <span class='unexecuted'>        self.discountScalar = discountScalar;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function getConfig(</span>
 107 |     | <span class='neutral'>        Data storage self</span>
 108 |     | <span class='neutral'>    )</span>
 109 |     | <span class='neutral'>        internal</span>
 110 |     | <span class='neutral'>        view</span>
 111 |     | <span class='neutral'>        returns (</span>
 112 |     | <span class='neutral'>            uint256 maxAmount,</span>
 113 |     | <span class='neutral'>            uint256 upperLimitDiscount,</span>
 114 |     | <span class='neutral'>            uint256 lowerLimitDiscount,</span>
 115 |     | <span class='neutral'>            uint256 discountScalar</span>
 116 |     | <span class='neutral'>        )</span>
 117 |     | <span class='neutral'>    {</span>
 118 |     | <span class='unexecuted'>        maxAmount = self.maxAmount;</span>
 119 |     | <span class='unexecuted'>        upperLimitDiscount = self.upperLimitDiscount;</span>
 120 |     | <span class='unexecuted'>        lowerLimitDiscount = self.lowerLimitDiscount;</span>
 121 |     | <span class='unexecuted'>        discountScalar = self.discountScalar;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function isSupported(Data storage self) internal view returns (bool) {</span>
 125 |     | <span class='neutral'>        return self.maxAmount != 0;</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>    function valueInUsd(</span>
 129 |     | <span class='neutral'>        Data storage self,</span>
 130 |     | <span class='neutral'>        uint256 amount,</span>
 131 |     | <span class='neutral'>        ISpotMarketSystem spotMarket,</span>
 132 |     | <span class='neutral'>        PerpsPrice.Tolerance stalenessTolerance,</span>
 133 |     | <span class='neutral'>        bool useDiscount</span>
 134 | *   | <span class='executed'>    ) internal view returns (uint256 collateralValueInUsd, uint256 discount) {</span>
 135 | *   | <span class='executed'>        uint256 skewScale = spotMarket.getMarketSkewScale(self.id);</span>
 136 |     | <span class='neutral'>        // only discount collateral if skew scale is set on spot market and useDiscount is set to true</span>
 137 | *   | <span class='executed'>        if (useDiscount &amp;&amp; skewScale != 0) {</span>
 138 | *   | <span class='executed'>            uint256 impactOnSkew = amount.divDecimal(skewScale).mulDecimal(self.discountScalar);</span>
 139 | *   | <span class='executed'>            discount = (</span>
 140 | *   | <span class='executed'>                MathUtil.max(</span>
 141 | *   | <span class='executed'>                    MathUtil.min(impactOnSkew, self.lowerLimitDiscount),</span>
 142 | *   | <span class='executed'>                    self.upperLimitDiscount</span>
 143 |     | <span class='neutral'>                )</span>
 144 |     | <span class='neutral'>            );</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>        // first get value of collateral in usd</span>
 147 | *   | <span class='executed'>        uint128 sellTxnType = 2;</span>
 148 | *   | <span class='executed'>        uint256 collateralPrice = spotMarket.indexPrice(</span>
 149 | *   | <span class='executed'>            self.id,</span>
 150 |     | <span class='neutral'>            sellTxnType,</span>
 151 | *   | <span class='executed'>            Price.Tolerance(uint256(stalenessTolerance)) // solhint-disable-line numcast/safe-cast</span>
 152 |     | <span class='neutral'>        );</span>
 153 | *   | <span class='executed'>        uint256 valueWithoutDiscount = amount.mulDecimal(collateralPrice);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        // if discount is 0, this just gets multiplied by 1</span>
 156 | *   | <span class='executed'>        collateralValueInUsd = valueWithoutDiscount.mulDecimal(DecimalMath.UNIT - discount);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'>}</span>
 159 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsMarket.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC2771Context} from &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
   5 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeCastU256, SafeCastI256, SafeCastU128} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Position} from &quot;./Position.sol&quot;;</span>
   8 |     | <span class='neutral'>import {AsyncOrder} from &quot;./AsyncOrder.sol&quot;;</span>
   9 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;./PerpsMarketConfiguration.sol&quot;;</span>
  10 |     | <span class='neutral'>import {MarketUpdate} from &quot;./MarketUpdate.sol&quot;;</span>
  11 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
  12 |     | <span class='neutral'>import {PerpsPrice} from &quot;./PerpsPrice.sol&quot;;</span>
  13 |     | <span class='neutral'>import {Liquidation} from &quot;./Liquidation.sol&quot;;</span>
  14 |     | <span class='neutral'>import {KeeperCosts} from &quot;./KeeperCosts.sol&quot;;</span>
  15 |     | <span class='neutral'>import {InterestRate} from &quot;./InterestRate.sol&quot;;</span>
  16 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/**</span>
  19 |     | <span class='neutral'> * @title Data for a single perps market</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='unexecuted'>library PerpsMarket {</span>
  22 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  23 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  24 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  25 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  26 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  27 |     | <span class='neutral'>    using Position for Position.Data;</span>
  28 |     | <span class='neutral'>    using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @notice Thrown when attempting to create a market that already exists or invalid id was passed in</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    error InvalidMarket(uint128 marketId);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @notice Thrown when attempting to load a market without a configured price feed</span>
  37 |     | <span class='neutral'>     */</span>
  38 |     | <span class='neutral'>    error PriceFeedNotSet(uint128 marketId);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @notice Thrown when attempting to load a market without a configured keeper costs</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    error KeeperCostsNotSet();</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct Data {</span>
  46 |     | <span class='neutral'>        string name;</span>
  47 |     | <span class='neutral'>        string symbol;</span>
  48 |     | <span class='neutral'>        uint128 id;</span>
  49 |     | <span class='neutral'>        int256 skew;</span>
  50 |     | <span class='neutral'>        uint256 size;</span>
  51 |     | <span class='neutral'>        int256 lastFundingRate;</span>
  52 |     | <span class='neutral'>        int256 lastFundingValue;</span>
  53 |     | <span class='neutral'>        uint256 lastFundingTime;</span>
  54 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
  55 |     | <span class='neutral'>        uint128 __unused_1;</span>
  56 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
  57 |     | <span class='neutral'>        uint128 __unused_2;</span>
  58 |     | <span class='neutral'>        // debt calculation</span>
  59 |     | <span class='neutral'>        // accumulates total notional size of the market including accrued funding until the last time any position changed</span>
  60 |     | <span class='neutral'>        int256 debtCorrectionAccumulator;</span>
  61 |     | <span class='neutral'>        // accountId =&gt; asyncOrder</span>
  62 |     | <span class='neutral'>        mapping(uint256 =&gt; AsyncOrder.Data) asyncOrders;</span>
  63 |     | <span class='neutral'>        // accountId =&gt; position</span>
  64 |     | <span class='neutral'>        mapping(uint256 =&gt; Position.Data) positions;</span>
  65 |     | <span class='neutral'>        // liquidation amounts</span>
  66 |     | <span class='neutral'>        Liquidation.Data[] liquidationData;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    function load(</span>
  70 |     | <span class='neutral'>        uint128 marketId</span>
  71 | *   | <span class='executed'>    ) internal pure returns (Data storage market) {</span>
  72 | *   | <span class='executed'>        bytes32 s = keccak256(</span>
  73 | *   | <span class='executed'>            abi.encode(&quot;io.synthetix.perps-market.PerpsMarket&quot;, marketId)</span>
  74 |     | <span class='neutral'>        );</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        assembly {</span>
  77 |     | <span class='neutral'>            market.slot := s</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function createValid(</span>
  82 |     | <span class='neutral'>        uint128 id,</span>
  83 |     | <span class='neutral'>        string memory name,</span>
  84 |     | <span class='neutral'>        string memory symbol</span>
  85 |     | <span class='unexecuted'>    ) internal returns (Data storage market) {</span>
  86 |     | <span class='unexecuted'>        if (id == 0 || load(id).id == id) {</span>
  87 |     | <span class='unexecuted'>            revert InvalidMarket(id);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        market = load(id);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        market.id = id;</span>
  93 |     | <span class='unexecuted'>        market.name = name;</span>
  94 |     | <span class='unexecuted'>        market.symbol = symbol;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @dev Reverts if the market does not exist with appropriate error. Otherwise, returns the market.</span>
  99 |     | <span class='neutral'>     */</span>
 100 | *   | <span class='executed'>    function loadValid(</span>
 101 |     | <span class='neutral'>        uint128 marketId</span>
 102 | *   | <span class='executed'>    ) internal view returns (Data storage market) {</span>
 103 | *   | <span class='executed'>        market = load(marketId);</span>
 104 | *   | <span class='executed'>        if (market.id == 0) {</span>
 105 |     | <span class='unexecuted'>            revert InvalidMarket(marketId);</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'></span>
 108 | *   | <span class='executed'>        if (PerpsPrice.load(marketId).feedId == &quot;&quot;) {</span>
 109 |     | <span class='unexecuted'>            revert PriceFeedNotSet(marketId);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>        if (KeeperCosts.load().keeperCostNodeId == &quot;&quot;) {</span>
 113 |     | <span class='unexecuted'>            revert KeeperCostsNotSet();</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @dev Returns the max amount of liquidation that can occur based on the market configuration</span>
 119 |     | <span class='neutral'>     * @notice Based on the configured liquidation window, a trader can only be liquidated for a certain</span>
 120 |     | <span class='neutral'>     *   amount within that window.  If the amount requested is greater than the amount allowed, the</span>
 121 |     | <span class='neutral'>     *   smaller amount is returned.  The function also updates its accounting to ensure the results on</span>
 122 |     | <span class='neutral'>     *   subsequent liquidations work appropriately.</span>
 123 |     | <span class='neutral'>     */</span>
 124 | *   | <span class='executed'>    function maxLiquidatableAmount(</span>
 125 |     | <span class='neutral'>        Data storage self,</span>
 126 |     | <span class='neutral'>        uint128 requestedLiquidationAmount</span>
 127 | *   | <span class='executed'>    ) internal returns (uint128 liquidatableAmount) {</span>
 128 | *   | <span class='executed'>        PerpsMarketConfiguration.Data</span>
 129 | *   | <span class='executed'>            storage marketConfig = PerpsMarketConfiguration.load(self.id);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>        // if endorsedLiquidator is configured and is the sender, allow full liquidation</span>
 132 | *   | <span class='executed'>        if (ERC2771Context._msgSender() == marketConfig.endorsedLiquidator) {</span>
 133 |     | <span class='unexecuted'>            _updateLiquidationData(self, requestedLiquidationAmount);</span>
 134 |     | <span class='unexecuted'>            return requestedLiquidationAmount;</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>        (</span>
 138 | *   | <span class='executed'>            uint256 liquidationCapacity,</span>
 139 | *   | <span class='executed'>            uint256 maxLiquidationInWindow,</span>
 140 | *   | <span class='executed'>            uint256 latestLiquidationTimestamp</span>
 141 | *   | <span class='executed'>        ) = currentLiquidationCapacity(self, marketConfig);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // this would only occur if there was a misconfiguration (like skew scale not being set)</span>
 144 |     | <span class='neutral'>        // or the max liquidation window not being set etc.</span>
 145 |     | <span class='neutral'>        // in this case, return the entire requested liquidation amount</span>
 146 | *   | <span class='executed'>        if (maxLiquidationInWindow == 0) {</span>
 147 |     | <span class='unexecuted'>            return requestedLiquidationAmount;</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='neutral'></span>
 150 | *   | <span class='executed'>        uint256 maxLiquidationPd = marketConfig.maxLiquidationPd;</span>
 151 |     | <span class='neutral'>        // if liquidation capacity exists, update accordingly</span>
 152 | *   | <span class='executed'>        if (liquidationCapacity != 0) {</span>
 153 | *   | <span class='executed'>            liquidatableAmount = MathUtil.min128(</span>
 154 | *   | <span class='executed'>                liquidationCapacity.to128(),</span>
 155 | *   | <span class='executed'>                requestedLiquidationAmount</span>
 156 |     | <span class='neutral'>            );</span>
 157 | *   | <span class='executed'>        } else if (</span>
 158 | *   | <span class='executed'>            maxLiquidationPd != 0 &amp;&amp;</span>
 159 |     | <span class='neutral'>            // only allow this if the last update was not in the current block</span>
 160 |     | <span class='unexecuted'>            latestLiquidationTimestamp != block.timestamp</span>
 161 |     | <span class='unexecuted'>        ) {</span>
 162 |     | <span class='neutral'>            /**</span>
 163 |     | <span class='neutral'>                if capacity is at 0, but the market is under configured liquidation p/d,</span>
 164 |     | <span class='neutral'>                another block of liquidation becomes allowable.</span>
 165 |     | <span class='neutral'>             */</span>
 166 | *   | <span class='executed'>            uint256 currentPd = MathUtil.abs(self.skew).divDecimal(</span>
 167 |     | <span class='unexecuted'>                marketConfig.skewScale</span>
 168 |     | <span class='neutral'>            );</span>
 169 |     | <span class='unexecuted'>            if (currentPd &lt; maxLiquidationPd) {</span>
 170 |     | <span class='unexecuted'>                liquidatableAmount = MathUtil.min128(</span>
 171 |     | <span class='unexecuted'>                    maxLiquidationInWindow.to128(),</span>
 172 |     | <span class='unexecuted'>                    requestedLiquidationAmount</span>
 173 |     | <span class='neutral'>                );</span>
 174 |     | <span class='neutral'>            }</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'></span>
 177 | *   | <span class='executed'>        if (liquidatableAmount &gt; 0) {</span>
 178 | *   | <span class='executed'>            _updateLiquidationData(self, liquidatableAmount);</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 | *   | <span class='executed'>    function _updateLiquidationData(</span>
 183 |     | <span class='neutral'>        Data storage self,</span>
 184 |     | <span class='neutral'>        uint128 liquidationAmount</span>
 185 | *   | <span class='executed'>    ) private {</span>
 186 | *   | <span class='executed'>        uint256 liquidationDataLength = self.liquidationData.length;</span>
 187 | *   | <span class='executed'>        uint256 currentTimestamp = liquidationDataLength == 0</span>
 188 | *   | <span class='executed'>            ? 0</span>
 189 | *   | <span class='executed'>            : self.liquidationData[liquidationDataLength - 1].timestamp;</span>
 190 |     | <span class='neutral'></span>
 191 | *   | <span class='executed'>        if (currentTimestamp == block.timestamp) {</span>
 192 | *   | <span class='executed'>            self</span>
 193 | *   | <span class='executed'>                .liquidationData[liquidationDataLength - 1]</span>
 194 | *   | <span class='executed'>                .amount += liquidationAmount;</span>
 195 |     | <span class='neutral'>        } else {</span>
 196 | *   | <span class='executed'>            self.liquidationData.push(</span>
 197 | *   | <span class='executed'>                Liquidation.Data({</span>
 198 |     | <span class='neutral'>                    amount: liquidationAmount,</span>
 199 | *   | <span class='executed'>                    timestamp: block.timestamp</span>
 200 |     | <span class='neutral'>                })</span>
 201 |     | <span class='neutral'>            );</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    /**</span>
 206 |     | <span class='neutral'>     * @dev Returns the current liquidation capacity for the market</span>
 207 |     | <span class='neutral'>     * @notice This function sums up the liquidation amounts in the current liquidation window</span>
 208 |     | <span class='neutral'>     * and returns the capacity left.</span>
 209 |     | <span class='neutral'>     */</span>
 210 |     | <span class='neutral'>    // function currentLiquidationCapacity(</span>
 211 |     | <span class='neutral'>    //     Data storage self,</span>
 212 |     | <span class='neutral'>    //     PerpsMarketConfiguration.Data storage marketConfig</span>
 213 |     | <span class='neutral'>    // )</span>
 214 |     | <span class='neutral'>    //     internal</span>
 215 |     | <span class='neutral'>    //     view</span>
 216 |     | <span class='neutral'>    //     returns (</span>
 217 |     | <span class='neutral'>    //         uint256 capacity,</span>
 218 |     | <span class='neutral'>    //         uint256 maxLiquidationInWindow,</span>
 219 |     | <span class='neutral'>    //         uint256 latestLiquidationTimestamp</span>
 220 |     | <span class='neutral'>    //     )</span>
 221 |     | <span class='neutral'>    // {</span>
 222 |     | <span class='neutral'>    //     maxLiquidationInWindow = marketConfig.maxLiquidationAmountInWindow();</span>
 223 |     | <span class='neutral'>    //     uint256 accumulatedLiquidationAmounts;</span>
 224 |     | <span class='neutral'>    //     uint256 liquidationDataLength = self.liquidationData.length;</span>
 225 |     | <span class='neutral'>    //     if (liquidationDataLength == 0)</span>
 226 |     | <span class='neutral'>    //         return (maxLiquidationInWindow, maxLiquidationInWindow, 0);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    //     uint256 currentIndex = liquidationDataLength - 1;</span>
 229 |     | <span class='neutral'>    //     latestLiquidationTimestamp = self</span>
 230 |     | <span class='neutral'>    //         .liquidationData[currentIndex]</span>
 231 |     | <span class='neutral'>    //         .timestamp;</span>
 232 |     | <span class='neutral'>    //     uint256 windowStartTimestamp = block.timestamp -</span>
 233 |     | <span class='neutral'>    //         marketConfig.maxSecondsInLiquidationWindow;</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    //     while (</span>
 236 |     | <span class='neutral'>    //         self.liquidationData[currentIndex].timestamp &gt; windowStartTimestamp</span>
 237 |     | <span class='neutral'>    //     ) {</span>
 238 |     | <span class='neutral'>    //         accumulatedLiquidationAmounts += self</span>
 239 |     | <span class='neutral'>    //             .liquidationData[currentIndex]</span>
 240 |     | <span class='neutral'>    //             .amount;</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    //         if (currentIndex == 0) break;</span>
 243 |     | <span class='neutral'>    //         currentIndex--;</span>
 244 |     | <span class='neutral'>    //     }</span>
 245 |     | <span class='neutral'>    //     int256 availableLiquidationCapacity = maxLiquidationInWindow.toInt() -</span>
 246 |     | <span class='neutral'>    //         accumulatedLiquidationAmounts.toInt();</span>
 247 |     | <span class='neutral'>    //     // solhint-disable-next-line numcast/safe-cast</span>
 248 |     | <span class='neutral'>    //     capacity = MathUtil</span>
 249 |     | <span class='neutral'>    //         .max(availableLiquidationCapacity, int256(0))</span>
 250 |     | <span class='neutral'>    //         .toUint();</span>
 251 |     | <span class='neutral'>    // }</span>
 252 |     | <span class='neutral'></span>
 253 | *   | <span class='executed'>    function currentLiquidationCapacity(</span>
 254 |     | <span class='neutral'>        Data storage self,</span>
 255 |     | <span class='neutral'>        PerpsMarketConfiguration.Data storage marketConfig</span>
 256 |     | <span class='neutral'>    )</span>
 257 |     | <span class='neutral'>        internal</span>
 258 |     | <span class='neutral'>        view</span>
 259 |     | <span class='neutral'>        returns (</span>
 260 | *   | <span class='executed'>            uint256 capacity,</span>
 261 | *   | <span class='executed'>            uint256 maxLiquidationInWindow,</span>
 262 | *   | <span class='executed'>            uint256 latestLiquidationTimestamp</span>
 263 |     | <span class='neutral'>        )</span>
 264 | *   | <span class='executed'>    {</span>
 265 | *   | <span class='executed'>        maxLiquidationInWindow = marketConfig.maxLiquidationAmountInWindow();</span>
 266 | *   | <span class='executed'>        console2.log(&quot;maxLiquidationInWindow&quot;, maxLiquidationInWindow);</span>
 267 |     | <span class='neutral'></span>
 268 | *   | <span class='executed'>        uint256 accumulatedLiquidationAmounts;</span>
 269 | *   | <span class='executed'>        console2.log(</span>
 270 |     | <span class='neutral'>            &quot;accumulatedLiquidationAmounts&quot;,</span>
 271 | *   | <span class='executed'>            accumulatedLiquidationAmounts</span>
 272 |     | <span class='neutral'>        );</span>
 273 |     | <span class='neutral'></span>
 274 | *   | <span class='executed'>        uint256 liquidationDataLength = self.liquidationData.length;</span>
 275 | *   | <span class='executed'>        console2.log(&quot;liquidationDataLength&quot;, liquidationDataLength);</span>
 276 |     | <span class='neutral'></span>
 277 | *   | <span class='executed'>        if (liquidationDataLength == 0) {</span>
 278 | *   | <span class='executed'>            console2.log(&quot;capacity&quot;, maxLiquidationInWindow);</span>
 279 | *   | <span class='executed'>            console2.log(&quot;maxLiquidationInWindow&quot;, maxLiquidationInWindow);</span>
 280 | *   | <span class='executed'>            return (maxLiquidationInWindow, maxLiquidationInWindow, 0);</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'></span>
 283 | *   | <span class='executed'>        uint256 currentIndex = liquidationDataLength - 1;</span>
 284 | *   | <span class='executed'>        console2.log(&quot;currentIndex&quot;, currentIndex);</span>
 285 |     | <span class='neutral'></span>
 286 | *   | <span class='executed'>        latestLiquidationTimestamp = self</span>
 287 | *   | <span class='executed'>            .liquidationData[currentIndex]</span>
 288 |     | <span class='neutral'>            .timestamp;</span>
 289 | *   | <span class='executed'>        console2.log(&quot;latestLiquidationTimestamp&quot;, latestLiquidationTimestamp);</span>
 290 |     | <span class='neutral'></span>
 291 | *   | <span class='executed'>        uint256 windowStartTimestamp = block.timestamp -</span>
 292 | *   | <span class='executed'>            marketConfig.maxSecondsInLiquidationWindow;</span>
 293 | *   | <span class='executed'>        console2.log(&quot;windowStartTimestamp&quot;, windowStartTimestamp);</span>
 294 | *   | <span class='executed'>        console2.log(&quot;block.timestamp&quot;, block.timestamp);</span>
 295 | *   | <span class='executed'>        console2.log(</span>
 296 |     | <span class='neutral'>            &quot;marketConfig.maxSecondsInLiquidationWindow&quot;,</span>
 297 | *   | <span class='executed'>            marketConfig.maxSecondsInLiquidationWindow</span>
 298 |     | <span class='neutral'>        );</span>
 299 |     | <span class='neutral'></span>
 300 | *   | <span class='executed'>        while (</span>
 301 | *   | <span class='executed'>            self.liquidationData[currentIndex].timestamp &gt; windowStartTimestamp</span>
 302 |     | <span class='neutral'>        ) {</span>
 303 | *   | <span class='executed'>            console2.log(</span>
 304 |     | <span class='neutral'>                &quot;self.liquidationData[currentIndex].timestamp&quot;,</span>
 305 | *   | <span class='executed'>                self.liquidationData[currentIndex].timestamp</span>
 306 |     | <span class='neutral'>            );</span>
 307 | *   | <span class='executed'>            console2.log(</span>
 308 |     | <span class='neutral'>                &quot;self.liquidationData[currentIndex].amount&quot;,</span>
 309 | *   | <span class='executed'>                self.liquidationData[currentIndex].amount</span>
 310 |     | <span class='neutral'>            );</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>            accumulatedLiquidationAmounts += self</span>
 313 | *   | <span class='executed'>                .liquidationData[currentIndex]</span>
 314 |     | <span class='neutral'>                .amount;</span>
 315 | *   | <span class='executed'>            console2.log(</span>
 316 |     | <span class='neutral'>                &quot;accumulatedLiquidationAmounts&quot;,</span>
 317 | *   | <span class='executed'>                accumulatedLiquidationAmounts</span>
 318 |     | <span class='neutral'>            );</span>
 319 |     | <span class='neutral'></span>
 320 | *   | <span class='executed'>            if (currentIndex == 0) break;</span>
 321 | *   | <span class='executed'>            currentIndex--;</span>
 322 | *   | <span class='executed'>            console2.log(&quot;currentIndex&quot;, currentIndex);</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'></span>
 325 | *   | <span class='executed'>        int256 availableLiquidationCapacity = maxLiquidationInWindow.toInt() -</span>
 326 | *   | <span class='executed'>            accumulatedLiquidationAmounts.toInt();</span>
 327 | *   | <span class='executed'>        console2.log(</span>
 328 |     | <span class='neutral'>            &quot;availableLiquidationCapacity&quot;,</span>
 329 | *   | <span class='executed'>            availableLiquidationCapacity</span>
 330 |     | <span class='neutral'>        );</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
 333 | *   | <span class='executed'>        capacity = MathUtil</span>
 334 | *   | <span class='executed'>            .max(availableLiquidationCapacity, int256(0))</span>
 335 |     | <span class='neutral'>            .toUint();</span>
 336 | *   | <span class='executed'>        console2.log(&quot;capacity&quot;, capacity);</span>
 337 |     | <span class='neutral'></span>
 338 | *   | <span class='executed'>        console2.log(&quot;Final maxLiquidationInWindow&quot;, maxLiquidationInWindow);</span>
 339 | *   | <span class='executed'>        console2.log(</span>
 340 |     | <span class='neutral'>            &quot;Final latestLiquidationTimestamp&quot;,</span>
 341 | *   | <span class='executed'>            latestLiquidationTimestamp</span>
 342 |     | <span class='neutral'>        );</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    struct PositionDataRuntime {</span>
 346 |     | <span class='neutral'>        uint256 currentPrice;</span>
 347 |     | <span class='neutral'>        int256 sizeDelta;</span>
 348 |     | <span class='neutral'>        int256 fundingDelta;</span>
 349 |     | <span class='neutral'>        int256 notionalDelta;</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    /**</span>
 353 |     | <span class='neutral'>     * @dev Use this function to update both market/position size/skew.</span>
 354 |     | <span class='neutral'>     * @dev Size and skew should not be updated directly.</span>
 355 |     | <span class='neutral'>     * @dev The return value is used to emit a MarketUpdated event.</span>
 356 |     | <span class='neutral'>     */</span>
 357 | *   | <span class='executed'>    function updatePositionData(</span>
 358 |     | <span class='neutral'>        Data storage self,</span>
 359 |     | <span class='neutral'>        uint128 accountId,</span>
 360 |     | <span class='neutral'>        Position.Data memory newPosition</span>
 361 | *   | <span class='executed'>    ) internal returns (MarketUpdate.Data memory) {</span>
 362 | *   | <span class='executed'>        PositionDataRuntime memory runtime;</span>
 363 | *   | <span class='executed'>        Position.Data storage oldPosition = self.positions[accountId];</span>
 364 |     | <span class='neutral'></span>
 365 | *   | <span class='executed'>        self.size =</span>
 366 | *   | <span class='executed'>            (self.size + MathUtil.abs128(newPosition.size)) -</span>
 367 | *   | <span class='executed'>            MathUtil.abs128(oldPosition.size);</span>
 368 | *   | <span class='executed'>        self.skew += newPosition.size - oldPosition.size;</span>
 369 |     | <span class='neutral'></span>
 370 | *   | <span class='executed'>        runtime.currentPrice = newPosition.latestInteractionPrice;</span>
 371 | *   | <span class='executed'>        (, int256 pricePnl, , int256 fundingPnl, , ) = oldPosition.getPnl(</span>
 372 |     | <span class='neutral'>            runtime.currentPrice</span>
 373 |     | <span class='neutral'>        );</span>
 374 |     | <span class='neutral'></span>
 375 | *   | <span class='executed'>        runtime.sizeDelta = newPosition.size - oldPosition.size;</span>
 376 | *   | <span class='executed'>        runtime.fundingDelta = calculateNextFunding(self, runtime.currentPrice)</span>
 377 |     | <span class='neutral'>            .mulDecimal(runtime.sizeDelta);</span>
 378 | *   | <span class='executed'>        runtime.notionalDelta = runtime.currentPrice.toInt().mulDecimal(</span>
 379 | *   | <span class='executed'>            runtime.sizeDelta</span>
 380 |     | <span class='neutral'>        );</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        // update the market debt correction accumulator before losing oldPosition details</span>
 383 |     | <span class='neutral'>        // by adding the new updated notional (old - new size) plus old position pnl</span>
 384 | *   | <span class='executed'>        self.debtCorrectionAccumulator +=</span>
 385 | *   | <span class='executed'>            runtime.fundingDelta +</span>
 386 |     | <span class='neutral'>            runtime.notionalDelta +</span>
 387 | *   | <span class='executed'>            pricePnl +</span>
 388 | *   | <span class='executed'>            fundingPnl;</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>        // update position to new position</span>
 391 |     | <span class='neutral'>        // Note: once market interest rate is updated, the current accrued interest is saved</span>
 392 |     | <span class='neutral'>        // to figure out the unrealized interest for the position</span>
 393 |     | <span class='neutral'>        // when we update market size, use a 1 month price tolerance for calculating minimum credit</span>
 394 | *   | <span class='executed'>        (uint128 interestRate, uint256 currentInterestAccrued) = InterestRate</span>
 395 | *   | <span class='executed'>            .update(PerpsPrice.Tolerance.ONE_MONTH);</span>
 396 |     | <span class='neutral'>        oldPosition.update(newPosition, currentInterestAccrued);</span>
 397 |     | <span class='neutral'></span>
 398 | *   | <span class='executed'>        return</span>
 399 | *   | <span class='executed'>            MarketUpdate.Data(</span>
 400 | *   | <span class='executed'>                self.id,</span>
 401 |     | <span class='neutral'>                interestRate,</span>
 402 | *   | <span class='executed'>                self.skew,</span>
 403 | *   | <span class='executed'>                self.size,</span>
 404 | *   | <span class='executed'>                self.lastFundingRate,</span>
 405 | *   | <span class='executed'>                currentFundingVelocity(self)</span>
 406 |     | <span class='neutral'>            );</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 | *   | <span class='executed'>    function recomputeFunding(</span>
 410 |     | <span class='neutral'>        Data storage self,</span>
 411 |     | <span class='neutral'>        uint256 price</span>
 412 | *   | <span class='executed'>    ) internal returns (int256 fundingRate, int256 fundingValue) {</span>
 413 | *   | <span class='executed'>        fundingRate = currentFundingRate(self);</span>
 414 | *   | <span class='executed'>        fundingValue = calculateNextFunding(self, price);</span>
 415 |     | <span class='neutral'></span>
 416 | *   | <span class='executed'>        self.lastFundingRate = fundingRate;</span>
 417 | *   | <span class='executed'>        self.lastFundingValue = fundingValue;</span>
 418 | *   | <span class='executed'>        self.lastFundingTime = block.timestamp;</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>        return (fundingRate, fundingValue);</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 | *   | <span class='executed'>    function calculateNextFunding(</span>
 424 |     | <span class='neutral'>        Data storage self,</span>
 425 |     | <span class='neutral'>        uint256 price</span>
 426 | *   | <span class='executed'>    ) internal view returns (int256 nextFunding) {</span>
 427 | *   | <span class='executed'>        nextFunding = self.lastFundingValue + unrecordedFunding(self, price);</span>
 428 |     | <span class='neutral'>    }</span>
 429 |     | <span class='neutral'></span>
 430 | *   | <span class='executed'>    function unrecordedFunding(</span>
 431 |     | <span class='neutral'>        Data storage self,</span>
 432 |     | <span class='neutral'>        uint256 price</span>
 433 | *   | <span class='executed'>    ) internal view returns (int256) {</span>
 434 | *   | <span class='executed'>        int256 fundingRate = currentFundingRate(self);</span>
 435 |     | <span class='neutral'>        // note the minus sign: funding flows in the opposite direction to the skew.</span>
 436 | *   | <span class='executed'>        int256 avgFundingRate = -(self.lastFundingRate + fundingRate)</span>
 437 | *   | <span class='executed'>            .divDecimal((DecimalMath.UNIT * 2).toInt());</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>        return</span>
 440 | *   | <span class='executed'>            avgFundingRate.mulDecimal(proportionalElapsed(self)).mulDecimal(</span>
 441 | *   | <span class='executed'>                price.toInt()</span>
 442 |     | <span class='neutral'>            );</span>
 443 |     | <span class='neutral'>    }</span>
 444 |     | <span class='neutral'></span>
 445 | *   | <span class='executed'>    function currentFundingRate(</span>
 446 |     | <span class='neutral'>        Data storage self</span>
 447 | *   | <span class='executed'>    ) internal view returns (int256) {</span>
 448 |     | <span class='neutral'>        // calculations:</span>
 449 |     | <span class='neutral'>        //  - velocity          = proportional_skew * max_funding_velocity</span>
 450 |     | <span class='neutral'>        //  - proportional_skew = skew / skew_scale</span>
 451 |     | <span class='neutral'>        //</span>
 452 |     | <span class='neutral'>        // example:</span>
 453 |     | <span class='neutral'>        //  - prev_funding_rate     = 0</span>
 454 |     | <span class='neutral'>        //  - prev_velocity         = 0.0025</span>
 455 |     | <span class='neutral'>        //  - time_delta            = 29,000s</span>
 456 |     | <span class='neutral'>        //  - max_funding_velocity  = 0.025 (2.5%)</span>
 457 |     | <span class='neutral'>        //  - skew                  = 300</span>
 458 |     | <span class='neutral'>        //  - skew_scale            = 10,000</span>
 459 |     | <span class='neutral'>        //</span>
 460 |     | <span class='neutral'>        // note: prev_velocity just refs to the velocity _before_ modifying the market skew.</span>
 461 |     | <span class='neutral'>        //</span>
 462 |     | <span class='neutral'>        // funding_rate = prev_funding_rate + prev_velocity * (time_delta / seconds_in_day)</span>
 463 |     | <span class='neutral'>        // funding_rate = 0 + 0.0025 * (29,000 / 86,400)</span>
 464 |     | <span class='neutral'>        //              = 0 + 0.0025 * 0.33564815</span>
 465 |     | <span class='neutral'>        //              = 0.00083912</span>
 466 |     | <span class='neutral'>        return</span>
 467 | *   | <span class='executed'>            self.lastFundingRate +</span>
 468 |     | <span class='neutral'>            (</span>
 469 | *   | <span class='executed'>                currentFundingVelocity(self).mulDecimal(</span>
 470 | *   | <span class='executed'>                    proportionalElapsed(self)</span>
 471 |     | <span class='neutral'>                )</span>
 472 |     | <span class='neutral'>            );</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'></span>
 475 | *   | <span class='executed'>    function currentFundingVelocity(</span>
 476 |     | <span class='neutral'>        Data storage self</span>
 477 | *   | <span class='executed'>    ) internal view returns (int256) {</span>
 478 | *   | <span class='executed'>        PerpsMarketConfiguration.Data</span>
 479 | *   | <span class='executed'>            storage marketConfig = PerpsMarketConfiguration.load(self.id);</span>
 480 | *   | <span class='executed'>        int256 maxFundingVelocity = marketConfig.maxFundingVelocity.toInt();</span>
 481 | *   | <span class='executed'>        int256 skewScale = marketConfig.skewScale.toInt();</span>
 482 |     | <span class='neutral'>        // Avoid a panic due to div by zero. Return 0 immediately.</span>
 483 | *   | <span class='executed'>        if (skewScale == 0) {</span>
 484 | *   | <span class='executed'>            return 0;</span>
 485 |     | <span class='neutral'>        }</span>
 486 |     | <span class='neutral'>        // Ensures the proportionalSkew is between -1 and 1.</span>
 487 | *   | <span class='executed'>        int256 pSkew = self.skew.divDecimal(skewScale);</span>
 488 | *   | <span class='executed'>        int256 pSkewBounded = MathUtil.min(</span>
 489 | *   | <span class='executed'>            MathUtil.max(-(DecimalMath.UNIT).toInt(), pSkew),</span>
 490 | *   | <span class='executed'>            (DecimalMath.UNIT).toInt()</span>
 491 |     | <span class='neutral'>        );</span>
 492 | *   | <span class='executed'>        return pSkewBounded.mulDecimal(maxFundingVelocity);</span>
 493 |     | <span class='neutral'>    }</span>
 494 |     | <span class='neutral'></span>
 495 | *   | <span class='executed'>    function proportionalElapsed(</span>
 496 |     | <span class='neutral'>        Data storage self</span>
 497 | *   | <span class='executed'>    ) internal view returns (int256) {</span>
 498 |     | <span class='neutral'>        // even though timestamps here are not D18, divDecimal multiplies by 1e18 to preserve decimals into D18</span>
 499 |     | <span class='neutral'>        return</span>
 500 | *   | <span class='executed'>            (block.timestamp - self.lastFundingTime).divDecimal(1 days).toInt();</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 | *   | <span class='executed'>    function validatePositionSize(</span>
 504 |     | <span class='neutral'>        Data storage self,</span>
 505 |     | <span class='neutral'>        uint256 maxSize,</span>
 506 |     | <span class='neutral'>        uint256 maxValue,</span>
 507 |     | <span class='neutral'>        uint256 price,</span>
 508 |     | <span class='neutral'>        int128 oldSize,</span>
 509 |     | <span class='neutral'>        int128 newSize</span>
 510 | *   | <span class='executed'>    ) internal view {</span>
 511 |     | <span class='neutral'>        // Allow users to reduce an order no matter the market conditions.</span>
 512 | *   | <span class='executed'>        bool isReducingInterest = MathUtil.isSameSideReducing(oldSize, newSize);</span>
 513 | *   | <span class='executed'>        if (!isReducingInterest) {</span>
 514 | *   | <span class='executed'>            int256 newSkew = self.skew - oldSize + newSize;</span>
 515 |     | <span class='neutral'></span>
 516 | *   | <span class='executed'>            int256 newMarketSize = self.size.toInt() -</span>
 517 | *   | <span class='executed'>                MathUtil.abs(oldSize).toInt() +</span>
 518 | *   | <span class='executed'>                MathUtil.abs(newSize).toInt();</span>
 519 |     | <span class='neutral'></span>
 520 | *   | <span class='executed'>            int256 newSideSize;</span>
 521 | *   | <span class='executed'>            if (0 &lt; newSize) {</span>
 522 |     | <span class='neutral'>                // long case: marketSize + skew</span>
 523 |     | <span class='neutral'>                //            = (|longSize| + |shortSize|) + (longSize + shortSize)</span>
 524 |     | <span class='neutral'>                //            = 2 * longSize</span>
 525 | *   | <span class='executed'>                newSideSize = newMarketSize + newSkew;</span>
 526 |     | <span class='neutral'>            } else {</span>
 527 |     | <span class='neutral'>                // short case: marketSize - skew</span>
 528 |     | <span class='neutral'>                //            = (|longSize| + |shortSize|) - (longSize + shortSize)</span>
 529 |     | <span class='neutral'>                //            = 2 * -shortSize</span>
 530 | *   | <span class='executed'>                newSideSize = newMarketSize - newSkew;</span>
 531 |     | <span class='neutral'>            }</span>
 532 |     | <span class='neutral'></span>
 533 |     | <span class='neutral'>            // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition</span>
 534 | *   | <span class='executed'>            if (maxSize &lt; MathUtil.abs(newSideSize / 2)) {</span>
 535 | *   | <span class='executed'>                revert PerpsMarketConfiguration.MaxOpenInterestReached(</span>
 536 | *   | <span class='executed'>                    self.id,</span>
 537 | *   | <span class='executed'>                    maxSize,</span>
 538 | *   | <span class='executed'>                    newSideSize / 2</span>
 539 |     | <span class='neutral'>                );</span>
 540 |     | <span class='neutral'>            }</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'>            // same check but with value (size * price)</span>
 543 |     | <span class='neutral'>            // note that if maxValue param is set to 0, this validation is skipped</span>
 544 | *   | <span class='executed'>            if (</span>
 545 | *   | <span class='executed'>                maxValue &gt; 0 &amp;&amp;</span>
 546 |     | <span class='unexecuted'>                maxValue &lt; MathUtil.abs(newSideSize / 2).mulDecimal(price)</span>
 547 |     | <span class='neutral'>            ) {</span>
 548 |     | <span class='unexecuted'>                revert PerpsMarketConfiguration.MaxUSDOpenInterestReached(</span>
 549 |     | <span class='unexecuted'>                    self.id,</span>
 550 |     | <span class='unexecuted'>                    maxValue,</span>
 551 |     | <span class='unexecuted'>                    newSideSize / 2,</span>
 552 |     | <span class='neutral'>                    price</span>
 553 |     | <span class='neutral'>                );</span>
 554 |     | <span class='neutral'>            }</span>
 555 |     | <span class='neutral'>        }</span>
 556 |     | <span class='neutral'>    }</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='neutral'>    /**</span>
 559 |     | <span class='neutral'>     * @dev Returns the market debt incurred by all positions</span>
 560 |     | <span class='neutral'>     * @notice  Market debt is the sum of all position sizes multiplied by the price, and old positions pnl that is included in the debt correction accumulator.</span>
 561 |     | <span class='neutral'>     */</span>
 562 | *   | <span class='executed'>    function marketDebt(</span>
 563 |     | <span class='neutral'>        Data storage self,</span>
 564 |     | <span class='neutral'>        uint256 price</span>
 565 | *   | <span class='executed'>    ) internal view returns (int256) {</span>
 566 |     | <span class='neutral'>        // all positions sizes multiplied by the price is equivalent to skew times price</span>
 567 |     | <span class='neutral'>        // and the debt correction accumulator is the  sum of all positions pnl</span>
 568 | *   | <span class='executed'>        int256 positionPnl = self.skew.mulDecimal(price.toInt());</span>
 569 | *   | <span class='executed'>        int256 fundingPnl = self.skew.mulDecimal(</span>
 570 | *   | <span class='executed'>            calculateNextFunding(self, price)</span>
 571 |     | <span class='neutral'>        );</span>
 572 |     | <span class='neutral'></span>
 573 | *   | <span class='executed'>        return positionPnl + fundingPnl - self.debtCorrectionAccumulator;</span>
 574 |     | <span class='neutral'>    }</span>
 575 |     | <span class='neutral'></span>
 576 | *   | <span class='executed'>    function requiredCredit(</span>
 577 |     | <span class='neutral'>        uint128 marketId,</span>
 578 |     | <span class='neutral'>        PerpsPrice.Tolerance tolerance</span>
 579 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 580 |     | <span class='neutral'>        return</span>
 581 | *   | <span class='executed'>            PerpsMarket</span>
 582 | *   | <span class='executed'>                .load(marketId)</span>
 583 |     | <span class='neutral'>                .size</span>
 584 | *   | <span class='executed'>                .mulDecimal(PerpsPrice.getCurrentPrice(marketId, tolerance))</span>
 585 |     | <span class='neutral'>                .mulDecimal(</span>
 586 | *   | <span class='executed'>                    PerpsMarketConfiguration.load(marketId).lockedOiRatioD18</span>
 587 |     | <span class='neutral'>                );</span>
 588 |     | <span class='neutral'>    }</span>
 589 |     | <span class='neutral'></span>
 590 | *   | <span class='executed'>    function accountPosition(</span>
 591 |     | <span class='neutral'>        uint128 marketId,</span>
 592 |     | <span class='neutral'>        uint128 accountId</span>
 593 | *   | <span class='executed'>    ) internal view returns (Position.Data storage position) {</span>
 594 | *   | <span class='executed'>        position = load(marketId).positions[accountId];</span>
 595 |     | <span class='neutral'>    }</span>
 596 |     | <span class='neutral'>}</span>
 597 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsMarketConfiguration.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SafeCastI128} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   6 |     | <span class='neutral'>import {OrderFee} from &quot;./OrderFee.sol&quot;;</span>
   7 |     | <span class='neutral'>import {SettlementStrategy} from &quot;./SettlementStrategy.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
   9 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library PerpsMarketConfiguration {</span>
  12 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  13 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  14 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    error MaxOpenInterestReached(</span>
  17 |     | <span class='neutral'>        uint128 marketId,</span>
  18 |     | <span class='neutral'>        uint256 maxMarketSize,</span>
  19 |     | <span class='neutral'>        int256 newSideSize</span>
  20 |     | <span class='neutral'>    );</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    error MaxUSDOpenInterestReached(</span>
  23 |     | <span class='neutral'>        uint128 marketId,</span>
  24 |     | <span class='neutral'>        uint256 maxMarketValue,</span>
  25 |     | <span class='neutral'>        int256 newSideSize,</span>
  26 |     | <span class='neutral'>        uint256 price</span>
  27 |     | <span class='neutral'>    );</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    error InvalidSettlementStrategy(uint256 settlementStrategyId);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    struct Data {</span>
  32 |     | <span class='neutral'>        OrderFee.Data orderFees;</span>
  33 |     | <span class='neutral'>        SettlementStrategy.Data[] settlementStrategies;</span>
  34 |     | <span class='neutral'>        uint256 maxMarketSize; // oi cap in units of asset</span>
  35 |     | <span class='neutral'>        uint256 maxFundingVelocity;</span>
  36 |     | <span class='neutral'>        uint256 skewScale;</span>
  37 |     | <span class='neutral'>        /**</span>
  38 |     | <span class='neutral'>         * @dev the initial margin requirements for this market when opening a position</span>
  39 |     | <span class='neutral'>         * @dev this fraction is multiplied by the impact of the position on the skew (open position size / skewScale)</span>
  40 |     | <span class='neutral'>         */</span>
  41 |     | <span class='neutral'>        uint256 initialMarginRatioD18;</span>
  42 |     | <span class='neutral'>        /**</span>
  43 |     | <span class='neutral'>         * @dev This scalar is applied to the calculated initial margin ratio</span>
  44 |     | <span class='neutral'>         * @dev this generally will be lower than initial margin but is used to determine when to liquidate a position</span>
  45 |     | <span class='neutral'>         * @dev this fraction is multiplied by the impact of the position on the skew (position size / skewScale)</span>
  46 |     | <span class='neutral'>         */</span>
  47 |     | <span class='neutral'>        uint256 maintenanceMarginScalarD18;</span>
  48 |     | <span class='neutral'>        /**</span>
  49 |     | <span class='neutral'>         * @dev This ratio is multiplied by the market&#39;s notional size (size * currentPrice) to determine how much credit is required for the market to be sufficiently backed by the LPs</span>
  50 |     | <span class='neutral'>         */</span>
  51 |     | <span class='neutral'>        uint256 lockedOiRatioD18;</span>
  52 |     | <span class='neutral'>        /**</span>
  53 |     | <span class='neutral'>         * @dev This multiplier is applied to the max liquidation value when calculating max liquidation for a given market</span>
  54 |     | <span class='neutral'>         */</span>
  55 |     | <span class='neutral'>        uint256 maxLiquidationLimitAccumulationMultiplier;</span>
  56 |     | <span class='neutral'>        /**</span>
  57 |     | <span class='neutral'>         * @dev This configured window is the max liquidation amount that can be accumulated.</span>
  58 |     | <span class='neutral'>         * @dev If you multiply maxLiquidationPerSecond * this window in seconds, you get the max liquidation amount that can be accumulated within this window</span>
  59 |     | <span class='neutral'>         */</span>
  60 |     | <span class='neutral'>        uint256 maxSecondsInLiquidationWindow;</span>
  61 |     | <span class='neutral'>        /**</span>
  62 |     | <span class='neutral'>         * @dev This value is multiplied by the notional value of a position to determine flag reward</span>
  63 |     | <span class='neutral'>         */</span>
  64 |     | <span class='neutral'>        uint256 flagRewardRatioD18;</span>
  65 |     | <span class='neutral'>        /**</span>
  66 |     | <span class='neutral'>         * @dev minimum position value in USD, this is a constant value added to position margin requirements (initial/maintenance)</span>
  67 |     | <span class='neutral'>         */</span>
  68 |     | <span class='neutral'>        uint256 minimumPositionMargin;</span>
  69 |     | <span class='neutral'>        /**</span>
  70 |     | <span class='neutral'>         * @dev This value gets applied to the initial margin ratio to ensure there&#39;s a cap on the max leverage regardless of position size</span>
  71 |     | <span class='neutral'>         */</span>
  72 |     | <span class='neutral'>        uint256 minimumInitialMarginRatioD18;</span>
  73 |     | <span class='neutral'>        /**</span>
  74 |     | <span class='neutral'>         * @dev Threshold for allowing further liquidations when max liquidation amount is reached</span>
  75 |     | <span class='neutral'>         */</span>
  76 |     | <span class='neutral'>        uint256 maxLiquidationPd;</span>
  77 |     | <span class='neutral'>        /**</span>
  78 |     | <span class='neutral'>         * @dev if the msg.sender is this endorsed liquidator during an account liquidation, the max liquidation amount doesn&#39;t apply.</span>
  79 |     | <span class='neutral'>         * @dev this address is allowed to fully liquidate any account eligible for liquidation.</span>
  80 |     | <span class='neutral'>         */</span>
  81 |     | <span class='neutral'>        address endorsedLiquidator;</span>
  82 |     | <span class='neutral'>        /**</span>
  83 |     | <span class='neutral'>         * @dev OI cap in USD denominated.</span>
  84 |     | <span class='neutral'>         * @dev If set to zero then there is no cap with value, just units</span>
  85 |     | <span class='neutral'>         */</span>
  86 |     | <span class='neutral'>        uint256 maxMarketValue;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function load(uint128 marketId) internal pure returns (Data storage store) {</span>
  90 | *   | <span class='executed'>        bytes32 s = keccak256(</span>
  91 | *   | <span class='executed'>            abi.encode(</span>
  92 |     | <span class='neutral'>                &quot;io.synthetix.perps-market.PerpsMarketConfiguration&quot;,</span>
  93 | *   | <span class='executed'>                marketId</span>
  94 |     | <span class='neutral'>            )</span>
  95 |     | <span class='neutral'>        );</span>
  96 |     | <span class='neutral'>        assembly {</span>
  97 |     | <span class='neutral'>            store.slot := s</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 | *   | <span class='executed'>    function maxLiquidationAmountInWindow(</span>
 102 |     | <span class='neutral'>        Data storage self</span>
 103 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 104 | *   | <span class='executed'>        OrderFee.Data storage orderFeeData = self.orderFees;</span>
 105 |     | <span class='neutral'>        return</span>
 106 | *   | <span class='executed'>            (orderFeeData.makerFee + orderFeeData.takerFee)</span>
 107 | *   | <span class='executed'>                .mulDecimal(self.skewScale)</span>
 108 | *   | <span class='executed'>                .mulDecimal(self.maxLiquidationLimitAccumulationMultiplier) *</span>
 109 | *   | <span class='executed'>            self.maxSecondsInLiquidationWindow;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>    function numberOfLiquidationWindows(</span>
 113 |     | <span class='neutral'>        Data storage self,</span>
 114 |     | <span class='neutral'>        uint256 positionSize</span>
 115 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 116 |     | <span class='neutral'>        return</span>
 117 | *   | <span class='executed'>            MathUtil.ceilDivide(</span>
 118 | *   | <span class='executed'>                positionSize,</span>
 119 | *   | <span class='executed'>                maxLiquidationAmountInWindow(self)</span>
 120 |     | <span class='neutral'>            );</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>    function calculateFlagReward(</span>
 124 |     | <span class='neutral'>        Data storage self,</span>
 125 |     | <span class='neutral'>        uint256 notionalValue</span>
 126 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 127 | *   | <span class='executed'>        return notionalValue.mulDecimal(self.flagRewardRatioD18);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // function calculateRequiredMargins(</span>
 131 |     | <span class='neutral'>    //     Data storage self,</span>
 132 |     | <span class='neutral'>    //     int128 size,</span>
 133 |     | <span class='neutral'>    //     uint256 price</span>
 134 |     | <span class='neutral'>    // )</span>
 135 |     | <span class='neutral'>    //     internal</span>
 136 |     | <span class='neutral'>    //     view</span>
 137 |     | <span class='neutral'>    //     returns (</span>
 138 |     | <span class='neutral'>    //         uint256 initialMarginRatio,</span>
 139 |     | <span class='neutral'>    //         uint256 maintenanceMarginRatio,</span>
 140 |     | <span class='neutral'>    //         uint256 initialMargin,</span>
 141 |     | <span class='neutral'>    //         uint256 maintenanceMargin</span>
 142 |     | <span class='neutral'>    //     )</span>
 143 |     | <span class='neutral'>    // {</span>
 144 |     | <span class='neutral'>    //     if (size == 0) {</span>
 145 |     | <span class='neutral'>    //         return (0, 0, 0, 0);</span>
 146 |     | <span class='neutral'>    //     }</span>
 147 |     | <span class='neutral'>    //     uint256 sizeAbs = MathUtil.abs(size.to256());</span>
 148 |     | <span class='neutral'>    //     uint256 impactOnSkew = self.skewScale == 0</span>
 149 |     | <span class='neutral'>    //         ? 0</span>
 150 |     | <span class='neutral'>    //         : sizeAbs.divDecimal(self.skewScale);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    //     initialMarginRatio =</span>
 153 |     | <span class='neutral'>    //         impactOnSkew.mulDecimal(self.initialMarginRatioD18) +</span>
 154 |     | <span class='neutral'>    //         self.minimumInitialMarginRatioD18;</span>
 155 |     | <span class='neutral'>    //     maintenanceMarginRatio = initialMarginRatio.mulDecimal(</span>
 156 |     | <span class='neutral'>    //         self.maintenanceMarginScalarD18</span>
 157 |     | <span class='neutral'>    //     );</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    //     uint256 notional = sizeAbs.mulDecimal(price);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    //     initialMargin =</span>
 162 |     | <span class='neutral'>    //         notional.mulDecimal(initialMarginRatio) +</span>
 163 |     | <span class='neutral'>    //         self.minimumPositionMargin;</span>
 164 |     | <span class='neutral'>    //     maintenanceMargin =</span>
 165 |     | <span class='neutral'>    //         notional.mulDecimal(maintenanceMarginRatio) +</span>
 166 |     | <span class='neutral'>    //         self.minimumPositionMargin;</span>
 167 |     | <span class='neutral'>    // }</span>
 168 | *   | <span class='executed'>    function calculateRequiredMargins(</span>
 169 |     | <span class='neutral'>        Data storage self,</span>
 170 |     | <span class='neutral'>        int128 size,</span>
 171 |     | <span class='neutral'>        uint256 price</span>
 172 |     | <span class='neutral'>    )</span>
 173 |     | <span class='neutral'>        internal</span>
 174 |     | <span class='neutral'>        view</span>
 175 |     | <span class='neutral'>        returns (</span>
 176 | *   | <span class='executed'>            uint256 initialMarginRatio,</span>
 177 | *   | <span class='executed'>            uint256 maintenanceMarginRatio,</span>
 178 | *   | <span class='executed'>            uint256 initialMargin,</span>
 179 | *   | <span class='executed'>            uint256 maintenanceMargin</span>
 180 |     | <span class='neutral'>        )</span>
 181 | *   | <span class='executed'>    {</span>
 182 | *   | <span class='executed'>        console2.log(&quot;size&quot;, int256(size));</span>
 183 | *   | <span class='executed'>        console2.log(&quot;price&quot;, price);</span>
 184 |     | <span class='neutral'></span>
 185 | *   | <span class='executed'>        if (size == 0) {</span>
 186 | *   | <span class='executed'>            console2.log(&quot;size is 0, returning all zeros&quot;);</span>
 187 | *   | <span class='executed'>            return (0, 0, 0, 0);</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'></span>
 190 | *   | <span class='executed'>        uint256 sizeAbs = MathUtil.abs(size.to256());</span>
 191 | *   | <span class='executed'>        console2.log(&quot;sizeAbs&quot;, sizeAbs);</span>
 192 |     | <span class='neutral'></span>
 193 | *   | <span class='executed'>        console2.log(&quot;self.skewScale&quot;, self.skewScale);</span>
 194 | *   | <span class='executed'>        uint256 impactOnSkew = self.skewScale == 0</span>
 195 |     | <span class='unexecuted'>            ? 0</span>
 196 | *   | <span class='executed'>            : sizeAbs.divDecimal(self.skewScale);</span>
 197 | *   | <span class='executed'>        console2.log(&quot;impactOnSkew&quot;, impactOnSkew);</span>
 198 |     | <span class='neutral'></span>
 199 | *   | <span class='executed'>        console2.log(&quot;self.initialMarginRatioD18&quot;, self.initialMarginRatioD18);</span>
 200 | *   | <span class='executed'>        console2.log(</span>
 201 |     | <span class='neutral'>            &quot;self.minimumInitialMarginRatioD18&quot;,</span>
 202 | *   | <span class='executed'>            self.minimumInitialMarginRatioD18</span>
 203 |     | <span class='neutral'>        );</span>
 204 | *   | <span class='executed'>        initialMarginRatio =</span>
 205 | *   | <span class='executed'>            impactOnSkew.mulDecimal(self.initialMarginRatioD18) +</span>
 206 | *   | <span class='executed'>            self.minimumInitialMarginRatioD18;</span>
 207 | *   | <span class='executed'>        console2.log(&quot;initialMarginRatio&quot;, initialMarginRatio);</span>
 208 |     | <span class='neutral'></span>
 209 | *   | <span class='executed'>        console2.log(</span>
 210 |     | <span class='neutral'>            &quot;self.maintenanceMarginScalarD18&quot;,</span>
 211 | *   | <span class='executed'>            self.maintenanceMarginScalarD18</span>
 212 |     | <span class='neutral'>        );</span>
 213 | *   | <span class='executed'>        maintenanceMarginRatio = initialMarginRatio.mulDecimal(</span>
 214 | *   | <span class='executed'>            self.maintenanceMarginScalarD18</span>
 215 |     | <span class='neutral'>        );</span>
 216 | *   | <span class='executed'>        console2.log(&quot;maintenanceMarginRatio&quot;, maintenanceMarginRatio);</span>
 217 |     | <span class='neutral'></span>
 218 | *   | <span class='executed'>        uint256 notional = sizeAbs.mulDecimal(price);</span>
 219 | *   | <span class='executed'>        console2.log(&quot;notional&quot;, notional);</span>
 220 |     | <span class='neutral'></span>
 221 | *   | <span class='executed'>        console2.log(&quot;self.minimumPositionMargin&quot;, self.minimumPositionMargin);</span>
 222 | *   | <span class='executed'>        initialMargin =</span>
 223 | *   | <span class='executed'>            notional.mulDecimal(initialMarginRatio) +</span>
 224 | *   | <span class='executed'>            self.minimumPositionMargin;</span>
 225 | *   | <span class='executed'>        console2.log(&quot;initialMargin&quot;, initialMargin);</span>
 226 |     | <span class='neutral'></span>
 227 | *   | <span class='executed'>        maintenanceMargin =</span>
 228 | *   | <span class='executed'>            notional.mulDecimal(maintenanceMarginRatio) +</span>
 229 | *   | <span class='executed'>            self.minimumPositionMargin;</span>
 230 | *   | <span class='executed'>        console2.log(&quot;maintenanceMargin&quot;, maintenanceMargin);</span>
 231 |     | <span class='neutral'></span>
 232 | *   | <span class='executed'>        console2.log(&quot;Final initialMarginRatio&quot;, initialMarginRatio);</span>
 233 | *   | <span class='executed'>        console2.log(&quot;Final maintenanceMarginRatio&quot;, maintenanceMarginRatio);</span>
 234 | *   | <span class='executed'>        console2.log(&quot;Final initialMargin&quot;, initialMargin);</span>
 235 | *   | <span class='executed'>        console2.log(&quot;Final maintenanceMargin&quot;, maintenanceMargin);</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @notice given a strategy id, returns the entire settlement strategy struct</span>
 239 |     | <span class='neutral'>     */</span>
 240 | *   | <span class='executed'>    function loadValidSettlementStrategy(</span>
 241 |     | <span class='neutral'>        uint128 marketId,</span>
 242 |     | <span class='neutral'>        uint256 settlementStrategyId</span>
 243 | *   | <span class='executed'>    ) internal view returns (SettlementStrategy.Data storage strategy) {</span>
 244 | *   | <span class='executed'>        Data storage self = load(marketId);</span>
 245 | *   | <span class='executed'>        validateStrategyExists(self, settlementStrategyId);</span>
 246 |     | <span class='neutral'></span>
 247 | *   | <span class='executed'>        strategy = self.settlementStrategies[settlementStrategyId];</span>
 248 | *   | <span class='executed'>        if (strategy.disabled) {</span>
 249 |     | <span class='unexecuted'>            revert InvalidSettlementStrategy(settlementStrategyId);</span>
 250 |     | <span class='neutral'>        }</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 | *   | <span class='executed'>    function validateStrategyExists(</span>
 254 |     | <span class='neutral'>        Data storage config,</span>
 255 |     | <span class='neutral'>        uint256 settlementStrategyId</span>
 256 |     | <span class='neutral'>    ) internal view {</span>
 257 | *   | <span class='executed'>        if (settlementStrategyId &gt;= config.settlementStrategies.length) {</span>
 258 |     | <span class='unexecuted'>            revert InvalidSettlementStrategy(settlementStrategyId);</span>
 259 |     | <span class='neutral'>        }</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'>}</span>
 262 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsMarketFactory.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ITokenModule} from &quot;@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol&quot;;</span>
   5 |     | <span class='neutral'>import {INodeModule} from &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ISynthetixSystem} from &quot;../interfaces/external/ISynthetixSystem.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ISpotMarketSystem} from &quot;../interfaces/external/ISpotMarketSystem.sol&quot;;</span>
   8 |     | <span class='neutral'>import {GlobalPerpsMarket} from &quot;../storage/GlobalPerpsMarket.sol&quot;;</span>
   9 |     | <span class='neutral'>import {PerpsMarket} from &quot;../storage/PerpsMarket.sol&quot;;</span>
  10 |     | <span class='neutral'>import {PerpsPrice} from &quot;../storage/PerpsPrice.sol&quot;;</span>
  11 |     | <span class='neutral'>import {PerpsCollateralConfiguration} from &quot;../storage/PerpsCollateralConfiguration.sol&quot;;</span>
  12 |     | <span class='neutral'>import {LiquidationAssetManager} from &quot;../storage/LiquidationAssetManager.sol&quot;;</span>
  13 |     | <span class='neutral'>import {SafeCastI256, SafeCastU256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  14 |     | <span class='neutral'>import {SetUtil} from &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/**</span>
  17 |     | <span class='neutral'> * @title Main factory library that registers perps markets.  Also houses global configuration for all perps markets.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library PerpsMarketFactory {</span>
  20 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  21 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  22 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  23 |     | <span class='neutral'>    using GlobalPerpsMarket for GlobalPerpsMarket.Data;</span>
  24 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  25 |     | <span class='neutral'>    using LiquidationAssetManager for LiquidationAssetManager.Data;</span>
  26 |     | <span class='neutral'>    using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    bytes32 private constant _SLOT_PERPS_MARKET_FACTORY =</span>
  29 | *   | <span class='executed'>        keccak256(abi.encode(&quot;io.synthetix.perps-market.PerpsMarketFactory&quot;));</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    error PerpsMarketNotInitialized();</span>
  32 |     | <span class='neutral'>    error PerpsMarketAlreadyInitialized();</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    struct Data {</span>
  35 |     | <span class='neutral'>        /**</span>
  36 |     | <span class='neutral'>         * @dev oracle manager address used for price feeds</span>
  37 |     | <span class='neutral'>         */</span>
  38 |     | <span class='neutral'>        INodeModule oracle;</span>
  39 |     | <span class='neutral'>        ITokenModule usdToken;</span>
  40 |     | <span class='neutral'>        /**</span>
  41 |     | <span class='neutral'>         * @dev Synthetix core v3 proxy address</span>
  42 |     | <span class='neutral'>         */</span>
  43 |     | <span class='neutral'>        ISynthetixSystem synthetix;</span>
  44 |     | <span class='neutral'>        ISpotMarketSystem spotMarket;</span>
  45 |     | <span class='neutral'>        uint128 perpsMarketId;</span>
  46 |     | <span class='neutral'>        string name;</span>
  47 |     | <span class='neutral'>        /**</span>
  48 |     | <span class='neutral'>         * @dev all liquidated account&#39;s assets are sent to this address</span>
  49 |     | <span class='neutral'>         */</span>
  50 |     | <span class='neutral'>        address liquidationAssetManager;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function onlyIfInitialized(Data storage self) internal view {</span>
  54 |     | <span class='unexecuted'>        if (self.perpsMarketId == 0) {</span>
  55 |     | <span class='unexecuted'>            revert PerpsMarketNotInitialized();</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function onlyIfNotInitialized(Data storage self) internal view {</span>
  60 |     | <span class='unexecuted'>        if (self.perpsMarketId != 0) {</span>
  61 |     | <span class='unexecuted'>            revert PerpsMarketAlreadyInitialized();</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 | *   | <span class='executed'>    function load() internal pure returns (Data storage perpsMarketFactory) {</span>
  66 | *   | <span class='executed'>        bytes32 s = _SLOT_PERPS_MARKET_FACTORY;</span>
  67 |     | <span class='neutral'>        assembly {</span>
  68 |     | <span class='neutral'>            perpsMarketFactory.slot := s</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function initialize(</span>
  73 |     | <span class='neutral'>        Data storage self,</span>
  74 |     | <span class='neutral'>        ISynthetixSystem synthetix,</span>
  75 |     | <span class='neutral'>        ISpotMarketSystem spotMarket</span>
  76 |     | <span class='unexecuted'>    ) internal returns (uint128 perpsMarketId) {</span>
  77 |     | <span class='unexecuted'>        onlyIfNotInitialized(self); // redundant check, but kept here in case this internal is called somewhere else</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        (address usdTokenAddress, ) = synthetix.getAssociatedSystem(&quot;USDToken&quot;);</span>
  80 |     | <span class='unexecuted'>        perpsMarketId = synthetix.registerMarket(address(this));</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        self.spotMarket = spotMarket;</span>
  83 |     | <span class='unexecuted'>        self.synthetix = synthetix;</span>
  84 |     | <span class='unexecuted'>        self.usdToken = ITokenModule(usdTokenAddress);</span>
  85 |     | <span class='unexecuted'>        self.oracle = synthetix.getOracleManager();</span>
  86 |     | <span class='unexecuted'>        self.perpsMarketId = perpsMarketId;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function totalWithdrawableUsd() internal view returns (uint256) {</span>
  90 | *   | <span class='executed'>        Data storage self = load();</span>
  91 | *   | <span class='executed'>        return self.synthetix.getWithdrawableMarketUsd(self.perpsMarketId);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>    function depositMarketCollateral(</span>
  95 |     | <span class='neutral'>        Data storage self,</span>
  96 |     | <span class='neutral'>        ITokenModule collateral,</span>
  97 |     | <span class='neutral'>        uint256 amount</span>
  98 |     | <span class='neutral'>    ) internal {</span>
  99 | *   | <span class='executed'>        collateral.approve(address(self.synthetix), amount);</span>
 100 | *   | <span class='executed'>        self.synthetix.depositMarketCollateral(self.perpsMarketId, address(collateral), amount);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function depositMarketUsd(Data storage self, uint256 amount) internal {</span>
 104 |     | <span class='neutral'>        self.usdToken.approve(address(this), amount);</span>
 105 |     | <span class='neutral'>        self.synthetix.depositMarketUsd(self.perpsMarketId, address(this), amount);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 | *   | <span class='executed'>    function withdrawMarketUsd(Data storage self, address to, uint256 amount) internal {</span>
 109 | *   | <span class='executed'>        self.synthetix.withdrawMarketUsd(self.perpsMarketId, to, amount);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>    function transferLiquidatedSynth(</span>
 113 |     | <span class='neutral'>        Data storage self,</span>
 114 |     | <span class='neutral'>        uint128 collateralId,</span>
 115 |     | <span class='neutral'>        uint256 amount</span>
 116 | *   | <span class='executed'>    ) internal returns (uint256 synthValue) {</span>
 117 | *   | <span class='executed'>        address synth = self.spotMarket.getSynth(collateralId);</span>
 118 | *   | <span class='executed'>        self.synthetix.withdrawMarketCollateral(self.perpsMarketId, synth, amount);</span>
 119 |     | <span class='neutral'></span>
 120 | *   | <span class='executed'>        (synthValue, ) = PerpsCollateralConfiguration.load(collateralId).valueInUsd(</span>
 121 | *   | <span class='executed'>            amount,</span>
 122 | *   | <span class='executed'>            self.spotMarket,</span>
 123 |     | <span class='neutral'>            PerpsPrice.Tolerance.DEFAULT,</span>
 124 |     | <span class='neutral'>            false</span>
 125 |     | <span class='neutral'>        );</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>        PerpsCollateralConfiguration.loadValidLam(collateralId).distributeCollateral(synth, amount);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsPrice.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {INodeModule} from &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
  5 |     | <span class='neutral'>import {NodeOutput} from &quot;@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol&quot;;</span>
  6 |     | <span class='neutral'>import {SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  7 |     | <span class='neutral'>import {PerpsMarketFactory} from &quot;./PerpsMarketFactory.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title Price storage for a specific synth market.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>library PerpsPrice {</span>
 13 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    enum Tolerance {</span>
 16 |     | <span class='neutral'>        DEFAULT,</span>
 17 |     | <span class='neutral'>        STRICT,</span>
 18 |     | <span class='neutral'>        ONE_MONTH</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>    uint256 private constant ONE_MONTH = 2592000;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    struct Data {</span>
 24 |     | <span class='neutral'>        /**</span>
 25 |     | <span class='neutral'>         * @dev the price feed id for the market.  this node is processed using the oracle manager which returns the price.</span>
 26 |     | <span class='neutral'>         * @dev the staleness tolerance is provided as a runtime argument to this feed for processing.</span>
 27 |     | <span class='neutral'>         */</span>
 28 |     | <span class='neutral'>        bytes32 feedId;</span>
 29 |     | <span class='neutral'>        /**</span>
 30 |     | <span class='neutral'>         * @dev strict tolerance in seconds, mainly utilized for liquidations.</span>
 31 |     | <span class='neutral'>         */</span>
 32 |     | <span class='neutral'>        uint256 strictStalenessTolerance;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>    function load(uint128 marketId) internal pure returns (Data storage price) {</span>
 36 | *   | <span class='executed'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.perps-market.Price&quot;, marketId));</span>
 37 |     | <span class='neutral'>        assembly {</span>
 38 |     | <span class='neutral'>            price.slot := s</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 | *   | <span class='executed'>    function getCurrentPrice(</span>
 43 |     | <span class='neutral'>        uint128 marketId,</span>
 44 |     | <span class='neutral'>        Tolerance priceTolerance</span>
 45 | *   | <span class='executed'>    ) internal view returns (uint256 price) {</span>
 46 | *   | <span class='executed'>        Data storage self = load(marketId);</span>
 47 | *   | <span class='executed'>        PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();</span>
 48 | *   | <span class='executed'>        NodeOutput.Data memory output;</span>
 49 | *   | <span class='executed'>        if (priceTolerance == Tolerance.DEFAULT) {</span>
 50 | *   | <span class='executed'>            output = INodeModule(factory.oracle).process(self.feedId);</span>
 51 | *   | <span class='executed'>        } else {</span>
 52 | *   | <span class='executed'>            bytes32[] memory runtimeKeys = new bytes32[](1);</span>
 53 | *   | <span class='executed'>            bytes32[] memory runtimeValues = new bytes32[](1);</span>
 54 | *   | <span class='executed'>            runtimeKeys[0] = bytes32(&quot;stalenessTolerance&quot;);</span>
 55 | *   | <span class='executed'>            runtimeValues[0] = toleranceBytes(self, priceTolerance);</span>
 56 | *   | <span class='executed'>            output = INodeModule(factory.oracle).processWithRuntime(</span>
 57 | *   | <span class='executed'>                self.feedId,</span>
 58 | *   | <span class='executed'>                runtimeKeys,</span>
 59 | *   | <span class='executed'>                runtimeValues</span>
 60 |     | <span class='neutral'>            );</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'></span>
 63 | *   | <span class='executed'>        return output.price.toUint();</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>    function update(Data storage self, bytes32 feedId, uint256 strictStalenessTolerance) internal {</span>
 67 |     | <span class='unexecuted'>        self.feedId = feedId;</span>
 68 |     | <span class='unexecuted'>        self.strictStalenessTolerance = strictStalenessTolerance;</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 | *   | <span class='executed'>    function toleranceBytes(</span>
 72 |     | <span class='neutral'>        Data storage self,</span>
 73 |     | <span class='neutral'>        Tolerance tolerance</span>
 74 | *   | <span class='executed'>    ) internal view returns (bytes32) {</span>
 75 | *   | <span class='executed'>        if (tolerance == Tolerance.STRICT) {</span>
 76 | *   | <span class='executed'>            return bytes32(self.strictStalenessTolerance);</span>
 77 | *   | <span class='executed'>        } else if (tolerance == Tolerance.ONE_MONTH) {</span>
 78 | *   | <span class='executed'>            return bytes32(ONE_MONTH);</span>
 79 |     | <span class='neutral'>        } else {</span>
 80 |     | <span class='unexecuted'>            return bytes32(0);</span>
 81 |     | <span class='neutral'>        }</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/Position.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {SafeCastU256, SafeCastU128} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import {PerpsMarket} from &quot;./PerpsMarket.sol&quot;;</span>
   7 |     | <span class='neutral'>import {PerpsMarketConfiguration} from &quot;./PerpsMarketConfiguration.sol&quot;;</span>
   8 |     | <span class='neutral'>import {InterestRate} from &quot;./InterestRate.sol&quot;;</span>
   9 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library Position {</span>
  12 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  13 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  14 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  15 |     | <span class='neutral'>    using DecimalMath for int128;</span>
  16 |     | <span class='neutral'>    using PerpsMarket for PerpsMarket.Data;</span>
  17 |     | <span class='neutral'>    using InterestRate for InterestRate.Data;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct Data {</span>
  20 |     | <span class='neutral'>        uint128 marketId;</span>
  21 |     | <span class='neutral'>        int128 size;</span>
  22 |     | <span class='neutral'>        uint128 latestInteractionPrice;</span>
  23 |     | <span class='neutral'>        int128 latestInteractionFunding;</span>
  24 |     | <span class='neutral'>        uint256 latestInterestAccrued;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function update(</span>
  28 |     | <span class='neutral'>        Data storage self,</span>
  29 |     | <span class='neutral'>        Data memory newPosition,</span>
  30 |     | <span class='neutral'>        uint256 latestInterestAccrued</span>
  31 |     | <span class='neutral'>    ) internal {</span>
  32 | *   | <span class='executed'>        self.size = newPosition.size;</span>
  33 | *   | <span class='executed'>        self.marketId = newPosition.marketId;</span>
  34 | *   | <span class='executed'>        self.latestInteractionPrice = newPosition.latestInteractionPrice;</span>
  35 | *   | <span class='executed'>        self.latestInteractionFunding = newPosition.latestInteractionFunding;</span>
  36 | *   | <span class='executed'>        self.latestInterestAccrued = latestInterestAccrued;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>    function getPositionData(</span>
  40 |     | <span class='neutral'>        Data storage self,</span>
  41 |     | <span class='neutral'>        uint256 price</span>
  42 |     | <span class='neutral'>    )</span>
  43 |     | <span class='neutral'>        internal</span>
  44 |     | <span class='neutral'>        view</span>
  45 |     | <span class='neutral'>        returns (</span>
  46 | *   | <span class='executed'>            uint256 notionalValue,</span>
  47 | *   | <span class='executed'>            int256 totalPnl,</span>
  48 | *   | <span class='executed'>            int256 pricePnl,</span>
  49 | *   | <span class='executed'>            uint256 chargedInterest,</span>
  50 | *   | <span class='executed'>            int256 accruedFunding,</span>
  51 | *   | <span class='executed'>            int256 netFundingPerUnit,</span>
  52 | *   | <span class='executed'>            int256 nextFunding</span>
  53 |     | <span class='neutral'>        )</span>
  54 |     | <span class='neutral'>    {</span>
  55 | *   | <span class='executed'>        (</span>
  56 |     | <span class='neutral'>            totalPnl,</span>
  57 |     | <span class='neutral'>            pricePnl,</span>
  58 |     | <span class='neutral'>            chargedInterest,</span>
  59 |     | <span class='neutral'>            accruedFunding,</span>
  60 |     | <span class='neutral'>            netFundingPerUnit,</span>
  61 |     | <span class='neutral'>            nextFunding</span>
  62 | *   | <span class='executed'>        ) = getPnl(self, price);</span>
  63 | *   | <span class='executed'>        notionalValue = getNotionalValue(self, price);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>    function getPnl(</span>
  67 |     | <span class='neutral'>        Data storage self,</span>
  68 |     | <span class='neutral'>        uint256 price</span>
  69 |     | <span class='neutral'>    )</span>
  70 |     | <span class='neutral'>        internal</span>
  71 |     | <span class='neutral'>        view</span>
  72 |     | <span class='neutral'>        returns (</span>
  73 | *   | <span class='executed'>            int256 totalPnl,</span>
  74 | *   | <span class='executed'>            int256 pricePnl,</span>
  75 | *   | <span class='executed'>            uint256 chargedInterest,</span>
  76 | *   | <span class='executed'>            int256 accruedFunding,</span>
  77 | *   | <span class='executed'>            int256 netFundingPerUnit,</span>
  78 | *   | <span class='executed'>            int256 nextFunding</span>
  79 |     | <span class='neutral'>        )</span>
  80 | *   | <span class='executed'>    {</span>
  81 | *   | <span class='executed'>        nextFunding = PerpsMarket.load(self.marketId).calculateNextFunding(</span>
  82 | *   | <span class='executed'>            price</span>
  83 |     | <span class='neutral'>        );</span>
  84 | *   | <span class='executed'>        netFundingPerUnit = nextFunding - self.latestInteractionFunding;</span>
  85 | *   | <span class='executed'>        accruedFunding = self.size.mulDecimal(netFundingPerUnit);</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>        int256 priceShift = price.toInt() - self.latestInteractionPrice.toInt();</span>
  88 | *   | <span class='executed'>        pricePnl = self.size.mulDecimal(priceShift);</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>        chargedInterest = interestAccrued(self, price);</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>        totalPnl = pricePnl + accruedFunding - chargedInterest.toInt();</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function interestAccrued(</span>
  96 |     | <span class='neutral'>        Data storage self,</span>
  97 |     | <span class='neutral'>        uint256 price</span>
  98 | *   | <span class='executed'>    ) internal view returns (uint256 chargedInterest) {</span>
  99 | *   | <span class='executed'>        uint256 nextInterestAccrued = InterestRate</span>
 100 |     | <span class='neutral'>            .load()</span>
 101 |     | <span class='neutral'>            .calculateNextInterest();</span>
 102 | *   | <span class='executed'>        uint256 netInterestPerDollar = nextInterestAccrued -</span>
 103 | *   | <span class='executed'>            self.latestInterestAccrued;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // The interest is charged pro-rata on this position&#39;s contribution to the locked OI requirement</span>
 106 | *   | <span class='executed'>        chargedInterest = getLockedNotionalValue(self, price).mulDecimal(</span>
 107 | *   | <span class='executed'>            netInterestPerDollar</span>
 108 |     | <span class='neutral'>        );</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>    function getLockedNotionalValue(</span>
 112 |     | <span class='neutral'>        Data storage self,</span>
 113 |     | <span class='neutral'>        uint256 price</span>
 114 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 115 |     | <span class='neutral'>        return</span>
 116 | *   | <span class='executed'>            getNotionalValue(self, price).mulDecimal(</span>
 117 | *   | <span class='executed'>                PerpsMarketConfiguration.load(self.marketId).lockedOiRatioD18</span>
 118 |     | <span class='neutral'>            );</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>    function getNotionalValue(</span>
 122 |     | <span class='neutral'>        Data storage self,</span>
 123 |     | <span class='neutral'>        uint256 price</span>
 124 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 125 | *   | <span class='executed'>        return MathUtil.abs(self.size).mulDecimal(price);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'>}</span>
 128 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/SettlementStrategy.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
  5 |     | <span class='neutral'>import {SafeCastI256, SafeCastU256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  6 |     | <span class='neutral'>import {MathUtil} from &quot;../utils/MathUtil.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library SettlementStrategy {</span>
  9 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
 10 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
 11 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    struct Data {</span>
 14 |     | <span class='neutral'>        /**</span>
 15 |     | <span class='neutral'>         * @dev see Type for more details</span>
 16 |     | <span class='neutral'>         */</span>
 17 |     | <span class='neutral'>        Type strategyType;</span>
 18 |     | <span class='neutral'>        /**</span>
 19 |     | <span class='neutral'>         * @dev the delay added to commitment time after which committed orders can be settled.</span>
 20 |     | <span class='neutral'>         * @dev this ensures settlements aren&#39;t on the same block as commitment.</span>
 21 |     | <span class='neutral'>         */</span>
 22 |     | <span class='neutral'>        uint256 settlementDelay;</span>
 23 |     | <span class='neutral'>        /**</span>
 24 |     | <span class='neutral'>         * @dev the duration of the settlement window, after which committed orders can be cancelled.</span>
 25 |     | <span class='neutral'>         */</span>
 26 |     | <span class='neutral'>        uint256 settlementWindowDuration;</span>
 27 |     | <span class='neutral'>        /**</span>
 28 |     | <span class='neutral'>         * @dev the address of the contract that returns the benchmark price at a given timestamp</span>
 29 |     | <span class='neutral'>         * @dev generally this contract orchestrates the erc7412 logic to force push an offchain price for a given timestamp.</span>
 30 |     | <span class='neutral'>         */</span>
 31 |     | <span class='neutral'>        address priceVerificationContract; // For Chainlink and Pyth settlement strategies</span>
 32 |     | <span class='neutral'>        /**</span>
 33 |     | <span class='neutral'>         * @dev configurable feed id for chainlink and pyth</span>
 34 |     | <span class='neutral'>         */</span>
 35 |     | <span class='neutral'>        bytes32 feedId;</span>
 36 |     | <span class='neutral'>        /**</span>
 37 |     | <span class='neutral'>         * @dev the amount of reward paid to the keeper for settling the order.</span>
 38 |     | <span class='neutral'>         */</span>
 39 |     | <span class='neutral'>        uint256 settlementReward;</span>
 40 |     | <span class='neutral'>        /**</span>
 41 |     | <span class='neutral'>         * @dev whether the strategy is disabled or not.</span>
 42 |     | <span class='neutral'>         */</span>
 43 |     | <span class='neutral'>        bool disabled;</span>
 44 |     | <span class='neutral'>        /**</span>
 45 |     | <span class='neutral'>         * @dev the delay added to commitment time for determining valid price. Defines the expected price timestamp.</span>
 46 |     | <span class='neutral'>         * @dev this ensures price aren&#39;t on the same block as commitment in case of blockchain drift in timestamp or bad actors timestamp manipulation.</span>
 47 |     | <span class='neutral'>         */</span>
 48 |     | <span class='neutral'>        uint256 commitmentPriceDelay;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    enum Type {</span>
 52 |     | <span class='neutral'>        PYTH</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/utils/Flags.sol</b>
<code>
 1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='unexecuted'>library Flags {</span>
 5 |     | <span class='unexecuted'>    bytes32 public constant PERPS_SYSTEM = &quot;perpsSystem&quot;;</span>
 6 |     | <span class='unexecuted'>    bytes32 public constant CREATE_MARKET = &quot;createMarket&quot;;</span>
 7 |     | <span class='neutral'>}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/utils/MathUtil.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {SafeCastI256, SafeCastI128, SafeCastU256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library MathUtil {</span>
  7 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  8 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  9 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>    function abs(int256 x) internal pure returns (uint256) {</span>
 12 | *   | <span class='executed'>        return x &gt;= 0 ? x.toUint() : (-x).toUint();</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 | *   | <span class='executed'>    function abs128(int128 x) internal pure returns (uint128) {</span>
 16 | *   | <span class='executed'>        return x &gt;= 0 ? x.toUint() : (-x).toUint();</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    function max(int256 x, int256 y) internal pure returns (int256) {</span>
 20 | *   | <span class='executed'>        return x &lt; y ? y : x;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function max(uint256 x, uint256 y) internal pure returns (uint256) {</span>
 24 | *   | <span class='executed'>        return x &lt; y ? y : x;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function min(int256 x, int256 y) internal pure returns (int256) {</span>
 28 | *   | <span class='executed'>        return x &lt; y ? x : y;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function min128(int128 x, int128 y) internal pure returns (int128) {</span>
 32 |     | <span class='neutral'>        return x &lt; y ? x : y;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>    function min(uint256 x, uint256 y) internal pure returns (uint256) {</span>
 36 | *   | <span class='executed'>        return x &lt; y ? x : y;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 | *   | <span class='executed'>    function min128(uint128 x, uint128 y) internal pure returns (uint128) {</span>
 40 | *   | <span class='executed'>        return x &lt; y ? x : y;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 | *   | <span class='executed'>    function sameSide(int256 a, int256 b) internal pure returns (bool) {</span>
 44 | *   | <span class='executed'>        return (a == 0) || (b == 0) || (a &gt; 0) == (b &gt; 0);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 | *   | <span class='executed'>    function isSameSideReducing(int128 a, int128 b) internal pure returns (bool) {</span>
 48 | *   | <span class='executed'>        return sameSide(a, b) &amp;&amp; abs(b) &lt; abs(a);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 | *   | <span class='executed'>    function ceilDivide(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 52 | *   | <span class='executed'>        if (b == 0) return 0;</span>
 53 | *   | <span class='executed'>        return a / b + (a % b == 0 ? 0 : 1);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/Base.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage} from &quot;./StdStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm, VmSafe} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract CommonBase {</span>
  8 |     | <span class='neutral'>    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.</span>
  9 | *   | <span class='executed'>    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));</span>
 10 |     | <span class='neutral'>    // console.sol and console2.sol work by executing a staticcall to this address.</span>
 11 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 12 |     | <span class='neutral'>    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 13 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 14 |     | <span class='neutral'>    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.</span>
 15 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))));</span>
 16 |     | <span class='neutral'>    // Address of the test contract, deployed by the DEFAULT_SENDER.</span>
 17 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 18 |     | <span class='neutral'>    // Deterministic deployment address of the Multicall3 contract.</span>
 19 |     | <span class='neutral'>    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;</span>
 20 |     | <span class='neutral'>    // The order of the secp256k1 curve.</span>
 21 |     | <span class='neutral'>    uint256 internal constant SECP256K1_ORDER =</span>
 22 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
 25 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 28 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
 34 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions {</span>
   8 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    event log(string);</span>
  11 |     | <span class='neutral'>    event logs(bytes);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event log_address(address);</span>
  14 |     | <span class='neutral'>    event log_bytes32(bytes32);</span>
  15 |     | <span class='neutral'>    event log_int(int256);</span>
  16 |     | <span class='neutral'>    event log_uint(uint256);</span>
  17 |     | <span class='neutral'>    event log_bytes(bytes);</span>
  18 |     | <span class='neutral'>    event log_string(string);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event log_named_address(string key, address val);</span>
  21 |     | <span class='neutral'>    event log_named_bytes32(string key, bytes32 val);</span>
  22 |     | <span class='neutral'>    event log_named_decimal_int(string key, int256 val, uint256 decimals);</span>
  23 |     | <span class='neutral'>    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);</span>
  24 |     | <span class='neutral'>    event log_named_int(string key, int256 val);</span>
  25 |     | <span class='neutral'>    event log_named_uint(string key, uint256 val);</span>
  26 |     | <span class='neutral'>    event log_named_bytes(string key, bytes val);</span>
  27 |     | <span class='neutral'>    event log_named_string(string key, string val);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
  30 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  31 |     | <span class='neutral'>    event log_array(address[] val);</span>
  32 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  33 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  34 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    bool private _failed;</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>    function failed() public view returns (bool) {</span>
  39 | *   | <span class='executed'>        if (_failed) {</span>
  40 |     | <span class='unexecuted'>            return _failed;</span>
  41 |     | <span class='neutral'>        } else {</span>
  42 | *   | <span class='executed'>            return vm.load(address(vm), bytes32(&quot;failed&quot;)) != bytes32(0);</span>
  43 |     | <span class='neutral'>        }</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function fail() internal virtual {</span>
  47 |     | <span class='neutral'>        vm.store(address(vm), bytes32(&quot;failed&quot;), bytes32(uint256(1)));</span>
  48 |     | <span class='neutral'>        _failed = true;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function assertTrue(bool data) internal pure virtual {</span>
  52 |     | <span class='neutral'>        vm.assertTrue(data);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function assertTrue(bool data, string memory err) internal pure virtual {</span>
  56 |     | <span class='neutral'>        vm.assertTrue(data, err);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function assertFalse(bool data) internal pure virtual {</span>
  60 |     | <span class='neutral'>        vm.assertFalse(data);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal pure virtual {</span>
  64 |     | <span class='neutral'>        vm.assertFalse(data, err);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function assertEq(bool left, bool right) internal pure virtual {</span>
  68 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function assertEq(bool left, bool right, string memory err) internal pure virtual {</span>
  72 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right) internal pure virtual {</span>
  76 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
  80 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
  84 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
  88 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) internal pure virtual {</span>
  92 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
  96 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 100 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 104 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function assertEq(address left, address right) internal pure virtual {</span>
 108 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    function assertEq(address left, address right, string memory err) internal pure virtual {</span>
 112 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 116 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 120 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 124 |     | <span class='neutral'>        assertEq(left, right);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 128 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function assertEq(string memory left, string memory right) internal pure virtual {</span>
 132 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 136 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 140 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 144 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 148 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 152 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 156 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 160 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 164 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 168 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 172 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 176 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 180 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 184 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 188 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 192 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 196 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 200 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    // Legacy helper</span>
 204 |     | <span class='neutral'>    function assertEqUint(uint256 left, uint256 right) internal pure virtual {</span>
 205 |     | <span class='neutral'>        assertEq(left, right);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) internal pure virtual {</span>
 209 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {</span>
 213 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) internal pure virtual {</span>
 217 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 221 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 225 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)</span>
 229 |     | <span class='neutral'>        internal</span>
 230 |     | <span class='neutral'>        pure</span>
 231 |     | <span class='neutral'>        virtual</span>
 232 |     | <span class='neutral'>    {</span>
 233 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) internal pure virtual {</span>
 237 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
 241 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 245 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 249 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    function assertNotEq(address left, address right) internal pure virtual {</span>
 253 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assertNotEq(address left, address right, string memory err) internal pure virtual {</span>
 257 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 261 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 265 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 269 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 273 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right) internal pure virtual {</span>
 277 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 281 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 285 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 289 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 293 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 297 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 301 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 305 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 309 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 313 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 317 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 321 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 325 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 329 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 333 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 337 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 341 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 345 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) internal pure virtual {</span>
 349 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 353 |     | <span class='neutral'>        vm.assertLt(left, right, err);</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 357 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 361 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) internal pure virtual {</span>
 365 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 366 |     | <span class='neutral'>    }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 369 |     | <span class='neutral'>        vm.assertLt(left, right, err);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 373 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 374 |     | <span class='neutral'>    }</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 377 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) internal pure virtual {</span>
 381 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 385 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 389 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 393 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) internal pure virtual {</span>
 397 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 401 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 405 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 409 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) internal pure virtual {</span>
 413 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 417 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 421 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 425 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) internal pure virtual {</span>
 429 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 433 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 437 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 441 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 442 |     | <span class='neutral'>    }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) internal pure virtual {</span>
 445 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 449 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 453 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 457 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) internal pure virtual {</span>
 461 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 465 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 466 |     | <span class='neutral'>    }</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 469 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 473 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 474 |     | <span class='neutral'>    }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {</span>
 477 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 478 |     | <span class='neutral'>    }</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)</span>
 481 |     | <span class='neutral'>        internal</span>
 482 |     | <span class='neutral'>        pure</span>
 483 |     | <span class='neutral'>        virtual</span>
 484 |     | <span class='neutral'>    {</span>
 485 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 486 |     | <span class='neutral'>    }</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)</span>
 489 |     | <span class='neutral'>        internal</span>
 490 |     | <span class='neutral'>        pure</span>
 491 |     | <span class='neutral'>        virtual</span>
 492 |     | <span class='neutral'>    {</span>
 493 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 494 |     | <span class='neutral'>    }</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 497 |     | <span class='neutral'>        uint256 left,</span>
 498 |     | <span class='neutral'>        uint256 right,</span>
 499 |     | <span class='neutral'>        uint256 maxDelta,</span>
 500 |     | <span class='neutral'>        uint256 decimals,</span>
 501 |     | <span class='neutral'>        string memory err</span>
 502 |     | <span class='neutral'>    ) internal pure virtual {</span>
 503 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {</span>
 507 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 508 |     | <span class='neutral'>    }</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {</span>
 511 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)</span>
 515 |     | <span class='neutral'>        internal</span>
 516 |     | <span class='neutral'>        pure</span>
 517 |     | <span class='neutral'>        virtual</span>
 518 |     | <span class='neutral'>    {</span>
 519 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)</span>
 523 |     | <span class='neutral'>        internal</span>
 524 |     | <span class='neutral'>        pure</span>
 525 |     | <span class='neutral'>        virtual</span>
 526 |     | <span class='neutral'>    {</span>
 527 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 528 |     | <span class='neutral'>    }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 531 |     | <span class='neutral'>        uint256 left,</span>
 532 |     | <span class='neutral'>        uint256 right,</span>
 533 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 534 |     | <span class='neutral'>    ) internal pure virtual {</span>
 535 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 539 |     | <span class='neutral'>        uint256 left,</span>
 540 |     | <span class='neutral'>        uint256 right,</span>
 541 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 542 |     | <span class='neutral'>        string memory err</span>
 543 |     | <span class='neutral'>    ) internal pure virtual {</span>
 544 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 545 |     | <span class='neutral'>    }</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 548 |     | <span class='neutral'>        uint256 left,</span>
 549 |     | <span class='neutral'>        uint256 right,</span>
 550 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 551 |     | <span class='neutral'>        uint256 decimals</span>
 552 |     | <span class='neutral'>    ) internal pure virtual {</span>
 553 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 554 |     | <span class='neutral'>    }</span>
 555 |     | <span class='neutral'></span>
 556 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 557 |     | <span class='neutral'>        uint256 left,</span>
 558 |     | <span class='neutral'>        uint256 right,</span>
 559 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 560 |     | <span class='neutral'>        uint256 decimals,</span>
 561 |     | <span class='neutral'>        string memory err</span>
 562 |     | <span class='neutral'>    ) internal pure virtual {</span>
 563 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {</span>
 567 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 571 |     | <span class='neutral'>        int256 left,</span>
 572 |     | <span class='neutral'>        int256 right,</span>
 573 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 574 |     | <span class='neutral'>        string memory err</span>
 575 |     | <span class='neutral'>    ) internal pure virtual {</span>
 576 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 580 |     | <span class='neutral'>        int256 left,</span>
 581 |     | <span class='neutral'>        int256 right,</span>
 582 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 583 |     | <span class='neutral'>        uint256 decimals</span>
 584 |     | <span class='neutral'>    ) internal pure virtual {</span>
 585 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 589 |     | <span class='neutral'>        int256 left,</span>
 590 |     | <span class='neutral'>        int256 right,</span>
 591 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 592 |     | <span class='neutral'>        uint256 decimals,</span>
 593 |     | <span class='neutral'>        string memory err</span>
 594 |     | <span class='neutral'>    ) internal pure virtual {</span>
 595 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 596 |     | <span class='neutral'>    }</span>
 597 |     | <span class='neutral'></span>
 598 |     | <span class='neutral'>    // Inherited from DSTest, not used but kept for backwards-compatibility</span>
 599 |     | <span class='neutral'>    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {</span>
 600 |     | <span class='neutral'>        return keccak256(left) == keccak256(right);</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 604 |     | <span class='neutral'>        assertEq(left, right);</span>
 605 |     | <span class='neutral'>    }</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 608 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 609 |     | <span class='neutral'>    }</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 612 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 616 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 617 |     | <span class='neutral'>    }</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {</span>
 620 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, true);</span>
 621 |     | <span class='neutral'>    }</span>
 622 |     | <span class='neutral'></span>
 623 |     | <span class='neutral'>    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)</span>
 624 |     | <span class='neutral'>        internal</span>
 625 |     | <span class='neutral'>        virtual</span>
 626 |     | <span class='neutral'>    {</span>
 627 |     | <span class='neutral'>        assertEqCall(targetA, callDataA, targetB, callDataB, true);</span>
 628 |     | <span class='neutral'>    }</span>
 629 |     | <span class='neutral'></span>
 630 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)</span>
 631 |     | <span class='neutral'>        internal</span>
 632 |     | <span class='neutral'>        virtual</span>
 633 |     | <span class='neutral'>    {</span>
 634 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, strictRevertData);</span>
 635 |     | <span class='neutral'>    }</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='neutral'>    function assertEqCall(</span>
 638 |     | <span class='neutral'>        address targetA,</span>
 639 |     | <span class='neutral'>        bytes memory callDataA,</span>
 640 |     | <span class='neutral'>        address targetB,</span>
 641 |     | <span class='neutral'>        bytes memory callDataB,</span>
 642 |     | <span class='neutral'>        bool strictRevertData</span>
 643 |     | <span class='neutral'>    ) internal virtual {</span>
 644 |     | <span class='neutral'>        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);</span>
 645 |     | <span class='neutral'>        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>        if (successA &amp;&amp; successB) {</span>
 648 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call return data does not match&quot;);</span>
 649 |     | <span class='neutral'>        }</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>        if (!successA &amp;&amp; !successB &amp;&amp; strictRevertData) {</span>
 652 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call revert data does not match&quot;);</span>
 653 |     | <span class='neutral'>        }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='neutral'>        if (!successA &amp;&amp; successB) {</span>
 656 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 657 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call revert data&quot;, returnDataA);</span>
 658 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call return data&quot;, returnDataB);</span>
 659 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 660 |     | <span class='neutral'>        }</span>
 661 |     | <span class='neutral'></span>
 662 |     | <span class='neutral'>        if (successA &amp;&amp; !successB) {</span>
 663 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 664 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call return data&quot;, returnDataA);</span>
 665 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call revert data&quot;, returnDataB);</span>
 666 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 667 |     | <span class='neutral'>        }</span>
 668 |     | <span class='neutral'>    }</span>
 669 |     | <span class='neutral'>}</span>
 670 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdChains.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * StdChains provides information about EVM compatible chains that can be used in scripts/tests.</span>
   8 |     | <span class='neutral'> * For each chain, the chain&#39;s name, chain ID, and a default RPC URL are provided. Chains are</span>
   9 |     | <span class='neutral'> * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of</span>
  10 |     | <span class='neutral'> * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the</span>
  11 |     | <span class='neutral'> * alias used in this contract, which can be found as the first argument to the</span>
  12 |     | <span class='neutral'> * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * There are two main ways to use this contract:</span>
  15 |     | <span class='neutral'> *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or</span>
  16 |     | <span class='neutral'> *      `setChain(string memory chainAlias, Chain memory chain)`</span>
  17 |     | <span class='neutral'> *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * The first time either of those are used, chains are initialized with the default set of RPC URLs.</span>
  20 |     | <span class='neutral'> * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in</span>
  21 |     | <span class='neutral'> * `defaultRpcUrls`.</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * The `setChain` function is straightforward, and it simply saves off the given chain data.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let&#39;s say</span>
  26 |     | <span class='neutral'> * we want to retrieve the RPC URL for `mainnet`:</span>
  27 |     | <span class='neutral'> *   - If you have specified data with `setChain`, it will return that.</span>
  28 |     | <span class='neutral'> *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it</span>
  29 |     | <span class='neutral'> *     is valid (e.g. a URL is specified, or an environment variable is given and exists).</span>
  30 |     | <span class='neutral'> *   - If neither of the above conditions is met, the default data is returned.</span>
  31 |     | <span class='neutral'> *</span>
  32 |     | <span class='neutral'> * Summarizing the above, the prioritization hierarchy is `setChain` -&gt; `foundry.toml` -&gt; environment variable -&gt; defaults.</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='neutral'>abstract contract StdChains {</span>
  35 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    bool private stdChainsInitialized;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct ChainData {</span>
  40 |     | <span class='neutral'>        string name;</span>
  41 |     | <span class='neutral'>        uint256 chainId;</span>
  42 |     | <span class='neutral'>        string rpcUrl;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct Chain {</span>
  46 |     | <span class='neutral'>        // The chain name.</span>
  47 |     | <span class='neutral'>        string name;</span>
  48 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  49 |     | <span class='neutral'>        uint256 chainId;</span>
  50 |     | <span class='neutral'>        // The chain&#39;s alias. (i.e. what gets specified in `foundry.toml`).</span>
  51 |     | <span class='neutral'>        string chainAlias;</span>
  52 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  53 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  54 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  55 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  56 |     | <span class='neutral'>        string rpcUrl;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    // Maps from the chain&#39;s alias (matching the alias in the `foundry.toml` file) to chain data.</span>
  60 |     | <span class='neutral'>    mapping(string =&gt; Chain) private chains;</span>
  61 |     | <span class='neutral'>    // Maps from the chain&#39;s alias to it&#39;s default RPC URL.</span>
  62 |     | <span class='neutral'>    mapping(string =&gt; string) private defaultRpcUrls;</span>
  63 |     | <span class='neutral'>    // Maps from a chain ID to it&#39;s alias.</span>
  64 |     | <span class='neutral'>    mapping(uint256 =&gt; string) private idToAlias;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    bool private fallbackToDefaultRpcUrls = true;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // The RPC URL will be fetched from config or defaultRpcUrls if possible.</span>
  69 |     | <span class='neutral'>    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {</span>
  70 |     | <span class='neutral'>        require(bytes(chainAlias).length != 0, &quot;StdChains getChain(string): Chain alias cannot be the empty string.&quot;);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        initializeStdChains();</span>
  73 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  74 |     | <span class='neutral'>        require(</span>
  75 |     | <span class='neutral'>            chain.chainId != 0,</span>
  76 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(string): Chain with alias \&quot;&quot;, chainAlias, &quot;\&quot; not found.&quot;))</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {</span>
  83 |     | <span class='neutral'>        require(chainId != 0, &quot;StdChains getChain(uint256): Chain ID cannot be 0.&quot;);</span>
  84 |     | <span class='neutral'>        initializeStdChains();</span>
  85 |     | <span class='neutral'>        string memory chainAlias = idToAlias[chainId];</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        require(</span>
  90 |     | <span class='neutral'>            chain.chainId != 0,</span>
  91 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(uint256): Chain with ID &quot;, vm.toString(chainId), &quot; not found.&quot;))</span>
  92 |     | <span class='neutral'>        );</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
  98 |     | <span class='neutral'>    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {</span>
  99 |     | <span class='neutral'>        require(</span>
 100 |     | <span class='neutral'>            bytes(chainAlias).length != 0,</span>
 101 |     | <span class='neutral'>            &quot;StdChains setChain(string,ChainData): Chain alias cannot be the empty string.&quot;</span>
 102 |     | <span class='neutral'>        );</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        require(chain.chainId != 0, &quot;StdChains setChain(string,ChainData): Chain ID cannot be 0.&quot;);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        initializeStdChains();</span>
 107 |     | <span class='neutral'>        string memory foundAlias = idToAlias[chain.chainId];</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        require(</span>
 110 |     | <span class='neutral'>            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),</span>
 111 |     | <span class='neutral'>            string(</span>
 112 |     | <span class='neutral'>                abi.encodePacked(</span>
 113 |     | <span class='neutral'>                    &quot;StdChains setChain(string,ChainData): Chain ID &quot;,</span>
 114 |     | <span class='neutral'>                    vm.toString(chain.chainId),</span>
 115 |     | <span class='neutral'>                    &quot; already used by \&quot;&quot;,</span>
 116 |     | <span class='neutral'>                    foundAlias,</span>
 117 |     | <span class='neutral'>                    &quot;\&quot;.&quot;</span>
 118 |     | <span class='neutral'>                )</span>
 119 |     | <span class='neutral'>            )</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        uint256 oldChainId = chains[chainAlias].chainId;</span>
 123 |     | <span class='neutral'>        delete idToAlias[oldChainId];</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>        chains[chainAlias] =</span>
 126 |     | <span class='neutral'>            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});</span>
 127 |     | <span class='neutral'>        idToAlias[chain.chainId] = chainAlias;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
 131 |     | <span class='neutral'>    function setChain(string memory chainAlias, Chain memory chain) internal virtual {</span>
 132 |     | <span class='neutral'>        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function _toUpper(string memory str) private pure returns (string memory) {</span>
 136 |     | <span class='neutral'>        bytes memory strb = bytes(str);</span>
 137 |     | <span class='neutral'>        bytes memory copy = new bytes(strb.length);</span>
 138 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; strb.length; i++) {</span>
 139 |     | <span class='neutral'>            bytes1 b = strb[i];</span>
 140 |     | <span class='neutral'>            if (b &gt;= 0x61 &amp;&amp; b &lt;= 0x7A) {</span>
 141 |     | <span class='neutral'>                copy[i] = bytes1(uint8(b) - 32);</span>
 142 |     | <span class='neutral'>            } else {</span>
 143 |     | <span class='neutral'>                copy[i] = b;</span>
 144 |     | <span class='neutral'>            }</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>        return string(copy);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    // lookup rpcUrl, in descending order of priority:</span>
 150 |     | <span class='neutral'>    // current -&gt; config (foundry.toml) -&gt; environment variable -&gt; default</span>
 151 |     | <span class='neutral'>    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)</span>
 152 |     | <span class='neutral'>        private</span>
 153 |     | <span class='neutral'>        view</span>
 154 |     | <span class='neutral'>        returns (Chain memory)</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        if (bytes(chain.rpcUrl).length == 0) {</span>
 157 |     | <span class='neutral'>            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {</span>
 158 |     | <span class='neutral'>                chain.rpcUrl = configRpcUrl;</span>
 159 |     | <span class='neutral'>            } catch (bytes memory err) {</span>
 160 |     | <span class='neutral'>                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), &quot;_RPC_URL&quot;));</span>
 161 |     | <span class='neutral'>                if (fallbackToDefaultRpcUrls) {</span>
 162 |     | <span class='neutral'>                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);</span>
 163 |     | <span class='neutral'>                } else {</span>
 164 |     | <span class='neutral'>                    chain.rpcUrl = vm.envString(envName);</span>
 165 |     | <span class='neutral'>                }</span>
 166 |     | <span class='neutral'>                // Distinguish &#39;not found&#39; from &#39;cannot read&#39;</span>
 167 |     | <span class='neutral'>                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions</span>
 168 |     | <span class='neutral'>                bytes memory oldNotFoundError =</span>
 169 |     | <span class='neutral'>                    abi.encodeWithSignature(&quot;CheatCodeError&quot;, string(abi.encodePacked(&quot;invalid rpc url &quot;, chainAlias)));</span>
 170 |     | <span class='neutral'>                bytes memory newNotFoundError = abi.encodeWithSignature(</span>
 171 |     | <span class='neutral'>                    &quot;CheatcodeError(string)&quot;, string(abi.encodePacked(&quot;invalid rpc url: &quot;, chainAlias))</span>
 172 |     | <span class='neutral'>                );</span>
 173 |     | <span class='neutral'>                bytes32 errHash = keccak256(err);</span>
 174 |     | <span class='neutral'>                if (</span>
 175 |     | <span class='neutral'>                    (errHash != keccak256(oldNotFoundError) &amp;&amp; errHash != keccak256(newNotFoundError))</span>
 176 |     | <span class='neutral'>                        || bytes(chain.rpcUrl).length == 0</span>
 177 |     | <span class='neutral'>                ) {</span>
 178 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 179 |     | <span class='neutral'>                    assembly {</span>
 180 |     | <span class='neutral'>                        revert(add(32, err), mload(err))</span>
 181 |     | <span class='neutral'>                    }</span>
 182 |     | <span class='neutral'>                }</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>        return chain;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    function setFallbackToDefaultRpcUrls(bool useDefault) internal {</span>
 189 |     | <span class='neutral'>        fallbackToDefaultRpcUrls = useDefault;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function initializeStdChains() private {</span>
 193 |     | <span class='neutral'>        if (stdChainsInitialized) return;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        stdChainsInitialized = true;</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`</span>
 198 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;anvil&quot;, ChainData(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;));</span>
 199 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 200 |     | <span class='neutral'>            &quot;mainnet&quot;, ChainData(&quot;Mainnet&quot;, 1, &quot;https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP&quot;)</span>
 201 |     | <span class='neutral'>        );</span>
 202 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 203 |     | <span class='neutral'>            &quot;sepolia&quot;, ChainData(&quot;Sepolia&quot;, 11155111, &quot;https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001&quot;)</span>
 204 |     | <span class='neutral'>        );</span>
 205 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;holesky&quot;, ChainData(&quot;Holesky&quot;, 17000, &quot;https://rpc.holesky.ethpandaops.io&quot;));</span>
 206 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism&quot;, ChainData(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;));</span>
 207 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 208 |     | <span class='neutral'>            &quot;optimism_sepolia&quot;, ChainData(&quot;Optimism Sepolia&quot;, 11155420, &quot;https://sepolia.optimism.io&quot;)</span>
 209 |     | <span class='neutral'>        );</span>
 210 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_one&quot;, ChainData(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;));</span>
 211 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 212 |     | <span class='neutral'>            &quot;arbitrum_one_sepolia&quot;, ChainData(&quot;Arbitrum One Sepolia&quot;, 421614, &quot;https://sepolia-rollup.arbitrum.io/rpc&quot;)</span>
 213 |     | <span class='neutral'>        );</span>
 214 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_nova&quot;, ChainData(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;));</span>
 215 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon&quot;, ChainData(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;));</span>
 216 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 217 |     | <span class='neutral'>            &quot;polygon_amoy&quot;, ChainData(&quot;Polygon Amoy&quot;, 80002, &quot;https://rpc-amoy.polygon.technology&quot;)</span>
 218 |     | <span class='neutral'>        );</span>
 219 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;avalanche&quot;, ChainData(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;));</span>
 220 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 221 |     | <span class='neutral'>            &quot;avalanche_fuji&quot;, ChainData(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;)</span>
 222 |     | <span class='neutral'>        );</span>
 223 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 224 |     | <span class='neutral'>            &quot;bnb_smart_chain&quot;, ChainData(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;)</span>
 225 |     | <span class='neutral'>        );</span>
 226 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 227 |     | <span class='neutral'>            &quot;bnb_smart_chain_testnet&quot;,</span>
 228 |     | <span class='neutral'>            ChainData(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://rpc.ankr.com/bsc_testnet_chapel&quot;)</span>
 229 |     | <span class='neutral'>        );</span>
 230 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;gnosis_chain&quot;, ChainData(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;));</span>
 231 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbeam&quot;, ChainData(&quot;Moonbeam&quot;, 1284, &quot;https://rpc.api.moonbeam.network&quot;));</span>
 232 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 233 |     | <span class='neutral'>            &quot;moonriver&quot;, ChainData(&quot;Moonriver&quot;, 1285, &quot;https://rpc.api.moonriver.moonbeam.network&quot;)</span>
 234 |     | <span class='neutral'>        );</span>
 235 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbase&quot;, ChainData(&quot;Moonbase&quot;, 1287, &quot;https://rpc.testnet.moonbeam.network&quot;));</span>
 236 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base_sepolia&quot;, ChainData(&quot;Base Sepolia&quot;, 84532, &quot;https://sepolia.base.org&quot;));</span>
 237 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base&quot;, ChainData(&quot;Base&quot;, 8453, &quot;https://mainnet.base.org&quot;));</span>
 238 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast_sepolia&quot;, ChainData(&quot;Blast Sepolia&quot;, 168587773, &quot;https://sepolia.blast.io&quot;));</span>
 239 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast&quot;, ChainData(&quot;Blast&quot;, 81457, &quot;https://rpc.blast.io&quot;));</span>
 240 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fantom_opera&quot;, ChainData(&quot;Fantom Opera&quot;, 250, &quot;https://rpc.ankr.com/fantom/&quot;));</span>
 241 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 242 |     | <span class='neutral'>            &quot;fantom_opera_testnet&quot;, ChainData(&quot;Fantom Opera Testnet&quot;, 4002, &quot;https://rpc.ankr.com/fantom_testnet/&quot;)</span>
 243 |     | <span class='neutral'>        );</span>
 244 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal&quot;, ChainData(&quot;Fraxtal&quot;, 252, &quot;https://rpc.frax.com&quot;));</span>
 245 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal_testnet&quot;, ChainData(&quot;Fraxtal Testnet&quot;, 2522, &quot;https://rpc.testnet.frax.com&quot;));</span>
 246 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 247 |     | <span class='neutral'>            &quot;berachain_bartio_testnet&quot;, ChainData(&quot;Berachain bArtio Testnet&quot;, 80084, &quot;https://bartio.rpc.berachain.com&quot;)</span>
 248 |     | <span class='neutral'>        );</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    // set chain info, with priority to chainAlias&#39; rpc url in foundry.toml</span>
 252 |     | <span class='neutral'>    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {</span>
 253 |     | <span class='neutral'>        string memory rpcUrl = chain.rpcUrl;</span>
 254 |     | <span class='neutral'>        defaultRpcUrls[chainAlias] = rpcUrl;</span>
 255 |     | <span class='neutral'>        chain.rpcUrl = &quot;&quot;;</span>
 256 |     | <span class='neutral'>        setChain(chainAlias, chain);</span>
 257 |     | <span class='neutral'>        chain.rpcUrl = rpcUrl; // restore argument</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'>}</span>
 260 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  11 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  14 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    bool private gasMeteringOff;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  19 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  20 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct RawTx1559 {</span>
  23 |     | <span class='neutral'>        string[] arguments;</span>
  24 |     | <span class='neutral'>        address contractAddress;</span>
  25 |     | <span class='neutral'>        string contractName;</span>
  26 |     | <span class='neutral'>        // json value name = function</span>
  27 |     | <span class='neutral'>        string functionSig;</span>
  28 |     | <span class='neutral'>        bytes32 hash;</span>
  29 |     | <span class='neutral'>        // json value name = tx</span>
  30 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  31 |     | <span class='neutral'>        // json value name = type</span>
  32 |     | <span class='neutral'>        string opcode;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  36 |     | <span class='neutral'>        AccessList[] accessList;</span>
  37 |     | <span class='neutral'>        bytes data;</span>
  38 |     | <span class='neutral'>        address from;</span>
  39 |     | <span class='neutral'>        bytes gas;</span>
  40 |     | <span class='neutral'>        bytes nonce;</span>
  41 |     | <span class='neutral'>        address to;</span>
  42 |     | <span class='neutral'>        bytes txType;</span>
  43 |     | <span class='neutral'>        bytes value;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    struct Tx1559 {</span>
  47 |     | <span class='neutral'>        string[] arguments;</span>
  48 |     | <span class='neutral'>        address contractAddress;</span>
  49 |     | <span class='neutral'>        string contractName;</span>
  50 |     | <span class='neutral'>        string functionSig;</span>
  51 |     | <span class='neutral'>        bytes32 hash;</span>
  52 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  53 |     | <span class='neutral'>        string opcode;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  57 |     | <span class='neutral'>        AccessList[] accessList;</span>
  58 |     | <span class='neutral'>        bytes data;</span>
  59 |     | <span class='neutral'>        address from;</span>
  60 |     | <span class='neutral'>        uint256 gas;</span>
  61 |     | <span class='neutral'>        uint256 nonce;</span>
  62 |     | <span class='neutral'>        address to;</span>
  63 |     | <span class='neutral'>        uint256 txType;</span>
  64 |     | <span class='neutral'>        uint256 value;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  68 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  69 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    struct TxLegacy {</span>
  72 |     | <span class='neutral'>        string[] arguments;</span>
  73 |     | <span class='neutral'>        address contractAddress;</span>
  74 |     | <span class='neutral'>        string contractName;</span>
  75 |     | <span class='neutral'>        string functionSig;</span>
  76 |     | <span class='neutral'>        string hash;</span>
  77 |     | <span class='neutral'>        string opcode;</span>
  78 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  82 |     | <span class='neutral'>        AccessList[] accessList;</span>
  83 |     | <span class='neutral'>        uint256 chainId;</span>
  84 |     | <span class='neutral'>        bytes data;</span>
  85 |     | <span class='neutral'>        address from;</span>
  86 |     | <span class='neutral'>        uint256 gas;</span>
  87 |     | <span class='neutral'>        uint256 gasPrice;</span>
  88 |     | <span class='neutral'>        bytes32 hash;</span>
  89 |     | <span class='neutral'>        uint256 nonce;</span>
  90 |     | <span class='neutral'>        bytes1 opcode;</span>
  91 |     | <span class='neutral'>        bytes32 r;</span>
  92 |     | <span class='neutral'>        bytes32 s;</span>
  93 |     | <span class='neutral'>        uint256 txType;</span>
  94 |     | <span class='neutral'>        address to;</span>
  95 |     | <span class='neutral'>        uint8 v;</span>
  96 |     | <span class='neutral'>        uint256 value;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    struct AccessList {</span>
 100 |     | <span class='neutral'>        address accessAddress;</span>
 101 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 105 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 106 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    struct RawReceipt {</span>
 109 |     | <span class='neutral'>        bytes32 blockHash;</span>
 110 |     | <span class='neutral'>        bytes blockNumber;</span>
 111 |     | <span class='neutral'>        address contractAddress;</span>
 112 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 113 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 114 |     | <span class='neutral'>        address from;</span>
 115 |     | <span class='neutral'>        bytes gasUsed;</span>
 116 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 117 |     | <span class='neutral'>        bytes logsBloom;</span>
 118 |     | <span class='neutral'>        bytes status;</span>
 119 |     | <span class='neutral'>        address to;</span>
 120 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 121 |     | <span class='neutral'>        bytes transactionIndex;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    struct Receipt {</span>
 125 |     | <span class='neutral'>        bytes32 blockHash;</span>
 126 |     | <span class='neutral'>        uint256 blockNumber;</span>
 127 |     | <span class='neutral'>        address contractAddress;</span>
 128 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 129 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 130 |     | <span class='neutral'>        address from;</span>
 131 |     | <span class='neutral'>        uint256 gasUsed;</span>
 132 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 133 |     | <span class='neutral'>        bytes logsBloom;</span>
 134 |     | <span class='neutral'>        uint256 status;</span>
 135 |     | <span class='neutral'>        address to;</span>
 136 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 137 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 141 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 144 |     | <span class='neutral'>        string[] libraries;</span>
 145 |     | <span class='neutral'>        string path;</span>
 146 |     | <span class='neutral'>        string[] pending;</span>
 147 |     | <span class='neutral'>        Receipt[] receipts;</span>
 148 |     | <span class='neutral'>        uint256 timestamp;</span>
 149 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 150 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 154 |     | <span class='neutral'>        string[] libraries;</span>
 155 |     | <span class='neutral'>        string path;</span>
 156 |     | <span class='neutral'>        string[] pending;</span>
 157 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 158 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 159 |     | <span class='neutral'>        uint256 timestamp;</span>
 160 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 164 |     | <span class='neutral'>        // json value = address</span>
 165 |     | <span class='neutral'>        address logAddress;</span>
 166 |     | <span class='neutral'>        bytes32 blockHash;</span>
 167 |     | <span class='neutral'>        bytes blockNumber;</span>
 168 |     | <span class='neutral'>        bytes data;</span>
 169 |     | <span class='neutral'>        bytes logIndex;</span>
 170 |     | <span class='neutral'>        bool removed;</span>
 171 |     | <span class='neutral'>        bytes32[] topics;</span>
 172 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 173 |     | <span class='neutral'>        bytes transactionIndex;</span>
 174 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    struct ReceiptLog {</span>
 178 |     | <span class='neutral'>        // json value = address</span>
 179 |     | <span class='neutral'>        address logAddress;</span>
 180 |     | <span class='neutral'>        bytes32 blockHash;</span>
 181 |     | <span class='neutral'>        uint256 blockNumber;</span>
 182 |     | <span class='neutral'>        bytes data;</span>
 183 |     | <span class='neutral'>        uint256 logIndex;</span>
 184 |     | <span class='neutral'>        bytes32[] topics;</span>
 185 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 186 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 187 |     | <span class='neutral'>        bool removed;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    struct TxReturn {</span>
 191 |     | <span class='neutral'>        string internalType;</span>
 192 |     | <span class='neutral'>        string value;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    struct Account {</span>
 196 |     | <span class='neutral'>        address addr;</span>
 197 |     | <span class='neutral'>        uint256 key;</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    enum AddressType {</span>
 201 |     | <span class='neutral'>        Payable,</span>
 202 |     | <span class='neutral'>        NonPayable,</span>
 203 |     | <span class='neutral'>        ZeroAddress,</span>
 204 |     | <span class='neutral'>        Precompile,</span>
 205 |     | <span class='neutral'>        ForgeAddress</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 209 |     | <span class='neutral'>    function assumeNotBlacklisted(address token, address addr) internal view virtual {</span>
 210 |     | <span class='neutral'>        // Nothing to check if `token` is not a contract.</span>
 211 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 212 |     | <span class='neutral'>        assembly {</span>
 213 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.&quot;);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        bool success;</span>
 218 |     | <span class='neutral'>        bytes memory returnData;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // 4-byte selector for `isBlacklisted(address)`, used by USDC.</span>
 221 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));</span>
 222 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // 4-byte selector for `isBlackListed(address)`, used by USDT.</span>
 225 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));</span>
 226 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 230 |     | <span class='neutral'>    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for</span>
 231 |     | <span class='neutral'>    // backwards compatibility, since this name was used in the original PR which has already has</span>
 232 |     | <span class='neutral'>    // a release. This function can be removed in a future release once we want a breaking change.</span>
 233 |     | <span class='neutral'>    function assumeNoBlacklisted(address token, address addr) internal view virtual {</span>
 234 |     | <span class='neutral'>        assumeNotBlacklisted(token, addr);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {</span>
 238 |     | <span class='neutral'>        if (addressType == AddressType.Payable) {</span>
 239 |     | <span class='neutral'>            assumeNotPayable(addr);</span>
 240 |     | <span class='neutral'>        } else if (addressType == AddressType.NonPayable) {</span>
 241 |     | <span class='neutral'>            assumePayable(addr);</span>
 242 |     | <span class='neutral'>        } else if (addressType == AddressType.ZeroAddress) {</span>
 243 |     | <span class='neutral'>            assumeNotZeroAddress(addr);</span>
 244 |     | <span class='neutral'>        } else if (addressType == AddressType.Precompile) {</span>
 245 |     | <span class='neutral'>            assumeNotPrecompile(addr);</span>
 246 |     | <span class='neutral'>        } else if (addressType == AddressType.ForgeAddress) {</span>
 247 |     | <span class='neutral'>            assumeNotForgeAddress(addr);</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {</span>
 252 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 253 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 257 |     | <span class='neutral'>        address addr,</span>
 258 |     | <span class='neutral'>        AddressType addressType1,</span>
 259 |     | <span class='neutral'>        AddressType addressType2,</span>
 260 |     | <span class='neutral'>        AddressType addressType3</span>
 261 |     | <span class='neutral'>    ) internal virtual {</span>
 262 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 263 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 264 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 268 |     | <span class='neutral'>        address addr,</span>
 269 |     | <span class='neutral'>        AddressType addressType1,</span>
 270 |     | <span class='neutral'>        AddressType addressType2,</span>
 271 |     | <span class='neutral'>        AddressType addressType3,</span>
 272 |     | <span class='neutral'>        AddressType addressType4</span>
 273 |     | <span class='neutral'>    ) internal virtual {</span>
 274 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 275 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 276 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 277 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType4);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to</span>
 281 |     | <span class='neutral'>    // `addr` and checking the `success` return value.</span>
 282 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 283 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used.</span>
 284 |     | <span class='neutral'>    function _isPayable(address addr) private returns (bool) {</span>
 285 |     | <span class='neutral'>        require(</span>
 286 |     | <span class='neutral'>            addr.balance &lt; UINT256_MAX,</span>
 287 |     | <span class='neutral'>            &quot;StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds&quot;</span>
 288 |     | <span class='neutral'>        );</span>
 289 |     | <span class='neutral'>        uint256 origBalanceTest = address(this).balance;</span>
 290 |     | <span class='neutral'>        uint256 origBalanceAddr = address(addr).balance;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        vm.deal(address(this), 1);</span>
 293 |     | <span class='neutral'>        (bool success,) = payable(addr).call{value: 1}(&quot;&quot;);</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>        // reset balances</span>
 296 |     | <span class='neutral'>        vm.deal(address(this), origBalanceTest);</span>
 297 |     | <span class='neutral'>        vm.deal(addr, origBalanceAddr);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>        return success;</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 303 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used. See the</span>
 304 |     | <span class='neutral'>    // `_isPayable` method for more information.</span>
 305 |     | <span class='neutral'>    function assumePayable(address addr) internal virtual {</span>
 306 |     | <span class='neutral'>        vm.assume(_isPayable(addr));</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    function assumeNotPayable(address addr) internal virtual {</span>
 310 |     | <span class='neutral'>        vm.assume(!_isPayable(addr));</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>    function assumeNotZeroAddress(address addr) internal pure virtual {</span>
 314 |     | <span class='neutral'>        vm.assume(addr != address(0));</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>    function assumeNotPrecompile(address addr) internal pure virtual {</span>
 318 |     | <span class='neutral'>        assumeNotPrecompile(addr, _pureChainId());</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {</span>
 322 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 323 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        // These should be present on all EVM-compatible chains.</span>
 326 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0x9));</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 329 |     | <span class='neutral'>        if (chainId == 10 || chainId == 420) {</span>
 330 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 331 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 332 |     | <span class='neutral'>        } else if (chainId == 42161 || chainId == 421613) {</span>
 333 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 334 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 335 |     | <span class='neutral'>        } else if (chainId == 43114 || chainId == 43113) {</span>
 336 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 337 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 338 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 339 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assumeNotForgeAddress(address addr) internal pure virtual {</span>
 345 |     | <span class='neutral'>        // vm, console, and Create2Deployer addresses</span>
 346 |     | <span class='neutral'>        vm.assume(</span>
 347 |     | <span class='neutral'>            addr != address(vm) &amp;&amp; addr != 0x000000000000000000636F6e736F6c652e6c6f67</span>
 348 |     | <span class='neutral'>                &amp;&amp; addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C</span>
 349 |     | <span class='neutral'>        );</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 353 |     | <span class='neutral'>        internal</span>
 354 |     | <span class='neutral'>        view</span>
 355 |     | <span class='neutral'>        virtual</span>
 356 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 357 |     | <span class='neutral'>    {</span>
 358 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 359 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 360 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 361 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 362 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 363 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 364 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 365 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 366 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 367 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 368 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 369 |     | <span class='neutral'>        return artifact;</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 373 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 374 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 375 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'>        return txs;</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 381 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 382 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 383 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 384 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 385 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 386 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 387 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 388 |     | <span class='neutral'>        return transaction;</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 392 |     | <span class='neutral'>        internal</span>
 393 |     | <span class='neutral'>        pure</span>
 394 |     | <span class='neutral'>        virtual</span>
 395 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 396 |     | <span class='neutral'>    {</span>
 397 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 398 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 399 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 400 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 401 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 402 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 403 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 404 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 405 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 406 |     | <span class='neutral'>        return txDetail;</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 410 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 411 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 412 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 413 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 417 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 418 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 419 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 420 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 421 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 425 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 426 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 427 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 428 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 429 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 433 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 434 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 435 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 436 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 437 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 441 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 442 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 443 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 444 |     | <span class='neutral'>        }</span>
 445 |     | <span class='neutral'>        return receipts;</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 449 |     | <span class='neutral'>        Receipt memory receipt;</span>
 450 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 451 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 452 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 453 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 454 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 455 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 456 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 457 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 458 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 459 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 460 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 461 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 462 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 463 |     | <span class='neutral'>        return receipt;</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 467 |     | <span class='neutral'>        internal</span>
 468 |     | <span class='neutral'>        pure</span>
 469 |     | <span class='neutral'>        virtual</span>
 470 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 471 |     | <span class='neutral'>    {</span>
 472 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 473 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 474 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 475 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 476 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 477 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 478 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 479 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 480 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 481 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 482 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 483 |     | <span class='neutral'>        }</span>
 484 |     | <span class='neutral'>        return logs;</span>
 485 |     | <span class='neutral'>    }</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 488 |     | <span class='neutral'>    // the artifacts directory</span>
 489 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 490 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 491 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 492 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 493 |     | <span class='neutral'>        assembly {</span>
 494 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 495 |     | <span class='neutral'>        }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 498 |     | <span class='neutral'>    }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 501 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 502 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 503 |     | <span class='neutral'>        assembly {</span>
 504 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 505 |     | <span class='neutral'>        }</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 508 |     | <span class='neutral'>    }</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 511 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 512 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 513 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 514 |     | <span class='neutral'>        assembly {</span>
 515 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 519 |     | <span class='neutral'>    }</span>
 520 |     | <span class='neutral'></span>
 521 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 522 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 523 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 524 |     | <span class='neutral'>        assembly {</span>
 525 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 526 |     | <span class='neutral'>        }</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 529 |     | <span class='neutral'>    }</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 532 |     | <span class='neutral'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 533 |     | <span class='neutral'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 534 |     | <span class='neutral'>        addr = vm.addr(privateKey);</span>
 535 |     | <span class='neutral'>        vm.label(addr, name);</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    // creates a labeled address</span>
 539 |     | <span class='neutral'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 540 |     | <span class='neutral'>        (addr,) = makeAddrAndKey(name);</span>
 541 |     | <span class='neutral'>    }</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='neutral'>    // Destroys an account immediately, sending the balance to beneficiary.</span>
 544 |     | <span class='neutral'>    // Destroying means: balance will be zero, code will be empty, and nonce will be 0</span>
 545 |     | <span class='neutral'>    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce</span>
 546 |     | <span class='neutral'>    // only after tx ends, this will run immediately.</span>
 547 |     | <span class='neutral'>    function destroyAccount(address who, address beneficiary) internal virtual {</span>
 548 |     | <span class='neutral'>        uint256 currBalance = who.balance;</span>
 549 |     | <span class='neutral'>        vm.etch(who, abi.encode());</span>
 550 |     | <span class='neutral'>        vm.deal(who, 0);</span>
 551 |     | <span class='neutral'>        vm.resetNonce(who);</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>        uint256 beneficiaryBalance = beneficiary.balance;</span>
 554 |     | <span class='neutral'>        vm.deal(beneficiary, currBalance + beneficiaryBalance);</span>
 555 |     | <span class='neutral'>    }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>    // creates a struct containing both a labeled address and the corresponding private key</span>
 558 |     | <span class='neutral'>    function makeAccount(string memory name) internal virtual returns (Account memory account) {</span>
 559 |     | <span class='neutral'>        (account.addr, account.key) = makeAddrAndKey(name);</span>
 560 |     | <span class='neutral'>    }</span>
 561 |     | <span class='neutral'></span>
 562 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 563 |     | <span class='neutral'>        internal</span>
 564 |     | <span class='neutral'>        virtual</span>
 565 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 566 |     | <span class='neutral'>    {</span>
 567 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 568 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 569 |     | <span class='neutral'>    }</span>
 570 |     | <span class='neutral'></span>
 571 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 572 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 573 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 574 |     | <span class='neutral'>    }</span>
 575 |     | <span class='neutral'></span>
 576 |     | <span class='neutral'>    function isFork() internal view virtual returns (bool status) {</span>
 577 |     | <span class='neutral'>        try vm.activeFork() {</span>
 578 |     | <span class='neutral'>            status = true;</span>
 579 |     | <span class='neutral'>        } catch (bytes memory) {}</span>
 580 |     | <span class='neutral'>    }</span>
 581 |     | <span class='neutral'></span>
 582 |     | <span class='neutral'>    modifier skipWhenForking() {</span>
 583 |     | <span class='neutral'>        if (!isFork()) {</span>
 584 |     | <span class='neutral'>            _;</span>
 585 |     | <span class='neutral'>        }</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    modifier skipWhenNotForking() {</span>
 589 |     | <span class='neutral'>        if (isFork()) {</span>
 590 |     | <span class='neutral'>            _;</span>
 591 |     | <span class='neutral'>        }</span>
 592 |     | <span class='neutral'>    }</span>
 593 |     | <span class='neutral'></span>
 594 |     | <span class='neutral'>    modifier noGasMetering() {</span>
 595 |     | <span class='neutral'>        vm.pauseGasMetering();</span>
 596 |     | <span class='neutral'>        // To prevent turning gas monitoring back on with nested functions that use this modifier,</span>
 597 |     | <span class='neutral'>        // we check if gasMetering started in the off position. If it did, we don&#39;t want to turn</span>
 598 |     | <span class='neutral'>        // it back on until we exit the top level function that used the modifier</span>
 599 |     | <span class='neutral'>        //</span>
 600 |     | <span class='neutral'>        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.</span>
 601 |     | <span class='neutral'>        // funcA will have `gasStartedOff` as false, funcB will have it as true,</span>
 602 |     | <span class='neutral'>        // so we only turn metering back on at the end of the funcA</span>
 603 |     | <span class='neutral'>        bool gasStartedOff = gasMeteringOff;</span>
 604 |     | <span class='neutral'>        gasMeteringOff = true;</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='neutral'>        _;</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='neutral'>        // if gas metering was on when this modifier was called, turn it back on at the end</span>
 609 |     | <span class='neutral'>        if (!gasStartedOff) {</span>
 610 |     | <span class='neutral'>            gasMeteringOff = false;</span>
 611 |     | <span class='neutral'>            vm.resumeGasMetering();</span>
 612 |     | <span class='neutral'>        }</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 616 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 617 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 618 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 619 |     | <span class='neutral'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 620 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 621 |     | <span class='neutral'>        assembly {</span>
 622 |     | <span class='neutral'>            chainId := chainid()</span>
 623 |     | <span class='neutral'>        }</span>
 624 |     | <span class='neutral'></span>
 625 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 626 |     | <span class='neutral'>    }</span>
 627 |     | <span class='neutral'></span>
 628 |     | <span class='neutral'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 629 |     | <span class='neutral'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 630 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 631 |     | <span class='neutral'>        assembly {</span>
 632 |     | <span class='neutral'>            pureChainId := fnIn</span>
 633 |     | <span class='neutral'>        }</span>
 634 |     | <span class='neutral'>        chainId = pureChainId();</span>
 635 |     | <span class='neutral'>    }</span>
 636 |     | <span class='neutral'>}</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 639 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 640 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 641 |     | <span class='neutral'></span>
 642 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 643 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 644 |     | <span class='neutral'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 645 |     | <span class='neutral'></span>
 646 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 647 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 648 |     | <span class='neutral'>        vm.warp(block.timestamp + time);</span>
 649 |     | <span class='neutral'>    }</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 652 |     | <span class='neutral'>        vm.warp(block.timestamp - time);</span>
 653 |     | <span class='neutral'>    }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 656 |     | <span class='neutral'>    function hoax(address msgSender) internal virtual {</span>
 657 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 658 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 659 |     | <span class='neutral'>    }</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='neutral'>    function hoax(address msgSender, uint256 give) internal virtual {</span>
 662 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 663 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 664 |     | <span class='neutral'>    }</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='neutral'>    function hoax(address msgSender, address origin) internal virtual {</span>
 667 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 668 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 669 |     | <span class='neutral'>    }</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='neutral'>    function hoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 672 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 673 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 674 |     | <span class='neutral'>    }</span>
 675 |     | <span class='neutral'></span>
 676 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 677 |     | <span class='neutral'>    function startHoax(address msgSender) internal virtual {</span>
 678 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 679 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 680 |     | <span class='neutral'>    }</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='neutral'>    function startHoax(address msgSender, uint256 give) internal virtual {</span>
 683 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 684 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 685 |     | <span class='neutral'>    }</span>
 686 |     | <span class='neutral'></span>
 687 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 688 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 689 |     | <span class='neutral'>    function startHoax(address msgSender, address origin) internal virtual {</span>
 690 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 691 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 692 |     | <span class='neutral'>    }</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    function startHoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 695 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 696 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 697 |     | <span class='neutral'>    }</span>
 698 |     | <span class='neutral'></span>
 699 |     | <span class='neutral'>    function changePrank(address msgSender) internal virtual {</span>
 700 |     | <span class='neutral'>        console2_log_StdCheats(&quot;changePrank is deprecated. Please use vm.startPrank instead.&quot;);</span>
 701 |     | <span class='neutral'>        vm.stopPrank();</span>
 702 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 703 |     | <span class='neutral'>    }</span>
 704 |     | <span class='neutral'></span>
 705 |     | <span class='neutral'>    function changePrank(address msgSender, address txOrigin) internal virtual {</span>
 706 |     | <span class='neutral'>        vm.stopPrank();</span>
 707 |     | <span class='neutral'>        vm.startPrank(msgSender, txOrigin);</span>
 708 |     | <span class='neutral'>    }</span>
 709 |     | <span class='neutral'></span>
 710 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 711 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 712 |     | <span class='neutral'>    function deal(address to, uint256 give) internal virtual {</span>
 713 |     | <span class='neutral'>        vm.deal(to, give);</span>
 714 |     | <span class='neutral'>    }</span>
 715 |     | <span class='neutral'></span>
 716 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 717 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 718 |     | <span class='neutral'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 719 |     | <span class='neutral'>        deal(token, to, give, false);</span>
 720 |     | <span class='neutral'>    }</span>
 721 |     | <span class='neutral'></span>
 722 |     | <span class='neutral'>    // Set the balance of an account for any ERC1155 token</span>
 723 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 724 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {</span>
 725 |     | <span class='neutral'>        dealERC1155(token, to, id, give, false);</span>
 726 |     | <span class='neutral'>    }</span>
 727 |     | <span class='neutral'></span>
 728 |     | <span class='neutral'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 729 |     | <span class='neutral'>        // get current balance</span>
 730 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 731 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 732 |     | <span class='neutral'></span>
 733 |     | <span class='neutral'>        // update balance</span>
 734 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 735 |     | <span class='neutral'></span>
 736 |     | <span class='neutral'>        // update total supply</span>
 737 |     | <span class='neutral'>        if (adjust) {</span>
 738 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));</span>
 739 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 740 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 741 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 742 |     | <span class='neutral'>            } else {</span>
 743 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 744 |     | <span class='neutral'>            }</span>
 745 |     | <span class='neutral'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 746 |     | <span class='neutral'>        }</span>
 747 |     | <span class='neutral'>    }</span>
 748 |     | <span class='neutral'></span>
 749 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {</span>
 750 |     | <span class='neutral'>        // get current balance</span>
 751 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));</span>
 752 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 753 |     | <span class='neutral'></span>
 754 |     | <span class='neutral'>        // update balance</span>
 755 |     | <span class='neutral'>        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);</span>
 756 |     | <span class='neutral'></span>
 757 |     | <span class='neutral'>        // update total supply</span>
 758 |     | <span class='neutral'>        if (adjust) {</span>
 759 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));</span>
 760 |     | <span class='neutral'>            require(</span>
 761 |     | <span class='neutral'>                totSupData.length != 0,</span>
 762 |     | <span class='neutral'>                &quot;StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.&quot;</span>
 763 |     | <span class='neutral'>            );</span>
 764 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 765 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 766 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 767 |     | <span class='neutral'>            } else {</span>
 768 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 769 |     | <span class='neutral'>            }</span>
 770 |     | <span class='neutral'>            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);</span>
 771 |     | <span class='neutral'>        }</span>
 772 |     | <span class='neutral'>    }</span>
 773 |     | <span class='neutral'></span>
 774 |     | <span class='neutral'>    function dealERC721(address token, address to, uint256 id) internal virtual {</span>
 775 |     | <span class='neutral'>        // check if token id is already minted and the actual owner.</span>
 776 |     | <span class='neutral'>        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));</span>
 777 |     | <span class='neutral'>        require(successMinted, &quot;StdCheats deal(address,address,uint,bool): id not minted.&quot;);</span>
 778 |     | <span class='neutral'></span>
 779 |     | <span class='neutral'>        // get owner current balance</span>
 780 |     | <span class='neutral'>        (, bytes memory fromBalData) =</span>
 781 |     | <span class='neutral'>            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));</span>
 782 |     | <span class='neutral'>        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));</span>
 783 |     | <span class='neutral'></span>
 784 |     | <span class='neutral'>        // get new user current balance</span>
 785 |     | <span class='neutral'>        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 786 |     | <span class='neutral'>        uint256 toPrevBal = abi.decode(toBalData, (uint256));</span>
 787 |     | <span class='neutral'></span>
 788 |     | <span class='neutral'>        // update balances</span>
 789 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);</span>
 790 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);</span>
 791 |     | <span class='neutral'></span>
 792 |     | <span class='neutral'>        // update owner</span>
 793 |     | <span class='neutral'>        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);</span>
 794 |     | <span class='neutral'>    }</span>
 795 |     | <span class='neutral'></span>
 796 |     | <span class='neutral'>    function deployCodeTo(string memory what, address where) internal virtual {</span>
 797 |     | <span class='neutral'>        deployCodeTo(what, &quot;&quot;, 0, where);</span>
 798 |     | <span class='neutral'>    }</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {</span>
 801 |     | <span class='neutral'>        deployCodeTo(what, args, 0, where);</span>
 802 |     | <span class='neutral'>    }</span>
 803 |     | <span class='neutral'></span>
 804 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {</span>
 805 |     | <span class='neutral'>        bytes memory creationCode = vm.getCode(what);</span>
 806 |     | <span class='neutral'>        vm.etch(where, abi.encodePacked(creationCode, args));</span>
 807 |     | <span class='neutral'>        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(&quot;&quot;);</span>
 808 |     | <span class='neutral'>        require(success, &quot;StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.&quot;);</span>
 809 |     | <span class='neutral'>        vm.etch(where, runtimeBytecode);</span>
 810 |     | <span class='neutral'>    }</span>
 811 |     | <span class='neutral'></span>
 812 |     | <span class='neutral'>    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.</span>
 813 |     | <span class='neutral'>    function console2_log_StdCheats(string memory p0) private view {</span>
 814 |     | <span class='neutral'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 815 |     | <span class='neutral'>        status;</span>
 816 |     | <span class='neutral'>    }</span>
 817 |     | <span class='neutral'>}</span>
 818 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>library stdError {</span>
  6 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdInvariant.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract StdInvariant {</span>
   7 |     | <span class='neutral'>    struct FuzzSelector {</span>
   8 |     | <span class='neutral'>        address addr;</span>
   9 |     | <span class='neutral'>        bytes4[] selectors;</span>
  10 |     | <span class='neutral'>    }</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct FuzzArtifactSelector {</span>
  13 |     | <span class='neutral'>        string artifact;</span>
  14 |     | <span class='neutral'>        bytes4[] selectors;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct FuzzInterface {</span>
  18 |     | <span class='neutral'>        address addr;</span>
  19 |     | <span class='neutral'>        string[] artifacts;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    address[] private _excludedContracts;</span>
  23 |     | <span class='neutral'>    address[] private _excludedSenders;</span>
  24 |     | <span class='neutral'>    address[] private _targetedContracts;</span>
  25 |     | <span class='neutral'>    address[] private _targetedSenders;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    string[] private _excludedArtifacts;</span>
  28 |     | <span class='neutral'>    string[] private _targetedArtifacts;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    FuzzArtifactSelector[] private _targetedArtifactSelectors;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    FuzzSelector[] private _excludedSelectors;</span>
  33 |     | <span class='neutral'>    FuzzSelector[] private _targetedSelectors;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    FuzzInterface[] private _targetedInterfaces;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // Functions for users:</span>
  38 |     | <span class='neutral'>    // These are intended to be called in tests.</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function excludeContract(address newExcludedContract_) internal {</span>
  41 |     | <span class='neutral'>        _excludedContracts.push(newExcludedContract_);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {</span>
  45 |     | <span class='neutral'>        _excludedSelectors.push(newExcludedSelector_);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function excludeSender(address newExcludedSender_) internal {</span>
  49 |     | <span class='neutral'>        _excludedSenders.push(newExcludedSender_);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function excludeArtifact(string memory newExcludedArtifact_) internal {</span>
  53 |     | <span class='neutral'>        _excludedArtifacts.push(newExcludedArtifact_);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function targetArtifact(string memory newTargetedArtifact_) internal {</span>
  57 |     | <span class='neutral'>        _targetedArtifacts.push(newTargetedArtifact_);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {</span>
  61 |     | <span class='neutral'>        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function targetContract(address newTargetedContract_) internal {</span>
  65 |     | <span class='neutral'>        _targetedContracts.push(newTargetedContract_);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {</span>
  69 |     | <span class='neutral'>        _targetedSelectors.push(newTargetedSelector_);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function targetSender(address newTargetedSender_) internal {</span>
  73 |     | <span class='neutral'>        _targetedSenders.push(newTargetedSender_);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {</span>
  77 |     | <span class='neutral'>        _targetedInterfaces.push(newTargetedInterface_);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // Functions for forge:</span>
  81 |     | <span class='neutral'>    // These are called by forge to run invariant tests and don&#39;t need to be called in tests.</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {</span>
  84 | *   | <span class='executed'>        excludedArtifacts_ = _excludedArtifacts;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>    function excludeContracts() public view returns (address[] memory excludedContracts_) {</span>
  88 | *   | <span class='executed'>        excludedContracts_ = _excludedContracts;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>    function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {</span>
  92 | *   | <span class='executed'>        excludedSelectors_ = _excludedSelectors;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function excludeSenders() public view returns (address[] memory excludedSenders_) {</span>
  96 | *   | <span class='executed'>        excludedSenders_ = _excludedSenders;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {</span>
 100 | *   | <span class='executed'>        targetedArtifacts_ = _targetedArtifacts;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {</span>
 104 | *   | <span class='executed'>        targetedArtifactSelectors_ = _targetedArtifactSelectors;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>    function targetContracts() public view returns (address[] memory targetedContracts_) {</span>
 108 | *   | <span class='executed'>        targetedContracts_ = _targetedContracts;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {</span>
 112 | *   | <span class='executed'>        targetedSelectors_ = _targetedSelectors;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>    function targetSenders() public view returns (address[] memory targetedSenders_) {</span>
 116 | *   | <span class='executed'>        targetedSenders_ = _targetedSenders;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {</span>
 120 | *   | <span class='executed'>        targetedInterfaces_ = _targetedInterfaces;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'>}</span>
 123 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// json.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdJson {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  29 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal pure returns (uint256) {</span>
  33 |     | <span class='neutral'>        return vm.parseJsonUint(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {</span>
  37 |     | <span class='neutral'>        return vm.parseJsonUintArray(json, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal pure returns (int256) {</span>
  41 |     | <span class='neutral'>        return vm.parseJsonInt(json, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {</span>
  45 |     | <span class='neutral'>        return vm.parseJsonIntArray(json, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {</span>
  49 |     | <span class='neutral'>        return vm.parseJsonBytes32(json, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {</span>
  53 |     | <span class='neutral'>        return vm.parseJsonBytes32Array(json, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal pure returns (string memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseJsonString(json, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseJsonStringArray(json, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal pure returns (address) {</span>
  65 |     | <span class='neutral'>        return vm.parseJsonAddress(json, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {</span>
  69 |     | <span class='neutral'>        return vm.parseJsonAddressArray(json, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal pure returns (bool) {</span>
  73 |     | <span class='neutral'>        return vm.parseJsonBool(json, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {</span>
  77 |     | <span class='neutral'>        return vm.parseJsonBoolArray(json, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseJsonBytes(json, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseJsonBytesArray(json, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
  89 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='neutral'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct FindData {</span>
   7 |     | <span class='neutral'>    uint256 slot;</span>
   8 |     | <span class='neutral'>    uint256 offsetLeft;</span>
   9 |     | <span class='neutral'>    uint256 offsetRight;</span>
  10 |     | <span class='neutral'>    bool found;</span>
  11 |     | <span class='neutral'>}</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>struct StdStorage {</span>
  14 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; FindData))) finds;</span>
  15 |     | <span class='neutral'>    bytes32[] _keys;</span>
  16 |     | <span class='neutral'>    bytes4 _sig;</span>
  17 |     | <span class='neutral'>    uint256 _depth;</span>
  18 |     | <span class='neutral'>    address _target;</span>
  19 |     | <span class='neutral'>    bytes32 _set;</span>
  20 |     | <span class='neutral'>    bool _enable_packed_slots;</span>
  21 |     | <span class='neutral'>    bytes _calldata;</span>
  22 |     | <span class='neutral'>}</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>library stdStorageSafe {</span>
  25 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  26 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  29 |     | <span class='neutral'>    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  32 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {</span>
  36 |     | <span class='neutral'>        if (self._calldata.length == 0) {</span>
  37 |     | <span class='neutral'>            return flatten(self._keys);</span>
  38 |     | <span class='neutral'>        } else {</span>
  39 |     | <span class='neutral'>            return self._calldata;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // Calls target contract with configured parameters</span>
  44 |     | <span class='neutral'>    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {</span>
  45 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));</span>
  46 |     | <span class='neutral'>        (bool success, bytes memory rdat) = self._target.staticcall(cald);</span>
  47 |     | <span class='neutral'>        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        return (success, result);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // Tries mutating slot value to determine if the targeted value is stored in it.</span>
  53 |     | <span class='neutral'>    // If current value is 0, then we are setting slot value to type(uint256).max</span>
  54 |     | <span class='neutral'>    // Otherwise, we set it to 0. That way, return value should always be affected.</span>
  55 |     | <span class='neutral'>    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {</span>
  56 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  57 |     | <span class='neutral'>        (bool success, bytes32 prevReturnValue) = callTarget(self);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);</span>
  60 |     | <span class='neutral'>        vm.store(self._target, slot, testVal);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        (, bytes32 newReturnValue) = callTarget(self);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        return (success &amp;&amp; (prevReturnValue != newReturnValue));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    // Tries setting one of the bits in slot to 1 until return value changes.</span>
  70 |     | <span class='neutral'>    // Index of resulted bit is an offset packed slot has from left/right side</span>
  71 |     | <span class='neutral'>    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {</span>
  72 |     | <span class='neutral'>        for (uint256 offset = 0; offset &lt; 256; offset++) {</span>
  73 |     | <span class='neutral'>            uint256 valueToPut = left ? (1 &lt;&lt; (255 - offset)) : (1 &lt;&lt; offset);</span>
  74 |     | <span class='neutral'>            vm.store(self._target, slot, bytes32(valueToPut));</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            (bool success, bytes32 data) = callTarget(self);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>            if (success &amp;&amp; (uint256(data) &gt; 0)) {</span>
  79 |     | <span class='neutral'>                return (true, offset);</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>        return (false, 0);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {</span>
  86 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);</span>
  89 |     | <span class='neutral'>        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // `findOffset` may mutate slot value, so we are setting it to initial value</span>
  92 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  93 |     | <span class='neutral'>        return (foundLeft &amp;&amp; foundRight, offsetLeft, offsetRight);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (FindData storage) {</span>
  97 |     | <span class='neutral'>        return find(self, true);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
 101 |     | <span class='neutral'>    // slot complexity:</span>
 102 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
 103 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
 104 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
 105 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
 106 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {</span>
 107 |     | <span class='neutral'>        address who = self._target;</span>
 108 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 109 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 110 |     | <span class='neutral'>        bytes memory params = getCallParams(self);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // calldata to test against</span>
 113 |     | <span class='neutral'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 114 |     | <span class='neutral'>            if (_clear) {</span>
 115 |     | <span class='neutral'>                clear(self);</span>
 116 |     | <span class='neutral'>            }</span>
 117 |     | <span class='neutral'>            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>        vm.record();</span>
 120 |     | <span class='neutral'>        (, bytes32 callResult) = callTarget(self);</span>
 121 |     | <span class='neutral'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        if (reads.length == 0) {</span>
 124 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
 125 |     | <span class='neutral'>        } else {</span>
 126 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; reads.length; i++) {</span>
 127 |     | <span class='neutral'>                bytes32 prev = vm.load(who, reads[i]);</span>
 128 |     | <span class='neutral'>                if (prev == bytes32(0)) {</span>
 129 |     | <span class='neutral'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
 130 |     | <span class='neutral'>                }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>                if (!checkSlotMutatesCall(self, reads[i])) {</span>
 133 |     | <span class='neutral'>                    continue;</span>
 134 |     | <span class='neutral'>                }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>                if (self._enable_packed_slots) {</span>
 139 |     | <span class='neutral'>                    bool found;</span>
 140 |     | <span class='neutral'>                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);</span>
 141 |     | <span class='neutral'>                    if (!found) {</span>
 142 |     | <span class='neutral'>                        continue;</span>
 143 |     | <span class='neutral'>                    }</span>
 144 |     | <span class='neutral'>                }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>                // Check that value between found offsets is equal to the current call result</span>
 147 |     | <span class='neutral'>                uint256 curVal = (uint256(prev) &amp; getMaskByOffsets(offsetLeft, offsetRight)) &gt;&gt; offsetRight;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>                if (uint256(callResult) != curVal) {</span>
 150 |     | <span class='neutral'>                    continue;</span>
 151 |     | <span class='neutral'>                }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));</span>
 154 |     | <span class='neutral'>                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =</span>
 155 |     | <span class='neutral'>                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);</span>
 156 |     | <span class='neutral'>                break;</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        require(</span>
 161 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,</span>
 162 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
 163 |     | <span class='neutral'>        );</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        if (_clear) {</span>
 166 |     | <span class='neutral'>            clear(self);</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 172 |     | <span class='neutral'>        self._target = _target;</span>
 173 |     | <span class='neutral'>        return self;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 177 |     | <span class='neutral'>        self._sig = _sig;</span>
 178 |     | <span class='neutral'>        return self;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 182 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 183 |     | <span class='neutral'>        return self;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 187 |     | <span class='neutral'>        self._calldata = _calldata;</span>
 188 |     | <span class='neutral'>        return self;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 192 |     | <span class='neutral'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 193 |     | <span class='neutral'>        return self;</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 197 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 198 |     | <span class='neutral'>        return self;</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 202 |     | <span class='neutral'>        self._keys.push(key);</span>
 203 |     | <span class='neutral'>        return self;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 207 |     | <span class='neutral'>        self._enable_packed_slots = true;</span>
 208 |     | <span class='neutral'>        return self;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 212 |     | <span class='neutral'>        self._depth = _depth;</span>
 213 |     | <span class='neutral'>        return self;</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 217 |     | <span class='neutral'>        FindData storage data = find(self, false);</span>
 218 |     | <span class='neutral'>        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);</span>
 219 |     | <span class='neutral'>        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) &amp; mask) &gt;&gt; data.offsetRight;</span>
 220 |     | <span class='neutral'>        clear(self);</span>
 221 |     | <span class='neutral'>        return abi.encode(value);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 225 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 229 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 230 |     | <span class='neutral'>        if (v == 0) return false;</span>
 231 |     | <span class='neutral'>        if (v == 1) return true;</span>
 232 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 236 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 240 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 244 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 248 |     | <span class='neutral'>        address who = self._target;</span>
 249 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 250 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 251 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 252 |     | <span class='neutral'>        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 253 |     | <span class='neutral'>        if (!found) {</span>
 254 |     | <span class='neutral'>            revert(</span>
 255 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 256 |     | <span class='neutral'>            );</span>
 257 |     | <span class='neutral'>        }</span>
 258 |     | <span class='neutral'>        return (uint256(parent_slot), key);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 262 |     | <span class='neutral'>        address who = self._target;</span>
 263 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 264 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 265 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 266 |     | <span class='neutral'>        bool found;</span>
 267 |     | <span class='neutral'>        bytes32 root_slot;</span>
 268 |     | <span class='neutral'>        bytes32 parent_slot;</span>
 269 |     | <span class='neutral'>        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 270 |     | <span class='neutral'>        if (!found) {</span>
 271 |     | <span class='neutral'>            revert(</span>
 272 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 273 |     | <span class='neutral'>            );</span>
 274 |     | <span class='neutral'>        }</span>
 275 |     | <span class='neutral'>        while (found) {</span>
 276 |     | <span class='neutral'>            root_slot = parent_slot;</span>
 277 |     | <span class='neutral'>            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>        return uint256(root_slot);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 283 |     | <span class='neutral'>        bytes32 out;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 286 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 287 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'>        return out;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 293 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 294 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 295 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 296 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>            assembly {</span>
 298 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 299 |     | <span class='neutral'>            }</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        return result;</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 306 |     | <span class='neutral'>        delete self._target;</span>
 307 |     | <span class='neutral'>        delete self._sig;</span>
 308 |     | <span class='neutral'>        delete self._keys;</span>
 309 |     | <span class='neutral'>        delete self._depth;</span>
 310 |     | <span class='neutral'>        delete self._enable_packed_slots;</span>
 311 |     | <span class='neutral'>        delete self._calldata;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`</span>
 315 |     | <span class='neutral'>    // (slotValue &amp; mask) &gt;&gt; offsetRight will be the value of the given packed variable</span>
 316 |     | <span class='neutral'>    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {</span>
 317 |     | <span class='neutral'>        // mask = ((1 &lt;&lt; (256 - (offsetRight + offsetLeft))) - 1) &lt;&lt; offsetRight;</span>
 318 |     | <span class='neutral'>        // using assembly because (1 &lt;&lt; 256) causes overflow</span>
 319 |     | <span class='neutral'>        assembly {</span>
 320 |     | <span class='neutral'>            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    // Returns slot value with updated packed variable.</span>
 325 |     | <span class='neutral'>    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)</span>
 326 |     | <span class='neutral'>        internal</span>
 327 |     | <span class='neutral'>        pure</span>
 328 |     | <span class='neutral'>        returns (bytes32 newValue)</span>
 329 |     | <span class='neutral'>    {</span>
 330 |     | <span class='neutral'>        return bytes32((uint256(curValue) &amp; ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue &lt;&lt; offsetRight));</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'>}</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>library stdStorage {</span>
 335 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 338 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 342 |     | <span class='neutral'>        return find(self, true);</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (uint256) {</span>
 346 |     | <span class='neutral'>        return stdStorageSafe.find(self, _clear).slot;</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 350 |     | <span class='neutral'>        return stdStorageSafe.target(self, _target);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 354 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 358 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 362 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, who);</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 366 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 370 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 374 |     | <span class='neutral'>        return stdStorageSafe.with_calldata(self, _calldata);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 378 |     | <span class='neutral'>        return stdStorageSafe.enable_packed_slots(self);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 382 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 386 |     | <span class='neutral'>        stdStorageSafe.clear(self);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 390 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 391 |     | <span class='neutral'>    }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 394 |     | <span class='neutral'>        checked_write(self, bytes32(amt));</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    function checked_write_int(StdStorage storage self, int256 val) internal {</span>
 398 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(val)));</span>
 399 |     | <span class='neutral'>    }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 402 |     | <span class='neutral'>        bytes32 t;</span>
 403 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 404 |     | <span class='neutral'>        assembly {</span>
 405 |     | <span class='neutral'>            t := write</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='neutral'>        checked_write(self, t);</span>
 408 |     | <span class='neutral'>    }</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 411 |     | <span class='neutral'>        address who = self._target;</span>
 412 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 413 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 414 |     | <span class='neutral'>        bytes memory params = stdStorageSafe.getCallParams(self);</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 417 |     | <span class='neutral'>            find(self, false);</span>
 418 |     | <span class='neutral'>        }</span>
 419 |     | <span class='neutral'>        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 420 |     | <span class='neutral'>        if ((data.offsetLeft + data.offsetRight) &gt; 0) {</span>
 421 |     | <span class='neutral'>            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));</span>
 422 |     | <span class='neutral'>            require(</span>
 423 |     | <span class='neutral'>                uint256(set) &lt; maxVal,</span>
 424 |     | <span class='neutral'>                string(</span>
 425 |     | <span class='neutral'>                    abi.encodePacked(</span>
 426 |     | <span class='neutral'>                        &quot;stdStorage find(StdStorage): Packed slot. We can&#39;t fit value greater than &quot;,</span>
 427 |     | <span class='neutral'>                        vm.toString(maxVal)</span>
 428 |     | <span class='neutral'>                    )</span>
 429 |     | <span class='neutral'>                )</span>
 430 |     | <span class='neutral'>            );</span>
 431 |     | <span class='neutral'>        }</span>
 432 |     | <span class='neutral'>        bytes32 curVal = vm.load(who, bytes32(data.slot));</span>
 433 |     | <span class='neutral'>        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>        vm.store(who, bytes32(data.slot), valToSet);</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>        if (!success || callResult != set) {</span>
 440 |     | <span class='neutral'>            vm.store(who, bytes32(data.slot), curVal);</span>
 441 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): Failed to write value.&quot;);</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='neutral'>        clear(self);</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 447 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 448 |     | <span class='neutral'>    }</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 451 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 455 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 459 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 460 |     | <span class='neutral'>    }</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 463 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 467 |     | <span class='neutral'>        return stdStorageSafe.parent(self);</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 471 |     | <span class='neutral'>        return stdStorageSafe.root(self);</span>
 472 |     | <span class='neutral'>    }</span>
 473 |     | <span class='neutral'>}</span>
 474 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdStyle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library StdStyle {</span>
   7 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    string constant RED = &quot;\u001b[91m&quot;;</span>
  10 |     | <span class='neutral'>    string constant GREEN = &quot;\u001b[92m&quot;;</span>
  11 |     | <span class='neutral'>    string constant YELLOW = &quot;\u001b[93m&quot;;</span>
  12 |     | <span class='neutral'>    string constant BLUE = &quot;\u001b[94m&quot;;</span>
  13 |     | <span class='neutral'>    string constant MAGENTA = &quot;\u001b[95m&quot;;</span>
  14 |     | <span class='neutral'>    string constant CYAN = &quot;\u001b[96m&quot;;</span>
  15 |     | <span class='neutral'>    string constant BOLD = &quot;\u001b[1m&quot;;</span>
  16 |     | <span class='neutral'>    string constant DIM = &quot;\u001b[2m&quot;;</span>
  17 |     | <span class='neutral'>    string constant ITALIC = &quot;\u001b[3m&quot;;</span>
  18 |     | <span class='neutral'>    string constant UNDERLINE = &quot;\u001b[4m&quot;;</span>
  19 |     | <span class='neutral'>    string constant INVERSE = &quot;\u001b[7m&quot;;</span>
  20 |     | <span class='neutral'>    string constant RESET = &quot;\u001b[0m&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function styleConcat(string memory style, string memory self) private pure returns (string memory) {</span>
  23 |     | <span class='neutral'>        return string(abi.encodePacked(style, self, RESET));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function red(string memory self) internal pure returns (string memory) {</span>
  27 |     | <span class='neutral'>        return styleConcat(RED, self);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function red(uint256 self) internal pure returns (string memory) {</span>
  31 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function red(int256 self) internal pure returns (string memory) {</span>
  35 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function red(address self) internal pure returns (string memory) {</span>
  39 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function red(bool self) internal pure returns (string memory) {</span>
  43 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function redBytes(bytes memory self) internal pure returns (string memory) {</span>
  47 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function redBytes32(bytes32 self) internal pure returns (string memory) {</span>
  51 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function green(string memory self) internal pure returns (string memory) {</span>
  55 |     | <span class='neutral'>        return styleConcat(GREEN, self);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function green(uint256 self) internal pure returns (string memory) {</span>
  59 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function green(int256 self) internal pure returns (string memory) {</span>
  63 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function green(address self) internal pure returns (string memory) {</span>
  67 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function green(bool self) internal pure returns (string memory) {</span>
  71 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function greenBytes(bytes memory self) internal pure returns (string memory) {</span>
  75 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function greenBytes32(bytes32 self) internal pure returns (string memory) {</span>
  79 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function yellow(string memory self) internal pure returns (string memory) {</span>
  83 |     | <span class='neutral'>        return styleConcat(YELLOW, self);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function yellow(uint256 self) internal pure returns (string memory) {</span>
  87 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function yellow(int256 self) internal pure returns (string memory) {</span>
  91 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function yellow(address self) internal pure returns (string memory) {</span>
  95 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function yellow(bool self) internal pure returns (string memory) {</span>
  99 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function yellowBytes(bytes memory self) internal pure returns (string memory) {</span>
 103 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function yellowBytes32(bytes32 self) internal pure returns (string memory) {</span>
 107 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function blue(string memory self) internal pure returns (string memory) {</span>
 111 |     | <span class='neutral'>        return styleConcat(BLUE, self);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function blue(uint256 self) internal pure returns (string memory) {</span>
 115 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function blue(int256 self) internal pure returns (string memory) {</span>
 119 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function blue(address self) internal pure returns (string memory) {</span>
 123 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function blue(bool self) internal pure returns (string memory) {</span>
 127 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function blueBytes(bytes memory self) internal pure returns (string memory) {</span>
 131 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function blueBytes32(bytes32 self) internal pure returns (string memory) {</span>
 135 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function magenta(string memory self) internal pure returns (string memory) {</span>
 139 |     | <span class='neutral'>        return styleConcat(MAGENTA, self);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function magenta(uint256 self) internal pure returns (string memory) {</span>
 143 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function magenta(int256 self) internal pure returns (string memory) {</span>
 147 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function magenta(address self) internal pure returns (string memory) {</span>
 151 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function magenta(bool self) internal pure returns (string memory) {</span>
 155 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function magentaBytes(bytes memory self) internal pure returns (string memory) {</span>
 159 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function magentaBytes32(bytes32 self) internal pure returns (string memory) {</span>
 163 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function cyan(string memory self) internal pure returns (string memory) {</span>
 167 |     | <span class='neutral'>        return styleConcat(CYAN, self);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function cyan(uint256 self) internal pure returns (string memory) {</span>
 171 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function cyan(int256 self) internal pure returns (string memory) {</span>
 175 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function cyan(address self) internal pure returns (string memory) {</span>
 179 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    function cyan(bool self) internal pure returns (string memory) {</span>
 183 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function cyanBytes(bytes memory self) internal pure returns (string memory) {</span>
 187 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    function cyanBytes32(bytes32 self) internal pure returns (string memory) {</span>
 191 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    function bold(string memory self) internal pure returns (string memory) {</span>
 195 |     | <span class='neutral'>        return styleConcat(BOLD, self);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function bold(uint256 self) internal pure returns (string memory) {</span>
 199 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function bold(int256 self) internal pure returns (string memory) {</span>
 203 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function bold(address self) internal pure returns (string memory) {</span>
 207 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function bold(bool self) internal pure returns (string memory) {</span>
 211 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function boldBytes(bytes memory self) internal pure returns (string memory) {</span>
 215 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function boldBytes32(bytes32 self) internal pure returns (string memory) {</span>
 219 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function dim(string memory self) internal pure returns (string memory) {</span>
 223 |     | <span class='neutral'>        return styleConcat(DIM, self);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function dim(uint256 self) internal pure returns (string memory) {</span>
 227 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function dim(int256 self) internal pure returns (string memory) {</span>
 231 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function dim(address self) internal pure returns (string memory) {</span>
 235 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function dim(bool self) internal pure returns (string memory) {</span>
 239 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function dimBytes(bytes memory self) internal pure returns (string memory) {</span>
 243 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function dimBytes32(bytes32 self) internal pure returns (string memory) {</span>
 247 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    function italic(string memory self) internal pure returns (string memory) {</span>
 251 |     | <span class='neutral'>        return styleConcat(ITALIC, self);</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function italic(uint256 self) internal pure returns (string memory) {</span>
 255 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    function italic(int256 self) internal pure returns (string memory) {</span>
 259 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function italic(address self) internal pure returns (string memory) {</span>
 263 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    function italic(bool self) internal pure returns (string memory) {</span>
 267 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function italicBytes(bytes memory self) internal pure returns (string memory) {</span>
 271 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    function italicBytes32(bytes32 self) internal pure returns (string memory) {</span>
 275 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    function underline(string memory self) internal pure returns (string memory) {</span>
 279 |     | <span class='neutral'>        return styleConcat(UNDERLINE, self);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function underline(uint256 self) internal pure returns (string memory) {</span>
 283 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    function underline(int256 self) internal pure returns (string memory) {</span>
 287 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function underline(address self) internal pure returns (string memory) {</span>
 291 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    function underline(bool self) internal pure returns (string memory) {</span>
 295 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    function underlineBytes(bytes memory self) internal pure returns (string memory) {</span>
 299 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    function underlineBytes32(bytes32 self) internal pure returns (string memory) {</span>
 303 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    function inverse(string memory self) internal pure returns (string memory) {</span>
 307 |     | <span class='neutral'>        return styleConcat(INVERSE, self);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    function inverse(uint256 self) internal pure returns (string memory) {</span>
 311 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function inverse(int256 self) internal pure returns (string memory) {</span>
 315 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>    function inverse(address self) internal pure returns (string memory) {</span>
 319 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    function inverse(bool self) internal pure returns (string memory) {</span>
 323 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    function inverseBytes(bytes memory self) internal pure returns (string memory) {</span>
 327 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function inverseBytes32(bytes32 self) internal pure returns (string memory) {</span>
 331 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'>}</span>
 334 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdToml.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing TOML files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdToml for string;</span>
  12 |     | <span class='neutral'>// string memory toml = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// toml.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdToml for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdToml {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  29 |     | <span class='neutral'>        return vm.parseToml(toml, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function readUint(string memory toml, string memory key) internal pure returns (uint256) {</span>
  33 |     | <span class='neutral'>        return vm.parseTomlUint(toml, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {</span>
  37 |     | <span class='neutral'>        return vm.parseTomlUintArray(toml, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readInt(string memory toml, string memory key) internal pure returns (int256) {</span>
  41 |     | <span class='neutral'>        return vm.parseTomlInt(toml, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {</span>
  45 |     | <span class='neutral'>        return vm.parseTomlIntArray(toml, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {</span>
  49 |     | <span class='neutral'>        return vm.parseTomlBytes32(toml, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {</span>
  53 |     | <span class='neutral'>        return vm.parseTomlBytes32Array(toml, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readString(string memory toml, string memory key) internal pure returns (string memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseTomlString(toml, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseTomlStringArray(toml, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readAddress(string memory toml, string memory key) internal pure returns (address) {</span>
  65 |     | <span class='neutral'>        return vm.parseTomlAddress(toml, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {</span>
  69 |     | <span class='neutral'>        return vm.parseTomlAddressArray(toml, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readBool(string memory toml, string memory key) internal pure returns (bool) {</span>
  73 |     | <span class='neutral'>        return vm.parseTomlBool(toml, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {</span>
  77 |     | <span class='neutral'>        return vm.parseTomlBoolArray(toml, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseTomlBytes(toml, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseTomlBytesArray(toml, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
  89 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeToml(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeToml(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IMulticall3} from &quot;./interfaces/IMulticall3.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MockERC20} from &quot;./mocks/MockERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MockERC721} from &quot;./mocks/MockERC721.sol&quot;;</span>
   9 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>abstract contract StdUtils {</span>
  12 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  13 |     | <span class='neutral'>                                     CONSTANTS</span>
  14 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);</span>
  17 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  18 |     | <span class='neutral'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
  19 |     | <span class='neutral'>    uint256 private constant INT256_MIN_ABS =</span>
  20 |     | <span class='neutral'>        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  21 |     | <span class='neutral'>    uint256 private constant SECP256K1_ORDER =</span>
  22 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
  23 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  24 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
  27 |     | <span class='neutral'>    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  30 |     | <span class='neutral'>                                 INTERNAL FUNCTIONS</span>
  31 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  34 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
  35 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
  36 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
  37 |     | <span class='neutral'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        uint256 size = max - min + 1;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
  42 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
  43 |     | <span class='neutral'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
  44 |     | <span class='neutral'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
  47 |     | <span class='neutral'>        if (x &gt; max) {</span>
  48 |     | <span class='neutral'>            uint256 diff = x - max;</span>
  49 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
  50 |     | <span class='neutral'>            if (rem == 0) return max;</span>
  51 |     | <span class='neutral'>            result = min + rem - 1;</span>
  52 |     | <span class='neutral'>        } else if (x &lt; min) {</span>
  53 |     | <span class='neutral'>            uint256 diff = min - x;</span>
  54 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
  55 |     | <span class='neutral'>            if (rem == 0) return min;</span>
  56 |     | <span class='neutral'>            result = max - rem + 1;</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  61 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
  62 |     | <span class='neutral'>        console2_log_StdUtils(&quot;Bound result&quot;, result);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  66 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(int256,int256,int256): Max is less than min.&quot;);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:</span>
  69 |     | <span class='neutral'>        // int256 : -(2**255) ~ (2**255 - 1)</span>
  70 |     | <span class='neutral'>        // uint256:     0     ~ (2**256 - 1)</span>
  71 |     | <span class='neutral'>        // So, add 2**255, INT256_MIN_ABS to the integer values.</span>
  72 |     | <span class='neutral'>        //</span>
  73 |     | <span class='neutral'>        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.</span>
  74 |     | <span class='neutral'>        // So, use `~uint256(x) + 1` instead.</span>
  75 |     | <span class='neutral'>        uint256 _x = x &lt; 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);</span>
  76 |     | <span class='neutral'>        uint256 _min = min &lt; 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);</span>
  77 |     | <span class='neutral'>        uint256 _max = max &lt; 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        uint256 y = _bound(_x, _min, _max);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // To move it back to int256 value, subtract INT256_MIN_ABS at here.</span>
  82 |     | <span class='neutral'>        result = y &lt; INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  86 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
  87 |     | <span class='neutral'>        console2_log_StdUtils(&quot;Bound result&quot;, vm.toString(result));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {</span>
  91 |     | <span class='neutral'>        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
  95 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
  96 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
 100 |     | <span class='neutral'>    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
 101 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
 102 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.&quot;);</span>
 103 |     | <span class='neutral'>        return vm.computeCreateAddress(deployer, nonce);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
 107 |     | <span class='neutral'>        internal</span>
 108 |     | <span class='neutral'>        pure</span>
 109 |     | <span class='neutral'>        virtual</span>
 110 |     | <span class='neutral'>        returns (address)</span>
 111 |     | <span class='neutral'>    {</span>
 112 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 113 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initcodeHash, deployer);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer</span>
 117 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {</span>
 118 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 119 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initCodeHash);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev returns an initialized mock ERC20 contract</span>
 123 |     | <span class='neutral'>    function deployMockERC20(string memory name, string memory symbol, uint8 decimals)</span>
 124 |     | <span class='neutral'>        internal</span>
 125 |     | <span class='neutral'>        returns (MockERC20 mock)</span>
 126 |     | <span class='neutral'>    {</span>
 127 |     | <span class='neutral'>        mock = new MockERC20();</span>
 128 |     | <span class='neutral'>        mock.initialize(name, symbol, decimals);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev returns an initialized mock ERC721 contract</span>
 132 |     | <span class='neutral'>    function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {</span>
 133 |     | <span class='neutral'>        mock = new MockERC721();</span>
 134 |     | <span class='neutral'>        mock.initialize(name, symbol);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments</span>
 138 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 139 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {</span>
 140 |     | <span class='neutral'>        return hashInitCode(creationCode, &quot;&quot;);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2</span>
 144 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 145 |     | <span class='neutral'>    /// @param args the ABI-encoded arguments to the constructor of C</span>
 146 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {</span>
 147 |     | <span class='neutral'>        return keccak256(abi.encodePacked(creationCode, args));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.</span>
 151 |     | <span class='neutral'>    function getTokenBalances(address token, address[] memory addresses)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        virtual</span>
 154 |     | <span class='neutral'>        returns (uint256[] memory balances)</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 157 |     | <span class='neutral'>        assembly {</span>
 158 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdUtils getTokenBalances(address,address[]): Token address is not a contract.&quot;);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        // ABI encode the aggregate call to Multicall3.</span>
 163 |     | <span class='neutral'>        uint256 length = addresses.length;</span>
 164 |     | <span class='neutral'>        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);</span>
 165 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 166 |     | <span class='neutral'>            // 0x70a08231 = bytes4(&quot;balanceOf(address)&quot;))</span>
 167 |     | <span class='neutral'>            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});</span>
 168 |     | <span class='neutral'>        }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // Make the aggregate call.</span>
 171 |     | <span class='neutral'>        (, bytes[] memory returnData) = multicall.aggregate(calls);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        // ABI decode the return data and return the balances.</span>
 174 |     | <span class='neutral'>        balances = new uint256[](length);</span>
 175 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 176 |     | <span class='neutral'>            balances[i] = abi.decode(returnData[i], (uint256));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
 181 |     | <span class='neutral'>                                 PRIVATE FUNCTIONS</span>
 182 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 185 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // This section is used to prevent the compilation of console, which shortens the compilation time when console is</span>
 189 |     | <span class='neutral'>    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid</span>
 190 |     | <span class='neutral'>    // any breaking changes to function signatures.</span>
 191 |     | <span class='neutral'>    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)</span>
 192 |     | <span class='neutral'>        internal</span>
 193 |     | <span class='neutral'>        pure</span>
 194 |     | <span class='neutral'>        returns (function(bytes memory) internal pure fnOut)</span>
 195 |     | <span class='neutral'>    {</span>
 196 |     | <span class='neutral'>        assembly {</span>
 197 |     | <span class='neutral'>            fnOut := fnIn</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
 202 |     | <span class='neutral'>        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    function _sendLogPayloadView(bytes memory payload) private view {</span>
 206 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
 207 |     | <span class='neutral'>        address consoleAddress = CONSOLE2_ADDRESS;</span>
 208 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 209 |     | <span class='neutral'>        assembly {</span>
 210 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
 211 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0) private pure {</span>
 216 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {</span>
 220 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0, string memory p1) private pure {</span>
 224 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'>}</span>
 227 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// 💬 ABOUT</span>
  7 |     | <span class='neutral'>// Forge Std&#39;s default Test.</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>// 🧩 MODULES</span>
 10 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
 11 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 12 |     | <span class='neutral'>import {safeconsole} from &quot;./safeconsole.sol&quot;;</span>
 13 |     | <span class='neutral'>import {StdAssertions} from &quot;./StdAssertions.sol&quot;;</span>
 14 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 15 |     | <span class='neutral'>import {StdCheats} from &quot;./StdCheats.sol&quot;;</span>
 16 |     | <span class='neutral'>import {stdError} from &quot;./StdError.sol&quot;;</span>
 17 |     | <span class='neutral'>import {StdInvariant} from &quot;./StdInvariant.sol&quot;;</span>
 18 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 19 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 20 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
 21 |     | <span class='neutral'>import {StdStyle} from &quot;./StdStyle.sol&quot;;</span>
 22 |     | <span class='neutral'>import {stdToml} from &quot;./StdToml.sol&quot;;</span>
 23 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 24 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>// 📦 BOILERPLATE</span>
 27 |     | <span class='neutral'>import {TestBase} from &quot;./Base.sol&quot;;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>// ⭐️ TEST</span>
 30 |     | <span class='neutral'>abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {</span>
 31 |     | <span class='neutral'>    // Note: IS_TEST() must return true.</span>
 32 | *   | <span class='executed'>    bool public IS_TEST = true;</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/Vm.sol</b>
<code>
    1 |     | <span class='neutral'>// Automatically @generated by scripts/vm.py. Do not modify manually.</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>// SPDX-License-Identifier: MIT OR Apache-2.0</span>
    4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
    5 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may</span>
    8 |     | <span class='neutral'>/// result in Script simulations differing from on-chain execution. It is recommended to only use</span>
    9 |     | <span class='neutral'>/// these cheats in scripts.</span>
   10 |     | <span class='neutral'>interface VmSafe {</span>
   11 |     | <span class='neutral'>    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.</span>
   12 |     | <span class='neutral'>    enum CallerMode {</span>
   13 |     | <span class='neutral'>        // No caller modification is currently active.</span>
   14 |     | <span class='neutral'>        None,</span>
   15 |     | <span class='neutral'>        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.</span>
   16 |     | <span class='neutral'>        Broadcast,</span>
   17 |     | <span class='neutral'>        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.</span>
   18 |     | <span class='neutral'>        RecurrentBroadcast,</span>
   19 |     | <span class='neutral'>        // A one time prank triggered by a `vm.prank()` call is currently active.</span>
   20 |     | <span class='neutral'>        Prank,</span>
   21 |     | <span class='neutral'>        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.</span>
   22 |     | <span class='neutral'>        RecurrentPrank</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    /// The kind of account access that occurred.</span>
   26 |     | <span class='neutral'>    enum AccountAccessKind {</span>
   27 |     | <span class='neutral'>        // The account was called.</span>
   28 |     | <span class='neutral'>        Call,</span>
   29 |     | <span class='neutral'>        // The account was called via delegatecall.</span>
   30 |     | <span class='neutral'>        DelegateCall,</span>
   31 |     | <span class='neutral'>        // The account was called via callcode.</span>
   32 |     | <span class='neutral'>        CallCode,</span>
   33 |     | <span class='neutral'>        // The account was called via staticcall.</span>
   34 |     | <span class='neutral'>        StaticCall,</span>
   35 |     | <span class='neutral'>        // The account was created.</span>
   36 |     | <span class='neutral'>        Create,</span>
   37 |     | <span class='neutral'>        // The account was selfdestructed.</span>
   38 |     | <span class='neutral'>        SelfDestruct,</span>
   39 |     | <span class='neutral'>        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).</span>
   40 |     | <span class='neutral'>        Resume,</span>
   41 |     | <span class='neutral'>        // The account&#39;s balance was read.</span>
   42 |     | <span class='neutral'>        Balance,</span>
   43 |     | <span class='neutral'>        // The account&#39;s codesize was read.</span>
   44 |     | <span class='neutral'>        Extcodesize,</span>
   45 |     | <span class='neutral'>        // The account&#39;s codehash was read.</span>
   46 |     | <span class='neutral'>        Extcodehash,</span>
   47 |     | <span class='neutral'>        // The account&#39;s code was copied.</span>
   48 |     | <span class='neutral'>        Extcodecopy</span>
   49 |     | <span class='neutral'>    }</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='neutral'>    /// Forge execution contexts.</span>
   52 |     | <span class='neutral'>    enum ForgeContext {</span>
   53 |     | <span class='neutral'>        // Test group execution context (test, coverage or snapshot).</span>
   54 |     | <span class='neutral'>        TestGroup,</span>
   55 |     | <span class='neutral'>        // `forge test` execution context.</span>
   56 |     | <span class='neutral'>        Test,</span>
   57 |     | <span class='neutral'>        // `forge coverage` execution context.</span>
   58 |     | <span class='neutral'>        Coverage,</span>
   59 |     | <span class='neutral'>        // `forge snapshot` execution context.</span>
   60 |     | <span class='neutral'>        Snapshot,</span>
   61 |     | <span class='neutral'>        // Script group execution context (dry run, broadcast or resume).</span>
   62 |     | <span class='neutral'>        ScriptGroup,</span>
   63 |     | <span class='neutral'>        // `forge script` execution context.</span>
   64 |     | <span class='neutral'>        ScriptDryRun,</span>
   65 |     | <span class='neutral'>        // `forge script --broadcast` execution context.</span>
   66 |     | <span class='neutral'>        ScriptBroadcast,</span>
   67 |     | <span class='neutral'>        // `forge script --resume` execution context.</span>
   68 |     | <span class='neutral'>        ScriptResume,</span>
   69 |     | <span class='neutral'>        // Unknown `forge` execution context.</span>
   70 |     | <span class='neutral'>        Unknown</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    /// An Ethereum log. Returned by `getRecordedLogs`.</span>
   74 |     | <span class='neutral'>    struct Log {</span>
   75 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
   76 |     | <span class='neutral'>        bytes32[] topics;</span>
   77 |     | <span class='neutral'>        // The raw data of the log.</span>
   78 |     | <span class='neutral'>        bytes data;</span>
   79 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
   80 |     | <span class='neutral'>        address emitter;</span>
   81 |     | <span class='neutral'>    }</span>
   82 |     | <span class='neutral'></span>
   83 |     | <span class='neutral'>    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.</span>
   84 |     | <span class='neutral'>    struct Rpc {</span>
   85 |     | <span class='neutral'>        // The alias of the RPC URL.</span>
   86 |     | <span class='neutral'>        string key;</span>
   87 |     | <span class='neutral'>        // The RPC URL.</span>
   88 |     | <span class='neutral'>        string url;</span>
   89 |     | <span class='neutral'>    }</span>
   90 |     | <span class='neutral'></span>
   91 |     | <span class='neutral'>    /// An RPC log object. Returned by `eth_getLogs`.</span>
   92 |     | <span class='neutral'>    struct EthGetLogs {</span>
   93 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
   94 |     | <span class='neutral'>        address emitter;</span>
   95 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
   96 |     | <span class='neutral'>        bytes32[] topics;</span>
   97 |     | <span class='neutral'>        // The raw data of the log.</span>
   98 |     | <span class='neutral'>        bytes data;</span>
   99 |     | <span class='neutral'>        // The block hash.</span>
  100 |     | <span class='neutral'>        bytes32 blockHash;</span>
  101 |     | <span class='neutral'>        // The block number.</span>
  102 |     | <span class='neutral'>        uint64 blockNumber;</span>
  103 |     | <span class='neutral'>        // The transaction hash.</span>
  104 |     | <span class='neutral'>        bytes32 transactionHash;</span>
  105 |     | <span class='neutral'>        // The transaction index in the block.</span>
  106 |     | <span class='neutral'>        uint64 transactionIndex;</span>
  107 |     | <span class='neutral'>        // The log index.</span>
  108 |     | <span class='neutral'>        uint256 logIndex;</span>
  109 |     | <span class='neutral'>        // Whether the log was removed.</span>
  110 |     | <span class='neutral'>        bool removed;</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    /// A single entry in a directory listing. Returned by `readDir`.</span>
  114 |     | <span class='neutral'>    struct DirEntry {</span>
  115 |     | <span class='neutral'>        // The error message, if any.</span>
  116 |     | <span class='neutral'>        string errorMessage;</span>
  117 |     | <span class='neutral'>        // The path of the entry.</span>
  118 |     | <span class='neutral'>        string path;</span>
  119 |     | <span class='neutral'>        // The depth of the entry.</span>
  120 |     | <span class='neutral'>        uint64 depth;</span>
  121 |     | <span class='neutral'>        // Whether the entry is a directory.</span>
  122 |     | <span class='neutral'>        bool isDir;</span>
  123 |     | <span class='neutral'>        // Whether the entry is a symlink.</span>
  124 |     | <span class='neutral'>        bool isSymlink;</span>
  125 |     | <span class='neutral'>    }</span>
  126 |     | <span class='neutral'></span>
  127 |     | <span class='neutral'>    /// Metadata information about a file.</span>
  128 |     | <span class='neutral'>    /// This structure is returned from the `fsMetadata` function and represents known</span>
  129 |     | <span class='neutral'>    /// metadata about a file such as its permissions, size, modification</span>
  130 |     | <span class='neutral'>    /// times, etc.</span>
  131 |     | <span class='neutral'>    struct FsMetadata {</span>
  132 |     | <span class='neutral'>        // True if this metadata is for a directory.</span>
  133 |     | <span class='neutral'>        bool isDir;</span>
  134 |     | <span class='neutral'>        // True if this metadata is for a symlink.</span>
  135 |     | <span class='neutral'>        bool isSymlink;</span>
  136 |     | <span class='neutral'>        // The size of the file, in bytes, this metadata is for.</span>
  137 |     | <span class='neutral'>        uint256 length;</span>
  138 |     | <span class='neutral'>        // True if this metadata is for a readonly (unwritable) file.</span>
  139 |     | <span class='neutral'>        bool readOnly;</span>
  140 |     | <span class='neutral'>        // The last modification time listed in this metadata.</span>
  141 |     | <span class='neutral'>        uint256 modified;</span>
  142 |     | <span class='neutral'>        // The last access time of this metadata.</span>
  143 |     | <span class='neutral'>        uint256 accessed;</span>
  144 |     | <span class='neutral'>        // The creation time listed in this metadata.</span>
  145 |     | <span class='neutral'>        uint256 created;</span>
  146 |     | <span class='neutral'>    }</span>
  147 |     | <span class='neutral'></span>
  148 |     | <span class='neutral'>    /// A wallet with a public and private key.</span>
  149 |     | <span class='neutral'>    struct Wallet {</span>
  150 |     | <span class='neutral'>        // The wallet&#39;s address.</span>
  151 |     | <span class='neutral'>        address addr;</span>
  152 |     | <span class='neutral'>        // The wallet&#39;s public key `X`.</span>
  153 |     | <span class='neutral'>        uint256 publicKeyX;</span>
  154 |     | <span class='neutral'>        // The wallet&#39;s public key `Y`.</span>
  155 |     | <span class='neutral'>        uint256 publicKeyY;</span>
  156 |     | <span class='neutral'>        // The wallet&#39;s private key.</span>
  157 |     | <span class='neutral'>        uint256 privateKey;</span>
  158 |     | <span class='neutral'>    }</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='neutral'>    /// The result of a `tryFfi` call.</span>
  161 |     | <span class='neutral'>    struct FfiResult {</span>
  162 |     | <span class='neutral'>        // The exit code of the call.</span>
  163 |     | <span class='neutral'>        int32 exitCode;</span>
  164 |     | <span class='neutral'>        // The optionally hex-decoded `stdout` data.</span>
  165 |     | <span class='neutral'>        bytes stdout;</span>
  166 |     | <span class='neutral'>        // The `stderr` data.</span>
  167 |     | <span class='neutral'>        bytes stderr;</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    /// Information on the chain and fork.</span>
  171 |     | <span class='neutral'>    struct ChainInfo {</span>
  172 |     | <span class='neutral'>        // The fork identifier. Set to zero if no fork is active.</span>
  173 |     | <span class='neutral'>        uint256 forkId;</span>
  174 |     | <span class='neutral'>        // The chain ID of the current fork.</span>
  175 |     | <span class='neutral'>        uint256 chainId;</span>
  176 |     | <span class='neutral'>    }</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>    /// The result of a `stopAndReturnStateDiff` call.</span>
  179 |     | <span class='neutral'>    struct AccountAccess {</span>
  180 |     | <span class='neutral'>        // The chain and fork the access occurred.</span>
  181 |     | <span class='neutral'>        ChainInfo chainInfo;</span>
  182 |     | <span class='neutral'>        // The kind of account access that determines what the account is.</span>
  183 |     | <span class='neutral'>        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.</span>
  184 |     | <span class='neutral'>        // If kind is Create, then the account is the newly created account.</span>
  185 |     | <span class='neutral'>        // If kind is SelfDestruct, then the account is the selfdestruct recipient.</span>
  186 |     | <span class='neutral'>        // If kind is a Resume, then account represents a account context that has resumed.</span>
  187 |     | <span class='neutral'>        AccountAccessKind kind;</span>
  188 |     | <span class='neutral'>        // The account that was accessed.</span>
  189 |     | <span class='neutral'>        // It&#39;s either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.</span>
  190 |     | <span class='neutral'>        address account;</span>
  191 |     | <span class='neutral'>        // What accessed the account.</span>
  192 |     | <span class='neutral'>        address accessor;</span>
  193 |     | <span class='neutral'>        // If the account was initialized or empty prior to the access.</span>
  194 |     | <span class='neutral'>        // An account is considered initialized if it has code, a</span>
  195 |     | <span class='neutral'>        // non-zero nonce, or a non-zero balance.</span>
  196 |     | <span class='neutral'>        bool initialized;</span>
  197 |     | <span class='neutral'>        // The previous balance of the accessed account.</span>
  198 |     | <span class='neutral'>        uint256 oldBalance;</span>
  199 |     | <span class='neutral'>        // The potential new balance of the accessed account.</span>
  200 |     | <span class='neutral'>        // That is, all balance changes are recorded here, even if reverts occurred.</span>
  201 |     | <span class='neutral'>        uint256 newBalance;</span>
  202 |     | <span class='neutral'>        // Code of the account deployed by CREATE.</span>
  203 |     | <span class='neutral'>        bytes deployedCode;</span>
  204 |     | <span class='neutral'>        // Value passed along with the account access</span>
  205 |     | <span class='neutral'>        uint256 value;</span>
  206 |     | <span class='neutral'>        // Input data provided to the CREATE or CALL</span>
  207 |     | <span class='neutral'>        bytes data;</span>
  208 |     | <span class='neutral'>        // If this access reverted in either the current or parent context.</span>
  209 |     | <span class='neutral'>        bool reverted;</span>
  210 |     | <span class='neutral'>        // An ordered list of storage accesses made during an account access operation.</span>
  211 |     | <span class='neutral'>        StorageAccess[] storageAccesses;</span>
  212 |     | <span class='neutral'>        // Call depth traversed during the recording of state differences</span>
  213 |     | <span class='neutral'>        uint64 depth;</span>
  214 |     | <span class='neutral'>    }</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>    /// The storage accessed during an `AccountAccess`.</span>
  217 |     | <span class='neutral'>    struct StorageAccess {</span>
  218 |     | <span class='neutral'>        // The account whose storage was accessed.</span>
  219 |     | <span class='neutral'>        address account;</span>
  220 |     | <span class='neutral'>        // The slot that was accessed.</span>
  221 |     | <span class='neutral'>        bytes32 slot;</span>
  222 |     | <span class='neutral'>        // If the access was a write.</span>
  223 |     | <span class='neutral'>        bool isWrite;</span>
  224 |     | <span class='neutral'>        // The previous value of the slot.</span>
  225 |     | <span class='neutral'>        bytes32 previousValue;</span>
  226 |     | <span class='neutral'>        // The new value of the slot.</span>
  227 |     | <span class='neutral'>        bytes32 newValue;</span>
  228 |     | <span class='neutral'>        // If the access was reverted.</span>
  229 |     | <span class='neutral'>        bool reverted;</span>
  230 |     | <span class='neutral'>    }</span>
  231 |     | <span class='neutral'></span>
  232 |     | <span class='neutral'>    /// Gas used. Returned by `lastCallGas`.</span>
  233 |     | <span class='neutral'>    struct Gas {</span>
  234 |     | <span class='neutral'>        // The gas limit of the call.</span>
  235 |     | <span class='neutral'>        uint64 gasLimit;</span>
  236 |     | <span class='neutral'>        // The total gas used.</span>
  237 |     | <span class='neutral'>        uint64 gasTotalUsed;</span>
  238 |     | <span class='neutral'>        // DEPRECATED: The amount of gas used for memory expansion. Ref: &lt;https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939&gt;</span>
  239 |     | <span class='neutral'>        uint64 gasMemoryUsed;</span>
  240 |     | <span class='neutral'>        // The amount of gas refunded.</span>
  241 |     | <span class='neutral'>        int64 gasRefunded;</span>
  242 |     | <span class='neutral'>        // The amount of gas remaining.</span>
  243 |     | <span class='neutral'>        uint64 gasRemaining;</span>
  244 |     | <span class='neutral'>    }</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='neutral'>    // ======== Environment ========</span>
  247 |     | <span class='neutral'></span>
  248 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  249 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  250 |     | <span class='neutral'>    function envAddress(string calldata name) external view returns (address value);</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  253 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  254 |     | <span class='neutral'>    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  257 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  258 |     | <span class='neutral'>    function envBool(string calldata name) external view returns (bool value);</span>
  259 |     | <span class='neutral'></span>
  260 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  261 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  262 |     | <span class='neutral'>    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  265 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  266 |     | <span class='neutral'>    function envBytes32(string calldata name) external view returns (bytes32 value);</span>
  267 |     | <span class='neutral'></span>
  268 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  269 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  270 |     | <span class='neutral'>    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);</span>
  271 |     | <span class='neutral'></span>
  272 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  273 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  274 |     | <span class='neutral'>    function envBytes(string calldata name) external view returns (bytes memory value);</span>
  275 |     | <span class='neutral'></span>
  276 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  277 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  278 |     | <span class='neutral'>    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);</span>
  279 |     | <span class='neutral'></span>
  280 |     | <span class='neutral'>    /// Gets the environment variable `name` and returns true if it exists, else returns false.</span>
  281 |     | <span class='neutral'>    function envExists(string calldata name) external view returns (bool result);</span>
  282 |     | <span class='neutral'></span>
  283 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  284 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  285 |     | <span class='neutral'>    function envInt(string calldata name) external view returns (int256 value);</span>
  286 |     | <span class='neutral'></span>
  287 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  288 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  289 |     | <span class='neutral'>    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);</span>
  290 |     | <span class='neutral'></span>
  291 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  292 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  293 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  294 |     | <span class='neutral'>    function envOr(string calldata name, bool defaultValue) external view returns (bool value);</span>
  295 |     | <span class='neutral'></span>
  296 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  297 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  298 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  299 |     | <span class='neutral'>    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  302 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  303 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  304 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)</span>
  305 |     | <span class='neutral'>        external</span>
  306 |     | <span class='neutral'>        view</span>
  307 |     | <span class='neutral'>        returns (address[] memory value);</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  310 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  311 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  312 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)</span>
  313 |     | <span class='neutral'>        external</span>
  314 |     | <span class='neutral'>        view</span>
  315 |     | <span class='neutral'>        returns (bytes32[] memory value);</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  318 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  319 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  320 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)</span>
  321 |     | <span class='neutral'>        external</span>
  322 |     | <span class='neutral'>        view</span>
  323 |     | <span class='neutral'>        returns (string[] memory value);</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  326 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  327 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  328 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)</span>
  329 |     | <span class='neutral'>        external</span>
  330 |     | <span class='neutral'>        view</span>
  331 |     | <span class='neutral'>        returns (bytes[] memory value);</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  334 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  335 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  336 |     | <span class='neutral'>    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  339 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  340 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  341 |     | <span class='neutral'>    function envOr(string calldata name, address defaultValue) external view returns (address value);</span>
  342 |     | <span class='neutral'></span>
  343 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  344 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  345 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  346 |     | <span class='neutral'>    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  349 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  350 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  351 |     | <span class='neutral'>    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  354 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  355 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  356 |     | <span class='neutral'>    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  359 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  360 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  361 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)</span>
  362 |     | <span class='neutral'>        external</span>
  363 |     | <span class='neutral'>        view</span>
  364 |     | <span class='neutral'>        returns (bool[] memory value);</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  367 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  368 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  369 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)</span>
  370 |     | <span class='neutral'>        external</span>
  371 |     | <span class='neutral'>        view</span>
  372 |     | <span class='neutral'>        returns (uint256[] memory value);</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  375 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  376 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  377 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)</span>
  378 |     | <span class='neutral'>        external</span>
  379 |     | <span class='neutral'>        view</span>
  380 |     | <span class='neutral'>        returns (int256[] memory value);</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  383 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  384 |     | <span class='neutral'>    function envString(string calldata name) external view returns (string memory value);</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  387 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  388 |     | <span class='neutral'>    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  391 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  392 |     | <span class='neutral'>    function envUint(string calldata name) external view returns (uint256 value);</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  395 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  396 |     | <span class='neutral'>    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>    /// Returns true if `forge` command was executed in given context.</span>
  399 |     | <span class='neutral'>    function isContext(ForgeContext context) external view returns (bool result);</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    /// Sets environment variables.</span>
  402 |     | <span class='neutral'>    function setEnv(string calldata name, string calldata value) external;</span>
  403 |     | <span class='neutral'></span>
  404 |     | <span class='neutral'>    // ======== EVM ========</span>
  405 |     | <span class='neutral'></span>
  406 |     | <span class='neutral'>    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.</span>
  407 |     | <span class='neutral'>    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    /// Gets the address for a given private key.</span>
  410 |     | <span class='neutral'>    function addr(uint256 privateKey) external pure returns (address keyAddr);</span>
  411 |     | <span class='neutral'></span>
  412 |     | <span class='neutral'>    /// Gets all the logs according to specified filter.</span>
  413 |     | <span class='neutral'>    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)</span>
  414 |     | <span class='neutral'>        external</span>
  415 |     | <span class='neutral'>        returns (EthGetLogs[] memory logs);</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    /// Gets the current `block.blobbasefee`.</span>
  418 |     | <span class='neutral'>    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,</span>
  419 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  420 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  421 |     | <span class='neutral'>    function getBlobBaseFee() external view returns (uint256 blobBaseFee);</span>
  422 |     | <span class='neutral'></span>
  423 |     | <span class='neutral'>    /// Gets the current `block.number`.</span>
  424 |     | <span class='neutral'>    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,</span>
  425 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  426 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  427 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 height);</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    /// Gets the current `block.timestamp`.</span>
  430 |     | <span class='neutral'>    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,</span>
  431 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  432 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  433 |     | <span class='neutral'>    function getBlockTimestamp() external view returns (uint256 timestamp);</span>
  434 |     | <span class='neutral'></span>
  435 |     | <span class='neutral'>    /// Gets the map key and parent of a mapping at a given slot, for a given address.</span>
  436 |     | <span class='neutral'>    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)</span>
  437 |     | <span class='neutral'>        external</span>
  438 |     | <span class='neutral'>        returns (bool found, bytes32 key, bytes32 parent);</span>
  439 |     | <span class='neutral'></span>
  440 |     | <span class='neutral'>    /// Gets the number of elements in the mapping at the given slot, for a given address.</span>
  441 |     | <span class='neutral'>    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);</span>
  442 |     | <span class='neutral'></span>
  443 |     | <span class='neutral'>    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The</span>
  444 |     | <span class='neutral'>    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).</span>
  445 |     | <span class='neutral'>    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);</span>
  446 |     | <span class='neutral'></span>
  447 |     | <span class='neutral'>    /// Gets the nonce of an account.</span>
  448 |     | <span class='neutral'>    function getNonce(address account) external view returns (uint64 nonce);</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='neutral'>    /// Gets all the recorded logs.</span>
  451 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory logs);</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    /// Gets the gas used in the last call.</span>
  454 |     | <span class='neutral'>    function lastCallGas() external view returns (Gas memory gas);</span>
  455 |     | <span class='neutral'></span>
  456 |     | <span class='neutral'>    /// Loads a storage slot from an address.</span>
  457 |     | <span class='neutral'>    function load(address target, bytes32 slot) external view returns (bytes32 data);</span>
  458 |     | <span class='neutral'></span>
  459 |     | <span class='neutral'>    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.</span>
  460 |     | <span class='neutral'>    function pauseGasMetering() external;</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>    /// Records all storage reads and writes.</span>
  463 |     | <span class='neutral'>    function record() external;</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    /// Record all the transaction logs.</span>
  466 |     | <span class='neutral'>    function recordLogs() external;</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.</span>
  469 |     | <span class='neutral'>    function resumeGasMetering() external;</span>
  470 |     | <span class='neutral'></span>
  471 |     | <span class='neutral'>    /// Performs an Ethereum JSON-RPC request to the current fork URL.</span>
  472 |     | <span class='neutral'>    function rpc(string calldata method, string calldata params) external returns (bytes memory data);</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256r1 curve.</span>
  475 |     | <span class='neutral'>    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256k1 curve.</span>
  478 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  479 |     | <span class='neutral'></span>
  480 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  481 |     | <span class='neutral'>    /// If `--sender` is provided, the signer with provided address is used, otherwise,</span>
  482 |     | <span class='neutral'>    /// if exactly one signer is provided to the script, that signer is used.</span>
  483 |     | <span class='neutral'>    /// Raises error if signer passed through `--sender` does not match any unlocked signers or</span>
  484 |     | <span class='neutral'>    /// if `--sender` is not provided and not exactly one signer is passed to the script.</span>
  485 |     | <span class='neutral'>    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  486 |     | <span class='neutral'></span>
  487 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  488 |     | <span class='neutral'>    /// Raises error if none of the signers passed into the script have provided address.</span>
  489 |     | <span class='neutral'>    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  490 |     | <span class='neutral'></span>
  491 |     | <span class='neutral'>    /// Starts recording all map SSTOREs for later retrieval.</span>
  492 |     | <span class='neutral'>    function startMappingRecording() external;</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='neutral'>    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,</span>
  495 |     | <span class='neutral'>    /// along with the context of the calls</span>
  496 |     | <span class='neutral'>    function startStateDiffRecording() external;</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.</span>
  499 |     | <span class='neutral'>    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.</span>
  502 |     | <span class='neutral'>    function stopMappingRecording() external;</span>
  503 |     | <span class='neutral'></span>
  504 |     | <span class='neutral'>    // ======== Filesystem ========</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
  507 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  508 |     | <span class='neutral'>    function closeFile(string calldata path) external;</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.</span>
  511 |     | <span class='neutral'>    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.</span>
  512 |     | <span class='neutral'>    /// Both `from` and `to` are relative to the project root.</span>
  513 |     | <span class='neutral'>    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);</span>
  514 |     | <span class='neutral'></span>
  515 |     | <span class='neutral'>    /// Creates a new, empty directory at the provided path.</span>
  516 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  517 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  518 |     | <span class='neutral'>    /// - A parent of the given path doesn&#39;t exist and `recursive` is false.</span>
  519 |     | <span class='neutral'>    /// - `path` already exists and `recursive` is false.</span>
  520 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  521 |     | <span class='neutral'>    function createDir(string calldata path, bool recursive) external;</span>
  522 |     | <span class='neutral'></span>
  523 |     | <span class='neutral'>    /// Returns true if the given path points to an existing entity, else returns false.</span>
  524 |     | <span class='neutral'>    function exists(string calldata path) external returns (bool result);</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    /// Performs a foreign function call via the terminal.</span>
  527 |     | <span class='neutral'>    function ffi(string[] calldata commandInput) external returns (bytes memory result);</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    /// Given a path, query the file system to get information about a file, directory, etc.</span>
  530 |     | <span class='neutral'>    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);</span>
  531 |     | <span class='neutral'></span>
  532 |     | <span class='neutral'>    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  533 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  534 |     | <span class='neutral'>    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);</span>
  535 |     | <span class='neutral'></span>
  536 |     | <span class='neutral'>    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  537 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  538 |     | <span class='neutral'>    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);</span>
  539 |     | <span class='neutral'></span>
  540 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.</span>
  541 |     | <span class='neutral'>    function isDir(string calldata path) external returns (bool result);</span>
  542 |     | <span class='neutral'></span>
  543 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.</span>
  544 |     | <span class='neutral'>    function isFile(string calldata path) external returns (bool result);</span>
  545 |     | <span class='neutral'></span>
  546 |     | <span class='neutral'>    /// Get the path of the current project root.</span>
  547 |     | <span class='neutral'>    function projectRoot() external view returns (string memory path);</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    /// Prompts the user for a string value in the terminal.</span>
  550 |     | <span class='neutral'>    function prompt(string calldata promptText) external returns (string memory input);</span>
  551 |     | <span class='neutral'></span>
  552 |     | <span class='neutral'>    /// Prompts the user for an address in the terminal.</span>
  553 |     | <span class='neutral'>    function promptAddress(string calldata promptText) external returns (address);</span>
  554 |     | <span class='neutral'></span>
  555 |     | <span class='neutral'>    /// Prompts the user for a hidden string value in the terminal.</span>
  556 |     | <span class='neutral'>    function promptSecret(string calldata promptText) external returns (string memory input);</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    /// Prompts the user for hidden uint256 in the terminal (usually pk).</span>
  559 |     | <span class='neutral'>    function promptSecretUint(string calldata promptText) external returns (uint256);</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    /// Prompts the user for uint256 in the terminal.</span>
  562 |     | <span class='neutral'>    function promptUint(string calldata promptText) external returns (uint256);</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='neutral'>    /// Reads the directory at the given path recursively, up to `maxDepth`.</span>
  565 |     | <span class='neutral'>    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.</span>
  566 |     | <span class='neutral'>    /// Follows symbolic links if `followLinks` is true.</span>
  567 |     | <span class='neutral'>    function readDir(string calldata path) external view returns (DirEntry[] memory entries);</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  570 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);</span>
  571 |     | <span class='neutral'></span>
  572 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  573 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth, bool followLinks)</span>
  574 |     | <span class='neutral'>        external</span>
  575 |     | <span class='neutral'>        view</span>
  576 |     | <span class='neutral'>        returns (DirEntry[] memory entries);</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>    /// Reads the entire content of file to string. `path` is relative to the project root.</span>
  579 |     | <span class='neutral'>    function readFile(string calldata path) external view returns (string memory data);</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    /// Reads the entire content of file as binary. `path` is relative to the project root.</span>
  582 |     | <span class='neutral'>    function readFileBinary(string calldata path) external view returns (bytes memory data);</span>
  583 |     | <span class='neutral'></span>
  584 |     | <span class='neutral'>    /// Reads next line of file to string.</span>
  585 |     | <span class='neutral'>    function readLine(string calldata path) external view returns (string memory line);</span>
  586 |     | <span class='neutral'></span>
  587 |     | <span class='neutral'>    /// Reads a symbolic link, returning the path that the link points to.</span>
  588 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  589 |     | <span class='neutral'>    /// - `path` is not a symbolic link.</span>
  590 |     | <span class='neutral'>    /// - `path` does not exist.</span>
  591 |     | <span class='neutral'>    function readLink(string calldata linkPath) external view returns (string memory targetPath);</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    /// Removes a directory at the provided path.</span>
  594 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  595 |     | <span class='neutral'>    /// - `path` doesn&#39;t exist.</span>
  596 |     | <span class='neutral'>    /// - `path` isn&#39;t a directory.</span>
  597 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  598 |     | <span class='neutral'>    /// - The directory is not empty and `recursive` is false.</span>
  599 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  600 |     | <span class='neutral'>    function removeDir(string calldata path, bool recursive) external;</span>
  601 |     | <span class='neutral'></span>
  602 |     | <span class='neutral'>    /// Removes a file from the filesystem.</span>
  603 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  604 |     | <span class='neutral'>    /// - `path` points to a directory.</span>
  605 |     | <span class='neutral'>    /// - The file doesn&#39;t exist.</span>
  606 |     | <span class='neutral'>    /// - The user lacks permissions to remove the file.</span>
  607 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  608 |     | <span class='neutral'>    function removeFile(string calldata path) external;</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.</span>
  611 |     | <span class='neutral'>    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    /// Returns the time since unix epoch in milliseconds.</span>
  614 |     | <span class='neutral'>    function unixTime() external returns (uint256 milliseconds);</span>
  615 |     | <span class='neutral'></span>
  616 |     | <span class='neutral'>    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  617 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  618 |     | <span class='neutral'>    function writeFile(string calldata path, string calldata data) external;</span>
  619 |     | <span class='neutral'></span>
  620 |     | <span class='neutral'>    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  621 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  622 |     | <span class='neutral'>    function writeFileBinary(string calldata path, bytes calldata data) external;</span>
  623 |     | <span class='neutral'></span>
  624 |     | <span class='neutral'>    /// Writes line to file, creating a file if it does not exist.</span>
  625 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  626 |     | <span class='neutral'>    function writeLine(string calldata path, string calldata data) external;</span>
  627 |     | <span class='neutral'></span>
  628 |     | <span class='neutral'>    // ======== JSON ========</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object</span>
  631 |     | <span class='neutral'>    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.</span>
  632 |     | <span class='neutral'>    function keyExists(string calldata json, string calldata key) external view returns (bool);</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object.</span>
  635 |     | <span class='neutral'>    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address`.</span>
  638 |     | <span class='neutral'>    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address[]`.</span>
  641 |     | <span class='neutral'>    function parseJsonAddressArray(string calldata json, string calldata key)</span>
  642 |     | <span class='neutral'>        external</span>
  643 |     | <span class='neutral'>        pure</span>
  644 |     | <span class='neutral'>        returns (address[] memory);</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool`.</span>
  647 |     | <span class='neutral'>    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.</span>
  650 |     | <span class='neutral'>    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);</span>
  651 |     | <span class='neutral'></span>
  652 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes`.</span>
  653 |     | <span class='neutral'>    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);</span>
  654 |     | <span class='neutral'></span>
  655 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.</span>
  656 |     | <span class='neutral'>    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.</span>
  659 |     | <span class='neutral'>    function parseJsonBytes32Array(string calldata json, string calldata key)</span>
  660 |     | <span class='neutral'>        external</span>
  661 |     | <span class='neutral'>        pure</span>
  662 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
  663 |     | <span class='neutral'></span>
  664 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.</span>
  665 |     | <span class='neutral'>    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);</span>
  666 |     | <span class='neutral'></span>
  667 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256`.</span>
  668 |     | <span class='neutral'>    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);</span>
  669 |     | <span class='neutral'></span>
  670 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.</span>
  671 |     | <span class='neutral'>    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    /// Returns an array of all the keys in a JSON object.</span>
  674 |     | <span class='neutral'>    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);</span>
  675 |     | <span class='neutral'></span>
  676 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string`.</span>
  677 |     | <span class='neutral'>    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);</span>
  678 |     | <span class='neutral'></span>
  679 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string[]`.</span>
  680 |     | <span class='neutral'>    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256`.</span>
  683 |     | <span class='neutral'>    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.</span>
  686 |     | <span class='neutral'>    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);</span>
  687 |     | <span class='neutral'></span>
  688 |     | <span class='neutral'>    /// ABI-encodes a JSON object.</span>
  689 |     | <span class='neutral'>    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);</span>
  690 |     | <span class='neutral'></span>
  691 |     | <span class='neutral'>    /// ABI-encodes a JSON object at `key`.</span>
  692 |     | <span class='neutral'>    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  695 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)</span>
  696 |     | <span class='neutral'>        external</span>
  697 |     | <span class='neutral'>        returns (string memory json);</span>
  698 |     | <span class='neutral'></span>
  699 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  700 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)</span>
  701 |     | <span class='neutral'>        external</span>
  702 |     | <span class='neutral'>        returns (string memory json);</span>
  703 |     | <span class='neutral'></span>
  704 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  705 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)</span>
  706 |     | <span class='neutral'>        external</span>
  707 |     | <span class='neutral'>        returns (string memory json);</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  710 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)</span>
  711 |     | <span class='neutral'>        external</span>
  712 |     | <span class='neutral'>        returns (string memory json);</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  715 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)</span>
  716 |     | <span class='neutral'>        external</span>
  717 |     | <span class='neutral'>        returns (string memory json);</span>
  718 |     | <span class='neutral'></span>
  719 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  720 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)</span>
  721 |     | <span class='neutral'>        external</span>
  722 |     | <span class='neutral'>        returns (string memory json);</span>
  723 |     | <span class='neutral'></span>
  724 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  725 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)</span>
  726 |     | <span class='neutral'>        external</span>
  727 |     | <span class='neutral'>        returns (string memory json);</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  730 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)</span>
  731 |     | <span class='neutral'>        external</span>
  732 |     | <span class='neutral'>        returns (string memory json);</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  735 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)</span>
  736 |     | <span class='neutral'>        external</span>
  737 |     | <span class='neutral'>        returns (string memory json);</span>
  738 |     | <span class='neutral'></span>
  739 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  740 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)</span>
  741 |     | <span class='neutral'>        external</span>
  742 |     | <span class='neutral'>        returns (string memory json);</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='neutral'>    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.</span>
  745 |     | <span class='neutral'>    /// Returns the stringified version of the specific JSON file up to that moment.</span>
  746 |     | <span class='neutral'>    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);</span>
  747 |     | <span class='neutral'></span>
  748 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  749 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)</span>
  750 |     | <span class='neutral'>        external</span>
  751 |     | <span class='neutral'>        returns (string memory json);</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  754 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)</span>
  755 |     | <span class='neutral'>        external</span>
  756 |     | <span class='neutral'>        returns (string memory json);</span>
  757 |     | <span class='neutral'></span>
  758 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  759 |     | <span class='neutral'>    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)</span>
  760 |     | <span class='neutral'>        external</span>
  761 |     | <span class='neutral'>        returns (string memory json);</span>
  762 |     | <span class='neutral'></span>
  763 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  764 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)</span>
  765 |     | <span class='neutral'>        external</span>
  766 |     | <span class='neutral'>        returns (string memory json);</span>
  767 |     | <span class='neutral'></span>
  768 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  769 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)</span>
  770 |     | <span class='neutral'>        external</span>
  771 |     | <span class='neutral'>        returns (string memory json);</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
  774 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path) external;</span>
  775 |     | <span class='neutral'></span>
  776 |     | <span class='neutral'>    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key.&gt;</span>
  777 |     | <span class='neutral'>    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.</span>
  778 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='neutral'>    // ======== Scripting ========</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.</span>
  783 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
  784 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
  785 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
  786 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
  787 |     | <span class='neutral'>    function broadcast() external;</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the address provided</span>
  790 |     | <span class='neutral'>    /// as the sender that can later be signed and sent onchain.</span>
  791 |     | <span class='neutral'>    function broadcast(address signer) external;</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the private key</span>
  794 |     | <span class='neutral'>    /// provided as the sender that can later be signed and sent onchain.</span>
  795 |     | <span class='neutral'>    function broadcast(uint256 privateKey) external;</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.</span>
  798 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
  799 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
  800 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
  801 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
  802 |     | <span class='neutral'>    function startBroadcast() external;</span>
  803 |     | <span class='neutral'></span>
  804 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the address</span>
  805 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
  806 |     | <span class='neutral'>    function startBroadcast(address signer) external;</span>
  807 |     | <span class='neutral'></span>
  808 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the private key</span>
  809 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
  810 |     | <span class='neutral'>    function startBroadcast(uint256 privateKey) external;</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='neutral'>    /// Stops collecting onchain transactions.</span>
  813 |     | <span class='neutral'>    function stopBroadcast() external;</span>
  814 |     | <span class='neutral'></span>
  815 |     | <span class='neutral'>    // ======== String ========</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    /// Returns the index of the first occurrence of a `key` in an `input` string.</span>
  818 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.</span>
  819 |     | <span class='neutral'>    /// Returns 0 in case of an empty `key`.</span>
  820 |     | <span class='neutral'>    function indexOf(string calldata input, string calldata key) external pure returns (uint256);</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    /// Parses the given `string` into an `address`.</span>
  823 |     | <span class='neutral'>    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    /// Parses the given `string` into a `bool`.</span>
  826 |     | <span class='neutral'>    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);</span>
  827 |     | <span class='neutral'></span>
  828 |     | <span class='neutral'>    /// Parses the given `string` into `bytes`.</span>
  829 |     | <span class='neutral'>    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);</span>
  830 |     | <span class='neutral'></span>
  831 |     | <span class='neutral'>    /// Parses the given `string` into a `bytes32`.</span>
  832 |     | <span class='neutral'>    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    /// Parses the given `string` into a `int256`.</span>
  835 |     | <span class='neutral'>    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    /// Parses the given `string` into a `uint256`.</span>
  838 |     | <span class='neutral'>    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);</span>
  839 |     | <span class='neutral'></span>
  840 |     | <span class='neutral'>    /// Replaces occurrences of `from` in the given `string` with `to`.</span>
  841 |     | <span class='neutral'>    function replace(string calldata input, string calldata from, string calldata to)</span>
  842 |     | <span class='neutral'>        external</span>
  843 |     | <span class='neutral'>        pure</span>
  844 |     | <span class='neutral'>        returns (string memory output);</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='neutral'>    /// Splits the given `string` into an array of strings divided by the `delimiter`.</span>
  847 |     | <span class='neutral'>    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    /// Converts the given `string` value to Lowercase.</span>
  850 |     | <span class='neutral'>    function toLowercase(string calldata input) external pure returns (string memory output);</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  853 |     | <span class='neutral'>    function toString(address value) external pure returns (string memory stringifiedValue);</span>
  854 |     | <span class='neutral'></span>
  855 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  856 |     | <span class='neutral'>    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  859 |     | <span class='neutral'>    function toString(bytes32 value) external pure returns (string memory stringifiedValue);</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  862 |     | <span class='neutral'>    function toString(bool value) external pure returns (string memory stringifiedValue);</span>
  863 |     | <span class='neutral'></span>
  864 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  865 |     | <span class='neutral'>    function toString(uint256 value) external pure returns (string memory stringifiedValue);</span>
  866 |     | <span class='neutral'></span>
  867 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  868 |     | <span class='neutral'>    function toString(int256 value) external pure returns (string memory stringifiedValue);</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    /// Converts the given `string` value to Uppercase.</span>
  871 |     | <span class='neutral'>    function toUppercase(string calldata input) external pure returns (string memory output);</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    /// Trims leading and trailing whitespace from the given `string` value.</span>
  874 |     | <span class='neutral'>    function trim(string calldata input) external pure returns (string memory output);</span>
  875 |     | <span class='neutral'></span>
  876 |     | <span class='neutral'>    // ======== Testing ========</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  879 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  880 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  883 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  884 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
  885 |     | <span class='neutral'>        uint256 left,</span>
  886 |     | <span class='neutral'>        uint256 right,</span>
  887 |     | <span class='neutral'>        uint256 maxDelta,</span>
  888 |     | <span class='neutral'>        uint256 decimals,</span>
  889 |     | <span class='neutral'>        string calldata error</span>
  890 |     | <span class='neutral'>    ) external pure;</span>
  891 |     | <span class='neutral'></span>
  892 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  893 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  894 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
  895 |     | <span class='neutral'></span>
  896 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  897 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  898 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
  899 |     | <span class='neutral'>        int256 left,</span>
  900 |     | <span class='neutral'>        int256 right,</span>
  901 |     | <span class='neutral'>        uint256 maxDelta,</span>
  902 |     | <span class='neutral'>        uint256 decimals,</span>
  903 |     | <span class='neutral'>        string calldata error</span>
  904 |     | <span class='neutral'>    ) external pure;</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  907 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  910 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  911 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  914 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;</span>
  915 |     | <span class='neutral'></span>
  916 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  917 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  918 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  921 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  922 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  923 |     | <span class='neutral'>    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)</span>
  924 |     | <span class='neutral'>        external</span>
  925 |     | <span class='neutral'>        pure;</span>
  926 |     | <span class='neutral'></span>
  927 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  928 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  929 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  930 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
  931 |     | <span class='neutral'>        uint256 left,</span>
  932 |     | <span class='neutral'>        uint256 right,</span>
  933 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
  934 |     | <span class='neutral'>        uint256 decimals,</span>
  935 |     | <span class='neutral'>        string calldata error</span>
  936 |     | <span class='neutral'>    ) external pure;</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  939 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  940 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  941 |     | <span class='neutral'>    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)</span>
  942 |     | <span class='neutral'>        external</span>
  943 |     | <span class='neutral'>        pure;</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  946 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  947 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  948 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
  949 |     | <span class='neutral'>        int256 left,</span>
  950 |     | <span class='neutral'>        int256 right,</span>
  951 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
  952 |     | <span class='neutral'>        uint256 decimals,</span>
  953 |     | <span class='neutral'>        string calldata error</span>
  954 |     | <span class='neutral'>    ) external pure;</span>
  955 |     | <span class='neutral'></span>
  956 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  957 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  958 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;</span>
  959 |     | <span class='neutral'></span>
  960 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  961 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  962 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  963 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)</span>
  964 |     | <span class='neutral'>        external</span>
  965 |     | <span class='neutral'>        pure;</span>
  966 |     | <span class='neutral'></span>
  967 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  968 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  969 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;</span>
  970 |     | <span class='neutral'></span>
  971 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  972 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  973 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  974 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)</span>
  975 |     | <span class='neutral'>        external</span>
  976 |     | <span class='neutral'>        pure;</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
  979 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
  982 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  983 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
  986 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
  987 |     | <span class='neutral'></span>
  988 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
  989 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  990 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
  991 |     | <span class='neutral'></span>
  992 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal.</span>
  993 |     | <span class='neutral'>    function assertEq(bool left, bool right) external pure;</span>
  994 |     | <span class='neutral'></span>
  995 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.</span>
  996 |     | <span class='neutral'>    function assertEq(bool left, bool right, string calldata error) external pure;</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>    /// Asserts that two `string` values are equal.</span>
  999 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right) external pure;</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    /// Asserts that two `string` values are equal and includes error message into revert string on failure.</span>
 1002 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1003 |     | <span class='neutral'></span>
 1004 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal.</span>
 1005 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right) external pure;</span>
 1006 |     | <span class='neutral'></span>
 1007 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.</span>
 1008 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal.</span>
 1011 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.</span>
 1014 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1015 |     | <span class='neutral'></span>
 1016 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256 values are equal.</span>
 1017 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1018 |     | <span class='neutral'></span>
 1019 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.</span>
 1020 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal.</span>
 1023 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.</span>
 1026 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal.</span>
 1029 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right) external pure;</span>
 1030 |     | <span class='neutral'></span>
 1031 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal.</span>
 1032 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right) external pure;</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.</span>
 1035 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal.</span>
 1038 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1039 |     | <span class='neutral'></span>
 1040 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.</span>
 1041 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1042 |     | <span class='neutral'></span>
 1043 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal.</span>
 1044 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right) external pure;</span>
 1045 |     | <span class='neutral'></span>
 1046 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.</span>
 1047 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal.</span>
 1050 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1051 |     | <span class='neutral'></span>
 1052 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.</span>
 1053 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1054 |     | <span class='neutral'></span>
 1055 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.</span>
 1056 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal.</span>
 1059 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) external pure;</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.</span>
 1062 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string calldata error) external pure;</span>
 1063 |     | <span class='neutral'></span>
 1064 |     | <span class='neutral'>    /// Asserts that two `address` values are equal.</span>
 1065 |     | <span class='neutral'>    function assertEq(address left, address right) external pure;</span>
 1066 |     | <span class='neutral'></span>
 1067 |     | <span class='neutral'>    /// Asserts that two `address` values are equal and includes error message into revert string on failure.</span>
 1068 |     | <span class='neutral'>    function assertEq(address left, address right, string calldata error) external pure;</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal.</span>
 1071 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right) external pure;</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.</span>
 1074 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>    /// Asserts that the given condition is false.</span>
 1077 |     | <span class='neutral'>    function assertFalse(bool condition) external pure;</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='neutral'>    /// Asserts that the given condition is false and includes error message into revert string on failure.</span>
 1080 |     | <span class='neutral'>    function assertFalse(bool condition, string calldata error) external pure;</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1083 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1084 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1087 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1088 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1091 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1092 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1095 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1096 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1099 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) external pure;</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1102 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1103 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1106 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) external pure;</span>
 1107 |     | <span class='neutral'></span>
 1108 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1109 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1110 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string calldata error) external pure;</span>
 1111 |     | <span class='neutral'></span>
 1112 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1113 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1114 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1117 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1118 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1119 |     | <span class='neutral'></span>
 1120 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1121 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1122 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1125 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1126 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1127 |     | <span class='neutral'></span>
 1128 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1129 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) external pure;</span>
 1130 |     | <span class='neutral'></span>
 1131 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1132 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1133 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1134 |     | <span class='neutral'></span>
 1135 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1136 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) external pure;</span>
 1137 |     | <span class='neutral'></span>
 1138 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1139 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1140 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string calldata error) external pure;</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1143 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1144 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1147 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1148 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1151 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1152 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1155 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1156 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1159 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) external pure;</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1162 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1163 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1166 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) external pure;</span>
 1167 |     | <span class='neutral'></span>
 1168 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1169 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1170 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string calldata error) external pure;</span>
 1171 |     | <span class='neutral'></span>
 1172 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1173 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1174 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1175 |     | <span class='neutral'></span>
 1176 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1177 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1178 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1179 |     | <span class='neutral'></span>
 1180 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1181 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1182 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1183 |     | <span class='neutral'></span>
 1184 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1185 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1186 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1187 |     | <span class='neutral'></span>
 1188 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1189 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) external pure;</span>
 1190 |     | <span class='neutral'></span>
 1191 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1192 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1193 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1194 |     | <span class='neutral'></span>
 1195 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1196 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) external pure;</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1199 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1200 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string calldata error) external pure;</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1203 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1206 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1207 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1210 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1211 |     | <span class='neutral'></span>
 1212 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1213 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1214 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1215 |     | <span class='neutral'></span>
 1216 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal.</span>
 1217 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) external pure;</span>
 1218 |     | <span class='neutral'></span>
 1219 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.</span>
 1220 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string calldata error) external pure;</span>
 1221 |     | <span class='neutral'></span>
 1222 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal.</span>
 1223 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right) external pure;</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.</span>
 1226 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1227 |     | <span class='neutral'></span>
 1228 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal.</span>
 1229 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right) external pure;</span>
 1230 |     | <span class='neutral'></span>
 1231 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.</span>
 1232 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal.</span>
 1235 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.</span>
 1238 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1239 |     | <span class='neutral'></span>
 1240 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal.</span>
 1241 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1242 |     | <span class='neutral'></span>
 1243 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.</span>
 1244 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal.</span>
 1247 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.</span>
 1250 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1251 |     | <span class='neutral'></span>
 1252 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal.</span>
 1253 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) external pure;</span>
 1254 |     | <span class='neutral'></span>
 1255 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal.</span>
 1256 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right) external pure;</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.</span>
 1259 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal.</span>
 1262 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1263 |     | <span class='neutral'></span>
 1264 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1265 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1266 |     | <span class='neutral'></span>
 1267 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal.</span>
 1268 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right) external pure;</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.</span>
 1271 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal.</span>
 1274 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1275 |     | <span class='neutral'></span>
 1276 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.</span>
 1277 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1278 |     | <span class='neutral'></span>
 1279 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.</span>
 1280 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1281 |     | <span class='neutral'></span>
 1282 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal.</span>
 1283 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) external pure;</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.</span>
 1286 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string calldata error) external pure;</span>
 1287 |     | <span class='neutral'></span>
 1288 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal.</span>
 1289 |     | <span class='neutral'>    function assertNotEq(address left, address right) external pure;</span>
 1290 |     | <span class='neutral'></span>
 1291 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.</span>
 1292 |     | <span class='neutral'>    function assertNotEq(address left, address right, string calldata error) external pure;</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal.</span>
 1295 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) external pure;</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1298 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1299 |     | <span class='neutral'></span>
 1300 |     | <span class='neutral'>    /// Asserts that the given condition is true.</span>
 1301 |     | <span class='neutral'>    function assertTrue(bool condition) external pure;</span>
 1302 |     | <span class='neutral'></span>
 1303 |     | <span class='neutral'>    /// Asserts that the given condition is true and includes error message into revert string on failure.</span>
 1304 |     | <span class='neutral'>    function assertTrue(bool condition, string calldata error) external pure;</span>
 1305 |     | <span class='neutral'></span>
 1306 |     | <span class='neutral'>    /// If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 1307 |     | <span class='neutral'>    function assume(bool condition) external pure;</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    /// Writes a breakpoint to jump to in the debugger.</span>
 1310 |     | <span class='neutral'>    function breakpoint(string calldata char) external;</span>
 1311 |     | <span class='neutral'></span>
 1312 |     | <span class='neutral'>    /// Writes a conditional breakpoint to jump to in the debugger.</span>
 1313 |     | <span class='neutral'>    function breakpoint(string calldata char, bool value) external;</span>
 1314 |     | <span class='neutral'></span>
 1315 |     | <span class='neutral'>    /// Returns the RPC url for the given alias.</span>
 1316 |     | <span class='neutral'>    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases as structs.</span>
 1319 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory urls);</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases `[alias, url][]`.</span>
 1322 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory urls);</span>
 1323 |     | <span class='neutral'></span>
 1324 |     | <span class='neutral'>    /// Suspends execution of the main thread for `duration` milliseconds.</span>
 1325 |     | <span class='neutral'>    function sleep(uint256 duration) external;</span>
 1326 |     | <span class='neutral'></span>
 1327 |     | <span class='neutral'>    // ======== Toml ========</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    /// Checks if `key` exists in a TOML table.</span>
 1330 |     | <span class='neutral'>    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);</span>
 1331 |     | <span class='neutral'></span>
 1332 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address`.</span>
 1333 |     | <span class='neutral'>    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);</span>
 1334 |     | <span class='neutral'></span>
 1335 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address[]`.</span>
 1336 |     | <span class='neutral'>    function parseTomlAddressArray(string calldata toml, string calldata key)</span>
 1337 |     | <span class='neutral'>        external</span>
 1338 |     | <span class='neutral'>        pure</span>
 1339 |     | <span class='neutral'>        returns (address[] memory);</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool`.</span>
 1342 |     | <span class='neutral'>    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);</span>
 1343 |     | <span class='neutral'></span>
 1344 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.</span>
 1345 |     | <span class='neutral'>    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);</span>
 1346 |     | <span class='neutral'></span>
 1347 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes`.</span>
 1348 |     | <span class='neutral'>    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);</span>
 1349 |     | <span class='neutral'></span>
 1350 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.</span>
 1351 |     | <span class='neutral'>    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.</span>
 1354 |     | <span class='neutral'>    function parseTomlBytes32Array(string calldata toml, string calldata key)</span>
 1355 |     | <span class='neutral'>        external</span>
 1356 |     | <span class='neutral'>        pure</span>
 1357 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
 1358 |     | <span class='neutral'></span>
 1359 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.</span>
 1360 |     | <span class='neutral'>    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256`.</span>
 1363 |     | <span class='neutral'>    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.</span>
 1366 |     | <span class='neutral'>    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);</span>
 1367 |     | <span class='neutral'></span>
 1368 |     | <span class='neutral'>    /// Returns an array of all the keys in a TOML table.</span>
 1369 |     | <span class='neutral'>    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);</span>
 1370 |     | <span class='neutral'></span>
 1371 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string`.</span>
 1372 |     | <span class='neutral'>    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string[]`.</span>
 1375 |     | <span class='neutral'>    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256`.</span>
 1378 |     | <span class='neutral'>    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);</span>
 1379 |     | <span class='neutral'></span>
 1380 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.</span>
 1381 |     | <span class='neutral'>    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);</span>
 1382 |     | <span class='neutral'></span>
 1383 |     | <span class='neutral'>    /// ABI-encodes a TOML table.</span>
 1384 |     | <span class='neutral'>    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    /// ABI-encodes a TOML table at `key`.</span>
 1387 |     | <span class='neutral'>    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.</span>
 1390 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path) external;</span>
 1391 |     | <span class='neutral'></span>
 1392 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = &lt;value_key.&gt;</span>
 1393 |     | <span class='neutral'>    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.</span>
 1394 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;</span>
 1395 |     | <span class='neutral'></span>
 1396 |     | <span class='neutral'>    // ======== Utilities ========</span>
 1397 |     | <span class='neutral'></span>
 1398 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.</span>
 1399 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)</span>
 1400 |     | <span class='neutral'>        external</span>
 1401 |     | <span class='neutral'>        pure</span>
 1402 |     | <span class='neutral'>        returns (address);</span>
 1403 |     | <span class='neutral'></span>
 1404 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.</span>
 1405 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);</span>
 1406 |     | <span class='neutral'></span>
 1407 |     | <span class='neutral'>    /// Compute the address a contract will be deployed at for a given deployer address and nonce.</span>
 1408 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);</span>
 1409 |     | <span class='neutral'></span>
 1410 |     | <span class='neutral'>    /// Derives a private key from the name, labels the account with that name, and returns the wallet.</span>
 1411 |     | <span class='neutral'>    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    /// Generates a wallet from the private key and returns the wallet.</span>
 1414 |     | <span class='neutral'>    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);</span>
 1415 |     | <span class='neutral'></span>
 1416 |     | <span class='neutral'>    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.</span>
 1417 |     | <span class='neutral'>    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);</span>
 1418 |     | <span class='neutral'></span>
 1419 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
 1420 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
 1421 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);</span>
 1422 |     | <span class='neutral'></span>
 1423 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
 1424 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
 1425 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)</span>
 1426 |     | <span class='neutral'>        external</span>
 1427 |     | <span class='neutral'>        pure</span>
 1428 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
 1431 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
 1432 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)</span>
 1433 |     | <span class='neutral'>        external</span>
 1434 |     | <span class='neutral'>        pure</span>
 1435 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
 1438 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
 1439 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)</span>
 1440 |     | <span class='neutral'>        external</span>
 1441 |     | <span class='neutral'>        pure</span>
 1442 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 1443 |     | <span class='neutral'></span>
 1444 |     | <span class='neutral'>    /// Returns ENS namehash for provided string.</span>
 1445 |     | <span class='neutral'>    function ensNamehash(string calldata name) external pure returns (bytes32);</span>
 1446 |     | <span class='neutral'></span>
 1447 |     | <span class='neutral'>    /// Gets the label for the specified address.</span>
 1448 |     | <span class='neutral'>    function getLabel(address account) external view returns (string memory currentLabel);</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    /// Get a `Wallet`&#39;s nonce.</span>
 1451 |     | <span class='neutral'>    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    /// Labels an address in call traces.</span>
 1454 |     | <span class='neutral'>    function label(address account, string calldata newLabel) external;</span>
 1455 |     | <span class='neutral'></span>
 1456 |     | <span class='neutral'>    /// Returns a random `address`.</span>
 1457 |     | <span class='neutral'>    function randomAddress() external returns (address);</span>
 1458 |     | <span class='neutral'></span>
 1459 |     | <span class='neutral'>    /// Returns a random uint256 value.</span>
 1460 |     | <span class='neutral'>    function randomUint() external returns (uint256);</span>
 1461 |     | <span class='neutral'></span>
 1462 |     | <span class='neutral'>    /// Returns random uin256 value between the provided range (=min..=max).</span>
 1463 |     | <span class='neutral'>    function randomUint(uint256 min, uint256 max) external returns (uint256);</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    /// Adds a private key to the local forge wallet and returns the address.</span>
 1466 |     | <span class='neutral'>    function rememberKey(uint256 privateKey) external returns (address keyAddr);</span>
 1467 |     | <span class='neutral'></span>
 1468 |     | <span class='neutral'>    /// Signs data with a `Wallet`.</span>
 1469 |     | <span class='neutral'>    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);</span>
 1470 |     | <span class='neutral'></span>
 1471 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64url string.</span>
 1472 |     | <span class='neutral'>    function toBase64URL(bytes calldata data) external pure returns (string memory);</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    /// Encodes a `string` value to a base64url string.</span>
 1475 |     | <span class='neutral'>    function toBase64URL(string calldata data) external pure returns (string memory);</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64 string.</span>
 1478 |     | <span class='neutral'>    function toBase64(bytes calldata data) external pure returns (string memory);</span>
 1479 |     | <span class='neutral'></span>
 1480 |     | <span class='neutral'>    /// Encodes a `string` value to a base64 string.</span>
 1481 |     | <span class='neutral'>    function toBase64(string calldata data) external pure returns (string memory);</span>
 1482 |     | <span class='neutral'>}</span>
 1483 |     | <span class='neutral'></span>
 1484 |     | <span class='neutral'>/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used</span>
 1485 |     | <span class='neutral'>/// in tests, but it is not recommended to use these cheats in scripts.</span>
 1486 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 1487 |     | <span class='neutral'>    // ======== EVM ========</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.</span>
 1490 |     | <span class='neutral'>    function activeFork() external view returns (uint256 forkId);</span>
 1491 |     | <span class='neutral'></span>
 1492 |     | <span class='neutral'>    /// In forking mode, explicitly grant the given address cheatcode access.</span>
 1493 |     | <span class='neutral'>    function allowCheatcodes(address account) external;</span>
 1494 |     | <span class='neutral'></span>
 1495 |     | <span class='neutral'>    /// Sets `block.blobbasefee`</span>
 1496 |     | <span class='neutral'>    function blobBaseFee(uint256 newBlobBaseFee) external;</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>    /// Sets the blobhashes in the transaction.</span>
 1499 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 1500 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1501 |     | <span class='neutral'>    function blobhashes(bytes32[] calldata hashes) external;</span>
 1502 |     | <span class='neutral'></span>
 1503 |     | <span class='neutral'>    /// Sets `block.chainid`.</span>
 1504 |     | <span class='neutral'>    function chainId(uint256 newChainId) external;</span>
 1505 |     | <span class='neutral'></span>
 1506 |     | <span class='neutral'>    /// Clears all mocked calls.</span>
 1507 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    /// Sets `block.coinbase`.</span>
 1510 |     | <span class='neutral'>    function coinbase(address newCoinbase) external;</span>
 1511 |     | <span class='neutral'></span>
 1512 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.</span>
 1513 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 1514 |     | <span class='neutral'></span>
 1515 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 1516 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 1517 |     | <span class='neutral'></span>
 1518 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,</span>
 1519 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.</span>
 1520 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.</span>
 1523 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 1526 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 1527 |     | <span class='neutral'></span>
 1528 |     | <span class='neutral'>    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,</span>
 1529 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.</span>
 1530 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 1531 |     | <span class='neutral'></span>
 1532 |     | <span class='neutral'>    /// Sets an address&#39; balance.</span>
 1533 |     | <span class='neutral'>    function deal(address account, uint256 newBalance) external;</span>
 1534 |     | <span class='neutral'></span>
 1535 |     | <span class='neutral'>    /// Removes the snapshot with the given ID created by `snapshot`.</span>
 1536 |     | <span class='neutral'>    /// Takes the snapshot ID to delete.</span>
 1537 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully deleted.</span>
 1538 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1539 |     | <span class='neutral'>    function deleteSnapshot(uint256 snapshotId) external returns (bool success);</span>
 1540 |     | <span class='neutral'></span>
 1541 |     | <span class='neutral'>    /// Removes _all_ snapshots previously created by `snapshot`.</span>
 1542 |     | <span class='neutral'>    function deleteSnapshots() external;</span>
 1543 |     | <span class='neutral'></span>
 1544 |     | <span class='neutral'>    /// Sets `block.difficulty`.</span>
 1545 |     | <span class='neutral'>    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.</span>
 1546 |     | <span class='neutral'>    /// Reverts if used on unsupported EVM versions.</span>
 1547 |     | <span class='neutral'>    function difficulty(uint256 newDifficulty) external;</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>    /// Dump a genesis JSON file&#39;s `allocs` to disk.</span>
 1550 |     | <span class='neutral'>    function dumpState(string calldata pathToStateJson) external;</span>
 1551 |     | <span class='neutral'></span>
 1552 |     | <span class='neutral'>    /// Sets an address&#39; code.</span>
 1553 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 1554 |     | <span class='neutral'></span>
 1555 |     | <span class='neutral'>    /// Sets `block.basefee`.</span>
 1556 |     | <span class='neutral'>    function fee(uint256 newBasefee) external;</span>
 1557 |     | <span class='neutral'></span>
 1558 |     | <span class='neutral'>    /// Gets the blockhashes from the current transaction.</span>
 1559 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 1560 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1561 |     | <span class='neutral'>    function getBlobhashes() external view returns (bytes32[] memory hashes);</span>
 1562 |     | <span class='neutral'></span>
 1563 |     | <span class='neutral'>    /// Returns true if the account is marked as persistent.</span>
 1564 |     | <span class='neutral'>    function isPersistent(address account) external view returns (bool persistent);</span>
 1565 |     | <span class='neutral'></span>
 1566 |     | <span class='neutral'>    /// Load a genesis JSON file&#39;s `allocs` into the in-memory revm state.</span>
 1567 |     | <span class='neutral'>    function loadAllocs(string calldata pathToAllocsJson) external;</span>
 1568 |     | <span class='neutral'></span>
 1569 |     | <span class='neutral'>    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 1570 |     | <span class='neutral'>    /// Meaning, changes made to the state of this account will be kept when switching forks.</span>
 1571 |     | <span class='neutral'>    function makePersistent(address account) external;</span>
 1572 |     | <span class='neutral'></span>
 1573 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1574 |     | <span class='neutral'>    function makePersistent(address account0, address account1) external;</span>
 1575 |     | <span class='neutral'></span>
 1576 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1577 |     | <span class='neutral'>    function makePersistent(address account0, address account1, address account2) external;</span>
 1578 |     | <span class='neutral'></span>
 1579 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1580 |     | <span class='neutral'>    function makePersistent(address[] calldata accounts) external;</span>
 1581 |     | <span class='neutral'></span>
 1582 |     | <span class='neutral'>    /// Reverts a call to an address with specified revert data.</span>
 1583 |     | <span class='neutral'>    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;</span>
 1584 |     | <span class='neutral'></span>
 1585 |     | <span class='neutral'>    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.</span>
 1586 |     | <span class='neutral'>    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)</span>
 1587 |     | <span class='neutral'>        external;</span>
 1588 |     | <span class='neutral'></span>
 1589 |     | <span class='neutral'>    /// Mocks a call to an address, returning specified data.</span>
 1590 |     | <span class='neutral'>    /// Calldata can either be strict or a partial match, e.g. if you only</span>
 1591 |     | <span class='neutral'>    /// pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 1592 |     | <span class='neutral'>    /// function will be mocked.</span>
 1593 |     | <span class='neutral'>    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;</span>
 1594 |     | <span class='neutral'></span>
 1595 |     | <span class='neutral'>    /// Mocks a call to an address with a specific `msg.value`, returning specified data.</span>
 1596 |     | <span class='neutral'>    /// Calldata match takes precedence over `msg.value` in case of ambiguity.</span>
 1597 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;</span>
 1598 |     | <span class='neutral'></span>
 1599 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address.</span>
 1600 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
 1601 |     | <span class='neutral'></span>
 1602 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address, and the `tx.origin` to be the second input.</span>
 1603 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin) external;</span>
 1604 |     | <span class='neutral'></span>
 1605 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 1606 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 1607 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1608 |     | <span class='neutral'>    function prevrandao(bytes32 newPrevrandao) external;</span>
 1609 |     | <span class='neutral'></span>
 1610 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 1611 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 1612 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1613 |     | <span class='neutral'>    function prevrandao(uint256 newPrevrandao) external;</span>
 1614 |     | <span class='neutral'></span>
 1615 |     | <span class='neutral'>    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.</span>
 1616 |     | <span class='neutral'>    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);</span>
 1617 |     | <span class='neutral'></span>
 1618 |     | <span class='neutral'>    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.</span>
 1619 |     | <span class='neutral'>    function resetNonce(address account) external;</span>
 1620 |     | <span class='neutral'></span>
 1621 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot</span>
 1622 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 1623 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted.</span>
 1624 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1625 |     | <span class='neutral'>    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.</span>
 1626 |     | <span class='neutral'>    function revertTo(uint256 snapshotId) external returns (bool success);</span>
 1627 |     | <span class='neutral'></span>
 1628 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots</span>
 1629 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 1630 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted and deleted.</span>
 1631 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1632 |     | <span class='neutral'>    function revertToAndDelete(uint256 snapshotId) external returns (bool success);</span>
 1633 |     | <span class='neutral'></span>
 1634 |     | <span class='neutral'>    /// Revokes persistent status from the address, previously added via `makePersistent`.</span>
 1635 |     | <span class='neutral'>    function revokePersistent(address account) external;</span>
 1636 |     | <span class='neutral'></span>
 1637 |     | <span class='neutral'>    /// See `revokePersistent(address)`.</span>
 1638 |     | <span class='neutral'>    function revokePersistent(address[] calldata accounts) external;</span>
 1639 |     | <span class='neutral'></span>
 1640 |     | <span class='neutral'>    /// Sets `block.height`.</span>
 1641 |     | <span class='neutral'>    function roll(uint256 newHeight) external;</span>
 1642 |     | <span class='neutral'></span>
 1643 |     | <span class='neutral'>    /// Updates the currently active fork to given block number</span>
 1644 |     | <span class='neutral'>    /// This is similar to `roll` but for the currently active fork.</span>
 1645 |     | <span class='neutral'>    function rollFork(uint256 blockNumber) external;</span>
 1646 |     | <span class='neutral'></span>
 1647 |     | <span class='neutral'>    /// Updates the currently active fork to given transaction. This will `rollFork` with the number</span>
 1648 |     | <span class='neutral'>    /// of the block the transaction was mined in and replays all transaction mined before it in the block.</span>
 1649 |     | <span class='neutral'>    function rollFork(bytes32 txHash) external;</span>
 1650 |     | <span class='neutral'></span>
 1651 |     | <span class='neutral'>    /// Updates the given fork to given block number.</span>
 1652 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 1653 |     | <span class='neutral'></span>
 1654 |     | <span class='neutral'>    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.</span>
 1655 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 txHash) external;</span>
 1656 |     | <span class='neutral'></span>
 1657 |     | <span class='neutral'>    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 1658 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 1659 |     | <span class='neutral'></span>
 1660 |     | <span class='neutral'>    /// Sets the nonce of an account. Must be higher than the current nonce of the account.</span>
 1661 |     | <span class='neutral'>    function setNonce(address account, uint64 newNonce) external;</span>
 1662 |     | <span class='neutral'></span>
 1663 |     | <span class='neutral'>    /// Sets the nonce of an account to an arbitrary value.</span>
 1664 |     | <span class='neutral'>    function setNonceUnsafe(address account, uint64 newNonce) external;</span>
 1665 |     | <span class='neutral'></span>
 1666 |     | <span class='neutral'>    /// Snapshot the current state of the evm.</span>
 1667 |     | <span class='neutral'>    /// Returns the ID of the snapshot that was created.</span>
 1668 |     | <span class='neutral'>    /// To revert a snapshot use `revertTo`.</span>
 1669 |     | <span class='neutral'>    function snapshot() external returns (uint256 snapshotId);</span>
 1670 |     | <span class='neutral'></span>
 1671 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called.</span>
 1672 |     | <span class='neutral'>    function startPrank(address msgSender) external;</span>
 1673 |     | <span class='neutral'></span>
 1674 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.</span>
 1675 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin) external;</span>
 1676 |     | <span class='neutral'></span>
 1677 |     | <span class='neutral'>    /// Resets subsequent calls&#39; `msg.sender` to be `address(this)`.</span>
 1678 |     | <span class='neutral'>    function stopPrank() external;</span>
 1679 |     | <span class='neutral'></span>
 1680 |     | <span class='neutral'>    /// Stores a value to an address&#39; storage slot.</span>
 1681 |     | <span class='neutral'>    function store(address target, bytes32 slot, bytes32 value) external;</span>
 1682 |     | <span class='neutral'></span>
 1683 |     | <span class='neutral'>    /// Fetches the given transaction from the active fork and executes it on the current state.</span>
 1684 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 1685 |     | <span class='neutral'></span>
 1686 |     | <span class='neutral'>    /// Fetches the given transaction from the given fork and executes it on the current state.</span>
 1687 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 1688 |     | <span class='neutral'></span>
 1689 |     | <span class='neutral'>    /// Sets `tx.gasprice`.</span>
 1690 |     | <span class='neutral'>    function txGasPrice(uint256 newGasPrice) external;</span>
 1691 |     | <span class='neutral'></span>
 1692 |     | <span class='neutral'>    /// Sets `block.timestamp`.</span>
 1693 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
 1694 |     | <span class='neutral'></span>
 1695 |     | <span class='neutral'>    // ======== Testing ========</span>
 1696 |     | <span class='neutral'></span>
 1697 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 1698 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;</span>
 1699 |     | <span class='neutral'></span>
 1700 |     | <span class='neutral'>    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 1701 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)</span>
 1702 |     | <span class='neutral'>        external;</span>
 1703 |     | <span class='neutral'></span>
 1704 |     | <span class='neutral'>    /// Expects a call to an address with the specified calldata.</span>
 1705 |     | <span class='neutral'>    /// Calldata can either be a strict or a partial match.</span>
 1706 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data) external;</span>
 1707 |     | <span class='neutral'></span>
 1708 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified calldata.</span>
 1709 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data, uint64 count) external;</span>
 1710 |     | <span class='neutral'></span>
 1711 |     | <span class='neutral'>    /// Expects a call to an address with the specified `msg.value` and calldata.</span>
 1712 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;</span>
 1713 |     | <span class='neutral'></span>
 1714 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value` and calldata.</span>
 1715 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;</span>
 1716 |     | <span class='neutral'></span>
 1717 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.</span>
 1718 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;</span>
 1719 |     | <span class='neutral'></span>
 1720 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.</span>
 1721 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;</span>
 1722 |     | <span class='neutral'></span>
 1723 |     | <span class='neutral'>    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).</span>
 1724 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 1725 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).</span>
 1726 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;</span>
 1727 |     | <span class='neutral'></span>
 1728 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 1729 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)</span>
 1730 |     | <span class='neutral'>        external;</span>
 1731 |     | <span class='neutral'></span>
 1732 |     | <span class='neutral'>    /// Prepare an expected log with all topic and data checks enabled.</span>
 1733 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 1734 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data.</span>
 1735 |     | <span class='neutral'>    function expectEmit() external;</span>
 1736 |     | <span class='neutral'></span>
 1737 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 1738 |     | <span class='neutral'>    function expectEmit(address emitter) external;</span>
 1739 |     | <span class='neutral'></span>
 1740 |     | <span class='neutral'>    /// Expects an error on next call with any revert data.</span>
 1741 |     | <span class='neutral'>    function expectRevert() external;</span>
 1742 |     | <span class='neutral'></span>
 1743 |     | <span class='neutral'>    /// Expects an error on next call that starts with the revert data.</span>
 1744 |     | <span class='neutral'>    function expectRevert(bytes4 revertData) external;</span>
 1745 |     | <span class='neutral'></span>
 1746 |     | <span class='neutral'>    /// Expects an error on next call that exactly matches the revert data.</span>
 1747 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData) external;</span>
 1748 |     | <span class='neutral'></span>
 1749 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other</span>
 1750 |     | <span class='neutral'>    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.</span>
 1751 |     | <span class='neutral'>    function expectSafeMemory(uint64 min, uint64 max) external;</span>
 1752 |     | <span class='neutral'></span>
 1753 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.</span>
 1754 |     | <span class='neutral'>    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges</span>
 1755 |     | <span class='neutral'>    /// to the set.</span>
 1756 |     | <span class='neutral'>    function expectSafeMemoryCall(uint64 min, uint64 max) external;</span>
 1757 |     | <span class='neutral'></span>
 1758 |     | <span class='neutral'>    /// Marks a test as skipped. Must be called at the top of the test.</span>
 1759 |     | <span class='neutral'>    function skip(bool skipTest) external;</span>
 1760 |     | <span class='neutral'></span>
 1761 |     | <span class='neutral'>    /// Stops all safe memory expectation in the current subcontext.</span>
 1762 |     | <span class='neutral'>    function stopExpectSafeMemory() external;</span>
 1763 |     | <span class='neutral'>}</span>
 1764 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>library console {</span>
    5 | *   | <span class='executed'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>    function _castLogPayloadViewToPure(</span>
    8 |     | <span class='neutral'>        function(bytes memory) internal view fnIn</span>
    9 |     | <span class='neutral'>    ) internal pure returns (function(bytes memory) internal pure fnOut) {</span>
   10 |     | <span class='neutral'>        assembly {</span>
   11 |     | <span class='neutral'>            fnOut := fnIn</span>
   12 |     | <span class='neutral'>        }</span>
   13 |     | <span class='neutral'>    }</span>
   14 |     | <span class='neutral'></span>
   15 | *   | <span class='executed'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
   16 | *   | <span class='executed'>        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);</span>
   17 |     | <span class='neutral'>    }</span>
   18 |     | <span class='neutral'></span>
   19 | *   | <span class='executed'>    function _sendLogPayloadView(bytes memory payload) private view {</span>
   20 | *   | <span class='executed'>        uint256 payloadLength = payload.length;</span>
   21 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   22 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   23 | *   | <span class='executed'>        assembly {</span>
   24 | *   | <span class='executed'>            let payloadStart := add(payload, 32)</span>
   25 | *   | <span class='executed'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   26 |     | <span class='neutral'>        }</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function log() internal pure {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 | *   | <span class='executed'>    function logInt(int p0) internal pure {</span>
   34 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logUint(uint p0) internal pure {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logString(string memory p0) internal pure {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBool(bool p0) internal pure {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logAddress(address p0) internal pure {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal pure {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal pure {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal pure {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal pure {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal pure {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal pure {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal pure {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal pure {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal pure {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal pure {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal pure {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal pure {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal pure {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal pure {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal pure {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal pure {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal pure {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal pure {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal pure {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal pure {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal pure {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal pure {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal pure {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal pure {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal pure {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal pure {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal pure {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal pure {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal pure {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal pure {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal pure {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal pure {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 | *   | <span class='executed'>    function logBytes32(bytes32 p0) internal pure {</span>
  182 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(uint p0) internal pure {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(int p0) internal pure {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 | *   | <span class='executed'>    function log(string memory p0) internal pure {</span>
  194 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    function log(uint p0, uint p1) internal pure {</span>
  206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal pure {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(uint p0, bool p1) internal pure {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(uint p0, address p1) internal pure {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 | *   | <span class='executed'>    function log(string memory p0, uint p1) internal pure {</span>
  222 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 | *   | <span class='executed'>    function log(string memory p0, int p1) internal pure {</span>
  226 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,int)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal pure {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 | *   | <span class='executed'>    function log(string memory p0, bool p1) internal pure {</span>
  234 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 | *   | <span class='executed'>    function log(string memory p0, address p1) internal pure {</span>
  238 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(bool p0, uint p1) internal pure {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal pure {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(address p0, uint p1) internal pure {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(address p0, string memory p1) internal pure {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2) internal pure {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal pure {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal pure {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal pure {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal pure {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal pure {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal pure {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal pure {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal pure {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal pure {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal pure {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal pure {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal pure {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal pure {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal pure {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal pure {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2) internal pure {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal pure {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal pure {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal pure {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal pure {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal pure {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal pure {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal pure {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal pure {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal pure {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal pure {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal pure {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal pure {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal pure {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal pure {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal pure {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal pure {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal pure {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal pure {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal pure {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal pure {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal pure {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal pure {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal pure {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal pure {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal pure {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal pure {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal pure {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal pure {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal pure {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal pure {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal pure {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal pure {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal pure {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal pure {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal pure {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal pure {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal pure {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal pure {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal pure {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal pure {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal pure {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal pure {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal pure {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal pure {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal pure {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal pure {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal pure {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal pure {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal pure {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal pure {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal pure {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal pure {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal pure {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal pure {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal pure {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal pure {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal pure {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal pure {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal pure {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal pure {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal pure {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal pure {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal pure {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal pure {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal pure {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal pure {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal pure {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal pure {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal pure {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal pure {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal pure {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal pure {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal pure {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal pure {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal pure {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal pure {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal pure {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal pure {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal pure {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal pure {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal pure {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal pure {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal pure {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal pure {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal pure {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal pure {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal pure {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal pure {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal pure {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal pure {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal pure {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal pure {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal pure {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal pure {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal pure {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal pure {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal pure {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal pure {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal pure {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal pure {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal pure {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal pure {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal pure {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal pure {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal pure {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal pure {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal pure {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal pure {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal pure {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal pure {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal pure {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal pure {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal pure {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal pure {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal pure {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal pure {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal pure {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal pure {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal pure {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal pure {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal pure {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal pure {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal pure {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal pure {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal pure {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal pure {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal pure {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal pure {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal pure {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal pure {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal pure {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal pure {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal pure {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal pure {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal pure {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal pure {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal pure {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal pure {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal pure {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal pure {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal pure {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal pure {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal pure {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal pure {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal pure {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal pure {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal pure {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal pure {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal pure {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal pure {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal pure {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal pure {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal pure {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal pure {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal pure {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal pure {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal pure {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal pure {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal pure {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal pure {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal pure {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal pure {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal pure {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal pure {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal pure {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal pure {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal pure {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal pure {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal pure {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal pure {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal pure {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal pure {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal pure {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal pure {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal pure {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal pure {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal pure {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal pure {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal pure {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal pure {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal pure {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal pure {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal pure {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal pure {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal pure {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal pure {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal pure {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal pure {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal pure {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal pure {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal pure {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal pure {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal pure {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal pure {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal pure {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal pure {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal pure {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal pure {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal pure {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal pure {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal pure {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal pure {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal pure {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal pure {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal pure {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal pure {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal pure {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal pure {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal pure {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal pure {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal pure {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal pure {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal pure {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal pure {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal pure {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal pure {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal pure {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal pure {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal pure {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal pure {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal pure {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal pure {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal pure {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal pure {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal pure {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal pure {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal pure {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal pure {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal pure {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal pure {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal pure {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal pure {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal pure {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal pure {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal pure {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal pure {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
 1534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1535 |     | <span class='neutral'>    }</span>
 1536 |     | <span class='neutral'></span>
 1537 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal pure {</span>
 1538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1539 |     | <span class='neutral'>    }</span>
 1540 |     | <span class='neutral'></span>
 1541 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal pure {</span>
 1542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1543 |     | <span class='neutral'>    }</span>
 1544 |     | <span class='neutral'></span>
 1545 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
 1546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1547 |     | <span class='neutral'>    }</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
 1550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1551 |     | <span class='neutral'>    }</span>
 1552 |     | <span class='neutral'>}</span>
 1553 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/console2.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {console as console2} from &quot;./console.sol&quot;;</span>
 5 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC165 {</span>
  5 |     | <span class='neutral'>    /// @notice Query if a contract implements an interface</span>
  6 |     | <span class='neutral'>    /// @param interfaceID The interface identifier, as specified in ERC-165</span>
  7 |     | <span class='neutral'>    /// @dev Interface identification is specified in ERC-165. This function</span>
  8 |     | <span class='neutral'>    /// uses less than 30,000 gas.</span>
  9 |     | <span class='neutral'>    /// @return `true` if the contract implements `interfaceID` and</span>
 10 |     | <span class='neutral'>    /// `interfaceID` is not 0xffffffff, `false` otherwise</span>
 11 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @dev Interface of the ERC20 standard as defined in the EIP.</span>
  5 |     | <span class='neutral'>/// @dev This includes the optional name, symbol, and decimals metadata.</span>
  6 |     | <span class='neutral'>interface IERC20 {</span>
  7 |     | <span class='neutral'>    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).</span>
  8 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`</span>
 11 |     | <span class='neutral'>    /// is the new allowance.</span>
 12 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Returns the amount of tokens in existence.</span>
 15 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @notice Returns the amount of tokens owned by `account`.</span>
 18 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 21 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns the remaining number of tokens that `spender` is allowed</span>
 24 |     | <span class='neutral'>    /// to spend on behalf of `owner`</span>
 25 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @notice Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 28 |     | <span class='neutral'>    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 29 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.</span>
 32 |     | <span class='neutral'>    /// `amount` is then deducted from the caller&#39;s allowance.</span>
 33 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @notice Returns the name of the token.</span>
 36 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    /// @notice Returns the symbol of the token.</span>
 39 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Returns the decimals places of the token.</span>
 42 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard</span>
   7 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
   8 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.</span>
   9 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  10 |     | <span class='neutral'>    /// @dev This emits when ownership of any NFT changes by any mechanism.</span>
  11 |     | <span class='neutral'>    /// This event emits when NFTs are created (`from` == 0) and destroyed</span>
  12 |     | <span class='neutral'>    /// (`to` == 0). Exception: during contract creation, any number of NFTs</span>
  13 |     | <span class='neutral'>    /// may be created and assigned without emitting Transfer. At the time of</span>
  14 |     | <span class='neutral'>    /// any transfer, the approved address for that NFT (if any) is reset to none.</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @dev This emits when the approved address for an NFT is changed or</span>
  18 |     | <span class='neutral'>    /// reaffirmed. The zero address indicates there is no approved address.</span>
  19 |     | <span class='neutral'>    /// When a Transfer event emits, this also indicates that the approved</span>
  20 |     | <span class='neutral'>    /// address for that NFT (if any) is reset to none.</span>
  21 |     | <span class='neutral'>    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @dev This emits when an operator is enabled or disabled for an owner.</span>
  24 |     | <span class='neutral'>    /// The operator can manage all NFTs of the owner.</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice Count all NFTs assigned to an owner</span>
  28 |     | <span class='neutral'>    /// @dev NFTs assigned to the zero address are considered invalid, and this</span>
  29 |     | <span class='neutral'>    /// function throws for queries about the zero address.</span>
  30 |     | <span class='neutral'>    /// @param _owner An address for whom to query the balance</span>
  31 |     | <span class='neutral'>    /// @return The number of NFTs owned by `_owner`, possibly zero</span>
  32 |     | <span class='neutral'>    function balanceOf(address _owner) external view returns (uint256);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice Find the owner of an NFT</span>
  35 |     | <span class='neutral'>    /// @dev NFTs assigned to zero address are considered invalid, and queries</span>
  36 |     | <span class='neutral'>    /// about them do throw.</span>
  37 |     | <span class='neutral'>    /// @param _tokenId The identifier for an NFT</span>
  38 |     | <span class='neutral'>    /// @return The address of the owner of the NFT</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 _tokenId) external view returns (address);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Transfers the ownership of an NFT from one address to another address</span>
  42 |     | <span class='neutral'>    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span>
  43 |     | <span class='neutral'>    /// operator, or the approved address for this NFT. Throws if `_from` is</span>
  44 |     | <span class='neutral'>    /// not the current owner. Throws if `_to` is the zero address. Throws if</span>
  45 |     | <span class='neutral'>    /// `_tokenId` is not a valid NFT. When transfer is complete, this function</span>
  46 |     | <span class='neutral'>    /// checks if `_to` is a smart contract (code size &gt; 0). If so, it calls</span>
  47 |     | <span class='neutral'>    /// `onERC721Received` on `_to` and throws if the return value is not</span>
  48 |     | <span class='neutral'>    /// `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`.</span>
  49 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  50 |     | <span class='neutral'>    /// @param _to The new owner</span>
  51 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  52 |     | <span class='neutral'>    /// @param data Additional data with no specified format, sent in call to `_to`</span>
  53 |     | <span class='neutral'>    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice Transfers the ownership of an NFT from one address to another address</span>
  56 |     | <span class='neutral'>    /// @dev This works identically to the other function with an extra data parameter,</span>
  57 |     | <span class='neutral'>    /// except this function just sets data to &quot;&quot;.</span>
  58 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  59 |     | <span class='neutral'>    /// @param _to The new owner</span>
  60 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  61 |     | <span class='neutral'>    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE</span>
  64 |     | <span class='neutral'>    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE</span>
  65 |     | <span class='neutral'>    /// THEY MAY BE PERMANENTLY LOST</span>
  66 |     | <span class='neutral'>    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span>
  67 |     | <span class='neutral'>    /// operator, or the approved address for this NFT. Throws if `_from` is</span>
  68 |     | <span class='neutral'>    /// not the current owner. Throws if `_to` is the zero address. Throws if</span>
  69 |     | <span class='neutral'>    /// `_tokenId` is not a valid NFT.</span>
  70 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  71 |     | <span class='neutral'>    /// @param _to The new owner</span>
  72 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  73 |     | <span class='neutral'>    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /// @notice Change or reaffirm the approved address for an NFT</span>
  76 |     | <span class='neutral'>    /// @dev The zero address indicates there is no approved address.</span>
  77 |     | <span class='neutral'>    /// Throws unless `msg.sender` is the current NFT owner, or an authorized</span>
  78 |     | <span class='neutral'>    /// operator of the current owner.</span>
  79 |     | <span class='neutral'>    /// @param _approved The new approved NFT controller</span>
  80 |     | <span class='neutral'>    /// @param _tokenId The NFT to approve</span>
  81 |     | <span class='neutral'>    function approve(address _approved, uint256 _tokenId) external payable;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Enable or disable approval for a third party (&quot;operator&quot;) to manage</span>
  84 |     | <span class='neutral'>    /// all of `msg.sender`&#39;s assets</span>
  85 |     | <span class='neutral'>    /// @dev Emits the ApprovalForAll event. The contract MUST allow</span>
  86 |     | <span class='neutral'>    /// multiple operators per owner.</span>
  87 |     | <span class='neutral'>    /// @param _operator Address to add to the set of authorized operators</span>
  88 |     | <span class='neutral'>    /// @param _approved True if the operator is approved, false to revoke approval</span>
  89 |     | <span class='neutral'>    function setApprovalForAll(address _operator, bool _approved) external;</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /// @notice Get the approved address for a single NFT</span>
  92 |     | <span class='neutral'>    /// @dev Throws if `_tokenId` is not a valid NFT.</span>
  93 |     | <span class='neutral'>    /// @param _tokenId The NFT to find the approved address for</span>
  94 |     | <span class='neutral'>    /// @return The approved address for this NFT, or the zero address if there is none</span>
  95 |     | <span class='neutral'>    function getApproved(uint256 _tokenId) external view returns (address);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Query if an address is an authorized operator for another address</span>
  98 |     | <span class='neutral'>    /// @param _owner The address that owns the NFTs</span>
  99 |     | <span class='neutral'>    /// @param _operator The address that acts on behalf of the owner</span>
 100 |     | <span class='neutral'>    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise</span>
 101 |     | <span class='neutral'>    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span>
 102 |     | <span class='neutral'>}</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.</span>
 105 |     | <span class='neutral'>interface IERC721TokenReceiver {</span>
 106 |     | <span class='neutral'>    /// @notice Handle the receipt of an NFT</span>
 107 |     | <span class='neutral'>    /// @dev The ERC721 smart contract calls this function on the recipient</span>
 108 |     | <span class='neutral'>    /// after a `transfer`. This function MAY throw to revert and reject the</span>
 109 |     | <span class='neutral'>    /// transfer. Return of other than the magic value MUST result in the</span>
 110 |     | <span class='neutral'>    /// transaction being reverted.</span>
 111 |     | <span class='neutral'>    /// Note: the contract address is always the message sender.</span>
 112 |     | <span class='neutral'>    /// @param _operator The address which called `safeTransferFrom` function</span>
 113 |     | <span class='neutral'>    /// @param _from The address which previously owned the token</span>
 114 |     | <span class='neutral'>    /// @param _tokenId The NFT identifier which is being transferred</span>
 115 |     | <span class='neutral'>    /// @param _data Additional data with no specified format</span>
 116 |     | <span class='neutral'>    /// @return `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`</span>
 117 |     | <span class='neutral'>    ///  unless throwing</span>
 118 |     | <span class='neutral'>    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)</span>
 119 |     | <span class='neutral'>        external</span>
 120 |     | <span class='neutral'>        returns (bytes4);</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension</span>
 124 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 125 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.</span>
 126 |     | <span class='neutral'>interface IERC721Metadata is IERC721 {</span>
 127 |     | <span class='neutral'>    /// @notice A descriptive name for a collection of NFTs in this contract</span>
 128 |     | <span class='neutral'>    function name() external view returns (string memory _name);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @notice An abbreviated name for NFTs in this contract</span>
 131 |     | <span class='neutral'>    function symbol() external view returns (string memory _symbol);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.</span>
 134 |     | <span class='neutral'>    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC</span>
 135 |     | <span class='neutral'>    /// 3986. The URI may point to a JSON file that conforms to the &quot;ERC721</span>
 136 |     | <span class='neutral'>    /// Metadata JSON Schema&quot;.</span>
 137 |     | <span class='neutral'>    function tokenURI(uint256 _tokenId) external view returns (string memory);</span>
 138 |     | <span class='neutral'>}</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension</span>
 141 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 142 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x780e9d63.</span>
 143 |     | <span class='neutral'>interface IERC721Enumerable is IERC721 {</span>
 144 |     | <span class='neutral'>    /// @notice Count NFTs tracked by this contract</span>
 145 |     | <span class='neutral'>    /// @return A count of valid NFTs tracked by this contract, where each one of</span>
 146 |     | <span class='neutral'>    /// them has an assigned and queryable owner not equal to the zero address</span>
 147 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice Enumerate valid NFTs</span>
 150 |     | <span class='neutral'>    /// @dev Throws if `_index` &gt;= `totalSupply()`.</span>
 151 |     | <span class='neutral'>    /// @param _index A counter less than `totalSupply()`</span>
 152 |     | <span class='neutral'>    /// @return The token identifier for the `_index`th NFT,</span>
 153 |     | <span class='neutral'>    /// (sort order not specified)</span>
 154 |     | <span class='neutral'>    function tokenByIndex(uint256 _index) external view returns (uint256);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /// @notice Enumerate NFTs assigned to an owner</span>
 157 |     | <span class='neutral'>    /// @dev Throws if `_index` &gt;= `balanceOf(_owner)` or if</span>
 158 |     | <span class='neutral'>    /// `_owner` is the zero address, representing invalid NFTs.</span>
 159 |     | <span class='neutral'>    /// @param _owner An address where we are interested in NFTs owned by them</span>
 160 |     | <span class='neutral'>    /// @param _index A counter less than `balanceOf(_owner)`</span>
 161 |     | <span class='neutral'>    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,</span>
 162 |     | <span class='neutral'>    /// (sort order not specified)</span>
 163 |     | <span class='neutral'>    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);</span>
 164 |     | <span class='neutral'>}</span>
 165 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IMulticall3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IMulticall3 {</span>
  7 |     | <span class='neutral'>    struct Call {</span>
  8 |     | <span class='neutral'>        address target;</span>
  9 |     | <span class='neutral'>        bytes callData;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct Call3 {</span>
 13 |     | <span class='neutral'>        address target;</span>
 14 |     | <span class='neutral'>        bool allowFailure;</span>
 15 |     | <span class='neutral'>        bytes callData;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct Call3Value {</span>
 19 |     | <span class='neutral'>        address target;</span>
 20 |     | <span class='neutral'>        bool allowFailure;</span>
 21 |     | <span class='neutral'>        uint256 value;</span>
 22 |     | <span class='neutral'>        bytes callData;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    struct Result {</span>
 26 |     | <span class='neutral'>        bool success;</span>
 27 |     | <span class='neutral'>        bytes returnData;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function aggregate(Call[] calldata calls)</span>
 31 |     | <span class='neutral'>        external</span>
 32 |     | <span class='neutral'>        payable</span>
 33 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes[] memory returnData);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function blockAndAggregate(Call[] calldata calls)</span>
 40 |     | <span class='neutral'>        external</span>
 41 |     | <span class='neutral'>        payable</span>
 42 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function getBasefee() external view returns (uint256 basefee);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 blockNumber);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function getChainId() external view returns (uint256 chainid);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function getCurrentBlockCoinbase() external view returns (address coinbase);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function getEthBalance(address addr) external view returns (uint256 balance);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function getLastBlockHash() external view returns (bytes32 blockHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function tryAggregate(bool requireSuccess, Call[] calldata calls)</span>
 65 |     | <span class='neutral'>        external</span>
 66 |     | <span class='neutral'>        payable</span>
 67 |     | <span class='neutral'>        returns (Result[] memory returnData);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)</span>
 70 |     | <span class='neutral'>        external</span>
 71 |     | <span class='neutral'>        payable</span>
 72 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/mocks/MockERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;../interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.</span>
   7 |     | <span class='neutral'>/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol</span>
   8 |     | <span class='unexecuted'>contract MockERC20 is IERC20 {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                            METADATA STORAGE</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    string internal _name;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string internal _symbol;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    uint8 internal _decimals;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    function name() external view override returns (string memory) {</span>
  20 |     | <span class='unexecuted'>        return _name;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function symbol() external view override returns (string memory) {</span>
  24 |     | <span class='unexecuted'>        return _symbol;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    function decimals() external view override returns (uint8) {</span>
  28 |     | <span class='unexecuted'>        return _decimals;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  32 |     | <span class='neutral'>                              ERC20 STORAGE</span>
  33 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    uint256 internal _totalSupply;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _balanceOf;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) internal _allowance;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function totalSupply() external view override returns (uint256) {</span>
  42 |     | <span class='unexecuted'>        return _totalSupply;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function balanceOf(address owner) external view override returns (uint256) {</span>
  46 |     | <span class='unexecuted'>        return _balanceOf[owner];</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function allowance(address owner, address spender) external view override returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        return _allowance[owner][spender];</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  54 |     | <span class='neutral'>                            EIP-2612 STORAGE</span>
  55 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    uint256 internal INITIAL_CHAIN_ID;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    bytes32 internal INITIAL_DOMAIN_SEPARATOR;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  64 |     | <span class='neutral'>                               INITIALIZE</span>
  65 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @dev A bool to track whether the contract has been initialized.</span>
  68 |     | <span class='neutral'>    bool private initialized;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  71 |     | <span class='neutral'>    /// syntaxes, we add an initialization function that can be called only once.</span>
  72 |     | <span class='unexecuted'>    function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {</span>
  73 |     | <span class='unexecuted'>        require(!initialized, &quot;ALREADY_INITIALIZED&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        _name = name_;</span>
  76 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  77 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        INITIAL_CHAIN_ID = _pureChainId();</span>
  80 |     | <span class='unexecuted'>        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        initialized = true;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  86 |     | <span class='neutral'>                               ERC20 LOGIC</span>
  87 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
  90 |     | <span class='unexecuted'>        _allowance[msg.sender][spender] = amount;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        return true;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
  98 |     | <span class='unexecuted'>        _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);</span>
  99 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        return true;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 107 |     | <span class='unexecuted'>        uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 112 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 120 |     | <span class='neutral'>                             EIP-2612 LOGIC</span>
 121 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 124 |     | <span class='neutral'>        public</span>
 125 |     | <span class='neutral'>        virtual</span>
 126 |     | <span class='unexecuted'>    {</span>
 127 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(</span>
 130 |     | <span class='unexecuted'>            keccak256(</span>
 131 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 132 |     | <span class='neutral'>                    &quot;\x19\x01&quot;,</span>
 133 |     | <span class='unexecuted'>                    DOMAIN_SEPARATOR(),</span>
 134 |     | <span class='unexecuted'>                    keccak256(</span>
 135 |     | <span class='unexecuted'>                        abi.encode(</span>
 136 |     | <span class='unexecuted'>                            keccak256(</span>
 137 |     | <span class='neutral'>                                &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
 138 |     | <span class='neutral'>                            ),</span>
 139 |     | <span class='unexecuted'>                            owner,</span>
 140 |     | <span class='unexecuted'>                            spender,</span>
 141 |     | <span class='unexecuted'>                            value,</span>
 142 |     | <span class='unexecuted'>                            nonces[owner]++,</span>
 143 |     | <span class='neutral'>                            deadline</span>
 144 |     | <span class='neutral'>                        )</span>
 145 |     | <span class='neutral'>                    )</span>
 146 |     | <span class='neutral'>                )</span>
 147 |     | <span class='neutral'>            ),</span>
 148 |     | <span class='neutral'>            v,</span>
 149 |     | <span class='neutral'>            r,</span>
 150 |     | <span class='neutral'>            s</span>
 151 |     | <span class='neutral'>        );</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;INVALID_SIGNER&quot;);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>        _allowance[recoveredAddress][spender] = value;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {</span>
 161 |     | <span class='unexecuted'>        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function computeDomainSeparator() internal view virtual returns (bytes32) {</span>
 165 |     | <span class='unexecuted'>        return keccak256(</span>
 166 |     | <span class='unexecuted'>            abi.encode(</span>
 167 |     | <span class='unexecuted'>                keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 168 |     | <span class='unexecuted'>                keccak256(bytes(_name)),</span>
 169 |     | <span class='unexecuted'>                keccak256(&quot;1&quot;),</span>
 170 |     | <span class='unexecuted'>                _pureChainId(),</span>
 171 |     | <span class='unexecuted'>                address(this)</span>
 172 |     | <span class='neutral'>            )</span>
 173 |     | <span class='neutral'>        );</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 177 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 178 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function _mint(address to, uint256 amount) internal virtual {</span>
 181 |     | <span class='neutral'>        _totalSupply = _add(_totalSupply, amount);</span>
 182 |     | <span class='neutral'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        emit Transfer(address(0), to, amount);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function _burn(address from, uint256 amount) internal virtual {</span>
 188 |     | <span class='neutral'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 189 |     | <span class='neutral'>        _totalSupply = _sub(_totalSupply, amount);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        emit Transfer(from, address(0), amount);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 195 |     | <span class='neutral'>                        INTERNAL SAFE MATH LOGIC</span>
 196 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function _add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 199 |     | <span class='unexecuted'>        uint256 c = a + b;</span>
 200 |     | <span class='unexecuted'>        require(c &gt;= a, &quot;ERC20: addition overflow&quot;);</span>
 201 |     | <span class='neutral'>        return c;</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 205 |     | <span class='unexecuted'>        require(a &gt;= b, &quot;ERC20: subtraction underflow&quot;);</span>
 206 |     | <span class='unexecuted'>        return a - b;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 210 |     | <span class='neutral'>                                HELPERS</span>
 211 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 214 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 215 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 216 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 217 |     | <span class='unexecuted'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 218 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 219 |     | <span class='neutral'>        assembly {</span>
 220 |     | <span class='unexecuted'>            chainId := chainid()</span>
 221 |     | <span class='neutral'>        }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 227 |     | <span class='unexecuted'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 228 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 229 |     | <span class='neutral'>        assembly {</span>
 230 |     | <span class='neutral'>            pureChainId := fnIn</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='unexecuted'>        chainId = pureChainId();</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'>}</span>
 235 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/mocks/MockERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC721Metadata, IERC721TokenReceiver} from &quot;../interfaces/IERC721.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.</span>
   7 |     | <span class='neutral'>/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol</span>
   8 |     | <span class='unexecuted'>contract MockERC721 is IERC721Metadata {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                         METADATA STORAGE/LOGIC</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    string internal _name;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string internal _symbol;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    function name() external view override returns (string memory) {</span>
  18 |     | <span class='unexecuted'>        return _name;</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function symbol() external view override returns (string memory) {</span>
  22 |     | <span class='unexecuted'>        return _symbol;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function tokenURI(uint256 id) public view virtual override returns (string memory) {}</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                      ERC721 BALANCE/OWNER STORAGE</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _ownerOf;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _balanceOf;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function ownerOf(uint256 id) public view virtual override returns (address owner) {</span>
  36 |     | <span class='unexecuted'>        require((owner = _ownerOf[id]) != address(0), &quot;NOT_MINTED&quot;);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  40 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ZERO_ADDRESS&quot;);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        return _balanceOf[owner];</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  46 |     | <span class='neutral'>                         ERC721 APPROVAL STORAGE</span>
  47 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _getApproved;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) internal _isApprovedForAll;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function getApproved(uint256 id) public view virtual override returns (address) {</span>
  54 |     | <span class='unexecuted'>        return _getApproved[id];</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
  58 |     | <span class='unexecuted'>        return _isApprovedForAll[owner][operator];</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  62 |     | <span class='neutral'>                               INITIALIZE</span>
  63 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @dev A bool to track whether the contract has been initialized.</span>
  66 |     | <span class='neutral'>    bool private initialized;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  69 |     | <span class='neutral'>    /// syntaxes, we add an initialization function that can be called only once.</span>
  70 |     | <span class='unexecuted'>    function initialize(string memory name_, string memory symbol_) public {</span>
  71 |     | <span class='unexecuted'>        require(!initialized, &quot;ALREADY_INITIALIZED&quot;);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        _name = name_;</span>
  74 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        initialized = true;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>                              ERC721 LOGIC</span>
  81 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function approve(address spender, uint256 id) public payable virtual override {</span>
  84 |     | <span class='unexecuted'>        address owner = _ownerOf[id];</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], &quot;NOT_AUTHORIZED&quot;);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        _getApproved[id] = spender;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        emit Approval(owner, spender, id);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
  94 |     | <span class='unexecuted'>        _isApprovedForAll[msg.sender][operator] = approved;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        emit ApprovalForAll(msg.sender, operator, approved);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 id) public payable virtual override {</span>
 100 |     | <span class='unexecuted'>        require(from == _ownerOf[id], &quot;WRONG_FROM&quot;);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        require(to != address(0), &quot;INVALID_RECIPIENT&quot;);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        require(</span>
 105 |     | <span class='unexecuted'>            msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],</span>
 106 |     | <span class='neutral'>            &quot;NOT_AUTHORIZED&quot;</span>
 107 |     | <span class='neutral'>        );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Underflow of the sender&#39;s balance is impossible because we check for</span>
 110 |     | <span class='neutral'>        // ownership above and the recipient&#39;s balance can&#39;t realistically overflow.</span>
 111 |     | <span class='unexecuted'>        _balanceOf[from]--;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        _balanceOf[to]++;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        _ownerOf[id] = to;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        delete _getApproved[id];</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        emit Transfer(from, to, id);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {</span>
 123 |     | <span class='unexecuted'>        transferFrom(from, to, id);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        require(</span>
 126 |     | <span class='unexecuted'>            !_isContract(to)</span>
 127 |     | <span class='unexecuted'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, &quot;&quot;)</span>
 128 |     | <span class='unexecuted'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 129 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 130 |     | <span class='neutral'>        );</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 id, bytes memory data)</span>
 134 |     | <span class='neutral'>        public</span>
 135 |     | <span class='neutral'>        payable</span>
 136 |     | <span class='neutral'>        virtual</span>
 137 |     | <span class='neutral'>        override</span>
 138 |     | <span class='neutral'>    {</span>
 139 |     | <span class='unexecuted'>        transferFrom(from, to, id);</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        require(</span>
 142 |     | <span class='unexecuted'>            !_isContract(to)</span>
 143 |     | <span class='unexecuted'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)</span>
 144 |     | <span class='unexecuted'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 145 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 150 |     | <span class='neutral'>                              ERC165 LOGIC</span>
 151 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 154 |     | <span class='unexecuted'>        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165</span>
 155 |     | <span class='unexecuted'>            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721</span>
 156 |     | <span class='unexecuted'>            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 160 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 161 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function _mint(address to, uint256 id) internal virtual {</span>
 164 |     | <span class='neutral'>        require(to != address(0), &quot;INVALID_RECIPIENT&quot;);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        require(_ownerOf[id] == address(0), &quot;ALREADY_MINTED&quot;);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>        // Counter overflow is incredibly unrealistic.</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        _balanceOf[to]++;</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>        _ownerOf[id] = to;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        emit Transfer(address(0), to, id);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    function _burn(uint256 id) internal virtual {</span>
 178 |     | <span class='neutral'>        address owner = _ownerOf[id];</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        require(owner != address(0), &quot;NOT_MINTED&quot;);</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        _balanceOf[owner]--;</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        delete _ownerOf[id];</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        delete _getApproved[id];</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        emit Transfer(owner, address(0), id);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 192 |     | <span class='neutral'>                        INTERNAL SAFE MINT LOGIC</span>
 193 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function _safeMint(address to, uint256 id) internal virtual {</span>
 196 |     | <span class='neutral'>        _mint(to, id);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        require(</span>
 199 |     | <span class='neutral'>            !_isContract(to)</span>
 200 |     | <span class='neutral'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, &quot;&quot;)</span>
 201 |     | <span class='neutral'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 202 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 203 |     | <span class='neutral'>        );</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {</span>
 207 |     | <span class='neutral'>        _mint(to, id);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        require(</span>
 210 |     | <span class='neutral'>            !_isContract(to)</span>
 211 |     | <span class='neutral'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)</span>
 212 |     | <span class='neutral'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 213 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 214 |     | <span class='neutral'>        );</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 218 |     | <span class='neutral'>                                HELPERS</span>
 219 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    function _isContract(address _addr) private view returns (bool) {</span>
 222 |     | <span class='neutral'>        uint256 codeLength;</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // Assembly required for versions &lt; 0.8.0 to check extcodesize.</span>
 225 |     | <span class='neutral'>        assembly {</span>
 226 |     | <span class='unexecuted'>            codeLength := extcodesize(_addr)</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        return codeLength &gt; 0;</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'>}</span>
 232 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/safeconsole.sol</b>
<code>
     1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
     2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
     3 |     | <span class='neutral'></span>
     4 |     | <span class='neutral'>/// @author philogy &lt;https://github.com/philogy&gt;</span>
     5 |     | <span class='neutral'>/// @dev Code generated automatically by script.</span>
     6 |     | <span class='unexecuted'>library safeconsole {</span>
     7 |     | <span class='neutral'>    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;</span>
     8 |     | <span class='neutral'></span>
     9 |     | <span class='neutral'>    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)</span>
    10 |     | <span class='neutral'>    // for the view-to-pure log trick.</span>
    11 |     | <span class='neutral'>    function _sendLogPayload(uint256 offset, uint256 size) private pure {</span>
    12 |     | <span class='neutral'>        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;</span>
    13 |     | <span class='neutral'>        function(uint256, uint256) internal pure pureSendLogPayload;</span>
    14 |     | <span class='neutral'>        assembly {</span>
    15 |     | <span class='neutral'>            pureSendLogPayload := fnIn</span>
    16 |     | <span class='neutral'>        }</span>
    17 |     | <span class='neutral'>        pureSendLogPayload(offset, size);</span>
    18 |     | <span class='neutral'>    }</span>
    19 |     | <span class='neutral'></span>
    20 |     | <span class='neutral'>    function _sendLogPayloadView(uint256 offset, uint256 size) private view {</span>
    21 |     | <span class='neutral'>        assembly {</span>
    22 |     | <span class='neutral'>            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))</span>
    23 |     | <span class='neutral'>        }</span>
    24 |     | <span class='neutral'>    }</span>
    25 |     | <span class='neutral'></span>
    26 |     | <span class='neutral'>    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {</span>
    27 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;</span>
    28 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal pure pureMemcopy;</span>
    29 |     | <span class='neutral'>        assembly {</span>
    30 |     | <span class='neutral'>            pureMemcopy := fnIn</span>
    31 |     | <span class='neutral'>        }</span>
    32 |     | <span class='neutral'>        pureMemcopy(fromOffset, toOffset, length);</span>
    33 |     | <span class='neutral'>    }</span>
    34 |     | <span class='neutral'></span>
    35 |     | <span class='neutral'>    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {</span>
    36 |     | <span class='neutral'>        assembly {</span>
    37 |     | <span class='neutral'>            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))</span>
    38 |     | <span class='neutral'>        }</span>
    39 |     | <span class='neutral'>    }</span>
    40 |     | <span class='neutral'></span>
    41 |     | <span class='neutral'>    function logMemory(uint256 offset, uint256 length) internal pure {</span>
    42 |     | <span class='neutral'>        if (offset &gt;= 0x60) {</span>
    43 |     | <span class='neutral'>            // Sufficient memory before slice to prepare call header.</span>
    44 |     | <span class='neutral'>            bytes32 m0;</span>
    45 |     | <span class='neutral'>            bytes32 m1;</span>
    46 |     | <span class='neutral'>            bytes32 m2;</span>
    47 |     | <span class='neutral'>            assembly {</span>
    48 |     | <span class='neutral'>                m0 := mload(sub(offset, 0x60))</span>
    49 |     | <span class='neutral'>                m1 := mload(sub(offset, 0x40))</span>
    50 |     | <span class='neutral'>                m2 := mload(sub(offset, 0x20))</span>
    51 |     | <span class='neutral'>                // Selector of `logBytes(bytes)`.</span>
    52 |     | <span class='neutral'>                mstore(sub(offset, 0x60), 0xe17bf956)</span>
    53 |     | <span class='neutral'>                mstore(sub(offset, 0x40), 0x20)</span>
    54 |     | <span class='neutral'>                mstore(sub(offset, 0x20), length)</span>
    55 |     | <span class='neutral'>            }</span>
    56 |     | <span class='neutral'>            _sendLogPayload(offset - 0x44, length + 0x44);</span>
    57 |     | <span class='neutral'>            assembly {</span>
    58 |     | <span class='neutral'>                mstore(sub(offset, 0x60), m0)</span>
    59 |     | <span class='neutral'>                mstore(sub(offset, 0x40), m1)</span>
    60 |     | <span class='neutral'>                mstore(sub(offset, 0x20), m2)</span>
    61 |     | <span class='neutral'>            }</span>
    62 |     | <span class='neutral'>        } else {</span>
    63 |     | <span class='neutral'>            // Insufficient space, so copy slice forward, add header and reverse.</span>
    64 |     | <span class='neutral'>            bytes32 m0;</span>
    65 |     | <span class='neutral'>            bytes32 m1;</span>
    66 |     | <span class='neutral'>            bytes32 m2;</span>
    67 |     | <span class='neutral'>            uint256 endOffset = offset + length;</span>
    68 |     | <span class='neutral'>            assembly {</span>
    69 |     | <span class='neutral'>                m0 := mload(add(endOffset, 0x00))</span>
    70 |     | <span class='neutral'>                m1 := mload(add(endOffset, 0x20))</span>
    71 |     | <span class='neutral'>                m2 := mload(add(endOffset, 0x40))</span>
    72 |     | <span class='neutral'>            }</span>
    73 |     | <span class='neutral'>            _memcopy(offset, offset + 0x60, length);</span>
    74 |     | <span class='neutral'>            assembly {</span>
    75 |     | <span class='neutral'>                // Selector of `logBytes(bytes)`.</span>
    76 |     | <span class='neutral'>                mstore(add(offset, 0x00), 0xe17bf956)</span>
    77 |     | <span class='neutral'>                mstore(add(offset, 0x20), 0x20)</span>
    78 |     | <span class='neutral'>                mstore(add(offset, 0x40), length)</span>
    79 |     | <span class='neutral'>            }</span>
    80 |     | <span class='neutral'>            _sendLogPayload(offset + 0x1c, length + 0x44);</span>
    81 |     | <span class='neutral'>            _memcopy(offset + 0x60, offset, length);</span>
    82 |     | <span class='neutral'>            assembly {</span>
    83 |     | <span class='neutral'>                mstore(add(endOffset, 0x00), m0)</span>
    84 |     | <span class='neutral'>                mstore(add(endOffset, 0x20), m1)</span>
    85 |     | <span class='neutral'>                mstore(add(endOffset, 0x40), m2)</span>
    86 |     | <span class='neutral'>            }</span>
    87 |     | <span class='neutral'>        }</span>
    88 |     | <span class='neutral'>    }</span>
    89 |     | <span class='neutral'></span>
    90 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
    91 |     | <span class='neutral'>        bytes32 m0;</span>
    92 |     | <span class='neutral'>        bytes32 m1;</span>
    93 |     | <span class='neutral'>        assembly {</span>
    94 |     | <span class='neutral'>            m0 := mload(0x00)</span>
    95 |     | <span class='neutral'>            m1 := mload(0x20)</span>
    96 |     | <span class='neutral'>            // Selector of `log(address)`.</span>
    97 |     | <span class='neutral'>            mstore(0x00, 0x2c2ecbc2)</span>
    98 |     | <span class='neutral'>            mstore(0x20, p0)</span>
    99 |     | <span class='neutral'>        }</span>
   100 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   101 |     | <span class='neutral'>        assembly {</span>
   102 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   103 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   104 |     | <span class='neutral'>        }</span>
   105 |     | <span class='neutral'>    }</span>
   106 |     | <span class='neutral'></span>
   107 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
   108 |     | <span class='neutral'>        bytes32 m0;</span>
   109 |     | <span class='neutral'>        bytes32 m1;</span>
   110 |     | <span class='neutral'>        assembly {</span>
   111 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   112 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   113 |     | <span class='neutral'>            // Selector of `log(bool)`.</span>
   114 |     | <span class='neutral'>            mstore(0x00, 0x32458eed)</span>
   115 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   116 |     | <span class='neutral'>        }</span>
   117 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   118 |     | <span class='neutral'>        assembly {</span>
   119 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   120 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   121 |     | <span class='neutral'>        }</span>
   122 |     | <span class='neutral'>    }</span>
   123 |     | <span class='neutral'></span>
   124 |     | <span class='neutral'>    function log(uint256 p0) internal pure {</span>
   125 |     | <span class='neutral'>        bytes32 m0;</span>
   126 |     | <span class='neutral'>        bytes32 m1;</span>
   127 |     | <span class='neutral'>        assembly {</span>
   128 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   129 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   130 |     | <span class='neutral'>            // Selector of `log(uint256)`.</span>
   131 |     | <span class='neutral'>            mstore(0x00, 0xf82c50f1)</span>
   132 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   133 |     | <span class='neutral'>        }</span>
   134 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   135 |     | <span class='neutral'>        assembly {</span>
   136 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   137 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   138 |     | <span class='neutral'>        }</span>
   139 |     | <span class='neutral'>    }</span>
   140 |     | <span class='neutral'></span>
   141 |     | <span class='neutral'>    function log(bytes32 p0) internal pure {</span>
   142 |     | <span class='neutral'>        bytes32 m0;</span>
   143 |     | <span class='neutral'>        bytes32 m1;</span>
   144 |     | <span class='neutral'>        bytes32 m2;</span>
   145 |     | <span class='neutral'>        bytes32 m3;</span>
   146 |     | <span class='neutral'>        assembly {</span>
   147 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   148 |     | <span class='neutral'>                let length := 0</span>
   149 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   150 |     | <span class='neutral'>                mstore(pos, length)</span>
   151 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   152 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   153 |     | <span class='neutral'>            }</span>
   154 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   155 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   156 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   157 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   158 |     | <span class='neutral'>            // Selector of `log(string)`.</span>
   159 |     | <span class='neutral'>            mstore(0x00, 0x41304fac)</span>
   160 |     | <span class='neutral'>            mstore(0x20, 0x20)</span>
   161 |     | <span class='neutral'>            writeString(0x40, p0)</span>
   162 |     | <span class='neutral'>        }</span>
   163 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   164 |     | <span class='neutral'>        assembly {</span>
   165 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   166 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   167 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   168 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   169 |     | <span class='neutral'>        }</span>
   170 |     | <span class='neutral'>    }</span>
   171 |     | <span class='neutral'></span>
   172 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
   173 |     | <span class='neutral'>        bytes32 m0;</span>
   174 |     | <span class='neutral'>        bytes32 m1;</span>
   175 |     | <span class='neutral'>        bytes32 m2;</span>
   176 |     | <span class='neutral'>        assembly {</span>
   177 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   178 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   179 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   180 |     | <span class='neutral'>            // Selector of `log(address,address)`.</span>
   181 |     | <span class='neutral'>            mstore(0x00, 0xdaf0d4aa)</span>
   182 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   183 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   184 |     | <span class='neutral'>        }</span>
   185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   186 |     | <span class='neutral'>        assembly {</span>
   187 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   188 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   189 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   190 |     | <span class='neutral'>        }</span>
   191 |     | <span class='neutral'>    }</span>
   192 |     | <span class='neutral'></span>
   193 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
   194 |     | <span class='neutral'>        bytes32 m0;</span>
   195 |     | <span class='neutral'>        bytes32 m1;</span>
   196 |     | <span class='neutral'>        bytes32 m2;</span>
   197 |     | <span class='neutral'>        assembly {</span>
   198 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   199 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   200 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   201 |     | <span class='neutral'>            // Selector of `log(address,bool)`.</span>
   202 |     | <span class='neutral'>            mstore(0x00, 0x75b605d3)</span>
   203 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   204 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   205 |     | <span class='neutral'>        }</span>
   206 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   207 |     | <span class='neutral'>        assembly {</span>
   208 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   209 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   210 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   211 |     | <span class='neutral'>        }</span>
   212 |     | <span class='neutral'>    }</span>
   213 |     | <span class='neutral'></span>
   214 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal pure {</span>
   215 |     | <span class='neutral'>        bytes32 m0;</span>
   216 |     | <span class='neutral'>        bytes32 m1;</span>
   217 |     | <span class='neutral'>        bytes32 m2;</span>
   218 |     | <span class='neutral'>        assembly {</span>
   219 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   220 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   221 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   222 |     | <span class='neutral'>            // Selector of `log(address,uint256)`.</span>
   223 |     | <span class='neutral'>            mstore(0x00, 0x8309e8a8)</span>
   224 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   225 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   226 |     | <span class='neutral'>        }</span>
   227 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   228 |     | <span class='neutral'>        assembly {</span>
   229 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   230 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   231 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   232 |     | <span class='neutral'>        }</span>
   233 |     | <span class='neutral'>    }</span>
   234 |     | <span class='neutral'></span>
   235 |     | <span class='neutral'>    function log(address p0, bytes32 p1) internal pure {</span>
   236 |     | <span class='neutral'>        bytes32 m0;</span>
   237 |     | <span class='neutral'>        bytes32 m1;</span>
   238 |     | <span class='neutral'>        bytes32 m2;</span>
   239 |     | <span class='neutral'>        bytes32 m3;</span>
   240 |     | <span class='neutral'>        bytes32 m4;</span>
   241 |     | <span class='neutral'>        assembly {</span>
   242 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   243 |     | <span class='neutral'>                let length := 0</span>
   244 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   245 |     | <span class='neutral'>                mstore(pos, length)</span>
   246 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   247 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   248 |     | <span class='neutral'>            }</span>
   249 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   250 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   251 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   252 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   253 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   254 |     | <span class='neutral'>            // Selector of `log(address,string)`.</span>
   255 |     | <span class='neutral'>            mstore(0x00, 0x759f86bb)</span>
   256 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   257 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   258 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   259 |     | <span class='neutral'>        }</span>
   260 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   261 |     | <span class='neutral'>        assembly {</span>
   262 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   263 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   264 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   265 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   266 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   267 |     | <span class='neutral'>        }</span>
   268 |     | <span class='neutral'>    }</span>
   269 |     | <span class='neutral'></span>
   270 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
   271 |     | <span class='neutral'>        bytes32 m0;</span>
   272 |     | <span class='neutral'>        bytes32 m1;</span>
   273 |     | <span class='neutral'>        bytes32 m2;</span>
   274 |     | <span class='neutral'>        assembly {</span>
   275 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   276 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   277 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   278 |     | <span class='neutral'>            // Selector of `log(bool,address)`.</span>
   279 |     | <span class='neutral'>            mstore(0x00, 0x853c4849)</span>
   280 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   281 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   282 |     | <span class='neutral'>        }</span>
   283 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   284 |     | <span class='neutral'>        assembly {</span>
   285 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   286 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   287 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   288 |     | <span class='neutral'>        }</span>
   289 |     | <span class='neutral'>    }</span>
   290 |     | <span class='neutral'></span>
   291 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
   292 |     | <span class='neutral'>        bytes32 m0;</span>
   293 |     | <span class='neutral'>        bytes32 m1;</span>
   294 |     | <span class='neutral'>        bytes32 m2;</span>
   295 |     | <span class='neutral'>        assembly {</span>
   296 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   297 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   298 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   299 |     | <span class='neutral'>            // Selector of `log(bool,bool)`.</span>
   300 |     | <span class='neutral'>            mstore(0x00, 0x2a110e83)</span>
   301 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   302 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   303 |     | <span class='neutral'>        }</span>
   304 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   305 |     | <span class='neutral'>        assembly {</span>
   306 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   307 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   308 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   309 |     | <span class='neutral'>        }</span>
   310 |     | <span class='neutral'>    }</span>
   311 |     | <span class='neutral'></span>
   312 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal pure {</span>
   313 |     | <span class='neutral'>        bytes32 m0;</span>
   314 |     | <span class='neutral'>        bytes32 m1;</span>
   315 |     | <span class='neutral'>        bytes32 m2;</span>
   316 |     | <span class='neutral'>        assembly {</span>
   317 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   318 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   319 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   320 |     | <span class='neutral'>            // Selector of `log(bool,uint256)`.</span>
   321 |     | <span class='neutral'>            mstore(0x00, 0x399174d3)</span>
   322 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   323 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   324 |     | <span class='neutral'>        }</span>
   325 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   326 |     | <span class='neutral'>        assembly {</span>
   327 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   328 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   329 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   330 |     | <span class='neutral'>        }</span>
   331 |     | <span class='neutral'>    }</span>
   332 |     | <span class='neutral'></span>
   333 |     | <span class='neutral'>    function log(bool p0, bytes32 p1) internal pure {</span>
   334 |     | <span class='neutral'>        bytes32 m0;</span>
   335 |     | <span class='neutral'>        bytes32 m1;</span>
   336 |     | <span class='neutral'>        bytes32 m2;</span>
   337 |     | <span class='neutral'>        bytes32 m3;</span>
   338 |     | <span class='neutral'>        bytes32 m4;</span>
   339 |     | <span class='neutral'>        assembly {</span>
   340 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   341 |     | <span class='neutral'>                let length := 0</span>
   342 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   343 |     | <span class='neutral'>                mstore(pos, length)</span>
   344 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   345 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   346 |     | <span class='neutral'>            }</span>
   347 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   348 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   349 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   350 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   351 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   352 |     | <span class='neutral'>            // Selector of `log(bool,string)`.</span>
   353 |     | <span class='neutral'>            mstore(0x00, 0x8feac525)</span>
   354 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   355 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   356 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   357 |     | <span class='neutral'>        }</span>
   358 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   359 |     | <span class='neutral'>        assembly {</span>
   360 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   361 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   362 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   363 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   364 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   365 |     | <span class='neutral'>        }</span>
   366 |     | <span class='neutral'>    }</span>
   367 |     | <span class='neutral'></span>
   368 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal pure {</span>
   369 |     | <span class='neutral'>        bytes32 m0;</span>
   370 |     | <span class='neutral'>        bytes32 m1;</span>
   371 |     | <span class='neutral'>        bytes32 m2;</span>
   372 |     | <span class='neutral'>        assembly {</span>
   373 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   374 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   375 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   376 |     | <span class='neutral'>            // Selector of `log(uint256,address)`.</span>
   377 |     | <span class='neutral'>            mstore(0x00, 0x69276c86)</span>
   378 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   379 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   380 |     | <span class='neutral'>        }</span>
   381 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   382 |     | <span class='neutral'>        assembly {</span>
   383 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   384 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   385 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   386 |     | <span class='neutral'>        }</span>
   387 |     | <span class='neutral'>    }</span>
   388 |     | <span class='neutral'></span>
   389 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal pure {</span>
   390 |     | <span class='neutral'>        bytes32 m0;</span>
   391 |     | <span class='neutral'>        bytes32 m1;</span>
   392 |     | <span class='neutral'>        bytes32 m2;</span>
   393 |     | <span class='neutral'>        assembly {</span>
   394 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   395 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   396 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   397 |     | <span class='neutral'>            // Selector of `log(uint256,bool)`.</span>
   398 |     | <span class='neutral'>            mstore(0x00, 0x1c9d7eb3)</span>
   399 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   400 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   401 |     | <span class='neutral'>        }</span>
   402 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   403 |     | <span class='neutral'>        assembly {</span>
   404 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   405 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   406 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   407 |     | <span class='neutral'>        }</span>
   408 |     | <span class='neutral'>    }</span>
   409 |     | <span class='neutral'></span>
   410 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal pure {</span>
   411 |     | <span class='neutral'>        bytes32 m0;</span>
   412 |     | <span class='neutral'>        bytes32 m1;</span>
   413 |     | <span class='neutral'>        bytes32 m2;</span>
   414 |     | <span class='neutral'>        assembly {</span>
   415 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   416 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   417 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   418 |     | <span class='neutral'>            // Selector of `log(uint256,uint256)`.</span>
   419 |     | <span class='neutral'>            mstore(0x00, 0xf666715a)</span>
   420 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   421 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   422 |     | <span class='neutral'>        }</span>
   423 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   424 |     | <span class='neutral'>        assembly {</span>
   425 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   426 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   427 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   428 |     | <span class='neutral'>        }</span>
   429 |     | <span class='neutral'>    }</span>
   430 |     | <span class='neutral'></span>
   431 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1) internal pure {</span>
   432 |     | <span class='neutral'>        bytes32 m0;</span>
   433 |     | <span class='neutral'>        bytes32 m1;</span>
   434 |     | <span class='neutral'>        bytes32 m2;</span>
   435 |     | <span class='neutral'>        bytes32 m3;</span>
   436 |     | <span class='neutral'>        bytes32 m4;</span>
   437 |     | <span class='neutral'>        assembly {</span>
   438 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   439 |     | <span class='neutral'>                let length := 0</span>
   440 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   441 |     | <span class='neutral'>                mstore(pos, length)</span>
   442 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   443 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   444 |     | <span class='neutral'>            }</span>
   445 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   446 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   447 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   448 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   449 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   450 |     | <span class='neutral'>            // Selector of `log(uint256,string)`.</span>
   451 |     | <span class='neutral'>            mstore(0x00, 0x643fd0df)</span>
   452 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   453 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   454 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   455 |     | <span class='neutral'>        }</span>
   456 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   457 |     | <span class='neutral'>        assembly {</span>
   458 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   459 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   460 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   461 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   462 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   463 |     | <span class='neutral'>        }</span>
   464 |     | <span class='neutral'>    }</span>
   465 |     | <span class='neutral'></span>
   466 |     | <span class='neutral'>    function log(bytes32 p0, address p1) internal pure {</span>
   467 |     | <span class='neutral'>        bytes32 m0;</span>
   468 |     | <span class='neutral'>        bytes32 m1;</span>
   469 |     | <span class='neutral'>        bytes32 m2;</span>
   470 |     | <span class='neutral'>        bytes32 m3;</span>
   471 |     | <span class='neutral'>        bytes32 m4;</span>
   472 |     | <span class='neutral'>        assembly {</span>
   473 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   474 |     | <span class='neutral'>                let length := 0</span>
   475 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   476 |     | <span class='neutral'>                mstore(pos, length)</span>
   477 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   478 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   479 |     | <span class='neutral'>            }</span>
   480 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   481 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   482 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   483 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   484 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   485 |     | <span class='neutral'>            // Selector of `log(string,address)`.</span>
   486 |     | <span class='neutral'>            mstore(0x00, 0x319af333)</span>
   487 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   488 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   489 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   490 |     | <span class='neutral'>        }</span>
   491 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   492 |     | <span class='neutral'>        assembly {</span>
   493 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   494 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   495 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   496 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   497 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   498 |     | <span class='neutral'>        }</span>
   499 |     | <span class='neutral'>    }</span>
   500 |     | <span class='neutral'></span>
   501 |     | <span class='neutral'>    function log(bytes32 p0, bool p1) internal pure {</span>
   502 |     | <span class='neutral'>        bytes32 m0;</span>
   503 |     | <span class='neutral'>        bytes32 m1;</span>
   504 |     | <span class='neutral'>        bytes32 m2;</span>
   505 |     | <span class='neutral'>        bytes32 m3;</span>
   506 |     | <span class='neutral'>        bytes32 m4;</span>
   507 |     | <span class='neutral'>        assembly {</span>
   508 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   509 |     | <span class='neutral'>                let length := 0</span>
   510 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   511 |     | <span class='neutral'>                mstore(pos, length)</span>
   512 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   513 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   514 |     | <span class='neutral'>            }</span>
   515 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   516 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   517 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   518 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   519 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   520 |     | <span class='neutral'>            // Selector of `log(string,bool)`.</span>
   521 |     | <span class='neutral'>            mstore(0x00, 0xc3b55635)</span>
   522 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   523 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   524 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   525 |     | <span class='neutral'>        }</span>
   526 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   527 |     | <span class='neutral'>        assembly {</span>
   528 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   529 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   530 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   531 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   532 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   533 |     | <span class='neutral'>        }</span>
   534 |     | <span class='neutral'>    }</span>
   535 |     | <span class='neutral'></span>
   536 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1) internal pure {</span>
   537 |     | <span class='neutral'>        bytes32 m0;</span>
   538 |     | <span class='neutral'>        bytes32 m1;</span>
   539 |     | <span class='neutral'>        bytes32 m2;</span>
   540 |     | <span class='neutral'>        bytes32 m3;</span>
   541 |     | <span class='neutral'>        bytes32 m4;</span>
   542 |     | <span class='neutral'>        assembly {</span>
   543 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   544 |     | <span class='neutral'>                let length := 0</span>
   545 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   546 |     | <span class='neutral'>                mstore(pos, length)</span>
   547 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   548 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   549 |     | <span class='neutral'>            }</span>
   550 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   551 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   552 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   553 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   554 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   555 |     | <span class='neutral'>            // Selector of `log(string,uint256)`.</span>
   556 |     | <span class='neutral'>            mstore(0x00, 0xb60e72cc)</span>
   557 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   558 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   559 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   560 |     | <span class='neutral'>        }</span>
   561 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   562 |     | <span class='neutral'>        assembly {</span>
   563 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   564 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   565 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   566 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   567 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   568 |     | <span class='neutral'>        }</span>
   569 |     | <span class='neutral'>    }</span>
   570 |     | <span class='neutral'></span>
   571 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1) internal pure {</span>
   572 |     | <span class='neutral'>        bytes32 m0;</span>
   573 |     | <span class='neutral'>        bytes32 m1;</span>
   574 |     | <span class='neutral'>        bytes32 m2;</span>
   575 |     | <span class='neutral'>        bytes32 m3;</span>
   576 |     | <span class='neutral'>        bytes32 m4;</span>
   577 |     | <span class='neutral'>        bytes32 m5;</span>
   578 |     | <span class='neutral'>        bytes32 m6;</span>
   579 |     | <span class='neutral'>        assembly {</span>
   580 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   581 |     | <span class='neutral'>                let length := 0</span>
   582 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   583 |     | <span class='neutral'>                mstore(pos, length)</span>
   584 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   585 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   586 |     | <span class='neutral'>            }</span>
   587 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   588 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   589 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   590 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   591 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   592 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   593 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
   594 |     | <span class='neutral'>            // Selector of `log(string,string)`.</span>
   595 |     | <span class='neutral'>            mstore(0x00, 0x4b5c4277)</span>
   596 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   597 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
   598 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   599 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
   600 |     | <span class='neutral'>        }</span>
   601 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
   602 |     | <span class='neutral'>        assembly {</span>
   603 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   604 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   605 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   606 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   607 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   608 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   609 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
   610 |     | <span class='neutral'>        }</span>
   611 |     | <span class='neutral'>    }</span>
   612 |     | <span class='neutral'></span>
   613 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
   614 |     | <span class='neutral'>        bytes32 m0;</span>
   615 |     | <span class='neutral'>        bytes32 m1;</span>
   616 |     | <span class='neutral'>        bytes32 m2;</span>
   617 |     | <span class='neutral'>        bytes32 m3;</span>
   618 |     | <span class='neutral'>        assembly {</span>
   619 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   620 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   621 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   622 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   623 |     | <span class='neutral'>            // Selector of `log(address,address,address)`.</span>
   624 |     | <span class='neutral'>            mstore(0x00, 0x018c84c2)</span>
   625 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   626 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   627 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   628 |     | <span class='neutral'>        }</span>
   629 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   630 |     | <span class='neutral'>        assembly {</span>
   631 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   632 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   633 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   634 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   635 |     | <span class='neutral'>        }</span>
   636 |     | <span class='neutral'>    }</span>
   637 |     | <span class='neutral'></span>
   638 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
   639 |     | <span class='neutral'>        bytes32 m0;</span>
   640 |     | <span class='neutral'>        bytes32 m1;</span>
   641 |     | <span class='neutral'>        bytes32 m2;</span>
   642 |     | <span class='neutral'>        bytes32 m3;</span>
   643 |     | <span class='neutral'>        assembly {</span>
   644 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   645 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   646 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   647 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   648 |     | <span class='neutral'>            // Selector of `log(address,address,bool)`.</span>
   649 |     | <span class='neutral'>            mstore(0x00, 0xf2a66286)</span>
   650 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   651 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   652 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   653 |     | <span class='neutral'>        }</span>
   654 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   655 |     | <span class='neutral'>        assembly {</span>
   656 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   657 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   658 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   659 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   660 |     | <span class='neutral'>        }</span>
   661 |     | <span class='neutral'>    }</span>
   662 |     | <span class='neutral'></span>
   663 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal pure {</span>
   664 |     | <span class='neutral'>        bytes32 m0;</span>
   665 |     | <span class='neutral'>        bytes32 m1;</span>
   666 |     | <span class='neutral'>        bytes32 m2;</span>
   667 |     | <span class='neutral'>        bytes32 m3;</span>
   668 |     | <span class='neutral'>        assembly {</span>
   669 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   670 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   671 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   672 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   673 |     | <span class='neutral'>            // Selector of `log(address,address,uint256)`.</span>
   674 |     | <span class='neutral'>            mstore(0x00, 0x17fe6185)</span>
   675 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   676 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   677 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   678 |     | <span class='neutral'>        }</span>
   679 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   680 |     | <span class='neutral'>        assembly {</span>
   681 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   682 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   683 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   684 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   685 |     | <span class='neutral'>        }</span>
   686 |     | <span class='neutral'>    }</span>
   687 |     | <span class='neutral'></span>
   688 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2) internal pure {</span>
   689 |     | <span class='neutral'>        bytes32 m0;</span>
   690 |     | <span class='neutral'>        bytes32 m1;</span>
   691 |     | <span class='neutral'>        bytes32 m2;</span>
   692 |     | <span class='neutral'>        bytes32 m3;</span>
   693 |     | <span class='neutral'>        bytes32 m4;</span>
   694 |     | <span class='neutral'>        bytes32 m5;</span>
   695 |     | <span class='neutral'>        assembly {</span>
   696 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   697 |     | <span class='neutral'>                let length := 0</span>
   698 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   699 |     | <span class='neutral'>                mstore(pos, length)</span>
   700 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   701 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   702 |     | <span class='neutral'>            }</span>
   703 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   704 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   705 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   706 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   707 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   708 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   709 |     | <span class='neutral'>            // Selector of `log(address,address,string)`.</span>
   710 |     | <span class='neutral'>            mstore(0x00, 0x007150be)</span>
   711 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   712 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   713 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   714 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   715 |     | <span class='neutral'>        }</span>
   716 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   717 |     | <span class='neutral'>        assembly {</span>
   718 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   719 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   720 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   721 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   722 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   723 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   724 |     | <span class='neutral'>        }</span>
   725 |     | <span class='neutral'>    }</span>
   726 |     | <span class='neutral'></span>
   727 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
   728 |     | <span class='neutral'>        bytes32 m0;</span>
   729 |     | <span class='neutral'>        bytes32 m1;</span>
   730 |     | <span class='neutral'>        bytes32 m2;</span>
   731 |     | <span class='neutral'>        bytes32 m3;</span>
   732 |     | <span class='neutral'>        assembly {</span>
   733 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   734 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   735 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   736 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   737 |     | <span class='neutral'>            // Selector of `log(address,bool,address)`.</span>
   738 |     | <span class='neutral'>            mstore(0x00, 0xf11699ed)</span>
   739 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   740 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   741 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   742 |     | <span class='neutral'>        }</span>
   743 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   744 |     | <span class='neutral'>        assembly {</span>
   745 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   746 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   747 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   748 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   749 |     | <span class='neutral'>        }</span>
   750 |     | <span class='neutral'>    }</span>
   751 |     | <span class='neutral'></span>
   752 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
   753 |     | <span class='neutral'>        bytes32 m0;</span>
   754 |     | <span class='neutral'>        bytes32 m1;</span>
   755 |     | <span class='neutral'>        bytes32 m2;</span>
   756 |     | <span class='neutral'>        bytes32 m3;</span>
   757 |     | <span class='neutral'>        assembly {</span>
   758 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   759 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   760 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   761 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   762 |     | <span class='neutral'>            // Selector of `log(address,bool,bool)`.</span>
   763 |     | <span class='neutral'>            mstore(0x00, 0xeb830c92)</span>
   764 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   765 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   766 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   767 |     | <span class='neutral'>        }</span>
   768 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   769 |     | <span class='neutral'>        assembly {</span>
   770 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   771 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   772 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   773 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   774 |     | <span class='neutral'>        }</span>
   775 |     | <span class='neutral'>    }</span>
   776 |     | <span class='neutral'></span>
   777 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal pure {</span>
   778 |     | <span class='neutral'>        bytes32 m0;</span>
   779 |     | <span class='neutral'>        bytes32 m1;</span>
   780 |     | <span class='neutral'>        bytes32 m2;</span>
   781 |     | <span class='neutral'>        bytes32 m3;</span>
   782 |     | <span class='neutral'>        assembly {</span>
   783 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   784 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   785 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   786 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   787 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256)`.</span>
   788 |     | <span class='neutral'>            mstore(0x00, 0x9c4f99fb)</span>
   789 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   790 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   791 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   792 |     | <span class='neutral'>        }</span>
   793 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   794 |     | <span class='neutral'>        assembly {</span>
   795 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   796 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   797 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   798 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   799 |     | <span class='neutral'>        }</span>
   800 |     | <span class='neutral'>    }</span>
   801 |     | <span class='neutral'></span>
   802 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2) internal pure {</span>
   803 |     | <span class='neutral'>        bytes32 m0;</span>
   804 |     | <span class='neutral'>        bytes32 m1;</span>
   805 |     | <span class='neutral'>        bytes32 m2;</span>
   806 |     | <span class='neutral'>        bytes32 m3;</span>
   807 |     | <span class='neutral'>        bytes32 m4;</span>
   808 |     | <span class='neutral'>        bytes32 m5;</span>
   809 |     | <span class='neutral'>        assembly {</span>
   810 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   811 |     | <span class='neutral'>                let length := 0</span>
   812 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   813 |     | <span class='neutral'>                mstore(pos, length)</span>
   814 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   815 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   816 |     | <span class='neutral'>            }</span>
   817 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   818 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   819 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   820 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   821 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   822 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   823 |     | <span class='neutral'>            // Selector of `log(address,bool,string)`.</span>
   824 |     | <span class='neutral'>            mstore(0x00, 0x212255cc)</span>
   825 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   826 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   827 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   828 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   829 |     | <span class='neutral'>        }</span>
   830 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   831 |     | <span class='neutral'>        assembly {</span>
   832 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   833 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   834 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   835 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   836 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   837 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   838 |     | <span class='neutral'>        }</span>
   839 |     | <span class='neutral'>    }</span>
   840 |     | <span class='neutral'></span>
   841 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal pure {</span>
   842 |     | <span class='neutral'>        bytes32 m0;</span>
   843 |     | <span class='neutral'>        bytes32 m1;</span>
   844 |     | <span class='neutral'>        bytes32 m2;</span>
   845 |     | <span class='neutral'>        bytes32 m3;</span>
   846 |     | <span class='neutral'>        assembly {</span>
   847 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   848 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   849 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   850 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   851 |     | <span class='neutral'>            // Selector of `log(address,uint256,address)`.</span>
   852 |     | <span class='neutral'>            mstore(0x00, 0x7bc0d848)</span>
   853 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   854 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   855 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   856 |     | <span class='neutral'>        }</span>
   857 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   858 |     | <span class='neutral'>        assembly {</span>
   859 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   860 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   861 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   862 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   863 |     | <span class='neutral'>        }</span>
   864 |     | <span class='neutral'>    }</span>
   865 |     | <span class='neutral'></span>
   866 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal pure {</span>
   867 |     | <span class='neutral'>        bytes32 m0;</span>
   868 |     | <span class='neutral'>        bytes32 m1;</span>
   869 |     | <span class='neutral'>        bytes32 m2;</span>
   870 |     | <span class='neutral'>        bytes32 m3;</span>
   871 |     | <span class='neutral'>        assembly {</span>
   872 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   873 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   874 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   875 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   876 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool)`.</span>
   877 |     | <span class='neutral'>            mstore(0x00, 0x678209a8)</span>
   878 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   879 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   880 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   881 |     | <span class='neutral'>        }</span>
   882 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   883 |     | <span class='neutral'>        assembly {</span>
   884 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   885 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   886 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   887 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   888 |     | <span class='neutral'>        }</span>
   889 |     | <span class='neutral'>    }</span>
   890 |     | <span class='neutral'></span>
   891 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal pure {</span>
   892 |     | <span class='neutral'>        bytes32 m0;</span>
   893 |     | <span class='neutral'>        bytes32 m1;</span>
   894 |     | <span class='neutral'>        bytes32 m2;</span>
   895 |     | <span class='neutral'>        bytes32 m3;</span>
   896 |     | <span class='neutral'>        assembly {</span>
   897 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   898 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   899 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   900 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   901 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256)`.</span>
   902 |     | <span class='neutral'>            mstore(0x00, 0xb69bcaf6)</span>
   903 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   904 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   905 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   906 |     | <span class='neutral'>        }</span>
   907 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   908 |     | <span class='neutral'>        assembly {</span>
   909 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   910 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   911 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   912 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   913 |     | <span class='neutral'>        }</span>
   914 |     | <span class='neutral'>    }</span>
   915 |     | <span class='neutral'></span>
   916 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2) internal pure {</span>
   917 |     | <span class='neutral'>        bytes32 m0;</span>
   918 |     | <span class='neutral'>        bytes32 m1;</span>
   919 |     | <span class='neutral'>        bytes32 m2;</span>
   920 |     | <span class='neutral'>        bytes32 m3;</span>
   921 |     | <span class='neutral'>        bytes32 m4;</span>
   922 |     | <span class='neutral'>        bytes32 m5;</span>
   923 |     | <span class='neutral'>        assembly {</span>
   924 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   925 |     | <span class='neutral'>                let length := 0</span>
   926 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   927 |     | <span class='neutral'>                mstore(pos, length)</span>
   928 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   929 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   930 |     | <span class='neutral'>            }</span>
   931 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   932 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   933 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   934 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   935 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   936 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   937 |     | <span class='neutral'>            // Selector of `log(address,uint256,string)`.</span>
   938 |     | <span class='neutral'>            mstore(0x00, 0xa1f2e8aa)</span>
   939 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   940 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   941 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   942 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   943 |     | <span class='neutral'>        }</span>
   944 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   945 |     | <span class='neutral'>        assembly {</span>
   946 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   947 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   948 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   949 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   950 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   951 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   952 |     | <span class='neutral'>        }</span>
   953 |     | <span class='neutral'>    }</span>
   954 |     | <span class='neutral'></span>
   955 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2) internal pure {</span>
   956 |     | <span class='neutral'>        bytes32 m0;</span>
   957 |     | <span class='neutral'>        bytes32 m1;</span>
   958 |     | <span class='neutral'>        bytes32 m2;</span>
   959 |     | <span class='neutral'>        bytes32 m3;</span>
   960 |     | <span class='neutral'>        bytes32 m4;</span>
   961 |     | <span class='neutral'>        bytes32 m5;</span>
   962 |     | <span class='neutral'>        assembly {</span>
   963 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   964 |     | <span class='neutral'>                let length := 0</span>
   965 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   966 |     | <span class='neutral'>                mstore(pos, length)</span>
   967 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   968 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   969 |     | <span class='neutral'>            }</span>
   970 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   971 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   972 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   973 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   974 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   975 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   976 |     | <span class='neutral'>            // Selector of `log(address,string,address)`.</span>
   977 |     | <span class='neutral'>            mstore(0x00, 0xf08744e8)</span>
   978 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   979 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
   980 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   981 |     | <span class='neutral'>            writeString(0x80, p1)</span>
   982 |     | <span class='neutral'>        }</span>
   983 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   984 |     | <span class='neutral'>        assembly {</span>
   985 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   986 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   987 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   988 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   989 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   990 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   991 |     | <span class='neutral'>        }</span>
   992 |     | <span class='neutral'>    }</span>
   993 |     | <span class='neutral'></span>
   994 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2) internal pure {</span>
   995 |     | <span class='neutral'>        bytes32 m0;</span>
   996 |     | <span class='neutral'>        bytes32 m1;</span>
   997 |     | <span class='neutral'>        bytes32 m2;</span>
   998 |     | <span class='neutral'>        bytes32 m3;</span>
   999 |     | <span class='neutral'>        bytes32 m4;</span>
  1000 |     | <span class='neutral'>        bytes32 m5;</span>
  1001 |     | <span class='neutral'>        assembly {</span>
  1002 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1003 |     | <span class='neutral'>                let length := 0</span>
  1004 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1005 |     | <span class='neutral'>                mstore(pos, length)</span>
  1006 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1007 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1008 |     | <span class='neutral'>            }</span>
  1009 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1010 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1011 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1012 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1013 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1014 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1015 |     | <span class='neutral'>            // Selector of `log(address,string,bool)`.</span>
  1016 |     | <span class='neutral'>            mstore(0x00, 0xcf020fb1)</span>
  1017 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1018 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1019 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1020 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1021 |     | <span class='neutral'>        }</span>
  1022 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1023 |     | <span class='neutral'>        assembly {</span>
  1024 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1025 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1026 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1027 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1028 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1029 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1030 |     | <span class='neutral'>        }</span>
  1031 |     | <span class='neutral'>    }</span>
  1032 |     | <span class='neutral'></span>
  1033 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2) internal pure {</span>
  1034 |     | <span class='neutral'>        bytes32 m0;</span>
  1035 |     | <span class='neutral'>        bytes32 m1;</span>
  1036 |     | <span class='neutral'>        bytes32 m2;</span>
  1037 |     | <span class='neutral'>        bytes32 m3;</span>
  1038 |     | <span class='neutral'>        bytes32 m4;</span>
  1039 |     | <span class='neutral'>        bytes32 m5;</span>
  1040 |     | <span class='neutral'>        assembly {</span>
  1041 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1042 |     | <span class='neutral'>                let length := 0</span>
  1043 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1044 |     | <span class='neutral'>                mstore(pos, length)</span>
  1045 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1046 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1047 |     | <span class='neutral'>            }</span>
  1048 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1049 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1050 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1051 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1052 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1053 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1054 |     | <span class='neutral'>            // Selector of `log(address,string,uint256)`.</span>
  1055 |     | <span class='neutral'>            mstore(0x00, 0x67dd6ff1)</span>
  1056 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1057 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1058 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1059 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1060 |     | <span class='neutral'>        }</span>
  1061 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1062 |     | <span class='neutral'>        assembly {</span>
  1063 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1064 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1065 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1066 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1067 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1068 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1069 |     | <span class='neutral'>        }</span>
  1070 |     | <span class='neutral'>    }</span>
  1071 |     | <span class='neutral'></span>
  1072 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1073 |     | <span class='neutral'>        bytes32 m0;</span>
  1074 |     | <span class='neutral'>        bytes32 m1;</span>
  1075 |     | <span class='neutral'>        bytes32 m2;</span>
  1076 |     | <span class='neutral'>        bytes32 m3;</span>
  1077 |     | <span class='neutral'>        bytes32 m4;</span>
  1078 |     | <span class='neutral'>        bytes32 m5;</span>
  1079 |     | <span class='neutral'>        bytes32 m6;</span>
  1080 |     | <span class='neutral'>        bytes32 m7;</span>
  1081 |     | <span class='neutral'>        assembly {</span>
  1082 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1083 |     | <span class='neutral'>                let length := 0</span>
  1084 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1085 |     | <span class='neutral'>                mstore(pos, length)</span>
  1086 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1087 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1088 |     | <span class='neutral'>            }</span>
  1089 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1090 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1091 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1092 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1093 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1094 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1095 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1096 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1097 |     | <span class='neutral'>            // Selector of `log(address,string,string)`.</span>
  1098 |     | <span class='neutral'>            mstore(0x00, 0xfb772265)</span>
  1099 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1100 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1101 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1102 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1103 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1104 |     | <span class='neutral'>        }</span>
  1105 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1106 |     | <span class='neutral'>        assembly {</span>
  1107 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1108 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1109 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1110 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1111 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1112 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1113 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1114 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1115 |     | <span class='neutral'>        }</span>
  1116 |     | <span class='neutral'>    }</span>
  1117 |     | <span class='neutral'></span>
  1118 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  1119 |     | <span class='neutral'>        bytes32 m0;</span>
  1120 |     | <span class='neutral'>        bytes32 m1;</span>
  1121 |     | <span class='neutral'>        bytes32 m2;</span>
  1122 |     | <span class='neutral'>        bytes32 m3;</span>
  1123 |     | <span class='neutral'>        assembly {</span>
  1124 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1125 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1126 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1127 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1128 |     | <span class='neutral'>            // Selector of `log(bool,address,address)`.</span>
  1129 |     | <span class='neutral'>            mstore(0x00, 0xd2763667)</span>
  1130 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1131 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1132 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1133 |     | <span class='neutral'>        }</span>
  1134 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1135 |     | <span class='neutral'>        assembly {</span>
  1136 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1137 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1138 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1139 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1140 |     | <span class='neutral'>        }</span>
  1141 |     | <span class='neutral'>    }</span>
  1142 |     | <span class='neutral'></span>
  1143 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  1144 |     | <span class='neutral'>        bytes32 m0;</span>
  1145 |     | <span class='neutral'>        bytes32 m1;</span>
  1146 |     | <span class='neutral'>        bytes32 m2;</span>
  1147 |     | <span class='neutral'>        bytes32 m3;</span>
  1148 |     | <span class='neutral'>        assembly {</span>
  1149 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1150 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1151 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1152 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1153 |     | <span class='neutral'>            // Selector of `log(bool,address,bool)`.</span>
  1154 |     | <span class='neutral'>            mstore(0x00, 0x18c9c746)</span>
  1155 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1156 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1157 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1158 |     | <span class='neutral'>        }</span>
  1159 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1160 |     | <span class='neutral'>        assembly {</span>
  1161 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1162 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1163 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1164 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1165 |     | <span class='neutral'>        }</span>
  1166 |     | <span class='neutral'>    }</span>
  1167 |     | <span class='neutral'></span>
  1168 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal pure {</span>
  1169 |     | <span class='neutral'>        bytes32 m0;</span>
  1170 |     | <span class='neutral'>        bytes32 m1;</span>
  1171 |     | <span class='neutral'>        bytes32 m2;</span>
  1172 |     | <span class='neutral'>        bytes32 m3;</span>
  1173 |     | <span class='neutral'>        assembly {</span>
  1174 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1175 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1176 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1177 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1178 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256)`.</span>
  1179 |     | <span class='neutral'>            mstore(0x00, 0x5f7b9afb)</span>
  1180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1183 |     | <span class='neutral'>        }</span>
  1184 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1185 |     | <span class='neutral'>        assembly {</span>
  1186 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1187 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1188 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1189 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1190 |     | <span class='neutral'>        }</span>
  1191 |     | <span class='neutral'>    }</span>
  1192 |     | <span class='neutral'></span>
  1193 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2) internal pure {</span>
  1194 |     | <span class='neutral'>        bytes32 m0;</span>
  1195 |     | <span class='neutral'>        bytes32 m1;</span>
  1196 |     | <span class='neutral'>        bytes32 m2;</span>
  1197 |     | <span class='neutral'>        bytes32 m3;</span>
  1198 |     | <span class='neutral'>        bytes32 m4;</span>
  1199 |     | <span class='neutral'>        bytes32 m5;</span>
  1200 |     | <span class='neutral'>        assembly {</span>
  1201 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1202 |     | <span class='neutral'>                let length := 0</span>
  1203 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1204 |     | <span class='neutral'>                mstore(pos, length)</span>
  1205 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1206 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1207 |     | <span class='neutral'>            }</span>
  1208 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1209 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1210 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1211 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1212 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1213 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1214 |     | <span class='neutral'>            // Selector of `log(bool,address,string)`.</span>
  1215 |     | <span class='neutral'>            mstore(0x00, 0xde9a9270)</span>
  1216 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1217 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1218 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1219 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1220 |     | <span class='neutral'>        }</span>
  1221 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1222 |     | <span class='neutral'>        assembly {</span>
  1223 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1224 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1225 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1226 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1227 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1228 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1229 |     | <span class='neutral'>        }</span>
  1230 |     | <span class='neutral'>    }</span>
  1231 |     | <span class='neutral'></span>
  1232 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  1233 |     | <span class='neutral'>        bytes32 m0;</span>
  1234 |     | <span class='neutral'>        bytes32 m1;</span>
  1235 |     | <span class='neutral'>        bytes32 m2;</span>
  1236 |     | <span class='neutral'>        bytes32 m3;</span>
  1237 |     | <span class='neutral'>        assembly {</span>
  1238 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1239 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1240 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1241 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1242 |     | <span class='neutral'>            // Selector of `log(bool,bool,address)`.</span>
  1243 |     | <span class='neutral'>            mstore(0x00, 0x1078f68d)</span>
  1244 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1245 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1246 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1247 |     | <span class='neutral'>        }</span>
  1248 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1249 |     | <span class='neutral'>        assembly {</span>
  1250 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1251 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1252 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1253 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1254 |     | <span class='neutral'>        }</span>
  1255 |     | <span class='neutral'>    }</span>
  1256 |     | <span class='neutral'></span>
  1257 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  1258 |     | <span class='neutral'>        bytes32 m0;</span>
  1259 |     | <span class='neutral'>        bytes32 m1;</span>
  1260 |     | <span class='neutral'>        bytes32 m2;</span>
  1261 |     | <span class='neutral'>        bytes32 m3;</span>
  1262 |     | <span class='neutral'>        assembly {</span>
  1263 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1264 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1265 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1266 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1267 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool)`.</span>
  1268 |     | <span class='neutral'>            mstore(0x00, 0x50709698)</span>
  1269 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1270 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1271 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1272 |     | <span class='neutral'>        }</span>
  1273 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1274 |     | <span class='neutral'>        assembly {</span>
  1275 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1276 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1277 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1278 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1279 |     | <span class='neutral'>        }</span>
  1280 |     | <span class='neutral'>    }</span>
  1281 |     | <span class='neutral'></span>
  1282 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal pure {</span>
  1283 |     | <span class='neutral'>        bytes32 m0;</span>
  1284 |     | <span class='neutral'>        bytes32 m1;</span>
  1285 |     | <span class='neutral'>        bytes32 m2;</span>
  1286 |     | <span class='neutral'>        bytes32 m3;</span>
  1287 |     | <span class='neutral'>        assembly {</span>
  1288 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1289 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1290 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1291 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1292 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256)`.</span>
  1293 |     | <span class='neutral'>            mstore(0x00, 0x12f21602)</span>
  1294 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1295 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1296 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1297 |     | <span class='neutral'>        }</span>
  1298 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1299 |     | <span class='neutral'>        assembly {</span>
  1300 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1301 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1302 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1303 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1304 |     | <span class='neutral'>        }</span>
  1305 |     | <span class='neutral'>    }</span>
  1306 |     | <span class='neutral'></span>
  1307 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2) internal pure {</span>
  1308 |     | <span class='neutral'>        bytes32 m0;</span>
  1309 |     | <span class='neutral'>        bytes32 m1;</span>
  1310 |     | <span class='neutral'>        bytes32 m2;</span>
  1311 |     | <span class='neutral'>        bytes32 m3;</span>
  1312 |     | <span class='neutral'>        bytes32 m4;</span>
  1313 |     | <span class='neutral'>        bytes32 m5;</span>
  1314 |     | <span class='neutral'>        assembly {</span>
  1315 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1316 |     | <span class='neutral'>                let length := 0</span>
  1317 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1318 |     | <span class='neutral'>                mstore(pos, length)</span>
  1319 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1320 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1321 |     | <span class='neutral'>            }</span>
  1322 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1323 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1324 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1325 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1326 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1327 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1328 |     | <span class='neutral'>            // Selector of `log(bool,bool,string)`.</span>
  1329 |     | <span class='neutral'>            mstore(0x00, 0x2555fa46)</span>
  1330 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1331 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1332 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1333 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1334 |     | <span class='neutral'>        }</span>
  1335 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1336 |     | <span class='neutral'>        assembly {</span>
  1337 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1338 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1339 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1340 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1341 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1342 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1343 |     | <span class='neutral'>        }</span>
  1344 |     | <span class='neutral'>    }</span>
  1345 |     | <span class='neutral'></span>
  1346 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal pure {</span>
  1347 |     | <span class='neutral'>        bytes32 m0;</span>
  1348 |     | <span class='neutral'>        bytes32 m1;</span>
  1349 |     | <span class='neutral'>        bytes32 m2;</span>
  1350 |     | <span class='neutral'>        bytes32 m3;</span>
  1351 |     | <span class='neutral'>        assembly {</span>
  1352 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1353 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1354 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1355 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1356 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address)`.</span>
  1357 |     | <span class='neutral'>            mstore(0x00, 0x088ef9d2)</span>
  1358 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1359 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1360 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1361 |     | <span class='neutral'>        }</span>
  1362 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1363 |     | <span class='neutral'>        assembly {</span>
  1364 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1365 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1366 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1367 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1368 |     | <span class='neutral'>        }</span>
  1369 |     | <span class='neutral'>    }</span>
  1370 |     | <span class='neutral'></span>
  1371 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal pure {</span>
  1372 |     | <span class='neutral'>        bytes32 m0;</span>
  1373 |     | <span class='neutral'>        bytes32 m1;</span>
  1374 |     | <span class='neutral'>        bytes32 m2;</span>
  1375 |     | <span class='neutral'>        bytes32 m3;</span>
  1376 |     | <span class='neutral'>        assembly {</span>
  1377 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1378 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1379 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1380 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1381 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool)`.</span>
  1382 |     | <span class='neutral'>            mstore(0x00, 0xe8defba9)</span>
  1383 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1384 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1385 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1386 |     | <span class='neutral'>        }</span>
  1387 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1388 |     | <span class='neutral'>        assembly {</span>
  1389 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1390 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1391 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1392 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1393 |     | <span class='neutral'>        }</span>
  1394 |     | <span class='neutral'>    }</span>
  1395 |     | <span class='neutral'></span>
  1396 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal pure {</span>
  1397 |     | <span class='neutral'>        bytes32 m0;</span>
  1398 |     | <span class='neutral'>        bytes32 m1;</span>
  1399 |     | <span class='neutral'>        bytes32 m2;</span>
  1400 |     | <span class='neutral'>        bytes32 m3;</span>
  1401 |     | <span class='neutral'>        assembly {</span>
  1402 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1403 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1404 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1405 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1406 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256)`.</span>
  1407 |     | <span class='neutral'>            mstore(0x00, 0x37103367)</span>
  1408 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1409 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1410 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1411 |     | <span class='neutral'>        }</span>
  1412 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1413 |     | <span class='neutral'>        assembly {</span>
  1414 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1415 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1416 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1417 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1418 |     | <span class='neutral'>        }</span>
  1419 |     | <span class='neutral'>    }</span>
  1420 |     | <span class='neutral'></span>
  1421 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2) internal pure {</span>
  1422 |     | <span class='neutral'>        bytes32 m0;</span>
  1423 |     | <span class='neutral'>        bytes32 m1;</span>
  1424 |     | <span class='neutral'>        bytes32 m2;</span>
  1425 |     | <span class='neutral'>        bytes32 m3;</span>
  1426 |     | <span class='neutral'>        bytes32 m4;</span>
  1427 |     | <span class='neutral'>        bytes32 m5;</span>
  1428 |     | <span class='neutral'>        assembly {</span>
  1429 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1430 |     | <span class='neutral'>                let length := 0</span>
  1431 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1432 |     | <span class='neutral'>                mstore(pos, length)</span>
  1433 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1434 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1435 |     | <span class='neutral'>            }</span>
  1436 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1437 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1438 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1439 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1440 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1441 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1442 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string)`.</span>
  1443 |     | <span class='neutral'>            mstore(0x00, 0xc3fc3970)</span>
  1444 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1445 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1446 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1447 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1448 |     | <span class='neutral'>        }</span>
  1449 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1450 |     | <span class='neutral'>        assembly {</span>
  1451 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1452 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1453 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1454 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1455 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1456 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1457 |     | <span class='neutral'>        }</span>
  1458 |     | <span class='neutral'>    }</span>
  1459 |     | <span class='neutral'></span>
  1460 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2) internal pure {</span>
  1461 |     | <span class='neutral'>        bytes32 m0;</span>
  1462 |     | <span class='neutral'>        bytes32 m1;</span>
  1463 |     | <span class='neutral'>        bytes32 m2;</span>
  1464 |     | <span class='neutral'>        bytes32 m3;</span>
  1465 |     | <span class='neutral'>        bytes32 m4;</span>
  1466 |     | <span class='neutral'>        bytes32 m5;</span>
  1467 |     | <span class='neutral'>        assembly {</span>
  1468 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1469 |     | <span class='neutral'>                let length := 0</span>
  1470 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1471 |     | <span class='neutral'>                mstore(pos, length)</span>
  1472 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1473 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1474 |     | <span class='neutral'>            }</span>
  1475 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1476 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1477 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1478 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1479 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1480 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1481 |     | <span class='neutral'>            // Selector of `log(bool,string,address)`.</span>
  1482 |     | <span class='neutral'>            mstore(0x00, 0x9591b953)</span>
  1483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1484 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1485 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1486 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1487 |     | <span class='neutral'>        }</span>
  1488 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1489 |     | <span class='neutral'>        assembly {</span>
  1490 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1491 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1492 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1493 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1494 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1495 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1496 |     | <span class='neutral'>        }</span>
  1497 |     | <span class='neutral'>    }</span>
  1498 |     | <span class='neutral'></span>
  1499 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2) internal pure {</span>
  1500 |     | <span class='neutral'>        bytes32 m0;</span>
  1501 |     | <span class='neutral'>        bytes32 m1;</span>
  1502 |     | <span class='neutral'>        bytes32 m2;</span>
  1503 |     | <span class='neutral'>        bytes32 m3;</span>
  1504 |     | <span class='neutral'>        bytes32 m4;</span>
  1505 |     | <span class='neutral'>        bytes32 m5;</span>
  1506 |     | <span class='neutral'>        assembly {</span>
  1507 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1508 |     | <span class='neutral'>                let length := 0</span>
  1509 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1510 |     | <span class='neutral'>                mstore(pos, length)</span>
  1511 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1512 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1513 |     | <span class='neutral'>            }</span>
  1514 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1515 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1516 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1517 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1518 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1519 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1520 |     | <span class='neutral'>            // Selector of `log(bool,string,bool)`.</span>
  1521 |     | <span class='neutral'>            mstore(0x00, 0xdbb4c247)</span>
  1522 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1523 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1524 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1525 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1526 |     | <span class='neutral'>        }</span>
  1527 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1528 |     | <span class='neutral'>        assembly {</span>
  1529 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1530 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1531 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1532 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1533 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1534 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1535 |     | <span class='neutral'>        }</span>
  1536 |     | <span class='neutral'>    }</span>
  1537 |     | <span class='neutral'></span>
  1538 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2) internal pure {</span>
  1539 |     | <span class='neutral'>        bytes32 m0;</span>
  1540 |     | <span class='neutral'>        bytes32 m1;</span>
  1541 |     | <span class='neutral'>        bytes32 m2;</span>
  1542 |     | <span class='neutral'>        bytes32 m3;</span>
  1543 |     | <span class='neutral'>        bytes32 m4;</span>
  1544 |     | <span class='neutral'>        bytes32 m5;</span>
  1545 |     | <span class='neutral'>        assembly {</span>
  1546 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1547 |     | <span class='neutral'>                let length := 0</span>
  1548 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1549 |     | <span class='neutral'>                mstore(pos, length)</span>
  1550 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1551 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1552 |     | <span class='neutral'>            }</span>
  1553 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1554 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1555 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1556 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1557 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1558 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1559 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256)`.</span>
  1560 |     | <span class='neutral'>            mstore(0x00, 0x1093ee11)</span>
  1561 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1562 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1563 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1564 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1565 |     | <span class='neutral'>        }</span>
  1566 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1567 |     | <span class='neutral'>        assembly {</span>
  1568 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1569 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1570 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1571 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1572 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1573 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1574 |     | <span class='neutral'>        }</span>
  1575 |     | <span class='neutral'>    }</span>
  1576 |     | <span class='neutral'></span>
  1577 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1578 |     | <span class='neutral'>        bytes32 m0;</span>
  1579 |     | <span class='neutral'>        bytes32 m1;</span>
  1580 |     | <span class='neutral'>        bytes32 m2;</span>
  1581 |     | <span class='neutral'>        bytes32 m3;</span>
  1582 |     | <span class='neutral'>        bytes32 m4;</span>
  1583 |     | <span class='neutral'>        bytes32 m5;</span>
  1584 |     | <span class='neutral'>        bytes32 m6;</span>
  1585 |     | <span class='neutral'>        bytes32 m7;</span>
  1586 |     | <span class='neutral'>        assembly {</span>
  1587 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1588 |     | <span class='neutral'>                let length := 0</span>
  1589 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1590 |     | <span class='neutral'>                mstore(pos, length)</span>
  1591 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1592 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1593 |     | <span class='neutral'>            }</span>
  1594 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1595 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1596 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1597 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1598 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1599 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1600 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1601 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1602 |     | <span class='neutral'>            // Selector of `log(bool,string,string)`.</span>
  1603 |     | <span class='neutral'>            mstore(0x00, 0xb076847f)</span>
  1604 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1605 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1606 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1607 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1608 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1609 |     | <span class='neutral'>        }</span>
  1610 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1611 |     | <span class='neutral'>        assembly {</span>
  1612 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1613 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1614 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1615 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1616 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1617 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1618 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1619 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1620 |     | <span class='neutral'>        }</span>
  1621 |     | <span class='neutral'>    }</span>
  1622 |     | <span class='neutral'></span>
  1623 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal pure {</span>
  1624 |     | <span class='neutral'>        bytes32 m0;</span>
  1625 |     | <span class='neutral'>        bytes32 m1;</span>
  1626 |     | <span class='neutral'>        bytes32 m2;</span>
  1627 |     | <span class='neutral'>        bytes32 m3;</span>
  1628 |     | <span class='neutral'>        assembly {</span>
  1629 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1630 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1631 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1632 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1633 |     | <span class='neutral'>            // Selector of `log(uint256,address,address)`.</span>
  1634 |     | <span class='neutral'>            mstore(0x00, 0xbcfd9be0)</span>
  1635 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1636 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1637 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1638 |     | <span class='neutral'>        }</span>
  1639 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1640 |     | <span class='neutral'>        assembly {</span>
  1641 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1642 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1643 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1644 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1645 |     | <span class='neutral'>        }</span>
  1646 |     | <span class='neutral'>    }</span>
  1647 |     | <span class='neutral'></span>
  1648 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal pure {</span>
  1649 |     | <span class='neutral'>        bytes32 m0;</span>
  1650 |     | <span class='neutral'>        bytes32 m1;</span>
  1651 |     | <span class='neutral'>        bytes32 m2;</span>
  1652 |     | <span class='neutral'>        bytes32 m3;</span>
  1653 |     | <span class='neutral'>        assembly {</span>
  1654 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1655 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1656 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1657 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1658 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool)`.</span>
  1659 |     | <span class='neutral'>            mstore(0x00, 0x9b6ec042)</span>
  1660 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1661 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1662 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1663 |     | <span class='neutral'>        }</span>
  1664 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1665 |     | <span class='neutral'>        assembly {</span>
  1666 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1667 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1668 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1669 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1670 |     | <span class='neutral'>        }</span>
  1671 |     | <span class='neutral'>    }</span>
  1672 |     | <span class='neutral'></span>
  1673 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal pure {</span>
  1674 |     | <span class='neutral'>        bytes32 m0;</span>
  1675 |     | <span class='neutral'>        bytes32 m1;</span>
  1676 |     | <span class='neutral'>        bytes32 m2;</span>
  1677 |     | <span class='neutral'>        bytes32 m3;</span>
  1678 |     | <span class='neutral'>        assembly {</span>
  1679 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1680 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1681 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1682 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1683 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256)`.</span>
  1684 |     | <span class='neutral'>            mstore(0x00, 0x5a9b5ed5)</span>
  1685 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1686 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1687 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1688 |     | <span class='neutral'>        }</span>
  1689 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1690 |     | <span class='neutral'>        assembly {</span>
  1691 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1692 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1693 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1694 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1695 |     | <span class='neutral'>        }</span>
  1696 |     | <span class='neutral'>    }</span>
  1697 |     | <span class='neutral'></span>
  1698 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2) internal pure {</span>
  1699 |     | <span class='neutral'>        bytes32 m0;</span>
  1700 |     | <span class='neutral'>        bytes32 m1;</span>
  1701 |     | <span class='neutral'>        bytes32 m2;</span>
  1702 |     | <span class='neutral'>        bytes32 m3;</span>
  1703 |     | <span class='neutral'>        bytes32 m4;</span>
  1704 |     | <span class='neutral'>        bytes32 m5;</span>
  1705 |     | <span class='neutral'>        assembly {</span>
  1706 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1707 |     | <span class='neutral'>                let length := 0</span>
  1708 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1709 |     | <span class='neutral'>                mstore(pos, length)</span>
  1710 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1711 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1712 |     | <span class='neutral'>            }</span>
  1713 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1714 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1715 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1716 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1717 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1718 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1719 |     | <span class='neutral'>            // Selector of `log(uint256,address,string)`.</span>
  1720 |     | <span class='neutral'>            mstore(0x00, 0x63cb41f9)</span>
  1721 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1722 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1723 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1724 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1725 |     | <span class='neutral'>        }</span>
  1726 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1727 |     | <span class='neutral'>        assembly {</span>
  1728 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1729 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1730 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1731 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1732 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1733 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1734 |     | <span class='neutral'>        }</span>
  1735 |     | <span class='neutral'>    }</span>
  1736 |     | <span class='neutral'></span>
  1737 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal pure {</span>
  1738 |     | <span class='neutral'>        bytes32 m0;</span>
  1739 |     | <span class='neutral'>        bytes32 m1;</span>
  1740 |     | <span class='neutral'>        bytes32 m2;</span>
  1741 |     | <span class='neutral'>        bytes32 m3;</span>
  1742 |     | <span class='neutral'>        assembly {</span>
  1743 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1744 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1745 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1746 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1747 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address)`.</span>
  1748 |     | <span class='neutral'>            mstore(0x00, 0x35085f7b)</span>
  1749 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1750 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1751 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1752 |     | <span class='neutral'>        }</span>
  1753 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1754 |     | <span class='neutral'>        assembly {</span>
  1755 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1756 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1757 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1758 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1759 |     | <span class='neutral'>        }</span>
  1760 |     | <span class='neutral'>    }</span>
  1761 |     | <span class='neutral'></span>
  1762 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal pure {</span>
  1763 |     | <span class='neutral'>        bytes32 m0;</span>
  1764 |     | <span class='neutral'>        bytes32 m1;</span>
  1765 |     | <span class='neutral'>        bytes32 m2;</span>
  1766 |     | <span class='neutral'>        bytes32 m3;</span>
  1767 |     | <span class='neutral'>        assembly {</span>
  1768 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1769 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1770 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1771 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1772 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool)`.</span>
  1773 |     | <span class='neutral'>            mstore(0x00, 0x20718650)</span>
  1774 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1775 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1776 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1777 |     | <span class='neutral'>        }</span>
  1778 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1779 |     | <span class='neutral'>        assembly {</span>
  1780 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1781 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1782 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1783 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1784 |     | <span class='neutral'>        }</span>
  1785 |     | <span class='neutral'>    }</span>
  1786 |     | <span class='neutral'></span>
  1787 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal pure {</span>
  1788 |     | <span class='neutral'>        bytes32 m0;</span>
  1789 |     | <span class='neutral'>        bytes32 m1;</span>
  1790 |     | <span class='neutral'>        bytes32 m2;</span>
  1791 |     | <span class='neutral'>        bytes32 m3;</span>
  1792 |     | <span class='neutral'>        assembly {</span>
  1793 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1794 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1795 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1796 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1797 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256)`.</span>
  1798 |     | <span class='neutral'>            mstore(0x00, 0x20098014)</span>
  1799 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1800 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1801 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1802 |     | <span class='neutral'>        }</span>
  1803 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1804 |     | <span class='neutral'>        assembly {</span>
  1805 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1806 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1807 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1808 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1809 |     | <span class='neutral'>        }</span>
  1810 |     | <span class='neutral'>    }</span>
  1811 |     | <span class='neutral'></span>
  1812 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2) internal pure {</span>
  1813 |     | <span class='neutral'>        bytes32 m0;</span>
  1814 |     | <span class='neutral'>        bytes32 m1;</span>
  1815 |     | <span class='neutral'>        bytes32 m2;</span>
  1816 |     | <span class='neutral'>        bytes32 m3;</span>
  1817 |     | <span class='neutral'>        bytes32 m4;</span>
  1818 |     | <span class='neutral'>        bytes32 m5;</span>
  1819 |     | <span class='neutral'>        assembly {</span>
  1820 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1821 |     | <span class='neutral'>                let length := 0</span>
  1822 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1823 |     | <span class='neutral'>                mstore(pos, length)</span>
  1824 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1825 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1826 |     | <span class='neutral'>            }</span>
  1827 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1828 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1829 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1830 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1831 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1832 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1833 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string)`.</span>
  1834 |     | <span class='neutral'>            mstore(0x00, 0x85775021)</span>
  1835 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1836 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1837 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1838 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1839 |     | <span class='neutral'>        }</span>
  1840 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1841 |     | <span class='neutral'>        assembly {</span>
  1842 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1843 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1844 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1845 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1846 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1847 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1848 |     | <span class='neutral'>        }</span>
  1849 |     | <span class='neutral'>    }</span>
  1850 |     | <span class='neutral'></span>
  1851 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal pure {</span>
  1852 |     | <span class='neutral'>        bytes32 m0;</span>
  1853 |     | <span class='neutral'>        bytes32 m1;</span>
  1854 |     | <span class='neutral'>        bytes32 m2;</span>
  1855 |     | <span class='neutral'>        bytes32 m3;</span>
  1856 |     | <span class='neutral'>        assembly {</span>
  1857 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1858 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1859 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1860 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1861 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address)`.</span>
  1862 |     | <span class='neutral'>            mstore(0x00, 0x5c96b331)</span>
  1863 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1864 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1865 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1866 |     | <span class='neutral'>        }</span>
  1867 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1868 |     | <span class='neutral'>        assembly {</span>
  1869 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1870 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1871 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1872 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1873 |     | <span class='neutral'>        }</span>
  1874 |     | <span class='neutral'>    }</span>
  1875 |     | <span class='neutral'></span>
  1876 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal pure {</span>
  1877 |     | <span class='neutral'>        bytes32 m0;</span>
  1878 |     | <span class='neutral'>        bytes32 m1;</span>
  1879 |     | <span class='neutral'>        bytes32 m2;</span>
  1880 |     | <span class='neutral'>        bytes32 m3;</span>
  1881 |     | <span class='neutral'>        assembly {</span>
  1882 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1883 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1884 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1885 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1886 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool)`.</span>
  1887 |     | <span class='neutral'>            mstore(0x00, 0x4766da72)</span>
  1888 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1889 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1890 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1891 |     | <span class='neutral'>        }</span>
  1892 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1893 |     | <span class='neutral'>        assembly {</span>
  1894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1898 |     | <span class='neutral'>        }</span>
  1899 |     | <span class='neutral'>    }</span>
  1900 |     | <span class='neutral'></span>
  1901 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {</span>
  1902 |     | <span class='neutral'>        bytes32 m0;</span>
  1903 |     | <span class='neutral'>        bytes32 m1;</span>
  1904 |     | <span class='neutral'>        bytes32 m2;</span>
  1905 |     | <span class='neutral'>        bytes32 m3;</span>
  1906 |     | <span class='neutral'>        assembly {</span>
  1907 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1908 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1909 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1910 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1911 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256)`.</span>
  1912 |     | <span class='neutral'>            mstore(0x00, 0xd1ed7a3c)</span>
  1913 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1914 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1915 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1916 |     | <span class='neutral'>        }</span>
  1917 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1918 |     | <span class='neutral'>        assembly {</span>
  1919 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1920 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1921 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1922 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1923 |     | <span class='neutral'>        }</span>
  1924 |     | <span class='neutral'>    }</span>
  1925 |     | <span class='neutral'></span>
  1926 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {</span>
  1927 |     | <span class='neutral'>        bytes32 m0;</span>
  1928 |     | <span class='neutral'>        bytes32 m1;</span>
  1929 |     | <span class='neutral'>        bytes32 m2;</span>
  1930 |     | <span class='neutral'>        bytes32 m3;</span>
  1931 |     | <span class='neutral'>        bytes32 m4;</span>
  1932 |     | <span class='neutral'>        bytes32 m5;</span>
  1933 |     | <span class='neutral'>        assembly {</span>
  1934 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1935 |     | <span class='neutral'>                let length := 0</span>
  1936 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1937 |     | <span class='neutral'>                mstore(pos, length)</span>
  1938 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1939 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1940 |     | <span class='neutral'>            }</span>
  1941 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1942 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1943 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1944 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1945 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1946 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1947 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string)`.</span>
  1948 |     | <span class='neutral'>            mstore(0x00, 0x71d04af2)</span>
  1949 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1950 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1951 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1952 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1953 |     | <span class='neutral'>        }</span>
  1954 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1955 |     | <span class='neutral'>        assembly {</span>
  1956 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1957 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1958 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1959 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1960 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1961 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1962 |     | <span class='neutral'>        }</span>
  1963 |     | <span class='neutral'>    }</span>
  1964 |     | <span class='neutral'></span>
  1965 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2) internal pure {</span>
  1966 |     | <span class='neutral'>        bytes32 m0;</span>
  1967 |     | <span class='neutral'>        bytes32 m1;</span>
  1968 |     | <span class='neutral'>        bytes32 m2;</span>
  1969 |     | <span class='neutral'>        bytes32 m3;</span>
  1970 |     | <span class='neutral'>        bytes32 m4;</span>
  1971 |     | <span class='neutral'>        bytes32 m5;</span>
  1972 |     | <span class='neutral'>        assembly {</span>
  1973 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1974 |     | <span class='neutral'>                let length := 0</span>
  1975 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1976 |     | <span class='neutral'>                mstore(pos, length)</span>
  1977 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1978 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1979 |     | <span class='neutral'>            }</span>
  1980 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1981 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1982 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1983 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1984 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1985 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1986 |     | <span class='neutral'>            // Selector of `log(uint256,string,address)`.</span>
  1987 |     | <span class='neutral'>            mstore(0x00, 0x7afac959)</span>
  1988 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1989 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1990 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1991 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1992 |     | <span class='neutral'>        }</span>
  1993 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1994 |     | <span class='neutral'>        assembly {</span>
  1995 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1996 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1997 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1998 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1999 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2000 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2001 |     | <span class='neutral'>        }</span>
  2002 |     | <span class='neutral'>    }</span>
  2003 |     | <span class='neutral'></span>
  2004 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2) internal pure {</span>
  2005 |     | <span class='neutral'>        bytes32 m0;</span>
  2006 |     | <span class='neutral'>        bytes32 m1;</span>
  2007 |     | <span class='neutral'>        bytes32 m2;</span>
  2008 |     | <span class='neutral'>        bytes32 m3;</span>
  2009 |     | <span class='neutral'>        bytes32 m4;</span>
  2010 |     | <span class='neutral'>        bytes32 m5;</span>
  2011 |     | <span class='neutral'>        assembly {</span>
  2012 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2013 |     | <span class='neutral'>                let length := 0</span>
  2014 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2015 |     | <span class='neutral'>                mstore(pos, length)</span>
  2016 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2017 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2018 |     | <span class='neutral'>            }</span>
  2019 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2020 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2021 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2022 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2023 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2024 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2025 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool)`.</span>
  2026 |     | <span class='neutral'>            mstore(0x00, 0x4ceda75a)</span>
  2027 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2028 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2029 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2030 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2031 |     | <span class='neutral'>        }</span>
  2032 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2033 |     | <span class='neutral'>        assembly {</span>
  2034 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2035 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2036 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2037 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2038 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2039 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2040 |     | <span class='neutral'>        }</span>
  2041 |     | <span class='neutral'>    }</span>
  2042 |     | <span class='neutral'></span>
  2043 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2044 |     | <span class='neutral'>        bytes32 m0;</span>
  2045 |     | <span class='neutral'>        bytes32 m1;</span>
  2046 |     | <span class='neutral'>        bytes32 m2;</span>
  2047 |     | <span class='neutral'>        bytes32 m3;</span>
  2048 |     | <span class='neutral'>        bytes32 m4;</span>
  2049 |     | <span class='neutral'>        bytes32 m5;</span>
  2050 |     | <span class='neutral'>        assembly {</span>
  2051 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2052 |     | <span class='neutral'>                let length := 0</span>
  2053 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2054 |     | <span class='neutral'>                mstore(pos, length)</span>
  2055 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2056 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2057 |     | <span class='neutral'>            }</span>
  2058 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2059 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2060 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2061 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2062 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2063 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2064 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256)`.</span>
  2065 |     | <span class='neutral'>            mstore(0x00, 0x37aa7d4c)</span>
  2066 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2067 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2068 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2069 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2070 |     | <span class='neutral'>        }</span>
  2071 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2072 |     | <span class='neutral'>        assembly {</span>
  2073 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2074 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2075 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2076 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2077 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2078 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2079 |     | <span class='neutral'>        }</span>
  2080 |     | <span class='neutral'>    }</span>
  2081 |     | <span class='neutral'></span>
  2082 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2083 |     | <span class='neutral'>        bytes32 m0;</span>
  2084 |     | <span class='neutral'>        bytes32 m1;</span>
  2085 |     | <span class='neutral'>        bytes32 m2;</span>
  2086 |     | <span class='neutral'>        bytes32 m3;</span>
  2087 |     | <span class='neutral'>        bytes32 m4;</span>
  2088 |     | <span class='neutral'>        bytes32 m5;</span>
  2089 |     | <span class='neutral'>        bytes32 m6;</span>
  2090 |     | <span class='neutral'>        bytes32 m7;</span>
  2091 |     | <span class='neutral'>        assembly {</span>
  2092 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2093 |     | <span class='neutral'>                let length := 0</span>
  2094 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2095 |     | <span class='neutral'>                mstore(pos, length)</span>
  2096 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2097 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2098 |     | <span class='neutral'>            }</span>
  2099 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2100 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2101 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2102 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2103 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2104 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2105 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2106 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2107 |     | <span class='neutral'>            // Selector of `log(uint256,string,string)`.</span>
  2108 |     | <span class='neutral'>            mstore(0x00, 0xb115611f)</span>
  2109 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2110 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2111 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2112 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2113 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2114 |     | <span class='neutral'>        }</span>
  2115 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2116 |     | <span class='neutral'>        assembly {</span>
  2117 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2118 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2119 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2120 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2121 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2122 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2123 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2124 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2125 |     | <span class='neutral'>        }</span>
  2126 |     | <span class='neutral'>    }</span>
  2127 |     | <span class='neutral'></span>
  2128 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2) internal pure {</span>
  2129 |     | <span class='neutral'>        bytes32 m0;</span>
  2130 |     | <span class='neutral'>        bytes32 m1;</span>
  2131 |     | <span class='neutral'>        bytes32 m2;</span>
  2132 |     | <span class='neutral'>        bytes32 m3;</span>
  2133 |     | <span class='neutral'>        bytes32 m4;</span>
  2134 |     | <span class='neutral'>        bytes32 m5;</span>
  2135 |     | <span class='neutral'>        assembly {</span>
  2136 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2137 |     | <span class='neutral'>                let length := 0</span>
  2138 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2139 |     | <span class='neutral'>                mstore(pos, length)</span>
  2140 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2141 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2142 |     | <span class='neutral'>            }</span>
  2143 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2144 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2145 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2146 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2147 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2148 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2149 |     | <span class='neutral'>            // Selector of `log(string,address,address)`.</span>
  2150 |     | <span class='neutral'>            mstore(0x00, 0xfcec75e0)</span>
  2151 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2152 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2153 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2154 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2155 |     | <span class='neutral'>        }</span>
  2156 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2157 |     | <span class='neutral'>        assembly {</span>
  2158 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2159 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2160 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2161 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2162 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2163 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2164 |     | <span class='neutral'>        }</span>
  2165 |     | <span class='neutral'>    }</span>
  2166 |     | <span class='neutral'></span>
  2167 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2) internal pure {</span>
  2168 |     | <span class='neutral'>        bytes32 m0;</span>
  2169 |     | <span class='neutral'>        bytes32 m1;</span>
  2170 |     | <span class='neutral'>        bytes32 m2;</span>
  2171 |     | <span class='neutral'>        bytes32 m3;</span>
  2172 |     | <span class='neutral'>        bytes32 m4;</span>
  2173 |     | <span class='neutral'>        bytes32 m5;</span>
  2174 |     | <span class='neutral'>        assembly {</span>
  2175 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2176 |     | <span class='neutral'>                let length := 0</span>
  2177 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2178 |     | <span class='neutral'>                mstore(pos, length)</span>
  2179 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2180 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2181 |     | <span class='neutral'>            }</span>
  2182 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2183 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2184 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2185 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2186 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2187 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2188 |     | <span class='neutral'>            // Selector of `log(string,address,bool)`.</span>
  2189 |     | <span class='neutral'>            mstore(0x00, 0xc91d5ed4)</span>
  2190 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2191 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2192 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2193 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2194 |     | <span class='neutral'>        }</span>
  2195 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2196 |     | <span class='neutral'>        assembly {</span>
  2197 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2198 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2199 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2200 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2201 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2202 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2203 |     | <span class='neutral'>        }</span>
  2204 |     | <span class='neutral'>    }</span>
  2205 |     | <span class='neutral'></span>
  2206 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2) internal pure {</span>
  2207 |     | <span class='neutral'>        bytes32 m0;</span>
  2208 |     | <span class='neutral'>        bytes32 m1;</span>
  2209 |     | <span class='neutral'>        bytes32 m2;</span>
  2210 |     | <span class='neutral'>        bytes32 m3;</span>
  2211 |     | <span class='neutral'>        bytes32 m4;</span>
  2212 |     | <span class='neutral'>        bytes32 m5;</span>
  2213 |     | <span class='neutral'>        assembly {</span>
  2214 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2215 |     | <span class='neutral'>                let length := 0</span>
  2216 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2217 |     | <span class='neutral'>                mstore(pos, length)</span>
  2218 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2219 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2220 |     | <span class='neutral'>            }</span>
  2221 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2222 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2223 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2224 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2225 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2226 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2227 |     | <span class='neutral'>            // Selector of `log(string,address,uint256)`.</span>
  2228 |     | <span class='neutral'>            mstore(0x00, 0x0d26b925)</span>
  2229 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2230 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2231 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2232 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2233 |     | <span class='neutral'>        }</span>
  2234 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2235 |     | <span class='neutral'>        assembly {</span>
  2236 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2237 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2238 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2239 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2240 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2241 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2242 |     | <span class='neutral'>        }</span>
  2243 |     | <span class='neutral'>    }</span>
  2244 |     | <span class='neutral'></span>
  2245 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2) internal pure {</span>
  2246 |     | <span class='neutral'>        bytes32 m0;</span>
  2247 |     | <span class='neutral'>        bytes32 m1;</span>
  2248 |     | <span class='neutral'>        bytes32 m2;</span>
  2249 |     | <span class='neutral'>        bytes32 m3;</span>
  2250 |     | <span class='neutral'>        bytes32 m4;</span>
  2251 |     | <span class='neutral'>        bytes32 m5;</span>
  2252 |     | <span class='neutral'>        bytes32 m6;</span>
  2253 |     | <span class='neutral'>        bytes32 m7;</span>
  2254 |     | <span class='neutral'>        assembly {</span>
  2255 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2256 |     | <span class='neutral'>                let length := 0</span>
  2257 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2258 |     | <span class='neutral'>                mstore(pos, length)</span>
  2259 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2260 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2261 |     | <span class='neutral'>            }</span>
  2262 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2263 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2264 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2265 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2266 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2267 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2268 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2269 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2270 |     | <span class='neutral'>            // Selector of `log(string,address,string)`.</span>
  2271 |     | <span class='neutral'>            mstore(0x00, 0xe0e9ad4f)</span>
  2272 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2273 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2274 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2275 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2276 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2277 |     | <span class='neutral'>        }</span>
  2278 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2279 |     | <span class='neutral'>        assembly {</span>
  2280 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2281 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2282 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2283 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2284 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2285 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2286 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2287 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2288 |     | <span class='neutral'>        }</span>
  2289 |     | <span class='neutral'>    }</span>
  2290 |     | <span class='neutral'></span>
  2291 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2) internal pure {</span>
  2292 |     | <span class='neutral'>        bytes32 m0;</span>
  2293 |     | <span class='neutral'>        bytes32 m1;</span>
  2294 |     | <span class='neutral'>        bytes32 m2;</span>
  2295 |     | <span class='neutral'>        bytes32 m3;</span>
  2296 |     | <span class='neutral'>        bytes32 m4;</span>
  2297 |     | <span class='neutral'>        bytes32 m5;</span>
  2298 |     | <span class='neutral'>        assembly {</span>
  2299 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2300 |     | <span class='neutral'>                let length := 0</span>
  2301 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2302 |     | <span class='neutral'>                mstore(pos, length)</span>
  2303 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2304 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2305 |     | <span class='neutral'>            }</span>
  2306 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2307 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2308 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2309 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2310 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2311 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2312 |     | <span class='neutral'>            // Selector of `log(string,bool,address)`.</span>
  2313 |     | <span class='neutral'>            mstore(0x00, 0x932bbb38)</span>
  2314 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2315 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2316 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2317 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2318 |     | <span class='neutral'>        }</span>
  2319 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2320 |     | <span class='neutral'>        assembly {</span>
  2321 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2322 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2323 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2324 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2325 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2326 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2327 |     | <span class='neutral'>        }</span>
  2328 |     | <span class='neutral'>    }</span>
  2329 |     | <span class='neutral'></span>
  2330 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2) internal pure {</span>
  2331 |     | <span class='neutral'>        bytes32 m0;</span>
  2332 |     | <span class='neutral'>        bytes32 m1;</span>
  2333 |     | <span class='neutral'>        bytes32 m2;</span>
  2334 |     | <span class='neutral'>        bytes32 m3;</span>
  2335 |     | <span class='neutral'>        bytes32 m4;</span>
  2336 |     | <span class='neutral'>        bytes32 m5;</span>
  2337 |     | <span class='neutral'>        assembly {</span>
  2338 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2339 |     | <span class='neutral'>                let length := 0</span>
  2340 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2341 |     | <span class='neutral'>                mstore(pos, length)</span>
  2342 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2343 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2344 |     | <span class='neutral'>            }</span>
  2345 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2346 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2347 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2348 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2349 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2350 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2351 |     | <span class='neutral'>            // Selector of `log(string,bool,bool)`.</span>
  2352 |     | <span class='neutral'>            mstore(0x00, 0x850b7ad6)</span>
  2353 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2354 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2355 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2356 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2357 |     | <span class='neutral'>        }</span>
  2358 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2359 |     | <span class='neutral'>        assembly {</span>
  2360 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2361 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2362 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2363 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2364 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2365 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2366 |     | <span class='neutral'>        }</span>
  2367 |     | <span class='neutral'>    }</span>
  2368 |     | <span class='neutral'></span>
  2369 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2) internal pure {</span>
  2370 |     | <span class='neutral'>        bytes32 m0;</span>
  2371 |     | <span class='neutral'>        bytes32 m1;</span>
  2372 |     | <span class='neutral'>        bytes32 m2;</span>
  2373 |     | <span class='neutral'>        bytes32 m3;</span>
  2374 |     | <span class='neutral'>        bytes32 m4;</span>
  2375 |     | <span class='neutral'>        bytes32 m5;</span>
  2376 |     | <span class='neutral'>        assembly {</span>
  2377 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2378 |     | <span class='neutral'>                let length := 0</span>
  2379 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2380 |     | <span class='neutral'>                mstore(pos, length)</span>
  2381 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2382 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2383 |     | <span class='neutral'>            }</span>
  2384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2389 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2390 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256)`.</span>
  2391 |     | <span class='neutral'>            mstore(0x00, 0xc95958d6)</span>
  2392 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2393 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2394 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2395 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2396 |     | <span class='neutral'>        }</span>
  2397 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2398 |     | <span class='neutral'>        assembly {</span>
  2399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2404 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2405 |     | <span class='neutral'>        }</span>
  2406 |     | <span class='neutral'>    }</span>
  2407 |     | <span class='neutral'></span>
  2408 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {</span>
  2409 |     | <span class='neutral'>        bytes32 m0;</span>
  2410 |     | <span class='neutral'>        bytes32 m1;</span>
  2411 |     | <span class='neutral'>        bytes32 m2;</span>
  2412 |     | <span class='neutral'>        bytes32 m3;</span>
  2413 |     | <span class='neutral'>        bytes32 m4;</span>
  2414 |     | <span class='neutral'>        bytes32 m5;</span>
  2415 |     | <span class='neutral'>        bytes32 m6;</span>
  2416 |     | <span class='neutral'>        bytes32 m7;</span>
  2417 |     | <span class='neutral'>        assembly {</span>
  2418 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2419 |     | <span class='neutral'>                let length := 0</span>
  2420 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2421 |     | <span class='neutral'>                mstore(pos, length)</span>
  2422 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2423 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2424 |     | <span class='neutral'>            }</span>
  2425 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2426 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2427 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2428 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2429 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2430 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2431 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2432 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2433 |     | <span class='neutral'>            // Selector of `log(string,bool,string)`.</span>
  2434 |     | <span class='neutral'>            mstore(0x00, 0xe298f47d)</span>
  2435 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2436 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2437 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2438 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2439 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2440 |     | <span class='neutral'>        }</span>
  2441 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2442 |     | <span class='neutral'>        assembly {</span>
  2443 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2444 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2445 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2446 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2447 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2448 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2449 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2450 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2451 |     | <span class='neutral'>        }</span>
  2452 |     | <span class='neutral'>    }</span>
  2453 |     | <span class='neutral'></span>
  2454 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2) internal pure {</span>
  2455 |     | <span class='neutral'>        bytes32 m0;</span>
  2456 |     | <span class='neutral'>        bytes32 m1;</span>
  2457 |     | <span class='neutral'>        bytes32 m2;</span>
  2458 |     | <span class='neutral'>        bytes32 m3;</span>
  2459 |     | <span class='neutral'>        bytes32 m4;</span>
  2460 |     | <span class='neutral'>        bytes32 m5;</span>
  2461 |     | <span class='neutral'>        assembly {</span>
  2462 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2463 |     | <span class='neutral'>                let length := 0</span>
  2464 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2465 |     | <span class='neutral'>                mstore(pos, length)</span>
  2466 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2467 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2468 |     | <span class='neutral'>            }</span>
  2469 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2470 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2471 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2472 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2473 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2474 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2475 |     | <span class='neutral'>            // Selector of `log(string,uint256,address)`.</span>
  2476 |     | <span class='neutral'>            mstore(0x00, 0x1c7ec448)</span>
  2477 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2478 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2479 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2480 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2481 |     | <span class='neutral'>        }</span>
  2482 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2483 |     | <span class='neutral'>        assembly {</span>
  2484 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2485 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2486 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2487 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2488 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2489 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2490 |     | <span class='neutral'>        }</span>
  2491 |     | <span class='neutral'>    }</span>
  2492 |     | <span class='neutral'></span>
  2493 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2) internal pure {</span>
  2494 |     | <span class='neutral'>        bytes32 m0;</span>
  2495 |     | <span class='neutral'>        bytes32 m1;</span>
  2496 |     | <span class='neutral'>        bytes32 m2;</span>
  2497 |     | <span class='neutral'>        bytes32 m3;</span>
  2498 |     | <span class='neutral'>        bytes32 m4;</span>
  2499 |     | <span class='neutral'>        bytes32 m5;</span>
  2500 |     | <span class='neutral'>        assembly {</span>
  2501 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2502 |     | <span class='neutral'>                let length := 0</span>
  2503 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2504 |     | <span class='neutral'>                mstore(pos, length)</span>
  2505 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2506 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2507 |     | <span class='neutral'>            }</span>
  2508 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2509 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2510 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2511 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2512 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2513 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2514 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool)`.</span>
  2515 |     | <span class='neutral'>            mstore(0x00, 0xca7733b1)</span>
  2516 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2517 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2518 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2519 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2520 |     | <span class='neutral'>        }</span>
  2521 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2522 |     | <span class='neutral'>        assembly {</span>
  2523 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2524 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2525 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2526 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2527 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2528 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2529 |     | <span class='neutral'>        }</span>
  2530 |     | <span class='neutral'>    }</span>
  2531 |     | <span class='neutral'></span>
  2532 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {</span>
  2533 |     | <span class='neutral'>        bytes32 m0;</span>
  2534 |     | <span class='neutral'>        bytes32 m1;</span>
  2535 |     | <span class='neutral'>        bytes32 m2;</span>
  2536 |     | <span class='neutral'>        bytes32 m3;</span>
  2537 |     | <span class='neutral'>        bytes32 m4;</span>
  2538 |     | <span class='neutral'>        bytes32 m5;</span>
  2539 |     | <span class='neutral'>        assembly {</span>
  2540 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2541 |     | <span class='neutral'>                let length := 0</span>
  2542 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2543 |     | <span class='neutral'>                mstore(pos, length)</span>
  2544 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2545 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2546 |     | <span class='neutral'>            }</span>
  2547 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2548 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2549 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2550 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2551 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2552 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2553 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256)`.</span>
  2554 |     | <span class='neutral'>            mstore(0x00, 0xca47c4eb)</span>
  2555 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2556 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2557 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2558 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2559 |     | <span class='neutral'>        }</span>
  2560 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2561 |     | <span class='neutral'>        assembly {</span>
  2562 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2563 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2564 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2565 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2566 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2567 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2568 |     | <span class='neutral'>        }</span>
  2569 |     | <span class='neutral'>    }</span>
  2570 |     | <span class='neutral'></span>
  2571 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {</span>
  2572 |     | <span class='neutral'>        bytes32 m0;</span>
  2573 |     | <span class='neutral'>        bytes32 m1;</span>
  2574 |     | <span class='neutral'>        bytes32 m2;</span>
  2575 |     | <span class='neutral'>        bytes32 m3;</span>
  2576 |     | <span class='neutral'>        bytes32 m4;</span>
  2577 |     | <span class='neutral'>        bytes32 m5;</span>
  2578 |     | <span class='neutral'>        bytes32 m6;</span>
  2579 |     | <span class='neutral'>        bytes32 m7;</span>
  2580 |     | <span class='neutral'>        assembly {</span>
  2581 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2582 |     | <span class='neutral'>                let length := 0</span>
  2583 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2584 |     | <span class='neutral'>                mstore(pos, length)</span>
  2585 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2586 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2587 |     | <span class='neutral'>            }</span>
  2588 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2589 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2590 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2591 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2592 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2593 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2594 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2595 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2596 |     | <span class='neutral'>            // Selector of `log(string,uint256,string)`.</span>
  2597 |     | <span class='neutral'>            mstore(0x00, 0x5970e089)</span>
  2598 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2599 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2600 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2601 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2602 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2603 |     | <span class='neutral'>        }</span>
  2604 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2605 |     | <span class='neutral'>        assembly {</span>
  2606 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2607 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2608 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2609 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2610 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2611 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2612 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2613 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2614 |     | <span class='neutral'>        }</span>
  2615 |     | <span class='neutral'>    }</span>
  2616 |     | <span class='neutral'></span>
  2617 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2) internal pure {</span>
  2618 |     | <span class='neutral'>        bytes32 m0;</span>
  2619 |     | <span class='neutral'>        bytes32 m1;</span>
  2620 |     | <span class='neutral'>        bytes32 m2;</span>
  2621 |     | <span class='neutral'>        bytes32 m3;</span>
  2622 |     | <span class='neutral'>        bytes32 m4;</span>
  2623 |     | <span class='neutral'>        bytes32 m5;</span>
  2624 |     | <span class='neutral'>        bytes32 m6;</span>
  2625 |     | <span class='neutral'>        bytes32 m7;</span>
  2626 |     | <span class='neutral'>        assembly {</span>
  2627 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2628 |     | <span class='neutral'>                let length := 0</span>
  2629 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2630 |     | <span class='neutral'>                mstore(pos, length)</span>
  2631 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2632 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2633 |     | <span class='neutral'>            }</span>
  2634 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2635 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2636 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2637 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2638 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2639 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2640 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2641 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2642 |     | <span class='neutral'>            // Selector of `log(string,string,address)`.</span>
  2643 |     | <span class='neutral'>            mstore(0x00, 0x95ed0195)</span>
  2644 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2645 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2646 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2647 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2648 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2649 |     | <span class='neutral'>        }</span>
  2650 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2651 |     | <span class='neutral'>        assembly {</span>
  2652 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2653 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2654 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2655 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2656 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2657 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2658 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2659 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2660 |     | <span class='neutral'>        }</span>
  2661 |     | <span class='neutral'>    }</span>
  2662 |     | <span class='neutral'></span>
  2663 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {</span>
  2664 |     | <span class='neutral'>        bytes32 m0;</span>
  2665 |     | <span class='neutral'>        bytes32 m1;</span>
  2666 |     | <span class='neutral'>        bytes32 m2;</span>
  2667 |     | <span class='neutral'>        bytes32 m3;</span>
  2668 |     | <span class='neutral'>        bytes32 m4;</span>
  2669 |     | <span class='neutral'>        bytes32 m5;</span>
  2670 |     | <span class='neutral'>        bytes32 m6;</span>
  2671 |     | <span class='neutral'>        bytes32 m7;</span>
  2672 |     | <span class='neutral'>        assembly {</span>
  2673 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2674 |     | <span class='neutral'>                let length := 0</span>
  2675 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2676 |     | <span class='neutral'>                mstore(pos, length)</span>
  2677 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2678 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2679 |     | <span class='neutral'>            }</span>
  2680 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2681 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2682 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2683 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2684 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2685 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2686 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2687 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2688 |     | <span class='neutral'>            // Selector of `log(string,string,bool)`.</span>
  2689 |     | <span class='neutral'>            mstore(0x00, 0xb0e0f9b5)</span>
  2690 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2691 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2692 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2693 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2694 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2695 |     | <span class='neutral'>        }</span>
  2696 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2697 |     | <span class='neutral'>        assembly {</span>
  2698 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2699 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2700 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2701 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2702 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2703 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2704 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2705 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2706 |     | <span class='neutral'>        }</span>
  2707 |     | <span class='neutral'>    }</span>
  2708 |     | <span class='neutral'></span>
  2709 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2710 |     | <span class='neutral'>        bytes32 m0;</span>
  2711 |     | <span class='neutral'>        bytes32 m1;</span>
  2712 |     | <span class='neutral'>        bytes32 m2;</span>
  2713 |     | <span class='neutral'>        bytes32 m3;</span>
  2714 |     | <span class='neutral'>        bytes32 m4;</span>
  2715 |     | <span class='neutral'>        bytes32 m5;</span>
  2716 |     | <span class='neutral'>        bytes32 m6;</span>
  2717 |     | <span class='neutral'>        bytes32 m7;</span>
  2718 |     | <span class='neutral'>        assembly {</span>
  2719 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2720 |     | <span class='neutral'>                let length := 0</span>
  2721 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2722 |     | <span class='neutral'>                mstore(pos, length)</span>
  2723 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2724 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2725 |     | <span class='neutral'>            }</span>
  2726 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2727 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2728 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2729 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2730 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2731 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2732 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2733 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2734 |     | <span class='neutral'>            // Selector of `log(string,string,uint256)`.</span>
  2735 |     | <span class='neutral'>            mstore(0x00, 0x5821efa1)</span>
  2736 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2737 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2738 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2739 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2740 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2741 |     | <span class='neutral'>        }</span>
  2742 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2743 |     | <span class='neutral'>        assembly {</span>
  2744 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2745 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2746 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2747 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2748 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2749 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2750 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2751 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2752 |     | <span class='neutral'>        }</span>
  2753 |     | <span class='neutral'>    }</span>
  2754 |     | <span class='neutral'></span>
  2755 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2756 |     | <span class='neutral'>        bytes32 m0;</span>
  2757 |     | <span class='neutral'>        bytes32 m1;</span>
  2758 |     | <span class='neutral'>        bytes32 m2;</span>
  2759 |     | <span class='neutral'>        bytes32 m3;</span>
  2760 |     | <span class='neutral'>        bytes32 m4;</span>
  2761 |     | <span class='neutral'>        bytes32 m5;</span>
  2762 |     | <span class='neutral'>        bytes32 m6;</span>
  2763 |     | <span class='neutral'>        bytes32 m7;</span>
  2764 |     | <span class='neutral'>        bytes32 m8;</span>
  2765 |     | <span class='neutral'>        bytes32 m9;</span>
  2766 |     | <span class='neutral'>        assembly {</span>
  2767 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2768 |     | <span class='neutral'>                let length := 0</span>
  2769 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2770 |     | <span class='neutral'>                mstore(pos, length)</span>
  2771 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2772 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2773 |     | <span class='neutral'>            }</span>
  2774 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2775 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2776 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2777 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2778 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2779 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2780 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2781 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2782 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  2783 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  2784 |     | <span class='neutral'>            // Selector of `log(string,string,string)`.</span>
  2785 |     | <span class='neutral'>            mstore(0x00, 0x2ced7cef)</span>
  2786 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2787 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2788 |     | <span class='neutral'>            mstore(0x60, 0xe0)</span>
  2789 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2790 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2791 |     | <span class='neutral'>            writeString(0x100, p2)</span>
  2792 |     | <span class='neutral'>        }</span>
  2793 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x124);</span>
  2794 |     | <span class='neutral'>        assembly {</span>
  2795 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2796 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2797 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2798 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2799 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2800 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2801 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2802 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2803 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  2804 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  2805 |     | <span class='neutral'>        }</span>
  2806 |     | <span class='neutral'>    }</span>
  2807 |     | <span class='neutral'></span>
  2808 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
  2809 |     | <span class='neutral'>        bytes32 m0;</span>
  2810 |     | <span class='neutral'>        bytes32 m1;</span>
  2811 |     | <span class='neutral'>        bytes32 m2;</span>
  2812 |     | <span class='neutral'>        bytes32 m3;</span>
  2813 |     | <span class='neutral'>        bytes32 m4;</span>
  2814 |     | <span class='neutral'>        assembly {</span>
  2815 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2816 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2817 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2818 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2819 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2820 |     | <span class='neutral'>            // Selector of `log(address,address,address,address)`.</span>
  2821 |     | <span class='neutral'>            mstore(0x00, 0x665bf134)</span>
  2822 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2823 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2824 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2825 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2826 |     | <span class='neutral'>        }</span>
  2827 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2828 |     | <span class='neutral'>        assembly {</span>
  2829 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2830 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2831 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2832 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2833 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2834 |     | <span class='neutral'>        }</span>
  2835 |     | <span class='neutral'>    }</span>
  2836 |     | <span class='neutral'></span>
  2837 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
  2838 |     | <span class='neutral'>        bytes32 m0;</span>
  2839 |     | <span class='neutral'>        bytes32 m1;</span>
  2840 |     | <span class='neutral'>        bytes32 m2;</span>
  2841 |     | <span class='neutral'>        bytes32 m3;</span>
  2842 |     | <span class='neutral'>        bytes32 m4;</span>
  2843 |     | <span class='neutral'>        assembly {</span>
  2844 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2845 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2846 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2847 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2848 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2849 |     | <span class='neutral'>            // Selector of `log(address,address,address,bool)`.</span>
  2850 |     | <span class='neutral'>            mstore(0x00, 0x0e378994)</span>
  2851 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2852 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2853 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2854 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2855 |     | <span class='neutral'>        }</span>
  2856 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2857 |     | <span class='neutral'>        assembly {</span>
  2858 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2859 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2860 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2861 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2862 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2863 |     | <span class='neutral'>        }</span>
  2864 |     | <span class='neutral'>    }</span>
  2865 |     | <span class='neutral'></span>
  2866 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal pure {</span>
  2867 |     | <span class='neutral'>        bytes32 m0;</span>
  2868 |     | <span class='neutral'>        bytes32 m1;</span>
  2869 |     | <span class='neutral'>        bytes32 m2;</span>
  2870 |     | <span class='neutral'>        bytes32 m3;</span>
  2871 |     | <span class='neutral'>        bytes32 m4;</span>
  2872 |     | <span class='neutral'>        assembly {</span>
  2873 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2874 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2875 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2876 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2877 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2878 |     | <span class='neutral'>            // Selector of `log(address,address,address,uint256)`.</span>
  2879 |     | <span class='neutral'>            mstore(0x00, 0x94250d77)</span>
  2880 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2881 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2882 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2883 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2884 |     | <span class='neutral'>        }</span>
  2885 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2886 |     | <span class='neutral'>        assembly {</span>
  2887 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2888 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2889 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2890 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2891 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2892 |     | <span class='neutral'>        }</span>
  2893 |     | <span class='neutral'>    }</span>
  2894 |     | <span class='neutral'></span>
  2895 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bytes32 p3) internal pure {</span>
  2896 |     | <span class='neutral'>        bytes32 m0;</span>
  2897 |     | <span class='neutral'>        bytes32 m1;</span>
  2898 |     | <span class='neutral'>        bytes32 m2;</span>
  2899 |     | <span class='neutral'>        bytes32 m3;</span>
  2900 |     | <span class='neutral'>        bytes32 m4;</span>
  2901 |     | <span class='neutral'>        bytes32 m5;</span>
  2902 |     | <span class='neutral'>        bytes32 m6;</span>
  2903 |     | <span class='neutral'>        assembly {</span>
  2904 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2905 |     | <span class='neutral'>                let length := 0</span>
  2906 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2907 |     | <span class='neutral'>                mstore(pos, length)</span>
  2908 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2909 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2910 |     | <span class='neutral'>            }</span>
  2911 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2912 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2913 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2914 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2915 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2916 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2917 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2918 |     | <span class='neutral'>            // Selector of `log(address,address,address,string)`.</span>
  2919 |     | <span class='neutral'>            mstore(0x00, 0xf808da20)</span>
  2920 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2921 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2922 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2923 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  2924 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  2925 |     | <span class='neutral'>        }</span>
  2926 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  2927 |     | <span class='neutral'>        assembly {</span>
  2928 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2929 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2930 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2931 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2932 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2933 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2934 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2935 |     | <span class='neutral'>        }</span>
  2936 |     | <span class='neutral'>    }</span>
  2937 |     | <span class='neutral'></span>
  2938 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
  2939 |     | <span class='neutral'>        bytes32 m0;</span>
  2940 |     | <span class='neutral'>        bytes32 m1;</span>
  2941 |     | <span class='neutral'>        bytes32 m2;</span>
  2942 |     | <span class='neutral'>        bytes32 m3;</span>
  2943 |     | <span class='neutral'>        bytes32 m4;</span>
  2944 |     | <span class='neutral'>        assembly {</span>
  2945 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2946 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2947 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2948 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2949 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2950 |     | <span class='neutral'>            // Selector of `log(address,address,bool,address)`.</span>
  2951 |     | <span class='neutral'>            mstore(0x00, 0x9f1bc36e)</span>
  2952 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2953 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2954 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2955 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2956 |     | <span class='neutral'>        }</span>
  2957 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2958 |     | <span class='neutral'>        assembly {</span>
  2959 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2960 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2961 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2962 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2963 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2964 |     | <span class='neutral'>        }</span>
  2965 |     | <span class='neutral'>    }</span>
  2966 |     | <span class='neutral'></span>
  2967 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
  2968 |     | <span class='neutral'>        bytes32 m0;</span>
  2969 |     | <span class='neutral'>        bytes32 m1;</span>
  2970 |     | <span class='neutral'>        bytes32 m2;</span>
  2971 |     | <span class='neutral'>        bytes32 m3;</span>
  2972 |     | <span class='neutral'>        bytes32 m4;</span>
  2973 |     | <span class='neutral'>        assembly {</span>
  2974 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2975 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2976 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2977 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2978 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2979 |     | <span class='neutral'>            // Selector of `log(address,address,bool,bool)`.</span>
  2980 |     | <span class='neutral'>            mstore(0x00, 0x2cd4134a)</span>
  2981 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2982 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2983 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2984 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2985 |     | <span class='neutral'>        }</span>
  2986 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2987 |     | <span class='neutral'>        assembly {</span>
  2988 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2989 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2990 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2991 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2992 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2993 |     | <span class='neutral'>        }</span>
  2994 |     | <span class='neutral'>    }</span>
  2995 |     | <span class='neutral'></span>
  2996 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal pure {</span>
  2997 |     | <span class='neutral'>        bytes32 m0;</span>
  2998 |     | <span class='neutral'>        bytes32 m1;</span>
  2999 |     | <span class='neutral'>        bytes32 m2;</span>
  3000 |     | <span class='neutral'>        bytes32 m3;</span>
  3001 |     | <span class='neutral'>        bytes32 m4;</span>
  3002 |     | <span class='neutral'>        assembly {</span>
  3003 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3004 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3005 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3006 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3007 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3008 |     | <span class='neutral'>            // Selector of `log(address,address,bool,uint256)`.</span>
  3009 |     | <span class='neutral'>            mstore(0x00, 0x3971e78c)</span>
  3010 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3011 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3012 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3013 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3014 |     | <span class='neutral'>        }</span>
  3015 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3016 |     | <span class='neutral'>        assembly {</span>
  3017 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3018 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3019 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3020 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3021 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3022 |     | <span class='neutral'>        }</span>
  3023 |     | <span class='neutral'>    }</span>
  3024 |     | <span class='neutral'></span>
  3025 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  3026 |     | <span class='neutral'>        bytes32 m0;</span>
  3027 |     | <span class='neutral'>        bytes32 m1;</span>
  3028 |     | <span class='neutral'>        bytes32 m2;</span>
  3029 |     | <span class='neutral'>        bytes32 m3;</span>
  3030 |     | <span class='neutral'>        bytes32 m4;</span>
  3031 |     | <span class='neutral'>        bytes32 m5;</span>
  3032 |     | <span class='neutral'>        bytes32 m6;</span>
  3033 |     | <span class='neutral'>        assembly {</span>
  3034 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3035 |     | <span class='neutral'>                let length := 0</span>
  3036 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3037 |     | <span class='neutral'>                mstore(pos, length)</span>
  3038 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3039 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3040 |     | <span class='neutral'>            }</span>
  3041 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3042 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3043 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3044 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3045 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3046 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3047 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3048 |     | <span class='neutral'>            // Selector of `log(address,address,bool,string)`.</span>
  3049 |     | <span class='neutral'>            mstore(0x00, 0xaa6540c8)</span>
  3050 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3051 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3052 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3053 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3054 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3055 |     | <span class='neutral'>        }</span>
  3056 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3057 |     | <span class='neutral'>        assembly {</span>
  3058 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3059 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3060 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3061 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3062 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3063 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3064 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3065 |     | <span class='neutral'>        }</span>
  3066 |     | <span class='neutral'>    }</span>
  3067 |     | <span class='neutral'></span>
  3068 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal pure {</span>
  3069 |     | <span class='neutral'>        bytes32 m0;</span>
  3070 |     | <span class='neutral'>        bytes32 m1;</span>
  3071 |     | <span class='neutral'>        bytes32 m2;</span>
  3072 |     | <span class='neutral'>        bytes32 m3;</span>
  3073 |     | <span class='neutral'>        bytes32 m4;</span>
  3074 |     | <span class='neutral'>        assembly {</span>
  3075 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3076 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3077 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3078 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3079 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3080 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,address)`.</span>
  3081 |     | <span class='neutral'>            mstore(0x00, 0x8da6def5)</span>
  3082 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3083 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3084 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3085 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3086 |     | <span class='neutral'>        }</span>
  3087 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3088 |     | <span class='neutral'>        assembly {</span>
  3089 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3090 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3091 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3092 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3093 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3094 |     | <span class='neutral'>        }</span>
  3095 |     | <span class='neutral'>    }</span>
  3096 |     | <span class='neutral'></span>
  3097 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal pure {</span>
  3098 |     | <span class='neutral'>        bytes32 m0;</span>
  3099 |     | <span class='neutral'>        bytes32 m1;</span>
  3100 |     | <span class='neutral'>        bytes32 m2;</span>
  3101 |     | <span class='neutral'>        bytes32 m3;</span>
  3102 |     | <span class='neutral'>        bytes32 m4;</span>
  3103 |     | <span class='neutral'>        assembly {</span>
  3104 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3105 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3106 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3107 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3108 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3109 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,bool)`.</span>
  3110 |     | <span class='neutral'>            mstore(0x00, 0x9b4254e2)</span>
  3111 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3112 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3113 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3114 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3115 |     | <span class='neutral'>        }</span>
  3116 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3117 |     | <span class='neutral'>        assembly {</span>
  3118 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3119 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3120 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3121 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3122 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3123 |     | <span class='neutral'>        }</span>
  3124 |     | <span class='neutral'>    }</span>
  3125 |     | <span class='neutral'></span>
  3126 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  3127 |     | <span class='neutral'>        bytes32 m0;</span>
  3128 |     | <span class='neutral'>        bytes32 m1;</span>
  3129 |     | <span class='neutral'>        bytes32 m2;</span>
  3130 |     | <span class='neutral'>        bytes32 m3;</span>
  3131 |     | <span class='neutral'>        bytes32 m4;</span>
  3132 |     | <span class='neutral'>        assembly {</span>
  3133 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3134 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3135 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3136 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3137 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3138 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,uint256)`.</span>
  3139 |     | <span class='neutral'>            mstore(0x00, 0xbe553481)</span>
  3140 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3141 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3142 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3143 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3144 |     | <span class='neutral'>        }</span>
  3145 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3146 |     | <span class='neutral'>        assembly {</span>
  3147 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3148 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3149 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3150 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3151 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3152 |     | <span class='neutral'>        }</span>
  3153 |     | <span class='neutral'>    }</span>
  3154 |     | <span class='neutral'></span>
  3155 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  3156 |     | <span class='neutral'>        bytes32 m0;</span>
  3157 |     | <span class='neutral'>        bytes32 m1;</span>
  3158 |     | <span class='neutral'>        bytes32 m2;</span>
  3159 |     | <span class='neutral'>        bytes32 m3;</span>
  3160 |     | <span class='neutral'>        bytes32 m4;</span>
  3161 |     | <span class='neutral'>        bytes32 m5;</span>
  3162 |     | <span class='neutral'>        bytes32 m6;</span>
  3163 |     | <span class='neutral'>        assembly {</span>
  3164 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3165 |     | <span class='neutral'>                let length := 0</span>
  3166 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3167 |     | <span class='neutral'>                mstore(pos, length)</span>
  3168 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3169 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3170 |     | <span class='neutral'>            }</span>
  3171 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3172 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3173 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3174 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3175 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3176 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3177 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3178 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,string)`.</span>
  3179 |     | <span class='neutral'>            mstore(0x00, 0xfdb4f990)</span>
  3180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3183 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3184 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3185 |     | <span class='neutral'>        }</span>
  3186 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3187 |     | <span class='neutral'>        assembly {</span>
  3188 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3189 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3190 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3191 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3192 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3193 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3194 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3195 |     | <span class='neutral'>        }</span>
  3196 |     | <span class='neutral'>    }</span>
  3197 |     | <span class='neutral'></span>
  3198 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, address p3) internal pure {</span>
  3199 |     | <span class='neutral'>        bytes32 m0;</span>
  3200 |     | <span class='neutral'>        bytes32 m1;</span>
  3201 |     | <span class='neutral'>        bytes32 m2;</span>
  3202 |     | <span class='neutral'>        bytes32 m3;</span>
  3203 |     | <span class='neutral'>        bytes32 m4;</span>
  3204 |     | <span class='neutral'>        bytes32 m5;</span>
  3205 |     | <span class='neutral'>        bytes32 m6;</span>
  3206 |     | <span class='neutral'>        assembly {</span>
  3207 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3208 |     | <span class='neutral'>                let length := 0</span>
  3209 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3210 |     | <span class='neutral'>                mstore(pos, length)</span>
  3211 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3212 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3213 |     | <span class='neutral'>            }</span>
  3214 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3215 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3216 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3217 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3218 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3219 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3220 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3221 |     | <span class='neutral'>            // Selector of `log(address,address,string,address)`.</span>
  3222 |     | <span class='neutral'>            mstore(0x00, 0x8f736d16)</span>
  3223 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3224 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3225 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3226 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3227 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3228 |     | <span class='neutral'>        }</span>
  3229 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3230 |     | <span class='neutral'>        assembly {</span>
  3231 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3232 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3233 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3234 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3235 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3236 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3237 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3238 |     | <span class='neutral'>        }</span>
  3239 |     | <span class='neutral'>    }</span>
  3240 |     | <span class='neutral'></span>
  3241 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  3242 |     | <span class='neutral'>        bytes32 m0;</span>
  3243 |     | <span class='neutral'>        bytes32 m1;</span>
  3244 |     | <span class='neutral'>        bytes32 m2;</span>
  3245 |     | <span class='neutral'>        bytes32 m3;</span>
  3246 |     | <span class='neutral'>        bytes32 m4;</span>
  3247 |     | <span class='neutral'>        bytes32 m5;</span>
  3248 |     | <span class='neutral'>        bytes32 m6;</span>
  3249 |     | <span class='neutral'>        assembly {</span>
  3250 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3251 |     | <span class='neutral'>                let length := 0</span>
  3252 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3253 |     | <span class='neutral'>                mstore(pos, length)</span>
  3254 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3255 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3256 |     | <span class='neutral'>            }</span>
  3257 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3258 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3259 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3260 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3261 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3262 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3263 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3264 |     | <span class='neutral'>            // Selector of `log(address,address,string,bool)`.</span>
  3265 |     | <span class='neutral'>            mstore(0x00, 0x6f1a594e)</span>
  3266 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3267 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3268 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3269 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3270 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3271 |     | <span class='neutral'>        }</span>
  3272 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3273 |     | <span class='neutral'>        assembly {</span>
  3274 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3275 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3276 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3277 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3278 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3279 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3280 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3281 |     | <span class='neutral'>        }</span>
  3282 |     | <span class='neutral'>    }</span>
  3283 |     | <span class='neutral'></span>
  3284 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  3285 |     | <span class='neutral'>        bytes32 m0;</span>
  3286 |     | <span class='neutral'>        bytes32 m1;</span>
  3287 |     | <span class='neutral'>        bytes32 m2;</span>
  3288 |     | <span class='neutral'>        bytes32 m3;</span>
  3289 |     | <span class='neutral'>        bytes32 m4;</span>
  3290 |     | <span class='neutral'>        bytes32 m5;</span>
  3291 |     | <span class='neutral'>        bytes32 m6;</span>
  3292 |     | <span class='neutral'>        assembly {</span>
  3293 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3294 |     | <span class='neutral'>                let length := 0</span>
  3295 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3296 |     | <span class='neutral'>                mstore(pos, length)</span>
  3297 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3298 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3299 |     | <span class='neutral'>            }</span>
  3300 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3301 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3302 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3303 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3304 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3305 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3306 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3307 |     | <span class='neutral'>            // Selector of `log(address,address,string,uint256)`.</span>
  3308 |     | <span class='neutral'>            mstore(0x00, 0xef1cefe7)</span>
  3309 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3310 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3311 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3312 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3313 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3314 |     | <span class='neutral'>        }</span>
  3315 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3316 |     | <span class='neutral'>        assembly {</span>
  3317 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3318 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3319 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3320 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3321 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3322 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3323 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3324 |     | <span class='neutral'>        }</span>
  3325 |     | <span class='neutral'>    }</span>
  3326 |     | <span class='neutral'></span>
  3327 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  3328 |     | <span class='neutral'>        bytes32 m0;</span>
  3329 |     | <span class='neutral'>        bytes32 m1;</span>
  3330 |     | <span class='neutral'>        bytes32 m2;</span>
  3331 |     | <span class='neutral'>        bytes32 m3;</span>
  3332 |     | <span class='neutral'>        bytes32 m4;</span>
  3333 |     | <span class='neutral'>        bytes32 m5;</span>
  3334 |     | <span class='neutral'>        bytes32 m6;</span>
  3335 |     | <span class='neutral'>        bytes32 m7;</span>
  3336 |     | <span class='neutral'>        bytes32 m8;</span>
  3337 |     | <span class='neutral'>        assembly {</span>
  3338 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3339 |     | <span class='neutral'>                let length := 0</span>
  3340 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3341 |     | <span class='neutral'>                mstore(pos, length)</span>
  3342 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3343 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3344 |     | <span class='neutral'>            }</span>
  3345 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3346 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3347 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3348 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3349 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3350 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3351 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3352 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  3353 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  3354 |     | <span class='neutral'>            // Selector of `log(address,address,string,string)`.</span>
  3355 |     | <span class='neutral'>            mstore(0x00, 0x21bdaf25)</span>
  3356 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3357 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3358 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3359 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  3360 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3361 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  3362 |     | <span class='neutral'>        }</span>
  3363 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  3364 |     | <span class='neutral'>        assembly {</span>
  3365 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3366 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3367 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3368 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3369 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3370 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3371 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3372 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  3373 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  3374 |     | <span class='neutral'>        }</span>
  3375 |     | <span class='neutral'>    }</span>
  3376 |     | <span class='neutral'></span>
  3377 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
  3378 |     | <span class='neutral'>        bytes32 m0;</span>
  3379 |     | <span class='neutral'>        bytes32 m1;</span>
  3380 |     | <span class='neutral'>        bytes32 m2;</span>
  3381 |     | <span class='neutral'>        bytes32 m3;</span>
  3382 |     | <span class='neutral'>        bytes32 m4;</span>
  3383 |     | <span class='neutral'>        assembly {</span>
  3384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3389 |     | <span class='neutral'>            // Selector of `log(address,bool,address,address)`.</span>
  3390 |     | <span class='neutral'>            mstore(0x00, 0x660375dd)</span>
  3391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3392 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3394 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3395 |     | <span class='neutral'>        }</span>
  3396 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3397 |     | <span class='neutral'>        assembly {</span>
  3398 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3399 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3400 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3401 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3402 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3403 |     | <span class='neutral'>        }</span>
  3404 |     | <span class='neutral'>    }</span>
  3405 |     | <span class='neutral'></span>
  3406 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
  3407 |     | <span class='neutral'>        bytes32 m0;</span>
  3408 |     | <span class='neutral'>        bytes32 m1;</span>
  3409 |     | <span class='neutral'>        bytes32 m2;</span>
  3410 |     | <span class='neutral'>        bytes32 m3;</span>
  3411 |     | <span class='neutral'>        bytes32 m4;</span>
  3412 |     | <span class='neutral'>        assembly {</span>
  3413 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3414 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3415 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3416 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3417 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3418 |     | <span class='neutral'>            // Selector of `log(address,bool,address,bool)`.</span>
  3419 |     | <span class='neutral'>            mstore(0x00, 0xa6f50b0f)</span>
  3420 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3421 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3422 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3423 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3424 |     | <span class='neutral'>        }</span>
  3425 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3426 |     | <span class='neutral'>        assembly {</span>
  3427 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3428 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3429 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3430 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3431 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3432 |     | <span class='neutral'>        }</span>
  3433 |     | <span class='neutral'>    }</span>
  3434 |     | <span class='neutral'></span>
  3435 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal pure {</span>
  3436 |     | <span class='neutral'>        bytes32 m0;</span>
  3437 |     | <span class='neutral'>        bytes32 m1;</span>
  3438 |     | <span class='neutral'>        bytes32 m2;</span>
  3439 |     | <span class='neutral'>        bytes32 m3;</span>
  3440 |     | <span class='neutral'>        bytes32 m4;</span>
  3441 |     | <span class='neutral'>        assembly {</span>
  3442 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3443 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3444 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3445 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3446 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3447 |     | <span class='neutral'>            // Selector of `log(address,bool,address,uint256)`.</span>
  3448 |     | <span class='neutral'>            mstore(0x00, 0xa75c59de)</span>
  3449 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3450 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3451 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3452 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3453 |     | <span class='neutral'>        }</span>
  3454 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3455 |     | <span class='neutral'>        assembly {</span>
  3456 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3457 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3458 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3459 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3460 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3461 |     | <span class='neutral'>        }</span>
  3462 |     | <span class='neutral'>    }</span>
  3463 |     | <span class='neutral'></span>
  3464 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  3465 |     | <span class='neutral'>        bytes32 m0;</span>
  3466 |     | <span class='neutral'>        bytes32 m1;</span>
  3467 |     | <span class='neutral'>        bytes32 m2;</span>
  3468 |     | <span class='neutral'>        bytes32 m3;</span>
  3469 |     | <span class='neutral'>        bytes32 m4;</span>
  3470 |     | <span class='neutral'>        bytes32 m5;</span>
  3471 |     | <span class='neutral'>        bytes32 m6;</span>
  3472 |     | <span class='neutral'>        assembly {</span>
  3473 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3474 |     | <span class='neutral'>                let length := 0</span>
  3475 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3476 |     | <span class='neutral'>                mstore(pos, length)</span>
  3477 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3478 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3479 |     | <span class='neutral'>            }</span>
  3480 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3481 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3482 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3483 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3484 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3485 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3486 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3487 |     | <span class='neutral'>            // Selector of `log(address,bool,address,string)`.</span>
  3488 |     | <span class='neutral'>            mstore(0x00, 0x2dd778e6)</span>
  3489 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3490 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3491 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3492 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3493 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3494 |     | <span class='neutral'>        }</span>
  3495 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3496 |     | <span class='neutral'>        assembly {</span>
  3497 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3498 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3499 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3500 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3501 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3502 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3503 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3504 |     | <span class='neutral'>        }</span>
  3505 |     | <span class='neutral'>    }</span>
  3506 |     | <span class='neutral'></span>
  3507 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
  3508 |     | <span class='neutral'>        bytes32 m0;</span>
  3509 |     | <span class='neutral'>        bytes32 m1;</span>
  3510 |     | <span class='neutral'>        bytes32 m2;</span>
  3511 |     | <span class='neutral'>        bytes32 m3;</span>
  3512 |     | <span class='neutral'>        bytes32 m4;</span>
  3513 |     | <span class='neutral'>        assembly {</span>
  3514 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3515 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3516 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3517 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3518 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3519 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,address)`.</span>
  3520 |     | <span class='neutral'>            mstore(0x00, 0xcf394485)</span>
  3521 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3522 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3523 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3524 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3525 |     | <span class='neutral'>        }</span>
  3526 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3527 |     | <span class='neutral'>        assembly {</span>
  3528 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3529 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3530 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3531 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3532 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3533 |     | <span class='neutral'>        }</span>
  3534 |     | <span class='neutral'>    }</span>
  3535 |     | <span class='neutral'></span>
  3536 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
  3537 |     | <span class='neutral'>        bytes32 m0;</span>
  3538 |     | <span class='neutral'>        bytes32 m1;</span>
  3539 |     | <span class='neutral'>        bytes32 m2;</span>
  3540 |     | <span class='neutral'>        bytes32 m3;</span>
  3541 |     | <span class='neutral'>        bytes32 m4;</span>
  3542 |     | <span class='neutral'>        assembly {</span>
  3543 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3544 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3545 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3546 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3547 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3548 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,bool)`.</span>
  3549 |     | <span class='neutral'>            mstore(0x00, 0xcac43479)</span>
  3550 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3551 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3552 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3553 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3554 |     | <span class='neutral'>        }</span>
  3555 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3556 |     | <span class='neutral'>        assembly {</span>
  3557 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3558 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3559 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3560 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3561 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3562 |     | <span class='neutral'>        }</span>
  3563 |     | <span class='neutral'>    }</span>
  3564 |     | <span class='neutral'></span>
  3565 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  3566 |     | <span class='neutral'>        bytes32 m0;</span>
  3567 |     | <span class='neutral'>        bytes32 m1;</span>
  3568 |     | <span class='neutral'>        bytes32 m2;</span>
  3569 |     | <span class='neutral'>        bytes32 m3;</span>
  3570 |     | <span class='neutral'>        bytes32 m4;</span>
  3571 |     | <span class='neutral'>        assembly {</span>
  3572 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3573 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3574 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3575 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3576 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3577 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,uint256)`.</span>
  3578 |     | <span class='neutral'>            mstore(0x00, 0x8c4e5de6)</span>
  3579 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3580 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3581 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3582 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3583 |     | <span class='neutral'>        }</span>
  3584 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3585 |     | <span class='neutral'>        assembly {</span>
  3586 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3587 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3588 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3589 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3590 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3591 |     | <span class='neutral'>        }</span>
  3592 |     | <span class='neutral'>    }</span>
  3593 |     | <span class='neutral'></span>
  3594 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  3595 |     | <span class='neutral'>        bytes32 m0;</span>
  3596 |     | <span class='neutral'>        bytes32 m1;</span>
  3597 |     | <span class='neutral'>        bytes32 m2;</span>
  3598 |     | <span class='neutral'>        bytes32 m3;</span>
  3599 |     | <span class='neutral'>        bytes32 m4;</span>
  3600 |     | <span class='neutral'>        bytes32 m5;</span>
  3601 |     | <span class='neutral'>        bytes32 m6;</span>
  3602 |     | <span class='neutral'>        assembly {</span>
  3603 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3604 |     | <span class='neutral'>                let length := 0</span>
  3605 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3606 |     | <span class='neutral'>                mstore(pos, length)</span>
  3607 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3608 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3609 |     | <span class='neutral'>            }</span>
  3610 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3611 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3612 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3613 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3614 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3615 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3616 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3617 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,string)`.</span>
  3618 |     | <span class='neutral'>            mstore(0x00, 0xdfc4a2e8)</span>
  3619 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3620 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3621 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3622 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3623 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3624 |     | <span class='neutral'>        }</span>
  3625 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3626 |     | <span class='neutral'>        assembly {</span>
  3627 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3628 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3629 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3630 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3631 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3632 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3633 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3634 |     | <span class='neutral'>        }</span>
  3635 |     | <span class='neutral'>    }</span>
  3636 |     | <span class='neutral'></span>
  3637 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal pure {</span>
  3638 |     | <span class='neutral'>        bytes32 m0;</span>
  3639 |     | <span class='neutral'>        bytes32 m1;</span>
  3640 |     | <span class='neutral'>        bytes32 m2;</span>
  3641 |     | <span class='neutral'>        bytes32 m3;</span>
  3642 |     | <span class='neutral'>        bytes32 m4;</span>
  3643 |     | <span class='neutral'>        assembly {</span>
  3644 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3645 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3646 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3647 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3648 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3649 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,address)`.</span>
  3650 |     | <span class='neutral'>            mstore(0x00, 0xccf790a1)</span>
  3651 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3652 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3653 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3654 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3655 |     | <span class='neutral'>        }</span>
  3656 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3657 |     | <span class='neutral'>        assembly {</span>
  3658 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3659 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3660 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3661 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3662 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3663 |     | <span class='neutral'>        }</span>
  3664 |     | <span class='neutral'>    }</span>
  3665 |     | <span class='neutral'></span>
  3666 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  3667 |     | <span class='neutral'>        bytes32 m0;</span>
  3668 |     | <span class='neutral'>        bytes32 m1;</span>
  3669 |     | <span class='neutral'>        bytes32 m2;</span>
  3670 |     | <span class='neutral'>        bytes32 m3;</span>
  3671 |     | <span class='neutral'>        bytes32 m4;</span>
  3672 |     | <span class='neutral'>        assembly {</span>
  3673 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3674 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3675 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3676 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3677 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3678 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,bool)`.</span>
  3679 |     | <span class='neutral'>            mstore(0x00, 0xc4643e20)</span>
  3680 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3681 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3682 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3683 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3684 |     | <span class='neutral'>        }</span>
  3685 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3686 |     | <span class='neutral'>        assembly {</span>
  3687 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3688 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3689 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3690 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3691 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3692 |     | <span class='neutral'>        }</span>
  3693 |     | <span class='neutral'>    }</span>
  3694 |     | <span class='neutral'></span>
  3695 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  3696 |     | <span class='neutral'>        bytes32 m0;</span>
  3697 |     | <span class='neutral'>        bytes32 m1;</span>
  3698 |     | <span class='neutral'>        bytes32 m2;</span>
  3699 |     | <span class='neutral'>        bytes32 m3;</span>
  3700 |     | <span class='neutral'>        bytes32 m4;</span>
  3701 |     | <span class='neutral'>        assembly {</span>
  3702 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3703 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3704 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3705 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3706 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3707 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,uint256)`.</span>
  3708 |     | <span class='neutral'>            mstore(0x00, 0x386ff5f4)</span>
  3709 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3710 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3711 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3712 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3713 |     | <span class='neutral'>        }</span>
  3714 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3715 |     | <span class='neutral'>        assembly {</span>
  3716 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3717 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3718 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3719 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3720 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3721 |     | <span class='neutral'>        }</span>
  3722 |     | <span class='neutral'>    }</span>
  3723 |     | <span class='neutral'></span>
  3724 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  3725 |     | <span class='neutral'>        bytes32 m0;</span>
  3726 |     | <span class='neutral'>        bytes32 m1;</span>
  3727 |     | <span class='neutral'>        bytes32 m2;</span>
  3728 |     | <span class='neutral'>        bytes32 m3;</span>
  3729 |     | <span class='neutral'>        bytes32 m4;</span>
  3730 |     | <span class='neutral'>        bytes32 m5;</span>
  3731 |     | <span class='neutral'>        bytes32 m6;</span>
  3732 |     | <span class='neutral'>        assembly {</span>
  3733 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3734 |     | <span class='neutral'>                let length := 0</span>
  3735 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3736 |     | <span class='neutral'>                mstore(pos, length)</span>
  3737 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3738 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3739 |     | <span class='neutral'>            }</span>
  3740 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3741 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3742 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3743 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3744 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3745 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3746 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3747 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,string)`.</span>
  3748 |     | <span class='neutral'>            mstore(0x00, 0x0aa6cfad)</span>
  3749 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3750 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3751 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3752 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3753 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3754 |     | <span class='neutral'>        }</span>
  3755 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3756 |     | <span class='neutral'>        assembly {</span>
  3757 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3758 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3759 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3760 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3761 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3762 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3763 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3764 |     | <span class='neutral'>        }</span>
  3765 |     | <span class='neutral'>    }</span>
  3766 |     | <span class='neutral'></span>
  3767 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  3768 |     | <span class='neutral'>        bytes32 m0;</span>
  3769 |     | <span class='neutral'>        bytes32 m1;</span>
  3770 |     | <span class='neutral'>        bytes32 m2;</span>
  3771 |     | <span class='neutral'>        bytes32 m3;</span>
  3772 |     | <span class='neutral'>        bytes32 m4;</span>
  3773 |     | <span class='neutral'>        bytes32 m5;</span>
  3774 |     | <span class='neutral'>        bytes32 m6;</span>
  3775 |     | <span class='neutral'>        assembly {</span>
  3776 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3777 |     | <span class='neutral'>                let length := 0</span>
  3778 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3779 |     | <span class='neutral'>                mstore(pos, length)</span>
  3780 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3781 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3782 |     | <span class='neutral'>            }</span>
  3783 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3784 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3785 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3786 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3787 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3788 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3789 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3790 |     | <span class='neutral'>            // Selector of `log(address,bool,string,address)`.</span>
  3791 |     | <span class='neutral'>            mstore(0x00, 0x19fd4956)</span>
  3792 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3793 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3794 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3795 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3796 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3797 |     | <span class='neutral'>        }</span>
  3798 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3799 |     | <span class='neutral'>        assembly {</span>
  3800 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3801 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3802 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3803 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3804 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3805 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3806 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3807 |     | <span class='neutral'>        }</span>
  3808 |     | <span class='neutral'>    }</span>
  3809 |     | <span class='neutral'></span>
  3810 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  3811 |     | <span class='neutral'>        bytes32 m0;</span>
  3812 |     | <span class='neutral'>        bytes32 m1;</span>
  3813 |     | <span class='neutral'>        bytes32 m2;</span>
  3814 |     | <span class='neutral'>        bytes32 m3;</span>
  3815 |     | <span class='neutral'>        bytes32 m4;</span>
  3816 |     | <span class='neutral'>        bytes32 m5;</span>
  3817 |     | <span class='neutral'>        bytes32 m6;</span>
  3818 |     | <span class='neutral'>        assembly {</span>
  3819 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3820 |     | <span class='neutral'>                let length := 0</span>
  3821 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3822 |     | <span class='neutral'>                mstore(pos, length)</span>
  3823 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3824 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3825 |     | <span class='neutral'>            }</span>
  3826 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3827 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3828 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3829 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3830 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3831 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3832 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3833 |     | <span class='neutral'>            // Selector of `log(address,bool,string,bool)`.</span>
  3834 |     | <span class='neutral'>            mstore(0x00, 0x50ad461d)</span>
  3835 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3836 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3837 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3838 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3839 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3840 |     | <span class='neutral'>        }</span>
  3841 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3842 |     | <span class='neutral'>        assembly {</span>
  3843 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3844 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3845 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3846 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3847 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3848 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3849 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3850 |     | <span class='neutral'>        }</span>
  3851 |     | <span class='neutral'>    }</span>
  3852 |     | <span class='neutral'></span>
  3853 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  3854 |     | <span class='neutral'>        bytes32 m0;</span>
  3855 |     | <span class='neutral'>        bytes32 m1;</span>
  3856 |     | <span class='neutral'>        bytes32 m2;</span>
  3857 |     | <span class='neutral'>        bytes32 m3;</span>
  3858 |     | <span class='neutral'>        bytes32 m4;</span>
  3859 |     | <span class='neutral'>        bytes32 m5;</span>
  3860 |     | <span class='neutral'>        bytes32 m6;</span>
  3861 |     | <span class='neutral'>        assembly {</span>
  3862 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3863 |     | <span class='neutral'>                let length := 0</span>
  3864 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3865 |     | <span class='neutral'>                mstore(pos, length)</span>
  3866 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3867 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3868 |     | <span class='neutral'>            }</span>
  3869 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3870 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3871 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3872 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3873 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3874 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3875 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3876 |     | <span class='neutral'>            // Selector of `log(address,bool,string,uint256)`.</span>
  3877 |     | <span class='neutral'>            mstore(0x00, 0x80e6a20b)</span>
  3878 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3879 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3880 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3881 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3882 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3883 |     | <span class='neutral'>        }</span>
  3884 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3885 |     | <span class='neutral'>        assembly {</span>
  3886 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3887 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3888 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3889 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3890 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3891 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3892 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3893 |     | <span class='neutral'>        }</span>
  3894 |     | <span class='neutral'>    }</span>
  3895 |     | <span class='neutral'></span>
  3896 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  3897 |     | <span class='neutral'>        bytes32 m0;</span>
  3898 |     | <span class='neutral'>        bytes32 m1;</span>
  3899 |     | <span class='neutral'>        bytes32 m2;</span>
  3900 |     | <span class='neutral'>        bytes32 m3;</span>
  3901 |     | <span class='neutral'>        bytes32 m4;</span>
  3902 |     | <span class='neutral'>        bytes32 m5;</span>
  3903 |     | <span class='neutral'>        bytes32 m6;</span>
  3904 |     | <span class='neutral'>        bytes32 m7;</span>
  3905 |     | <span class='neutral'>        bytes32 m8;</span>
  3906 |     | <span class='neutral'>        assembly {</span>
  3907 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3908 |     | <span class='neutral'>                let length := 0</span>
  3909 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3910 |     | <span class='neutral'>                mstore(pos, length)</span>
  3911 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3912 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3913 |     | <span class='neutral'>            }</span>
  3914 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3915 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3916 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3917 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3918 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3919 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3920 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3921 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  3922 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  3923 |     | <span class='neutral'>            // Selector of `log(address,bool,string,string)`.</span>
  3924 |     | <span class='neutral'>            mstore(0x00, 0x475c5c33)</span>
  3925 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3926 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3927 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3928 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  3929 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3930 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  3931 |     | <span class='neutral'>        }</span>
  3932 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  3933 |     | <span class='neutral'>        assembly {</span>
  3934 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3935 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3936 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3937 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3938 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3939 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3940 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3941 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  3942 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  3943 |     | <span class='neutral'>        }</span>
  3944 |     | <span class='neutral'>    }</span>
  3945 |     | <span class='neutral'></span>
  3946 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal pure {</span>
  3947 |     | <span class='neutral'>        bytes32 m0;</span>
  3948 |     | <span class='neutral'>        bytes32 m1;</span>
  3949 |     | <span class='neutral'>        bytes32 m2;</span>
  3950 |     | <span class='neutral'>        bytes32 m3;</span>
  3951 |     | <span class='neutral'>        bytes32 m4;</span>
  3952 |     | <span class='neutral'>        assembly {</span>
  3953 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3954 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3955 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3956 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3957 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3958 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,address)`.</span>
  3959 |     | <span class='neutral'>            mstore(0x00, 0x478d1c62)</span>
  3960 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3961 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3962 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3963 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3964 |     | <span class='neutral'>        }</span>
  3965 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3966 |     | <span class='neutral'>        assembly {</span>
  3967 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3968 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3969 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3970 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3971 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3972 |     | <span class='neutral'>        }</span>
  3973 |     | <span class='neutral'>    }</span>
  3974 |     | <span class='neutral'></span>
  3975 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal pure {</span>
  3976 |     | <span class='neutral'>        bytes32 m0;</span>
  3977 |     | <span class='neutral'>        bytes32 m1;</span>
  3978 |     | <span class='neutral'>        bytes32 m2;</span>
  3979 |     | <span class='neutral'>        bytes32 m3;</span>
  3980 |     | <span class='neutral'>        bytes32 m4;</span>
  3981 |     | <span class='neutral'>        assembly {</span>
  3982 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3983 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3984 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3985 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3986 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3987 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,bool)`.</span>
  3988 |     | <span class='neutral'>            mstore(0x00, 0xa1bcc9b3)</span>
  3989 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3990 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3991 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3992 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3993 |     | <span class='neutral'>        }</span>
  3994 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3995 |     | <span class='neutral'>        assembly {</span>
  3996 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3997 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3998 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3999 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4000 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4001 |     | <span class='neutral'>        }</span>
  4002 |     | <span class='neutral'>    }</span>
  4003 |     | <span class='neutral'></span>
  4004 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  4005 |     | <span class='neutral'>        bytes32 m0;</span>
  4006 |     | <span class='neutral'>        bytes32 m1;</span>
  4007 |     | <span class='neutral'>        bytes32 m2;</span>
  4008 |     | <span class='neutral'>        bytes32 m3;</span>
  4009 |     | <span class='neutral'>        bytes32 m4;</span>
  4010 |     | <span class='neutral'>        assembly {</span>
  4011 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4012 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4013 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4014 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4015 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4016 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,uint256)`.</span>
  4017 |     | <span class='neutral'>            mstore(0x00, 0x100f650e)</span>
  4018 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4019 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4020 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4021 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4022 |     | <span class='neutral'>        }</span>
  4023 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4024 |     | <span class='neutral'>        assembly {</span>
  4025 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4026 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4027 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4028 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4029 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4030 |     | <span class='neutral'>        }</span>
  4031 |     | <span class='neutral'>    }</span>
  4032 |     | <span class='neutral'></span>
  4033 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  4034 |     | <span class='neutral'>        bytes32 m0;</span>
  4035 |     | <span class='neutral'>        bytes32 m1;</span>
  4036 |     | <span class='neutral'>        bytes32 m2;</span>
  4037 |     | <span class='neutral'>        bytes32 m3;</span>
  4038 |     | <span class='neutral'>        bytes32 m4;</span>
  4039 |     | <span class='neutral'>        bytes32 m5;</span>
  4040 |     | <span class='neutral'>        bytes32 m6;</span>
  4041 |     | <span class='neutral'>        assembly {</span>
  4042 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4043 |     | <span class='neutral'>                let length := 0</span>
  4044 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4045 |     | <span class='neutral'>                mstore(pos, length)</span>
  4046 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4047 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4048 |     | <span class='neutral'>            }</span>
  4049 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4050 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4051 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4052 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4053 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4054 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4055 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4056 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,string)`.</span>
  4057 |     | <span class='neutral'>            mstore(0x00, 0x1da986ea)</span>
  4058 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4059 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4060 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4061 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4062 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4063 |     | <span class='neutral'>        }</span>
  4064 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4065 |     | <span class='neutral'>        assembly {</span>
  4066 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4067 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4068 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4069 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4070 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4071 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4072 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4073 |     | <span class='neutral'>        }</span>
  4074 |     | <span class='neutral'>    }</span>
  4075 |     | <span class='neutral'></span>
  4076 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal pure {</span>
  4077 |     | <span class='neutral'>        bytes32 m0;</span>
  4078 |     | <span class='neutral'>        bytes32 m1;</span>
  4079 |     | <span class='neutral'>        bytes32 m2;</span>
  4080 |     | <span class='neutral'>        bytes32 m3;</span>
  4081 |     | <span class='neutral'>        bytes32 m4;</span>
  4082 |     | <span class='neutral'>        assembly {</span>
  4083 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4084 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4085 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4086 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4087 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4088 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,address)`.</span>
  4089 |     | <span class='neutral'>            mstore(0x00, 0xa31bfdcc)</span>
  4090 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4091 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4092 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4093 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4094 |     | <span class='neutral'>        }</span>
  4095 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4096 |     | <span class='neutral'>        assembly {</span>
  4097 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4098 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4099 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4100 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4101 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4102 |     | <span class='neutral'>        }</span>
  4103 |     | <span class='neutral'>    }</span>
  4104 |     | <span class='neutral'></span>
  4105 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  4106 |     | <span class='neutral'>        bytes32 m0;</span>
  4107 |     | <span class='neutral'>        bytes32 m1;</span>
  4108 |     | <span class='neutral'>        bytes32 m2;</span>
  4109 |     | <span class='neutral'>        bytes32 m3;</span>
  4110 |     | <span class='neutral'>        bytes32 m4;</span>
  4111 |     | <span class='neutral'>        assembly {</span>
  4112 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4113 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4114 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4115 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4116 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4117 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,bool)`.</span>
  4118 |     | <span class='neutral'>            mstore(0x00, 0x3bf5e537)</span>
  4119 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4120 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4121 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4122 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4123 |     | <span class='neutral'>        }</span>
  4124 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4125 |     | <span class='neutral'>        assembly {</span>
  4126 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4127 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4128 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4129 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4130 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4131 |     | <span class='neutral'>        }</span>
  4132 |     | <span class='neutral'>    }</span>
  4133 |     | <span class='neutral'></span>
  4134 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  4135 |     | <span class='neutral'>        bytes32 m0;</span>
  4136 |     | <span class='neutral'>        bytes32 m1;</span>
  4137 |     | <span class='neutral'>        bytes32 m2;</span>
  4138 |     | <span class='neutral'>        bytes32 m3;</span>
  4139 |     | <span class='neutral'>        bytes32 m4;</span>
  4140 |     | <span class='neutral'>        assembly {</span>
  4141 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4142 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4143 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4144 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4145 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4146 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,uint256)`.</span>
  4147 |     | <span class='neutral'>            mstore(0x00, 0x22f6b999)</span>
  4148 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4149 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4150 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4151 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4152 |     | <span class='neutral'>        }</span>
  4153 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4154 |     | <span class='neutral'>        assembly {</span>
  4155 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4156 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4157 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4158 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4159 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4160 |     | <span class='neutral'>        }</span>
  4161 |     | <span class='neutral'>    }</span>
  4162 |     | <span class='neutral'></span>
  4163 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  4164 |     | <span class='neutral'>        bytes32 m0;</span>
  4165 |     | <span class='neutral'>        bytes32 m1;</span>
  4166 |     | <span class='neutral'>        bytes32 m2;</span>
  4167 |     | <span class='neutral'>        bytes32 m3;</span>
  4168 |     | <span class='neutral'>        bytes32 m4;</span>
  4169 |     | <span class='neutral'>        bytes32 m5;</span>
  4170 |     | <span class='neutral'>        bytes32 m6;</span>
  4171 |     | <span class='neutral'>        assembly {</span>
  4172 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4173 |     | <span class='neutral'>                let length := 0</span>
  4174 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4175 |     | <span class='neutral'>                mstore(pos, length)</span>
  4176 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4177 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4178 |     | <span class='neutral'>            }</span>
  4179 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4180 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4181 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4182 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4183 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4184 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4185 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4186 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,string)`.</span>
  4187 |     | <span class='neutral'>            mstore(0x00, 0xc5ad85f9)</span>
  4188 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4189 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4190 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4191 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4192 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4193 |     | <span class='neutral'>        }</span>
  4194 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4195 |     | <span class='neutral'>        assembly {</span>
  4196 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4197 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4198 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4199 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4200 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4201 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4202 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4203 |     | <span class='neutral'>        }</span>
  4204 |     | <span class='neutral'>    }</span>
  4205 |     | <span class='neutral'></span>
  4206 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  4207 |     | <span class='neutral'>        bytes32 m0;</span>
  4208 |     | <span class='neutral'>        bytes32 m1;</span>
  4209 |     | <span class='neutral'>        bytes32 m2;</span>
  4210 |     | <span class='neutral'>        bytes32 m3;</span>
  4211 |     | <span class='neutral'>        bytes32 m4;</span>
  4212 |     | <span class='neutral'>        assembly {</span>
  4213 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4214 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4215 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4216 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4217 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4218 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,address)`.</span>
  4219 |     | <span class='neutral'>            mstore(0x00, 0x20e3984d)</span>
  4220 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4221 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4222 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4223 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4224 |     | <span class='neutral'>        }</span>
  4225 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4226 |     | <span class='neutral'>        assembly {</span>
  4227 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4228 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4229 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4230 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4231 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4232 |     | <span class='neutral'>        }</span>
  4233 |     | <span class='neutral'>    }</span>
  4234 |     | <span class='neutral'></span>
  4235 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  4236 |     | <span class='neutral'>        bytes32 m0;</span>
  4237 |     | <span class='neutral'>        bytes32 m1;</span>
  4238 |     | <span class='neutral'>        bytes32 m2;</span>
  4239 |     | <span class='neutral'>        bytes32 m3;</span>
  4240 |     | <span class='neutral'>        bytes32 m4;</span>
  4241 |     | <span class='neutral'>        assembly {</span>
  4242 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4243 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4244 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4245 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4246 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4247 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,bool)`.</span>
  4248 |     | <span class='neutral'>            mstore(0x00, 0x66f1bc67)</span>
  4249 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4250 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4251 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4252 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4253 |     | <span class='neutral'>        }</span>
  4254 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4255 |     | <span class='neutral'>        assembly {</span>
  4256 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4257 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4258 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4259 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4260 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4261 |     | <span class='neutral'>        }</span>
  4262 |     | <span class='neutral'>    }</span>
  4263 |     | <span class='neutral'></span>
  4264 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  4265 |     | <span class='neutral'>        bytes32 m0;</span>
  4266 |     | <span class='neutral'>        bytes32 m1;</span>
  4267 |     | <span class='neutral'>        bytes32 m2;</span>
  4268 |     | <span class='neutral'>        bytes32 m3;</span>
  4269 |     | <span class='neutral'>        bytes32 m4;</span>
  4270 |     | <span class='neutral'>        assembly {</span>
  4271 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4272 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4273 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4274 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4275 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4276 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,uint256)`.</span>
  4277 |     | <span class='neutral'>            mstore(0x00, 0x34f0e636)</span>
  4278 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4279 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4280 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4281 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4282 |     | <span class='neutral'>        }</span>
  4283 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4284 |     | <span class='neutral'>        assembly {</span>
  4285 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4286 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4287 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4288 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4289 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4290 |     | <span class='neutral'>        }</span>
  4291 |     | <span class='neutral'>    }</span>
  4292 |     | <span class='neutral'></span>
  4293 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  4294 |     | <span class='neutral'>        bytes32 m0;</span>
  4295 |     | <span class='neutral'>        bytes32 m1;</span>
  4296 |     | <span class='neutral'>        bytes32 m2;</span>
  4297 |     | <span class='neutral'>        bytes32 m3;</span>
  4298 |     | <span class='neutral'>        bytes32 m4;</span>
  4299 |     | <span class='neutral'>        bytes32 m5;</span>
  4300 |     | <span class='neutral'>        bytes32 m6;</span>
  4301 |     | <span class='neutral'>        assembly {</span>
  4302 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4303 |     | <span class='neutral'>                let length := 0</span>
  4304 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4305 |     | <span class='neutral'>                mstore(pos, length)</span>
  4306 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4307 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4308 |     | <span class='neutral'>            }</span>
  4309 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4310 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4311 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4312 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4313 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4314 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4315 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4316 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,string)`.</span>
  4317 |     | <span class='neutral'>            mstore(0x00, 0x4a28c017)</span>
  4318 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4319 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4320 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4321 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4322 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4323 |     | <span class='neutral'>        }</span>
  4324 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4325 |     | <span class='neutral'>        assembly {</span>
  4326 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4327 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4328 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4329 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4330 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4331 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4332 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4333 |     | <span class='neutral'>        }</span>
  4334 |     | <span class='neutral'>    }</span>
  4335 |     | <span class='neutral'></span>
  4336 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  4337 |     | <span class='neutral'>        bytes32 m0;</span>
  4338 |     | <span class='neutral'>        bytes32 m1;</span>
  4339 |     | <span class='neutral'>        bytes32 m2;</span>
  4340 |     | <span class='neutral'>        bytes32 m3;</span>
  4341 |     | <span class='neutral'>        bytes32 m4;</span>
  4342 |     | <span class='neutral'>        bytes32 m5;</span>
  4343 |     | <span class='neutral'>        bytes32 m6;</span>
  4344 |     | <span class='neutral'>        assembly {</span>
  4345 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4346 |     | <span class='neutral'>                let length := 0</span>
  4347 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4348 |     | <span class='neutral'>                mstore(pos, length)</span>
  4349 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4350 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4351 |     | <span class='neutral'>            }</span>
  4352 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4353 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4354 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4355 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4356 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4357 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4358 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4359 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,address)`.</span>
  4360 |     | <span class='neutral'>            mstore(0x00, 0x5c430d47)</span>
  4361 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4362 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4363 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4364 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4365 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4366 |     | <span class='neutral'>        }</span>
  4367 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4368 |     | <span class='neutral'>        assembly {</span>
  4369 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4370 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4371 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4372 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4373 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4374 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4375 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4376 |     | <span class='neutral'>        }</span>
  4377 |     | <span class='neutral'>    }</span>
  4378 |     | <span class='neutral'></span>
  4379 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  4380 |     | <span class='neutral'>        bytes32 m0;</span>
  4381 |     | <span class='neutral'>        bytes32 m1;</span>
  4382 |     | <span class='neutral'>        bytes32 m2;</span>
  4383 |     | <span class='neutral'>        bytes32 m3;</span>
  4384 |     | <span class='neutral'>        bytes32 m4;</span>
  4385 |     | <span class='neutral'>        bytes32 m5;</span>
  4386 |     | <span class='neutral'>        bytes32 m6;</span>
  4387 |     | <span class='neutral'>        assembly {</span>
  4388 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4389 |     | <span class='neutral'>                let length := 0</span>
  4390 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4391 |     | <span class='neutral'>                mstore(pos, length)</span>
  4392 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4393 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4394 |     | <span class='neutral'>            }</span>
  4395 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4396 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4397 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4398 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4399 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4400 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4401 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4402 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,bool)`.</span>
  4403 |     | <span class='neutral'>            mstore(0x00, 0xcf18105c)</span>
  4404 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4405 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4406 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4407 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4408 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4409 |     | <span class='neutral'>        }</span>
  4410 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4411 |     | <span class='neutral'>        assembly {</span>
  4412 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4413 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4414 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4415 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4416 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4417 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4418 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4419 |     | <span class='neutral'>        }</span>
  4420 |     | <span class='neutral'>    }</span>
  4421 |     | <span class='neutral'></span>
  4422 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  4423 |     | <span class='neutral'>        bytes32 m0;</span>
  4424 |     | <span class='neutral'>        bytes32 m1;</span>
  4425 |     | <span class='neutral'>        bytes32 m2;</span>
  4426 |     | <span class='neutral'>        bytes32 m3;</span>
  4427 |     | <span class='neutral'>        bytes32 m4;</span>
  4428 |     | <span class='neutral'>        bytes32 m5;</span>
  4429 |     | <span class='neutral'>        bytes32 m6;</span>
  4430 |     | <span class='neutral'>        assembly {</span>
  4431 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4432 |     | <span class='neutral'>                let length := 0</span>
  4433 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4434 |     | <span class='neutral'>                mstore(pos, length)</span>
  4435 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4436 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4437 |     | <span class='neutral'>            }</span>
  4438 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4439 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4440 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4441 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4442 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4443 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4444 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4445 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,uint256)`.</span>
  4446 |     | <span class='neutral'>            mstore(0x00, 0xbf01f891)</span>
  4447 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4448 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4449 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4450 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4451 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4452 |     | <span class='neutral'>        }</span>
  4453 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4454 |     | <span class='neutral'>        assembly {</span>
  4455 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4456 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4457 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4458 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4459 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4460 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4461 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4462 |     | <span class='neutral'>        }</span>
  4463 |     | <span class='neutral'>    }</span>
  4464 |     | <span class='neutral'></span>
  4465 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  4466 |     | <span class='neutral'>        bytes32 m0;</span>
  4467 |     | <span class='neutral'>        bytes32 m1;</span>
  4468 |     | <span class='neutral'>        bytes32 m2;</span>
  4469 |     | <span class='neutral'>        bytes32 m3;</span>
  4470 |     | <span class='neutral'>        bytes32 m4;</span>
  4471 |     | <span class='neutral'>        bytes32 m5;</span>
  4472 |     | <span class='neutral'>        bytes32 m6;</span>
  4473 |     | <span class='neutral'>        bytes32 m7;</span>
  4474 |     | <span class='neutral'>        bytes32 m8;</span>
  4475 |     | <span class='neutral'>        assembly {</span>
  4476 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4477 |     | <span class='neutral'>                let length := 0</span>
  4478 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4479 |     | <span class='neutral'>                mstore(pos, length)</span>
  4480 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4481 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4482 |     | <span class='neutral'>            }</span>
  4483 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4484 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4485 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4486 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4487 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4488 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4489 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4490 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4491 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4492 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,string)`.</span>
  4493 |     | <span class='neutral'>            mstore(0x00, 0x88a8c406)</span>
  4494 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4495 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4496 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4497 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4498 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4499 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4500 |     | <span class='neutral'>        }</span>
  4501 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4502 |     | <span class='neutral'>        assembly {</span>
  4503 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4504 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4505 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4506 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4507 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4508 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4509 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4510 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4511 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4512 |     | <span class='neutral'>        }</span>
  4513 |     | <span class='neutral'>    }</span>
  4514 |     | <span class='neutral'></span>
  4515 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, address p3) internal pure {</span>
  4516 |     | <span class='neutral'>        bytes32 m0;</span>
  4517 |     | <span class='neutral'>        bytes32 m1;</span>
  4518 |     | <span class='neutral'>        bytes32 m2;</span>
  4519 |     | <span class='neutral'>        bytes32 m3;</span>
  4520 |     | <span class='neutral'>        bytes32 m4;</span>
  4521 |     | <span class='neutral'>        bytes32 m5;</span>
  4522 |     | <span class='neutral'>        bytes32 m6;</span>
  4523 |     | <span class='neutral'>        assembly {</span>
  4524 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4525 |     | <span class='neutral'>                let length := 0</span>
  4526 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4527 |     | <span class='neutral'>                mstore(pos, length)</span>
  4528 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4529 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4530 |     | <span class='neutral'>            }</span>
  4531 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4532 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4533 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4534 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4535 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4536 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4537 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4538 |     | <span class='neutral'>            // Selector of `log(address,string,address,address)`.</span>
  4539 |     | <span class='neutral'>            mstore(0x00, 0x0d36fa20)</span>
  4540 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4541 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4542 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4543 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4544 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4545 |     | <span class='neutral'>        }</span>
  4546 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4547 |     | <span class='neutral'>        assembly {</span>
  4548 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4549 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4550 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4551 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4552 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4553 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4554 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4555 |     | <span class='neutral'>        }</span>
  4556 |     | <span class='neutral'>    }</span>
  4557 |     | <span class='neutral'></span>
  4558 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  4559 |     | <span class='neutral'>        bytes32 m0;</span>
  4560 |     | <span class='neutral'>        bytes32 m1;</span>
  4561 |     | <span class='neutral'>        bytes32 m2;</span>
  4562 |     | <span class='neutral'>        bytes32 m3;</span>
  4563 |     | <span class='neutral'>        bytes32 m4;</span>
  4564 |     | <span class='neutral'>        bytes32 m5;</span>
  4565 |     | <span class='neutral'>        bytes32 m6;</span>
  4566 |     | <span class='neutral'>        assembly {</span>
  4567 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4568 |     | <span class='neutral'>                let length := 0</span>
  4569 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4570 |     | <span class='neutral'>                mstore(pos, length)</span>
  4571 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4572 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4573 |     | <span class='neutral'>            }</span>
  4574 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4575 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4576 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4577 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4578 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4579 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4580 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4581 |     | <span class='neutral'>            // Selector of `log(address,string,address,bool)`.</span>
  4582 |     | <span class='neutral'>            mstore(0x00, 0x0df12b76)</span>
  4583 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4584 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4585 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4586 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4587 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4588 |     | <span class='neutral'>        }</span>
  4589 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4590 |     | <span class='neutral'>        assembly {</span>
  4591 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4592 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4593 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4594 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4595 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4596 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4597 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4598 |     | <span class='neutral'>        }</span>
  4599 |     | <span class='neutral'>    }</span>
  4600 |     | <span class='neutral'></span>
  4601 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  4602 |     | <span class='neutral'>        bytes32 m0;</span>
  4603 |     | <span class='neutral'>        bytes32 m1;</span>
  4604 |     | <span class='neutral'>        bytes32 m2;</span>
  4605 |     | <span class='neutral'>        bytes32 m3;</span>
  4606 |     | <span class='neutral'>        bytes32 m4;</span>
  4607 |     | <span class='neutral'>        bytes32 m5;</span>
  4608 |     | <span class='neutral'>        bytes32 m6;</span>
  4609 |     | <span class='neutral'>        assembly {</span>
  4610 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4611 |     | <span class='neutral'>                let length := 0</span>
  4612 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4613 |     | <span class='neutral'>                mstore(pos, length)</span>
  4614 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4615 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4616 |     | <span class='neutral'>            }</span>
  4617 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4618 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4619 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4620 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4621 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4622 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4623 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4624 |     | <span class='neutral'>            // Selector of `log(address,string,address,uint256)`.</span>
  4625 |     | <span class='neutral'>            mstore(0x00, 0x457fe3cf)</span>
  4626 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4627 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4628 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4629 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4630 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4631 |     | <span class='neutral'>        }</span>
  4632 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4633 |     | <span class='neutral'>        assembly {</span>
  4634 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4635 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4636 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4637 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4638 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4639 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4640 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4641 |     | <span class='neutral'>        }</span>
  4642 |     | <span class='neutral'>    }</span>
  4643 |     | <span class='neutral'></span>
  4644 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  4645 |     | <span class='neutral'>        bytes32 m0;</span>
  4646 |     | <span class='neutral'>        bytes32 m1;</span>
  4647 |     | <span class='neutral'>        bytes32 m2;</span>
  4648 |     | <span class='neutral'>        bytes32 m3;</span>
  4649 |     | <span class='neutral'>        bytes32 m4;</span>
  4650 |     | <span class='neutral'>        bytes32 m5;</span>
  4651 |     | <span class='neutral'>        bytes32 m6;</span>
  4652 |     | <span class='neutral'>        bytes32 m7;</span>
  4653 |     | <span class='neutral'>        bytes32 m8;</span>
  4654 |     | <span class='neutral'>        assembly {</span>
  4655 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4656 |     | <span class='neutral'>                let length := 0</span>
  4657 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4658 |     | <span class='neutral'>                mstore(pos, length)</span>
  4659 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4660 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4661 |     | <span class='neutral'>            }</span>
  4662 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4663 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4664 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4665 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4666 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4667 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4668 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4669 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4670 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4671 |     | <span class='neutral'>            // Selector of `log(address,string,address,string)`.</span>
  4672 |     | <span class='neutral'>            mstore(0x00, 0xf7e36245)</span>
  4673 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4674 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4675 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4676 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4677 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4678 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4679 |     | <span class='neutral'>        }</span>
  4680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4681 |     | <span class='neutral'>        assembly {</span>
  4682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4689 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4690 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4691 |     | <span class='neutral'>        }</span>
  4692 |     | <span class='neutral'>    }</span>
  4693 |     | <span class='neutral'></span>
  4694 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  4695 |     | <span class='neutral'>        bytes32 m0;</span>
  4696 |     | <span class='neutral'>        bytes32 m1;</span>
  4697 |     | <span class='neutral'>        bytes32 m2;</span>
  4698 |     | <span class='neutral'>        bytes32 m3;</span>
  4699 |     | <span class='neutral'>        bytes32 m4;</span>
  4700 |     | <span class='neutral'>        bytes32 m5;</span>
  4701 |     | <span class='neutral'>        bytes32 m6;</span>
  4702 |     | <span class='neutral'>        assembly {</span>
  4703 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4704 |     | <span class='neutral'>                let length := 0</span>
  4705 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4706 |     | <span class='neutral'>                mstore(pos, length)</span>
  4707 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4708 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4709 |     | <span class='neutral'>            }</span>
  4710 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4711 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4712 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4713 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4714 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4715 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4716 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4717 |     | <span class='neutral'>            // Selector of `log(address,string,bool,address)`.</span>
  4718 |     | <span class='neutral'>            mstore(0x00, 0x205871c2)</span>
  4719 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4720 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4721 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4722 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4723 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4724 |     | <span class='neutral'>        }</span>
  4725 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4726 |     | <span class='neutral'>        assembly {</span>
  4727 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4728 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4729 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4730 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4731 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4732 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4733 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4734 |     | <span class='neutral'>        }</span>
  4735 |     | <span class='neutral'>    }</span>
  4736 |     | <span class='neutral'></span>
  4737 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  4738 |     | <span class='neutral'>        bytes32 m0;</span>
  4739 |     | <span class='neutral'>        bytes32 m1;</span>
  4740 |     | <span class='neutral'>        bytes32 m2;</span>
  4741 |     | <span class='neutral'>        bytes32 m3;</span>
  4742 |     | <span class='neutral'>        bytes32 m4;</span>
  4743 |     | <span class='neutral'>        bytes32 m5;</span>
  4744 |     | <span class='neutral'>        bytes32 m6;</span>
  4745 |     | <span class='neutral'>        assembly {</span>
  4746 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4747 |     | <span class='neutral'>                let length := 0</span>
  4748 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4749 |     | <span class='neutral'>                mstore(pos, length)</span>
  4750 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4751 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4752 |     | <span class='neutral'>            }</span>
  4753 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4754 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4755 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4756 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4757 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4758 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4759 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4760 |     | <span class='neutral'>            // Selector of `log(address,string,bool,bool)`.</span>
  4761 |     | <span class='neutral'>            mstore(0x00, 0x5f1d5c9f)</span>
  4762 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4763 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4764 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4765 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4766 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4767 |     | <span class='neutral'>        }</span>
  4768 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4769 |     | <span class='neutral'>        assembly {</span>
  4770 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4771 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4772 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4773 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4774 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4775 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4776 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4777 |     | <span class='neutral'>        }</span>
  4778 |     | <span class='neutral'>    }</span>
  4779 |     | <span class='neutral'></span>
  4780 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  4781 |     | <span class='neutral'>        bytes32 m0;</span>
  4782 |     | <span class='neutral'>        bytes32 m1;</span>
  4783 |     | <span class='neutral'>        bytes32 m2;</span>
  4784 |     | <span class='neutral'>        bytes32 m3;</span>
  4785 |     | <span class='neutral'>        bytes32 m4;</span>
  4786 |     | <span class='neutral'>        bytes32 m5;</span>
  4787 |     | <span class='neutral'>        bytes32 m6;</span>
  4788 |     | <span class='neutral'>        assembly {</span>
  4789 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4790 |     | <span class='neutral'>                let length := 0</span>
  4791 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4792 |     | <span class='neutral'>                mstore(pos, length)</span>
  4793 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4794 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4795 |     | <span class='neutral'>            }</span>
  4796 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4797 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4798 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4799 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4800 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4801 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4802 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4803 |     | <span class='neutral'>            // Selector of `log(address,string,bool,uint256)`.</span>
  4804 |     | <span class='neutral'>            mstore(0x00, 0x515e38b6)</span>
  4805 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4806 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4807 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4808 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4809 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4810 |     | <span class='neutral'>        }</span>
  4811 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4812 |     | <span class='neutral'>        assembly {</span>
  4813 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4814 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4815 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4816 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4817 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4818 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4819 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4820 |     | <span class='neutral'>        }</span>
  4821 |     | <span class='neutral'>    }</span>
  4822 |     | <span class='neutral'></span>
  4823 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  4824 |     | <span class='neutral'>        bytes32 m0;</span>
  4825 |     | <span class='neutral'>        bytes32 m1;</span>
  4826 |     | <span class='neutral'>        bytes32 m2;</span>
  4827 |     | <span class='neutral'>        bytes32 m3;</span>
  4828 |     | <span class='neutral'>        bytes32 m4;</span>
  4829 |     | <span class='neutral'>        bytes32 m5;</span>
  4830 |     | <span class='neutral'>        bytes32 m6;</span>
  4831 |     | <span class='neutral'>        bytes32 m7;</span>
  4832 |     | <span class='neutral'>        bytes32 m8;</span>
  4833 |     | <span class='neutral'>        assembly {</span>
  4834 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4835 |     | <span class='neutral'>                let length := 0</span>
  4836 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4837 |     | <span class='neutral'>                mstore(pos, length)</span>
  4838 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4839 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4840 |     | <span class='neutral'>            }</span>
  4841 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4842 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4843 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4844 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4845 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4846 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4847 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4848 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4849 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4850 |     | <span class='neutral'>            // Selector of `log(address,string,bool,string)`.</span>
  4851 |     | <span class='neutral'>            mstore(0x00, 0xbc0b61fe)</span>
  4852 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4853 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4854 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4855 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4856 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4857 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4858 |     | <span class='neutral'>        }</span>
  4859 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4860 |     | <span class='neutral'>        assembly {</span>
  4861 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4862 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4863 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4864 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4865 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4866 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4867 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4868 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4869 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4870 |     | <span class='neutral'>        }</span>
  4871 |     | <span class='neutral'>    }</span>
  4872 |     | <span class='neutral'></span>
  4873 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  4874 |     | <span class='neutral'>        bytes32 m0;</span>
  4875 |     | <span class='neutral'>        bytes32 m1;</span>
  4876 |     | <span class='neutral'>        bytes32 m2;</span>
  4877 |     | <span class='neutral'>        bytes32 m3;</span>
  4878 |     | <span class='neutral'>        bytes32 m4;</span>
  4879 |     | <span class='neutral'>        bytes32 m5;</span>
  4880 |     | <span class='neutral'>        bytes32 m6;</span>
  4881 |     | <span class='neutral'>        assembly {</span>
  4882 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4883 |     | <span class='neutral'>                let length := 0</span>
  4884 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4885 |     | <span class='neutral'>                mstore(pos, length)</span>
  4886 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4887 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4888 |     | <span class='neutral'>            }</span>
  4889 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4890 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4891 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4892 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4893 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4894 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4895 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4896 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,address)`.</span>
  4897 |     | <span class='neutral'>            mstore(0x00, 0x63183678)</span>
  4898 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4899 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4900 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4901 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4902 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4903 |     | <span class='neutral'>        }</span>
  4904 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4905 |     | <span class='neutral'>        assembly {</span>
  4906 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4907 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4908 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4909 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4910 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4911 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4912 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4913 |     | <span class='neutral'>        }</span>
  4914 |     | <span class='neutral'>    }</span>
  4915 |     | <span class='neutral'></span>
  4916 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  4917 |     | <span class='neutral'>        bytes32 m0;</span>
  4918 |     | <span class='neutral'>        bytes32 m1;</span>
  4919 |     | <span class='neutral'>        bytes32 m2;</span>
  4920 |     | <span class='neutral'>        bytes32 m3;</span>
  4921 |     | <span class='neutral'>        bytes32 m4;</span>
  4922 |     | <span class='neutral'>        bytes32 m5;</span>
  4923 |     | <span class='neutral'>        bytes32 m6;</span>
  4924 |     | <span class='neutral'>        assembly {</span>
  4925 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4926 |     | <span class='neutral'>                let length := 0</span>
  4927 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4928 |     | <span class='neutral'>                mstore(pos, length)</span>
  4929 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4930 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4931 |     | <span class='neutral'>            }</span>
  4932 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4933 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4934 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4935 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4936 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4937 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4938 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4939 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,bool)`.</span>
  4940 |     | <span class='neutral'>            mstore(0x00, 0x0ef7e050)</span>
  4941 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4942 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4943 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4944 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4945 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4946 |     | <span class='neutral'>        }</span>
  4947 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4948 |     | <span class='neutral'>        assembly {</span>
  4949 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4950 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4951 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4952 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4953 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4954 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4955 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4956 |     | <span class='neutral'>        }</span>
  4957 |     | <span class='neutral'>    }</span>
  4958 |     | <span class='neutral'></span>
  4959 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  4960 |     | <span class='neutral'>        bytes32 m0;</span>
  4961 |     | <span class='neutral'>        bytes32 m1;</span>
  4962 |     | <span class='neutral'>        bytes32 m2;</span>
  4963 |     | <span class='neutral'>        bytes32 m3;</span>
  4964 |     | <span class='neutral'>        bytes32 m4;</span>
  4965 |     | <span class='neutral'>        bytes32 m5;</span>
  4966 |     | <span class='neutral'>        bytes32 m6;</span>
  4967 |     | <span class='neutral'>        assembly {</span>
  4968 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4969 |     | <span class='neutral'>                let length := 0</span>
  4970 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4971 |     | <span class='neutral'>                mstore(pos, length)</span>
  4972 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4973 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4974 |     | <span class='neutral'>            }</span>
  4975 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4976 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4977 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4978 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4979 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4980 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4981 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4982 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,uint256)`.</span>
  4983 |     | <span class='neutral'>            mstore(0x00, 0x1dc8e1b8)</span>
  4984 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4985 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4986 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4987 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4988 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4989 |     | <span class='neutral'>        }</span>
  4990 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4991 |     | <span class='neutral'>        assembly {</span>
  4992 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4993 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4994 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4995 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4996 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4997 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4998 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4999 |     | <span class='neutral'>        }</span>
  5000 |     | <span class='neutral'>    }</span>
  5001 |     | <span class='neutral'></span>
  5002 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  5003 |     | <span class='neutral'>        bytes32 m0;</span>
  5004 |     | <span class='neutral'>        bytes32 m1;</span>
  5005 |     | <span class='neutral'>        bytes32 m2;</span>
  5006 |     | <span class='neutral'>        bytes32 m3;</span>
  5007 |     | <span class='neutral'>        bytes32 m4;</span>
  5008 |     | <span class='neutral'>        bytes32 m5;</span>
  5009 |     | <span class='neutral'>        bytes32 m6;</span>
  5010 |     | <span class='neutral'>        bytes32 m7;</span>
  5011 |     | <span class='neutral'>        bytes32 m8;</span>
  5012 |     | <span class='neutral'>        assembly {</span>
  5013 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5014 |     | <span class='neutral'>                let length := 0</span>
  5015 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5016 |     | <span class='neutral'>                mstore(pos, length)</span>
  5017 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5018 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5019 |     | <span class='neutral'>            }</span>
  5020 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5021 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5022 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5023 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5024 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5025 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5026 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5027 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5028 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5029 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,string)`.</span>
  5030 |     | <span class='neutral'>            mstore(0x00, 0x448830a8)</span>
  5031 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5032 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5033 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5034 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5035 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5036 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5037 |     | <span class='neutral'>        }</span>
  5038 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5039 |     | <span class='neutral'>        assembly {</span>
  5040 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5041 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5042 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5043 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5044 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5045 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5046 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5047 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5048 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5049 |     | <span class='neutral'>        }</span>
  5050 |     | <span class='neutral'>    }</span>
  5051 |     | <span class='neutral'></span>
  5052 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  5053 |     | <span class='neutral'>        bytes32 m0;</span>
  5054 |     | <span class='neutral'>        bytes32 m1;</span>
  5055 |     | <span class='neutral'>        bytes32 m2;</span>
  5056 |     | <span class='neutral'>        bytes32 m3;</span>
  5057 |     | <span class='neutral'>        bytes32 m4;</span>
  5058 |     | <span class='neutral'>        bytes32 m5;</span>
  5059 |     | <span class='neutral'>        bytes32 m6;</span>
  5060 |     | <span class='neutral'>        bytes32 m7;</span>
  5061 |     | <span class='neutral'>        bytes32 m8;</span>
  5062 |     | <span class='neutral'>        assembly {</span>
  5063 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5064 |     | <span class='neutral'>                let length := 0</span>
  5065 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5066 |     | <span class='neutral'>                mstore(pos, length)</span>
  5067 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5068 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5069 |     | <span class='neutral'>            }</span>
  5070 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5071 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5072 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5073 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5074 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5075 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5076 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5077 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5078 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5079 |     | <span class='neutral'>            // Selector of `log(address,string,string,address)`.</span>
  5080 |     | <span class='neutral'>            mstore(0x00, 0xa04e2f87)</span>
  5081 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5082 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5083 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5084 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5085 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5086 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5087 |     | <span class='neutral'>        }</span>
  5088 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5089 |     | <span class='neutral'>        assembly {</span>
  5090 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5091 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5092 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5093 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5094 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5095 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5096 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5097 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5098 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5099 |     | <span class='neutral'>        }</span>
  5100 |     | <span class='neutral'>    }</span>
  5101 |     | <span class='neutral'></span>
  5102 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  5103 |     | <span class='neutral'>        bytes32 m0;</span>
  5104 |     | <span class='neutral'>        bytes32 m1;</span>
  5105 |     | <span class='neutral'>        bytes32 m2;</span>
  5106 |     | <span class='neutral'>        bytes32 m3;</span>
  5107 |     | <span class='neutral'>        bytes32 m4;</span>
  5108 |     | <span class='neutral'>        bytes32 m5;</span>
  5109 |     | <span class='neutral'>        bytes32 m6;</span>
  5110 |     | <span class='neutral'>        bytes32 m7;</span>
  5111 |     | <span class='neutral'>        bytes32 m8;</span>
  5112 |     | <span class='neutral'>        assembly {</span>
  5113 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5114 |     | <span class='neutral'>                let length := 0</span>
  5115 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5116 |     | <span class='neutral'>                mstore(pos, length)</span>
  5117 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5118 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5119 |     | <span class='neutral'>            }</span>
  5120 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5121 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5122 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5123 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5124 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5125 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5126 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5127 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5128 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5129 |     | <span class='neutral'>            // Selector of `log(address,string,string,bool)`.</span>
  5130 |     | <span class='neutral'>            mstore(0x00, 0x35a5071f)</span>
  5131 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5132 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5133 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5134 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5135 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5136 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5137 |     | <span class='neutral'>        }</span>
  5138 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5139 |     | <span class='neutral'>        assembly {</span>
  5140 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5141 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5142 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5143 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5144 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5145 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5146 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5147 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5148 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5149 |     | <span class='neutral'>        }</span>
  5150 |     | <span class='neutral'>    }</span>
  5151 |     | <span class='neutral'></span>
  5152 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  5153 |     | <span class='neutral'>        bytes32 m0;</span>
  5154 |     | <span class='neutral'>        bytes32 m1;</span>
  5155 |     | <span class='neutral'>        bytes32 m2;</span>
  5156 |     | <span class='neutral'>        bytes32 m3;</span>
  5157 |     | <span class='neutral'>        bytes32 m4;</span>
  5158 |     | <span class='neutral'>        bytes32 m5;</span>
  5159 |     | <span class='neutral'>        bytes32 m6;</span>
  5160 |     | <span class='neutral'>        bytes32 m7;</span>
  5161 |     | <span class='neutral'>        bytes32 m8;</span>
  5162 |     | <span class='neutral'>        assembly {</span>
  5163 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5164 |     | <span class='neutral'>                let length := 0</span>
  5165 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5166 |     | <span class='neutral'>                mstore(pos, length)</span>
  5167 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5168 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5169 |     | <span class='neutral'>            }</span>
  5170 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5171 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5172 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5173 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5174 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5175 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5176 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5177 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5178 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5179 |     | <span class='neutral'>            // Selector of `log(address,string,string,uint256)`.</span>
  5180 |     | <span class='neutral'>            mstore(0x00, 0x159f8927)</span>
  5181 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5182 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5183 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5184 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5185 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5186 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5187 |     | <span class='neutral'>        }</span>
  5188 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5189 |     | <span class='neutral'>        assembly {</span>
  5190 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5191 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5192 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5193 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5194 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5195 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5196 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5197 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5198 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5199 |     | <span class='neutral'>        }</span>
  5200 |     | <span class='neutral'>    }</span>
  5201 |     | <span class='neutral'></span>
  5202 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  5203 |     | <span class='neutral'>        bytes32 m0;</span>
  5204 |     | <span class='neutral'>        bytes32 m1;</span>
  5205 |     | <span class='neutral'>        bytes32 m2;</span>
  5206 |     | <span class='neutral'>        bytes32 m3;</span>
  5207 |     | <span class='neutral'>        bytes32 m4;</span>
  5208 |     | <span class='neutral'>        bytes32 m5;</span>
  5209 |     | <span class='neutral'>        bytes32 m6;</span>
  5210 |     | <span class='neutral'>        bytes32 m7;</span>
  5211 |     | <span class='neutral'>        bytes32 m8;</span>
  5212 |     | <span class='neutral'>        bytes32 m9;</span>
  5213 |     | <span class='neutral'>        bytes32 m10;</span>
  5214 |     | <span class='neutral'>        assembly {</span>
  5215 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5216 |     | <span class='neutral'>                let length := 0</span>
  5217 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5218 |     | <span class='neutral'>                mstore(pos, length)</span>
  5219 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5220 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5221 |     | <span class='neutral'>            }</span>
  5222 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5223 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5224 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5225 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5226 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5227 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5228 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5229 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5230 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5231 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  5232 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  5233 |     | <span class='neutral'>            // Selector of `log(address,string,string,string)`.</span>
  5234 |     | <span class='neutral'>            mstore(0x00, 0x5d02c50b)</span>
  5235 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5236 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5237 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5238 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  5239 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5240 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5241 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  5242 |     | <span class='neutral'>        }</span>
  5243 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  5244 |     | <span class='neutral'>        assembly {</span>
  5245 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5246 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5247 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5248 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5249 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5250 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5251 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5252 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5253 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5254 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  5255 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  5256 |     | <span class='neutral'>        }</span>
  5257 |     | <span class='neutral'>    }</span>
  5258 |     | <span class='neutral'></span>
  5259 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
  5260 |     | <span class='neutral'>        bytes32 m0;</span>
  5261 |     | <span class='neutral'>        bytes32 m1;</span>
  5262 |     | <span class='neutral'>        bytes32 m2;</span>
  5263 |     | <span class='neutral'>        bytes32 m3;</span>
  5264 |     | <span class='neutral'>        bytes32 m4;</span>
  5265 |     | <span class='neutral'>        assembly {</span>
  5266 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5267 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5268 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5269 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5270 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5271 |     | <span class='neutral'>            // Selector of `log(bool,address,address,address)`.</span>
  5272 |     | <span class='neutral'>            mstore(0x00, 0x1d14d001)</span>
  5273 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5274 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5275 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5276 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5277 |     | <span class='neutral'>        }</span>
  5278 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5279 |     | <span class='neutral'>        assembly {</span>
  5280 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5281 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5282 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5283 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5284 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5285 |     | <span class='neutral'>        }</span>
  5286 |     | <span class='neutral'>    }</span>
  5287 |     | <span class='neutral'></span>
  5288 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
  5289 |     | <span class='neutral'>        bytes32 m0;</span>
  5290 |     | <span class='neutral'>        bytes32 m1;</span>
  5291 |     | <span class='neutral'>        bytes32 m2;</span>
  5292 |     | <span class='neutral'>        bytes32 m3;</span>
  5293 |     | <span class='neutral'>        bytes32 m4;</span>
  5294 |     | <span class='neutral'>        assembly {</span>
  5295 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5296 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5297 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5298 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5299 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5300 |     | <span class='neutral'>            // Selector of `log(bool,address,address,bool)`.</span>
  5301 |     | <span class='neutral'>            mstore(0x00, 0x46600be0)</span>
  5302 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5303 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5304 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5305 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5306 |     | <span class='neutral'>        }</span>
  5307 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5308 |     | <span class='neutral'>        assembly {</span>
  5309 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5310 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5311 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5312 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5313 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5314 |     | <span class='neutral'>        }</span>
  5315 |     | <span class='neutral'>    }</span>
  5316 |     | <span class='neutral'></span>
  5317 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal pure {</span>
  5318 |     | <span class='neutral'>        bytes32 m0;</span>
  5319 |     | <span class='neutral'>        bytes32 m1;</span>
  5320 |     | <span class='neutral'>        bytes32 m2;</span>
  5321 |     | <span class='neutral'>        bytes32 m3;</span>
  5322 |     | <span class='neutral'>        bytes32 m4;</span>
  5323 |     | <span class='neutral'>        assembly {</span>
  5324 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5325 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5326 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5327 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5328 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5329 |     | <span class='neutral'>            // Selector of `log(bool,address,address,uint256)`.</span>
  5330 |     | <span class='neutral'>            mstore(0x00, 0x0c66d1be)</span>
  5331 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5332 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5333 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5334 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5335 |     | <span class='neutral'>        }</span>
  5336 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5337 |     | <span class='neutral'>        assembly {</span>
  5338 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5339 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5340 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5341 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5342 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5343 |     | <span class='neutral'>        }</span>
  5344 |     | <span class='neutral'>    }</span>
  5345 |     | <span class='neutral'></span>
  5346 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {</span>
  5347 |     | <span class='neutral'>        bytes32 m0;</span>
  5348 |     | <span class='neutral'>        bytes32 m1;</span>
  5349 |     | <span class='neutral'>        bytes32 m2;</span>
  5350 |     | <span class='neutral'>        bytes32 m3;</span>
  5351 |     | <span class='neutral'>        bytes32 m4;</span>
  5352 |     | <span class='neutral'>        bytes32 m5;</span>
  5353 |     | <span class='neutral'>        bytes32 m6;</span>
  5354 |     | <span class='neutral'>        assembly {</span>
  5355 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5356 |     | <span class='neutral'>                let length := 0</span>
  5357 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5358 |     | <span class='neutral'>                mstore(pos, length)</span>
  5359 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5360 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5361 |     | <span class='neutral'>            }</span>
  5362 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5363 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5364 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5365 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5366 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5367 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5368 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5369 |     | <span class='neutral'>            // Selector of `log(bool,address,address,string)`.</span>
  5370 |     | <span class='neutral'>            mstore(0x00, 0xd812a167)</span>
  5371 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5372 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5373 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5374 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5375 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5376 |     | <span class='neutral'>        }</span>
  5377 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5378 |     | <span class='neutral'>        assembly {</span>
  5379 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5380 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5381 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5382 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5383 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5384 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5385 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5386 |     | <span class='neutral'>        }</span>
  5387 |     | <span class='neutral'>    }</span>
  5388 |     | <span class='neutral'></span>
  5389 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
  5390 |     | <span class='neutral'>        bytes32 m0;</span>
  5391 |     | <span class='neutral'>        bytes32 m1;</span>
  5392 |     | <span class='neutral'>        bytes32 m2;</span>
  5393 |     | <span class='neutral'>        bytes32 m3;</span>
  5394 |     | <span class='neutral'>        bytes32 m4;</span>
  5395 |     | <span class='neutral'>        assembly {</span>
  5396 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5397 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5398 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5399 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5400 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5401 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,address)`.</span>
  5402 |     | <span class='neutral'>            mstore(0x00, 0x1c41a336)</span>
  5403 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5404 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5405 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5406 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5407 |     | <span class='neutral'>        }</span>
  5408 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5409 |     | <span class='neutral'>        assembly {</span>
  5410 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5411 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5412 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5413 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5414 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5415 |     | <span class='neutral'>        }</span>
  5416 |     | <span class='neutral'>    }</span>
  5417 |     | <span class='neutral'></span>
  5418 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
  5419 |     | <span class='neutral'>        bytes32 m0;</span>
  5420 |     | <span class='neutral'>        bytes32 m1;</span>
  5421 |     | <span class='neutral'>        bytes32 m2;</span>
  5422 |     | <span class='neutral'>        bytes32 m3;</span>
  5423 |     | <span class='neutral'>        bytes32 m4;</span>
  5424 |     | <span class='neutral'>        assembly {</span>
  5425 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5426 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5427 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5428 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5429 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5430 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,bool)`.</span>
  5431 |     | <span class='neutral'>            mstore(0x00, 0x6a9c478b)</span>
  5432 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5433 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5434 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5435 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5436 |     | <span class='neutral'>        }</span>
  5437 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5438 |     | <span class='neutral'>        assembly {</span>
  5439 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5440 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5441 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5442 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5443 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5444 |     | <span class='neutral'>        }</span>
  5445 |     | <span class='neutral'>    }</span>
  5446 |     | <span class='neutral'></span>
  5447 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {</span>
  5448 |     | <span class='neutral'>        bytes32 m0;</span>
  5449 |     | <span class='neutral'>        bytes32 m1;</span>
  5450 |     | <span class='neutral'>        bytes32 m2;</span>
  5451 |     | <span class='neutral'>        bytes32 m3;</span>
  5452 |     | <span class='neutral'>        bytes32 m4;</span>
  5453 |     | <span class='neutral'>        assembly {</span>
  5454 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5455 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5456 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5457 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5458 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5459 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,uint256)`.</span>
  5460 |     | <span class='neutral'>            mstore(0x00, 0x07831502)</span>
  5461 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5462 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5463 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5464 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5465 |     | <span class='neutral'>        }</span>
  5466 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5467 |     | <span class='neutral'>        assembly {</span>
  5468 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5469 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5470 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5471 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5472 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5473 |     | <span class='neutral'>        }</span>
  5474 |     | <span class='neutral'>    }</span>
  5475 |     | <span class='neutral'></span>
  5476 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  5477 |     | <span class='neutral'>        bytes32 m0;</span>
  5478 |     | <span class='neutral'>        bytes32 m1;</span>
  5479 |     | <span class='neutral'>        bytes32 m2;</span>
  5480 |     | <span class='neutral'>        bytes32 m3;</span>
  5481 |     | <span class='neutral'>        bytes32 m4;</span>
  5482 |     | <span class='neutral'>        bytes32 m5;</span>
  5483 |     | <span class='neutral'>        bytes32 m6;</span>
  5484 |     | <span class='neutral'>        assembly {</span>
  5485 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5486 |     | <span class='neutral'>                let length := 0</span>
  5487 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5488 |     | <span class='neutral'>                mstore(pos, length)</span>
  5489 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5490 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5491 |     | <span class='neutral'>            }</span>
  5492 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5493 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5494 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5495 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5496 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5497 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5498 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5499 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,string)`.</span>
  5500 |     | <span class='neutral'>            mstore(0x00, 0x4a66cb34)</span>
  5501 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5502 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5503 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5504 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5505 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5506 |     | <span class='neutral'>        }</span>
  5507 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5508 |     | <span class='neutral'>        assembly {</span>
  5509 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5510 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5511 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5512 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5513 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5514 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5515 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5516 |     | <span class='neutral'>        }</span>
  5517 |     | <span class='neutral'>    }</span>
  5518 |     | <span class='neutral'></span>
  5519 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal pure {</span>
  5520 |     | <span class='neutral'>        bytes32 m0;</span>
  5521 |     | <span class='neutral'>        bytes32 m1;</span>
  5522 |     | <span class='neutral'>        bytes32 m2;</span>
  5523 |     | <span class='neutral'>        bytes32 m3;</span>
  5524 |     | <span class='neutral'>        bytes32 m4;</span>
  5525 |     | <span class='neutral'>        assembly {</span>
  5526 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5527 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5528 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5529 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5530 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5531 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,address)`.</span>
  5532 |     | <span class='neutral'>            mstore(0x00, 0x136b05dd)</span>
  5533 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5534 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5535 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5536 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5537 |     | <span class='neutral'>        }</span>
  5538 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5539 |     | <span class='neutral'>        assembly {</span>
  5540 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5541 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5542 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5543 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5544 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5545 |     | <span class='neutral'>        }</span>
  5546 |     | <span class='neutral'>    }</span>
  5547 |     | <span class='neutral'></span>
  5548 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {</span>
  5549 |     | <span class='neutral'>        bytes32 m0;</span>
  5550 |     | <span class='neutral'>        bytes32 m1;</span>
  5551 |     | <span class='neutral'>        bytes32 m2;</span>
  5552 |     | <span class='neutral'>        bytes32 m3;</span>
  5553 |     | <span class='neutral'>        bytes32 m4;</span>
  5554 |     | <span class='neutral'>        assembly {</span>
  5555 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5556 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5557 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5558 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5559 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5560 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,bool)`.</span>
  5561 |     | <span class='neutral'>            mstore(0x00, 0xd6019f1c)</span>
  5562 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5563 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5564 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5565 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5566 |     | <span class='neutral'>        }</span>
  5567 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5568 |     | <span class='neutral'>        assembly {</span>
  5569 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5570 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5571 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5572 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5573 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5574 |     | <span class='neutral'>        }</span>
  5575 |     | <span class='neutral'>    }</span>
  5576 |     | <span class='neutral'></span>
  5577 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  5578 |     | <span class='neutral'>        bytes32 m0;</span>
  5579 |     | <span class='neutral'>        bytes32 m1;</span>
  5580 |     | <span class='neutral'>        bytes32 m2;</span>
  5581 |     | <span class='neutral'>        bytes32 m3;</span>
  5582 |     | <span class='neutral'>        bytes32 m4;</span>
  5583 |     | <span class='neutral'>        assembly {</span>
  5584 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5585 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5586 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5587 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5588 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5589 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,uint256)`.</span>
  5590 |     | <span class='neutral'>            mstore(0x00, 0x7bf181a1)</span>
  5591 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5592 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5593 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5594 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5595 |     | <span class='neutral'>        }</span>
  5596 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5597 |     | <span class='neutral'>        assembly {</span>
  5598 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5599 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5600 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5601 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5602 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5603 |     | <span class='neutral'>        }</span>
  5604 |     | <span class='neutral'>    }</span>
  5605 |     | <span class='neutral'></span>
  5606 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  5607 |     | <span class='neutral'>        bytes32 m0;</span>
  5608 |     | <span class='neutral'>        bytes32 m1;</span>
  5609 |     | <span class='neutral'>        bytes32 m2;</span>
  5610 |     | <span class='neutral'>        bytes32 m3;</span>
  5611 |     | <span class='neutral'>        bytes32 m4;</span>
  5612 |     | <span class='neutral'>        bytes32 m5;</span>
  5613 |     | <span class='neutral'>        bytes32 m6;</span>
  5614 |     | <span class='neutral'>        assembly {</span>
  5615 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5616 |     | <span class='neutral'>                let length := 0</span>
  5617 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5618 |     | <span class='neutral'>                mstore(pos, length)</span>
  5619 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5620 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5621 |     | <span class='neutral'>            }</span>
  5622 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5623 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5624 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5625 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5626 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5627 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5628 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5629 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,string)`.</span>
  5630 |     | <span class='neutral'>            mstore(0x00, 0x51f09ff8)</span>
  5631 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5632 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5633 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5634 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5635 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5636 |     | <span class='neutral'>        }</span>
  5637 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5638 |     | <span class='neutral'>        assembly {</span>
  5639 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5640 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5641 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5642 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5643 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5644 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5645 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5646 |     | <span class='neutral'>        }</span>
  5647 |     | <span class='neutral'>    }</span>
  5648 |     | <span class='neutral'></span>
  5649 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {</span>
  5650 |     | <span class='neutral'>        bytes32 m0;</span>
  5651 |     | <span class='neutral'>        bytes32 m1;</span>
  5652 |     | <span class='neutral'>        bytes32 m2;</span>
  5653 |     | <span class='neutral'>        bytes32 m3;</span>
  5654 |     | <span class='neutral'>        bytes32 m4;</span>
  5655 |     | <span class='neutral'>        bytes32 m5;</span>
  5656 |     | <span class='neutral'>        bytes32 m6;</span>
  5657 |     | <span class='neutral'>        assembly {</span>
  5658 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5659 |     | <span class='neutral'>                let length := 0</span>
  5660 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5661 |     | <span class='neutral'>                mstore(pos, length)</span>
  5662 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5663 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5664 |     | <span class='neutral'>            }</span>
  5665 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5666 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5667 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5668 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5669 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5670 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5671 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5672 |     | <span class='neutral'>            // Selector of `log(bool,address,string,address)`.</span>
  5673 |     | <span class='neutral'>            mstore(0x00, 0x6f7c603e)</span>
  5674 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5675 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5676 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5677 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5678 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5679 |     | <span class='neutral'>        }</span>
  5680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5681 |     | <span class='neutral'>        assembly {</span>
  5682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5689 |     | <span class='neutral'>        }</span>
  5690 |     | <span class='neutral'>    }</span>
  5691 |     | <span class='neutral'></span>
  5692 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  5693 |     | <span class='neutral'>        bytes32 m0;</span>
  5694 |     | <span class='neutral'>        bytes32 m1;</span>
  5695 |     | <span class='neutral'>        bytes32 m2;</span>
  5696 |     | <span class='neutral'>        bytes32 m3;</span>
  5697 |     | <span class='neutral'>        bytes32 m4;</span>
  5698 |     | <span class='neutral'>        bytes32 m5;</span>
  5699 |     | <span class='neutral'>        bytes32 m6;</span>
  5700 |     | <span class='neutral'>        assembly {</span>
  5701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5702 |     | <span class='neutral'>                let length := 0</span>
  5703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5704 |     | <span class='neutral'>                mstore(pos, length)</span>
  5705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5707 |     | <span class='neutral'>            }</span>
  5708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5715 |     | <span class='neutral'>            // Selector of `log(bool,address,string,bool)`.</span>
  5716 |     | <span class='neutral'>            mstore(0x00, 0xe2bfd60b)</span>
  5717 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5719 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5721 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5722 |     | <span class='neutral'>        }</span>
  5723 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5724 |     | <span class='neutral'>        assembly {</span>
  5725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5730 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5731 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5732 |     | <span class='neutral'>        }</span>
  5733 |     | <span class='neutral'>    }</span>
  5734 |     | <span class='neutral'></span>
  5735 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  5736 |     | <span class='neutral'>        bytes32 m0;</span>
  5737 |     | <span class='neutral'>        bytes32 m1;</span>
  5738 |     | <span class='neutral'>        bytes32 m2;</span>
  5739 |     | <span class='neutral'>        bytes32 m3;</span>
  5740 |     | <span class='neutral'>        bytes32 m4;</span>
  5741 |     | <span class='neutral'>        bytes32 m5;</span>
  5742 |     | <span class='neutral'>        bytes32 m6;</span>
  5743 |     | <span class='neutral'>        assembly {</span>
  5744 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5745 |     | <span class='neutral'>                let length := 0</span>
  5746 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5747 |     | <span class='neutral'>                mstore(pos, length)</span>
  5748 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5749 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5750 |     | <span class='neutral'>            }</span>
  5751 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5752 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5753 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5754 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5755 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5756 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5757 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5758 |     | <span class='neutral'>            // Selector of `log(bool,address,string,uint256)`.</span>
  5759 |     | <span class='neutral'>            mstore(0x00, 0xc21f64c7)</span>
  5760 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5761 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5762 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5763 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5764 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5765 |     | <span class='neutral'>        }</span>
  5766 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5767 |     | <span class='neutral'>        assembly {</span>
  5768 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5769 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5770 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5771 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5772 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5773 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5774 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5775 |     | <span class='neutral'>        }</span>
  5776 |     | <span class='neutral'>    }</span>
  5777 |     | <span class='neutral'></span>
  5778 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  5779 |     | <span class='neutral'>        bytes32 m0;</span>
  5780 |     | <span class='neutral'>        bytes32 m1;</span>
  5781 |     | <span class='neutral'>        bytes32 m2;</span>
  5782 |     | <span class='neutral'>        bytes32 m3;</span>
  5783 |     | <span class='neutral'>        bytes32 m4;</span>
  5784 |     | <span class='neutral'>        bytes32 m5;</span>
  5785 |     | <span class='neutral'>        bytes32 m6;</span>
  5786 |     | <span class='neutral'>        bytes32 m7;</span>
  5787 |     | <span class='neutral'>        bytes32 m8;</span>
  5788 |     | <span class='neutral'>        assembly {</span>
  5789 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5790 |     | <span class='neutral'>                let length := 0</span>
  5791 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5792 |     | <span class='neutral'>                mstore(pos, length)</span>
  5793 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5794 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5795 |     | <span class='neutral'>            }</span>
  5796 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5797 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5798 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5799 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5800 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5801 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5802 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5803 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5804 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5805 |     | <span class='neutral'>            // Selector of `log(bool,address,string,string)`.</span>
  5806 |     | <span class='neutral'>            mstore(0x00, 0xa73c1db6)</span>
  5807 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5808 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5809 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5810 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5811 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5812 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5813 |     | <span class='neutral'>        }</span>
  5814 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5815 |     | <span class='neutral'>        assembly {</span>
  5816 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5817 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5818 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5819 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5820 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5821 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5822 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5823 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5824 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5825 |     | <span class='neutral'>        }</span>
  5826 |     | <span class='neutral'>    }</span>
  5827 |     | <span class='neutral'></span>
  5828 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
  5829 |     | <span class='neutral'>        bytes32 m0;</span>
  5830 |     | <span class='neutral'>        bytes32 m1;</span>
  5831 |     | <span class='neutral'>        bytes32 m2;</span>
  5832 |     | <span class='neutral'>        bytes32 m3;</span>
  5833 |     | <span class='neutral'>        bytes32 m4;</span>
  5834 |     | <span class='neutral'>        assembly {</span>
  5835 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5836 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5837 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5838 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5839 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5840 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,address)`.</span>
  5841 |     | <span class='neutral'>            mstore(0x00, 0xf4880ea4)</span>
  5842 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5843 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5844 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5845 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5846 |     | <span class='neutral'>        }</span>
  5847 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5848 |     | <span class='neutral'>        assembly {</span>
  5849 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5850 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5851 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5852 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5853 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5854 |     | <span class='neutral'>        }</span>
  5855 |     | <span class='neutral'>    }</span>
  5856 |     | <span class='neutral'></span>
  5857 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
  5858 |     | <span class='neutral'>        bytes32 m0;</span>
  5859 |     | <span class='neutral'>        bytes32 m1;</span>
  5860 |     | <span class='neutral'>        bytes32 m2;</span>
  5861 |     | <span class='neutral'>        bytes32 m3;</span>
  5862 |     | <span class='neutral'>        bytes32 m4;</span>
  5863 |     | <span class='neutral'>        assembly {</span>
  5864 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5865 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5866 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5867 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5868 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5869 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,bool)`.</span>
  5870 |     | <span class='neutral'>            mstore(0x00, 0xc0a302d8)</span>
  5871 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5872 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5873 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5874 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5875 |     | <span class='neutral'>        }</span>
  5876 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5877 |     | <span class='neutral'>        assembly {</span>
  5878 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5879 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5880 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5881 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5882 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5883 |     | <span class='neutral'>        }</span>
  5884 |     | <span class='neutral'>    }</span>
  5885 |     | <span class='neutral'></span>
  5886 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {</span>
  5887 |     | <span class='neutral'>        bytes32 m0;</span>
  5888 |     | <span class='neutral'>        bytes32 m1;</span>
  5889 |     | <span class='neutral'>        bytes32 m2;</span>
  5890 |     | <span class='neutral'>        bytes32 m3;</span>
  5891 |     | <span class='neutral'>        bytes32 m4;</span>
  5892 |     | <span class='neutral'>        assembly {</span>
  5893 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5894 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5895 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5896 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5897 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5898 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,uint256)`.</span>
  5899 |     | <span class='neutral'>            mstore(0x00, 0x4c123d57)</span>
  5900 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5901 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5902 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5903 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5904 |     | <span class='neutral'>        }</span>
  5905 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5906 |     | <span class='neutral'>        assembly {</span>
  5907 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5908 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5909 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5910 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5911 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5912 |     | <span class='neutral'>        }</span>
  5913 |     | <span class='neutral'>    }</span>
  5914 |     | <span class='neutral'></span>
  5915 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  5916 |     | <span class='neutral'>        bytes32 m0;</span>
  5917 |     | <span class='neutral'>        bytes32 m1;</span>
  5918 |     | <span class='neutral'>        bytes32 m2;</span>
  5919 |     | <span class='neutral'>        bytes32 m3;</span>
  5920 |     | <span class='neutral'>        bytes32 m4;</span>
  5921 |     | <span class='neutral'>        bytes32 m5;</span>
  5922 |     | <span class='neutral'>        bytes32 m6;</span>
  5923 |     | <span class='neutral'>        assembly {</span>
  5924 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5925 |     | <span class='neutral'>                let length := 0</span>
  5926 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5927 |     | <span class='neutral'>                mstore(pos, length)</span>
  5928 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5929 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5930 |     | <span class='neutral'>            }</span>
  5931 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5932 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5933 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5934 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5935 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5936 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5937 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5938 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,string)`.</span>
  5939 |     | <span class='neutral'>            mstore(0x00, 0xa0a47963)</span>
  5940 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5941 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5942 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5943 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5944 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5945 |     | <span class='neutral'>        }</span>
  5946 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5947 |     | <span class='neutral'>        assembly {</span>
  5948 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5949 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5950 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5951 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5952 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5953 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5954 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5955 |     | <span class='neutral'>        }</span>
  5956 |     | <span class='neutral'>    }</span>
  5957 |     | <span class='neutral'></span>
  5958 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
  5959 |     | <span class='neutral'>        bytes32 m0;</span>
  5960 |     | <span class='neutral'>        bytes32 m1;</span>
  5961 |     | <span class='neutral'>        bytes32 m2;</span>
  5962 |     | <span class='neutral'>        bytes32 m3;</span>
  5963 |     | <span class='neutral'>        bytes32 m4;</span>
  5964 |     | <span class='neutral'>        assembly {</span>
  5965 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5966 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5967 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5968 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5969 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5970 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,address)`.</span>
  5971 |     | <span class='neutral'>            mstore(0x00, 0x8c329b1a)</span>
  5972 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5973 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5974 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5975 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5976 |     | <span class='neutral'>        }</span>
  5977 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5978 |     | <span class='neutral'>        assembly {</span>
  5979 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5980 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5981 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5982 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5983 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5984 |     | <span class='neutral'>        }</span>
  5985 |     | <span class='neutral'>    }</span>
  5986 |     | <span class='neutral'></span>
  5987 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
  5988 |     | <span class='neutral'>        bytes32 m0;</span>
  5989 |     | <span class='neutral'>        bytes32 m1;</span>
  5990 |     | <span class='neutral'>        bytes32 m2;</span>
  5991 |     | <span class='neutral'>        bytes32 m3;</span>
  5992 |     | <span class='neutral'>        bytes32 m4;</span>
  5993 |     | <span class='neutral'>        assembly {</span>
  5994 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5995 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5996 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5997 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5998 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5999 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,bool)`.</span>
  6000 |     | <span class='neutral'>            mstore(0x00, 0x3b2a5ce0)</span>
  6001 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6002 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6003 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6004 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6005 |     | <span class='neutral'>        }</span>
  6006 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6007 |     | <span class='neutral'>        assembly {</span>
  6008 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6009 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6010 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6011 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6012 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6013 |     | <span class='neutral'>        }</span>
  6014 |     | <span class='neutral'>    }</span>
  6015 |     | <span class='neutral'></span>
  6016 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  6017 |     | <span class='neutral'>        bytes32 m0;</span>
  6018 |     | <span class='neutral'>        bytes32 m1;</span>
  6019 |     | <span class='neutral'>        bytes32 m2;</span>
  6020 |     | <span class='neutral'>        bytes32 m3;</span>
  6021 |     | <span class='neutral'>        bytes32 m4;</span>
  6022 |     | <span class='neutral'>        assembly {</span>
  6023 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6024 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6025 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6026 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6027 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6028 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,uint256)`.</span>
  6029 |     | <span class='neutral'>            mstore(0x00, 0x6d7045c1)</span>
  6030 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6031 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6032 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6033 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6034 |     | <span class='neutral'>        }</span>
  6035 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6036 |     | <span class='neutral'>        assembly {</span>
  6037 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6038 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6039 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6040 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6041 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6042 |     | <span class='neutral'>        }</span>
  6043 |     | <span class='neutral'>    }</span>
  6044 |     | <span class='neutral'></span>
  6045 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  6046 |     | <span class='neutral'>        bytes32 m0;</span>
  6047 |     | <span class='neutral'>        bytes32 m1;</span>
  6048 |     | <span class='neutral'>        bytes32 m2;</span>
  6049 |     | <span class='neutral'>        bytes32 m3;</span>
  6050 |     | <span class='neutral'>        bytes32 m4;</span>
  6051 |     | <span class='neutral'>        bytes32 m5;</span>
  6052 |     | <span class='neutral'>        bytes32 m6;</span>
  6053 |     | <span class='neutral'>        assembly {</span>
  6054 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6055 |     | <span class='neutral'>                let length := 0</span>
  6056 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6057 |     | <span class='neutral'>                mstore(pos, length)</span>
  6058 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6059 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6060 |     | <span class='neutral'>            }</span>
  6061 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6062 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6063 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6064 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6065 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6066 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6067 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6068 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,string)`.</span>
  6069 |     | <span class='neutral'>            mstore(0x00, 0x2ae408d4)</span>
  6070 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6071 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6072 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6073 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6074 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6075 |     | <span class='neutral'>        }</span>
  6076 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6077 |     | <span class='neutral'>        assembly {</span>
  6078 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6079 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6080 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6081 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6082 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6083 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6084 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6085 |     | <span class='neutral'>        }</span>
  6086 |     | <span class='neutral'>    }</span>
  6087 |     | <span class='neutral'></span>
  6088 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {</span>
  6089 |     | <span class='neutral'>        bytes32 m0;</span>
  6090 |     | <span class='neutral'>        bytes32 m1;</span>
  6091 |     | <span class='neutral'>        bytes32 m2;</span>
  6092 |     | <span class='neutral'>        bytes32 m3;</span>
  6093 |     | <span class='neutral'>        bytes32 m4;</span>
  6094 |     | <span class='neutral'>        assembly {</span>
  6095 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6096 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6097 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6098 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6099 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6100 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,address)`.</span>
  6101 |     | <span class='neutral'>            mstore(0x00, 0x54a7a9a0)</span>
  6102 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6103 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6104 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6105 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6106 |     | <span class='neutral'>        }</span>
  6107 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6108 |     | <span class='neutral'>        assembly {</span>
  6109 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6110 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6111 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6112 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6113 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6114 |     | <span class='neutral'>        }</span>
  6115 |     | <span class='neutral'>    }</span>
  6116 |     | <span class='neutral'></span>
  6117 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  6118 |     | <span class='neutral'>        bytes32 m0;</span>
  6119 |     | <span class='neutral'>        bytes32 m1;</span>
  6120 |     | <span class='neutral'>        bytes32 m2;</span>
  6121 |     | <span class='neutral'>        bytes32 m3;</span>
  6122 |     | <span class='neutral'>        bytes32 m4;</span>
  6123 |     | <span class='neutral'>        assembly {</span>
  6124 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6125 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6126 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6127 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6128 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6129 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,bool)`.</span>
  6130 |     | <span class='neutral'>            mstore(0x00, 0x619e4d0e)</span>
  6131 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6132 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6133 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6134 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6135 |     | <span class='neutral'>        }</span>
  6136 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6137 |     | <span class='neutral'>        assembly {</span>
  6138 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6139 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6140 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6141 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6142 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6143 |     | <span class='neutral'>        }</span>
  6144 |     | <span class='neutral'>    }</span>
  6145 |     | <span class='neutral'></span>
  6146 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  6147 |     | <span class='neutral'>        bytes32 m0;</span>
  6148 |     | <span class='neutral'>        bytes32 m1;</span>
  6149 |     | <span class='neutral'>        bytes32 m2;</span>
  6150 |     | <span class='neutral'>        bytes32 m3;</span>
  6151 |     | <span class='neutral'>        bytes32 m4;</span>
  6152 |     | <span class='neutral'>        assembly {</span>
  6153 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6154 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6155 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6156 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6157 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6158 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,uint256)`.</span>
  6159 |     | <span class='neutral'>            mstore(0x00, 0x0bb00eab)</span>
  6160 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6161 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6162 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6163 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6164 |     | <span class='neutral'>        }</span>
  6165 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6166 |     | <span class='neutral'>        assembly {</span>
  6167 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6168 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6169 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6170 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6171 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6172 |     | <span class='neutral'>        }</span>
  6173 |     | <span class='neutral'>    }</span>
  6174 |     | <span class='neutral'></span>
  6175 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  6176 |     | <span class='neutral'>        bytes32 m0;</span>
  6177 |     | <span class='neutral'>        bytes32 m1;</span>
  6178 |     | <span class='neutral'>        bytes32 m2;</span>
  6179 |     | <span class='neutral'>        bytes32 m3;</span>
  6180 |     | <span class='neutral'>        bytes32 m4;</span>
  6181 |     | <span class='neutral'>        bytes32 m5;</span>
  6182 |     | <span class='neutral'>        bytes32 m6;</span>
  6183 |     | <span class='neutral'>        assembly {</span>
  6184 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6185 |     | <span class='neutral'>                let length := 0</span>
  6186 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6187 |     | <span class='neutral'>                mstore(pos, length)</span>
  6188 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6189 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6190 |     | <span class='neutral'>            }</span>
  6191 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6192 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6193 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6194 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6195 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6196 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6197 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6198 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,string)`.</span>
  6199 |     | <span class='neutral'>            mstore(0x00, 0x7dd4d0e0)</span>
  6200 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6201 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6202 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6203 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6204 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6205 |     | <span class='neutral'>        }</span>
  6206 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6207 |     | <span class='neutral'>        assembly {</span>
  6208 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6209 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6210 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6211 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6212 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6213 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6214 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6215 |     | <span class='neutral'>        }</span>
  6216 |     | <span class='neutral'>    }</span>
  6217 |     | <span class='neutral'></span>
  6218 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  6219 |     | <span class='neutral'>        bytes32 m0;</span>
  6220 |     | <span class='neutral'>        bytes32 m1;</span>
  6221 |     | <span class='neutral'>        bytes32 m2;</span>
  6222 |     | <span class='neutral'>        bytes32 m3;</span>
  6223 |     | <span class='neutral'>        bytes32 m4;</span>
  6224 |     | <span class='neutral'>        bytes32 m5;</span>
  6225 |     | <span class='neutral'>        bytes32 m6;</span>
  6226 |     | <span class='neutral'>        assembly {</span>
  6227 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6228 |     | <span class='neutral'>                let length := 0</span>
  6229 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6230 |     | <span class='neutral'>                mstore(pos, length)</span>
  6231 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6232 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6233 |     | <span class='neutral'>            }</span>
  6234 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6235 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6236 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6237 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6238 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6239 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6240 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6241 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,address)`.</span>
  6242 |     | <span class='neutral'>            mstore(0x00, 0xf9ad2b89)</span>
  6243 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6244 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6245 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6246 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6247 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6248 |     | <span class='neutral'>        }</span>
  6249 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6250 |     | <span class='neutral'>        assembly {</span>
  6251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6258 |     | <span class='neutral'>        }</span>
  6259 |     | <span class='neutral'>    }</span>
  6260 |     | <span class='neutral'></span>
  6261 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  6262 |     | <span class='neutral'>        bytes32 m0;</span>
  6263 |     | <span class='neutral'>        bytes32 m1;</span>
  6264 |     | <span class='neutral'>        bytes32 m2;</span>
  6265 |     | <span class='neutral'>        bytes32 m3;</span>
  6266 |     | <span class='neutral'>        bytes32 m4;</span>
  6267 |     | <span class='neutral'>        bytes32 m5;</span>
  6268 |     | <span class='neutral'>        bytes32 m6;</span>
  6269 |     | <span class='neutral'>        assembly {</span>
  6270 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6271 |     | <span class='neutral'>                let length := 0</span>
  6272 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6273 |     | <span class='neutral'>                mstore(pos, length)</span>
  6274 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6275 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6276 |     | <span class='neutral'>            }</span>
  6277 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6278 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6279 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6280 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6281 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6282 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6283 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6284 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,bool)`.</span>
  6285 |     | <span class='neutral'>            mstore(0x00, 0xb857163a)</span>
  6286 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6287 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6288 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6289 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6290 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6291 |     | <span class='neutral'>        }</span>
  6292 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6293 |     | <span class='neutral'>        assembly {</span>
  6294 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6295 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6296 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6297 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6298 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6299 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6300 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6301 |     | <span class='neutral'>        }</span>
  6302 |     | <span class='neutral'>    }</span>
  6303 |     | <span class='neutral'></span>
  6304 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  6305 |     | <span class='neutral'>        bytes32 m0;</span>
  6306 |     | <span class='neutral'>        bytes32 m1;</span>
  6307 |     | <span class='neutral'>        bytes32 m2;</span>
  6308 |     | <span class='neutral'>        bytes32 m3;</span>
  6309 |     | <span class='neutral'>        bytes32 m4;</span>
  6310 |     | <span class='neutral'>        bytes32 m5;</span>
  6311 |     | <span class='neutral'>        bytes32 m6;</span>
  6312 |     | <span class='neutral'>        assembly {</span>
  6313 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6314 |     | <span class='neutral'>                let length := 0</span>
  6315 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6316 |     | <span class='neutral'>                mstore(pos, length)</span>
  6317 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6318 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6319 |     | <span class='neutral'>            }</span>
  6320 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6321 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6322 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6323 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6324 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6325 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6326 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6327 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,uint256)`.</span>
  6328 |     | <span class='neutral'>            mstore(0x00, 0xe3a9ca2f)</span>
  6329 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6330 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6331 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6332 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6333 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6334 |     | <span class='neutral'>        }</span>
  6335 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6336 |     | <span class='neutral'>        assembly {</span>
  6337 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6338 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6339 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6340 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6341 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6342 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6343 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6344 |     | <span class='neutral'>        }</span>
  6345 |     | <span class='neutral'>    }</span>
  6346 |     | <span class='neutral'></span>
  6347 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6348 |     | <span class='neutral'>        bytes32 m0;</span>
  6349 |     | <span class='neutral'>        bytes32 m1;</span>
  6350 |     | <span class='neutral'>        bytes32 m2;</span>
  6351 |     | <span class='neutral'>        bytes32 m3;</span>
  6352 |     | <span class='neutral'>        bytes32 m4;</span>
  6353 |     | <span class='neutral'>        bytes32 m5;</span>
  6354 |     | <span class='neutral'>        bytes32 m6;</span>
  6355 |     | <span class='neutral'>        bytes32 m7;</span>
  6356 |     | <span class='neutral'>        bytes32 m8;</span>
  6357 |     | <span class='neutral'>        assembly {</span>
  6358 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6359 |     | <span class='neutral'>                let length := 0</span>
  6360 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6361 |     | <span class='neutral'>                mstore(pos, length)</span>
  6362 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6363 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6364 |     | <span class='neutral'>            }</span>
  6365 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6366 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6367 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6368 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6369 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6370 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6371 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6372 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6373 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6374 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,string)`.</span>
  6375 |     | <span class='neutral'>            mstore(0x00, 0x6d1e8751)</span>
  6376 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6377 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6378 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6379 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6380 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6381 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6382 |     | <span class='neutral'>        }</span>
  6383 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6384 |     | <span class='neutral'>        assembly {</span>
  6385 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6386 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6387 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6388 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6389 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6390 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6391 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6392 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6393 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6394 |     | <span class='neutral'>        }</span>
  6395 |     | <span class='neutral'>    }</span>
  6396 |     | <span class='neutral'></span>
  6397 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal pure {</span>
  6398 |     | <span class='neutral'>        bytes32 m0;</span>
  6399 |     | <span class='neutral'>        bytes32 m1;</span>
  6400 |     | <span class='neutral'>        bytes32 m2;</span>
  6401 |     | <span class='neutral'>        bytes32 m3;</span>
  6402 |     | <span class='neutral'>        bytes32 m4;</span>
  6403 |     | <span class='neutral'>        assembly {</span>
  6404 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6405 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6406 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6407 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6408 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6409 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,address)`.</span>
  6410 |     | <span class='neutral'>            mstore(0x00, 0x26f560a8)</span>
  6411 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6412 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6413 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6414 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6415 |     | <span class='neutral'>        }</span>
  6416 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6417 |     | <span class='neutral'>        assembly {</span>
  6418 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6419 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6420 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6421 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6422 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6423 |     | <span class='neutral'>        }</span>
  6424 |     | <span class='neutral'>    }</span>
  6425 |     | <span class='neutral'></span>
  6426 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {</span>
  6427 |     | <span class='neutral'>        bytes32 m0;</span>
  6428 |     | <span class='neutral'>        bytes32 m1;</span>
  6429 |     | <span class='neutral'>        bytes32 m2;</span>
  6430 |     | <span class='neutral'>        bytes32 m3;</span>
  6431 |     | <span class='neutral'>        bytes32 m4;</span>
  6432 |     | <span class='neutral'>        assembly {</span>
  6433 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6434 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6435 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6436 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6437 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6438 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,bool)`.</span>
  6439 |     | <span class='neutral'>            mstore(0x00, 0xb4c314ff)</span>
  6440 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6441 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6442 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6443 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6444 |     | <span class='neutral'>        }</span>
  6445 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6446 |     | <span class='neutral'>        assembly {</span>
  6447 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6448 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6449 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6450 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6451 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6452 |     | <span class='neutral'>        }</span>
  6453 |     | <span class='neutral'>    }</span>
  6454 |     | <span class='neutral'></span>
  6455 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  6456 |     | <span class='neutral'>        bytes32 m0;</span>
  6457 |     | <span class='neutral'>        bytes32 m1;</span>
  6458 |     | <span class='neutral'>        bytes32 m2;</span>
  6459 |     | <span class='neutral'>        bytes32 m3;</span>
  6460 |     | <span class='neutral'>        bytes32 m4;</span>
  6461 |     | <span class='neutral'>        assembly {</span>
  6462 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6463 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6464 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6465 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6466 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6467 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,uint256)`.</span>
  6468 |     | <span class='neutral'>            mstore(0x00, 0x1537dc87)</span>
  6469 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6470 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6471 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6472 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6473 |     | <span class='neutral'>        }</span>
  6474 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6475 |     | <span class='neutral'>        assembly {</span>
  6476 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6477 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6478 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6479 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6480 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6481 |     | <span class='neutral'>        }</span>
  6482 |     | <span class='neutral'>    }</span>
  6483 |     | <span class='neutral'></span>
  6484 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  6485 |     | <span class='neutral'>        bytes32 m0;</span>
  6486 |     | <span class='neutral'>        bytes32 m1;</span>
  6487 |     | <span class='neutral'>        bytes32 m2;</span>
  6488 |     | <span class='neutral'>        bytes32 m3;</span>
  6489 |     | <span class='neutral'>        bytes32 m4;</span>
  6490 |     | <span class='neutral'>        bytes32 m5;</span>
  6491 |     | <span class='neutral'>        bytes32 m6;</span>
  6492 |     | <span class='neutral'>        assembly {</span>
  6493 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6494 |     | <span class='neutral'>                let length := 0</span>
  6495 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6496 |     | <span class='neutral'>                mstore(pos, length)</span>
  6497 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6498 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6499 |     | <span class='neutral'>            }</span>
  6500 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6501 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6502 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6503 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6504 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6505 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6506 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6507 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,string)`.</span>
  6508 |     | <span class='neutral'>            mstore(0x00, 0x1bb3b09a)</span>
  6509 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6510 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6511 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6512 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6513 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6514 |     | <span class='neutral'>        }</span>
  6515 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6516 |     | <span class='neutral'>        assembly {</span>
  6517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6521 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6522 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6523 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6524 |     | <span class='neutral'>        }</span>
  6525 |     | <span class='neutral'>    }</span>
  6526 |     | <span class='neutral'></span>
  6527 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {</span>
  6528 |     | <span class='neutral'>        bytes32 m0;</span>
  6529 |     | <span class='neutral'>        bytes32 m1;</span>
  6530 |     | <span class='neutral'>        bytes32 m2;</span>
  6531 |     | <span class='neutral'>        bytes32 m3;</span>
  6532 |     | <span class='neutral'>        bytes32 m4;</span>
  6533 |     | <span class='neutral'>        assembly {</span>
  6534 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6535 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6536 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6537 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6538 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6539 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,address)`.</span>
  6540 |     | <span class='neutral'>            mstore(0x00, 0x9acd3616)</span>
  6541 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6542 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6543 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6544 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6545 |     | <span class='neutral'>        }</span>
  6546 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6547 |     | <span class='neutral'>        assembly {</span>
  6548 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6549 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6550 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6551 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6552 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6553 |     | <span class='neutral'>        }</span>
  6554 |     | <span class='neutral'>    }</span>
  6555 |     | <span class='neutral'></span>
  6556 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  6557 |     | <span class='neutral'>        bytes32 m0;</span>
  6558 |     | <span class='neutral'>        bytes32 m1;</span>
  6559 |     | <span class='neutral'>        bytes32 m2;</span>
  6560 |     | <span class='neutral'>        bytes32 m3;</span>
  6561 |     | <span class='neutral'>        bytes32 m4;</span>
  6562 |     | <span class='neutral'>        assembly {</span>
  6563 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6564 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6565 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6566 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6567 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6568 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,bool)`.</span>
  6569 |     | <span class='neutral'>            mstore(0x00, 0xceb5f4d7)</span>
  6570 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6571 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6572 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6573 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6574 |     | <span class='neutral'>        }</span>
  6575 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6576 |     | <span class='neutral'>        assembly {</span>
  6577 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6578 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6579 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6580 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6581 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6582 |     | <span class='neutral'>        }</span>
  6583 |     | <span class='neutral'>    }</span>
  6584 |     | <span class='neutral'></span>
  6585 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  6586 |     | <span class='neutral'>        bytes32 m0;</span>
  6587 |     | <span class='neutral'>        bytes32 m1;</span>
  6588 |     | <span class='neutral'>        bytes32 m2;</span>
  6589 |     | <span class='neutral'>        bytes32 m3;</span>
  6590 |     | <span class='neutral'>        bytes32 m4;</span>
  6591 |     | <span class='neutral'>        assembly {</span>
  6592 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6593 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6594 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6595 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6596 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6597 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,uint256)`.</span>
  6598 |     | <span class='neutral'>            mstore(0x00, 0x7f9bbca2)</span>
  6599 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6600 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6601 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6602 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6603 |     | <span class='neutral'>        }</span>
  6604 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6605 |     | <span class='neutral'>        assembly {</span>
  6606 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6607 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6608 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6609 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6610 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6611 |     | <span class='neutral'>        }</span>
  6612 |     | <span class='neutral'>    }</span>
  6613 |     | <span class='neutral'></span>
  6614 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  6615 |     | <span class='neutral'>        bytes32 m0;</span>
  6616 |     | <span class='neutral'>        bytes32 m1;</span>
  6617 |     | <span class='neutral'>        bytes32 m2;</span>
  6618 |     | <span class='neutral'>        bytes32 m3;</span>
  6619 |     | <span class='neutral'>        bytes32 m4;</span>
  6620 |     | <span class='neutral'>        bytes32 m5;</span>
  6621 |     | <span class='neutral'>        bytes32 m6;</span>
  6622 |     | <span class='neutral'>        assembly {</span>
  6623 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6624 |     | <span class='neutral'>                let length := 0</span>
  6625 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6626 |     | <span class='neutral'>                mstore(pos, length)</span>
  6627 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6628 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6629 |     | <span class='neutral'>            }</span>
  6630 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6631 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6632 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6633 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6634 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6635 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6636 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6637 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,string)`.</span>
  6638 |     | <span class='neutral'>            mstore(0x00, 0x9143dbb1)</span>
  6639 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6640 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6641 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6642 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6643 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6644 |     | <span class='neutral'>        }</span>
  6645 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6646 |     | <span class='neutral'>        assembly {</span>
  6647 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6648 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6649 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6650 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6651 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6652 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6653 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6654 |     | <span class='neutral'>        }</span>
  6655 |     | <span class='neutral'>    }</span>
  6656 |     | <span class='neutral'></span>
  6657 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  6658 |     | <span class='neutral'>        bytes32 m0;</span>
  6659 |     | <span class='neutral'>        bytes32 m1;</span>
  6660 |     | <span class='neutral'>        bytes32 m2;</span>
  6661 |     | <span class='neutral'>        bytes32 m3;</span>
  6662 |     | <span class='neutral'>        bytes32 m4;</span>
  6663 |     | <span class='neutral'>        assembly {</span>
  6664 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6665 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6666 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6667 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6668 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6669 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,address)`.</span>
  6670 |     | <span class='neutral'>            mstore(0x00, 0x00dd87b9)</span>
  6671 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6672 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6673 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6674 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6675 |     | <span class='neutral'>        }</span>
  6676 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6677 |     | <span class='neutral'>        assembly {</span>
  6678 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6679 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6680 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6681 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6682 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6683 |     | <span class='neutral'>        }</span>
  6684 |     | <span class='neutral'>    }</span>
  6685 |     | <span class='neutral'></span>
  6686 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  6687 |     | <span class='neutral'>        bytes32 m0;</span>
  6688 |     | <span class='neutral'>        bytes32 m1;</span>
  6689 |     | <span class='neutral'>        bytes32 m2;</span>
  6690 |     | <span class='neutral'>        bytes32 m3;</span>
  6691 |     | <span class='neutral'>        bytes32 m4;</span>
  6692 |     | <span class='neutral'>        assembly {</span>
  6693 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6694 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6695 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6696 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6697 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6698 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,bool)`.</span>
  6699 |     | <span class='neutral'>            mstore(0x00, 0xbe984353)</span>
  6700 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6701 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6702 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6703 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6704 |     | <span class='neutral'>        }</span>
  6705 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6706 |     | <span class='neutral'>        assembly {</span>
  6707 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6708 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6709 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6710 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6711 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6712 |     | <span class='neutral'>        }</span>
  6713 |     | <span class='neutral'>    }</span>
  6714 |     | <span class='neutral'></span>
  6715 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  6716 |     | <span class='neutral'>        bytes32 m0;</span>
  6717 |     | <span class='neutral'>        bytes32 m1;</span>
  6718 |     | <span class='neutral'>        bytes32 m2;</span>
  6719 |     | <span class='neutral'>        bytes32 m3;</span>
  6720 |     | <span class='neutral'>        bytes32 m4;</span>
  6721 |     | <span class='neutral'>        assembly {</span>
  6722 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6723 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6724 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6725 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6726 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6727 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,uint256)`.</span>
  6728 |     | <span class='neutral'>            mstore(0x00, 0x374bb4b2)</span>
  6729 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6730 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6731 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6732 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6733 |     | <span class='neutral'>        }</span>
  6734 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6735 |     | <span class='neutral'>        assembly {</span>
  6736 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6737 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6738 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6739 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6740 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6741 |     | <span class='neutral'>        }</span>
  6742 |     | <span class='neutral'>    }</span>
  6743 |     | <span class='neutral'></span>
  6744 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  6745 |     | <span class='neutral'>        bytes32 m0;</span>
  6746 |     | <span class='neutral'>        bytes32 m1;</span>
  6747 |     | <span class='neutral'>        bytes32 m2;</span>
  6748 |     | <span class='neutral'>        bytes32 m3;</span>
  6749 |     | <span class='neutral'>        bytes32 m4;</span>
  6750 |     | <span class='neutral'>        bytes32 m5;</span>
  6751 |     | <span class='neutral'>        bytes32 m6;</span>
  6752 |     | <span class='neutral'>        assembly {</span>
  6753 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6754 |     | <span class='neutral'>                let length := 0</span>
  6755 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6756 |     | <span class='neutral'>                mstore(pos, length)</span>
  6757 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6758 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6759 |     | <span class='neutral'>            }</span>
  6760 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6761 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6762 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6763 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6764 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6765 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6766 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6767 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,string)`.</span>
  6768 |     | <span class='neutral'>            mstore(0x00, 0x8e69fb5d)</span>
  6769 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6770 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6771 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6772 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6773 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6774 |     | <span class='neutral'>        }</span>
  6775 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6776 |     | <span class='neutral'>        assembly {</span>
  6777 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6778 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6779 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6780 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6781 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6782 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6783 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6784 |     | <span class='neutral'>        }</span>
  6785 |     | <span class='neutral'>    }</span>
  6786 |     | <span class='neutral'></span>
  6787 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  6788 |     | <span class='neutral'>        bytes32 m0;</span>
  6789 |     | <span class='neutral'>        bytes32 m1;</span>
  6790 |     | <span class='neutral'>        bytes32 m2;</span>
  6791 |     | <span class='neutral'>        bytes32 m3;</span>
  6792 |     | <span class='neutral'>        bytes32 m4;</span>
  6793 |     | <span class='neutral'>        bytes32 m5;</span>
  6794 |     | <span class='neutral'>        bytes32 m6;</span>
  6795 |     | <span class='neutral'>        assembly {</span>
  6796 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6797 |     | <span class='neutral'>                let length := 0</span>
  6798 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6799 |     | <span class='neutral'>                mstore(pos, length)</span>
  6800 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6801 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6802 |     | <span class='neutral'>            }</span>
  6803 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6804 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6805 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6806 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6807 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6808 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6809 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6810 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,address)`.</span>
  6811 |     | <span class='neutral'>            mstore(0x00, 0xfedd1fff)</span>
  6812 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6813 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6814 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6815 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6816 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6817 |     | <span class='neutral'>        }</span>
  6818 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6819 |     | <span class='neutral'>        assembly {</span>
  6820 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6821 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6822 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6823 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6824 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6825 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6826 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6827 |     | <span class='neutral'>        }</span>
  6828 |     | <span class='neutral'>    }</span>
  6829 |     | <span class='neutral'></span>
  6830 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  6831 |     | <span class='neutral'>        bytes32 m0;</span>
  6832 |     | <span class='neutral'>        bytes32 m1;</span>
  6833 |     | <span class='neutral'>        bytes32 m2;</span>
  6834 |     | <span class='neutral'>        bytes32 m3;</span>
  6835 |     | <span class='neutral'>        bytes32 m4;</span>
  6836 |     | <span class='neutral'>        bytes32 m5;</span>
  6837 |     | <span class='neutral'>        bytes32 m6;</span>
  6838 |     | <span class='neutral'>        assembly {</span>
  6839 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6840 |     | <span class='neutral'>                let length := 0</span>
  6841 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6842 |     | <span class='neutral'>                mstore(pos, length)</span>
  6843 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6844 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6845 |     | <span class='neutral'>            }</span>
  6846 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6847 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6848 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6849 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6850 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6851 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6852 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6853 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,bool)`.</span>
  6854 |     | <span class='neutral'>            mstore(0x00, 0xe5e70b2b)</span>
  6855 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6856 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6857 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6858 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6859 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6860 |     | <span class='neutral'>        }</span>
  6861 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6862 |     | <span class='neutral'>        assembly {</span>
  6863 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6864 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6865 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6866 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6867 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6868 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6869 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6870 |     | <span class='neutral'>        }</span>
  6871 |     | <span class='neutral'>    }</span>
  6872 |     | <span class='neutral'></span>
  6873 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  6874 |     | <span class='neutral'>        bytes32 m0;</span>
  6875 |     | <span class='neutral'>        bytes32 m1;</span>
  6876 |     | <span class='neutral'>        bytes32 m2;</span>
  6877 |     | <span class='neutral'>        bytes32 m3;</span>
  6878 |     | <span class='neutral'>        bytes32 m4;</span>
  6879 |     | <span class='neutral'>        bytes32 m5;</span>
  6880 |     | <span class='neutral'>        bytes32 m6;</span>
  6881 |     | <span class='neutral'>        assembly {</span>
  6882 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6883 |     | <span class='neutral'>                let length := 0</span>
  6884 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6885 |     | <span class='neutral'>                mstore(pos, length)</span>
  6886 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6887 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6888 |     | <span class='neutral'>            }</span>
  6889 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6890 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6891 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6892 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6893 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6894 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6895 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6896 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,uint256)`.</span>
  6897 |     | <span class='neutral'>            mstore(0x00, 0x6a1199e2)</span>
  6898 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6899 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6900 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6901 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6902 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6903 |     | <span class='neutral'>        }</span>
  6904 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6905 |     | <span class='neutral'>        assembly {</span>
  6906 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6907 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6908 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6909 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6910 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6911 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6912 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6913 |     | <span class='neutral'>        }</span>
  6914 |     | <span class='neutral'>    }</span>
  6915 |     | <span class='neutral'></span>
  6916 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6917 |     | <span class='neutral'>        bytes32 m0;</span>
  6918 |     | <span class='neutral'>        bytes32 m1;</span>
  6919 |     | <span class='neutral'>        bytes32 m2;</span>
  6920 |     | <span class='neutral'>        bytes32 m3;</span>
  6921 |     | <span class='neutral'>        bytes32 m4;</span>
  6922 |     | <span class='neutral'>        bytes32 m5;</span>
  6923 |     | <span class='neutral'>        bytes32 m6;</span>
  6924 |     | <span class='neutral'>        bytes32 m7;</span>
  6925 |     | <span class='neutral'>        bytes32 m8;</span>
  6926 |     | <span class='neutral'>        assembly {</span>
  6927 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6928 |     | <span class='neutral'>                let length := 0</span>
  6929 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6930 |     | <span class='neutral'>                mstore(pos, length)</span>
  6931 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6932 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6933 |     | <span class='neutral'>            }</span>
  6934 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6935 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6936 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6937 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6938 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6939 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6940 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6941 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6942 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6943 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,string)`.</span>
  6944 |     | <span class='neutral'>            mstore(0x00, 0xf5bc2249)</span>
  6945 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6946 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6947 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6948 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6949 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6950 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6951 |     | <span class='neutral'>        }</span>
  6952 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6953 |     | <span class='neutral'>        assembly {</span>
  6954 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6955 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6956 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6957 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6958 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6959 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6960 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6961 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6962 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6963 |     | <span class='neutral'>        }</span>
  6964 |     | <span class='neutral'>    }</span>
  6965 |     | <span class='neutral'></span>
  6966 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {</span>
  6967 |     | <span class='neutral'>        bytes32 m0;</span>
  6968 |     | <span class='neutral'>        bytes32 m1;</span>
  6969 |     | <span class='neutral'>        bytes32 m2;</span>
  6970 |     | <span class='neutral'>        bytes32 m3;</span>
  6971 |     | <span class='neutral'>        bytes32 m4;</span>
  6972 |     | <span class='neutral'>        bytes32 m5;</span>
  6973 |     | <span class='neutral'>        bytes32 m6;</span>
  6974 |     | <span class='neutral'>        assembly {</span>
  6975 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6976 |     | <span class='neutral'>                let length := 0</span>
  6977 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6978 |     | <span class='neutral'>                mstore(pos, length)</span>
  6979 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6980 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6981 |     | <span class='neutral'>            }</span>
  6982 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6983 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6984 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6985 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6986 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6987 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6988 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6989 |     | <span class='neutral'>            // Selector of `log(bool,string,address,address)`.</span>
  6990 |     | <span class='neutral'>            mstore(0x00, 0x2b2b18dc)</span>
  6991 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6992 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  6993 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6994 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6995 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  6996 |     | <span class='neutral'>        }</span>
  6997 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6998 |     | <span class='neutral'>        assembly {</span>
  6999 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7000 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7001 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7002 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7003 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7004 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7005 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7006 |     | <span class='neutral'>        }</span>
  7007 |     | <span class='neutral'>    }</span>
  7008 |     | <span class='neutral'></span>
  7009 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  7010 |     | <span class='neutral'>        bytes32 m0;</span>
  7011 |     | <span class='neutral'>        bytes32 m1;</span>
  7012 |     | <span class='neutral'>        bytes32 m2;</span>
  7013 |     | <span class='neutral'>        bytes32 m3;</span>
  7014 |     | <span class='neutral'>        bytes32 m4;</span>
  7015 |     | <span class='neutral'>        bytes32 m5;</span>
  7016 |     | <span class='neutral'>        bytes32 m6;</span>
  7017 |     | <span class='neutral'>        assembly {</span>
  7018 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7019 |     | <span class='neutral'>                let length := 0</span>
  7020 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7021 |     | <span class='neutral'>                mstore(pos, length)</span>
  7022 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7023 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7024 |     | <span class='neutral'>            }</span>
  7025 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7026 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7027 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7028 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7029 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7030 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7031 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7032 |     | <span class='neutral'>            // Selector of `log(bool,string,address,bool)`.</span>
  7033 |     | <span class='neutral'>            mstore(0x00, 0x6dd434ca)</span>
  7034 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7035 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7036 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7037 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7038 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7039 |     | <span class='neutral'>        }</span>
  7040 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7041 |     | <span class='neutral'>        assembly {</span>
  7042 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7043 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7044 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7045 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7046 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7047 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7048 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7049 |     | <span class='neutral'>        }</span>
  7050 |     | <span class='neutral'>    }</span>
  7051 |     | <span class='neutral'></span>
  7052 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  7053 |     | <span class='neutral'>        bytes32 m0;</span>
  7054 |     | <span class='neutral'>        bytes32 m1;</span>
  7055 |     | <span class='neutral'>        bytes32 m2;</span>
  7056 |     | <span class='neutral'>        bytes32 m3;</span>
  7057 |     | <span class='neutral'>        bytes32 m4;</span>
  7058 |     | <span class='neutral'>        bytes32 m5;</span>
  7059 |     | <span class='neutral'>        bytes32 m6;</span>
  7060 |     | <span class='neutral'>        assembly {</span>
  7061 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7062 |     | <span class='neutral'>                let length := 0</span>
  7063 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7064 |     | <span class='neutral'>                mstore(pos, length)</span>
  7065 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7066 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7067 |     | <span class='neutral'>            }</span>
  7068 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7069 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7070 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7071 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7072 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7073 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7074 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7075 |     | <span class='neutral'>            // Selector of `log(bool,string,address,uint256)`.</span>
  7076 |     | <span class='neutral'>            mstore(0x00, 0xa5cada94)</span>
  7077 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7078 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7079 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7080 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7081 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7082 |     | <span class='neutral'>        }</span>
  7083 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7084 |     | <span class='neutral'>        assembly {</span>
  7085 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7086 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7087 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7088 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7089 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7090 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7091 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7092 |     | <span class='neutral'>        }</span>
  7093 |     | <span class='neutral'>    }</span>
  7094 |     | <span class='neutral'></span>
  7095 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  7096 |     | <span class='neutral'>        bytes32 m0;</span>
  7097 |     | <span class='neutral'>        bytes32 m1;</span>
  7098 |     | <span class='neutral'>        bytes32 m2;</span>
  7099 |     | <span class='neutral'>        bytes32 m3;</span>
  7100 |     | <span class='neutral'>        bytes32 m4;</span>
  7101 |     | <span class='neutral'>        bytes32 m5;</span>
  7102 |     | <span class='neutral'>        bytes32 m6;</span>
  7103 |     | <span class='neutral'>        bytes32 m7;</span>
  7104 |     | <span class='neutral'>        bytes32 m8;</span>
  7105 |     | <span class='neutral'>        assembly {</span>
  7106 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7107 |     | <span class='neutral'>                let length := 0</span>
  7108 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7109 |     | <span class='neutral'>                mstore(pos, length)</span>
  7110 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7111 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7112 |     | <span class='neutral'>            }</span>
  7113 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7114 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7115 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7116 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7117 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7118 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7119 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7120 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7121 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7122 |     | <span class='neutral'>            // Selector of `log(bool,string,address,string)`.</span>
  7123 |     | <span class='neutral'>            mstore(0x00, 0x12d6c788)</span>
  7124 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7125 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7126 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7127 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7128 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7129 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7130 |     | <span class='neutral'>        }</span>
  7131 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7132 |     | <span class='neutral'>        assembly {</span>
  7133 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7134 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7135 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7136 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7137 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7138 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7139 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7140 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7141 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7142 |     | <span class='neutral'>        }</span>
  7143 |     | <span class='neutral'>    }</span>
  7144 |     | <span class='neutral'></span>
  7145 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  7146 |     | <span class='neutral'>        bytes32 m0;</span>
  7147 |     | <span class='neutral'>        bytes32 m1;</span>
  7148 |     | <span class='neutral'>        bytes32 m2;</span>
  7149 |     | <span class='neutral'>        bytes32 m3;</span>
  7150 |     | <span class='neutral'>        bytes32 m4;</span>
  7151 |     | <span class='neutral'>        bytes32 m5;</span>
  7152 |     | <span class='neutral'>        bytes32 m6;</span>
  7153 |     | <span class='neutral'>        assembly {</span>
  7154 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7155 |     | <span class='neutral'>                let length := 0</span>
  7156 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7157 |     | <span class='neutral'>                mstore(pos, length)</span>
  7158 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7159 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7160 |     | <span class='neutral'>            }</span>
  7161 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7162 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7163 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7164 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7165 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7166 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7167 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7168 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,address)`.</span>
  7169 |     | <span class='neutral'>            mstore(0x00, 0x538e06ab)</span>
  7170 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7171 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7172 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7173 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7174 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7175 |     | <span class='neutral'>        }</span>
  7176 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7177 |     | <span class='neutral'>        assembly {</span>
  7178 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7179 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7180 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7181 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7182 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7183 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7184 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7185 |     | <span class='neutral'>        }</span>
  7186 |     | <span class='neutral'>    }</span>
  7187 |     | <span class='neutral'></span>
  7188 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  7189 |     | <span class='neutral'>        bytes32 m0;</span>
  7190 |     | <span class='neutral'>        bytes32 m1;</span>
  7191 |     | <span class='neutral'>        bytes32 m2;</span>
  7192 |     | <span class='neutral'>        bytes32 m3;</span>
  7193 |     | <span class='neutral'>        bytes32 m4;</span>
  7194 |     | <span class='neutral'>        bytes32 m5;</span>
  7195 |     | <span class='neutral'>        bytes32 m6;</span>
  7196 |     | <span class='neutral'>        assembly {</span>
  7197 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7198 |     | <span class='neutral'>                let length := 0</span>
  7199 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7200 |     | <span class='neutral'>                mstore(pos, length)</span>
  7201 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7202 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7203 |     | <span class='neutral'>            }</span>
  7204 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7205 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7206 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7207 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7208 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7209 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7210 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7211 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,bool)`.</span>
  7212 |     | <span class='neutral'>            mstore(0x00, 0xdc5e935b)</span>
  7213 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7214 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7215 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7216 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7217 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7218 |     | <span class='neutral'>        }</span>
  7219 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7220 |     | <span class='neutral'>        assembly {</span>
  7221 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7222 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7223 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7224 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7225 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7226 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7227 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7228 |     | <span class='neutral'>        }</span>
  7229 |     | <span class='neutral'>    }</span>
  7230 |     | <span class='neutral'></span>
  7231 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  7232 |     | <span class='neutral'>        bytes32 m0;</span>
  7233 |     | <span class='neutral'>        bytes32 m1;</span>
  7234 |     | <span class='neutral'>        bytes32 m2;</span>
  7235 |     | <span class='neutral'>        bytes32 m3;</span>
  7236 |     | <span class='neutral'>        bytes32 m4;</span>
  7237 |     | <span class='neutral'>        bytes32 m5;</span>
  7238 |     | <span class='neutral'>        bytes32 m6;</span>
  7239 |     | <span class='neutral'>        assembly {</span>
  7240 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7241 |     | <span class='neutral'>                let length := 0</span>
  7242 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7243 |     | <span class='neutral'>                mstore(pos, length)</span>
  7244 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7245 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7246 |     | <span class='neutral'>            }</span>
  7247 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7248 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7249 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7250 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7251 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7252 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7253 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7254 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,uint256)`.</span>
  7255 |     | <span class='neutral'>            mstore(0x00, 0x1606a393)</span>
  7256 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7257 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7258 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7259 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7260 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7261 |     | <span class='neutral'>        }</span>
  7262 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7263 |     | <span class='neutral'>        assembly {</span>
  7264 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7265 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7266 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7267 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7268 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7269 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7270 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7271 |     | <span class='neutral'>        }</span>
  7272 |     | <span class='neutral'>    }</span>
  7273 |     | <span class='neutral'></span>
  7274 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  7275 |     | <span class='neutral'>        bytes32 m0;</span>
  7276 |     | <span class='neutral'>        bytes32 m1;</span>
  7277 |     | <span class='neutral'>        bytes32 m2;</span>
  7278 |     | <span class='neutral'>        bytes32 m3;</span>
  7279 |     | <span class='neutral'>        bytes32 m4;</span>
  7280 |     | <span class='neutral'>        bytes32 m5;</span>
  7281 |     | <span class='neutral'>        bytes32 m6;</span>
  7282 |     | <span class='neutral'>        bytes32 m7;</span>
  7283 |     | <span class='neutral'>        bytes32 m8;</span>
  7284 |     | <span class='neutral'>        assembly {</span>
  7285 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7286 |     | <span class='neutral'>                let length := 0</span>
  7287 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7288 |     | <span class='neutral'>                mstore(pos, length)</span>
  7289 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7290 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7291 |     | <span class='neutral'>            }</span>
  7292 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7293 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7294 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7295 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7296 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7297 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7298 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7299 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7300 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7301 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,string)`.</span>
  7302 |     | <span class='neutral'>            mstore(0x00, 0x483d0416)</span>
  7303 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7304 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7305 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7306 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7307 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7308 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7309 |     | <span class='neutral'>        }</span>
  7310 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7311 |     | <span class='neutral'>        assembly {</span>
  7312 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7313 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7314 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7315 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7316 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7317 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7318 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7319 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7320 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7321 |     | <span class='neutral'>        }</span>
  7322 |     | <span class='neutral'>    }</span>
  7323 |     | <span class='neutral'></span>
  7324 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  7325 |     | <span class='neutral'>        bytes32 m0;</span>
  7326 |     | <span class='neutral'>        bytes32 m1;</span>
  7327 |     | <span class='neutral'>        bytes32 m2;</span>
  7328 |     | <span class='neutral'>        bytes32 m3;</span>
  7329 |     | <span class='neutral'>        bytes32 m4;</span>
  7330 |     | <span class='neutral'>        bytes32 m5;</span>
  7331 |     | <span class='neutral'>        bytes32 m6;</span>
  7332 |     | <span class='neutral'>        assembly {</span>
  7333 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7334 |     | <span class='neutral'>                let length := 0</span>
  7335 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7336 |     | <span class='neutral'>                mstore(pos, length)</span>
  7337 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7338 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7339 |     | <span class='neutral'>            }</span>
  7340 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7341 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7342 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7343 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7344 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7345 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7346 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7347 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,address)`.</span>
  7348 |     | <span class='neutral'>            mstore(0x00, 0x1596a1ce)</span>
  7349 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7350 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7351 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7352 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7353 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7354 |     | <span class='neutral'>        }</span>
  7355 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7356 |     | <span class='neutral'>        assembly {</span>
  7357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7362 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7363 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7364 |     | <span class='neutral'>        }</span>
  7365 |     | <span class='neutral'>    }</span>
  7366 |     | <span class='neutral'></span>
  7367 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  7368 |     | <span class='neutral'>        bytes32 m0;</span>
  7369 |     | <span class='neutral'>        bytes32 m1;</span>
  7370 |     | <span class='neutral'>        bytes32 m2;</span>
  7371 |     | <span class='neutral'>        bytes32 m3;</span>
  7372 |     | <span class='neutral'>        bytes32 m4;</span>
  7373 |     | <span class='neutral'>        bytes32 m5;</span>
  7374 |     | <span class='neutral'>        bytes32 m6;</span>
  7375 |     | <span class='neutral'>        assembly {</span>
  7376 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7377 |     | <span class='neutral'>                let length := 0</span>
  7378 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7379 |     | <span class='neutral'>                mstore(pos, length)</span>
  7380 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7381 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7382 |     | <span class='neutral'>            }</span>
  7383 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7384 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7385 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7386 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7387 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7388 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7389 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7390 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,bool)`.</span>
  7391 |     | <span class='neutral'>            mstore(0x00, 0x6b0e5d53)</span>
  7392 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7393 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7394 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7395 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7396 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7397 |     | <span class='neutral'>        }</span>
  7398 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7399 |     | <span class='neutral'>        assembly {</span>
  7400 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7401 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7402 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7403 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7404 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7405 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7406 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7407 |     | <span class='neutral'>        }</span>
  7408 |     | <span class='neutral'>    }</span>
  7409 |     | <span class='neutral'></span>
  7410 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  7411 |     | <span class='neutral'>        bytes32 m0;</span>
  7412 |     | <span class='neutral'>        bytes32 m1;</span>
  7413 |     | <span class='neutral'>        bytes32 m2;</span>
  7414 |     | <span class='neutral'>        bytes32 m3;</span>
  7415 |     | <span class='neutral'>        bytes32 m4;</span>
  7416 |     | <span class='neutral'>        bytes32 m5;</span>
  7417 |     | <span class='neutral'>        bytes32 m6;</span>
  7418 |     | <span class='neutral'>        assembly {</span>
  7419 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7420 |     | <span class='neutral'>                let length := 0</span>
  7421 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7422 |     | <span class='neutral'>                mstore(pos, length)</span>
  7423 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7424 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7425 |     | <span class='neutral'>            }</span>
  7426 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7427 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7428 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7429 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7430 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7431 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7432 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7433 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,uint256)`.</span>
  7434 |     | <span class='neutral'>            mstore(0x00, 0x28863fcb)</span>
  7435 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7436 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7437 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7438 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7439 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7440 |     | <span class='neutral'>        }</span>
  7441 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7442 |     | <span class='neutral'>        assembly {</span>
  7443 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7444 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7445 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7446 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7447 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7448 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7449 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7450 |     | <span class='neutral'>        }</span>
  7451 |     | <span class='neutral'>    }</span>
  7452 |     | <span class='neutral'></span>
  7453 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  7454 |     | <span class='neutral'>        bytes32 m0;</span>
  7455 |     | <span class='neutral'>        bytes32 m1;</span>
  7456 |     | <span class='neutral'>        bytes32 m2;</span>
  7457 |     | <span class='neutral'>        bytes32 m3;</span>
  7458 |     | <span class='neutral'>        bytes32 m4;</span>
  7459 |     | <span class='neutral'>        bytes32 m5;</span>
  7460 |     | <span class='neutral'>        bytes32 m6;</span>
  7461 |     | <span class='neutral'>        bytes32 m7;</span>
  7462 |     | <span class='neutral'>        bytes32 m8;</span>
  7463 |     | <span class='neutral'>        assembly {</span>
  7464 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7465 |     | <span class='neutral'>                let length := 0</span>
  7466 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7467 |     | <span class='neutral'>                mstore(pos, length)</span>
  7468 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7469 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7470 |     | <span class='neutral'>            }</span>
  7471 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7472 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7473 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7474 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7475 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7476 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7477 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7478 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7479 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7480 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,string)`.</span>
  7481 |     | <span class='neutral'>            mstore(0x00, 0x1ad96de6)</span>
  7482 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7483 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7484 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7485 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7486 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7487 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7488 |     | <span class='neutral'>        }</span>
  7489 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7490 |     | <span class='neutral'>        assembly {</span>
  7491 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7492 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7493 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7494 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7495 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7496 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7497 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7498 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7499 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7500 |     | <span class='neutral'>        }</span>
  7501 |     | <span class='neutral'>    }</span>
  7502 |     | <span class='neutral'></span>
  7503 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  7504 |     | <span class='neutral'>        bytes32 m0;</span>
  7505 |     | <span class='neutral'>        bytes32 m1;</span>
  7506 |     | <span class='neutral'>        bytes32 m2;</span>
  7507 |     | <span class='neutral'>        bytes32 m3;</span>
  7508 |     | <span class='neutral'>        bytes32 m4;</span>
  7509 |     | <span class='neutral'>        bytes32 m5;</span>
  7510 |     | <span class='neutral'>        bytes32 m6;</span>
  7511 |     | <span class='neutral'>        bytes32 m7;</span>
  7512 |     | <span class='neutral'>        bytes32 m8;</span>
  7513 |     | <span class='neutral'>        assembly {</span>
  7514 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7515 |     | <span class='neutral'>                let length := 0</span>
  7516 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7517 |     | <span class='neutral'>                mstore(pos, length)</span>
  7518 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7519 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7520 |     | <span class='neutral'>            }</span>
  7521 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7522 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7523 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7524 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7525 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7526 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7527 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7528 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7529 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7530 |     | <span class='neutral'>            // Selector of `log(bool,string,string,address)`.</span>
  7531 |     | <span class='neutral'>            mstore(0x00, 0x97d394d8)</span>
  7532 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7533 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7534 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7535 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7536 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7537 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7538 |     | <span class='neutral'>        }</span>
  7539 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7540 |     | <span class='neutral'>        assembly {</span>
  7541 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7542 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7543 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7544 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7545 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7546 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7547 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7548 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7549 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7550 |     | <span class='neutral'>        }</span>
  7551 |     | <span class='neutral'>    }</span>
  7552 |     | <span class='neutral'></span>
  7553 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  7554 |     | <span class='neutral'>        bytes32 m0;</span>
  7555 |     | <span class='neutral'>        bytes32 m1;</span>
  7556 |     | <span class='neutral'>        bytes32 m2;</span>
  7557 |     | <span class='neutral'>        bytes32 m3;</span>
  7558 |     | <span class='neutral'>        bytes32 m4;</span>
  7559 |     | <span class='neutral'>        bytes32 m5;</span>
  7560 |     | <span class='neutral'>        bytes32 m6;</span>
  7561 |     | <span class='neutral'>        bytes32 m7;</span>
  7562 |     | <span class='neutral'>        bytes32 m8;</span>
  7563 |     | <span class='neutral'>        assembly {</span>
  7564 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7565 |     | <span class='neutral'>                let length := 0</span>
  7566 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7567 |     | <span class='neutral'>                mstore(pos, length)</span>
  7568 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7569 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7570 |     | <span class='neutral'>            }</span>
  7571 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7572 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7573 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7574 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7575 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7576 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7577 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7578 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7579 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7580 |     | <span class='neutral'>            // Selector of `log(bool,string,string,bool)`.</span>
  7581 |     | <span class='neutral'>            mstore(0x00, 0x1e4b87e5)</span>
  7582 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7583 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7584 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7585 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7586 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7587 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7588 |     | <span class='neutral'>        }</span>
  7589 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7590 |     | <span class='neutral'>        assembly {</span>
  7591 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7592 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7593 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7594 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7595 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7596 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7597 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7598 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7599 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7600 |     | <span class='neutral'>        }</span>
  7601 |     | <span class='neutral'>    }</span>
  7602 |     | <span class='neutral'></span>
  7603 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  7604 |     | <span class='neutral'>        bytes32 m0;</span>
  7605 |     | <span class='neutral'>        bytes32 m1;</span>
  7606 |     | <span class='neutral'>        bytes32 m2;</span>
  7607 |     | <span class='neutral'>        bytes32 m3;</span>
  7608 |     | <span class='neutral'>        bytes32 m4;</span>
  7609 |     | <span class='neutral'>        bytes32 m5;</span>
  7610 |     | <span class='neutral'>        bytes32 m6;</span>
  7611 |     | <span class='neutral'>        bytes32 m7;</span>
  7612 |     | <span class='neutral'>        bytes32 m8;</span>
  7613 |     | <span class='neutral'>        assembly {</span>
  7614 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7615 |     | <span class='neutral'>                let length := 0</span>
  7616 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7617 |     | <span class='neutral'>                mstore(pos, length)</span>
  7618 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7619 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7620 |     | <span class='neutral'>            }</span>
  7621 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7622 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7623 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7624 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7625 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7626 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7627 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7628 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7629 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7630 |     | <span class='neutral'>            // Selector of `log(bool,string,string,uint256)`.</span>
  7631 |     | <span class='neutral'>            mstore(0x00, 0x7be0c3eb)</span>
  7632 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7633 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7634 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7635 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7636 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7637 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7638 |     | <span class='neutral'>        }</span>
  7639 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7640 |     | <span class='neutral'>        assembly {</span>
  7641 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7642 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7643 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7644 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7645 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7646 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7647 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7648 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7649 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7650 |     | <span class='neutral'>        }</span>
  7651 |     | <span class='neutral'>    }</span>
  7652 |     | <span class='neutral'></span>
  7653 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  7654 |     | <span class='neutral'>        bytes32 m0;</span>
  7655 |     | <span class='neutral'>        bytes32 m1;</span>
  7656 |     | <span class='neutral'>        bytes32 m2;</span>
  7657 |     | <span class='neutral'>        bytes32 m3;</span>
  7658 |     | <span class='neutral'>        bytes32 m4;</span>
  7659 |     | <span class='neutral'>        bytes32 m5;</span>
  7660 |     | <span class='neutral'>        bytes32 m6;</span>
  7661 |     | <span class='neutral'>        bytes32 m7;</span>
  7662 |     | <span class='neutral'>        bytes32 m8;</span>
  7663 |     | <span class='neutral'>        bytes32 m9;</span>
  7664 |     | <span class='neutral'>        bytes32 m10;</span>
  7665 |     | <span class='neutral'>        assembly {</span>
  7666 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7667 |     | <span class='neutral'>                let length := 0</span>
  7668 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7669 |     | <span class='neutral'>                mstore(pos, length)</span>
  7670 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7671 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7672 |     | <span class='neutral'>            }</span>
  7673 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7674 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7675 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7676 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7677 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7678 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7679 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7680 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7681 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7682 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  7683 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  7684 |     | <span class='neutral'>            // Selector of `log(bool,string,string,string)`.</span>
  7685 |     | <span class='neutral'>            mstore(0x00, 0x1762e32a)</span>
  7686 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7687 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7688 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7689 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  7690 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7691 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7692 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  7693 |     | <span class='neutral'>        }</span>
  7694 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  7695 |     | <span class='neutral'>        assembly {</span>
  7696 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7697 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7698 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7699 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7700 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7701 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7702 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7703 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7704 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7705 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  7706 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  7707 |     | <span class='neutral'>        }</span>
  7708 |     | <span class='neutral'>    }</span>
  7709 |     | <span class='neutral'></span>
  7710 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal pure {</span>
  7711 |     | <span class='neutral'>        bytes32 m0;</span>
  7712 |     | <span class='neutral'>        bytes32 m1;</span>
  7713 |     | <span class='neutral'>        bytes32 m2;</span>
  7714 |     | <span class='neutral'>        bytes32 m3;</span>
  7715 |     | <span class='neutral'>        bytes32 m4;</span>
  7716 |     | <span class='neutral'>        assembly {</span>
  7717 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7718 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7719 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7720 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7721 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7722 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,address)`.</span>
  7723 |     | <span class='neutral'>            mstore(0x00, 0x2488b414)</span>
  7724 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7725 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7726 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7727 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7728 |     | <span class='neutral'>        }</span>
  7729 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7730 |     | <span class='neutral'>        assembly {</span>
  7731 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7732 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7733 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7734 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7735 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7736 |     | <span class='neutral'>        }</span>
  7737 |     | <span class='neutral'>    }</span>
  7738 |     | <span class='neutral'></span>
  7739 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal pure {</span>
  7740 |     | <span class='neutral'>        bytes32 m0;</span>
  7741 |     | <span class='neutral'>        bytes32 m1;</span>
  7742 |     | <span class='neutral'>        bytes32 m2;</span>
  7743 |     | <span class='neutral'>        bytes32 m3;</span>
  7744 |     | <span class='neutral'>        bytes32 m4;</span>
  7745 |     | <span class='neutral'>        assembly {</span>
  7746 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7747 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7748 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7749 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7750 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7751 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,bool)`.</span>
  7752 |     | <span class='neutral'>            mstore(0x00, 0x091ffaf5)</span>
  7753 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7754 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7755 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7756 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7757 |     | <span class='neutral'>        }</span>
  7758 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7759 |     | <span class='neutral'>        assembly {</span>
  7760 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7761 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7762 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7763 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7764 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7765 |     | <span class='neutral'>        }</span>
  7766 |     | <span class='neutral'>    }</span>
  7767 |     | <span class='neutral'></span>
  7768 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {</span>
  7769 |     | <span class='neutral'>        bytes32 m0;</span>
  7770 |     | <span class='neutral'>        bytes32 m1;</span>
  7771 |     | <span class='neutral'>        bytes32 m2;</span>
  7772 |     | <span class='neutral'>        bytes32 m3;</span>
  7773 |     | <span class='neutral'>        bytes32 m4;</span>
  7774 |     | <span class='neutral'>        assembly {</span>
  7775 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7776 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7777 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7778 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7779 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7780 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,uint256)`.</span>
  7781 |     | <span class='neutral'>            mstore(0x00, 0x736efbb6)</span>
  7782 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7783 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7784 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7785 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7786 |     | <span class='neutral'>        }</span>
  7787 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7788 |     | <span class='neutral'>        assembly {</span>
  7789 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7790 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7791 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7792 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7793 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7794 |     | <span class='neutral'>        }</span>
  7795 |     | <span class='neutral'>    }</span>
  7796 |     | <span class='neutral'></span>
  7797 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {</span>
  7798 |     | <span class='neutral'>        bytes32 m0;</span>
  7799 |     | <span class='neutral'>        bytes32 m1;</span>
  7800 |     | <span class='neutral'>        bytes32 m2;</span>
  7801 |     | <span class='neutral'>        bytes32 m3;</span>
  7802 |     | <span class='neutral'>        bytes32 m4;</span>
  7803 |     | <span class='neutral'>        bytes32 m5;</span>
  7804 |     | <span class='neutral'>        bytes32 m6;</span>
  7805 |     | <span class='neutral'>        assembly {</span>
  7806 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7807 |     | <span class='neutral'>                let length := 0</span>
  7808 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7809 |     | <span class='neutral'>                mstore(pos, length)</span>
  7810 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7811 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7812 |     | <span class='neutral'>            }</span>
  7813 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7814 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7815 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7816 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7817 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7818 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7819 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7820 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,string)`.</span>
  7821 |     | <span class='neutral'>            mstore(0x00, 0x031c6f73)</span>
  7822 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7823 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7824 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7825 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7826 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7827 |     | <span class='neutral'>        }</span>
  7828 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7829 |     | <span class='neutral'>        assembly {</span>
  7830 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7831 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7832 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7833 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7834 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7835 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7836 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7837 |     | <span class='neutral'>        }</span>
  7838 |     | <span class='neutral'>    }</span>
  7839 |     | <span class='neutral'></span>
  7840 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal pure {</span>
  7841 |     | <span class='neutral'>        bytes32 m0;</span>
  7842 |     | <span class='neutral'>        bytes32 m1;</span>
  7843 |     | <span class='neutral'>        bytes32 m2;</span>
  7844 |     | <span class='neutral'>        bytes32 m3;</span>
  7845 |     | <span class='neutral'>        bytes32 m4;</span>
  7846 |     | <span class='neutral'>        assembly {</span>
  7847 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7848 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7849 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7850 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7851 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7852 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,address)`.</span>
  7853 |     | <span class='neutral'>            mstore(0x00, 0xef72c513)</span>
  7854 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7855 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7856 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7857 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7858 |     | <span class='neutral'>        }</span>
  7859 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7860 |     | <span class='neutral'>        assembly {</span>
  7861 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7862 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7863 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7864 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7865 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7866 |     | <span class='neutral'>        }</span>
  7867 |     | <span class='neutral'>    }</span>
  7868 |     | <span class='neutral'></span>
  7869 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {</span>
  7870 |     | <span class='neutral'>        bytes32 m0;</span>
  7871 |     | <span class='neutral'>        bytes32 m1;</span>
  7872 |     | <span class='neutral'>        bytes32 m2;</span>
  7873 |     | <span class='neutral'>        bytes32 m3;</span>
  7874 |     | <span class='neutral'>        bytes32 m4;</span>
  7875 |     | <span class='neutral'>        assembly {</span>
  7876 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7877 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7878 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7879 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7880 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7881 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,bool)`.</span>
  7882 |     | <span class='neutral'>            mstore(0x00, 0xe351140f)</span>
  7883 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7884 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7885 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7886 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7887 |     | <span class='neutral'>        }</span>
  7888 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7889 |     | <span class='neutral'>        assembly {</span>
  7890 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7891 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7892 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7893 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7894 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7895 |     | <span class='neutral'>        }</span>
  7896 |     | <span class='neutral'>    }</span>
  7897 |     | <span class='neutral'></span>
  7898 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {</span>
  7899 |     | <span class='neutral'>        bytes32 m0;</span>
  7900 |     | <span class='neutral'>        bytes32 m1;</span>
  7901 |     | <span class='neutral'>        bytes32 m2;</span>
  7902 |     | <span class='neutral'>        bytes32 m3;</span>
  7903 |     | <span class='neutral'>        bytes32 m4;</span>
  7904 |     | <span class='neutral'>        assembly {</span>
  7905 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7906 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7907 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7908 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7909 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7910 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,uint256)`.</span>
  7911 |     | <span class='neutral'>            mstore(0x00, 0x5abd992a)</span>
  7912 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7913 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7914 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7915 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7916 |     | <span class='neutral'>        }</span>
  7917 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7918 |     | <span class='neutral'>        assembly {</span>
  7919 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7920 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7921 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7922 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7923 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7924 |     | <span class='neutral'>        }</span>
  7925 |     | <span class='neutral'>    }</span>
  7926 |     | <span class='neutral'></span>
  7927 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  7928 |     | <span class='neutral'>        bytes32 m0;</span>
  7929 |     | <span class='neutral'>        bytes32 m1;</span>
  7930 |     | <span class='neutral'>        bytes32 m2;</span>
  7931 |     | <span class='neutral'>        bytes32 m3;</span>
  7932 |     | <span class='neutral'>        bytes32 m4;</span>
  7933 |     | <span class='neutral'>        bytes32 m5;</span>
  7934 |     | <span class='neutral'>        bytes32 m6;</span>
  7935 |     | <span class='neutral'>        assembly {</span>
  7936 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7937 |     | <span class='neutral'>                let length := 0</span>
  7938 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7939 |     | <span class='neutral'>                mstore(pos, length)</span>
  7940 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7941 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7942 |     | <span class='neutral'>            }</span>
  7943 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7944 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7945 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7946 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7947 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7948 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7949 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7950 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,string)`.</span>
  7951 |     | <span class='neutral'>            mstore(0x00, 0x90fb06aa)</span>
  7952 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7953 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7954 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7955 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7956 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7957 |     | <span class='neutral'>        }</span>
  7958 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7959 |     | <span class='neutral'>        assembly {</span>
  7960 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7961 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7962 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7963 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7964 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7965 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7966 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7967 |     | <span class='neutral'>        }</span>
  7968 |     | <span class='neutral'>    }</span>
  7969 |     | <span class='neutral'></span>
  7970 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {</span>
  7971 |     | <span class='neutral'>        bytes32 m0;</span>
  7972 |     | <span class='neutral'>        bytes32 m1;</span>
  7973 |     | <span class='neutral'>        bytes32 m2;</span>
  7974 |     | <span class='neutral'>        bytes32 m3;</span>
  7975 |     | <span class='neutral'>        bytes32 m4;</span>
  7976 |     | <span class='neutral'>        assembly {</span>
  7977 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7978 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7979 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7980 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7981 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7982 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,address)`.</span>
  7983 |     | <span class='neutral'>            mstore(0x00, 0x15c127b5)</span>
  7984 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7985 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7986 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7987 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7988 |     | <span class='neutral'>        }</span>
  7989 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7990 |     | <span class='neutral'>        assembly {</span>
  7991 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7992 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7993 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7994 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7995 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7996 |     | <span class='neutral'>        }</span>
  7997 |     | <span class='neutral'>    }</span>
  7998 |     | <span class='neutral'></span>
  7999 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {</span>
  8000 |     | <span class='neutral'>        bytes32 m0;</span>
  8001 |     | <span class='neutral'>        bytes32 m1;</span>
  8002 |     | <span class='neutral'>        bytes32 m2;</span>
  8003 |     | <span class='neutral'>        bytes32 m3;</span>
  8004 |     | <span class='neutral'>        bytes32 m4;</span>
  8005 |     | <span class='neutral'>        assembly {</span>
  8006 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8007 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8008 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8009 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8010 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8011 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,bool)`.</span>
  8012 |     | <span class='neutral'>            mstore(0x00, 0x5f743a7c)</span>
  8013 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8014 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8015 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8016 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8017 |     | <span class='neutral'>        }</span>
  8018 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8019 |     | <span class='neutral'>        assembly {</span>
  8020 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8021 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8022 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8023 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8024 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8025 |     | <span class='neutral'>        }</span>
  8026 |     | <span class='neutral'>    }</span>
  8027 |     | <span class='neutral'></span>
  8028 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  8029 |     | <span class='neutral'>        bytes32 m0;</span>
  8030 |     | <span class='neutral'>        bytes32 m1;</span>
  8031 |     | <span class='neutral'>        bytes32 m2;</span>
  8032 |     | <span class='neutral'>        bytes32 m3;</span>
  8033 |     | <span class='neutral'>        bytes32 m4;</span>
  8034 |     | <span class='neutral'>        assembly {</span>
  8035 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8036 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8037 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8038 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8039 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8040 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,uint256)`.</span>
  8041 |     | <span class='neutral'>            mstore(0x00, 0x0c9cd9c1)</span>
  8042 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8043 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8044 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8045 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8046 |     | <span class='neutral'>        }</span>
  8047 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8048 |     | <span class='neutral'>        assembly {</span>
  8049 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8050 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8051 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8052 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8053 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8054 |     | <span class='neutral'>        }</span>
  8055 |     | <span class='neutral'>    }</span>
  8056 |     | <span class='neutral'></span>
  8057 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  8058 |     | <span class='neutral'>        bytes32 m0;</span>
  8059 |     | <span class='neutral'>        bytes32 m1;</span>
  8060 |     | <span class='neutral'>        bytes32 m2;</span>
  8061 |     | <span class='neutral'>        bytes32 m3;</span>
  8062 |     | <span class='neutral'>        bytes32 m4;</span>
  8063 |     | <span class='neutral'>        bytes32 m5;</span>
  8064 |     | <span class='neutral'>        bytes32 m6;</span>
  8065 |     | <span class='neutral'>        assembly {</span>
  8066 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8067 |     | <span class='neutral'>                let length := 0</span>
  8068 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8069 |     | <span class='neutral'>                mstore(pos, length)</span>
  8070 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8071 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8072 |     | <span class='neutral'>            }</span>
  8073 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8074 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8075 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8076 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8077 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8078 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8079 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8080 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,string)`.</span>
  8081 |     | <span class='neutral'>            mstore(0x00, 0xddb06521)</span>
  8082 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8083 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8084 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8085 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8086 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8087 |     | <span class='neutral'>        }</span>
  8088 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8089 |     | <span class='neutral'>        assembly {</span>
  8090 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8091 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8092 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8093 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8094 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8095 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8096 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8097 |     | <span class='neutral'>        }</span>
  8098 |     | <span class='neutral'>    }</span>
  8099 |     | <span class='neutral'></span>
  8100 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {</span>
  8101 |     | <span class='neutral'>        bytes32 m0;</span>
  8102 |     | <span class='neutral'>        bytes32 m1;</span>
  8103 |     | <span class='neutral'>        bytes32 m2;</span>
  8104 |     | <span class='neutral'>        bytes32 m3;</span>
  8105 |     | <span class='neutral'>        bytes32 m4;</span>
  8106 |     | <span class='neutral'>        bytes32 m5;</span>
  8107 |     | <span class='neutral'>        bytes32 m6;</span>
  8108 |     | <span class='neutral'>        assembly {</span>
  8109 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8110 |     | <span class='neutral'>                let length := 0</span>
  8111 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8112 |     | <span class='neutral'>                mstore(pos, length)</span>
  8113 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8114 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8115 |     | <span class='neutral'>            }</span>
  8116 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8117 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8118 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8119 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8120 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8121 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8122 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8123 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,address)`.</span>
  8124 |     | <span class='neutral'>            mstore(0x00, 0x9cba8fff)</span>
  8125 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8126 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8127 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8128 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8129 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8130 |     | <span class='neutral'>        }</span>
  8131 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8132 |     | <span class='neutral'>        assembly {</span>
  8133 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8134 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8135 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8136 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8137 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8138 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8139 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8140 |     | <span class='neutral'>        }</span>
  8141 |     | <span class='neutral'>    }</span>
  8142 |     | <span class='neutral'></span>
  8143 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  8144 |     | <span class='neutral'>        bytes32 m0;</span>
  8145 |     | <span class='neutral'>        bytes32 m1;</span>
  8146 |     | <span class='neutral'>        bytes32 m2;</span>
  8147 |     | <span class='neutral'>        bytes32 m3;</span>
  8148 |     | <span class='neutral'>        bytes32 m4;</span>
  8149 |     | <span class='neutral'>        bytes32 m5;</span>
  8150 |     | <span class='neutral'>        bytes32 m6;</span>
  8151 |     | <span class='neutral'>        assembly {</span>
  8152 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8153 |     | <span class='neutral'>                let length := 0</span>
  8154 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8155 |     | <span class='neutral'>                mstore(pos, length)</span>
  8156 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8157 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8158 |     | <span class='neutral'>            }</span>
  8159 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8160 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8161 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8162 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8163 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8164 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8165 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8166 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,bool)`.</span>
  8167 |     | <span class='neutral'>            mstore(0x00, 0xcc32ab07)</span>
  8168 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8169 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8170 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8171 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8172 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8173 |     | <span class='neutral'>        }</span>
  8174 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8175 |     | <span class='neutral'>        assembly {</span>
  8176 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8177 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8178 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8179 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8180 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8181 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8182 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8183 |     | <span class='neutral'>        }</span>
  8184 |     | <span class='neutral'>    }</span>
  8185 |     | <span class='neutral'></span>
  8186 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  8187 |     | <span class='neutral'>        bytes32 m0;</span>
  8188 |     | <span class='neutral'>        bytes32 m1;</span>
  8189 |     | <span class='neutral'>        bytes32 m2;</span>
  8190 |     | <span class='neutral'>        bytes32 m3;</span>
  8191 |     | <span class='neutral'>        bytes32 m4;</span>
  8192 |     | <span class='neutral'>        bytes32 m5;</span>
  8193 |     | <span class='neutral'>        bytes32 m6;</span>
  8194 |     | <span class='neutral'>        assembly {</span>
  8195 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8196 |     | <span class='neutral'>                let length := 0</span>
  8197 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8198 |     | <span class='neutral'>                mstore(pos, length)</span>
  8199 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8200 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8201 |     | <span class='neutral'>            }</span>
  8202 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8203 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8204 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8205 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8206 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8207 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8208 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8209 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,uint256)`.</span>
  8210 |     | <span class='neutral'>            mstore(0x00, 0x46826b5d)</span>
  8211 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8212 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8213 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8214 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8215 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8216 |     | <span class='neutral'>        }</span>
  8217 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8218 |     | <span class='neutral'>        assembly {</span>
  8219 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8220 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8221 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8222 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8223 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8224 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8225 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8226 |     | <span class='neutral'>        }</span>
  8227 |     | <span class='neutral'>    }</span>
  8228 |     | <span class='neutral'></span>
  8229 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8230 |     | <span class='neutral'>        bytes32 m0;</span>
  8231 |     | <span class='neutral'>        bytes32 m1;</span>
  8232 |     | <span class='neutral'>        bytes32 m2;</span>
  8233 |     | <span class='neutral'>        bytes32 m3;</span>
  8234 |     | <span class='neutral'>        bytes32 m4;</span>
  8235 |     | <span class='neutral'>        bytes32 m5;</span>
  8236 |     | <span class='neutral'>        bytes32 m6;</span>
  8237 |     | <span class='neutral'>        bytes32 m7;</span>
  8238 |     | <span class='neutral'>        bytes32 m8;</span>
  8239 |     | <span class='neutral'>        assembly {</span>
  8240 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8241 |     | <span class='neutral'>                let length := 0</span>
  8242 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8243 |     | <span class='neutral'>                mstore(pos, length)</span>
  8244 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8245 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8246 |     | <span class='neutral'>            }</span>
  8247 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8248 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8249 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8250 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8251 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8252 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8253 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8254 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8255 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8256 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,string)`.</span>
  8257 |     | <span class='neutral'>            mstore(0x00, 0x3e128ca3)</span>
  8258 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8259 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8260 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8261 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  8262 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8263 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  8264 |     | <span class='neutral'>        }</span>
  8265 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8266 |     | <span class='neutral'>        assembly {</span>
  8267 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8268 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8269 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8270 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8271 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8272 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8273 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8274 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8275 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8276 |     | <span class='neutral'>        }</span>
  8277 |     | <span class='neutral'>    }</span>
  8278 |     | <span class='neutral'></span>
  8279 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal pure {</span>
  8280 |     | <span class='neutral'>        bytes32 m0;</span>
  8281 |     | <span class='neutral'>        bytes32 m1;</span>
  8282 |     | <span class='neutral'>        bytes32 m2;</span>
  8283 |     | <span class='neutral'>        bytes32 m3;</span>
  8284 |     | <span class='neutral'>        bytes32 m4;</span>
  8285 |     | <span class='neutral'>        assembly {</span>
  8286 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8287 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8288 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8289 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8290 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8291 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,address)`.</span>
  8292 |     | <span class='neutral'>            mstore(0x00, 0xa1ef4cbb)</span>
  8293 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8294 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8295 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8296 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8297 |     | <span class='neutral'>        }</span>
  8298 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8299 |     | <span class='neutral'>        assembly {</span>
  8300 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8301 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8302 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8303 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8304 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8305 |     | <span class='neutral'>        }</span>
  8306 |     | <span class='neutral'>    }</span>
  8307 |     | <span class='neutral'></span>
  8308 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {</span>
  8309 |     | <span class='neutral'>        bytes32 m0;</span>
  8310 |     | <span class='neutral'>        bytes32 m1;</span>
  8311 |     | <span class='neutral'>        bytes32 m2;</span>
  8312 |     | <span class='neutral'>        bytes32 m3;</span>
  8313 |     | <span class='neutral'>        bytes32 m4;</span>
  8314 |     | <span class='neutral'>        assembly {</span>
  8315 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8316 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8317 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8318 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8319 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8320 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,bool)`.</span>
  8321 |     | <span class='neutral'>            mstore(0x00, 0x454d54a5)</span>
  8322 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8323 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8324 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8325 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8326 |     | <span class='neutral'>        }</span>
  8327 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8328 |     | <span class='neutral'>        assembly {</span>
  8329 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8330 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8331 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8332 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8333 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8334 |     | <span class='neutral'>        }</span>
  8335 |     | <span class='neutral'>    }</span>
  8336 |     | <span class='neutral'></span>
  8337 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {</span>
  8338 |     | <span class='neutral'>        bytes32 m0;</span>
  8339 |     | <span class='neutral'>        bytes32 m1;</span>
  8340 |     | <span class='neutral'>        bytes32 m2;</span>
  8341 |     | <span class='neutral'>        bytes32 m3;</span>
  8342 |     | <span class='neutral'>        bytes32 m4;</span>
  8343 |     | <span class='neutral'>        assembly {</span>
  8344 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8345 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8346 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8347 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8348 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8349 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,uint256)`.</span>
  8350 |     | <span class='neutral'>            mstore(0x00, 0x078287f5)</span>
  8351 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8352 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8353 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8354 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8355 |     | <span class='neutral'>        }</span>
  8356 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8357 |     | <span class='neutral'>        assembly {</span>
  8358 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8359 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8360 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8361 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8362 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8363 |     | <span class='neutral'>        }</span>
  8364 |     | <span class='neutral'>    }</span>
  8365 |     | <span class='neutral'></span>
  8366 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  8367 |     | <span class='neutral'>        bytes32 m0;</span>
  8368 |     | <span class='neutral'>        bytes32 m1;</span>
  8369 |     | <span class='neutral'>        bytes32 m2;</span>
  8370 |     | <span class='neutral'>        bytes32 m3;</span>
  8371 |     | <span class='neutral'>        bytes32 m4;</span>
  8372 |     | <span class='neutral'>        bytes32 m5;</span>
  8373 |     | <span class='neutral'>        bytes32 m6;</span>
  8374 |     | <span class='neutral'>        assembly {</span>
  8375 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8376 |     | <span class='neutral'>                let length := 0</span>
  8377 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8378 |     | <span class='neutral'>                mstore(pos, length)</span>
  8379 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8380 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8381 |     | <span class='neutral'>            }</span>
  8382 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8383 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8384 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8385 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8386 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8387 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8388 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8389 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,string)`.</span>
  8390 |     | <span class='neutral'>            mstore(0x00, 0xade052c7)</span>
  8391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8392 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8394 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8395 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8396 |     | <span class='neutral'>        }</span>
  8397 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8398 |     | <span class='neutral'>        assembly {</span>
  8399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8404 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8405 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8406 |     | <span class='neutral'>        }</span>
  8407 |     | <span class='neutral'>    }</span>
  8408 |     | <span class='neutral'></span>
  8409 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {</span>
  8410 |     | <span class='neutral'>        bytes32 m0;</span>
  8411 |     | <span class='neutral'>        bytes32 m1;</span>
  8412 |     | <span class='neutral'>        bytes32 m2;</span>
  8413 |     | <span class='neutral'>        bytes32 m3;</span>
  8414 |     | <span class='neutral'>        bytes32 m4;</span>
  8415 |     | <span class='neutral'>        assembly {</span>
  8416 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8417 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8418 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8419 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8420 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8421 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,address)`.</span>
  8422 |     | <span class='neutral'>            mstore(0x00, 0x69640b59)</span>
  8423 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8424 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8425 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8426 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8427 |     | <span class='neutral'>        }</span>
  8428 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8429 |     | <span class='neutral'>        assembly {</span>
  8430 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8431 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8432 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8433 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8434 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8435 |     | <span class='neutral'>        }</span>
  8436 |     | <span class='neutral'>    }</span>
  8437 |     | <span class='neutral'></span>
  8438 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {</span>
  8439 |     | <span class='neutral'>        bytes32 m0;</span>
  8440 |     | <span class='neutral'>        bytes32 m1;</span>
  8441 |     | <span class='neutral'>        bytes32 m2;</span>
  8442 |     | <span class='neutral'>        bytes32 m3;</span>
  8443 |     | <span class='neutral'>        bytes32 m4;</span>
  8444 |     | <span class='neutral'>        assembly {</span>
  8445 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8446 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8447 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8448 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8449 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8450 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,bool)`.</span>
  8451 |     | <span class='neutral'>            mstore(0x00, 0xb6f577a1)</span>
  8452 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8453 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8454 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8455 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8456 |     | <span class='neutral'>        }</span>
  8457 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8458 |     | <span class='neutral'>        assembly {</span>
  8459 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8460 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8461 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8462 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8463 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8464 |     | <span class='neutral'>        }</span>
  8465 |     | <span class='neutral'>    }</span>
  8466 |     | <span class='neutral'></span>
  8467 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  8468 |     | <span class='neutral'>        bytes32 m0;</span>
  8469 |     | <span class='neutral'>        bytes32 m1;</span>
  8470 |     | <span class='neutral'>        bytes32 m2;</span>
  8471 |     | <span class='neutral'>        bytes32 m3;</span>
  8472 |     | <span class='neutral'>        bytes32 m4;</span>
  8473 |     | <span class='neutral'>        assembly {</span>
  8474 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8475 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8476 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8477 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8478 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8479 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,uint256)`.</span>
  8480 |     | <span class='neutral'>            mstore(0x00, 0x7464ce23)</span>
  8481 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8482 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8483 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8484 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8485 |     | <span class='neutral'>        }</span>
  8486 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8487 |     | <span class='neutral'>        assembly {</span>
  8488 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8489 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8490 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8491 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8492 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8493 |     | <span class='neutral'>        }</span>
  8494 |     | <span class='neutral'>    }</span>
  8495 |     | <span class='neutral'></span>
  8496 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  8497 |     | <span class='neutral'>        bytes32 m0;</span>
  8498 |     | <span class='neutral'>        bytes32 m1;</span>
  8499 |     | <span class='neutral'>        bytes32 m2;</span>
  8500 |     | <span class='neutral'>        bytes32 m3;</span>
  8501 |     | <span class='neutral'>        bytes32 m4;</span>
  8502 |     | <span class='neutral'>        bytes32 m5;</span>
  8503 |     | <span class='neutral'>        bytes32 m6;</span>
  8504 |     | <span class='neutral'>        assembly {</span>
  8505 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8506 |     | <span class='neutral'>                let length := 0</span>
  8507 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8508 |     | <span class='neutral'>                mstore(pos, length)</span>
  8509 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8510 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8511 |     | <span class='neutral'>            }</span>
  8512 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8513 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8514 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8515 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8516 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8517 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8518 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8519 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,string)`.</span>
  8520 |     | <span class='neutral'>            mstore(0x00, 0xdddb9561)</span>
  8521 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8522 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8523 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8524 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8525 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8526 |     | <span class='neutral'>        }</span>
  8527 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8528 |     | <span class='neutral'>        assembly {</span>
  8529 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8530 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8531 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8532 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8533 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8534 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8535 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8536 |     | <span class='neutral'>        }</span>
  8537 |     | <span class='neutral'>    }</span>
  8538 |     | <span class='neutral'></span>
  8539 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {</span>
  8540 |     | <span class='neutral'>        bytes32 m0;</span>
  8541 |     | <span class='neutral'>        bytes32 m1;</span>
  8542 |     | <span class='neutral'>        bytes32 m2;</span>
  8543 |     | <span class='neutral'>        bytes32 m3;</span>
  8544 |     | <span class='neutral'>        bytes32 m4;</span>
  8545 |     | <span class='neutral'>        assembly {</span>
  8546 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8547 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8548 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8549 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8550 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8551 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,address)`.</span>
  8552 |     | <span class='neutral'>            mstore(0x00, 0x88cb6041)</span>
  8553 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8554 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8555 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8556 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8557 |     | <span class='neutral'>        }</span>
  8558 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8559 |     | <span class='neutral'>        assembly {</span>
  8560 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8561 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8562 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8563 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8564 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8565 |     | <span class='neutral'>        }</span>
  8566 |     | <span class='neutral'>    }</span>
  8567 |     | <span class='neutral'></span>
  8568 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  8569 |     | <span class='neutral'>        bytes32 m0;</span>
  8570 |     | <span class='neutral'>        bytes32 m1;</span>
  8571 |     | <span class='neutral'>        bytes32 m2;</span>
  8572 |     | <span class='neutral'>        bytes32 m3;</span>
  8573 |     | <span class='neutral'>        bytes32 m4;</span>
  8574 |     | <span class='neutral'>        assembly {</span>
  8575 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8576 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8577 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8578 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8579 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8580 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,bool)`.</span>
  8581 |     | <span class='neutral'>            mstore(0x00, 0x91a02e2a)</span>
  8582 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8583 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8584 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8585 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8586 |     | <span class='neutral'>        }</span>
  8587 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8588 |     | <span class='neutral'>        assembly {</span>
  8589 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8590 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8591 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8592 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8593 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8594 |     | <span class='neutral'>        }</span>
  8595 |     | <span class='neutral'>    }</span>
  8596 |     | <span class='neutral'></span>
  8597 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  8598 |     | <span class='neutral'>        bytes32 m0;</span>
  8599 |     | <span class='neutral'>        bytes32 m1;</span>
  8600 |     | <span class='neutral'>        bytes32 m2;</span>
  8601 |     | <span class='neutral'>        bytes32 m3;</span>
  8602 |     | <span class='neutral'>        bytes32 m4;</span>
  8603 |     | <span class='neutral'>        assembly {</span>
  8604 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8605 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8606 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8607 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8608 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8609 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,uint256)`.</span>
  8610 |     | <span class='neutral'>            mstore(0x00, 0xc6acc7a8)</span>
  8611 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8612 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8613 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8614 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8615 |     | <span class='neutral'>        }</span>
  8616 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8617 |     | <span class='neutral'>        assembly {</span>
  8618 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8619 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8620 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8621 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8622 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8623 |     | <span class='neutral'>        }</span>
  8624 |     | <span class='neutral'>    }</span>
  8625 |     | <span class='neutral'></span>
  8626 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  8627 |     | <span class='neutral'>        bytes32 m0;</span>
  8628 |     | <span class='neutral'>        bytes32 m1;</span>
  8629 |     | <span class='neutral'>        bytes32 m2;</span>
  8630 |     | <span class='neutral'>        bytes32 m3;</span>
  8631 |     | <span class='neutral'>        bytes32 m4;</span>
  8632 |     | <span class='neutral'>        bytes32 m5;</span>
  8633 |     | <span class='neutral'>        bytes32 m6;</span>
  8634 |     | <span class='neutral'>        assembly {</span>
  8635 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8636 |     | <span class='neutral'>                let length := 0</span>
  8637 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8638 |     | <span class='neutral'>                mstore(pos, length)</span>
  8639 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8640 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8641 |     | <span class='neutral'>            }</span>
  8642 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8643 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8644 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8645 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8646 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8647 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8648 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8649 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,string)`.</span>
  8650 |     | <span class='neutral'>            mstore(0x00, 0xde03e774)</span>
  8651 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8652 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8653 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8654 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8655 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8656 |     | <span class='neutral'>        }</span>
  8657 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8658 |     | <span class='neutral'>        assembly {</span>
  8659 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8660 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8661 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8662 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8663 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8664 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8665 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8666 |     | <span class='neutral'>        }</span>
  8667 |     | <span class='neutral'>    }</span>
  8668 |     | <span class='neutral'></span>
  8669 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  8670 |     | <span class='neutral'>        bytes32 m0;</span>
  8671 |     | <span class='neutral'>        bytes32 m1;</span>
  8672 |     | <span class='neutral'>        bytes32 m2;</span>
  8673 |     | <span class='neutral'>        bytes32 m3;</span>
  8674 |     | <span class='neutral'>        bytes32 m4;</span>
  8675 |     | <span class='neutral'>        bytes32 m5;</span>
  8676 |     | <span class='neutral'>        bytes32 m6;</span>
  8677 |     | <span class='neutral'>        assembly {</span>
  8678 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8679 |     | <span class='neutral'>                let length := 0</span>
  8680 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8681 |     | <span class='neutral'>                mstore(pos, length)</span>
  8682 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8683 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8684 |     | <span class='neutral'>            }</span>
  8685 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8686 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8687 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8688 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8689 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8690 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8691 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8692 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,address)`.</span>
  8693 |     | <span class='neutral'>            mstore(0x00, 0xef529018)</span>
  8694 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8695 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8696 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8697 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8698 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8699 |     | <span class='neutral'>        }</span>
  8700 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8701 |     | <span class='neutral'>        assembly {</span>
  8702 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8703 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8704 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8705 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8706 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8707 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8708 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8709 |     | <span class='neutral'>        }</span>
  8710 |     | <span class='neutral'>    }</span>
  8711 |     | <span class='neutral'></span>
  8712 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  8713 |     | <span class='neutral'>        bytes32 m0;</span>
  8714 |     | <span class='neutral'>        bytes32 m1;</span>
  8715 |     | <span class='neutral'>        bytes32 m2;</span>
  8716 |     | <span class='neutral'>        bytes32 m3;</span>
  8717 |     | <span class='neutral'>        bytes32 m4;</span>
  8718 |     | <span class='neutral'>        bytes32 m5;</span>
  8719 |     | <span class='neutral'>        bytes32 m6;</span>
  8720 |     | <span class='neutral'>        assembly {</span>
  8721 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8722 |     | <span class='neutral'>                let length := 0</span>
  8723 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8724 |     | <span class='neutral'>                mstore(pos, length)</span>
  8725 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8726 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8727 |     | <span class='neutral'>            }</span>
  8728 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8729 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8730 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8731 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8732 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8733 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8734 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8735 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,bool)`.</span>
  8736 |     | <span class='neutral'>            mstore(0x00, 0xeb928d7f)</span>
  8737 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8738 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8739 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8740 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8741 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8742 |     | <span class='neutral'>        }</span>
  8743 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8744 |     | <span class='neutral'>        assembly {</span>
  8745 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8746 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8747 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8748 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8749 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8750 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8751 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8752 |     | <span class='neutral'>        }</span>
  8753 |     | <span class='neutral'>    }</span>
  8754 |     | <span class='neutral'></span>
  8755 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  8756 |     | <span class='neutral'>        bytes32 m0;</span>
  8757 |     | <span class='neutral'>        bytes32 m1;</span>
  8758 |     | <span class='neutral'>        bytes32 m2;</span>
  8759 |     | <span class='neutral'>        bytes32 m3;</span>
  8760 |     | <span class='neutral'>        bytes32 m4;</span>
  8761 |     | <span class='neutral'>        bytes32 m5;</span>
  8762 |     | <span class='neutral'>        bytes32 m6;</span>
  8763 |     | <span class='neutral'>        assembly {</span>
  8764 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8765 |     | <span class='neutral'>                let length := 0</span>
  8766 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8767 |     | <span class='neutral'>                mstore(pos, length)</span>
  8768 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8769 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8770 |     | <span class='neutral'>            }</span>
  8771 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8772 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8773 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8774 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8775 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8776 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8777 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8778 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,uint256)`.</span>
  8779 |     | <span class='neutral'>            mstore(0x00, 0x2c1d0746)</span>
  8780 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8781 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8782 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8783 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8784 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8785 |     | <span class='neutral'>        }</span>
  8786 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8787 |     | <span class='neutral'>        assembly {</span>
  8788 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8789 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8790 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8791 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8792 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8793 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8794 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8795 |     | <span class='neutral'>        }</span>
  8796 |     | <span class='neutral'>    }</span>
  8797 |     | <span class='neutral'></span>
  8798 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8799 |     | <span class='neutral'>        bytes32 m0;</span>
  8800 |     | <span class='neutral'>        bytes32 m1;</span>
  8801 |     | <span class='neutral'>        bytes32 m2;</span>
  8802 |     | <span class='neutral'>        bytes32 m3;</span>
  8803 |     | <span class='neutral'>        bytes32 m4;</span>
  8804 |     | <span class='neutral'>        bytes32 m5;</span>
  8805 |     | <span class='neutral'>        bytes32 m6;</span>
  8806 |     | <span class='neutral'>        bytes32 m7;</span>
  8807 |     | <span class='neutral'>        bytes32 m8;</span>
  8808 |     | <span class='neutral'>        assembly {</span>
  8809 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8810 |     | <span class='neutral'>                let length := 0</span>
  8811 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8812 |     | <span class='neutral'>                mstore(pos, length)</span>
  8813 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8814 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8815 |     | <span class='neutral'>            }</span>
  8816 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8817 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8818 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8819 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8820 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8821 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8822 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8823 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8824 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8825 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,string)`.</span>
  8826 |     | <span class='neutral'>            mstore(0x00, 0x68c8b8bd)</span>
  8827 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8828 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8829 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8830 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  8831 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8832 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  8833 |     | <span class='neutral'>        }</span>
  8834 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8835 |     | <span class='neutral'>        assembly {</span>
  8836 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8837 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8838 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8839 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8840 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8841 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8842 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8843 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8844 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8845 |     | <span class='neutral'>        }</span>
  8846 |     | <span class='neutral'>    }</span>
  8847 |     | <span class='neutral'></span>
  8848 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {</span>
  8849 |     | <span class='neutral'>        bytes32 m0;</span>
  8850 |     | <span class='neutral'>        bytes32 m1;</span>
  8851 |     | <span class='neutral'>        bytes32 m2;</span>
  8852 |     | <span class='neutral'>        bytes32 m3;</span>
  8853 |     | <span class='neutral'>        bytes32 m4;</span>
  8854 |     | <span class='neutral'>        assembly {</span>
  8855 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8856 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8857 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8858 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8859 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8860 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,address)`.</span>
  8861 |     | <span class='neutral'>            mstore(0x00, 0x56a5d1b1)</span>
  8862 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8863 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8864 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8865 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8866 |     | <span class='neutral'>        }</span>
  8867 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8868 |     | <span class='neutral'>        assembly {</span>
  8869 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8870 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8871 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8872 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8873 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8874 |     | <span class='neutral'>        }</span>
  8875 |     | <span class='neutral'>    }</span>
  8876 |     | <span class='neutral'></span>
  8877 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {</span>
  8878 |     | <span class='neutral'>        bytes32 m0;</span>
  8879 |     | <span class='neutral'>        bytes32 m1;</span>
  8880 |     | <span class='neutral'>        bytes32 m2;</span>
  8881 |     | <span class='neutral'>        bytes32 m3;</span>
  8882 |     | <span class='neutral'>        bytes32 m4;</span>
  8883 |     | <span class='neutral'>        assembly {</span>
  8884 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8885 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8886 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8887 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8888 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8889 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,bool)`.</span>
  8890 |     | <span class='neutral'>            mstore(0x00, 0x15cac476)</span>
  8891 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8892 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8893 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8894 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8895 |     | <span class='neutral'>        }</span>
  8896 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8897 |     | <span class='neutral'>        assembly {</span>
  8898 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8899 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8900 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8901 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8902 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8903 |     | <span class='neutral'>        }</span>
  8904 |     | <span class='neutral'>    }</span>
  8905 |     | <span class='neutral'></span>
  8906 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  8907 |     | <span class='neutral'>        bytes32 m0;</span>
  8908 |     | <span class='neutral'>        bytes32 m1;</span>
  8909 |     | <span class='neutral'>        bytes32 m2;</span>
  8910 |     | <span class='neutral'>        bytes32 m3;</span>
  8911 |     | <span class='neutral'>        bytes32 m4;</span>
  8912 |     | <span class='neutral'>        assembly {</span>
  8913 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8914 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8915 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8916 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8917 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8918 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,uint256)`.</span>
  8919 |     | <span class='neutral'>            mstore(0x00, 0x88f6e4b2)</span>
  8920 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8921 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8922 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8923 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8924 |     | <span class='neutral'>        }</span>
  8925 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8926 |     | <span class='neutral'>        assembly {</span>
  8927 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8928 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8929 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8930 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8931 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8932 |     | <span class='neutral'>        }</span>
  8933 |     | <span class='neutral'>    }</span>
  8934 |     | <span class='neutral'></span>
  8935 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  8936 |     | <span class='neutral'>        bytes32 m0;</span>
  8937 |     | <span class='neutral'>        bytes32 m1;</span>
  8938 |     | <span class='neutral'>        bytes32 m2;</span>
  8939 |     | <span class='neutral'>        bytes32 m3;</span>
  8940 |     | <span class='neutral'>        bytes32 m4;</span>
  8941 |     | <span class='neutral'>        bytes32 m5;</span>
  8942 |     | <span class='neutral'>        bytes32 m6;</span>
  8943 |     | <span class='neutral'>        assembly {</span>
  8944 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8945 |     | <span class='neutral'>                let length := 0</span>
  8946 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8947 |     | <span class='neutral'>                mstore(pos, length)</span>
  8948 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8949 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8950 |     | <span class='neutral'>            }</span>
  8951 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8952 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8953 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8954 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8955 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8956 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8957 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8958 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,string)`.</span>
  8959 |     | <span class='neutral'>            mstore(0x00, 0x6cde40b8)</span>
  8960 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8961 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8962 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8963 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8964 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8965 |     | <span class='neutral'>        }</span>
  8966 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8967 |     | <span class='neutral'>        assembly {</span>
  8968 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8969 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8970 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8971 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8972 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8973 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8974 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8975 |     | <span class='neutral'>        }</span>
  8976 |     | <span class='neutral'>    }</span>
  8977 |     | <span class='neutral'></span>
  8978 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {</span>
  8979 |     | <span class='neutral'>        bytes32 m0;</span>
  8980 |     | <span class='neutral'>        bytes32 m1;</span>
  8981 |     | <span class='neutral'>        bytes32 m2;</span>
  8982 |     | <span class='neutral'>        bytes32 m3;</span>
  8983 |     | <span class='neutral'>        bytes32 m4;</span>
  8984 |     | <span class='neutral'>        assembly {</span>
  8985 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8986 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8987 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8988 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8989 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8990 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,address)`.</span>
  8991 |     | <span class='neutral'>            mstore(0x00, 0x9a816a83)</span>
  8992 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8993 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8994 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8995 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8996 |     | <span class='neutral'>        }</span>
  8997 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8998 |     | <span class='neutral'>        assembly {</span>
  8999 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9000 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9001 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9002 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9003 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9004 |     | <span class='neutral'>        }</span>
  9005 |     | <span class='neutral'>    }</span>
  9006 |     | <span class='neutral'></span>
  9007 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  9008 |     | <span class='neutral'>        bytes32 m0;</span>
  9009 |     | <span class='neutral'>        bytes32 m1;</span>
  9010 |     | <span class='neutral'>        bytes32 m2;</span>
  9011 |     | <span class='neutral'>        bytes32 m3;</span>
  9012 |     | <span class='neutral'>        bytes32 m4;</span>
  9013 |     | <span class='neutral'>        assembly {</span>
  9014 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9015 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9016 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9017 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9018 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9019 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,bool)`.</span>
  9020 |     | <span class='neutral'>            mstore(0x00, 0xab085ae6)</span>
  9021 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9022 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9023 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9024 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9025 |     | <span class='neutral'>        }</span>
  9026 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9027 |     | <span class='neutral'>        assembly {</span>
  9028 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9029 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9030 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9031 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9032 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9033 |     | <span class='neutral'>        }</span>
  9034 |     | <span class='neutral'>    }</span>
  9035 |     | <span class='neutral'></span>
  9036 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  9037 |     | <span class='neutral'>        bytes32 m0;</span>
  9038 |     | <span class='neutral'>        bytes32 m1;</span>
  9039 |     | <span class='neutral'>        bytes32 m2;</span>
  9040 |     | <span class='neutral'>        bytes32 m3;</span>
  9041 |     | <span class='neutral'>        bytes32 m4;</span>
  9042 |     | <span class='neutral'>        assembly {</span>
  9043 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9044 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9045 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9046 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9047 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9048 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,uint256)`.</span>
  9049 |     | <span class='neutral'>            mstore(0x00, 0xeb7f6fd2)</span>
  9050 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9051 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9052 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9053 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9054 |     | <span class='neutral'>        }</span>
  9055 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9056 |     | <span class='neutral'>        assembly {</span>
  9057 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9058 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9059 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9060 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9061 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9062 |     | <span class='neutral'>        }</span>
  9063 |     | <span class='neutral'>    }</span>
  9064 |     | <span class='neutral'></span>
  9065 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  9066 |     | <span class='neutral'>        bytes32 m0;</span>
  9067 |     | <span class='neutral'>        bytes32 m1;</span>
  9068 |     | <span class='neutral'>        bytes32 m2;</span>
  9069 |     | <span class='neutral'>        bytes32 m3;</span>
  9070 |     | <span class='neutral'>        bytes32 m4;</span>
  9071 |     | <span class='neutral'>        bytes32 m5;</span>
  9072 |     | <span class='neutral'>        bytes32 m6;</span>
  9073 |     | <span class='neutral'>        assembly {</span>
  9074 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9075 |     | <span class='neutral'>                let length := 0</span>
  9076 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9077 |     | <span class='neutral'>                mstore(pos, length)</span>
  9078 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9079 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9080 |     | <span class='neutral'>            }</span>
  9081 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9082 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9083 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9084 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9085 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9086 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9087 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9088 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,string)`.</span>
  9089 |     | <span class='neutral'>            mstore(0x00, 0xa5b4fc99)</span>
  9090 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9091 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9092 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9093 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9094 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9095 |     | <span class='neutral'>        }</span>
  9096 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9097 |     | <span class='neutral'>        assembly {</span>
  9098 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9099 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9100 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9101 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9102 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9103 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9104 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9105 |     | <span class='neutral'>        }</span>
  9106 |     | <span class='neutral'>    }</span>
  9107 |     | <span class='neutral'></span>
  9108 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  9109 |     | <span class='neutral'>        bytes32 m0;</span>
  9110 |     | <span class='neutral'>        bytes32 m1;</span>
  9111 |     | <span class='neutral'>        bytes32 m2;</span>
  9112 |     | <span class='neutral'>        bytes32 m3;</span>
  9113 |     | <span class='neutral'>        bytes32 m4;</span>
  9114 |     | <span class='neutral'>        assembly {</span>
  9115 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9116 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9117 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9118 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9119 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9120 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,address)`.</span>
  9121 |     | <span class='neutral'>            mstore(0x00, 0xfa8185af)</span>
  9122 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9123 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9124 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9125 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9126 |     | <span class='neutral'>        }</span>
  9127 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9128 |     | <span class='neutral'>        assembly {</span>
  9129 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9130 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9131 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9132 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9133 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9134 |     | <span class='neutral'>        }</span>
  9135 |     | <span class='neutral'>    }</span>
  9136 |     | <span class='neutral'></span>
  9137 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  9138 |     | <span class='neutral'>        bytes32 m0;</span>
  9139 |     | <span class='neutral'>        bytes32 m1;</span>
  9140 |     | <span class='neutral'>        bytes32 m2;</span>
  9141 |     | <span class='neutral'>        bytes32 m3;</span>
  9142 |     | <span class='neutral'>        bytes32 m4;</span>
  9143 |     | <span class='neutral'>        assembly {</span>
  9144 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9145 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9146 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9147 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9148 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9149 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,bool)`.</span>
  9150 |     | <span class='neutral'>            mstore(0x00, 0xc598d185)</span>
  9151 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9152 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9153 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9154 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9155 |     | <span class='neutral'>        }</span>
  9156 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9157 |     | <span class='neutral'>        assembly {</span>
  9158 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9159 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9160 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9161 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9162 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9163 |     | <span class='neutral'>        }</span>
  9164 |     | <span class='neutral'>    }</span>
  9165 |     | <span class='neutral'></span>
  9166 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  9167 |     | <span class='neutral'>        bytes32 m0;</span>
  9168 |     | <span class='neutral'>        bytes32 m1;</span>
  9169 |     | <span class='neutral'>        bytes32 m2;</span>
  9170 |     | <span class='neutral'>        bytes32 m3;</span>
  9171 |     | <span class='neutral'>        bytes32 m4;</span>
  9172 |     | <span class='neutral'>        assembly {</span>
  9173 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9174 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9175 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9176 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9177 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9178 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,uint256)`.</span>
  9179 |     | <span class='neutral'>            mstore(0x00, 0x193fb800)</span>
  9180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9183 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9184 |     | <span class='neutral'>        }</span>
  9185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9186 |     | <span class='neutral'>        assembly {</span>
  9187 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9188 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9189 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9190 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9191 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9192 |     | <span class='neutral'>        }</span>
  9193 |     | <span class='neutral'>    }</span>
  9194 |     | <span class='neutral'></span>
  9195 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  9196 |     | <span class='neutral'>        bytes32 m0;</span>
  9197 |     | <span class='neutral'>        bytes32 m1;</span>
  9198 |     | <span class='neutral'>        bytes32 m2;</span>
  9199 |     | <span class='neutral'>        bytes32 m3;</span>
  9200 |     | <span class='neutral'>        bytes32 m4;</span>
  9201 |     | <span class='neutral'>        bytes32 m5;</span>
  9202 |     | <span class='neutral'>        bytes32 m6;</span>
  9203 |     | <span class='neutral'>        assembly {</span>
  9204 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9205 |     | <span class='neutral'>                let length := 0</span>
  9206 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9207 |     | <span class='neutral'>                mstore(pos, length)</span>
  9208 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9209 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9210 |     | <span class='neutral'>            }</span>
  9211 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9212 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9213 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9214 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9215 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9216 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9217 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9218 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,string)`.</span>
  9219 |     | <span class='neutral'>            mstore(0x00, 0x59cfcbe3)</span>
  9220 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9221 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9222 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9223 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9224 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9225 |     | <span class='neutral'>        }</span>
  9226 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9227 |     | <span class='neutral'>        assembly {</span>
  9228 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9229 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9230 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9231 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9232 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9233 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9234 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9235 |     | <span class='neutral'>        }</span>
  9236 |     | <span class='neutral'>    }</span>
  9237 |     | <span class='neutral'></span>
  9238 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  9239 |     | <span class='neutral'>        bytes32 m0;</span>
  9240 |     | <span class='neutral'>        bytes32 m1;</span>
  9241 |     | <span class='neutral'>        bytes32 m2;</span>
  9242 |     | <span class='neutral'>        bytes32 m3;</span>
  9243 |     | <span class='neutral'>        bytes32 m4;</span>
  9244 |     | <span class='neutral'>        bytes32 m5;</span>
  9245 |     | <span class='neutral'>        bytes32 m6;</span>
  9246 |     | <span class='neutral'>        assembly {</span>
  9247 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9248 |     | <span class='neutral'>                let length := 0</span>
  9249 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9250 |     | <span class='neutral'>                mstore(pos, length)</span>
  9251 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9252 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9253 |     | <span class='neutral'>            }</span>
  9254 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9255 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9256 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9257 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9258 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9259 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9260 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9261 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,address)`.</span>
  9262 |     | <span class='neutral'>            mstore(0x00, 0x42d21db7)</span>
  9263 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9264 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9265 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9266 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9267 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9268 |     | <span class='neutral'>        }</span>
  9269 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9270 |     | <span class='neutral'>        assembly {</span>
  9271 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9272 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9273 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9274 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9275 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9276 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9277 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9278 |     | <span class='neutral'>        }</span>
  9279 |     | <span class='neutral'>    }</span>
  9280 |     | <span class='neutral'></span>
  9281 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  9282 |     | <span class='neutral'>        bytes32 m0;</span>
  9283 |     | <span class='neutral'>        bytes32 m1;</span>
  9284 |     | <span class='neutral'>        bytes32 m2;</span>
  9285 |     | <span class='neutral'>        bytes32 m3;</span>
  9286 |     | <span class='neutral'>        bytes32 m4;</span>
  9287 |     | <span class='neutral'>        bytes32 m5;</span>
  9288 |     | <span class='neutral'>        bytes32 m6;</span>
  9289 |     | <span class='neutral'>        assembly {</span>
  9290 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9291 |     | <span class='neutral'>                let length := 0</span>
  9292 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9293 |     | <span class='neutral'>                mstore(pos, length)</span>
  9294 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9295 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9296 |     | <span class='neutral'>            }</span>
  9297 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9298 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9299 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9300 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9301 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9302 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9303 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9304 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,bool)`.</span>
  9305 |     | <span class='neutral'>            mstore(0x00, 0x7af6ab25)</span>
  9306 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9307 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9308 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9309 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9310 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9311 |     | <span class='neutral'>        }</span>
  9312 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9313 |     | <span class='neutral'>        assembly {</span>
  9314 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9315 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9316 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9317 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9318 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9319 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9320 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9321 |     | <span class='neutral'>        }</span>
  9322 |     | <span class='neutral'>    }</span>
  9323 |     | <span class='neutral'></span>
  9324 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  9325 |     | <span class='neutral'>        bytes32 m0;</span>
  9326 |     | <span class='neutral'>        bytes32 m1;</span>
  9327 |     | <span class='neutral'>        bytes32 m2;</span>
  9328 |     | <span class='neutral'>        bytes32 m3;</span>
  9329 |     | <span class='neutral'>        bytes32 m4;</span>
  9330 |     | <span class='neutral'>        bytes32 m5;</span>
  9331 |     | <span class='neutral'>        bytes32 m6;</span>
  9332 |     | <span class='neutral'>        assembly {</span>
  9333 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9334 |     | <span class='neutral'>                let length := 0</span>
  9335 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9336 |     | <span class='neutral'>                mstore(pos, length)</span>
  9337 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9338 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9339 |     | <span class='neutral'>            }</span>
  9340 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9341 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9342 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9343 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9344 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9345 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9346 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9347 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,uint256)`.</span>
  9348 |     | <span class='neutral'>            mstore(0x00, 0x5da297eb)</span>
  9349 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9350 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9351 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9352 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9353 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9354 |     | <span class='neutral'>        }</span>
  9355 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9356 |     | <span class='neutral'>        assembly {</span>
  9357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9362 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9363 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9364 |     | <span class='neutral'>        }</span>
  9365 |     | <span class='neutral'>    }</span>
  9366 |     | <span class='neutral'></span>
  9367 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  9368 |     | <span class='neutral'>        bytes32 m0;</span>
  9369 |     | <span class='neutral'>        bytes32 m1;</span>
  9370 |     | <span class='neutral'>        bytes32 m2;</span>
  9371 |     | <span class='neutral'>        bytes32 m3;</span>
  9372 |     | <span class='neutral'>        bytes32 m4;</span>
  9373 |     | <span class='neutral'>        bytes32 m5;</span>
  9374 |     | <span class='neutral'>        bytes32 m6;</span>
  9375 |     | <span class='neutral'>        bytes32 m7;</span>
  9376 |     | <span class='neutral'>        bytes32 m8;</span>
  9377 |     | <span class='neutral'>        assembly {</span>
  9378 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9379 |     | <span class='neutral'>                let length := 0</span>
  9380 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9381 |     | <span class='neutral'>                mstore(pos, length)</span>
  9382 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9383 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9384 |     | <span class='neutral'>            }</span>
  9385 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9386 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9387 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9388 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9389 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9390 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9391 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9392 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9393 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9394 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,string)`.</span>
  9395 |     | <span class='neutral'>            mstore(0x00, 0x27d8afd2)</span>
  9396 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9397 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9398 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9399 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9400 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9401 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9402 |     | <span class='neutral'>        }</span>
  9403 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9404 |     | <span class='neutral'>        assembly {</span>
  9405 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9406 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9407 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9408 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9409 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9410 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9411 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9412 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9413 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9414 |     | <span class='neutral'>        }</span>
  9415 |     | <span class='neutral'>    }</span>
  9416 |     | <span class='neutral'></span>
  9417 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {</span>
  9418 |     | <span class='neutral'>        bytes32 m0;</span>
  9419 |     | <span class='neutral'>        bytes32 m1;</span>
  9420 |     | <span class='neutral'>        bytes32 m2;</span>
  9421 |     | <span class='neutral'>        bytes32 m3;</span>
  9422 |     | <span class='neutral'>        bytes32 m4;</span>
  9423 |     | <span class='neutral'>        bytes32 m5;</span>
  9424 |     | <span class='neutral'>        bytes32 m6;</span>
  9425 |     | <span class='neutral'>        assembly {</span>
  9426 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9427 |     | <span class='neutral'>                let length := 0</span>
  9428 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9429 |     | <span class='neutral'>                mstore(pos, length)</span>
  9430 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9431 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9432 |     | <span class='neutral'>            }</span>
  9433 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9434 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9435 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9436 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9437 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9438 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9439 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9440 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,address)`.</span>
  9441 |     | <span class='neutral'>            mstore(0x00, 0x6168ed61)</span>
  9442 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9443 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9444 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9445 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9446 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9447 |     | <span class='neutral'>        }</span>
  9448 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9449 |     | <span class='neutral'>        assembly {</span>
  9450 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9451 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9452 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9453 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9454 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9455 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9456 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9457 |     | <span class='neutral'>        }</span>
  9458 |     | <span class='neutral'>    }</span>
  9459 |     | <span class='neutral'></span>
  9460 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  9461 |     | <span class='neutral'>        bytes32 m0;</span>
  9462 |     | <span class='neutral'>        bytes32 m1;</span>
  9463 |     | <span class='neutral'>        bytes32 m2;</span>
  9464 |     | <span class='neutral'>        bytes32 m3;</span>
  9465 |     | <span class='neutral'>        bytes32 m4;</span>
  9466 |     | <span class='neutral'>        bytes32 m5;</span>
  9467 |     | <span class='neutral'>        bytes32 m6;</span>
  9468 |     | <span class='neutral'>        assembly {</span>
  9469 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9470 |     | <span class='neutral'>                let length := 0</span>
  9471 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9472 |     | <span class='neutral'>                mstore(pos, length)</span>
  9473 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9474 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9475 |     | <span class='neutral'>            }</span>
  9476 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9477 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9478 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9479 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9480 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9481 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9482 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9483 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,bool)`.</span>
  9484 |     | <span class='neutral'>            mstore(0x00, 0x90c30a56)</span>
  9485 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9486 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9487 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9488 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9489 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9490 |     | <span class='neutral'>        }</span>
  9491 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9492 |     | <span class='neutral'>        assembly {</span>
  9493 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9494 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9495 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9496 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9497 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9498 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9499 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9500 |     | <span class='neutral'>        }</span>
  9501 |     | <span class='neutral'>    }</span>
  9502 |     | <span class='neutral'></span>
  9503 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  9504 |     | <span class='neutral'>        bytes32 m0;</span>
  9505 |     | <span class='neutral'>        bytes32 m1;</span>
  9506 |     | <span class='neutral'>        bytes32 m2;</span>
  9507 |     | <span class='neutral'>        bytes32 m3;</span>
  9508 |     | <span class='neutral'>        bytes32 m4;</span>
  9509 |     | <span class='neutral'>        bytes32 m5;</span>
  9510 |     | <span class='neutral'>        bytes32 m6;</span>
  9511 |     | <span class='neutral'>        assembly {</span>
  9512 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9513 |     | <span class='neutral'>                let length := 0</span>
  9514 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9515 |     | <span class='neutral'>                mstore(pos, length)</span>
  9516 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9517 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9518 |     | <span class='neutral'>            }</span>
  9519 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9520 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9521 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9522 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9523 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9524 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9525 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9526 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,uint256)`.</span>
  9527 |     | <span class='neutral'>            mstore(0x00, 0xe8d3018d)</span>
  9528 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9529 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9530 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9531 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9532 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9533 |     | <span class='neutral'>        }</span>
  9534 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9535 |     | <span class='neutral'>        assembly {</span>
  9536 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9537 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9538 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9539 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9540 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9541 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9542 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9543 |     | <span class='neutral'>        }</span>
  9544 |     | <span class='neutral'>    }</span>
  9545 |     | <span class='neutral'></span>
  9546 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  9547 |     | <span class='neutral'>        bytes32 m0;</span>
  9548 |     | <span class='neutral'>        bytes32 m1;</span>
  9549 |     | <span class='neutral'>        bytes32 m2;</span>
  9550 |     | <span class='neutral'>        bytes32 m3;</span>
  9551 |     | <span class='neutral'>        bytes32 m4;</span>
  9552 |     | <span class='neutral'>        bytes32 m5;</span>
  9553 |     | <span class='neutral'>        bytes32 m6;</span>
  9554 |     | <span class='neutral'>        bytes32 m7;</span>
  9555 |     | <span class='neutral'>        bytes32 m8;</span>
  9556 |     | <span class='neutral'>        assembly {</span>
  9557 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9558 |     | <span class='neutral'>                let length := 0</span>
  9559 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9560 |     | <span class='neutral'>                mstore(pos, length)</span>
  9561 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9562 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9563 |     | <span class='neutral'>            }</span>
  9564 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9565 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9566 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9567 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9568 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9569 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9570 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9571 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9572 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9573 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,string)`.</span>
  9574 |     | <span class='neutral'>            mstore(0x00, 0x9c3adfa1)</span>
  9575 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9576 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9577 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9578 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9579 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9580 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9581 |     | <span class='neutral'>        }</span>
  9582 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9583 |     | <span class='neutral'>        assembly {</span>
  9584 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9585 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9586 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9587 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9588 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9589 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9590 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9591 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9592 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9593 |     | <span class='neutral'>        }</span>
  9594 |     | <span class='neutral'>    }</span>
  9595 |     | <span class='neutral'></span>
  9596 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  9597 |     | <span class='neutral'>        bytes32 m0;</span>
  9598 |     | <span class='neutral'>        bytes32 m1;</span>
  9599 |     | <span class='neutral'>        bytes32 m2;</span>
  9600 |     | <span class='neutral'>        bytes32 m3;</span>
  9601 |     | <span class='neutral'>        bytes32 m4;</span>
  9602 |     | <span class='neutral'>        bytes32 m5;</span>
  9603 |     | <span class='neutral'>        bytes32 m6;</span>
  9604 |     | <span class='neutral'>        assembly {</span>
  9605 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9606 |     | <span class='neutral'>                let length := 0</span>
  9607 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9608 |     | <span class='neutral'>                mstore(pos, length)</span>
  9609 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9610 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9611 |     | <span class='neutral'>            }</span>
  9612 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9613 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9614 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9615 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9616 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9617 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9618 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9619 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,address)`.</span>
  9620 |     | <span class='neutral'>            mstore(0x00, 0xae2ec581)</span>
  9621 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9622 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9623 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9624 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9625 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9626 |     | <span class='neutral'>        }</span>
  9627 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9628 |     | <span class='neutral'>        assembly {</span>
  9629 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9630 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9631 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9632 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9633 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9634 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9635 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9636 |     | <span class='neutral'>        }</span>
  9637 |     | <span class='neutral'>    }</span>
  9638 |     | <span class='neutral'></span>
  9639 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  9640 |     | <span class='neutral'>        bytes32 m0;</span>
  9641 |     | <span class='neutral'>        bytes32 m1;</span>
  9642 |     | <span class='neutral'>        bytes32 m2;</span>
  9643 |     | <span class='neutral'>        bytes32 m3;</span>
  9644 |     | <span class='neutral'>        bytes32 m4;</span>
  9645 |     | <span class='neutral'>        bytes32 m5;</span>
  9646 |     | <span class='neutral'>        bytes32 m6;</span>
  9647 |     | <span class='neutral'>        assembly {</span>
  9648 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9649 |     | <span class='neutral'>                let length := 0</span>
  9650 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9651 |     | <span class='neutral'>                mstore(pos, length)</span>
  9652 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9653 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9654 |     | <span class='neutral'>            }</span>
  9655 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9656 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9657 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9658 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9659 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9660 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9661 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9662 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,bool)`.</span>
  9663 |     | <span class='neutral'>            mstore(0x00, 0xba535d9c)</span>
  9664 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9665 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9666 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9667 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9668 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9669 |     | <span class='neutral'>        }</span>
  9670 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9671 |     | <span class='neutral'>        assembly {</span>
  9672 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9673 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9674 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9675 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9676 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9677 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9678 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9679 |     | <span class='neutral'>        }</span>
  9680 |     | <span class='neutral'>    }</span>
  9681 |     | <span class='neutral'></span>
  9682 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  9683 |     | <span class='neutral'>        bytes32 m0;</span>
  9684 |     | <span class='neutral'>        bytes32 m1;</span>
  9685 |     | <span class='neutral'>        bytes32 m2;</span>
  9686 |     | <span class='neutral'>        bytes32 m3;</span>
  9687 |     | <span class='neutral'>        bytes32 m4;</span>
  9688 |     | <span class='neutral'>        bytes32 m5;</span>
  9689 |     | <span class='neutral'>        bytes32 m6;</span>
  9690 |     | <span class='neutral'>        assembly {</span>
  9691 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9692 |     | <span class='neutral'>                let length := 0</span>
  9693 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9694 |     | <span class='neutral'>                mstore(pos, length)</span>
  9695 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9696 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9697 |     | <span class='neutral'>            }</span>
  9698 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9699 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9700 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9701 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9702 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9703 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9704 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9705 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,uint256)`.</span>
  9706 |     | <span class='neutral'>            mstore(0x00, 0xcf009880)</span>
  9707 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9708 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9709 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9710 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9711 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9712 |     | <span class='neutral'>        }</span>
  9713 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9714 |     | <span class='neutral'>        assembly {</span>
  9715 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9716 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9717 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9718 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9719 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9720 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9721 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9722 |     | <span class='neutral'>        }</span>
  9723 |     | <span class='neutral'>    }</span>
  9724 |     | <span class='neutral'></span>
  9725 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  9726 |     | <span class='neutral'>        bytes32 m0;</span>
  9727 |     | <span class='neutral'>        bytes32 m1;</span>
  9728 |     | <span class='neutral'>        bytes32 m2;</span>
  9729 |     | <span class='neutral'>        bytes32 m3;</span>
  9730 |     | <span class='neutral'>        bytes32 m4;</span>
  9731 |     | <span class='neutral'>        bytes32 m5;</span>
  9732 |     | <span class='neutral'>        bytes32 m6;</span>
  9733 |     | <span class='neutral'>        bytes32 m7;</span>
  9734 |     | <span class='neutral'>        bytes32 m8;</span>
  9735 |     | <span class='neutral'>        assembly {</span>
  9736 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9737 |     | <span class='neutral'>                let length := 0</span>
  9738 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9739 |     | <span class='neutral'>                mstore(pos, length)</span>
  9740 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9741 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9742 |     | <span class='neutral'>            }</span>
  9743 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9744 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9745 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9746 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9747 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9748 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9749 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9750 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9751 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9752 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,string)`.</span>
  9753 |     | <span class='neutral'>            mstore(0x00, 0xd2d423cd)</span>
  9754 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9755 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9756 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9757 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9758 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9759 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9760 |     | <span class='neutral'>        }</span>
  9761 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9762 |     | <span class='neutral'>        assembly {</span>
  9763 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9764 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9765 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9766 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9767 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9768 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9769 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9770 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9771 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9772 |     | <span class='neutral'>        }</span>
  9773 |     | <span class='neutral'>    }</span>
  9774 |     | <span class='neutral'></span>
  9775 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  9776 |     | <span class='neutral'>        bytes32 m0;</span>
  9777 |     | <span class='neutral'>        bytes32 m1;</span>
  9778 |     | <span class='neutral'>        bytes32 m2;</span>
  9779 |     | <span class='neutral'>        bytes32 m3;</span>
  9780 |     | <span class='neutral'>        bytes32 m4;</span>
  9781 |     | <span class='neutral'>        bytes32 m5;</span>
  9782 |     | <span class='neutral'>        bytes32 m6;</span>
  9783 |     | <span class='neutral'>        assembly {</span>
  9784 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9785 |     | <span class='neutral'>                let length := 0</span>
  9786 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9787 |     | <span class='neutral'>                mstore(pos, length)</span>
  9788 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9789 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9790 |     | <span class='neutral'>            }</span>
  9791 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9792 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9793 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9794 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9795 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9796 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9797 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9798 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,address)`.</span>
  9799 |     | <span class='neutral'>            mstore(0x00, 0x3b2279b4)</span>
  9800 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9801 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9802 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9803 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9804 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9805 |     | <span class='neutral'>        }</span>
  9806 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9807 |     | <span class='neutral'>        assembly {</span>
  9808 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9809 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9810 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9811 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9812 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9813 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9814 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9815 |     | <span class='neutral'>        }</span>
  9816 |     | <span class='neutral'>    }</span>
  9817 |     | <span class='neutral'></span>
  9818 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  9819 |     | <span class='neutral'>        bytes32 m0;</span>
  9820 |     | <span class='neutral'>        bytes32 m1;</span>
  9821 |     | <span class='neutral'>        bytes32 m2;</span>
  9822 |     | <span class='neutral'>        bytes32 m3;</span>
  9823 |     | <span class='neutral'>        bytes32 m4;</span>
  9824 |     | <span class='neutral'>        bytes32 m5;</span>
  9825 |     | <span class='neutral'>        bytes32 m6;</span>
  9826 |     | <span class='neutral'>        assembly {</span>
  9827 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9828 |     | <span class='neutral'>                let length := 0</span>
  9829 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9830 |     | <span class='neutral'>                mstore(pos, length)</span>
  9831 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9832 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9833 |     | <span class='neutral'>            }</span>
  9834 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9835 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9836 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9837 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9838 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9839 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9840 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9841 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,bool)`.</span>
  9842 |     | <span class='neutral'>            mstore(0x00, 0x691a8f74)</span>
  9843 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9844 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9845 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9846 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9847 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9848 |     | <span class='neutral'>        }</span>
  9849 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9850 |     | <span class='neutral'>        assembly {</span>
  9851 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9852 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9853 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9854 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9855 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9856 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9857 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9858 |     | <span class='neutral'>        }</span>
  9859 |     | <span class='neutral'>    }</span>
  9860 |     | <span class='neutral'></span>
  9861 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  9862 |     | <span class='neutral'>        bytes32 m0;</span>
  9863 |     | <span class='neutral'>        bytes32 m1;</span>
  9864 |     | <span class='neutral'>        bytes32 m2;</span>
  9865 |     | <span class='neutral'>        bytes32 m3;</span>
  9866 |     | <span class='neutral'>        bytes32 m4;</span>
  9867 |     | <span class='neutral'>        bytes32 m5;</span>
  9868 |     | <span class='neutral'>        bytes32 m6;</span>
  9869 |     | <span class='neutral'>        assembly {</span>
  9870 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9871 |     | <span class='neutral'>                let length := 0</span>
  9872 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9873 |     | <span class='neutral'>                mstore(pos, length)</span>
  9874 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9875 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9876 |     | <span class='neutral'>            }</span>
  9877 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9878 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9879 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9880 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9881 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9882 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9883 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9884 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,uint256)`.</span>
  9885 |     | <span class='neutral'>            mstore(0x00, 0x82c25b74)</span>
  9886 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9887 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9888 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9889 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9890 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9891 |     | <span class='neutral'>        }</span>
  9892 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9893 |     | <span class='neutral'>        assembly {</span>
  9894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9898 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9899 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9900 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9901 |     | <span class='neutral'>        }</span>
  9902 |     | <span class='neutral'>    }</span>
  9903 |     | <span class='neutral'></span>
  9904 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  9905 |     | <span class='neutral'>        bytes32 m0;</span>
  9906 |     | <span class='neutral'>        bytes32 m1;</span>
  9907 |     | <span class='neutral'>        bytes32 m2;</span>
  9908 |     | <span class='neutral'>        bytes32 m3;</span>
  9909 |     | <span class='neutral'>        bytes32 m4;</span>
  9910 |     | <span class='neutral'>        bytes32 m5;</span>
  9911 |     | <span class='neutral'>        bytes32 m6;</span>
  9912 |     | <span class='neutral'>        bytes32 m7;</span>
  9913 |     | <span class='neutral'>        bytes32 m8;</span>
  9914 |     | <span class='neutral'>        assembly {</span>
  9915 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9916 |     | <span class='neutral'>                let length := 0</span>
  9917 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9918 |     | <span class='neutral'>                mstore(pos, length)</span>
  9919 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9920 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9921 |     | <span class='neutral'>            }</span>
  9922 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9923 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9924 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9925 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9926 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9927 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9928 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9929 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9930 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9931 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,string)`.</span>
  9932 |     | <span class='neutral'>            mstore(0x00, 0xb7b914ca)</span>
  9933 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9934 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9935 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9936 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9937 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9938 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9939 |     | <span class='neutral'>        }</span>
  9940 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9941 |     | <span class='neutral'>        assembly {</span>
  9942 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9943 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9944 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9945 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9946 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9947 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9948 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9949 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9950 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9951 |     | <span class='neutral'>        }</span>
  9952 |     | <span class='neutral'>    }</span>
  9953 |     | <span class='neutral'></span>
  9954 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  9955 |     | <span class='neutral'>        bytes32 m0;</span>
  9956 |     | <span class='neutral'>        bytes32 m1;</span>
  9957 |     | <span class='neutral'>        bytes32 m2;</span>
  9958 |     | <span class='neutral'>        bytes32 m3;</span>
  9959 |     | <span class='neutral'>        bytes32 m4;</span>
  9960 |     | <span class='neutral'>        bytes32 m5;</span>
  9961 |     | <span class='neutral'>        bytes32 m6;</span>
  9962 |     | <span class='neutral'>        bytes32 m7;</span>
  9963 |     | <span class='neutral'>        bytes32 m8;</span>
  9964 |     | <span class='neutral'>        assembly {</span>
  9965 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9966 |     | <span class='neutral'>                let length := 0</span>
  9967 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9968 |     | <span class='neutral'>                mstore(pos, length)</span>
  9969 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9970 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9971 |     | <span class='neutral'>            }</span>
  9972 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9973 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9974 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9975 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9976 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9977 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9978 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9979 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9980 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9981 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,address)`.</span>
  9982 |     | <span class='neutral'>            mstore(0x00, 0xd583c602)</span>
  9983 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9984 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9985 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  9986 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9987 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9988 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  9989 |     | <span class='neutral'>        }</span>
  9990 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9991 |     | <span class='neutral'>        assembly {</span>
  9992 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9993 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9994 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9995 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9996 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9997 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9998 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9999 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10000 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10001 |     | <span class='neutral'>        }</span>
 10002 |     | <span class='neutral'>    }</span>
 10003 |     | <span class='neutral'></span>
 10004 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 10005 |     | <span class='neutral'>        bytes32 m0;</span>
 10006 |     | <span class='neutral'>        bytes32 m1;</span>
 10007 |     | <span class='neutral'>        bytes32 m2;</span>
 10008 |     | <span class='neutral'>        bytes32 m3;</span>
 10009 |     | <span class='neutral'>        bytes32 m4;</span>
 10010 |     | <span class='neutral'>        bytes32 m5;</span>
 10011 |     | <span class='neutral'>        bytes32 m6;</span>
 10012 |     | <span class='neutral'>        bytes32 m7;</span>
 10013 |     | <span class='neutral'>        bytes32 m8;</span>
 10014 |     | <span class='neutral'>        assembly {</span>
 10015 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10016 |     | <span class='neutral'>                let length := 0</span>
 10017 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10018 |     | <span class='neutral'>                mstore(pos, length)</span>
 10019 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10020 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10021 |     | <span class='neutral'>            }</span>
 10022 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10023 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10024 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10025 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10026 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10027 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10028 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10029 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10030 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10031 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,bool)`.</span>
 10032 |     | <span class='neutral'>            mstore(0x00, 0xb3a6b6bd)</span>
 10033 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10034 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10035 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10036 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10037 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10038 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10039 |     | <span class='neutral'>        }</span>
 10040 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10041 |     | <span class='neutral'>        assembly {</span>
 10042 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10043 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10044 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10045 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10046 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10047 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10048 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10049 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10050 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10051 |     | <span class='neutral'>        }</span>
 10052 |     | <span class='neutral'>    }</span>
 10053 |     | <span class='neutral'></span>
 10054 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 10055 |     | <span class='neutral'>        bytes32 m0;</span>
 10056 |     | <span class='neutral'>        bytes32 m1;</span>
 10057 |     | <span class='neutral'>        bytes32 m2;</span>
 10058 |     | <span class='neutral'>        bytes32 m3;</span>
 10059 |     | <span class='neutral'>        bytes32 m4;</span>
 10060 |     | <span class='neutral'>        bytes32 m5;</span>
 10061 |     | <span class='neutral'>        bytes32 m6;</span>
 10062 |     | <span class='neutral'>        bytes32 m7;</span>
 10063 |     | <span class='neutral'>        bytes32 m8;</span>
 10064 |     | <span class='neutral'>        assembly {</span>
 10065 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10066 |     | <span class='neutral'>                let length := 0</span>
 10067 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10068 |     | <span class='neutral'>                mstore(pos, length)</span>
 10069 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10070 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10071 |     | <span class='neutral'>            }</span>
 10072 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10073 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10074 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10075 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10076 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10077 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10078 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10079 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10080 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10081 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,uint256)`.</span>
 10082 |     | <span class='neutral'>            mstore(0x00, 0xb028c9bd)</span>
 10083 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10084 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10085 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10086 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10087 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10088 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10089 |     | <span class='neutral'>        }</span>
 10090 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10091 |     | <span class='neutral'>        assembly {</span>
 10092 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10093 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10094 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10095 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10096 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10097 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10098 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10099 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10100 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10101 |     | <span class='neutral'>        }</span>
 10102 |     | <span class='neutral'>    }</span>
 10103 |     | <span class='neutral'></span>
 10104 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 10105 |     | <span class='neutral'>        bytes32 m0;</span>
 10106 |     | <span class='neutral'>        bytes32 m1;</span>
 10107 |     | <span class='neutral'>        bytes32 m2;</span>
 10108 |     | <span class='neutral'>        bytes32 m3;</span>
 10109 |     | <span class='neutral'>        bytes32 m4;</span>
 10110 |     | <span class='neutral'>        bytes32 m5;</span>
 10111 |     | <span class='neutral'>        bytes32 m6;</span>
 10112 |     | <span class='neutral'>        bytes32 m7;</span>
 10113 |     | <span class='neutral'>        bytes32 m8;</span>
 10114 |     | <span class='neutral'>        bytes32 m9;</span>
 10115 |     | <span class='neutral'>        bytes32 m10;</span>
 10116 |     | <span class='neutral'>        assembly {</span>
 10117 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10118 |     | <span class='neutral'>                let length := 0</span>
 10119 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10120 |     | <span class='neutral'>                mstore(pos, length)</span>
 10121 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10122 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10123 |     | <span class='neutral'>            }</span>
 10124 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10125 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10126 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10127 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10128 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10129 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10130 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10131 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10132 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10133 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 10134 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 10135 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,string)`.</span>
 10136 |     | <span class='neutral'>            mstore(0x00, 0x21ad0683)</span>
 10137 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10138 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10139 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10140 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 10141 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10142 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10143 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 10144 |     | <span class='neutral'>        }</span>
 10145 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 10146 |     | <span class='neutral'>        assembly {</span>
 10147 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10148 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10149 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10150 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10151 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10152 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10153 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10154 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10155 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10156 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 10157 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 10158 |     | <span class='neutral'>        }</span>
 10159 |     | <span class='neutral'>    }</span>
 10160 |     | <span class='neutral'></span>
 10161 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, address p3) internal pure {</span>
 10162 |     | <span class='neutral'>        bytes32 m0;</span>
 10163 |     | <span class='neutral'>        bytes32 m1;</span>
 10164 |     | <span class='neutral'>        bytes32 m2;</span>
 10165 |     | <span class='neutral'>        bytes32 m3;</span>
 10166 |     | <span class='neutral'>        bytes32 m4;</span>
 10167 |     | <span class='neutral'>        bytes32 m5;</span>
 10168 |     | <span class='neutral'>        bytes32 m6;</span>
 10169 |     | <span class='neutral'>        assembly {</span>
 10170 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10171 |     | <span class='neutral'>                let length := 0</span>
 10172 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10173 |     | <span class='neutral'>                mstore(pos, length)</span>
 10174 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10175 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10176 |     | <span class='neutral'>            }</span>
 10177 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10178 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10179 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10180 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10181 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10182 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10183 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10184 |     | <span class='neutral'>            // Selector of `log(string,address,address,address)`.</span>
 10185 |     | <span class='neutral'>            mstore(0x00, 0xed8f28f6)</span>
 10186 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10187 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10188 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10189 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10190 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10191 |     | <span class='neutral'>        }</span>
 10192 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10193 |     | <span class='neutral'>        assembly {</span>
 10194 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10195 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10196 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10197 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10198 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10199 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10200 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10201 |     | <span class='neutral'>        }</span>
 10202 |     | <span class='neutral'>    }</span>
 10203 |     | <span class='neutral'></span>
 10204 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {</span>
 10205 |     | <span class='neutral'>        bytes32 m0;</span>
 10206 |     | <span class='neutral'>        bytes32 m1;</span>
 10207 |     | <span class='neutral'>        bytes32 m2;</span>
 10208 |     | <span class='neutral'>        bytes32 m3;</span>
 10209 |     | <span class='neutral'>        bytes32 m4;</span>
 10210 |     | <span class='neutral'>        bytes32 m5;</span>
 10211 |     | <span class='neutral'>        bytes32 m6;</span>
 10212 |     | <span class='neutral'>        assembly {</span>
 10213 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10214 |     | <span class='neutral'>                let length := 0</span>
 10215 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10216 |     | <span class='neutral'>                mstore(pos, length)</span>
 10217 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10218 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10219 |     | <span class='neutral'>            }</span>
 10220 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10221 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10222 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10223 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10224 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10225 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10226 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10227 |     | <span class='neutral'>            // Selector of `log(string,address,address,bool)`.</span>
 10228 |     | <span class='neutral'>            mstore(0x00, 0xb59dbd60)</span>
 10229 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10230 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10231 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10232 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10233 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10234 |     | <span class='neutral'>        }</span>
 10235 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10236 |     | <span class='neutral'>        assembly {</span>
 10237 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10238 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10239 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10240 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10241 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10242 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10243 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10244 |     | <span class='neutral'>        }</span>
 10245 |     | <span class='neutral'>    }</span>
 10246 |     | <span class='neutral'></span>
 10247 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {</span>
 10248 |     | <span class='neutral'>        bytes32 m0;</span>
 10249 |     | <span class='neutral'>        bytes32 m1;</span>
 10250 |     | <span class='neutral'>        bytes32 m2;</span>
 10251 |     | <span class='neutral'>        bytes32 m3;</span>
 10252 |     | <span class='neutral'>        bytes32 m4;</span>
 10253 |     | <span class='neutral'>        bytes32 m5;</span>
 10254 |     | <span class='neutral'>        bytes32 m6;</span>
 10255 |     | <span class='neutral'>        assembly {</span>
 10256 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10257 |     | <span class='neutral'>                let length := 0</span>
 10258 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10259 |     | <span class='neutral'>                mstore(pos, length)</span>
 10260 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10261 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10262 |     | <span class='neutral'>            }</span>
 10263 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10264 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10265 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10266 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10267 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10268 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10269 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10270 |     | <span class='neutral'>            // Selector of `log(string,address,address,uint256)`.</span>
 10271 |     | <span class='neutral'>            mstore(0x00, 0x8ef3f399)</span>
 10272 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10273 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10274 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10275 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10276 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10277 |     | <span class='neutral'>        }</span>
 10278 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10279 |     | <span class='neutral'>        assembly {</span>
 10280 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10281 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10282 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10283 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10284 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10285 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10286 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10287 |     | <span class='neutral'>        }</span>
 10288 |     | <span class='neutral'>    }</span>
 10289 |     | <span class='neutral'></span>
 10290 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {</span>
 10291 |     | <span class='neutral'>        bytes32 m0;</span>
 10292 |     | <span class='neutral'>        bytes32 m1;</span>
 10293 |     | <span class='neutral'>        bytes32 m2;</span>
 10294 |     | <span class='neutral'>        bytes32 m3;</span>
 10295 |     | <span class='neutral'>        bytes32 m4;</span>
 10296 |     | <span class='neutral'>        bytes32 m5;</span>
 10297 |     | <span class='neutral'>        bytes32 m6;</span>
 10298 |     | <span class='neutral'>        bytes32 m7;</span>
 10299 |     | <span class='neutral'>        bytes32 m8;</span>
 10300 |     | <span class='neutral'>        assembly {</span>
 10301 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10302 |     | <span class='neutral'>                let length := 0</span>
 10303 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10304 |     | <span class='neutral'>                mstore(pos, length)</span>
 10305 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10306 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10307 |     | <span class='neutral'>            }</span>
 10308 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10309 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10310 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10311 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10312 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10313 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10314 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10315 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10316 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10317 |     | <span class='neutral'>            // Selector of `log(string,address,address,string)`.</span>
 10318 |     | <span class='neutral'>            mstore(0x00, 0x800a1c67)</span>
 10319 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10320 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10321 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10322 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10323 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10324 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10325 |     | <span class='neutral'>        }</span>
 10326 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10327 |     | <span class='neutral'>        assembly {</span>
 10328 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10329 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10330 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10331 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10332 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10333 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10334 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10335 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10336 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10337 |     | <span class='neutral'>        }</span>
 10338 |     | <span class='neutral'>    }</span>
 10339 |     | <span class='neutral'></span>
 10340 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {</span>
 10341 |     | <span class='neutral'>        bytes32 m0;</span>
 10342 |     | <span class='neutral'>        bytes32 m1;</span>
 10343 |     | <span class='neutral'>        bytes32 m2;</span>
 10344 |     | <span class='neutral'>        bytes32 m3;</span>
 10345 |     | <span class='neutral'>        bytes32 m4;</span>
 10346 |     | <span class='neutral'>        bytes32 m5;</span>
 10347 |     | <span class='neutral'>        bytes32 m6;</span>
 10348 |     | <span class='neutral'>        assembly {</span>
 10349 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10350 |     | <span class='neutral'>                let length := 0</span>
 10351 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10352 |     | <span class='neutral'>                mstore(pos, length)</span>
 10353 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10354 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10355 |     | <span class='neutral'>            }</span>
 10356 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10357 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10358 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10359 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10360 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10361 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10362 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10363 |     | <span class='neutral'>            // Selector of `log(string,address,bool,address)`.</span>
 10364 |     | <span class='neutral'>            mstore(0x00, 0x223603bd)</span>
 10365 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10366 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10367 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10368 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10369 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10370 |     | <span class='neutral'>        }</span>
 10371 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10372 |     | <span class='neutral'>        assembly {</span>
 10373 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10374 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10375 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10376 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10377 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10378 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10379 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10380 |     | <span class='neutral'>        }</span>
 10381 |     | <span class='neutral'>    }</span>
 10382 |     | <span class='neutral'></span>
 10383 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {</span>
 10384 |     | <span class='neutral'>        bytes32 m0;</span>
 10385 |     | <span class='neutral'>        bytes32 m1;</span>
 10386 |     | <span class='neutral'>        bytes32 m2;</span>
 10387 |     | <span class='neutral'>        bytes32 m3;</span>
 10388 |     | <span class='neutral'>        bytes32 m4;</span>
 10389 |     | <span class='neutral'>        bytes32 m5;</span>
 10390 |     | <span class='neutral'>        bytes32 m6;</span>
 10391 |     | <span class='neutral'>        assembly {</span>
 10392 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10393 |     | <span class='neutral'>                let length := 0</span>
 10394 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10395 |     | <span class='neutral'>                mstore(pos, length)</span>
 10396 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10397 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10398 |     | <span class='neutral'>            }</span>
 10399 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10400 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10401 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10402 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10403 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10404 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10405 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10406 |     | <span class='neutral'>            // Selector of `log(string,address,bool,bool)`.</span>
 10407 |     | <span class='neutral'>            mstore(0x00, 0x79884c2b)</span>
 10408 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10409 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10410 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10411 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10412 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10413 |     | <span class='neutral'>        }</span>
 10414 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10415 |     | <span class='neutral'>        assembly {</span>
 10416 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10417 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10418 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10419 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10420 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10421 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10422 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10423 |     | <span class='neutral'>        }</span>
 10424 |     | <span class='neutral'>    }</span>
 10425 |     | <span class='neutral'></span>
 10426 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {</span>
 10427 |     | <span class='neutral'>        bytes32 m0;</span>
 10428 |     | <span class='neutral'>        bytes32 m1;</span>
 10429 |     | <span class='neutral'>        bytes32 m2;</span>
 10430 |     | <span class='neutral'>        bytes32 m3;</span>
 10431 |     | <span class='neutral'>        bytes32 m4;</span>
 10432 |     | <span class='neutral'>        bytes32 m5;</span>
 10433 |     | <span class='neutral'>        bytes32 m6;</span>
 10434 |     | <span class='neutral'>        assembly {</span>
 10435 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10436 |     | <span class='neutral'>                let length := 0</span>
 10437 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10438 |     | <span class='neutral'>                mstore(pos, length)</span>
 10439 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10440 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10441 |     | <span class='neutral'>            }</span>
 10442 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10443 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10444 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10445 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10446 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10447 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10448 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10449 |     | <span class='neutral'>            // Selector of `log(string,address,bool,uint256)`.</span>
 10450 |     | <span class='neutral'>            mstore(0x00, 0x3e9f866a)</span>
 10451 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10452 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10453 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10454 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10455 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10456 |     | <span class='neutral'>        }</span>
 10457 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10458 |     | <span class='neutral'>        assembly {</span>
 10459 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10460 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10461 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10462 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10463 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10464 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10465 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10466 |     | <span class='neutral'>        }</span>
 10467 |     | <span class='neutral'>    }</span>
 10468 |     | <span class='neutral'></span>
 10469 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
 10470 |     | <span class='neutral'>        bytes32 m0;</span>
 10471 |     | <span class='neutral'>        bytes32 m1;</span>
 10472 |     | <span class='neutral'>        bytes32 m2;</span>
 10473 |     | <span class='neutral'>        bytes32 m3;</span>
 10474 |     | <span class='neutral'>        bytes32 m4;</span>
 10475 |     | <span class='neutral'>        bytes32 m5;</span>
 10476 |     | <span class='neutral'>        bytes32 m6;</span>
 10477 |     | <span class='neutral'>        bytes32 m7;</span>
 10478 |     | <span class='neutral'>        bytes32 m8;</span>
 10479 |     | <span class='neutral'>        assembly {</span>
 10480 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10481 |     | <span class='neutral'>                let length := 0</span>
 10482 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10483 |     | <span class='neutral'>                mstore(pos, length)</span>
 10484 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10485 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10486 |     | <span class='neutral'>            }</span>
 10487 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10488 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10489 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10490 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10491 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10492 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10493 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10494 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10495 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10496 |     | <span class='neutral'>            // Selector of `log(string,address,bool,string)`.</span>
 10497 |     | <span class='neutral'>            mstore(0x00, 0x0454c079)</span>
 10498 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10499 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10500 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10501 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10502 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10503 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10504 |     | <span class='neutral'>        }</span>
 10505 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10506 |     | <span class='neutral'>        assembly {</span>
 10507 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10508 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10509 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10510 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10511 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10512 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10513 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10514 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10515 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10516 |     | <span class='neutral'>        }</span>
 10517 |     | <span class='neutral'>    }</span>
 10518 |     | <span class='neutral'></span>
 10519 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {</span>
 10520 |     | <span class='neutral'>        bytes32 m0;</span>
 10521 |     | <span class='neutral'>        bytes32 m1;</span>
 10522 |     | <span class='neutral'>        bytes32 m2;</span>
 10523 |     | <span class='neutral'>        bytes32 m3;</span>
 10524 |     | <span class='neutral'>        bytes32 m4;</span>
 10525 |     | <span class='neutral'>        bytes32 m5;</span>
 10526 |     | <span class='neutral'>        bytes32 m6;</span>
 10527 |     | <span class='neutral'>        assembly {</span>
 10528 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10529 |     | <span class='neutral'>                let length := 0</span>
 10530 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10531 |     | <span class='neutral'>                mstore(pos, length)</span>
 10532 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10533 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10534 |     | <span class='neutral'>            }</span>
 10535 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10536 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10537 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10538 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10539 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10540 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10541 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10542 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,address)`.</span>
 10543 |     | <span class='neutral'>            mstore(0x00, 0x63fb8bc5)</span>
 10544 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10545 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10546 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10547 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10548 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10549 |     | <span class='neutral'>        }</span>
 10550 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10551 |     | <span class='neutral'>        assembly {</span>
 10552 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10553 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10554 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10555 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10556 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10557 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10558 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10559 |     | <span class='neutral'>        }</span>
 10560 |     | <span class='neutral'>    }</span>
 10561 |     | <span class='neutral'></span>
 10562 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {</span>
 10563 |     | <span class='neutral'>        bytes32 m0;</span>
 10564 |     | <span class='neutral'>        bytes32 m1;</span>
 10565 |     | <span class='neutral'>        bytes32 m2;</span>
 10566 |     | <span class='neutral'>        bytes32 m3;</span>
 10567 |     | <span class='neutral'>        bytes32 m4;</span>
 10568 |     | <span class='neutral'>        bytes32 m5;</span>
 10569 |     | <span class='neutral'>        bytes32 m6;</span>
 10570 |     | <span class='neutral'>        assembly {</span>
 10571 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10572 |     | <span class='neutral'>                let length := 0</span>
 10573 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10574 |     | <span class='neutral'>                mstore(pos, length)</span>
 10575 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10576 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10577 |     | <span class='neutral'>            }</span>
 10578 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10579 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10580 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10581 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10582 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10583 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10584 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10585 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,bool)`.</span>
 10586 |     | <span class='neutral'>            mstore(0x00, 0xfc4845f0)</span>
 10587 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10588 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10589 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10590 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10591 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10592 |     | <span class='neutral'>        }</span>
 10593 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10594 |     | <span class='neutral'>        assembly {</span>
 10595 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10596 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10597 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10598 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10599 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10600 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10601 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10602 |     | <span class='neutral'>        }</span>
 10603 |     | <span class='neutral'>    }</span>
 10604 |     | <span class='neutral'></span>
 10605 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 10606 |     | <span class='neutral'>        bytes32 m0;</span>
 10607 |     | <span class='neutral'>        bytes32 m1;</span>
 10608 |     | <span class='neutral'>        bytes32 m2;</span>
 10609 |     | <span class='neutral'>        bytes32 m3;</span>
 10610 |     | <span class='neutral'>        bytes32 m4;</span>
 10611 |     | <span class='neutral'>        bytes32 m5;</span>
 10612 |     | <span class='neutral'>        bytes32 m6;</span>
 10613 |     | <span class='neutral'>        assembly {</span>
 10614 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10615 |     | <span class='neutral'>                let length := 0</span>
 10616 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10617 |     | <span class='neutral'>                mstore(pos, length)</span>
 10618 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10619 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10620 |     | <span class='neutral'>            }</span>
 10621 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10622 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10623 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10624 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10625 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10626 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10627 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10628 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,uint256)`.</span>
 10629 |     | <span class='neutral'>            mstore(0x00, 0xf8f51b1e)</span>
 10630 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10631 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10632 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10633 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10634 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10635 |     | <span class='neutral'>        }</span>
 10636 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10637 |     | <span class='neutral'>        assembly {</span>
 10638 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10639 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10640 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10641 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10642 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10643 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10644 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10645 |     | <span class='neutral'>        }</span>
 10646 |     | <span class='neutral'>    }</span>
 10647 |     | <span class='neutral'></span>
 10648 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
 10649 |     | <span class='neutral'>        bytes32 m0;</span>
 10650 |     | <span class='neutral'>        bytes32 m1;</span>
 10651 |     | <span class='neutral'>        bytes32 m2;</span>
 10652 |     | <span class='neutral'>        bytes32 m3;</span>
 10653 |     | <span class='neutral'>        bytes32 m4;</span>
 10654 |     | <span class='neutral'>        bytes32 m5;</span>
 10655 |     | <span class='neutral'>        bytes32 m6;</span>
 10656 |     | <span class='neutral'>        bytes32 m7;</span>
 10657 |     | <span class='neutral'>        bytes32 m8;</span>
 10658 |     | <span class='neutral'>        assembly {</span>
 10659 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10660 |     | <span class='neutral'>                let length := 0</span>
 10661 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10662 |     | <span class='neutral'>                mstore(pos, length)</span>
 10663 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10664 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10665 |     | <span class='neutral'>            }</span>
 10666 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10667 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10668 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10669 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10670 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10671 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10672 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10673 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10674 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10675 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,string)`.</span>
 10676 |     | <span class='neutral'>            mstore(0x00, 0x5a477632)</span>
 10677 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10678 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10679 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10680 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10681 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10682 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10683 |     | <span class='neutral'>        }</span>
 10684 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10685 |     | <span class='neutral'>        assembly {</span>
 10686 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10687 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10688 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10689 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10690 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10691 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10692 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10693 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10694 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10695 |     | <span class='neutral'>        }</span>
 10696 |     | <span class='neutral'>    }</span>
 10697 |     | <span class='neutral'></span>
 10698 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {</span>
 10699 |     | <span class='neutral'>        bytes32 m0;</span>
 10700 |     | <span class='neutral'>        bytes32 m1;</span>
 10701 |     | <span class='neutral'>        bytes32 m2;</span>
 10702 |     | <span class='neutral'>        bytes32 m3;</span>
 10703 |     | <span class='neutral'>        bytes32 m4;</span>
 10704 |     | <span class='neutral'>        bytes32 m5;</span>
 10705 |     | <span class='neutral'>        bytes32 m6;</span>
 10706 |     | <span class='neutral'>        bytes32 m7;</span>
 10707 |     | <span class='neutral'>        bytes32 m8;</span>
 10708 |     | <span class='neutral'>        assembly {</span>
 10709 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10710 |     | <span class='neutral'>                let length := 0</span>
 10711 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10712 |     | <span class='neutral'>                mstore(pos, length)</span>
 10713 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10714 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10715 |     | <span class='neutral'>            }</span>
 10716 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10717 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10718 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10719 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10720 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10721 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10722 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10723 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10724 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10725 |     | <span class='neutral'>            // Selector of `log(string,address,string,address)`.</span>
 10726 |     | <span class='neutral'>            mstore(0x00, 0xaabc9a31)</span>
 10727 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10728 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10729 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10730 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10731 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10732 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10733 |     | <span class='neutral'>        }</span>
 10734 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10735 |     | <span class='neutral'>        assembly {</span>
 10736 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10737 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10738 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10739 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10740 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10741 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10742 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10743 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10744 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10745 |     | <span class='neutral'>        }</span>
 10746 |     | <span class='neutral'>    }</span>
 10747 |     | <span class='neutral'></span>
 10748 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
 10749 |     | <span class='neutral'>        bytes32 m0;</span>
 10750 |     | <span class='neutral'>        bytes32 m1;</span>
 10751 |     | <span class='neutral'>        bytes32 m2;</span>
 10752 |     | <span class='neutral'>        bytes32 m3;</span>
 10753 |     | <span class='neutral'>        bytes32 m4;</span>
 10754 |     | <span class='neutral'>        bytes32 m5;</span>
 10755 |     | <span class='neutral'>        bytes32 m6;</span>
 10756 |     | <span class='neutral'>        bytes32 m7;</span>
 10757 |     | <span class='neutral'>        bytes32 m8;</span>
 10758 |     | <span class='neutral'>        assembly {</span>
 10759 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10760 |     | <span class='neutral'>                let length := 0</span>
 10761 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10762 |     | <span class='neutral'>                mstore(pos, length)</span>
 10763 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10764 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10765 |     | <span class='neutral'>            }</span>
 10766 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10767 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10768 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10769 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10770 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10771 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10772 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10773 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10774 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10775 |     | <span class='neutral'>            // Selector of `log(string,address,string,bool)`.</span>
 10776 |     | <span class='neutral'>            mstore(0x00, 0x5f15d28c)</span>
 10777 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10778 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10779 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10780 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10781 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10782 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10783 |     | <span class='neutral'>        }</span>
 10784 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10785 |     | <span class='neutral'>        assembly {</span>
 10786 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10787 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10788 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10789 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10790 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10791 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10792 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10793 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10794 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10795 |     | <span class='neutral'>        }</span>
 10796 |     | <span class='neutral'>    }</span>
 10797 |     | <span class='neutral'></span>
 10798 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
 10799 |     | <span class='neutral'>        bytes32 m0;</span>
 10800 |     | <span class='neutral'>        bytes32 m1;</span>
 10801 |     | <span class='neutral'>        bytes32 m2;</span>
 10802 |     | <span class='neutral'>        bytes32 m3;</span>
 10803 |     | <span class='neutral'>        bytes32 m4;</span>
 10804 |     | <span class='neutral'>        bytes32 m5;</span>
 10805 |     | <span class='neutral'>        bytes32 m6;</span>
 10806 |     | <span class='neutral'>        bytes32 m7;</span>
 10807 |     | <span class='neutral'>        bytes32 m8;</span>
 10808 |     | <span class='neutral'>        assembly {</span>
 10809 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10810 |     | <span class='neutral'>                let length := 0</span>
 10811 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10812 |     | <span class='neutral'>                mstore(pos, length)</span>
 10813 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10814 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10815 |     | <span class='neutral'>            }</span>
 10816 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10817 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10818 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10819 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10820 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10821 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10822 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10823 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10824 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10825 |     | <span class='neutral'>            // Selector of `log(string,address,string,uint256)`.</span>
 10826 |     | <span class='neutral'>            mstore(0x00, 0x91d1112e)</span>
 10827 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10828 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10829 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10830 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10831 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10832 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10833 |     | <span class='neutral'>        }</span>
 10834 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10835 |     | <span class='neutral'>        assembly {</span>
 10836 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10837 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10838 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10839 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10840 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10841 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10842 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10843 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10844 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10845 |     | <span class='neutral'>        }</span>
 10846 |     | <span class='neutral'>    }</span>
 10847 |     | <span class='neutral'></span>
 10848 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
 10849 |     | <span class='neutral'>        bytes32 m0;</span>
 10850 |     | <span class='neutral'>        bytes32 m1;</span>
 10851 |     | <span class='neutral'>        bytes32 m2;</span>
 10852 |     | <span class='neutral'>        bytes32 m3;</span>
 10853 |     | <span class='neutral'>        bytes32 m4;</span>
 10854 |     | <span class='neutral'>        bytes32 m5;</span>
 10855 |     | <span class='neutral'>        bytes32 m6;</span>
 10856 |     | <span class='neutral'>        bytes32 m7;</span>
 10857 |     | <span class='neutral'>        bytes32 m8;</span>
 10858 |     | <span class='neutral'>        bytes32 m9;</span>
 10859 |     | <span class='neutral'>        bytes32 m10;</span>
 10860 |     | <span class='neutral'>        assembly {</span>
 10861 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10862 |     | <span class='neutral'>                let length := 0</span>
 10863 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10864 |     | <span class='neutral'>                mstore(pos, length)</span>
 10865 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10866 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10867 |     | <span class='neutral'>            }</span>
 10868 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10869 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10870 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10871 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10872 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10873 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10874 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10875 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10876 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10877 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 10878 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 10879 |     | <span class='neutral'>            // Selector of `log(string,address,string,string)`.</span>
 10880 |     | <span class='neutral'>            mstore(0x00, 0x245986f2)</span>
 10881 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10882 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10883 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10884 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 10885 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10886 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10887 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 10888 |     | <span class='neutral'>        }</span>
 10889 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 10890 |     | <span class='neutral'>        assembly {</span>
 10891 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10892 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10893 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10894 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10895 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10896 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10897 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10898 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10899 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10900 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 10901 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 10902 |     | <span class='neutral'>        }</span>
 10903 |     | <span class='neutral'>    }</span>
 10904 |     | <span class='neutral'></span>
 10905 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {</span>
 10906 |     | <span class='neutral'>        bytes32 m0;</span>
 10907 |     | <span class='neutral'>        bytes32 m1;</span>
 10908 |     | <span class='neutral'>        bytes32 m2;</span>
 10909 |     | <span class='neutral'>        bytes32 m3;</span>
 10910 |     | <span class='neutral'>        bytes32 m4;</span>
 10911 |     | <span class='neutral'>        bytes32 m5;</span>
 10912 |     | <span class='neutral'>        bytes32 m6;</span>
 10913 |     | <span class='neutral'>        assembly {</span>
 10914 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10915 |     | <span class='neutral'>                let length := 0</span>
 10916 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10917 |     | <span class='neutral'>                mstore(pos, length)</span>
 10918 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10919 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10920 |     | <span class='neutral'>            }</span>
 10921 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10922 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10923 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10924 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10925 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10926 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10927 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10928 |     | <span class='neutral'>            // Selector of `log(string,bool,address,address)`.</span>
 10929 |     | <span class='neutral'>            mstore(0x00, 0x33e9dd1d)</span>
 10930 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10931 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10932 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10933 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10934 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10935 |     | <span class='neutral'>        }</span>
 10936 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10937 |     | <span class='neutral'>        assembly {</span>
 10938 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10939 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10940 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10941 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10942 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10943 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10944 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10945 |     | <span class='neutral'>        }</span>
 10946 |     | <span class='neutral'>    }</span>
 10947 |     | <span class='neutral'></span>
 10948 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {</span>
 10949 |     | <span class='neutral'>        bytes32 m0;</span>
 10950 |     | <span class='neutral'>        bytes32 m1;</span>
 10951 |     | <span class='neutral'>        bytes32 m2;</span>
 10952 |     | <span class='neutral'>        bytes32 m3;</span>
 10953 |     | <span class='neutral'>        bytes32 m4;</span>
 10954 |     | <span class='neutral'>        bytes32 m5;</span>
 10955 |     | <span class='neutral'>        bytes32 m6;</span>
 10956 |     | <span class='neutral'>        assembly {</span>
 10957 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10958 |     | <span class='neutral'>                let length := 0</span>
 10959 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10960 |     | <span class='neutral'>                mstore(pos, length)</span>
 10961 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10962 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10963 |     | <span class='neutral'>            }</span>
 10964 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10965 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10966 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10967 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10968 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10969 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10970 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10971 |     | <span class='neutral'>            // Selector of `log(string,bool,address,bool)`.</span>
 10972 |     | <span class='neutral'>            mstore(0x00, 0x958c28c6)</span>
 10973 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10974 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10975 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10976 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10977 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10978 |     | <span class='neutral'>        }</span>
 10979 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10980 |     | <span class='neutral'>        assembly {</span>
 10981 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10982 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10983 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10984 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10985 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10986 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10987 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10988 |     | <span class='neutral'>        }</span>
 10989 |     | <span class='neutral'>    }</span>
 10990 |     | <span class='neutral'></span>
 10991 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {</span>
 10992 |     | <span class='neutral'>        bytes32 m0;</span>
 10993 |     | <span class='neutral'>        bytes32 m1;</span>
 10994 |     | <span class='neutral'>        bytes32 m2;</span>
 10995 |     | <span class='neutral'>        bytes32 m3;</span>
 10996 |     | <span class='neutral'>        bytes32 m4;</span>
 10997 |     | <span class='neutral'>        bytes32 m5;</span>
 10998 |     | <span class='neutral'>        bytes32 m6;</span>
 10999 |     | <span class='neutral'>        assembly {</span>
 11000 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11001 |     | <span class='neutral'>                let length := 0</span>
 11002 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11003 |     | <span class='neutral'>                mstore(pos, length)</span>
 11004 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11005 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11006 |     | <span class='neutral'>            }</span>
 11007 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11008 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11009 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11010 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11011 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11012 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11013 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11014 |     | <span class='neutral'>            // Selector of `log(string,bool,address,uint256)`.</span>
 11015 |     | <span class='neutral'>            mstore(0x00, 0x5d08bb05)</span>
 11016 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11017 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11018 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11019 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11020 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11021 |     | <span class='neutral'>        }</span>
 11022 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11023 |     | <span class='neutral'>        assembly {</span>
 11024 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11025 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11026 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11027 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11028 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11029 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11030 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11031 |     | <span class='neutral'>        }</span>
 11032 |     | <span class='neutral'>    }</span>
 11033 |     | <span class='neutral'></span>
 11034 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
 11035 |     | <span class='neutral'>        bytes32 m0;</span>
 11036 |     | <span class='neutral'>        bytes32 m1;</span>
 11037 |     | <span class='neutral'>        bytes32 m2;</span>
 11038 |     | <span class='neutral'>        bytes32 m3;</span>
 11039 |     | <span class='neutral'>        bytes32 m4;</span>
 11040 |     | <span class='neutral'>        bytes32 m5;</span>
 11041 |     | <span class='neutral'>        bytes32 m6;</span>
 11042 |     | <span class='neutral'>        bytes32 m7;</span>
 11043 |     | <span class='neutral'>        bytes32 m8;</span>
 11044 |     | <span class='neutral'>        assembly {</span>
 11045 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11046 |     | <span class='neutral'>                let length := 0</span>
 11047 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11048 |     | <span class='neutral'>                mstore(pos, length)</span>
 11049 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11050 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11051 |     | <span class='neutral'>            }</span>
 11052 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11053 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11054 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11055 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11056 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11057 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11058 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11059 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11060 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11061 |     | <span class='neutral'>            // Selector of `log(string,bool,address,string)`.</span>
 11062 |     | <span class='neutral'>            mstore(0x00, 0x2d8e33a4)</span>
 11063 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11064 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11065 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11066 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11067 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11068 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11069 |     | <span class='neutral'>        }</span>
 11070 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11071 |     | <span class='neutral'>        assembly {</span>
 11072 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11073 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11074 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11075 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11076 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11077 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11078 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11079 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11080 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11081 |     | <span class='neutral'>        }</span>
 11082 |     | <span class='neutral'>    }</span>
 11083 |     | <span class='neutral'></span>
 11084 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {</span>
 11085 |     | <span class='neutral'>        bytes32 m0;</span>
 11086 |     | <span class='neutral'>        bytes32 m1;</span>
 11087 |     | <span class='neutral'>        bytes32 m2;</span>
 11088 |     | <span class='neutral'>        bytes32 m3;</span>
 11089 |     | <span class='neutral'>        bytes32 m4;</span>
 11090 |     | <span class='neutral'>        bytes32 m5;</span>
 11091 |     | <span class='neutral'>        bytes32 m6;</span>
 11092 |     | <span class='neutral'>        assembly {</span>
 11093 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11094 |     | <span class='neutral'>                let length := 0</span>
 11095 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11096 |     | <span class='neutral'>                mstore(pos, length)</span>
 11097 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11098 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11099 |     | <span class='neutral'>            }</span>
 11100 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11101 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11102 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11103 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11104 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11105 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11106 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11107 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,address)`.</span>
 11108 |     | <span class='neutral'>            mstore(0x00, 0x7190a529)</span>
 11109 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11110 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11111 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11112 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11113 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11114 |     | <span class='neutral'>        }</span>
 11115 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11116 |     | <span class='neutral'>        assembly {</span>
 11117 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11118 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11119 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11120 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11121 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11122 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11123 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11124 |     | <span class='neutral'>        }</span>
 11125 |     | <span class='neutral'>    }</span>
 11126 |     | <span class='neutral'></span>
 11127 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {</span>
 11128 |     | <span class='neutral'>        bytes32 m0;</span>
 11129 |     | <span class='neutral'>        bytes32 m1;</span>
 11130 |     | <span class='neutral'>        bytes32 m2;</span>
 11131 |     | <span class='neutral'>        bytes32 m3;</span>
 11132 |     | <span class='neutral'>        bytes32 m4;</span>
 11133 |     | <span class='neutral'>        bytes32 m5;</span>
 11134 |     | <span class='neutral'>        bytes32 m6;</span>
 11135 |     | <span class='neutral'>        assembly {</span>
 11136 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11137 |     | <span class='neutral'>                let length := 0</span>
 11138 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11139 |     | <span class='neutral'>                mstore(pos, length)</span>
 11140 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11141 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11142 |     | <span class='neutral'>            }</span>
 11143 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11144 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11145 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11146 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11147 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11148 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11149 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11150 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,bool)`.</span>
 11151 |     | <span class='neutral'>            mstore(0x00, 0x895af8c5)</span>
 11152 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11153 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11154 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11155 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11156 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11157 |     | <span class='neutral'>        }</span>
 11158 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11159 |     | <span class='neutral'>        assembly {</span>
 11160 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11161 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11162 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11163 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11164 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11165 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11166 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11167 |     | <span class='neutral'>        }</span>
 11168 |     | <span class='neutral'>    }</span>
 11169 |     | <span class='neutral'></span>
 11170 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 11171 |     | <span class='neutral'>        bytes32 m0;</span>
 11172 |     | <span class='neutral'>        bytes32 m1;</span>
 11173 |     | <span class='neutral'>        bytes32 m2;</span>
 11174 |     | <span class='neutral'>        bytes32 m3;</span>
 11175 |     | <span class='neutral'>        bytes32 m4;</span>
 11176 |     | <span class='neutral'>        bytes32 m5;</span>
 11177 |     | <span class='neutral'>        bytes32 m6;</span>
 11178 |     | <span class='neutral'>        assembly {</span>
 11179 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11180 |     | <span class='neutral'>                let length := 0</span>
 11181 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11182 |     | <span class='neutral'>                mstore(pos, length)</span>
 11183 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11184 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11185 |     | <span class='neutral'>            }</span>
 11186 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11187 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11188 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11189 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11190 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11191 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11192 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11193 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,uint256)`.</span>
 11194 |     | <span class='neutral'>            mstore(0x00, 0x8e3f78a9)</span>
 11195 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11196 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11197 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11198 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11199 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11200 |     | <span class='neutral'>        }</span>
 11201 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11202 |     | <span class='neutral'>        assembly {</span>
 11203 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11204 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11205 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11206 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11207 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11208 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11209 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11210 |     | <span class='neutral'>        }</span>
 11211 |     | <span class='neutral'>    }</span>
 11212 |     | <span class='neutral'></span>
 11213 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
 11214 |     | <span class='neutral'>        bytes32 m0;</span>
 11215 |     | <span class='neutral'>        bytes32 m1;</span>
 11216 |     | <span class='neutral'>        bytes32 m2;</span>
 11217 |     | <span class='neutral'>        bytes32 m3;</span>
 11218 |     | <span class='neutral'>        bytes32 m4;</span>
 11219 |     | <span class='neutral'>        bytes32 m5;</span>
 11220 |     | <span class='neutral'>        bytes32 m6;</span>
 11221 |     | <span class='neutral'>        bytes32 m7;</span>
 11222 |     | <span class='neutral'>        bytes32 m8;</span>
 11223 |     | <span class='neutral'>        assembly {</span>
 11224 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11225 |     | <span class='neutral'>                let length := 0</span>
 11226 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11227 |     | <span class='neutral'>                mstore(pos, length)</span>
 11228 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11229 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11230 |     | <span class='neutral'>            }</span>
 11231 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11232 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11233 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11234 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11235 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11236 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11237 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11238 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11239 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11240 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,string)`.</span>
 11241 |     | <span class='neutral'>            mstore(0x00, 0x9d22d5dd)</span>
 11242 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11243 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11244 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11245 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11246 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11247 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11248 |     | <span class='neutral'>        }</span>
 11249 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11250 |     | <span class='neutral'>        assembly {</span>
 11251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11258 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11259 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11260 |     | <span class='neutral'>        }</span>
 11261 |     | <span class='neutral'>    }</span>
 11262 |     | <span class='neutral'></span>
 11263 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {</span>
 11264 |     | <span class='neutral'>        bytes32 m0;</span>
 11265 |     | <span class='neutral'>        bytes32 m1;</span>
 11266 |     | <span class='neutral'>        bytes32 m2;</span>
 11267 |     | <span class='neutral'>        bytes32 m3;</span>
 11268 |     | <span class='neutral'>        bytes32 m4;</span>
 11269 |     | <span class='neutral'>        bytes32 m5;</span>
 11270 |     | <span class='neutral'>        bytes32 m6;</span>
 11271 |     | <span class='neutral'>        assembly {</span>
 11272 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11273 |     | <span class='neutral'>                let length := 0</span>
 11274 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11275 |     | <span class='neutral'>                mstore(pos, length)</span>
 11276 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11277 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11278 |     | <span class='neutral'>            }</span>
 11279 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11280 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11281 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11282 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11283 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11284 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11285 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11286 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,address)`.</span>
 11287 |     | <span class='neutral'>            mstore(0x00, 0x935e09bf)</span>
 11288 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11289 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11290 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11291 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11292 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11293 |     | <span class='neutral'>        }</span>
 11294 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11295 |     | <span class='neutral'>        assembly {</span>
 11296 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11297 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11298 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11299 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11300 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11301 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11302 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11303 |     | <span class='neutral'>        }</span>
 11304 |     | <span class='neutral'>    }</span>
 11305 |     | <span class='neutral'></span>
 11306 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 11307 |     | <span class='neutral'>        bytes32 m0;</span>
 11308 |     | <span class='neutral'>        bytes32 m1;</span>
 11309 |     | <span class='neutral'>        bytes32 m2;</span>
 11310 |     | <span class='neutral'>        bytes32 m3;</span>
 11311 |     | <span class='neutral'>        bytes32 m4;</span>
 11312 |     | <span class='neutral'>        bytes32 m5;</span>
 11313 |     | <span class='neutral'>        bytes32 m6;</span>
 11314 |     | <span class='neutral'>        assembly {</span>
 11315 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11316 |     | <span class='neutral'>                let length := 0</span>
 11317 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11318 |     | <span class='neutral'>                mstore(pos, length)</span>
 11319 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11320 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11321 |     | <span class='neutral'>            }</span>
 11322 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11323 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11324 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11325 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11326 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11327 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11328 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11329 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,bool)`.</span>
 11330 |     | <span class='neutral'>            mstore(0x00, 0x8af7cf8a)</span>
 11331 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11332 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11333 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11334 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11335 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11336 |     | <span class='neutral'>        }</span>
 11337 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11338 |     | <span class='neutral'>        assembly {</span>
 11339 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11340 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11341 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11342 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11343 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11344 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11345 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11346 |     | <span class='neutral'>        }</span>
 11347 |     | <span class='neutral'>    }</span>
 11348 |     | <span class='neutral'></span>
 11349 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 11350 |     | <span class='neutral'>        bytes32 m0;</span>
 11351 |     | <span class='neutral'>        bytes32 m1;</span>
 11352 |     | <span class='neutral'>        bytes32 m2;</span>
 11353 |     | <span class='neutral'>        bytes32 m3;</span>
 11354 |     | <span class='neutral'>        bytes32 m4;</span>
 11355 |     | <span class='neutral'>        bytes32 m5;</span>
 11356 |     | <span class='neutral'>        bytes32 m6;</span>
 11357 |     | <span class='neutral'>        assembly {</span>
 11358 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11359 |     | <span class='neutral'>                let length := 0</span>
 11360 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11361 |     | <span class='neutral'>                mstore(pos, length)</span>
 11362 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11363 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11364 |     | <span class='neutral'>            }</span>
 11365 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11366 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11367 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11368 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11369 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11370 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11371 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11372 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,uint256)`.</span>
 11373 |     | <span class='neutral'>            mstore(0x00, 0x64b5bb67)</span>
 11374 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11375 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11376 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11377 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11378 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11379 |     | <span class='neutral'>        }</span>
 11380 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11381 |     | <span class='neutral'>        assembly {</span>
 11382 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11383 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11384 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11385 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11386 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11387 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11388 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11389 |     | <span class='neutral'>        }</span>
 11390 |     | <span class='neutral'>    }</span>
 11391 |     | <span class='neutral'></span>
 11392 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
 11393 |     | <span class='neutral'>        bytes32 m0;</span>
 11394 |     | <span class='neutral'>        bytes32 m1;</span>
 11395 |     | <span class='neutral'>        bytes32 m2;</span>
 11396 |     | <span class='neutral'>        bytes32 m3;</span>
 11397 |     | <span class='neutral'>        bytes32 m4;</span>
 11398 |     | <span class='neutral'>        bytes32 m5;</span>
 11399 |     | <span class='neutral'>        bytes32 m6;</span>
 11400 |     | <span class='neutral'>        bytes32 m7;</span>
 11401 |     | <span class='neutral'>        bytes32 m8;</span>
 11402 |     | <span class='neutral'>        assembly {</span>
 11403 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11404 |     | <span class='neutral'>                let length := 0</span>
 11405 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11406 |     | <span class='neutral'>                mstore(pos, length)</span>
 11407 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11408 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11409 |     | <span class='neutral'>            }</span>
 11410 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11411 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11412 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11413 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11414 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11415 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11416 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11417 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11418 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11419 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,string)`.</span>
 11420 |     | <span class='neutral'>            mstore(0x00, 0x742d6ee7)</span>
 11421 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11422 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11423 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11424 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11425 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11426 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11427 |     | <span class='neutral'>        }</span>
 11428 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11429 |     | <span class='neutral'>        assembly {</span>
 11430 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11431 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11432 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11433 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11434 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11435 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11436 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11437 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11438 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11439 |     | <span class='neutral'>        }</span>
 11440 |     | <span class='neutral'>    }</span>
 11441 |     | <span class='neutral'></span>
 11442 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
 11443 |     | <span class='neutral'>        bytes32 m0;</span>
 11444 |     | <span class='neutral'>        bytes32 m1;</span>
 11445 |     | <span class='neutral'>        bytes32 m2;</span>
 11446 |     | <span class='neutral'>        bytes32 m3;</span>
 11447 |     | <span class='neutral'>        bytes32 m4;</span>
 11448 |     | <span class='neutral'>        bytes32 m5;</span>
 11449 |     | <span class='neutral'>        bytes32 m6;</span>
 11450 |     | <span class='neutral'>        bytes32 m7;</span>
 11451 |     | <span class='neutral'>        bytes32 m8;</span>
 11452 |     | <span class='neutral'>        assembly {</span>
 11453 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11454 |     | <span class='neutral'>                let length := 0</span>
 11455 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11456 |     | <span class='neutral'>                mstore(pos, length)</span>
 11457 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11458 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11459 |     | <span class='neutral'>            }</span>
 11460 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11461 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11462 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11463 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11464 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11465 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11466 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11467 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11468 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11469 |     | <span class='neutral'>            // Selector of `log(string,bool,string,address)`.</span>
 11470 |     | <span class='neutral'>            mstore(0x00, 0xe0625b29)</span>
 11471 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11472 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11473 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11474 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11475 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11476 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11477 |     | <span class='neutral'>        }</span>
 11478 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11479 |     | <span class='neutral'>        assembly {</span>
 11480 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11481 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11482 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11483 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11484 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11485 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11486 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11487 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11488 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11489 |     | <span class='neutral'>        }</span>
 11490 |     | <span class='neutral'>    }</span>
 11491 |     | <span class='neutral'></span>
 11492 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
 11493 |     | <span class='neutral'>        bytes32 m0;</span>
 11494 |     | <span class='neutral'>        bytes32 m1;</span>
 11495 |     | <span class='neutral'>        bytes32 m2;</span>
 11496 |     | <span class='neutral'>        bytes32 m3;</span>
 11497 |     | <span class='neutral'>        bytes32 m4;</span>
 11498 |     | <span class='neutral'>        bytes32 m5;</span>
 11499 |     | <span class='neutral'>        bytes32 m6;</span>
 11500 |     | <span class='neutral'>        bytes32 m7;</span>
 11501 |     | <span class='neutral'>        bytes32 m8;</span>
 11502 |     | <span class='neutral'>        assembly {</span>
 11503 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11504 |     | <span class='neutral'>                let length := 0</span>
 11505 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11506 |     | <span class='neutral'>                mstore(pos, length)</span>
 11507 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11508 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11509 |     | <span class='neutral'>            }</span>
 11510 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11511 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11512 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11513 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11514 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11515 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11516 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11517 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11518 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11519 |     | <span class='neutral'>            // Selector of `log(string,bool,string,bool)`.</span>
 11520 |     | <span class='neutral'>            mstore(0x00, 0x3f8a701d)</span>
 11521 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11522 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11523 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11524 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11525 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11526 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11527 |     | <span class='neutral'>        }</span>
 11528 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11529 |     | <span class='neutral'>        assembly {</span>
 11530 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11531 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11532 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11533 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11534 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11535 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11536 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11537 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11538 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11539 |     | <span class='neutral'>        }</span>
 11540 |     | <span class='neutral'>    }</span>
 11541 |     | <span class='neutral'></span>
 11542 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
 11543 |     | <span class='neutral'>        bytes32 m0;</span>
 11544 |     | <span class='neutral'>        bytes32 m1;</span>
 11545 |     | <span class='neutral'>        bytes32 m2;</span>
 11546 |     | <span class='neutral'>        bytes32 m3;</span>
 11547 |     | <span class='neutral'>        bytes32 m4;</span>
 11548 |     | <span class='neutral'>        bytes32 m5;</span>
 11549 |     | <span class='neutral'>        bytes32 m6;</span>
 11550 |     | <span class='neutral'>        bytes32 m7;</span>
 11551 |     | <span class='neutral'>        bytes32 m8;</span>
 11552 |     | <span class='neutral'>        assembly {</span>
 11553 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11554 |     | <span class='neutral'>                let length := 0</span>
 11555 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11556 |     | <span class='neutral'>                mstore(pos, length)</span>
 11557 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11558 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11559 |     | <span class='neutral'>            }</span>
 11560 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11561 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11562 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11563 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11564 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11565 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11566 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11567 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11568 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11569 |     | <span class='neutral'>            // Selector of `log(string,bool,string,uint256)`.</span>
 11570 |     | <span class='neutral'>            mstore(0x00, 0x24f91465)</span>
 11571 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11572 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11573 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11574 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11575 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11576 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11577 |     | <span class='neutral'>        }</span>
 11578 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11579 |     | <span class='neutral'>        assembly {</span>
 11580 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11581 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11582 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11583 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11584 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11585 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11586 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11587 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11588 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11589 |     | <span class='neutral'>        }</span>
 11590 |     | <span class='neutral'>    }</span>
 11591 |     | <span class='neutral'></span>
 11592 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
 11593 |     | <span class='neutral'>        bytes32 m0;</span>
 11594 |     | <span class='neutral'>        bytes32 m1;</span>
 11595 |     | <span class='neutral'>        bytes32 m2;</span>
 11596 |     | <span class='neutral'>        bytes32 m3;</span>
 11597 |     | <span class='neutral'>        bytes32 m4;</span>
 11598 |     | <span class='neutral'>        bytes32 m5;</span>
 11599 |     | <span class='neutral'>        bytes32 m6;</span>
 11600 |     | <span class='neutral'>        bytes32 m7;</span>
 11601 |     | <span class='neutral'>        bytes32 m8;</span>
 11602 |     | <span class='neutral'>        bytes32 m9;</span>
 11603 |     | <span class='neutral'>        bytes32 m10;</span>
 11604 |     | <span class='neutral'>        assembly {</span>
 11605 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11606 |     | <span class='neutral'>                let length := 0</span>
 11607 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11608 |     | <span class='neutral'>                mstore(pos, length)</span>
 11609 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11610 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11611 |     | <span class='neutral'>            }</span>
 11612 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11613 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11614 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11615 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11616 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11617 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11618 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11619 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11620 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11621 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 11622 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 11623 |     | <span class='neutral'>            // Selector of `log(string,bool,string,string)`.</span>
 11624 |     | <span class='neutral'>            mstore(0x00, 0xa826caeb)</span>
 11625 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11626 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11627 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11628 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 11629 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11630 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11631 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 11632 |     | <span class='neutral'>        }</span>
 11633 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 11634 |     | <span class='neutral'>        assembly {</span>
 11635 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11636 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11637 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11638 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11639 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11640 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11641 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11642 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11643 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11644 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 11645 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 11646 |     | <span class='neutral'>        }</span>
 11647 |     | <span class='neutral'>    }</span>
 11648 |     | <span class='neutral'></span>
 11649 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {</span>
 11650 |     | <span class='neutral'>        bytes32 m0;</span>
 11651 |     | <span class='neutral'>        bytes32 m1;</span>
 11652 |     | <span class='neutral'>        bytes32 m2;</span>
 11653 |     | <span class='neutral'>        bytes32 m3;</span>
 11654 |     | <span class='neutral'>        bytes32 m4;</span>
 11655 |     | <span class='neutral'>        bytes32 m5;</span>
 11656 |     | <span class='neutral'>        bytes32 m6;</span>
 11657 |     | <span class='neutral'>        assembly {</span>
 11658 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11659 |     | <span class='neutral'>                let length := 0</span>
 11660 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11661 |     | <span class='neutral'>                mstore(pos, length)</span>
 11662 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11663 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11664 |     | <span class='neutral'>            }</span>
 11665 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11666 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11667 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11668 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11669 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11670 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11671 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11672 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,address)`.</span>
 11673 |     | <span class='neutral'>            mstore(0x00, 0x5ea2b7ae)</span>
 11674 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11675 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11676 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11677 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11678 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11679 |     | <span class='neutral'>        }</span>
 11680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11681 |     | <span class='neutral'>        assembly {</span>
 11682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11689 |     | <span class='neutral'>        }</span>
 11690 |     | <span class='neutral'>    }</span>
 11691 |     | <span class='neutral'></span>
 11692 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {</span>
 11693 |     | <span class='neutral'>        bytes32 m0;</span>
 11694 |     | <span class='neutral'>        bytes32 m1;</span>
 11695 |     | <span class='neutral'>        bytes32 m2;</span>
 11696 |     | <span class='neutral'>        bytes32 m3;</span>
 11697 |     | <span class='neutral'>        bytes32 m4;</span>
 11698 |     | <span class='neutral'>        bytes32 m5;</span>
 11699 |     | <span class='neutral'>        bytes32 m6;</span>
 11700 |     | <span class='neutral'>        assembly {</span>
 11701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11702 |     | <span class='neutral'>                let length := 0</span>
 11703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11704 |     | <span class='neutral'>                mstore(pos, length)</span>
 11705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11707 |     | <span class='neutral'>            }</span>
 11708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11715 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,bool)`.</span>
 11716 |     | <span class='neutral'>            mstore(0x00, 0x82112a42)</span>
 11717 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11719 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11721 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11722 |     | <span class='neutral'>        }</span>
 11723 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11724 |     | <span class='neutral'>        assembly {</span>
 11725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11730 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11731 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11732 |     | <span class='neutral'>        }</span>
 11733 |     | <span class='neutral'>    }</span>
 11734 |     | <span class='neutral'></span>
 11735 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 11736 |     | <span class='neutral'>        bytes32 m0;</span>
 11737 |     | <span class='neutral'>        bytes32 m1;</span>
 11738 |     | <span class='neutral'>        bytes32 m2;</span>
 11739 |     | <span class='neutral'>        bytes32 m3;</span>
 11740 |     | <span class='neutral'>        bytes32 m4;</span>
 11741 |     | <span class='neutral'>        bytes32 m5;</span>
 11742 |     | <span class='neutral'>        bytes32 m6;</span>
 11743 |     | <span class='neutral'>        assembly {</span>
 11744 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11745 |     | <span class='neutral'>                let length := 0</span>
 11746 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11747 |     | <span class='neutral'>                mstore(pos, length)</span>
 11748 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11749 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11750 |     | <span class='neutral'>            }</span>
 11751 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11752 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11753 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11754 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11755 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11756 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11757 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11758 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,uint256)`.</span>
 11759 |     | <span class='neutral'>            mstore(0x00, 0x4f04fdc6)</span>
 11760 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11761 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11762 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11763 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11764 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11765 |     | <span class='neutral'>        }</span>
 11766 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11767 |     | <span class='neutral'>        assembly {</span>
 11768 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11769 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11770 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11771 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11772 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11773 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11774 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11775 |     | <span class='neutral'>        }</span>
 11776 |     | <span class='neutral'>    }</span>
 11777 |     | <span class='neutral'></span>
 11778 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
 11779 |     | <span class='neutral'>        bytes32 m0;</span>
 11780 |     | <span class='neutral'>        bytes32 m1;</span>
 11781 |     | <span class='neutral'>        bytes32 m2;</span>
 11782 |     | <span class='neutral'>        bytes32 m3;</span>
 11783 |     | <span class='neutral'>        bytes32 m4;</span>
 11784 |     | <span class='neutral'>        bytes32 m5;</span>
 11785 |     | <span class='neutral'>        bytes32 m6;</span>
 11786 |     | <span class='neutral'>        bytes32 m7;</span>
 11787 |     | <span class='neutral'>        bytes32 m8;</span>
 11788 |     | <span class='neutral'>        assembly {</span>
 11789 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11790 |     | <span class='neutral'>                let length := 0</span>
 11791 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11792 |     | <span class='neutral'>                mstore(pos, length)</span>
 11793 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11794 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11795 |     | <span class='neutral'>            }</span>
 11796 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11797 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11798 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11799 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11800 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11801 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11802 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11803 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11804 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11805 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,string)`.</span>
 11806 |     | <span class='neutral'>            mstore(0x00, 0x9ffb2f93)</span>
 11807 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11808 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11809 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11810 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11811 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11812 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11813 |     | <span class='neutral'>        }</span>
 11814 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11815 |     | <span class='neutral'>        assembly {</span>
 11816 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11817 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11818 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11819 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11820 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11821 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11822 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11823 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11824 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11825 |     | <span class='neutral'>        }</span>
 11826 |     | <span class='neutral'>    }</span>
 11827 |     | <span class='neutral'></span>
 11828 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {</span>
 11829 |     | <span class='neutral'>        bytes32 m0;</span>
 11830 |     | <span class='neutral'>        bytes32 m1;</span>
 11831 |     | <span class='neutral'>        bytes32 m2;</span>
 11832 |     | <span class='neutral'>        bytes32 m3;</span>
 11833 |     | <span class='neutral'>        bytes32 m4;</span>
 11834 |     | <span class='neutral'>        bytes32 m5;</span>
 11835 |     | <span class='neutral'>        bytes32 m6;</span>
 11836 |     | <span class='neutral'>        assembly {</span>
 11837 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11838 |     | <span class='neutral'>                let length := 0</span>
 11839 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11840 |     | <span class='neutral'>                mstore(pos, length)</span>
 11841 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11842 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11843 |     | <span class='neutral'>            }</span>
 11844 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11845 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11846 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11847 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11848 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11849 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11850 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11851 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,address)`.</span>
 11852 |     | <span class='neutral'>            mstore(0x00, 0xe0e95b98)</span>
 11853 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11854 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11855 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11856 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11857 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11858 |     | <span class='neutral'>        }</span>
 11859 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11860 |     | <span class='neutral'>        assembly {</span>
 11861 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11862 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11863 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11864 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11865 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11866 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11867 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11868 |     | <span class='neutral'>        }</span>
 11869 |     | <span class='neutral'>    }</span>
 11870 |     | <span class='neutral'></span>
 11871 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 11872 |     | <span class='neutral'>        bytes32 m0;</span>
 11873 |     | <span class='neutral'>        bytes32 m1;</span>
 11874 |     | <span class='neutral'>        bytes32 m2;</span>
 11875 |     | <span class='neutral'>        bytes32 m3;</span>
 11876 |     | <span class='neutral'>        bytes32 m4;</span>
 11877 |     | <span class='neutral'>        bytes32 m5;</span>
 11878 |     | <span class='neutral'>        bytes32 m6;</span>
 11879 |     | <span class='neutral'>        assembly {</span>
 11880 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11881 |     | <span class='neutral'>                let length := 0</span>
 11882 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11883 |     | <span class='neutral'>                mstore(pos, length)</span>
 11884 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11885 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11886 |     | <span class='neutral'>            }</span>
 11887 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11888 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11889 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11890 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11891 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11892 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11893 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11894 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,bool)`.</span>
 11895 |     | <span class='neutral'>            mstore(0x00, 0x354c36d6)</span>
 11896 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11897 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11898 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11899 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11900 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11901 |     | <span class='neutral'>        }</span>
 11902 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11903 |     | <span class='neutral'>        assembly {</span>
 11904 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11905 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11906 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11907 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11908 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11909 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11910 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11911 |     | <span class='neutral'>        }</span>
 11912 |     | <span class='neutral'>    }</span>
 11913 |     | <span class='neutral'></span>
 11914 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 11915 |     | <span class='neutral'>        bytes32 m0;</span>
 11916 |     | <span class='neutral'>        bytes32 m1;</span>
 11917 |     | <span class='neutral'>        bytes32 m2;</span>
 11918 |     | <span class='neutral'>        bytes32 m3;</span>
 11919 |     | <span class='neutral'>        bytes32 m4;</span>
 11920 |     | <span class='neutral'>        bytes32 m5;</span>
 11921 |     | <span class='neutral'>        bytes32 m6;</span>
 11922 |     | <span class='neutral'>        assembly {</span>
 11923 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11924 |     | <span class='neutral'>                let length := 0</span>
 11925 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11926 |     | <span class='neutral'>                mstore(pos, length)</span>
 11927 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11928 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11929 |     | <span class='neutral'>            }</span>
 11930 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11931 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11932 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11933 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11934 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11935 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11936 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11937 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,uint256)`.</span>
 11938 |     | <span class='neutral'>            mstore(0x00, 0xe41b6f6f)</span>
 11939 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11940 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11941 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11942 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11943 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11944 |     | <span class='neutral'>        }</span>
 11945 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11946 |     | <span class='neutral'>        assembly {</span>
 11947 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11948 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11949 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11950 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11951 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11952 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11953 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11954 |     | <span class='neutral'>        }</span>
 11955 |     | <span class='neutral'>    }</span>
 11956 |     | <span class='neutral'></span>
 11957 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
 11958 |     | <span class='neutral'>        bytes32 m0;</span>
 11959 |     | <span class='neutral'>        bytes32 m1;</span>
 11960 |     | <span class='neutral'>        bytes32 m2;</span>
 11961 |     | <span class='neutral'>        bytes32 m3;</span>
 11962 |     | <span class='neutral'>        bytes32 m4;</span>
 11963 |     | <span class='neutral'>        bytes32 m5;</span>
 11964 |     | <span class='neutral'>        bytes32 m6;</span>
 11965 |     | <span class='neutral'>        bytes32 m7;</span>
 11966 |     | <span class='neutral'>        bytes32 m8;</span>
 11967 |     | <span class='neutral'>        assembly {</span>
 11968 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11969 |     | <span class='neutral'>                let length := 0</span>
 11970 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11971 |     | <span class='neutral'>                mstore(pos, length)</span>
 11972 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11973 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11974 |     | <span class='neutral'>            }</span>
 11975 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11976 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11977 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11978 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11979 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11980 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11981 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11982 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11983 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11984 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,string)`.</span>
 11985 |     | <span class='neutral'>            mstore(0x00, 0xabf73a98)</span>
 11986 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11987 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11988 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11989 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11990 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11991 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11992 |     | <span class='neutral'>        }</span>
 11993 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11994 |     | <span class='neutral'>        assembly {</span>
 11995 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11996 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11997 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11998 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11999 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12000 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12001 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12002 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12003 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12004 |     | <span class='neutral'>        }</span>
 12005 |     | <span class='neutral'>    }</span>
 12006 |     | <span class='neutral'></span>
 12007 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 12008 |     | <span class='neutral'>        bytes32 m0;</span>
 12009 |     | <span class='neutral'>        bytes32 m1;</span>
 12010 |     | <span class='neutral'>        bytes32 m2;</span>
 12011 |     | <span class='neutral'>        bytes32 m3;</span>
 12012 |     | <span class='neutral'>        bytes32 m4;</span>
 12013 |     | <span class='neutral'>        bytes32 m5;</span>
 12014 |     | <span class='neutral'>        bytes32 m6;</span>
 12015 |     | <span class='neutral'>        assembly {</span>
 12016 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12017 |     | <span class='neutral'>                let length := 0</span>
 12018 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12019 |     | <span class='neutral'>                mstore(pos, length)</span>
 12020 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12021 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12022 |     | <span class='neutral'>            }</span>
 12023 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12024 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12025 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12026 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12027 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12028 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12029 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12030 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,address)`.</span>
 12031 |     | <span class='neutral'>            mstore(0x00, 0xe21de278)</span>
 12032 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12033 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12034 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12035 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12036 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12037 |     | <span class='neutral'>        }</span>
 12038 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12039 |     | <span class='neutral'>        assembly {</span>
 12040 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12041 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12042 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12043 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12044 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12045 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12046 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12047 |     | <span class='neutral'>        }</span>
 12048 |     | <span class='neutral'>    }</span>
 12049 |     | <span class='neutral'></span>
 12050 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 12051 |     | <span class='neutral'>        bytes32 m0;</span>
 12052 |     | <span class='neutral'>        bytes32 m1;</span>
 12053 |     | <span class='neutral'>        bytes32 m2;</span>
 12054 |     | <span class='neutral'>        bytes32 m3;</span>
 12055 |     | <span class='neutral'>        bytes32 m4;</span>
 12056 |     | <span class='neutral'>        bytes32 m5;</span>
 12057 |     | <span class='neutral'>        bytes32 m6;</span>
 12058 |     | <span class='neutral'>        assembly {</span>
 12059 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12060 |     | <span class='neutral'>                let length := 0</span>
 12061 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12062 |     | <span class='neutral'>                mstore(pos, length)</span>
 12063 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12064 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12065 |     | <span class='neutral'>            }</span>
 12066 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12067 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12068 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12069 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12070 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12071 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12072 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12073 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,bool)`.</span>
 12074 |     | <span class='neutral'>            mstore(0x00, 0x7626db92)</span>
 12075 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12076 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12077 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12078 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12079 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12080 |     | <span class='neutral'>        }</span>
 12081 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12082 |     | <span class='neutral'>        assembly {</span>
 12083 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12084 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12085 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12086 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12087 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12088 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12089 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12090 |     | <span class='neutral'>        }</span>
 12091 |     | <span class='neutral'>    }</span>
 12092 |     | <span class='neutral'></span>
 12093 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 12094 |     | <span class='neutral'>        bytes32 m0;</span>
 12095 |     | <span class='neutral'>        bytes32 m1;</span>
 12096 |     | <span class='neutral'>        bytes32 m2;</span>
 12097 |     | <span class='neutral'>        bytes32 m3;</span>
 12098 |     | <span class='neutral'>        bytes32 m4;</span>
 12099 |     | <span class='neutral'>        bytes32 m5;</span>
 12100 |     | <span class='neutral'>        bytes32 m6;</span>
 12101 |     | <span class='neutral'>        assembly {</span>
 12102 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12103 |     | <span class='neutral'>                let length := 0</span>
 12104 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12105 |     | <span class='neutral'>                mstore(pos, length)</span>
 12106 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12107 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12108 |     | <span class='neutral'>            }</span>
 12109 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12110 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12111 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12112 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12113 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12114 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12115 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12116 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,uint256)`.</span>
 12117 |     | <span class='neutral'>            mstore(0x00, 0xa7a87853)</span>
 12118 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12119 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12120 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12121 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12122 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12123 |     | <span class='neutral'>        }</span>
 12124 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12125 |     | <span class='neutral'>        assembly {</span>
 12126 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12127 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12128 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12129 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12130 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12131 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12132 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12133 |     | <span class='neutral'>        }</span>
 12134 |     | <span class='neutral'>    }</span>
 12135 |     | <span class='neutral'></span>
 12136 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
 12137 |     | <span class='neutral'>        bytes32 m0;</span>
 12138 |     | <span class='neutral'>        bytes32 m1;</span>
 12139 |     | <span class='neutral'>        bytes32 m2;</span>
 12140 |     | <span class='neutral'>        bytes32 m3;</span>
 12141 |     | <span class='neutral'>        bytes32 m4;</span>
 12142 |     | <span class='neutral'>        bytes32 m5;</span>
 12143 |     | <span class='neutral'>        bytes32 m6;</span>
 12144 |     | <span class='neutral'>        bytes32 m7;</span>
 12145 |     | <span class='neutral'>        bytes32 m8;</span>
 12146 |     | <span class='neutral'>        assembly {</span>
 12147 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12148 |     | <span class='neutral'>                let length := 0</span>
 12149 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12150 |     | <span class='neutral'>                mstore(pos, length)</span>
 12151 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12152 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12153 |     | <span class='neutral'>            }</span>
 12154 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12155 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12156 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12157 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12158 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12159 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12160 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12161 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12162 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12163 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,string)`.</span>
 12164 |     | <span class='neutral'>            mstore(0x00, 0x854b3496)</span>
 12165 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12166 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12167 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12168 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12169 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12170 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12171 |     | <span class='neutral'>        }</span>
 12172 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12173 |     | <span class='neutral'>        assembly {</span>
 12174 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12175 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12176 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12177 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12178 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12179 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12180 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12181 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12182 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12183 |     | <span class='neutral'>        }</span>
 12184 |     | <span class='neutral'>    }</span>
 12185 |     | <span class='neutral'></span>
 12186 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
 12187 |     | <span class='neutral'>        bytes32 m0;</span>
 12188 |     | <span class='neutral'>        bytes32 m1;</span>
 12189 |     | <span class='neutral'>        bytes32 m2;</span>
 12190 |     | <span class='neutral'>        bytes32 m3;</span>
 12191 |     | <span class='neutral'>        bytes32 m4;</span>
 12192 |     | <span class='neutral'>        bytes32 m5;</span>
 12193 |     | <span class='neutral'>        bytes32 m6;</span>
 12194 |     | <span class='neutral'>        bytes32 m7;</span>
 12195 |     | <span class='neutral'>        bytes32 m8;</span>
 12196 |     | <span class='neutral'>        assembly {</span>
 12197 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12198 |     | <span class='neutral'>                let length := 0</span>
 12199 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12200 |     | <span class='neutral'>                mstore(pos, length)</span>
 12201 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12202 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12203 |     | <span class='neutral'>            }</span>
 12204 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12205 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12206 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12207 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12208 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12209 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12210 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12211 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12212 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12213 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,address)`.</span>
 12214 |     | <span class='neutral'>            mstore(0x00, 0x7c4632a4)</span>
 12215 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12216 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12217 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12218 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12219 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12220 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12221 |     | <span class='neutral'>        }</span>
 12222 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12223 |     | <span class='neutral'>        assembly {</span>
 12224 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12225 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12226 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12227 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12228 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12229 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12230 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12231 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12232 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12233 |     | <span class='neutral'>        }</span>
 12234 |     | <span class='neutral'>    }</span>
 12235 |     | <span class='neutral'></span>
 12236 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
 12237 |     | <span class='neutral'>        bytes32 m0;</span>
 12238 |     | <span class='neutral'>        bytes32 m1;</span>
 12239 |     | <span class='neutral'>        bytes32 m2;</span>
 12240 |     | <span class='neutral'>        bytes32 m3;</span>
 12241 |     | <span class='neutral'>        bytes32 m4;</span>
 12242 |     | <span class='neutral'>        bytes32 m5;</span>
 12243 |     | <span class='neutral'>        bytes32 m6;</span>
 12244 |     | <span class='neutral'>        bytes32 m7;</span>
 12245 |     | <span class='neutral'>        bytes32 m8;</span>
 12246 |     | <span class='neutral'>        assembly {</span>
 12247 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12248 |     | <span class='neutral'>                let length := 0</span>
 12249 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12250 |     | <span class='neutral'>                mstore(pos, length)</span>
 12251 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12252 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12253 |     | <span class='neutral'>            }</span>
 12254 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12255 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12256 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12257 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12258 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12259 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12260 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12261 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12262 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12263 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,bool)`.</span>
 12264 |     | <span class='neutral'>            mstore(0x00, 0x7d24491d)</span>
 12265 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12266 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12267 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12268 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12269 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12270 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12271 |     | <span class='neutral'>        }</span>
 12272 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12273 |     | <span class='neutral'>        assembly {</span>
 12274 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12275 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12276 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12277 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12278 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12279 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12280 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12281 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12282 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12283 |     | <span class='neutral'>        }</span>
 12284 |     | <span class='neutral'>    }</span>
 12285 |     | <span class='neutral'></span>
 12286 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
 12287 |     | <span class='neutral'>        bytes32 m0;</span>
 12288 |     | <span class='neutral'>        bytes32 m1;</span>
 12289 |     | <span class='neutral'>        bytes32 m2;</span>
 12290 |     | <span class='neutral'>        bytes32 m3;</span>
 12291 |     | <span class='neutral'>        bytes32 m4;</span>
 12292 |     | <span class='neutral'>        bytes32 m5;</span>
 12293 |     | <span class='neutral'>        bytes32 m6;</span>
 12294 |     | <span class='neutral'>        bytes32 m7;</span>
 12295 |     | <span class='neutral'>        bytes32 m8;</span>
 12296 |     | <span class='neutral'>        assembly {</span>
 12297 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12298 |     | <span class='neutral'>                let length := 0</span>
 12299 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12300 |     | <span class='neutral'>                mstore(pos, length)</span>
 12301 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12302 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12303 |     | <span class='neutral'>            }</span>
 12304 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12305 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12306 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12307 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12308 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12309 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12310 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12311 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12312 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12313 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,uint256)`.</span>
 12314 |     | <span class='neutral'>            mstore(0x00, 0xc67ea9d1)</span>
 12315 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12316 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12317 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12318 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12319 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12320 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12321 |     | <span class='neutral'>        }</span>
 12322 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12323 |     | <span class='neutral'>        assembly {</span>
 12324 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12325 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12326 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12327 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12328 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12329 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12330 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12331 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12332 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12333 |     | <span class='neutral'>        }</span>
 12334 |     | <span class='neutral'>    }</span>
 12335 |     | <span class='neutral'></span>
 12336 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 12337 |     | <span class='neutral'>        bytes32 m0;</span>
 12338 |     | <span class='neutral'>        bytes32 m1;</span>
 12339 |     | <span class='neutral'>        bytes32 m2;</span>
 12340 |     | <span class='neutral'>        bytes32 m3;</span>
 12341 |     | <span class='neutral'>        bytes32 m4;</span>
 12342 |     | <span class='neutral'>        bytes32 m5;</span>
 12343 |     | <span class='neutral'>        bytes32 m6;</span>
 12344 |     | <span class='neutral'>        bytes32 m7;</span>
 12345 |     | <span class='neutral'>        bytes32 m8;</span>
 12346 |     | <span class='neutral'>        bytes32 m9;</span>
 12347 |     | <span class='neutral'>        bytes32 m10;</span>
 12348 |     | <span class='neutral'>        assembly {</span>
 12349 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12350 |     | <span class='neutral'>                let length := 0</span>
 12351 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12352 |     | <span class='neutral'>                mstore(pos, length)</span>
 12353 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12354 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12355 |     | <span class='neutral'>            }</span>
 12356 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12357 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12358 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12359 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12360 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12361 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12362 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12363 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12364 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12365 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12366 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12367 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,string)`.</span>
 12368 |     | <span class='neutral'>            mstore(0x00, 0x5ab84e1f)</span>
 12369 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12370 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12371 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12372 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12373 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12374 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12375 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12376 |     | <span class='neutral'>        }</span>
 12377 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12378 |     | <span class='neutral'>        assembly {</span>
 12379 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12380 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12381 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12382 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12383 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12384 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12385 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12386 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12387 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12388 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12389 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12390 |     | <span class='neutral'>        }</span>
 12391 |     | <span class='neutral'>    }</span>
 12392 |     | <span class='neutral'></span>
 12393 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {</span>
 12394 |     | <span class='neutral'>        bytes32 m0;</span>
 12395 |     | <span class='neutral'>        bytes32 m1;</span>
 12396 |     | <span class='neutral'>        bytes32 m2;</span>
 12397 |     | <span class='neutral'>        bytes32 m3;</span>
 12398 |     | <span class='neutral'>        bytes32 m4;</span>
 12399 |     | <span class='neutral'>        bytes32 m5;</span>
 12400 |     | <span class='neutral'>        bytes32 m6;</span>
 12401 |     | <span class='neutral'>        bytes32 m7;</span>
 12402 |     | <span class='neutral'>        bytes32 m8;</span>
 12403 |     | <span class='neutral'>        assembly {</span>
 12404 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12405 |     | <span class='neutral'>                let length := 0</span>
 12406 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12407 |     | <span class='neutral'>                mstore(pos, length)</span>
 12408 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12409 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12410 |     | <span class='neutral'>            }</span>
 12411 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12412 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12413 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12414 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12415 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12416 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12417 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12418 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12419 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12420 |     | <span class='neutral'>            // Selector of `log(string,string,address,address)`.</span>
 12421 |     | <span class='neutral'>            mstore(0x00, 0x439c7bef)</span>
 12422 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12423 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12424 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12425 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12426 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12427 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12428 |     | <span class='neutral'>        }</span>
 12429 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12430 |     | <span class='neutral'>        assembly {</span>
 12431 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12432 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12433 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12434 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12435 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12436 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12437 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12438 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12439 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12440 |     | <span class='neutral'>        }</span>
 12441 |     | <span class='neutral'>    }</span>
 12442 |     | <span class='neutral'></span>
 12443 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
 12444 |     | <span class='neutral'>        bytes32 m0;</span>
 12445 |     | <span class='neutral'>        bytes32 m1;</span>
 12446 |     | <span class='neutral'>        bytes32 m2;</span>
 12447 |     | <span class='neutral'>        bytes32 m3;</span>
 12448 |     | <span class='neutral'>        bytes32 m4;</span>
 12449 |     | <span class='neutral'>        bytes32 m5;</span>
 12450 |     | <span class='neutral'>        bytes32 m6;</span>
 12451 |     | <span class='neutral'>        bytes32 m7;</span>
 12452 |     | <span class='neutral'>        bytes32 m8;</span>
 12453 |     | <span class='neutral'>        assembly {</span>
 12454 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12455 |     | <span class='neutral'>                let length := 0</span>
 12456 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12457 |     | <span class='neutral'>                mstore(pos, length)</span>
 12458 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12459 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12460 |     | <span class='neutral'>            }</span>
 12461 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12462 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12463 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12464 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12465 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12466 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12467 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12468 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12469 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12470 |     | <span class='neutral'>            // Selector of `log(string,string,address,bool)`.</span>
 12471 |     | <span class='neutral'>            mstore(0x00, 0x5ccd4e37)</span>
 12472 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12473 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12474 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12475 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12476 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12477 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12478 |     | <span class='neutral'>        }</span>
 12479 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12480 |     | <span class='neutral'>        assembly {</span>
 12481 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12482 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12483 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12484 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12485 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12486 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12487 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12488 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12489 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12490 |     | <span class='neutral'>        }</span>
 12491 |     | <span class='neutral'>    }</span>
 12492 |     | <span class='neutral'></span>
 12493 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
 12494 |     | <span class='neutral'>        bytes32 m0;</span>
 12495 |     | <span class='neutral'>        bytes32 m1;</span>
 12496 |     | <span class='neutral'>        bytes32 m2;</span>
 12497 |     | <span class='neutral'>        bytes32 m3;</span>
 12498 |     | <span class='neutral'>        bytes32 m4;</span>
 12499 |     | <span class='neutral'>        bytes32 m5;</span>
 12500 |     | <span class='neutral'>        bytes32 m6;</span>
 12501 |     | <span class='neutral'>        bytes32 m7;</span>
 12502 |     | <span class='neutral'>        bytes32 m8;</span>
 12503 |     | <span class='neutral'>        assembly {</span>
 12504 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12505 |     | <span class='neutral'>                let length := 0</span>
 12506 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12507 |     | <span class='neutral'>                mstore(pos, length)</span>
 12508 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12509 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12510 |     | <span class='neutral'>            }</span>
 12511 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12512 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12513 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12514 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12515 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12516 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12517 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12518 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12519 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12520 |     | <span class='neutral'>            // Selector of `log(string,string,address,uint256)`.</span>
 12521 |     | <span class='neutral'>            mstore(0x00, 0x7cc3c607)</span>
 12522 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12523 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12524 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12525 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12526 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12527 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12528 |     | <span class='neutral'>        }</span>
 12529 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12530 |     | <span class='neutral'>        assembly {</span>
 12531 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12532 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12533 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12534 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12535 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12536 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12537 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12538 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12539 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12540 |     | <span class='neutral'>        }</span>
 12541 |     | <span class='neutral'>    }</span>
 12542 |     | <span class='neutral'></span>
 12543 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
 12544 |     | <span class='neutral'>        bytes32 m0;</span>
 12545 |     | <span class='neutral'>        bytes32 m1;</span>
 12546 |     | <span class='neutral'>        bytes32 m2;</span>
 12547 |     | <span class='neutral'>        bytes32 m3;</span>
 12548 |     | <span class='neutral'>        bytes32 m4;</span>
 12549 |     | <span class='neutral'>        bytes32 m5;</span>
 12550 |     | <span class='neutral'>        bytes32 m6;</span>
 12551 |     | <span class='neutral'>        bytes32 m7;</span>
 12552 |     | <span class='neutral'>        bytes32 m8;</span>
 12553 |     | <span class='neutral'>        bytes32 m9;</span>
 12554 |     | <span class='neutral'>        bytes32 m10;</span>
 12555 |     | <span class='neutral'>        assembly {</span>
 12556 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12557 |     | <span class='neutral'>                let length := 0</span>
 12558 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12559 |     | <span class='neutral'>                mstore(pos, length)</span>
 12560 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12561 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12562 |     | <span class='neutral'>            }</span>
 12563 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12564 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12565 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12566 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12567 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12568 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12569 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12570 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12571 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12572 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12573 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12574 |     | <span class='neutral'>            // Selector of `log(string,string,address,string)`.</span>
 12575 |     | <span class='neutral'>            mstore(0x00, 0xeb1bff80)</span>
 12576 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12577 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12578 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12579 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12580 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12581 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12582 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12583 |     | <span class='neutral'>        }</span>
 12584 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12585 |     | <span class='neutral'>        assembly {</span>
 12586 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12587 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12588 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12589 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12590 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12591 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12592 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12593 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12594 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12595 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12596 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12597 |     | <span class='neutral'>        }</span>
 12598 |     | <span class='neutral'>    }</span>
 12599 |     | <span class='neutral'></span>
 12600 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
 12601 |     | <span class='neutral'>        bytes32 m0;</span>
 12602 |     | <span class='neutral'>        bytes32 m1;</span>
 12603 |     | <span class='neutral'>        bytes32 m2;</span>
 12604 |     | <span class='neutral'>        bytes32 m3;</span>
 12605 |     | <span class='neutral'>        bytes32 m4;</span>
 12606 |     | <span class='neutral'>        bytes32 m5;</span>
 12607 |     | <span class='neutral'>        bytes32 m6;</span>
 12608 |     | <span class='neutral'>        bytes32 m7;</span>
 12609 |     | <span class='neutral'>        bytes32 m8;</span>
 12610 |     | <span class='neutral'>        assembly {</span>
 12611 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12612 |     | <span class='neutral'>                let length := 0</span>
 12613 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12614 |     | <span class='neutral'>                mstore(pos, length)</span>
 12615 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12616 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12617 |     | <span class='neutral'>            }</span>
 12618 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12619 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12620 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12621 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12622 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12623 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12624 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12625 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12626 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12627 |     | <span class='neutral'>            // Selector of `log(string,string,bool,address)`.</span>
 12628 |     | <span class='neutral'>            mstore(0x00, 0xc371c7db)</span>
 12629 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12630 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12631 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12632 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12633 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12634 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12635 |     | <span class='neutral'>        }</span>
 12636 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12637 |     | <span class='neutral'>        assembly {</span>
 12638 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12639 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12640 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12641 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12642 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12643 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12644 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12645 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12646 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12647 |     | <span class='neutral'>        }</span>
 12648 |     | <span class='neutral'>    }</span>
 12649 |     | <span class='neutral'></span>
 12650 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
 12651 |     | <span class='neutral'>        bytes32 m0;</span>
 12652 |     | <span class='neutral'>        bytes32 m1;</span>
 12653 |     | <span class='neutral'>        bytes32 m2;</span>
 12654 |     | <span class='neutral'>        bytes32 m3;</span>
 12655 |     | <span class='neutral'>        bytes32 m4;</span>
 12656 |     | <span class='neutral'>        bytes32 m5;</span>
 12657 |     | <span class='neutral'>        bytes32 m6;</span>
 12658 |     | <span class='neutral'>        bytes32 m7;</span>
 12659 |     | <span class='neutral'>        bytes32 m8;</span>
 12660 |     | <span class='neutral'>        assembly {</span>
 12661 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12662 |     | <span class='neutral'>                let length := 0</span>
 12663 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12664 |     | <span class='neutral'>                mstore(pos, length)</span>
 12665 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12666 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12667 |     | <span class='neutral'>            }</span>
 12668 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12669 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12670 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12671 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12672 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12673 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12674 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12675 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12676 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12677 |     | <span class='neutral'>            // Selector of `log(string,string,bool,bool)`.</span>
 12678 |     | <span class='neutral'>            mstore(0x00, 0x40785869)</span>
 12679 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12680 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12681 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12682 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12683 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12684 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12685 |     | <span class='neutral'>        }</span>
 12686 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12687 |     | <span class='neutral'>        assembly {</span>
 12688 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12689 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12690 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12691 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12692 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12693 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12694 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12695 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12696 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12697 |     | <span class='neutral'>        }</span>
 12698 |     | <span class='neutral'>    }</span>
 12699 |     | <span class='neutral'></span>
 12700 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
 12701 |     | <span class='neutral'>        bytes32 m0;</span>
 12702 |     | <span class='neutral'>        bytes32 m1;</span>
 12703 |     | <span class='neutral'>        bytes32 m2;</span>
 12704 |     | <span class='neutral'>        bytes32 m3;</span>
 12705 |     | <span class='neutral'>        bytes32 m4;</span>
 12706 |     | <span class='neutral'>        bytes32 m5;</span>
 12707 |     | <span class='neutral'>        bytes32 m6;</span>
 12708 |     | <span class='neutral'>        bytes32 m7;</span>
 12709 |     | <span class='neutral'>        bytes32 m8;</span>
 12710 |     | <span class='neutral'>        assembly {</span>
 12711 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12712 |     | <span class='neutral'>                let length := 0</span>
 12713 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12714 |     | <span class='neutral'>                mstore(pos, length)</span>
 12715 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12716 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12717 |     | <span class='neutral'>            }</span>
 12718 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12719 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12720 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12721 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12722 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12723 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12724 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12725 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12726 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12727 |     | <span class='neutral'>            // Selector of `log(string,string,bool,uint256)`.</span>
 12728 |     | <span class='neutral'>            mstore(0x00, 0xd6aefad2)</span>
 12729 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12730 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12731 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12732 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12733 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12734 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12735 |     | <span class='neutral'>        }</span>
 12736 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12737 |     | <span class='neutral'>        assembly {</span>
 12738 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12739 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12740 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12741 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12742 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12743 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12744 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12745 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12746 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12747 |     | <span class='neutral'>        }</span>
 12748 |     | <span class='neutral'>    }</span>
 12749 |     | <span class='neutral'></span>
 12750 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
 12751 |     | <span class='neutral'>        bytes32 m0;</span>
 12752 |     | <span class='neutral'>        bytes32 m1;</span>
 12753 |     | <span class='neutral'>        bytes32 m2;</span>
 12754 |     | <span class='neutral'>        bytes32 m3;</span>
 12755 |     | <span class='neutral'>        bytes32 m4;</span>
 12756 |     | <span class='neutral'>        bytes32 m5;</span>
 12757 |     | <span class='neutral'>        bytes32 m6;</span>
 12758 |     | <span class='neutral'>        bytes32 m7;</span>
 12759 |     | <span class='neutral'>        bytes32 m8;</span>
 12760 |     | <span class='neutral'>        bytes32 m9;</span>
 12761 |     | <span class='neutral'>        bytes32 m10;</span>
 12762 |     | <span class='neutral'>        assembly {</span>
 12763 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12764 |     | <span class='neutral'>                let length := 0</span>
 12765 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12766 |     | <span class='neutral'>                mstore(pos, length)</span>
 12767 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12768 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12769 |     | <span class='neutral'>            }</span>
 12770 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12771 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12772 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12773 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12774 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12775 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12776 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12777 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12778 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12779 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12780 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12781 |     | <span class='neutral'>            // Selector of `log(string,string,bool,string)`.</span>
 12782 |     | <span class='neutral'>            mstore(0x00, 0x5e84b0ea)</span>
 12783 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12784 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12785 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12786 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12787 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12788 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12789 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12790 |     | <span class='neutral'>        }</span>
 12791 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12792 |     | <span class='neutral'>        assembly {</span>
 12793 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12794 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12795 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12796 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12797 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12798 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12799 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12800 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12801 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12802 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12803 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12804 |     | <span class='neutral'>        }</span>
 12805 |     | <span class='neutral'>    }</span>
 12806 |     | <span class='neutral'></span>
 12807 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
 12808 |     | <span class='neutral'>        bytes32 m0;</span>
 12809 |     | <span class='neutral'>        bytes32 m1;</span>
 12810 |     | <span class='neutral'>        bytes32 m2;</span>
 12811 |     | <span class='neutral'>        bytes32 m3;</span>
 12812 |     | <span class='neutral'>        bytes32 m4;</span>
 12813 |     | <span class='neutral'>        bytes32 m5;</span>
 12814 |     | <span class='neutral'>        bytes32 m6;</span>
 12815 |     | <span class='neutral'>        bytes32 m7;</span>
 12816 |     | <span class='neutral'>        bytes32 m8;</span>
 12817 |     | <span class='neutral'>        assembly {</span>
 12818 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12819 |     | <span class='neutral'>                let length := 0</span>
 12820 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12821 |     | <span class='neutral'>                mstore(pos, length)</span>
 12822 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12823 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12824 |     | <span class='neutral'>            }</span>
 12825 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12826 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12827 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12828 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12829 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12830 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12831 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12832 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12833 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12834 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,address)`.</span>
 12835 |     | <span class='neutral'>            mstore(0x00, 0x1023f7b2)</span>
 12836 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12837 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12838 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12839 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12840 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12841 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12842 |     | <span class='neutral'>        }</span>
 12843 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12844 |     | <span class='neutral'>        assembly {</span>
 12845 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12846 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12847 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12848 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12849 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12850 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12851 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12852 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12853 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12854 |     | <span class='neutral'>        }</span>
 12855 |     | <span class='neutral'>    }</span>
 12856 |     | <span class='neutral'></span>
 12857 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
 12858 |     | <span class='neutral'>        bytes32 m0;</span>
 12859 |     | <span class='neutral'>        bytes32 m1;</span>
 12860 |     | <span class='neutral'>        bytes32 m2;</span>
 12861 |     | <span class='neutral'>        bytes32 m3;</span>
 12862 |     | <span class='neutral'>        bytes32 m4;</span>
 12863 |     | <span class='neutral'>        bytes32 m5;</span>
 12864 |     | <span class='neutral'>        bytes32 m6;</span>
 12865 |     | <span class='neutral'>        bytes32 m7;</span>
 12866 |     | <span class='neutral'>        bytes32 m8;</span>
 12867 |     | <span class='neutral'>        assembly {</span>
 12868 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12869 |     | <span class='neutral'>                let length := 0</span>
 12870 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12871 |     | <span class='neutral'>                mstore(pos, length)</span>
 12872 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12873 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12874 |     | <span class='neutral'>            }</span>
 12875 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12876 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12877 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12878 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12879 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12880 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12881 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12882 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12883 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12884 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,bool)`.</span>
 12885 |     | <span class='neutral'>            mstore(0x00, 0xc3a8a654)</span>
 12886 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12887 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12888 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12889 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12890 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12891 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12892 |     | <span class='neutral'>        }</span>
 12893 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12894 |     | <span class='neutral'>        assembly {</span>
 12895 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12896 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12897 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12898 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12899 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12900 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12901 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12902 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12903 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12904 |     | <span class='neutral'>        }</span>
 12905 |     | <span class='neutral'>    }</span>
 12906 |     | <span class='neutral'></span>
 12907 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
 12908 |     | <span class='neutral'>        bytes32 m0;</span>
 12909 |     | <span class='neutral'>        bytes32 m1;</span>
 12910 |     | <span class='neutral'>        bytes32 m2;</span>
 12911 |     | <span class='neutral'>        bytes32 m3;</span>
 12912 |     | <span class='neutral'>        bytes32 m4;</span>
 12913 |     | <span class='neutral'>        bytes32 m5;</span>
 12914 |     | <span class='neutral'>        bytes32 m6;</span>
 12915 |     | <span class='neutral'>        bytes32 m7;</span>
 12916 |     | <span class='neutral'>        bytes32 m8;</span>
 12917 |     | <span class='neutral'>        assembly {</span>
 12918 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12919 |     | <span class='neutral'>                let length := 0</span>
 12920 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12921 |     | <span class='neutral'>                mstore(pos, length)</span>
 12922 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12923 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12924 |     | <span class='neutral'>            }</span>
 12925 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12926 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12927 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12928 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12929 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12930 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12931 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12932 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12933 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12934 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,uint256)`.</span>
 12935 |     | <span class='neutral'>            mstore(0x00, 0xf45d7d2c)</span>
 12936 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12937 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12938 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12939 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12940 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12941 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12942 |     | <span class='neutral'>        }</span>
 12943 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12944 |     | <span class='neutral'>        assembly {</span>
 12945 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12946 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12947 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12948 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12949 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12950 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12951 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12952 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12953 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12954 |     | <span class='neutral'>        }</span>
 12955 |     | <span class='neutral'>    }</span>
 12956 |     | <span class='neutral'></span>
 12957 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
 12958 |     | <span class='neutral'>        bytes32 m0;</span>
 12959 |     | <span class='neutral'>        bytes32 m1;</span>
 12960 |     | <span class='neutral'>        bytes32 m2;</span>
 12961 |     | <span class='neutral'>        bytes32 m3;</span>
 12962 |     | <span class='neutral'>        bytes32 m4;</span>
 12963 |     | <span class='neutral'>        bytes32 m5;</span>
 12964 |     | <span class='neutral'>        bytes32 m6;</span>
 12965 |     | <span class='neutral'>        bytes32 m7;</span>
 12966 |     | <span class='neutral'>        bytes32 m8;</span>
 12967 |     | <span class='neutral'>        bytes32 m9;</span>
 12968 |     | <span class='neutral'>        bytes32 m10;</span>
 12969 |     | <span class='neutral'>        assembly {</span>
 12970 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12971 |     | <span class='neutral'>                let length := 0</span>
 12972 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12973 |     | <span class='neutral'>                mstore(pos, length)</span>
 12974 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12975 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12976 |     | <span class='neutral'>            }</span>
 12977 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12978 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12979 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12980 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12981 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12982 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12983 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12984 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12985 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12986 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12987 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12988 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,string)`.</span>
 12989 |     | <span class='neutral'>            mstore(0x00, 0x5d1a971a)</span>
 12990 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12991 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12992 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12993 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12994 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12995 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12996 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12997 |     | <span class='neutral'>        }</span>
 12998 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12999 |     | <span class='neutral'>        assembly {</span>
 13000 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13001 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13002 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13003 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13004 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13005 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13006 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13007 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13008 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13009 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13010 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13011 |     | <span class='neutral'>        }</span>
 13012 |     | <span class='neutral'>    }</span>
 13013 |     | <span class='neutral'></span>
 13014 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
 13015 |     | <span class='neutral'>        bytes32 m0;</span>
 13016 |     | <span class='neutral'>        bytes32 m1;</span>
 13017 |     | <span class='neutral'>        bytes32 m2;</span>
 13018 |     | <span class='neutral'>        bytes32 m3;</span>
 13019 |     | <span class='neutral'>        bytes32 m4;</span>
 13020 |     | <span class='neutral'>        bytes32 m5;</span>
 13021 |     | <span class='neutral'>        bytes32 m6;</span>
 13022 |     | <span class='neutral'>        bytes32 m7;</span>
 13023 |     | <span class='neutral'>        bytes32 m8;</span>
 13024 |     | <span class='neutral'>        bytes32 m9;</span>
 13025 |     | <span class='neutral'>        bytes32 m10;</span>
 13026 |     | <span class='neutral'>        assembly {</span>
 13027 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13028 |     | <span class='neutral'>                let length := 0</span>
 13029 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13030 |     | <span class='neutral'>                mstore(pos, length)</span>
 13031 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13032 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13033 |     | <span class='neutral'>            }</span>
 13034 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13035 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13036 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13037 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13038 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13039 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13040 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13041 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13042 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13043 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13044 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13045 |     | <span class='neutral'>            // Selector of `log(string,string,string,address)`.</span>
 13046 |     | <span class='neutral'>            mstore(0x00, 0x6d572f44)</span>
 13047 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13048 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13049 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13050 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13051 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13052 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13053 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13054 |     | <span class='neutral'>        }</span>
 13055 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13056 |     | <span class='neutral'>        assembly {</span>
 13057 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13058 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13059 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13060 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13061 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13062 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13063 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13064 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13065 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13066 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13067 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13068 |     | <span class='neutral'>        }</span>
 13069 |     | <span class='neutral'>    }</span>
 13070 |     | <span class='neutral'></span>
 13071 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 13072 |     | <span class='neutral'>        bytes32 m0;</span>
 13073 |     | <span class='neutral'>        bytes32 m1;</span>
 13074 |     | <span class='neutral'>        bytes32 m2;</span>
 13075 |     | <span class='neutral'>        bytes32 m3;</span>
 13076 |     | <span class='neutral'>        bytes32 m4;</span>
 13077 |     | <span class='neutral'>        bytes32 m5;</span>
 13078 |     | <span class='neutral'>        bytes32 m6;</span>
 13079 |     | <span class='neutral'>        bytes32 m7;</span>
 13080 |     | <span class='neutral'>        bytes32 m8;</span>
 13081 |     | <span class='neutral'>        bytes32 m9;</span>
 13082 |     | <span class='neutral'>        bytes32 m10;</span>
 13083 |     | <span class='neutral'>        assembly {</span>
 13084 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13085 |     | <span class='neutral'>                let length := 0</span>
 13086 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13087 |     | <span class='neutral'>                mstore(pos, length)</span>
 13088 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13089 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13090 |     | <span class='neutral'>            }</span>
 13091 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13092 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13093 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13094 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13095 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13096 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13097 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13098 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13099 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13100 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13101 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13102 |     | <span class='neutral'>            // Selector of `log(string,string,string,bool)`.</span>
 13103 |     | <span class='neutral'>            mstore(0x00, 0x2c1754ed)</span>
 13104 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13105 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13106 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13107 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13108 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13109 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13110 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13111 |     | <span class='neutral'>        }</span>
 13112 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13113 |     | <span class='neutral'>        assembly {</span>
 13114 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13115 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13116 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13117 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13118 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13119 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13120 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13121 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13122 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13123 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13124 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13125 |     | <span class='neutral'>        }</span>
 13126 |     | <span class='neutral'>    }</span>
 13127 |     | <span class='neutral'></span>
 13128 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 13129 |     | <span class='neutral'>        bytes32 m0;</span>
 13130 |     | <span class='neutral'>        bytes32 m1;</span>
 13131 |     | <span class='neutral'>        bytes32 m2;</span>
 13132 |     | <span class='neutral'>        bytes32 m3;</span>
 13133 |     | <span class='neutral'>        bytes32 m4;</span>
 13134 |     | <span class='neutral'>        bytes32 m5;</span>
 13135 |     | <span class='neutral'>        bytes32 m6;</span>
 13136 |     | <span class='neutral'>        bytes32 m7;</span>
 13137 |     | <span class='neutral'>        bytes32 m8;</span>
 13138 |     | <span class='neutral'>        bytes32 m9;</span>
 13139 |     | <span class='neutral'>        bytes32 m10;</span>
 13140 |     | <span class='neutral'>        assembly {</span>
 13141 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13142 |     | <span class='neutral'>                let length := 0</span>
 13143 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13144 |     | <span class='neutral'>                mstore(pos, length)</span>
 13145 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13146 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13147 |     | <span class='neutral'>            }</span>
 13148 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13149 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13150 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13151 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13152 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13153 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13154 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13155 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13156 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13157 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13158 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13159 |     | <span class='neutral'>            // Selector of `log(string,string,string,uint256)`.</span>
 13160 |     | <span class='neutral'>            mstore(0x00, 0x8eafb02b)</span>
 13161 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13162 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13163 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13164 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13165 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13166 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13167 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13168 |     | <span class='neutral'>        }</span>
 13169 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13170 |     | <span class='neutral'>        assembly {</span>
 13171 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13172 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13173 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13174 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13175 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13176 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13177 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13178 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13179 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13180 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13181 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13182 |     | <span class='neutral'>        }</span>
 13183 |     | <span class='neutral'>    }</span>
 13184 |     | <span class='neutral'></span>
 13185 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 13186 |     | <span class='neutral'>        bytes32 m0;</span>
 13187 |     | <span class='neutral'>        bytes32 m1;</span>
 13188 |     | <span class='neutral'>        bytes32 m2;</span>
 13189 |     | <span class='neutral'>        bytes32 m3;</span>
 13190 |     | <span class='neutral'>        bytes32 m4;</span>
 13191 |     | <span class='neutral'>        bytes32 m5;</span>
 13192 |     | <span class='neutral'>        bytes32 m6;</span>
 13193 |     | <span class='neutral'>        bytes32 m7;</span>
 13194 |     | <span class='neutral'>        bytes32 m8;</span>
 13195 |     | <span class='neutral'>        bytes32 m9;</span>
 13196 |     | <span class='neutral'>        bytes32 m10;</span>
 13197 |     | <span class='neutral'>        bytes32 m11;</span>
 13198 |     | <span class='neutral'>        bytes32 m12;</span>
 13199 |     | <span class='neutral'>        assembly {</span>
 13200 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13201 |     | <span class='neutral'>                let length := 0</span>
 13202 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13203 |     | <span class='neutral'>                mstore(pos, length)</span>
 13204 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13205 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13206 |     | <span class='neutral'>            }</span>
 13207 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13208 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13209 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13210 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13211 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13212 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13213 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13214 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13215 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13216 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13217 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13218 |     | <span class='neutral'>            m11 := mload(0x160)</span>
 13219 |     | <span class='neutral'>            m12 := mload(0x180)</span>
 13220 |     | <span class='neutral'>            // Selector of `log(string,string,string,string)`.</span>
 13221 |     | <span class='neutral'>            mstore(0x00, 0xde68f20a)</span>
 13222 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13223 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13224 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13225 |     | <span class='neutral'>            mstore(0x80, 0x140)</span>
 13226 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13227 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13228 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13229 |     | <span class='neutral'>            writeString(0x160, p3)</span>
 13230 |     | <span class='neutral'>        }</span>
 13231 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x184);</span>
 13232 |     | <span class='neutral'>        assembly {</span>
 13233 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13234 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13235 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13236 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13237 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13238 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13239 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13240 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13241 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13242 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13243 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13244 |     | <span class='neutral'>            mstore(0x160, m11)</span>
 13245 |     | <span class='neutral'>            mstore(0x180, m12)</span>
 13246 |     | <span class='neutral'>        }</span>
 13247 |     | <span class='neutral'>    }</span>
 13248 |     | <span class='neutral'>}</span>
 13249 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/Constants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library Constants {</span>
  5 |     | <span class='neutral'>    // https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require</span>
  6 |     | <span class='neutral'>    // 0x00: Used for generic compiler inserted panics.</span>
  7 |     | <span class='neutral'>    // 0x01: If you call assert with an argument that evaluates to false.</span>
  8 |     | <span class='neutral'>    // 0x11: If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.</span>
  9 |     | <span class='neutral'>    // 0x12; If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).</span>
 10 |     | <span class='neutral'>    // 0x21: If you convert a value that is too big or negative into an enum type.</span>
 11 |     | <span class='neutral'>    // 0x22: If you access a storage byte array that is incorrectly encoded.</span>
 12 |     | <span class='neutral'>    // 0x31: If you call .pop() on an empty array.</span>
 13 |     | <span class='neutral'>    // 0x32: If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i &gt;= x.length or i &lt; 0).</span>
 14 |     | <span class='neutral'>    // 0x41: If you allocate too much memory or create an array that is too large.</span>
 15 |     | <span class='neutral'>    // 0x51: If you call a zero-initialized variable of internal function type.</span>
 16 |     | <span class='unexecuted'>    uint256 public constant PANIC_GENERAL = 0x00;</span>
 17 |     | <span class='unexecuted'>    uint256 public constant PANIC_ASSERT = 0x01;</span>
 18 |     | <span class='unexecuted'>    uint256 public constant PANIC_ARITHMETIC = 0x11;</span>
 19 |     | <span class='unexecuted'>    uint256 public constant PANIC_DIVISION_BY_ZERO = 0x12;</span>
 20 |     | <span class='unexecuted'>    uint256 public constant PANIC_ENUM_OUT_OF_BOUNDS = 0x21;</span>
 21 |     | <span class='unexecuted'>    uint256 public constant PANIC_STORAGE_BYTES_ARRAY_ENCODING = 0x22;</span>
 22 |     | <span class='unexecuted'>    uint256 public constant PANIC_POP_EMPTY_ARRAY = 0x31;</span>
 23 |     | <span class='unexecuted'>    uint256 public constant PANIC_ARRAY_OUT_OF_BOUNDS = 0x32;</span>
 24 |     | <span class='unexecuted'>    uint256 public constant PANIC_ALLOC_TOO_MUCH_MEMORY = 0x41;</span>
 25 |     | <span class='unexecuted'>    uint256 public constant PANIC_ZERO_INIT_INTERNAL_FUNCTION = 0x51;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    address public constant ADDRESS_CHEATS =</span>
 28 |     | <span class='unexecuted'>        0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/FuzzBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Fuzzlib} from &quot;./Fuzzlib.sol&quot;;</span>
  5 |     | <span class='neutral'>import {PlatformCrytic} from &quot;./platform/PlatformCrytic.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract FuzzBase {</span>
  8 |     | <span class='unexecuted'>    Fuzzlib internal fl = new Fuzzlib();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    constructor() {</span>
 11 |     | <span class='unexecuted'>        fl.setPlatform(address(new PlatformCrytic()));</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/FuzzLibString.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
   7 |     | <span class='neutral'>/// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   8 |     | <span class='unexecuted'>library FuzzLibString {</span>
   9 |     | <span class='neutral'>    bytes16 internal constant HEX_DIGITS = &quot;0123456789abcdef&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 | *   | <span class='executed'>    function toString(int256 value) internal pure returns (string memory str) {</span>
  12 | *   | <span class='executed'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
  13 | *   | <span class='executed'>        str = toString(absValue);</span>
  14 |     | <span class='neutral'></span>
  15 | *   | <span class='executed'>        if (value &lt; 0) {</span>
  16 | *   | <span class='executed'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
  17 |     | <span class='neutral'>        }</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
  21 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  22 |     | <span class='neutral'>        assembly {</span>
  23 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
  24 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
  25 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
  26 | *   | <span class='executed'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
  29 | *   | <span class='executed'>            mstore(0x40, newFreeMemoryPointer)</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
  32 | *   | <span class='executed'>            str := sub(newFreeMemoryPointer, 32)</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
  35 | *   | <span class='executed'>            mstore(str, 0)</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
  38 | *   | <span class='executed'>            let end := str</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
  41 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
  42 |     | <span class='neutral'>            // prettier-ignore</span>
  43 | *   | <span class='executed'>            for { let temp := value } 1 {} {</span>
  44 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
  45 | *   | <span class='executed'>                str := sub(str, 1)</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>                // Write the character to the pointer.</span>
  48 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
  49 | *   | <span class='executed'>                mstore8(str, add(48, mod(temp, 10)))</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
  52 | *   | <span class='executed'>                temp := div(temp, 10)</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>                 // prettier-ignore</span>
  55 | *   | <span class='executed'>                if iszero(temp) { break }</span>
  56 |     | <span class='neutral'>            }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
  59 | *   | <span class='executed'>            let length := sub(end, str)</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
  62 | *   | <span class='executed'>            str := sub(str, 32)</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
  65 | *   | <span class='executed'>            mstore(str, length)</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    function toString(address value) internal pure returns (string memory str) {</span>
  70 |     | <span class='unexecuted'>        bytes memory s = new bytes(40);</span>
  71 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 20; i++) {</span>
  72 |     | <span class='unexecuted'>            bytes1 b = bytes1(</span>
  73 |     | <span class='unexecuted'>                uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))</span>
  74 |     | <span class='neutral'>            );</span>
  75 |     | <span class='unexecuted'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
  76 |     | <span class='unexecuted'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
  77 |     | <span class='unexecuted'>            s[2 * i] = char(hi);</span>
  78 |     | <span class='unexecuted'>            s[2 * i + 1] = char(lo);</span>
  79 |     | <span class='neutral'>        }</span>
  80 | *   | <span class='executed'>        return string(s);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
  84 | *   | <span class='executed'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
  85 |     | <span class='unexecuted'>        else return bytes1(uint8(b) + 0x57);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    // based on OZ&#39;s toHexString</span>
  89 |     | <span class='neutral'>    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol</span>
  90 |     | <span class='unexecuted'>    function toHexString(bytes memory value)</span>
  91 |     | <span class='neutral'>        internal</span>
  92 |     | <span class='neutral'>        pure</span>
  93 |     | <span class='unexecuted'>        returns (string memory)</span>
  94 |     | <span class='neutral'>    {</span>
  95 |     | <span class='unexecuted'>        bytes memory buffer = new bytes(2 * value.length + 2);</span>
  96 |     | <span class='unexecuted'>        buffer[0] = &quot;0&quot;;</span>
  97 |     | <span class='unexecuted'>        buffer[1] = &quot;x&quot;;</span>
  98 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; value.length; i++) {</span>
  99 |     | <span class='unexecuted'>            uint8 valueByte = uint8(value[i]);</span>
 100 |     | <span class='unexecuted'>            buffer[2 * i + 2] = HEX_DIGITS[valueByte &gt;&gt; 4];</span>
 101 |     | <span class='unexecuted'>            buffer[2 * i + 3] = HEX_DIGITS[valueByte &amp; 0xf];</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'>        return string(buffer);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    // https://ethereum.stackexchange.com/a/83577</span>
 107 |     | <span class='unexecuted'>    function getRevertMsg(bytes memory returnData)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        pure</span>
 110 |     | <span class='unexecuted'>        returns (string memory)</span>
 111 |     | <span class='neutral'>    {</span>
 112 |     | <span class='neutral'>        // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code</span>
 113 |     | <span class='unexecuted'>        if (returnData.length == 4 + 32) {</span>
 114 |     | <span class='neutral'>            // Check that the data starts with the Panic signature</span>
 115 |     | <span class='unexecuted'>            bytes4 panicSignature = bytes4(keccak256(bytes(&quot;Panic(uint256)&quot;)));</span>
 116 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; 4; i++) {</span>
 117 |     | <span class='unexecuted'>                if (returnData[i] != panicSignature[i])</span>
 118 |     | <span class='unexecuted'>                    return &quot;Undefined signature&quot;;</span>
 119 |     | <span class='neutral'>            }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>            uint256 panicCode;</span>
 122 |     | <span class='unexecuted'>            for (uint256 i = 4; i &lt; 36; i++) {</span>
 123 |     | <span class='unexecuted'>                panicCode = panicCode &lt;&lt; 8;</span>
 124 |     | <span class='unexecuted'>                panicCode |= uint8(returnData[i]);</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>            // Now convert the panic code into its string representation</span>
 128 |     | <span class='unexecuted'>            if (panicCode == 17) {</span>
 129 |     | <span class='unexecuted'>                return &quot;Panic(17)&quot;;</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>            // Add other panic codes as needed or return a generic &quot;Unknown panic&quot;</span>
 133 |     | <span class='unexecuted'>            return &quot;Undefined panic code&quot;;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // If the returnData length is less than 68, then the transaction failed silently (without a revert message)</span>
 137 |     | <span class='unexecuted'>        if (returnData.length &lt; 68) return &quot;Transaction reverted silently&quot;;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        assembly {</span>
 140 |     | <span class='neutral'>            // Slice the sighash.</span>
 141 |     | <span class='unexecuted'>            returnData := add(returnData, 0x04)</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='unexecuted'>        return abi.decode(returnData, (string)); // All that remains is the revert string</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function isRevertReasonEqual(bytes memory returnData, string memory reason)</span>
 147 |     | <span class='neutral'>        internal</span>
 148 |     | <span class='neutral'>        pure</span>
 149 |     | <span class='unexecuted'>        returns (bool)</span>
 150 |     | <span class='neutral'>    {</span>
 151 |     | <span class='unexecuted'>        return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==</span>
 152 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(reason)));</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'>}</span>
 155 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/Fuzzlib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {HelperBase} from &quot;./helpers/HelperBase.sol&quot;;</span>
  5 |     | <span class='neutral'>import {HelperAssert} from &quot;./helpers/HelperAssert.sol&quot;;</span>
  6 |     | <span class='neutral'>import {HelperClamp} from &quot;./helpers/HelperClamp.sol&quot;;</span>
  7 |     | <span class='neutral'>import {HelperLog} from &quot;./helpers/HelperLog.sol&quot;;</span>
  8 |     | <span class='neutral'>import {HelperMath} from &quot;./helpers/HelperMath.sol&quot;;</span>
  9 |     | <span class='neutral'>import {HelperRandom} from &quot;./helpers/HelperRandom.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>contract Fuzzlib is</span>
 12 |     | <span class='neutral'>    HelperBase,</span>
 13 |     | <span class='neutral'>    HelperAssert,</span>
 14 |     | <span class='neutral'>    HelperClamp,</span>
 15 |     | <span class='neutral'>    HelperLog,</span>
 16 |     | <span class='neutral'>    HelperMath,</span>
 17 |     | <span class='neutral'>    HelperRandom</span>
 18 |     | <span class='neutral'>{}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/IHEVM.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Constants} from &quot;./Constants.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IHevm {</span>
  7 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  8 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    // Set block.number to newNumber</span>
 11 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // Add the condition b to the assumption base for the current branch</span>
 14 |     | <span class='neutral'>    // This function is almost identical to require</span>
 15 |     | <span class='neutral'>    function assume(bool b) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // Sets the eth balance of usr to amt</span>
 18 |     | <span class='neutral'>    function deal(address usr, uint256 amt) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 21 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 24 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (v, r, s)</span>
 27 |     | <span class='neutral'>    function sign(</span>
 28 |     | <span class='neutral'>        uint256 privateKey,</span>
 29 |     | <span class='neutral'>        bytes32 digest</span>
 30 |     | <span class='neutral'>    ) external returns (uint8 v, bytes32 r, bytes32 s);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    // Gets address for a given private key</span>
 33 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address addr);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 36 |     | <span class='neutral'>    function ffi(</span>
 37 |     | <span class='neutral'>        string[] calldata inputs</span>
 38 |     | <span class='neutral'>    ) external returns (bytes memory result);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 41 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 44 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    // Takes a fork identifier created by createFork and sets the corresponding forked state as active</span>
 47 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    // Returns the identifier of the current fork</span>
 50 |     | <span class='neutral'>    function activeFork() external returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    // Labels the address in traces</span>
 53 |     | <span class='neutral'>    function label(address addr, string calldata label) external;</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>IHevm constant vm = IHevm(Constants.ADDRESS_CHEATS);</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperAssert.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./HelperBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../FuzzLibString.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   9 |     | <span class='neutral'>abstract contract HelperAssert is HelperBase {</span>
  10 |     | <span class='neutral'>    event AssertFail(string);</span>
  11 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  12 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  13 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  14 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  15 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  16 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  17 |     | <span class='neutral'></span>
  18 | *   | <span class='executed'>    function t(bool b, string memory reason) public {</span>
  19 | *   | <span class='executed'>        if (!b) {</span>
  20 | *   | <span class='executed'>            emit AssertFail(reason);</span>
  21 | *   | <span class='executed'>            platform.assertFail();</span>
  22 |     | <span class='neutral'>        }</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  26 | *   | <span class='executed'>    function eq(</span>
  27 |     | <span class='neutral'>        uint256 a,</span>
  28 |     | <span class='neutral'>        uint256 b,</span>
  29 |     | <span class='neutral'>        string memory reason</span>
  30 |     | <span class='neutral'>    ) public {</span>
  31 | *   | <span class='executed'>        if (a != b) {</span>
  32 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
  33 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
  34 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  35 |     | <span class='neutral'>            emit AssertEqFail(assertMsg);</span>
  36 |     | <span class='neutral'>            platform.assertFail();</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice int256 version of eq</span>
  41 | *   | <span class='executed'>    function eq(</span>
  42 |     | <span class='neutral'>        int256 a,</span>
  43 |     | <span class='neutral'>        int256 b,</span>
  44 |     | <span class='neutral'>        string memory reason</span>
  45 |     | <span class='neutral'>    ) public {</span>
  46 | *   | <span class='executed'>        if (a != b) {</span>
  47 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
  48 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
  49 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  50 |     | <span class='unexecuted'>           emit AssertEqFail(assertMsg);</span>
  51 |     | <span class='neutral'>            platform.assertFail();</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice bool version of eq</span>
  56 |     | <span class='unexecuted'>    function eq(</span>
  57 |     | <span class='neutral'>        bool a,</span>
  58 |     | <span class='neutral'>        bool b,</span>
  59 |     | <span class='neutral'>        string memory reason</span>
  60 |     | <span class='neutral'>    ) public {</span>
  61 |     | <span class='unexecuted'>        if (a != b) {</span>
  62 |     | <span class='unexecuted'>            string memory aStr = a ? &quot;true&quot; : &quot;false&quot;;</span>
  63 |     | <span class='unexecuted'>            string memory bStr = b ? &quot;true&quot; : &quot;false&quot;;</span>
  64 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  65 |     | <span class='neutral'>            emit AssertEqFail(assertMsg);</span>
  66 |     | <span class='neutral'>            platform.assertFail();</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice address version of eq</span>
  71 |     | <span class='unexecuted'>    function eq(</span>
  72 |     | <span class='neutral'>        address a,</span>
  73 |     | <span class='neutral'>        address b,</span>
  74 |     | <span class='neutral'>        string memory reason</span>
  75 |     | <span class='neutral'>    ) public {</span>
  76 |     | <span class='unexecuted'>        if (a != b) {</span>
  77 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
  78 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
  79 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  80 |     | <span class='neutral'>            emit AssertEqFail(assertMsg);</span>
  81 |     | <span class='neutral'>            platform.assertFail();</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice bytes4 version of eq</span>
  86 |     | <span class='unexecuted'>    function eq(</span>
  87 |     | <span class='neutral'>        bytes4 a,</span>
  88 |     | <span class='neutral'>        bytes4 b,</span>
  89 |     | <span class='neutral'>        string memory reason</span>
  90 |     | <span class='neutral'>    ) public {</span>
  91 |     | <span class='unexecuted'>        if (a != b) {</span>
  92 |     | <span class='unexecuted'>            bytes memory aBytes = abi.encodePacked(a);</span>
  93 |     | <span class='unexecuted'>            bytes memory bBytes = abi.encodePacked(b);</span>
  94 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toHexString(aBytes);</span>
  95 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toHexString(bBytes);</span>
  96 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  97 |     | <span class='unexecuted'>            emit AssertEqFail(assertMsg);</span>
  98 |     | <span class='unexecuted'>            platform.assertFail();</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
 103 |     | <span class='unexecuted'>    function neq(</span>
 104 |     | <span class='neutral'>        uint256 a,</span>
 105 |     | <span class='neutral'>        uint256 b,</span>
 106 |     | <span class='neutral'>        string memory reason</span>
 107 |     | <span class='neutral'>    ) public {</span>
 108 |     | <span class='unexecuted'>        if (a == b) {</span>
 109 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 110 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 111 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;==&quot;, reason);</span>
 112 |     | <span class='unexecuted'>            emit AssertNeqFail(assertMsg);</span>
 113 |     | <span class='neutral'>            platform.assertFail();</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /// @notice int256 version of neq</span>
 118 |     | <span class='unexecuted'>    function neq(</span>
 119 |     | <span class='neutral'>        int256 a,</span>
 120 |     | <span class='neutral'>        int256 b,</span>
 121 |     | <span class='neutral'>        string memory reason</span>
 122 |     | <span class='neutral'>    ) public {</span>
 123 |     | <span class='unexecuted'>        if (a == b) {</span>
 124 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 125 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 126 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;==&quot;, reason);</span>
 127 |     | <span class='neutral'>            emit AssertNeqFail(assertMsg);</span>
 128 |     | <span class='neutral'>            platform.assertFail();</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
 133 | *   | <span class='executed'>    function gte(</span>
 134 |     | <span class='neutral'>        uint256 a,</span>
 135 |     | <span class='neutral'>        uint256 b,</span>
 136 |     | <span class='neutral'>        string memory reason</span>
 137 |     | <span class='neutral'>    ) public {</span>
 138 | *   | <span class='executed'>        if (!(a &gt;= b)) {</span>
 139 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 140 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 141 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;&quot;, reason);</span>
 142 |     | <span class='neutral'>            emit AssertGteFail(assertMsg);</span>
 143 |     | <span class='neutral'>            platform.assertFail();</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /// @notice int256 version of gte</span>
 148 |     | <span class='unexecuted'>    function gte(</span>
 149 |     | <span class='neutral'>        int256 a,</span>
 150 |     | <span class='neutral'>        int256 b,</span>
 151 |     | <span class='neutral'>        string memory reason</span>
 152 |     | <span class='neutral'>    ) public {</span>
 153 |     | <span class='unexecuted'>        if (!(a &gt;= b)) {</span>
 154 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 155 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 156 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;&quot;, reason);</span>
 157 |     | <span class='unexecuted'>            emit AssertGteFail(assertMsg);</span>
 158 |     | <span class='neutral'>            platform.assertFail();</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
 163 | *   | <span class='executed'>    function gt(</span>
 164 |     | <span class='neutral'>        uint256 a,</span>
 165 |     | <span class='neutral'>        uint256 b,</span>
 166 |     | <span class='neutral'>        string memory reason</span>
 167 |     | <span class='neutral'>    ) public {</span>
 168 | *   | <span class='executed'>        if (!(a &gt; b)) {</span>
 169 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 170 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 171 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;=&quot;, reason);</span>
 172 |     | <span class='unexecuted'>            emit AssertGtFail(assertMsg);</span>
 173 |     | <span class='neutral'>            platform.assertFail();</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    /// @notice int256 version of gt</span>
 178 | *   | <span class='executed'>    function gt(</span>
 179 |     | <span class='neutral'>        int256 a,</span>
 180 |     | <span class='neutral'>        int256 b,</span>
 181 |     | <span class='neutral'>        string memory reason</span>
 182 |     | <span class='neutral'>    ) public {</span>
 183 | *   | <span class='executed'>        if (!(a &gt; b)) {</span>
 184 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 185 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 186 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;=&quot;, reason);</span>
 187 |     | <span class='neutral'>            emit AssertGtFail(assertMsg);</span>
 188 |     | <span class='neutral'>            platform.assertFail();</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 193 | *   | <span class='executed'>    function lte(</span>
 194 |     | <span class='neutral'>        uint256 a,</span>
 195 |     | <span class='neutral'>        uint256 b,</span>
 196 |     | <span class='neutral'>        string memory reason</span>
 197 |     | <span class='neutral'>    ) public {</span>
 198 | *   | <span class='executed'>        if (!(a &lt;= b)) {</span>
 199 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 200 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 201 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;&quot;, reason);</span>
 202 |     | <span class='neutral'>            emit AssertLteFail(assertMsg);</span>
 203 |     | <span class='neutral'>            platform.assertFail();</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    /// @notice int256 version of lte</span>
 208 |     | <span class='unexecuted'>    function lte(</span>
 209 |     | <span class='neutral'>        int256 a,</span>
 210 |     | <span class='neutral'>        int256 b,</span>
 211 |     | <span class='neutral'>        string memory reason</span>
 212 |     | <span class='neutral'>    ) public {</span>
 213 |     | <span class='unexecuted'>        if (!(a &lt;= b)) {</span>
 214 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 215 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 216 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;&quot;, reason);</span>
 217 |     | <span class='unexecuted'>            emit AssertLteFail(assertMsg);</span>
 218 |     | <span class='neutral'>            platform.assertFail();</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 223 | *   | <span class='executed'>    function lt(</span>
 224 |     | <span class='neutral'>        uint256 a,</span>
 225 |     | <span class='neutral'>        uint256 b,</span>
 226 |     | <span class='neutral'>        string memory reason</span>
 227 |     | <span class='neutral'>    ) public {</span>
 228 | *   | <span class='executed'>        if (!(a &lt; b)) {</span>
 229 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 230 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 231 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;=&quot;, reason);</span>
 232 |     | <span class='unexecuted'>            emit AssertLtFail(assertMsg);</span>
 233 |     | <span class='unexecuted'>            platform.assertFail();</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /// @notice int256 version of lt</span>
 238 |     | <span class='unexecuted'>    function lt(</span>
 239 |     | <span class='neutral'>        int256 a,</span>
 240 |     | <span class='neutral'>        int256 b,</span>
 241 |     | <span class='neutral'>        string memory reason</span>
 242 |     | <span class='neutral'>    ) public {</span>
 243 |     | <span class='unexecuted'>        if (!(a &lt; b)) {</span>
 244 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 245 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 246 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;=&quot;, reason);</span>
 247 |     | <span class='neutral'>            emit AssertLtFail(assertMsg);</span>
 248 |     | <span class='neutral'>            platform.assertFail();</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>    function assertRevertReasonNotEqual(</span>
 253 |     | <span class='neutral'>        bytes memory returnData,</span>
 254 |     | <span class='neutral'>        string memory reason</span>
 255 |     | <span class='neutral'>    ) public {</span>
 256 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);</span>
 257 |     | <span class='unexecuted'>        t(!isEqual, reason);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 261 |     | <span class='neutral'>        bytes memory returnData,</span>
 262 |     | <span class='neutral'>        string memory reason</span>
 263 |     | <span class='neutral'>    ) public {</span>
 264 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);</span>
 265 |     | <span class='unexecuted'>        t(isEqual, reason);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 269 |     | <span class='neutral'>        bytes memory returnData,</span>
 270 |     | <span class='neutral'>        string memory reason1,</span>
 271 |     | <span class='neutral'>        string memory reason2</span>
 272 |     | <span class='unexecuted'>    ) public {</span>
 273 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 274 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason2);</span>
 275 |     | <span class='unexecuted'>        string memory assertMsg = string(</span>
 276 |     | <span class='unexecuted'>            abi.encodePacked(reason1, &quot; OR &quot;, reason2)</span>
 277 |     | <span class='neutral'>        );</span>
 278 |     | <span class='unexecuted'>        t(isEqual, assertMsg);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 282 |     | <span class='neutral'>        bytes memory returnData,</span>
 283 |     | <span class='neutral'>        string memory reason1,</span>
 284 |     | <span class='neutral'>        string memory reason2,</span>
 285 |     | <span class='neutral'>        string memory reason3</span>
 286 |     | <span class='unexecuted'>    ) public {</span>
 287 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 288 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason2) ||</span>
 289 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason3);</span>
 290 |     | <span class='unexecuted'>        string memory assertMsg = string(</span>
 291 |     | <span class='unexecuted'>            abi.encodePacked(reason1, &quot; OR &quot;, reason2, &quot; OR &quot;, reason3)</span>
 292 |     | <span class='neutral'>        );</span>
 293 |     | <span class='unexecuted'>        t(isEqual, assertMsg);</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 297 |     | <span class='neutral'>        bytes memory returnData,</span>
 298 |     | <span class='neutral'>        string memory reason1,</span>
 299 |     | <span class='neutral'>        string memory reason2,</span>
 300 |     | <span class='neutral'>        string memory reason3,</span>
 301 |     | <span class='neutral'>        string memory reason4</span>
 302 |     | <span class='unexecuted'>    ) public {</span>
 303 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 304 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason2) ||</span>
 305 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason3) ||</span>
 306 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason4);</span>
 307 |     | <span class='unexecuted'>        string memory assertMsg = string(</span>
 308 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 309 |     | <span class='unexecuted'>                reason1,</span>
 310 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 311 |     | <span class='unexecuted'>                reason2,</span>
 312 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 313 |     | <span class='unexecuted'>                reason3,</span>
 314 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 315 |     | <span class='unexecuted'>                reason4</span>
 316 |     | <span class='neutral'>            )</span>
 317 |     | <span class='neutral'>        );</span>
 318 |     | <span class='unexecuted'>        t(isEqual, assertMsg);</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>    function errAllow(</span>
 322 |     | <span class='neutral'>        bytes4 errorSelector,</span>
 323 |     | <span class='neutral'>        bytes4[] memory allowedErrors,</span>
 324 |     | <span class='neutral'>        string memory message</span>
 325 |     | <span class='unexecuted'>    ) public {</span>
 326 |     | <span class='unexecuted'>        bool allowed = false;</span>
 327 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; allowedErrors.length; i++) {</span>
 328 |     | <span class='unexecuted'>            if (errorSelector == allowedErrors[i]) {</span>
 329 |     | <span class='unexecuted'>                allowed = true;</span>
 330 |     | <span class='unexecuted'>                break;</span>
 331 |     | <span class='neutral'>            }</span>
 332 |     | <span class='neutral'>        }</span>
 333 |     | <span class='unexecuted'>        t(allowed, message);</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>    function errsAllow(</span>
 337 |     | <span class='neutral'>        bytes4 errorSelector,</span>
 338 |     | <span class='neutral'>        bytes4[] memory allowedErrors,</span>
 339 |     | <span class='neutral'>        string[] memory messages</span>
 340 |     | <span class='neutral'>    ) public {</span>
 341 |     | <span class='unexecuted'>        bool allowed = false;</span>
 342 |     | <span class='unexecuted'>        uint256 passIndex = 0;</span>
 343 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; allowedErrors.length; i++) {</span>
 344 |     | <span class='unexecuted'>            if (errorSelector == allowedErrors[i]) {</span>
 345 |     | <span class='unexecuted'>                allowed = true;</span>
 346 |     | <span class='unexecuted'>                passIndex = i;</span>
 347 |     | <span class='unexecuted'>                break;</span>
 348 |     | <span class='neutral'>            }</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='unexecuted'>        t(allowed, messages[passIndex]);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>    function createAssertFailMessage(string memory aStr, string memory bStr, string memory operator, string memory reason)internal pure returns (string memory) {</span>
 354 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;Invalid: &quot;, aStr, operator, bStr, &quot;, reason: &quot;, reason));</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>}</span>
 358 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IPlatform} from &quot;../platform/IPlatform.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract HelperBase {</span>
  7 |     | <span class='unexecuted'>    IPlatform public platform;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function setPlatform(address _platform) public {</span>
 10 |     | <span class='unexecuted'>        platform = IPlatform(_platform);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperClamp.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../FuzzLibString.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./HelperAssert.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   8 |     | <span class='neutral'>abstract contract HelperClamp is HelperAssert {</span>
   9 |     | <span class='neutral'>    event Clamped(string);</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    /*</span>
  12 |     | <span class='neutral'>     **************************************************************************</span>
  13 |     | <span class='neutral'>     * Clamp functions with logging enabled</span>
  14 |     | <span class='neutral'>     **************************************************************************</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
  18 | *   | <span class='executed'>    function clamp(</span>
  19 |     | <span class='neutral'>        uint256 value,</span>
  20 |     | <span class='neutral'>        uint256 low,</span>
  21 |     | <span class='neutral'>        uint256 high</span>
  22 | *   | <span class='executed'>    ) public returns (uint256) {</span>
  23 | *   | <span class='executed'>        return clamp(value, low, high, true);</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice int256 version of clamp</span>
  27 | *   | <span class='executed'>    function clamp(</span>
  28 |     | <span class='neutral'>        int256 value,</span>
  29 |     | <span class='neutral'>        int256 low,</span>
  30 |     | <span class='neutral'>        int256 high</span>
  31 | *   | <span class='executed'>    ) public returns (int256) {</span>
  32 | *   | <span class='executed'>        return clamp(value, low, high, true);</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
  36 |     | <span class='unexecuted'>    function clampLt(uint256 a, uint256 b) public returns (uint256) {</span>
  37 |     | <span class='unexecuted'>        return clampLt(a, b);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
  41 |     | <span class='unexecuted'>    function clampLt(int256 a, int256 b) public returns (int256) {</span>
  42 |     | <span class='unexecuted'>        return clampLt(a, b, true);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
  46 |     | <span class='unexecuted'>    function clampLte(uint256 a, uint256 b) public returns (uint256) {</span>
  47 |     | <span class='unexecuted'>        return clampLte(a, b, true);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
  51 |     | <span class='unexecuted'>    function clampLte(int256 a, int256 b) public returns (int256) {</span>
  52 |     | <span class='unexecuted'>        return clampLte(a, b, true);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
  56 |     | <span class='unexecuted'>    function clampGt(uint256 a, uint256 b) public returns (uint256) {</span>
  57 |     | <span class='unexecuted'>        return clampGt(a, b, true);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
  61 |     | <span class='unexecuted'>    function clampGt(int256 a, int256 b) public returns (int256) {</span>
  62 |     | <span class='unexecuted'>        return clampGt(a, b, true);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
  66 |     | <span class='unexecuted'>    function clampGte(uint256 a, uint256 b) public returns (uint256) {</span>
  67 |     | <span class='unexecuted'>        return clampGte(a, b, true);</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
  71 |     | <span class='unexecuted'>    function clampGte(int256 a, int256 b) public returns (int256) {</span>
  72 |     | <span class='unexecuted'>        return clampGte(a, b, true);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /*</span>
  76 |     | <span class='neutral'>     **************************************************************************</span>
  77 |     | <span class='neutral'>     * Clamp functions with optional logging</span>
  78 |     | <span class='neutral'>     **************************************************************************</span>
  79 |     | <span class='neutral'>     */</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
  82 | *   | <span class='executed'>    function clamp(</span>
  83 |     | <span class='neutral'>        uint256 value,</span>
  84 |     | <span class='neutral'>        uint256 low,</span>
  85 |     | <span class='neutral'>        uint256 high,</span>
  86 |     | <span class='neutral'>        bool enableLogs</span>
  87 | *   | <span class='executed'>    ) public returns (uint256) {</span>
  88 | *   | <span class='executed'>        if (value &lt; low || value &gt; high) {</span>
  89 | *   | <span class='executed'>            uint256 ans = low + (value % (high - low + 1));</span>
  90 | *   | <span class='executed'>            if (enableLogs) {</span>
  91 | *   | <span class='executed'>                string memory valueStr = FuzzLibString.toString(value);</span>
  92 | *   | <span class='executed'>                string memory ansStr = FuzzLibString.toString(ans);</span>
  93 | *   | <span class='executed'>                bytes memory message = abi.encodePacked(</span>
  94 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
  95 | *   | <span class='executed'>                    valueStr,</span>
  96 |     | <span class='neutral'>                    &quot; to &quot;,</span>
  97 | *   | <span class='executed'>                    ansStr</span>
  98 |     | <span class='neutral'>                );</span>
  99 | *   | <span class='executed'>                emit Clamped(string(message));</span>
 100 |     | <span class='neutral'>            }</span>
 101 | *   | <span class='executed'>            return ans;</span>
 102 |     | <span class='neutral'>        }</span>
 103 | *   | <span class='executed'>        return value;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /// @notice int256 version of clamp</span>
 107 | *   | <span class='executed'>    function clamp(</span>
 108 |     | <span class='neutral'>        int256 value,</span>
 109 |     | <span class='neutral'>        int256 low,</span>
 110 |     | <span class='neutral'>        int256 high,</span>
 111 |     | <span class='neutral'>        bool enableLogs</span>
 112 | *   | <span class='executed'>    ) public returns (int256) {</span>
 113 | *   | <span class='executed'>        if (value &lt; low || value &gt; high) {</span>
 114 | *   | <span class='executed'>            int256 range = high - low + 1;</span>
 115 | *   | <span class='executed'>            int256 clamped = (value - low) % (range);</span>
 116 | *   | <span class='executed'>            if (clamped &lt; 0) clamped += range;</span>
 117 | *   | <span class='executed'>            int256 ans = low + clamped;</span>
 118 | *   | <span class='executed'>            if (enableLogs) {</span>
 119 | *   | <span class='executed'>                string memory valueStr = FuzzLibString.toString(value);</span>
 120 | *   | <span class='executed'>                string memory ansStr = FuzzLibString.toString(ans);</span>
 121 | *   | <span class='executed'>                bytes memory message = abi.encodePacked(</span>
 122 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 123 | *   | <span class='executed'>                    valueStr,</span>
 124 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 125 | *   | <span class='executed'>                    ansStr</span>
 126 |     | <span class='neutral'>                );</span>
 127 | *   | <span class='executed'>                emit Clamped(string(message));</span>
 128 |     | <span class='neutral'>            }</span>
 129 | *   | <span class='executed'>            return ans;</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>        return value;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 135 |     | <span class='unexecuted'>    function clampLt(</span>
 136 |     | <span class='neutral'>        uint256 a,</span>
 137 |     | <span class='neutral'>        uint256 b,</span>
 138 |     | <span class='neutral'>        bool enableLogs</span>
 139 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 140 |     | <span class='unexecuted'>        if (!(a &lt; b)) {</span>
 141 |     | <span class='unexecuted'>            neq(</span>
 142 |     | <span class='unexecuted'>                b,</span>
 143 |     | <span class='unexecuted'>                0,</span>
 144 |     | <span class='neutral'>                &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;</span>
 145 |     | <span class='neutral'>            );</span>
 146 |     | <span class='unexecuted'>            uint256 value = a % b;</span>
 147 |     | <span class='neutral'>            if (enableLogs) {</span>
 148 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 149 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 150 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 151 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 152 |     | <span class='neutral'>                    aStr,</span>
 153 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 154 |     | <span class='neutral'>                    valueStr</span>
 155 |     | <span class='neutral'>                );</span>
 156 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>            return value;</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>        return a;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 164 |     | <span class='unexecuted'>    function clampLt(</span>
 165 |     | <span class='neutral'>        int256 a,</span>
 166 |     | <span class='neutral'>        int256 b,</span>
 167 |     | <span class='neutral'>        bool enableLogs</span>
 168 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 169 |     | <span class='unexecuted'>        if (!(a &lt; b)) {</span>
 170 |     | <span class='unexecuted'>            int256 value = b - 1;</span>
 171 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 172 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 173 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 174 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 175 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 176 |     | <span class='neutral'>                    aStr,</span>
 177 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 178 |     | <span class='neutral'>                    valueStr</span>
 179 |     | <span class='neutral'>                );</span>
 180 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 181 |     | <span class='neutral'>            }</span>
 182 |     | <span class='neutral'>            return value;</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>        return a;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 188 |     | <span class='unexecuted'>    function clampLte(</span>
 189 |     | <span class='neutral'>        uint256 a,</span>
 190 |     | <span class='neutral'>        uint256 b,</span>
 191 |     | <span class='neutral'>        bool enableLogs</span>
 192 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 193 |     | <span class='unexecuted'>        if (!(a &lt;= b)) {</span>
 194 |     | <span class='unexecuted'>            uint256 value = a % (b + 1);</span>
 195 |     | <span class='neutral'>            if (enableLogs) {</span>
 196 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 197 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 198 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 199 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 200 |     | <span class='neutral'>                    aStr,</span>
 201 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 202 |     | <span class='neutral'>                    valueStr</span>
 203 |     | <span class='neutral'>                );</span>
 204 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 205 |     | <span class='neutral'>            }</span>
 206 |     | <span class='neutral'>            return value;</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>        return a;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 212 | *   | <span class='executed'>    function clampLte(</span>
 213 |     | <span class='neutral'>        int256 a,</span>
 214 |     | <span class='neutral'>        int256 b,</span>
 215 |     | <span class='neutral'>        bool enableLogs</span>
 216 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 217 |     | <span class='unexecuted'>        if (!(a &lt;= b)) {</span>
 218 |     | <span class='unexecuted'>            int256 value = b;</span>
 219 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 220 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 221 |     | <span class='unexecuted'>                string memory valueStr = FuzzLibString.toString(value);</span>
 222 |     | <span class='unexecuted'>                bytes memory message = abi.encodePacked(</span>
 223 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 224 |     | <span class='unexecuted'>                    aStr,</span>
 225 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 226 |     | <span class='unexecuted'>                    valueStr</span>
 227 |     | <span class='neutral'>                );</span>
 228 |     | <span class='unexecuted'>                emit Clamped(string(message));</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='unexecuted'>            return value;</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='unexecuted'>        return a;</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 236 |     | <span class='unexecuted'>    function clampGt(</span>
 237 |     | <span class='neutral'>        uint256 a,</span>
 238 |     | <span class='neutral'>        uint256 b,</span>
 239 |     | <span class='neutral'>        bool enableLogs</span>
 240 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 241 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 242 |     | <span class='unexecuted'>            neq(</span>
 243 |     | <span class='unexecuted'>                b,</span>
 244 |     | <span class='neutral'>                type(uint256).max,</span>
 245 |     | <span class='neutral'>                &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;</span>
 246 |     | <span class='neutral'>            );</span>
 247 |     | <span class='unexecuted'>            uint256 value = b + 1;</span>
 248 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 249 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 250 |     | <span class='unexecuted'>                string memory valueStr = FuzzLibString.toString(value);</span>
 251 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 252 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 253 |     | <span class='neutral'>                    aStr,</span>
 254 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 255 |     | <span class='neutral'>                    valueStr</span>
 256 |     | <span class='neutral'>                );</span>
 257 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='neutral'>            return value;</span>
 260 |     | <span class='neutral'>        } else {</span>
 261 |     | <span class='unexecuted'>            return a;</span>
 262 |     | <span class='neutral'>        }</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 266 |     | <span class='unexecuted'>    function clampGt(</span>
 267 |     | <span class='neutral'>        int256 a,</span>
 268 |     | <span class='neutral'>        int256 b,</span>
 269 |     | <span class='neutral'>        bool enableLogs</span>
 270 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 271 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 272 |     | <span class='unexecuted'>            int256 value = b + 1;</span>
 273 |     | <span class='neutral'>            if (enableLogs) {</span>
 274 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 275 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 276 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 277 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 278 |     | <span class='neutral'>                    aStr,</span>
 279 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 280 |     | <span class='neutral'>                    valueStr</span>
 281 |     | <span class='neutral'>                );</span>
 282 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 283 |     | <span class='neutral'>            }</span>
 284 |     | <span class='neutral'>            return value;</span>
 285 |     | <span class='neutral'>        } else {</span>
 286 |     | <span class='neutral'>            return a;</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 291 |     | <span class='unexecuted'>    function clampGte(</span>
 292 |     | <span class='neutral'>        uint256 a,</span>
 293 |     | <span class='neutral'>        uint256 b,</span>
 294 |     | <span class='neutral'>        bool enableLogs</span>
 295 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 296 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 297 |     | <span class='unexecuted'>            uint256 value = b;</span>
 298 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 299 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 300 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 301 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 302 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 303 |     | <span class='neutral'>                    aStr,</span>
 304 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 305 |     | <span class='neutral'>                    valueStr</span>
 306 |     | <span class='neutral'>                );</span>
 307 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 308 |     | <span class='neutral'>            }</span>
 309 |     | <span class='neutral'>            return value;</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'>        return a;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 315 |     | <span class='unexecuted'>    function clampGte(</span>
 316 |     | <span class='neutral'>        int256 a,</span>
 317 |     | <span class='neutral'>        int256 b,</span>
 318 |     | <span class='neutral'>        bool enableLogs</span>
 319 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 320 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 321 |     | <span class='unexecuted'>            int256 value = b;</span>
 322 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 323 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 324 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 325 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 326 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 327 |     | <span class='neutral'>                    aStr,</span>
 328 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 329 |     | <span class='neutral'>                    valueStr</span>
 330 |     | <span class='neutral'>                );</span>
 331 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 332 |     | <span class='neutral'>            }</span>
 333 |     | <span class='neutral'>            return value;</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>        return a;</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'>}</span>
 338 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperLog.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {LibLog} from &quot;../libraries/LibLog.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract HelperLog {</span>
  7 | *   | <span class='executed'>    function log(string memory message) public {</span>
  8 | *   | <span class='executed'>        LibLog.log(message);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function log(string memory message, string memory data) public {</span>
 12 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function log(string memory message, bytes memory data) public {</span>
 16 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    function log(string memory message, uint256 data) public {</span>
 20 | *   | <span class='executed'>        LibLog.log(message, data);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function log(string memory message, int256 data) public {</span>
 24 | *   | <span class='executed'>        LibLog.log(message, data);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function log(string memory message, address data) public {</span>
 28 | *   | <span class='executed'>        LibLog.log(message, data);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 | *   | <span class='executed'>    function log(string memory message, bool data) public {</span>
 32 | *   | <span class='executed'>        LibLog.log(message, data);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function log(string memory message, bytes32 data) public {</span>
 36 |     | <span class='neutral'>        LibLog.log(message, data);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function logFail() public {</span>
 40 |     | <span class='unexecuted'>        LibLog.logFail();</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function logFail(string memory message) public {</span>
 44 |     | <span class='unexecuted'>        LibLog.logFail(message);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function logFail(string memory message, string memory data) public {</span>
 48 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function logFail(string memory message, bytes memory data) public {</span>
 52 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function logFail(string memory message, uint256 data) public {</span>
 56 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function logFail(string memory message, int256 data) public {</span>
 60 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function logFail(string memory message, address data) public {</span>
 64 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 | *   | <span class='executed'>    function logFail(string memory message, bool data) public {</span>
 68 | *   | <span class='executed'>        LibLog.logFail(message, data);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function logFail(string memory message, bytes32 data) public {</span>
 72 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract HelperMath {</span>
  5 | *   | <span class='executed'>    function min(uint256 a, uint256 b) public pure returns (uint256) {</span>
  6 | *   | <span class='executed'>        return a &lt; b ? a : b;</span>
  7 |     | <span class='neutral'>    }</span>
  8 |     | <span class='neutral'></span>
  9 | *   | <span class='executed'>    function max(uint256 a, uint256 b) public pure returns (uint256) {</span>
 10 | *   | <span class='executed'>        return a &gt; b ? a : b;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/utils/math/SignedMath.sol</span>
 14 |     | <span class='unexecuted'>    function max(int256 a, int256 b) public pure returns (int256) {</span>
 15 |     | <span class='unexecuted'>        return a &gt; b ? a : b;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // Forked with modifications from https://ethereum.stackexchange.com/a/84391</span>
 19 |     | <span class='unexecuted'>    function abs(int128 n) public pure returns (int128) {</span>
 20 |     | <span class='unexecuted'>        return n &gt;= 0 ? n : -n;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function abs(int256 n) public pure returns (uint256) {</span>
 24 | *   | <span class='executed'>        return n &gt;= 0 ? uint256(n) : uint256(-n);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function diff(int256 a, int256 b) public pure returns (uint256) {</span>
 28 |     | <span class='unexecuted'>        return a &gt;= b ? uint256(a - b) : uint256(b - a);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function diff(uint256 a, uint256 b) public pure returns (uint256) {</span>
 32 |     | <span class='unexecuted'>        return a &gt;= b ? a - b : b - a;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperRandom.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract HelperRandom {</span>
  5 |     | <span class='neutral'>    /// @notice Shuffle an array using Fisher-Yates algorithm</span>
  6 |     | <span class='neutral'>    /// @dev Based on https://gist.github.com/scammi/602387a22e04c77beb73c0ebc0f0bc18</span>
  7 |     | <span class='unexecuted'>    function shuffleArray(</span>
  8 |     | <span class='neutral'>        uint256[] memory shuffle,</span>
  9 |     | <span class='neutral'>        uint256 entropy</span>
 10 |     | <span class='neutral'>    ) public pure {</span>
 11 |     | <span class='unexecuted'>        for (uint256 i = shuffle.length - 1; i &gt; 0; i--) {</span>
 12 |     | <span class='unexecuted'>            uint256 swapIndex = entropy % (shuffle.length - i);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>            uint256 currentIndex = shuffle[i];</span>
 15 |     | <span class='unexecuted'>            uint256 indexToSwap = shuffle[swapIndex];</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>            shuffle[i] = indexToSwap;</span>
 18 |     | <span class='unexecuted'>            shuffle[swapIndex] = currentIndex;</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/libraries/LibLog.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library LibLog {</span>
  5 |     | <span class='neutral'>    event Log(string message);</span>
  6 |     | <span class='neutral'>    event LogString(string message, string data);</span>
  7 |     | <span class='neutral'>    event LogBytes(string message, bytes data);</span>
  8 |     | <span class='neutral'>    event LogUint(string message, uint256 data);</span>
  9 |     | <span class='neutral'>    event LogInt(string message, int256 data);</span>
 10 |     | <span class='neutral'>    event LogAddress(string message, address data);</span>
 11 |     | <span class='neutral'>    event LogBool(string message, bool data);</span>
 12 |     | <span class='neutral'>    event LogBytes32(string message, bytes32 data);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    event AssertionFailed();</span>
 15 |     | <span class='neutral'>    event AssertionFailed(string message);</span>
 16 |     | <span class='neutral'>    event AssertionFailed(string message, string data);</span>
 17 |     | <span class='neutral'>    event AssertionFailed(string message, bytes data);</span>
 18 |     | <span class='neutral'>    event AssertionFailed(string message, uint256 data);</span>
 19 |     | <span class='neutral'>    event AssertionFailed(string message, int256 data);</span>
 20 |     | <span class='neutral'>    event AssertionFailed(string message, address data);</span>
 21 |     | <span class='neutral'>    event AssertionFailed(string message, bool data);</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function log(string memory message) internal {</span>
 24 | *   | <span class='executed'>        emit Log(message);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function log(string memory message, string memory data) internal {</span>
 28 |     | <span class='unexecuted'>        emit LogString(message, data);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function log(string memory message, bytes memory data) internal {</span>
 32 |     | <span class='unexecuted'>        emit LogBytes(message, data);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>    function log(string memory message, uint256 data) internal {</span>
 36 | *   | <span class='executed'>        emit LogUint(message, data);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 | *   | <span class='executed'>    function log(string memory message, int256 data) internal {</span>
 40 | *   | <span class='executed'>        emit LogInt(message, data);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 | *   | <span class='executed'>    function log(string memory message, address data) internal {</span>
 44 | *   | <span class='executed'>        emit LogAddress(message, data);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 | *   | <span class='executed'>    function log(string memory message, bool data) internal {</span>
 48 | *   | <span class='executed'>        emit LogBool(message, data);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function log(string memory message, bytes32 data) internal {</span>
 52 |     | <span class='unexecuted'>        emit LogBytes32(message, data);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function logFail() internal {</span>
 56 |     | <span class='unexecuted'>        emit AssertionFailed();</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function logFail(string memory message) internal {</span>
 60 |     | <span class='unexecuted'>        emit AssertionFailed(message);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function logFail(string memory message, string memory data) internal {</span>
 64 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function logFail(string memory message, bytes memory data) internal {</span>
 68 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function logFail(string memory message, uint256 data) internal {</span>
 72 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>    function logFail(string memory message, int256 data) internal {</span>
 76 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='unexecuted'>    function logFail(string memory message, address data) internal {</span>
 80 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 | *   | <span class='executed'>    function logFail(string memory message, bool data) internal {</span>
 84 | *   | <span class='executed'>        emit AssertionFailed(message, data);</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'></span>
 87 |     | <span class='neutral'>    function logFail(string memory message, bytes32 data) internal {</span>
 88 |     | <span class='neutral'>        emit LogBytes32(message, data);</span>
 89 |     | <span class='neutral'>    }</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/platform/IPlatform.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IPlatform {</span>
 5 |     | <span class='neutral'>    function assertFail() pure external;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/platform/PlatformCrytic.sol</b>
<code>
  1 |     | <span class='neutral'></span>
  2 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IPlatform} from &quot;./IPlatform.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract PlatformCrytic is IPlatform {</span>
  8 | *   | <span class='executed'>    function assertFail() pure public override{</span>
  9 | *   | <span class='executed'>        assert(false);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 | *   | <span class='executed'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 | *   | <span class='executed'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='neutral'>        address spender = _msgSender();</span>
 160 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 161 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 162 | *   | <span class='executed'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='neutral'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='neutral'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='neutral'>        address owner = _msgSender();</span>
 199 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 | *   | <span class='executed'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *   | <span class='executed'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 229 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 | *   | <span class='executed'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 | *   | <span class='executed'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 | *   | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 | *   | <span class='executed'>        uint256 accountBalance = _balances[account];</span>
 283 | *   | <span class='executed'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 | *   | <span class='executed'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 | *   | <span class='executed'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 | *   | <span class='executed'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 | *   | <span class='executed'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 313 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 | *   | <span class='executed'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 327 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/AccessError.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Library for access related errors.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library AccessError {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @dev Thrown when an address tries to perform an unauthorized action.</span>
 10 |     | <span class='neutral'>     * @param addr The address that attempts the action.</span>
 11 |     | <span class='neutral'>     */</span>
 12 |     | <span class='neutral'>    error Unauthorized(address addr);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/AddressError.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Library for address related errors.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library AddressError {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @dev Thrown when a zero address was passed as a function parameter (0x0000000000000000000000000000000000000000).</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'>    error ZeroAddress();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Thrown when an address representing a contract is expected, but no code is found at the address.</span>
 15 |     | <span class='neutral'>     * @param contr The address that was expected to be a contract.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    error NotAContract(address contr);</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/ChangeError.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Library for change related errors.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library ChangeError {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @dev Thrown when a change is expected but none is detected.</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'>    error NoChange();</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/InitError.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Library for initialization related errors.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library InitError {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @dev Thrown when attempting to initialize a contract that is already initialized.</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'>    error AlreadyInitialized();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Thrown when attempting to interact with a contract that has not been initialized yet.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    error NotInitialized();</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/ParameterError.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Library for errors related with expected function parameters.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library ParameterError {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @dev Thrown when an invalid parameter is used in a function.</span>
 10 |     | <span class='neutral'>     * @param parameter The name of the parameter.</span>
 11 |     | <span class='neutral'>     * @param reason The reason why the received parameter is invalid.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    error InvalidParameter(string parameter, string reason);</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/initializable/InitializableMixin.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../errors/InitError.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Mixin for contracts that require initialization.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>abstract contract InitializableMixin {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Reverts if contract is not initialized.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    modifier onlyIfInitialized() {</span>
 14 |     | <span class='neutral'>        if (!_isInitialized()) {</span>
 15 |     | <span class='neutral'>            revert InitError.NotInitialized();</span>
 16 |     | <span class='neutral'>        }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>        _;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev Reverts if contract is already initialized.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    modifier onlyIfNotInitialized() {</span>
 25 |     | <span class='neutral'>        if (_isInitialized()) {</span>
 26 |     | <span class='neutral'>            revert InitError.AlreadyInitialized();</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>        _;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @dev Override this function to determine if the contract is initialized.</span>
 34 |     | <span class='neutral'>     * @return True if initialized, false otherwise.</span>
 35 |     | <span class='neutral'>     */</span>
 36 |     | <span class='neutral'>    function _isInitialized() internal view virtual returns (bool);</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title ERC165 interface for determining if a contract supports a given interface.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='neutral'>interface IERC165 {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @notice Determines if the contract in question supports the specified interface.</span>
 10 |     | <span class='neutral'>     * @param interfaceID XOR of all selectors in the contract.</span>
 11 |     | <span class='neutral'>     * @return True if the contract supports the specified interface.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IERC20.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title ERC20 token implementation.</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface IERC20 {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Emitted when tokens have been transferred.</span>
  10 |     | <span class='neutral'>     * @param from The address that originally owned the tokens.</span>
  11 |     | <span class='neutral'>     * @param to The address that received the tokens.</span>
  12 |     | <span class='neutral'>     * @param amount The number of tokens that were transferred.</span>
  13 |     | <span class='neutral'>     */</span>
  14 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 amount);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @notice Emitted when a user has provided allowance to another user for transferring tokens on its behalf.</span>
  18 |     | <span class='neutral'>     * @param owner The address that is providing the allowance.</span>
  19 |     | <span class='neutral'>     * @param spender The address that received the allowance.</span>
  20 |     | <span class='neutral'>     * @param amount The number of tokens that were added to `spender`&#39;s allowance.</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 amount);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @notice Thrown when the address interacting with the contract does not have sufficient allowance to transfer tokens from another contract.</span>
  26 |     | <span class='neutral'>     * @param required The necessary allowance.</span>
  27 |     | <span class='neutral'>     * @param existing The current allowance.</span>
  28 |     | <span class='neutral'>     */</span>
  29 |     | <span class='neutral'>    error InsufficientAllowance(uint256 required, uint256 existing);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @notice Thrown when the address interacting with the contract does not have sufficient tokens.</span>
  33 |     | <span class='neutral'>     * @param required The necessary balance.</span>
  34 |     | <span class='neutral'>     * @param existing The current balance.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    error InsufficientBalance(uint256 required, uint256 existing);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @notice Retrieves the name of the token, e.g. &quot;Synthetix Network Token&quot;.</span>
  40 |     | <span class='neutral'>     * @return A string with the name of the token.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @notice Retrieves the symbol of the token, e.g. &quot;SNX&quot;.</span>
  46 |     | <span class='neutral'>     * @return A string with the symbol of the token.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Retrieves the number of decimals used by the token. The default is 18.</span>
  52 |     | <span class='neutral'>     * @return The number of decimals.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @notice Returns the total number of tokens in circulation (minted - burnt).</span>
  58 |     | <span class='neutral'>     * @return The total number of tokens.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @notice Returns the balance of a user.</span>
  64 |     | <span class='neutral'>     * @param owner The address whose balance is being retrieved.</span>
  65 |     | <span class='neutral'>     * @return The number of tokens owned by the user.</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @notice Returns how many tokens a user has allowed another user to transfer on its behalf.</span>
  71 |     | <span class='neutral'>     * @param owner The user who has given the allowance.</span>
  72 |     | <span class='neutral'>     * @param spender The user who was given the allowance.</span>
  73 |     | <span class='neutral'>     * @return The amount of tokens `spender` can transfer on `owner`&#39;s behalf.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @notice Transfer tokens from one address to another.</span>
  79 |     | <span class='neutral'>     * @param to The address that will receive the tokens.</span>
  80 |     | <span class='neutral'>     * @param amount The amount of tokens to be transferred.</span>
  81 |     | <span class='neutral'>     * @return A boolean which is true if the operation succeeded.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @notice Allows users to provide allowance to other users so that they can transfer tokens on their behalf.</span>
  87 |     | <span class='neutral'>     * @param spender The address that is receiving the allowance.</span>
  88 |     | <span class='neutral'>     * @param amount The amount of tokens that are being added to the allowance.</span>
  89 |     | <span class='neutral'>     * @return A boolean which is true if the operation succeeded.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @notice Atomically increases the allowance granted to `spender` by the caller.</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
  97 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * Requirements:</span>
 102 |     | <span class='neutral'>     *</span>
 103 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='neutral'>    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @notice Atomically decreases the allowance granted to `spender` by the caller.</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 111 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * Requirements:</span>
 116 |     | <span class='neutral'>     *</span>
 117 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 118 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 119 |     | <span class='neutral'>     * `subtractedValue`.</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @notice Allows a user who has been given allowance to transfer tokens on another user&#39;s behalf.</span>
 125 |     | <span class='neutral'>     * @param from The address that owns the tokens that are being transferred.</span>
 126 |     | <span class='neutral'>     * @param to The address that will receive the tokens.</span>
 127 |     | <span class='neutral'>     * @param amount The number of tokens to transfer.</span>
 128 |     | <span class='neutral'>     * @return A boolean which is true if the operation succeeded.</span>
 129 |     | <span class='neutral'>     */</span>
 130 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 131 |     | <span class='neutral'>}</span>
 132 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IOwnable.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Contract for facilitating ownership by a single address.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='neutral'>interface IOwnable {</span>
  8 |     | <span class='neutral'>    /**</span>
  9 |     | <span class='neutral'>     * @notice Thrown when an address tries to accept ownership but has not been nominated.</span>
 10 |     | <span class='neutral'>     * @param addr The address that is trying to accept ownership.</span>
 11 |     | <span class='neutral'>     */</span>
 12 |     | <span class='neutral'>    error NotNominated(address addr);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @notice Emitted when an address has been nominated.</span>
 16 |     | <span class='neutral'>     * @param newOwner The address that has been nominated.</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    event OwnerNominated(address newOwner);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /**</span>
 21 |     | <span class='neutral'>     * @notice Emitted when the owner of the contract has changed.</span>
 22 |     | <span class='neutral'>     * @param oldOwner The previous owner of the contract.</span>
 23 |     | <span class='neutral'>     * @param newOwner The new owner of the contract.</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    event OwnerChanged(address oldOwner, address newOwner);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /**</span>
 28 |     | <span class='neutral'>     * @notice Allows a nominated address to accept ownership of the contract.</span>
 29 |     | <span class='neutral'>     * @dev Reverts if the caller is not nominated.</span>
 30 |     | <span class='neutral'>     */</span>
 31 |     | <span class='neutral'>    function acceptOwnership() external;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /**</span>
 34 |     | <span class='neutral'>     * @notice Allows the current owner to nominate a new owner.</span>
 35 |     | <span class='neutral'>     * @dev The nominated owner will have to call `acceptOwnership` in a separate transaction in order to finalize the action and become the new contract owner.</span>
 36 |     | <span class='neutral'>     * @param newNominatedOwner The address that is to become nominated.</span>
 37 |     | <span class='neutral'>     */</span>
 38 |     | <span class='neutral'>    function nominateNewOwner(address newNominatedOwner) external;</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @notice Allows a nominated owner to reject the nomination.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='neutral'>    function renounceNomination() external;</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /**</span>
 46 |     | <span class='neutral'>     * @notice Returns the current owner of the contract.</span>
 47 |     | <span class='neutral'>     */</span>
 48 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /**</span>
 51 |     | <span class='neutral'>     * @notice Returns the current nominated owner of the contract.</span>
 52 |     | <span class='neutral'>     * @dev Only one address can be nominated at a time.</span>
 53 |     | <span class='neutral'>     */</span>
 54 |     | <span class='neutral'>    function nominatedOwner() external view returns (address);</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IUUPSImplementation.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Contract to be used as the implementation of a Universal Upgradeable Proxy Standard (UUPS) proxy.</span>
  6 |     | <span class='neutral'> *</span>
  7 |     | <span class='neutral'> * Important: A UUPS proxy requires its upgradeability functions to be in the implementation as opposed to the proxy. This means that if the proxy is upgraded to an implementation that does not support this interface, it will no longer be upgradeable.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IUUPSImplementation {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @notice Thrown when an incoming implementation will not be able to receive future upgrades.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    error ImplementationIsSterile(address implementation);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @notice Thrown intentionally when testing future upgradeability of an implementation.</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    error UpgradeSimulationFailed();</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /**</span>
 21 |     | <span class='neutral'>     * @notice Emitted when the implementation of the proxy has been upgraded.</span>
 22 |     | <span class='neutral'>     * @param self The address of the proxy whose implementation was upgraded.</span>
 23 |     | <span class='neutral'>     * @param implementation The address of the proxy&#39;s new implementation.</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    event Upgraded(address indexed self, address implementation);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /**</span>
 28 |     | <span class='neutral'>     * @notice Allows the proxy to be upgraded to a new implementation.</span>
 29 |     | <span class='neutral'>     * @param newImplementation The address of the proxy&#39;s new implementation.</span>
 30 |     | <span class='neutral'>     * @dev Will revert if `newImplementation` is not upgradeable.</span>
 31 |     | <span class='neutral'>     * @dev The implementation of this function needs to be protected by some sort of access control such as `onlyOwner`.</span>
 32 |     | <span class='neutral'>     */</span>
 33 |     | <span class='neutral'>    function upgradeTo(address newImplementation) external;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @notice Function used to determine if a new implementation will be able to receive future upgrades in `upgradeTo`.</span>
 37 |     | <span class='neutral'>     * @param newImplementation The address of the new implementation being tested for future upgradeability.</span>
 38 |     | <span class='neutral'>     * @dev This function will always revert, but will revert with different error messages. The function `upgradeTo` uses this error to determine the future upgradeability of the implementation in question.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    function simulateUpgradeTo(address newImplementation) external;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /**</span>
 43 |     | <span class='neutral'>     * @notice Retrieves the current implementation of the proxy.</span>
 44 |     | <span class='neutral'>     * @return The address of the current implementation.</span>
 45 |     | <span class='neutral'>     */</span>
 46 |     | <span class='neutral'>    function getImplementation() external view returns (address);</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/ownership/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./OwnableStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../interfaces/IOwnable.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../errors/AddressError.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../errors/ChangeError.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title Contract for facilitating ownership by a single address.</span>
 11 |     | <span class='neutral'> * See IOwnable.</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='unexecuted'>contract Ownable is IOwnable {</span>
 14 |     | <span class='unexecuted'>    constructor(address initialOwner) {</span>
 15 |     | <span class='unexecuted'>        OwnableStorage.load().owner = initialOwner;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @inheritdoc IOwnable</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='unexecuted'>    function acceptOwnership() public override {</span>
 22 |     | <span class='unexecuted'>        OwnableStorage.Data storage store = OwnableStorage.load();</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>        address currentNominatedOwner = store.nominatedOwner;</span>
 25 |     | <span class='unexecuted'>        if (msg.sender != currentNominatedOwner) {</span>
 26 |     | <span class='unexecuted'>            revert NotNominated(msg.sender);</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        emit OwnerChanged(store.owner, currentNominatedOwner);</span>
 30 |     | <span class='unexecuted'>        store.owner = currentNominatedOwner;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        store.nominatedOwner = address(0);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @inheritdoc IOwnable</span>
 37 |     | <span class='neutral'>     */</span>
 38 |     | <span class='unexecuted'>    function nominateNewOwner(address newNominatedOwner) public override onlyOwner {</span>
 39 |     | <span class='unexecuted'>        OwnableStorage.Data storage store = OwnableStorage.load();</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>        if (newNominatedOwner == address(0)) {</span>
 42 |     | <span class='unexecuted'>            revert AddressError.ZeroAddress();</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        if (newNominatedOwner == store.nominatedOwner) {</span>
 46 |     | <span class='unexecuted'>            revert ChangeError.NoChange();</span>
 47 |     | <span class='neutral'>        }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>        store.nominatedOwner = newNominatedOwner;</span>
 50 |     | <span class='unexecuted'>        emit OwnerNominated(newNominatedOwner);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /**</span>
 54 |     | <span class='neutral'>     * @inheritdoc IOwnable</span>
 55 |     | <span class='neutral'>     */</span>
 56 |     | <span class='unexecuted'>    function renounceNomination() external override {</span>
 57 |     | <span class='unexecuted'>        OwnableStorage.Data storage store = OwnableStorage.load();</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        if (store.nominatedOwner != msg.sender) {</span>
 60 |     | <span class='unexecuted'>            revert NotNominated(msg.sender);</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>        store.nominatedOwner = address(0);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    /**</span>
 67 |     | <span class='neutral'>     * @inheritdoc IOwnable</span>
 68 |     | <span class='neutral'>     */</span>
 69 |     | <span class='unexecuted'>    function owner() external view override returns (address) {</span>
 70 |     | <span class='unexecuted'>        return OwnableStorage.load().owner;</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /**</span>
 74 |     | <span class='neutral'>     * @inheritdoc IOwnable</span>
 75 |     | <span class='neutral'>     */</span>
 76 |     | <span class='unexecuted'>    function nominatedOwner() external view override returns (address) {</span>
 77 |     | <span class='unexecuted'>        return OwnableStorage.load().nominatedOwner;</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>    /**</span>
 81 |     | <span class='neutral'>     * @dev Reverts if the caller is not the owner.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 84 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='neutral'>        _;</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../errors/AccessError.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library OwnableStorage {</span>
  7 |     | <span class='neutral'>    bytes32 private constant _SLOT_OWNABLE_STORAGE =</span>
  8 | *   | <span class='executed'>        keccak256(abi.encode(&quot;io.synthetix.core-contracts.Ownable&quot;));</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    struct Data {</span>
 11 |     | <span class='neutral'>        address owner;</span>
 12 |     | <span class='neutral'>        address nominatedOwner;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 | *   | <span class='executed'>    function load() internal pure returns (Data storage store) {</span>
 16 |     | <span class='unexecuted'>        bytes32 s = _SLOT_OWNABLE_STORAGE;</span>
 17 |     | <span class='neutral'>        assembly {</span>
 18 |     | <span class='neutral'>            store.slot := s</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function onlyOwner() internal view {</span>
 23 |     | <span class='unexecuted'>        if (msg.sender != getOwner()) {</span>
 24 |     | <span class='unexecuted'>            revert AccessError.Unauthorized(msg.sender);</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function getOwner() internal view returns (address) {</span>
 29 |     | <span class='unexecuted'>        return OwnableStorage.load().owner;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'>}</span>
 32 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/AbstractProxy.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract AbstractProxy {</span>
  5 |     | <span class='neutral'>    fallback() external payable {</span>
  6 | *   | <span class='executed'>        _forward();</span>
  7 |     | <span class='neutral'>    }</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    receive() external payable {</span>
 10 |     | <span class='unexecuted'>        _forward();</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>    function _forward() internal {</span>
 14 | *   | <span class='executed'>        address implementation = _getImplementation();</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>        // solhint-disable-next-line no-inline-assembly</span>
 17 |     | <span class='neutral'>        assembly {</span>
 18 | *   | <span class='executed'>            calldatacopy(0, 0, calldatasize())</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>            returndatacopy(0, 0, returndatasize())</span>
 23 |     | <span class='neutral'></span>
 24 | *   | <span class='executed'>            switch result</span>
 25 | *   | <span class='executed'>            case 0 {</span>
 26 | *   | <span class='executed'>                revert(0, returndatasize())</span>
 27 |     | <span class='neutral'>            }</span>
 28 |     | <span class='neutral'>            default {</span>
 29 | *   | <span class='executed'>                return(0, returndatasize())</span>
 30 |     | <span class='neutral'>            }</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function _getImplementation() internal view virtual returns (address);</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/ProxyStorage.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>contract ProxyStorage {</span>
  5 |     | <span class='neutral'>    bytes32 private constant _SLOT_PROXY_STORAGE =</span>
  6 | *   | <span class='executed'>        keccak256(abi.encode(&quot;io.synthetix.core-contracts.Proxy&quot;));</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    struct ProxyStore {</span>
  9 |     | <span class='neutral'>        address implementation;</span>
 10 |     | <span class='neutral'>        bool simulatingUpgrade;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>    function _proxyStore() internal pure returns (ProxyStore storage store) {</span>
 14 | *   | <span class='executed'>        bytes32 s = _SLOT_PROXY_STORAGE;</span>
 15 |     | <span class='neutral'>        assembly {</span>
 16 |     | <span class='neutral'>            store.slot := s</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../interfaces/IUUPSImplementation.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../errors/AddressError.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../errors/ChangeError.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../utils/AddressUtil.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./ProxyStorage.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>abstract contract UUPSImplementation is IUUPSImplementation, ProxyStorage {</span>
 11 |     | <span class='neutral'>    /**</span>
 12 |     | <span class='neutral'>     * @inheritdoc IUUPSImplementation</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='unexecuted'>    function simulateUpgradeTo(address newImplementation) public override {</span>
 15 |     | <span class='unexecuted'>        ProxyStore storage store = _proxyStore();</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>        store.simulatingUpgrade = true;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>        address currentImplementation = store.implementation;</span>
 20 |     | <span class='unexecuted'>        store.implementation = newImplementation;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>        (bool rollbackSuccessful, ) = newImplementation.delegatecall(</span>
 23 |     | <span class='unexecuted'>            abi.encodeCall(this.upgradeTo, (currentImplementation))</span>
 24 |     | <span class='neutral'>        );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        if (!rollbackSuccessful || _proxyStore().implementation != currentImplementation) {</span>
 27 |     | <span class='unexecuted'>            revert UpgradeSimulationFailed();</span>
 28 |     | <span class='neutral'>        }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        store.simulatingUpgrade = false;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>        // solhint-disable-next-line reason-string</span>
 33 |     | <span class='unexecuted'>        revert();</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /**</span>
 37 |     | <span class='neutral'>     * @inheritdoc IUUPSImplementation</span>
 38 |     | <span class='neutral'>     */</span>
 39 |     | <span class='unexecuted'>    function getImplementation() external view override returns (address) {</span>
 40 |     | <span class='unexecuted'>        return _proxyStore().implementation;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function _upgradeTo(address newImplementation) internal virtual {</span>
 44 |     | <span class='unexecuted'>        if (newImplementation == address(0)) {</span>
 45 |     | <span class='unexecuted'>            revert AddressError.ZeroAddress();</span>
 46 |     | <span class='neutral'>        }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>        if (!AddressUtil.isContract(newImplementation)) {</span>
 49 |     | <span class='unexecuted'>            revert AddressError.NotAContract(newImplementation);</span>
 50 |     | <span class='neutral'>        }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>        ProxyStore storage store = _proxyStore();</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>        if (newImplementation == store.implementation) {</span>
 55 |     | <span class='unexecuted'>            revert ChangeError.NoChange();</span>
 56 |     | <span class='neutral'>        }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>        if (!store.simulatingUpgrade &amp;&amp; _implementationIsSterile(newImplementation)) {</span>
 59 |     | <span class='unexecuted'>            revert ImplementationIsSterile(newImplementation);</span>
 60 |     | <span class='neutral'>        }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>        store.implementation = newImplementation;</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>        emit Upgraded(address(this), newImplementation);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function _implementationIsSterile(</span>
 68 |     | <span class='neutral'>        address candidateImplementation</span>
 69 |     | <span class='neutral'>    ) internal virtual returns (bool) {</span>
 70 |     | <span class='unexecuted'>        (bool simulationReverted, bytes memory simulationResponse) = address(this).delegatecall(</span>
 71 |     | <span class='unexecuted'>            abi.encodeCall(this.simulateUpgradeTo, (candidateImplementation))</span>
 72 |     | <span class='neutral'>        );</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='unexecuted'>        return</span>
 75 |     | <span class='unexecuted'>            !simulationReverted &amp;&amp;</span>
 76 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(simulationResponse)) ==</span>
 77 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(UpgradeSimulationFailed.selector));</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/UUPSProxy.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./AbstractProxy.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./ProxyStorage.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../errors/AddressError.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../utils/AddressUtil.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract UUPSProxy is AbstractProxy, ProxyStorage {</span>
 10 |     | <span class='unexecuted'>    constructor(address firstImplementation) {</span>
 11 |     | <span class='unexecuted'>        if (firstImplementation == address(0)) {</span>
 12 |     | <span class='unexecuted'>            revert AddressError.ZeroAddress();</span>
 13 |     | <span class='neutral'>        }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>        if (!AddressUtil.isContract(firstImplementation)) {</span>
 16 |     | <span class='unexecuted'>            revert AddressError.NotAContract(firstImplementation);</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>        _proxyStore().implementation = firstImplementation;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>    function _getImplementation() internal view virtual override returns (address) {</span>
 23 | *   | <span class='executed'>        return _proxyStore().implementation;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/UUPSProxyWithOwner.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {UUPSProxy} from &quot;./UUPSProxy.sol&quot;;</span>
  5 |     | <span class='neutral'>import {OwnableStorage} from &quot;../ownership/OwnableStorage.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract UUPSProxyWithOwner is UUPSProxy {</span>
  8 |     | <span class='neutral'>    // solhint-disable-next-line no-empty-blocks</span>
  9 |     | <span class='unexecuted'>    constructor(address firstImplementation, address initialOwner) UUPSProxy(firstImplementation) {</span>
 10 |     | <span class='unexecuted'>        OwnableStorage.load().owner = initialOwner;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/token/ERC20Helper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library ERC20Helper {</span>
  7 |     | <span class='neutral'>    error FailedTransfer(address from, address to, uint256 value);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function safeTransfer(address token, address to, uint256 value) internal {</span>
 10 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(</span>
 11 |     | <span class='unexecuted'>            abi.encodeWithSelector(IERC20.transfer.selector, to, value)</span>
 12 |     | <span class='neutral'>        );</span>
 13 |     | <span class='unexecuted'>        if (!success || (data.length != 0 &amp;&amp; !abi.decode(data, (bool)))) {</span>
 14 |     | <span class='unexecuted'>            revert FailedTransfer(address(this), to, value);</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function safeTransferFrom(address token, address from, address to, uint256 value) internal {</span>
 19 |     | <span class='neutral'>        (bool success, bytes memory data) = token.call(</span>
 20 |     | <span class='neutral'>            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)</span>
 21 |     | <span class='neutral'>        );</span>
 22 |     | <span class='neutral'>        if (!success || (data.length != 0 &amp;&amp; !abi.decode(data, (bool)))) {</span>
 23 |     | <span class='neutral'>            revert FailedTransfer(from, to, value);</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/AddressUtil.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library AddressUtil {</span>
  5 |     | <span class='unexecuted'>    function isContract(address account) internal view returns (bool) {</span>
  6 |     | <span class='neutral'>        uint256 size;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>        assembly {</span>
  9 |     | <span class='unexecuted'>            size := extcodesize(account)</span>
 10 |     | <span class='neutral'>        }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>        return size &gt; 0;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/DecimalMath.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title Utility library used to represent &quot;decimals&quot; (fixed point numbers) with integers, with two different levels of precision.</span>
   8 |     | <span class='neutral'> *</span>
   9 |     | <span class='neutral'> * They are represented by N * UNIT, where UNIT is the number of decimals of precision in the representation.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * Examples:</span>
  12 |     | <span class='neutral'> * 1) Given UNIT = 100</span>
  13 |     | <span class='neutral'> * then if A = 50, A represents the decimal 0.50</span>
  14 |     | <span class='neutral'> * 2) Given UNIT = 1000000000000000000</span>
  15 |     | <span class='neutral'> * then if A = 500000000000000000, A represents the decimal 0.500000000000000000</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * Note: An accompanying naming convention of the postfix &quot;D&lt;Precision&gt;&quot; is helpful with this utility. I.e. if a variable &quot;myValue&quot; represents a low resolution decimal, it should be named &quot;myValueD18&quot;, and if it was a high resolution decimal &quot;myValueD27&quot;. While scaling, intermediate precision decimals like &quot;myValue45&quot; could arise. Non-decimals should have no postfix, i.e. just &quot;myValue&quot;.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * Important: Multiplication and division operations are currently not supported for high precision decimals. Using these operations on them will yield incorrect results and fail silently.</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='unexecuted'>library DecimalMath {</span>
  22 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  23 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // solhint-disable numcast/safe-cast</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // Numbers representing 1.0 (low precision).</span>
  28 | *   | <span class='executed'>    uint256 public constant UNIT = 1e18;</span>
  29 |     | <span class='neutral'>    int256 public constant UNIT_INT = int256(UNIT);</span>
  30 |     | <span class='unexecuted'>    uint128 public constant UNIT_UINT128 = uint128(UNIT);</span>
  31 |     | <span class='unexecuted'>    int128 public constant UNIT_INT128 = int128(UNIT_INT);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    // Numbers representing 1.0 (high precision).</span>
  34 |     | <span class='unexecuted'>    uint256 public constant UNIT_PRECISE = 1e27;</span>
  35 |     | <span class='unexecuted'>    int256 public constant UNIT_PRECISE_INT = int256(UNIT_PRECISE);</span>
  36 |     | <span class='unexecuted'>    int128 public constant UNIT_PRECISE_INT128 = int128(UNIT_PRECISE_INT);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // Precision scaling, (used to scale down/up from one precision to the other).</span>
  39 |     | <span class='unexecuted'>    uint256 public constant PRECISION_FACTOR = 9; // 27 - 18 = 9 :)</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // solhint-enable numcast/safe-cast</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // -----------------</span>
  44 |     | <span class='neutral'>    // uint256</span>
  45 |     | <span class='neutral'>    // -----------------</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Multiplies two low precision decimals.</span>
  49 |     | <span class='neutral'>     *</span>
  50 |     | <span class='neutral'>     * Since the two numbers are assumed to be fixed point numbers,</span>
  51 |     | <span class='neutral'>     * (x * UNIT) * (y * UNIT) = x * y * UNIT ^ 2,</span>
  52 |     | <span class='neutral'>     * the result is divided by UNIT to remove double scaling.</span>
  53 |     | <span class='neutral'>     */</span>
  54 | *   | <span class='executed'>    function mulDecimal(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  55 | *   | <span class='executed'>        return (x * y) / UNIT;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @dev Divides two low precision decimals.</span>
  60 |     | <span class='neutral'>     *</span>
  61 |     | <span class='neutral'>     * Since the two numbers are assumed to be fixed point numbers,</span>
  62 |     | <span class='neutral'>     * (x * UNIT) / (y * UNIT) = x / y (Decimal representation is lost),</span>
  63 |     | <span class='neutral'>     * x is first scaled up to end up with a decimal representation.</span>
  64 |     | <span class='neutral'>     */</span>
  65 | *   | <span class='executed'>    function divDecimal(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  66 | *   | <span class='executed'>        return (x * UNIT) / y;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Scales up a value.</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * E.g. if value is not a decimal, a scale up by 18 makes it a low precision decimal.</span>
  73 |     | <span class='neutral'>     * If value is a low precision decimal, a scale up by 9 makes it a high precision decimal.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    function upscale(uint256 x, uint256 factor) internal pure returns (uint256) {</span>
  76 |     | <span class='neutral'>        return x * 10 ** factor;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev Scales down a value.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * E.g. if value is a high precision decimal, a scale down by 9 makes it a low precision decimal.</span>
  83 |     | <span class='neutral'>     * If value is a low precision decimal, a scale down by 9 makes it a regular integer.</span>
  84 |     | <span class='neutral'>     *</span>
  85 |     | <span class='neutral'>     * Scaling down a regular integer would not make sense.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    function downscale(uint256 x, uint256 factor) internal pure returns (uint256) {</span>
  88 |     | <span class='neutral'>        return x / 10 ** factor;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    // -----------------</span>
  92 |     | <span class='neutral'>    // uint128</span>
  93 |     | <span class='neutral'>    // -----------------</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    // Note: Overloading doesn&#39;t seem to work for similar types, i.e. int256 and int128, uint256 and uint128, etc, so explicitly naming the functions differently here.</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @dev See mulDecimal for uint256.</span>
  99 |     | <span class='neutral'>     */</span>
 100 | *   | <span class='executed'>    function mulDecimalUint128(uint128 x, uint128 y) internal pure returns (uint128) {</span>
 101 | *   | <span class='executed'>        return (x * y) / UNIT_UINT128;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /**</span>
 105 |     | <span class='neutral'>     * @dev See divDecimal for uint256.</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function divDecimalUint128(uint128 x, uint128 y) internal pure returns (uint128) {</span>
 108 |     | <span class='neutral'>        return (x * UNIT_UINT128) / y;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev See upscale for uint256.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function upscaleUint128(uint128 x, uint256 factor) internal pure returns (uint128) {</span>
 115 |     | <span class='neutral'>        return x * (10 ** factor).to128();</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @dev See downscale for uint256.</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    function downscaleUint128(uint128 x, uint256 factor) internal pure returns (uint128) {</span>
 122 |     | <span class='neutral'>        return x / (10 ** factor).to128();</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    // -----------------</span>
 126 |     | <span class='neutral'>    // int256</span>
 127 |     | <span class='neutral'>    // -----------------</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev See mulDecimal for uint256.</span>
 131 |     | <span class='neutral'>     */</span>
 132 | *   | <span class='executed'>    function mulDecimal(int256 x, int256 y) internal pure returns (int256) {</span>
 133 | *   | <span class='executed'>        return (x * y) / UNIT_INT;</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /**</span>
 137 |     | <span class='neutral'>     * @dev See divDecimal for uint256.</span>
 138 |     | <span class='neutral'>     */</span>
 139 | *   | <span class='executed'>    function divDecimal(int256 x, int256 y) internal pure returns (int256) {</span>
 140 | *   | <span class='executed'>        return (x * UNIT_INT) / y;</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @dev See upscale for uint256.</span>
 145 |     | <span class='neutral'>     */</span>
 146 |     | <span class='neutral'>    function upscale(int256 x, uint256 factor) internal pure returns (int256) {</span>
 147 |     | <span class='neutral'>        return x * (10 ** factor).toInt();</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /**</span>
 151 |     | <span class='neutral'>     * @dev See downscale for uint256.</span>
 152 |     | <span class='neutral'>     */</span>
 153 |     | <span class='neutral'>    function downscale(int256 x, uint256 factor) internal pure returns (int256) {</span>
 154 |     | <span class='neutral'>        return x / (10 ** factor).toInt();</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    // -----------------</span>
 158 |     | <span class='neutral'>    // int128</span>
 159 |     | <span class='neutral'>    // -----------------</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev See mulDecimal for uint256.</span>
 163 |     | <span class='neutral'>     */</span>
 164 |     | <span class='neutral'>    function mulDecimalInt128(int128 x, int128 y) internal pure returns (int128) {</span>
 165 |     | <span class='neutral'>        return (x * y) / UNIT_INT128;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /**</span>
 169 |     | <span class='neutral'>     * @dev See divDecimal for uint256.</span>
 170 |     | <span class='neutral'>     */</span>
 171 |     | <span class='neutral'>    function divDecimalInt128(int128 x, int128 y) internal pure returns (int128) {</span>
 172 |     | <span class='neutral'>        return (x * UNIT_INT128) / y;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     * @dev See upscale for uint256.</span>
 177 |     | <span class='neutral'>     */</span>
 178 |     | <span class='neutral'>    function upscaleInt128(int128 x, uint256 factor) internal pure returns (int128) {</span>
 179 |     | <span class='neutral'>        return x * ((10 ** factor).toInt()).to128();</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /**</span>
 183 |     | <span class='neutral'>     * @dev See downscale for uint256.</span>
 184 |     | <span class='neutral'>     */</span>
 185 |     | <span class='neutral'>    function downscaleInt128(int128 x, uint256 factor) internal pure returns (int128) {</span>
 186 |     | <span class='neutral'>        return x / ((10 ** factor).toInt().to128());</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'>}</span>
 189 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../interfaces/IERC165.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library ERC165Helper {</span>
  7 | *   | <span class='executed'>    function safeSupportsInterface(</span>
  8 |     | <span class='neutral'>        address candidate,</span>
  9 |     | <span class='neutral'>        bytes4 interfaceID</span>
 10 |     | <span class='unexecuted'>    ) internal returns (bool supportsInterface) {</span>
 11 |     | <span class='unexecuted'>        (bool success, bytes memory response) = candidate.call(</span>
 12 |     | <span class='unexecuted'>            abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceID)</span>
 13 |     | <span class='neutral'>        );</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>        if (!success) {</span>
 16 |     | <span class='unexecuted'>            return false;</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>        if (response.length == 0) {</span>
 20 |     | <span class='unexecuted'>            return false;</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>        assembly {</span>
 24 |     | <span class='unexecuted'>            supportsInterface := mload(add(response, 32))</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/* solhint-disable meta-transactions/no-msg-sender */</span>
  5 |     | <span class='neutral'>/* solhint-disable meta-transactions/no-msg-data */</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library ERC2771Context {</span>
  8 |     | <span class='neutral'>    // This is the trusted-multicall-forwarder. The address is constant due to CREATE2.</span>
  9 | *   | <span class='executed'>    address private constant TRUSTED_FORWARDER = 0xE2C5658cC5C448B48141168f3e475dF8f65A1e3e;</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>    function _msgSender() internal view returns (address sender) {</span>
 12 | *   | <span class='executed'>        if (isTrustedForwarder(msg.sender) &amp;&amp; msg.data.length &gt;= 20) {</span>
 13 |     | <span class='neutral'>            // The assembly code is more direct than the Solidity version using `abi.decode`.</span>
 14 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 15 |     | <span class='neutral'>            assembly {</span>
 16 |     | <span class='unexecuted'>                sender := shr(96, calldataload(sub(calldatasize(), 20)))</span>
 17 |     | <span class='neutral'>            }</span>
 18 |     | <span class='neutral'>        } else {</span>
 19 | *   | <span class='executed'>            return msg.sender;</span>
 20 |     | <span class='neutral'>        }</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function _msgData() internal view returns (bytes calldata) {</span>
 24 |     | <span class='neutral'>        if (isTrustedForwarder(msg.sender) &amp;&amp; msg.data.length &gt;= 20) {</span>
 25 |     | <span class='neutral'>            return msg.data[:msg.data.length - 20];</span>
 26 |     | <span class='neutral'>        } else {</span>
 27 |     | <span class='neutral'>            return msg.data;</span>
 28 |     | <span class='neutral'>        }</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function isTrustedForwarder(address forwarder) internal pure returns (bool) {</span>
 32 | *   | <span class='executed'>        return forwarder == TRUSTED_FORWARDER;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function trustedForwarder() internal pure returns (address) {</span>
 36 |     | <span class='neutral'>        return TRUSTED_FORWARDER;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/HeapUtil.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Eth Heap</span>
   5 |     | <span class='neutral'>// Author: Zac Mitton</span>
   6 |     | <span class='neutral'>// License: MIT</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library HeapUtil {</span>
   9 |     | <span class='neutral'>    // default max-heap</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    uint256 private constant _ROOT_INDEX = 1;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    struct Data {</span>
  14 |     | <span class='neutral'>        uint128 idCount;</span>
  15 |     | <span class='neutral'>        Node[] nodes; // root is index 1; index 0 not used</span>
  16 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) indices; // unique id =&gt; node index</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'>    struct Node {</span>
  19 |     | <span class='neutral'>        uint128 id; //use with another mapping to store arbitrary object types</span>
  20 |     | <span class='neutral'>        int128 priority;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    //call init before anything else</span>
  24 |     | <span class='neutral'>    function init(Data storage self) internal {</span>
  25 |     | <span class='neutral'>        if (self.nodes.length == 0) self.nodes.push(Node(0, 0));</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function insert(Data storage self, uint128 id, int128 priority) internal returns (Node memory) {</span>
  29 |     | <span class='neutral'>        //√</span>
  30 |     | <span class='neutral'>        if (self.nodes.length == 0) {</span>
  31 |     | <span class='neutral'>            init(self);</span>
  32 |     | <span class='neutral'>        } // test on-the-fly-init</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>        Node memory n;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        // MODIFIED: support updates</span>
  37 |     | <span class='neutral'>        extractById(self, id);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        self.idCount++;</span>
  40 |     | <span class='neutral'>        self.nodes.push();</span>
  41 |     | <span class='neutral'>        n = Node(id, priority);</span>
  42 |     | <span class='neutral'>        _bubbleUp(self, n, self.nodes.length - 1);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        return n;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    function extractMax(Data storage self) internal returns (Node memory) {</span>
  48 |     | <span class='neutral'>        //√</span>
  49 |     | <span class='neutral'>        return _extract(self, _ROOT_INDEX);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function extractById(Data storage self, uint128 id) internal returns (Node memory) {</span>
  53 |     | <span class='neutral'>        //√</span>
  54 |     | <span class='neutral'>        return _extract(self, self.indices[id]);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    //view</span>
  58 |     | <span class='neutral'>    function dump(Data storage self) internal view returns (Node[] memory) {</span>
  59 |     | <span class='neutral'>        //note: Empty set will return `[Node(0,0)]`. uninitialized will return `[]`.</span>
  60 |     | <span class='neutral'>        return self.nodes;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function getById(Data storage self, uint128 id) internal view returns (Node memory) {</span>
  64 |     | <span class='neutral'>        return getByIndex(self, self.indices[id]); //test that all these return the emptyNode</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function getByIndex(Data storage self, uint256 i) internal view returns (Node memory) {</span>
  68 |     | <span class='neutral'>        return self.nodes.length &gt; i ? self.nodes[i] : Node(0, 0);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function getMax(Data storage self) internal view returns (Node memory) {</span>
  72 |     | <span class='neutral'>        return getByIndex(self, _ROOT_INDEX);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function size(Data storage self) internal view returns (uint256) {</span>
  76 |     | <span class='neutral'>        return self.nodes.length &gt; 0 ? self.nodes.length - 1 : 0;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function isNode(Node memory n) internal pure returns (bool) {</span>
  80 |     | <span class='neutral'>        return n.id &gt; 0;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    //private</span>
  84 |     | <span class='neutral'>    function _extract(Data storage self, uint256 i) private returns (Node memory) {</span>
  85 |     | <span class='neutral'>        //√</span>
  86 |     | <span class='neutral'>        if (self.nodes.length &lt;= i || i &lt;= 0) {</span>
  87 |     | <span class='neutral'>            return Node(0, 0);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        Node memory extractedNode = self.nodes[i];</span>
  91 |     | <span class='neutral'>        delete self.indices[extractedNode.id];</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        Node memory tailNode = self.nodes[self.nodes.length - 1];</span>
  94 |     | <span class='neutral'>        self.nodes.pop();</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        if (i &lt; self.nodes.length) {</span>
  97 |     | <span class='neutral'>            // if extracted node was not tail</span>
  98 |     | <span class='neutral'>            _bubbleUp(self, tailNode, i);</span>
  99 |     | <span class='neutral'>            _bubbleDown(self, self.nodes[i], i); // then try bubbling down</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>        return extractedNode;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function _bubbleUp(Data storage self, Node memory n, uint256 i) private {</span>
 105 |     | <span class='neutral'>        //√</span>
 106 |     | <span class='neutral'>        if (i == _ROOT_INDEX || n.priority &lt;= self.nodes[i / 2].priority) {</span>
 107 |     | <span class='neutral'>            _insert(self, n, i);</span>
 108 |     | <span class='neutral'>        } else {</span>
 109 |     | <span class='neutral'>            _insert(self, self.nodes[i / 2], i);</span>
 110 |     | <span class='neutral'>            _bubbleUp(self, n, i / 2);</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function _bubbleDown(Data storage self, Node memory n, uint256 i) private {</span>
 115 |     | <span class='neutral'>        //</span>
 116 |     | <span class='neutral'>        uint256 length = self.nodes.length;</span>
 117 |     | <span class='neutral'>        uint256 cIndex = i * 2; // left child index</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        if (length &lt;= cIndex) {</span>
 120 |     | <span class='neutral'>            _insert(self, n, i);</span>
 121 |     | <span class='neutral'>        } else {</span>
 122 |     | <span class='neutral'>            Node memory largestChild = self.nodes[cIndex];</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>            if (length &gt; cIndex + 1 &amp;&amp; self.nodes[cIndex + 1].priority &gt; largestChild.priority) {</span>
 125 |     | <span class='neutral'>                largestChild = self.nodes[++cIndex]; // TEST ++ gets executed first here</span>
 126 |     | <span class='neutral'>            }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>            if (largestChild.priority &lt;= n.priority) {</span>
 129 |     | <span class='neutral'>                //TEST: priority 0 is valid! negative ints work</span>
 130 |     | <span class='neutral'>                _insert(self, n, i);</span>
 131 |     | <span class='neutral'>            } else {</span>
 132 |     | <span class='neutral'>                _insert(self, largestChild, i);</span>
 133 |     | <span class='neutral'>                _bubbleDown(self, n, cIndex);</span>
 134 |     | <span class='neutral'>            }</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function _insert(Data storage self, Node memory n, uint256 i) private {</span>
 139 |     | <span class='neutral'>        //√</span>
 140 |     | <span class='neutral'>        self.nodes[i] = n;</span>
 141 |     | <span class='neutral'>        self.indices[n.id] = i;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * Utilities that convert numeric types avoiding silent overflows.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastU32.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastI32.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastI24.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastU56.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastI56.sol&quot;;</span>
 12 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastU64.sol&quot;;</span>
 13 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastI64.sol&quot;;</span>
 14 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastI128.sol&quot;;</span>
 15 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastI256.sol&quot;;</span>
 16 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastU128.sol&quot;;</span>
 17 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastU160.sol&quot;;</span>
 18 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastU256.sol&quot;;</span>
 19 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastAddress.sol&quot;;</span>
 20 |     | <span class='neutral'>import &quot;./SafeCast/SafeCastBytes32.sol&quot;;</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastAddress.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastAddress {</span>
  8 |     | <span class='neutral'>    function toBytes32(address x) internal pure returns (bytes32) {</span>
  9 |     | <span class='neutral'>        return bytes32(uint256(uint160(x)));</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastBytes32.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastBytes32 {</span>
  8 |     | <span class='neutral'>    function toAddress(bytes32 x) internal pure returns (address) {</span>
  9 |     | <span class='neutral'>        return address(uint160(uint256(x)));</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    function toUint(bytes32 x) internal pure returns (uint) {</span>
 13 | *   | <span class='executed'>        return uint(x);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI128.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastI128 {</span>
  8 |     | <span class='neutral'>    error OverflowInt128ToUint128();</span>
  9 |     | <span class='neutral'>    error OverflowInt128ToInt32();</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>    function toUint(int128 x) internal pure returns (uint128) {</span>
 12 |     | <span class='neutral'>        // ----------------&lt;==============o==============&gt;-----------------</span>
 13 |     | <span class='neutral'>        // ----------------xxxxxxxxxxxxxxxo===============&gt;----------------</span>
 14 | *   | <span class='executed'>        if (x &lt; 0) {</span>
 15 |     | <span class='unexecuted'>            revert OverflowInt128ToUint128();</span>
 16 |     | <span class='neutral'>        }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>        return uint128(x);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function to256(int128 x) internal pure returns (int256) {</span>
 22 |     | <span class='neutral'>        return int256(x);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function to32(int128 x) internal pure returns (int32) {</span>
 26 |     | <span class='neutral'>        // ----------------&lt;==============o==============&gt;-----------------</span>
 27 |     | <span class='neutral'>        // ----------------xxxxxxxxxxxx&lt;==o==&gt;xxxxxxxxxxxx-----------------</span>
 28 |     | <span class='neutral'>        if (x &lt; int256(type(int32).min) || x &gt; int256(type(int32).max)) {</span>
 29 |     | <span class='neutral'>            revert OverflowInt128ToInt32();</span>
 30 |     | <span class='neutral'>        }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>        return int32(x);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function zero() internal pure returns (int128) {</span>
 36 |     | <span class='neutral'>        return int128(0);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI24.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastI24 {</span>
  8 |     | <span class='neutral'>    function to256(int24 x) internal pure returns (int256) {</span>
  9 |     | <span class='neutral'>        return int256(x);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI256.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastI256 {</span>
  8 |     | <span class='neutral'>    error OverflowInt256ToUint256();</span>
  9 |     | <span class='neutral'>    error OverflowInt256ToInt128();</span>
 10 |     | <span class='neutral'>    error OverflowInt256ToInt24();</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    function to128(int256 x) internal pure returns (int128) {</span>
 13 |     | <span class='neutral'>        // ----&lt;==========================o===========================&gt;----</span>
 14 |     | <span class='neutral'>        // ----xxxxxxxxxxxx&lt;==============o==============&gt;xxxxxxxxxxxxx----</span>
 15 | *   | <span class='executed'>        if (x &lt; int256(type(int128).min) || x &gt; int256(type(int128).max)) {</span>
 16 |     | <span class='unexecuted'>            revert OverflowInt256ToInt128();</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>        return int128(x);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function to24(int256 x) internal pure returns (int24) {</span>
 23 |     | <span class='neutral'>        // ----&lt;==========================o===========================&gt;----</span>
 24 |     | <span class='neutral'>        // ----xxxxxxxxxxxxxxxxxxxx&lt;======o=======&gt;xxxxxxxxxxxxxxxxxxxx----</span>
 25 |     | <span class='neutral'>        if (x &lt; int256(type(int24).min) || x &gt; int256(type(int24).max)) {</span>
 26 |     | <span class='neutral'>            revert OverflowInt256ToInt24();</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>        return int24(x);</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 | *   | <span class='executed'>    function toUint(int256 x) internal pure returns (uint256) {</span>
 33 |     | <span class='neutral'>        // ----&lt;==========================o===========================&gt;----</span>
 34 |     | <span class='neutral'>        // ----xxxxxxxxxxxxxxxxxxxxxxxxxxxo===============================&gt;</span>
 35 | *   | <span class='executed'>        if (x &lt; 0) {</span>
 36 |     | <span class='unexecuted'>            revert OverflowInt256ToUint256();</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'></span>
 39 | *   | <span class='executed'>        return uint256(x);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function zero() internal pure returns (int256) {</span>
 43 |     | <span class='neutral'>        return int256(0);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI32.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastI32 {</span>
  8 |     | <span class='neutral'>    error OverflowInt32ToUint32();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function toUint(int32 x) internal pure returns (uint32) {</span>
 11 |     | <span class='neutral'>        // ----------------------&lt;========o========&gt;----------------------</span>
 12 |     | <span class='neutral'>        // ----------------------xxxxxxxxxo=========&gt;----------------------</span>
 13 |     | <span class='neutral'>        if (x &lt; 0) {</span>
 14 |     | <span class='neutral'>            revert OverflowInt32ToUint32();</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        return uint32(x);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI56.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastI56 {</span>
  8 |     | <span class='neutral'>    error OverflowInt56ToInt24();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function to24(int56 x) internal pure returns (int24) {</span>
 11 |     | <span class='neutral'>        // ----------------------&lt;========o========&gt;-----------------------</span>
 12 |     | <span class='neutral'>        // ----------------------xxx&lt;=====o=====&gt;xxx-----------------------</span>
 13 |     | <span class='neutral'>        if (x &lt; int256(type(int24).min) || x &gt; int256(type(int24).max)) {</span>
 14 |     | <span class='neutral'>            revert OverflowInt56ToInt24();</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        return int24(x);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI64.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastI64 {</span>
  8 |     | <span class='neutral'>    error OverflowInt64ToUint64();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function toUint(int64 x) internal pure returns (uint64) {</span>
 11 |     | <span class='neutral'>        // ----------------------&lt;========o========&gt;----------------------</span>
 12 |     | <span class='neutral'>        // ----------------------xxxxxxxxxo=========&gt;----------------------</span>
 13 |     | <span class='neutral'>        if (x &lt; 0) {</span>
 14 |     | <span class='neutral'>            revert OverflowInt64ToUint64();</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        return uint64(x);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU128.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastU128 {</span>
  8 |     | <span class='neutral'>    error OverflowUint128ToInt128();</span>
  9 |     | <span class='neutral'></span>
 10 | *   | <span class='executed'>    function to256(uint128 x) internal pure returns (uint256) {</span>
 11 |     | <span class='neutral'>        return uint256(x);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>    function toInt(uint128 x) internal pure returns (int128) {</span>
 15 |     | <span class='neutral'>        // -------------------------------o===============&gt;----------------</span>
 16 |     | <span class='neutral'>        // ----------------&lt;==============o==============&gt;x----------------</span>
 17 | *   | <span class='executed'>        if (x &gt; uint128(type(int128).max)) {</span>
 18 |     | <span class='unexecuted'>            revert OverflowUint128ToInt128();</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>        return int128(x);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function toBytes32(uint128 x) internal pure returns (bytes32) {</span>
 25 |     | <span class='neutral'>        return bytes32(uint256(x));</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU160.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastU160 {</span>
  8 |     | <span class='neutral'>    function to256(uint160 x) internal pure returns (uint256) {</span>
  9 |     | <span class='neutral'>        return uint256(x);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU256.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastU256 {</span>
  8 |     | <span class='neutral'>    error OverflowUint256ToUint128();</span>
  9 |     | <span class='neutral'>    error OverflowUint256ToInt256();</span>
 10 |     | <span class='neutral'>    error OverflowUint256ToUint64();</span>
 11 |     | <span class='neutral'>    error OverflowUint256ToUint32();</span>
 12 |     | <span class='neutral'>    error OverflowUint256ToUint160();</span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>    function to128(uint256 x) internal pure returns (uint128) {</span>
 15 |     | <span class='neutral'>        // -------------------------------o===============================&gt;</span>
 16 |     | <span class='neutral'>        // -------------------------------o===============&gt;xxxxxxxxxxxxxxxx</span>
 17 | *   | <span class='executed'>        if (x &gt; type(uint128).max) {</span>
 18 |     | <span class='unexecuted'>            revert OverflowUint256ToUint128();</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>        return uint128(x);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 | *   | <span class='executed'>    function to64(uint256 x) internal pure returns (uint64) {</span>
 25 |     | <span class='neutral'>        // -------------------------------o===============================&gt;</span>
 26 |     | <span class='neutral'>        // -------------------------------o======&gt;xxxxxxxxxxxxxxxxxxxxxxxxx</span>
 27 | *   | <span class='executed'>        if (x &gt; type(uint64).max) {</span>
 28 |     | <span class='unexecuted'>            revert OverflowUint256ToUint64();</span>
 29 |     | <span class='neutral'>        }</span>
 30 |     | <span class='neutral'></span>
 31 | *   | <span class='executed'>        return uint64(x);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function to32(uint256 x) internal pure returns (uint32) {</span>
 35 |     | <span class='neutral'>        // -------------------------------o===============================&gt;</span>
 36 |     | <span class='neutral'>        // -------------------------------o===&gt;xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span>
 37 |     | <span class='neutral'>        if (x &gt; type(uint32).max) {</span>
 38 |     | <span class='neutral'>            revert OverflowUint256ToUint32();</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return uint32(x);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function to160(uint256 x) internal pure returns (uint160) {</span>
 45 |     | <span class='neutral'>        // -------------------------------o===============================&gt;</span>
 46 |     | <span class='neutral'>        // -------------------------------o==================&gt;xxxxxxxxxxxxx</span>
 47 |     | <span class='neutral'>        if (x &gt; type(uint160).max) {</span>
 48 |     | <span class='neutral'>            revert OverflowUint256ToUint160();</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>        return uint160(x);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function toBytes32(uint256 x) internal pure returns (bytes32) {</span>
 55 |     | <span class='neutral'>        return bytes32(x);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 | *   | <span class='executed'>    function toInt(uint256 x) internal pure returns (int256) {</span>
 59 |     | <span class='neutral'>        // -------------------------------o===============================&gt;</span>
 60 |     | <span class='neutral'>        // ----&lt;==========================o===========================&gt;xxxx</span>
 61 | *   | <span class='executed'>        if (x &gt; uint256(type(int256).max)) {</span>
 62 |     | <span class='unexecuted'>            revert OverflowUint256ToInt256();</span>
 63 |     | <span class='neutral'>        }</span>
 64 |     | <span class='neutral'></span>
 65 | *   | <span class='executed'>        return int256(x);</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU32.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastU32 {</span>
  8 |     | <span class='neutral'>    error OverflowUint32ToInt32();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function toInt(uint32 x) internal pure returns (int32) {</span>
 11 |     | <span class='neutral'>        // -------------------------------o=========&gt;----------------------</span>
 12 |     | <span class='neutral'>        // ----------------------&lt;========o========&gt;x----------------------</span>
 13 |     | <span class='neutral'>        if (x &gt; uint32(type(int32).max)) {</span>
 14 |     | <span class='neutral'>            revert OverflowUint32ToInt32();</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        return int32(x);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function to256(uint32 x) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        return uint256(x);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function to56(uint32 x) internal pure returns (uint56) {</span>
 25 |     | <span class='neutral'>        return uint56(x);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU56.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastU56 {</span>
  8 |     | <span class='neutral'>    error OverflowUint56ToInt56();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function toInt(uint56 x) internal pure returns (int56) {</span>
 11 |     | <span class='neutral'>        // -------------------------------o=========&gt;----------------------</span>
 12 |     | <span class='neutral'>        // ----------------------&lt;========o========&gt;x----------------------</span>
 13 |     | <span class='neutral'>        if (x &gt; uint56(type(int56).max)) {</span>
 14 |     | <span class='neutral'>            revert OverflowUint56ToInt56();</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        return int56(x);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU64.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title See SafeCast.sol.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library SafeCastU64 {</span>
  8 |     | <span class='neutral'>    error OverflowUint64ToInt64();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function toInt(uint64 x) internal pure returns (int64) {</span>
 11 |     | <span class='neutral'>        // -------------------------------o=========&gt;----------------------</span>
 12 |     | <span class='neutral'>        // ----------------------&lt;========o========&gt;x----------------------</span>
 13 |     | <span class='neutral'>        if (x &gt; uint64(type(int64).max)) {</span>
 14 |     | <span class='neutral'>            revert OverflowUint64ToInt64();</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        return int64(x);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function to256(uint64 x) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        return uint256(x);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SetUtil.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library SetUtil {</span>
   7 |     | <span class='neutral'>    using SafeCastAddress for address;</span>
   8 |     | <span class='neutral'>    using SafeCastBytes32 for bytes32;</span>
   9 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    // ----------------------------------------</span>
  12 |     | <span class='neutral'>    // Uint support</span>
  13 |     | <span class='neutral'>    // ----------------------------------------</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    struct UintSet {</span>
  16 |     | <span class='neutral'>        Bytes32Set raw;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 | *   | <span class='executed'>    function add(UintSet storage set, uint256 value) internal {</span>
  20 | *   | <span class='executed'>        add(set.raw, value.toBytes32());</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>    function remove(UintSet storage set, uint256 value) internal {</span>
  24 | *   | <span class='executed'>        remove(set.raw, value.toBytes32());</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function replace(UintSet storage set, uint256 value, uint256 newValue) internal {</span>
  28 |     | <span class='neutral'>        replace(set.raw, value.toBytes32(), newValue.toBytes32());</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    function contains(UintSet storage set, uint256 value) internal view returns (bool) {</span>
  32 | *   | <span class='executed'>        return contains(set.raw, value.toBytes32());</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 | *   | <span class='executed'>    function length(UintSet storage set) internal view returns (uint256) {</span>
  36 | *   | <span class='executed'>        return length(set.raw);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>    function valueAt(UintSet storage set, uint256 position) internal view returns (uint256) {</span>
  40 | *   | <span class='executed'>        return valueAt(set.raw, position).toUint();</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function positionOf(UintSet storage set, uint256 value) internal view returns (uint256) {</span>
  44 |     | <span class='neutral'>        return positionOf(set.raw, value.toBytes32());</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>    function values(UintSet storage set) internal view returns (uint256[] memory) {</span>
  48 | *   | <span class='executed'>        bytes32[] memory store = values(set.raw);</span>
  49 |     | <span class='neutral'>        uint256[] memory result;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        assembly {</span>
  52 |     | <span class='neutral'>            result := store</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        return result;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    // ----------------------------------------</span>
  59 |     | <span class='neutral'>    // Address support</span>
  60 |     | <span class='neutral'>    // ----------------------------------------</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    struct AddressSet {</span>
  63 |     | <span class='neutral'>        Bytes32Set raw;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function add(AddressSet storage set, address value) internal {</span>
  67 |     | <span class='unexecuted'>        add(set.raw, value.toBytes32());</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function remove(AddressSet storage set, address value) internal {</span>
  71 |     | <span class='unexecuted'>        remove(set.raw, value.toBytes32());</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function replace(AddressSet storage set, address value, address newValue) internal {</span>
  75 |     | <span class='neutral'>        replace(set.raw, value.toBytes32(), newValue.toBytes32());</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 | *   | <span class='executed'>    function contains(AddressSet storage set, address value) internal view returns (bool) {</span>
  79 | *   | <span class='executed'>        return contains(set.raw, value.toBytes32());</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function length(AddressSet storage set) internal view returns (uint256) {</span>
  83 |     | <span class='neutral'>        return length(set.raw);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function valueAt(AddressSet storage set, uint256 position) internal view returns (address) {</span>
  87 |     | <span class='neutral'>        return valueAt(set.raw, position).toAddress();</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function positionOf(AddressSet storage set, address value) internal view returns (uint256) {</span>
  91 |     | <span class='neutral'>        return positionOf(set.raw, value.toBytes32());</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>    function values(AddressSet storage set) internal view returns (address[] memory) {</span>
  95 |     | <span class='unexecuted'>        bytes32[] memory store = values(set.raw);</span>
  96 |     | <span class='neutral'>        address[] memory result;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        assembly {</span>
  99 |     | <span class='neutral'>            result := store</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        return result;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    // ----------------------------------------</span>
 106 |     | <span class='neutral'>    // Core bytes32 support</span>
 107 |     | <span class='neutral'>    // ----------------------------------------</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    error PositionOutOfBounds();</span>
 110 |     | <span class='neutral'>    error ValueNotInSet();</span>
 111 |     | <span class='neutral'>    error ValueAlreadyInSet();</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    struct Bytes32Set {</span>
 114 |     | <span class='neutral'>        bytes32[] _values;</span>
 115 |     | <span class='neutral'>        mapping(bytes32 =&gt; uint256) _positions; // Position zero is never used.</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>    function add(Bytes32Set storage set, bytes32 value) internal {</span>
 119 | *   | <span class='executed'>        if (contains(set, value)) {</span>
 120 |     | <span class='unexecuted'>            revert ValueAlreadyInSet();</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>        set._values.push(value);</span>
 124 | *   | <span class='executed'>        set._positions[value] = set._values.length;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>    function remove(Bytes32Set storage set, bytes32 value) internal {</span>
 128 | *   | <span class='executed'>        uint256 position = set._positions[value];</span>
 129 | *   | <span class='executed'>        if (position == 0) {</span>
 130 |     | <span class='unexecuted'>            revert ValueNotInSet();</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 | *   | <span class='executed'>        uint256 index = position - 1;</span>
 134 | *   | <span class='executed'>        uint256 lastIndex = set._values.length - 1;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // If the element being deleted is not the last in the values,</span>
 137 |     | <span class='neutral'>        // move the last element to its position.</span>
 138 | *   | <span class='executed'>        if (index != lastIndex) {</span>
 139 | *   | <span class='executed'>            bytes32 lastValue = set._values[lastIndex];</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>            set._values[index] = lastValue;</span>
 142 | *   | <span class='executed'>            set._positions[lastValue] = position;</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        // Remove the last element in the values.</span>
 146 | *   | <span class='executed'>        set._values.pop();</span>
 147 | *   | <span class='executed'>        delete set._positions[value];</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function replace(Bytes32Set storage set, bytes32 value, bytes32 newValue) internal {</span>
 151 |     | <span class='neutral'>        if (!contains(set, value)) {</span>
 152 |     | <span class='neutral'>            revert ValueNotInSet();</span>
 153 |     | <span class='neutral'>        }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        if (contains(set, newValue)) {</span>
 156 |     | <span class='neutral'>            revert ValueAlreadyInSet();</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>        uint256 position = set._positions[value];</span>
 160 |     | <span class='neutral'>        delete set._positions[value];</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        uint256 index = position - 1;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        set._values[index] = newValue;</span>
 165 |     | <span class='neutral'>        set._positions[newValue] = position;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 | *   | <span class='executed'>    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {</span>
 169 | *   | <span class='executed'>        return set._positions[value] != 0;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 | *   | <span class='executed'>    function length(Bytes32Set storage set) internal view returns (uint256) {</span>
 173 | *   | <span class='executed'>        return set._values.length;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 | *   | <span class='executed'>    function valueAt(Bytes32Set storage set, uint256 position) internal view returns (bytes32) {</span>
 177 | *   | <span class='executed'>        if (position == 0 || position &gt; set._values.length) {</span>
 178 |     | <span class='unexecuted'>            revert PositionOutOfBounds();</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'></span>
 181 | *   | <span class='executed'>        uint256 index = position - 1;</span>
 182 |     | <span class='neutral'></span>
 183 | *   | <span class='executed'>        return set._values[index];</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function positionOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {</span>
 187 |     | <span class='neutral'>        if (!contains(set, value)) {</span>
 188 |     | <span class='neutral'>            revert ValueNotInSet();</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        return set._positions[value];</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 | *   | <span class='executed'>    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {</span>
 195 | *   | <span class='executed'>        return set._values;</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'>}</span>
 198 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/IAssociatedSystemsModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Module for connecting a system with other associated systems.</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'> * Associated systems become available to all system modules for communication and interaction, but as opposed to inter-modular communications, interactions with associated systems will require the use of `CALL`.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Associated systems can be managed or unmanaged.</span>
 10 |     | <span class='neutral'> * - Managed systems are connected via a proxy, which means that their implementation can be updated, and the system controls the execution context of the associated system. Example, an snxUSD token connected to the system, and controlled by the system.</span>
 11 |     | <span class='neutral'> * - Unmanaged systems are just addresses tracked by the system, for which it has no control whatsoever. Example, Uniswap v3, Curve, etc.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * Furthermore, associated systems are typed in the AssociatedSystem utility library (See AssociatedSystem.sol):</span>
 14 |     | <span class='neutral'> * - KIND_ERC20: A managed associated system specifically wrapping an ERC20 implementation.</span>
 15 |     | <span class='neutral'> * - KIND_ERC721: A managed associated system specifically wrapping an ERC721 implementation.</span>
 16 |     | <span class='neutral'> * - KIND_UNMANAGED: Any unmanaged associated system.</span>
 17 |     | <span class='neutral'> */</span>
 18 |     | <span class='neutral'>interface IAssociatedSystemsModule {</span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @notice Emitted when an associated system is set.</span>
 21 |     | <span class='neutral'>     * @param kind The type of associated system (managed ERC20, managed ERC721, unmanaged, etc - See the AssociatedSystem util).</span>
 22 |     | <span class='neutral'>     * @param id The bytes32 identifier of the associated system.</span>
 23 |     | <span class='neutral'>     * @param proxy The main external contract address of the associated system.</span>
 24 |     | <span class='neutral'>     * @param impl The address of the implementation of the associated system (if not behind a proxy, will equal `proxy`).</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    event AssociatedSystemSet(</span>
 27 |     | <span class='neutral'>        bytes32 indexed kind,</span>
 28 |     | <span class='neutral'>        bytes32 indexed id,</span>
 29 |     | <span class='neutral'>        address proxy,</span>
 30 |     | <span class='neutral'>        address impl</span>
 31 |     | <span class='neutral'>    );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /**</span>
 34 |     | <span class='neutral'>     * @notice Emitted when the function you are calling requires an associated system, but it</span>
 35 |     | <span class='neutral'>     * has not been registered</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    error MissingAssociatedSystem(bytes32 id);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @notice Creates or initializes a managed associated ERC20 token.</span>
 41 |     | <span class='neutral'>     * @param id The bytes32 identifier of the associated system. If the id is new to the system, it will create a new proxy for the associated system.</span>
 42 |     | <span class='neutral'>     * @param name The token name that will be used to initialize the proxy.</span>
 43 |     | <span class='neutral'>     * @param symbol The token symbol that will be used to initialize the proxy.</span>
 44 |     | <span class='neutral'>     * @param decimals The token decimals that will be used to initialize the proxy.</span>
 45 |     | <span class='neutral'>     * @param impl The ERC20 implementation of the proxy.</span>
 46 |     | <span class='neutral'>     */</span>
 47 |     | <span class='neutral'>    function initOrUpgradeToken(</span>
 48 |     | <span class='neutral'>        bytes32 id,</span>
 49 |     | <span class='neutral'>        string memory name,</span>
 50 |     | <span class='neutral'>        string memory symbol,</span>
 51 |     | <span class='neutral'>        uint8 decimals,</span>
 52 |     | <span class='neutral'>        address impl</span>
 53 |     | <span class='neutral'>    ) external;</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /**</span>
 56 |     | <span class='neutral'>     * @notice Creates or initializes a managed associated ERC721 token.</span>
 57 |     | <span class='neutral'>     * @param id The bytes32 identifier of the associated system. If the id is new to the system, it will create a new proxy for the associated system.</span>
 58 |     | <span class='neutral'>     * @param name The token name that will be used to initialize the proxy.</span>
 59 |     | <span class='neutral'>     * @param symbol The token symbol that will be used to initialize the proxy.</span>
 60 |     | <span class='neutral'>     * @param uri The token uri that will be used to initialize the proxy.</span>
 61 |     | <span class='neutral'>     * @param impl The ERC721 implementation of the proxy.</span>
 62 |     | <span class='neutral'>     */</span>
 63 |     | <span class='neutral'>    function initOrUpgradeNft(</span>
 64 |     | <span class='neutral'>        bytes32 id,</span>
 65 |     | <span class='neutral'>        string memory name,</span>
 66 |     | <span class='neutral'>        string memory symbol,</span>
 67 |     | <span class='neutral'>        string memory uri,</span>
 68 |     | <span class='neutral'>        address impl</span>
 69 |     | <span class='neutral'>    ) external;</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    /**</span>
 72 |     | <span class='neutral'>     * @notice Registers an unmanaged external contract in the system.</span>
 73 |     | <span class='neutral'>     * @param id The bytes32 identifier to use to reference the associated system.</span>
 74 |     | <span class='neutral'>     * @param endpoint The address of the associated system.</span>
 75 |     | <span class='neutral'>     *</span>
 76 |     | <span class='neutral'>     * Note: The system will not be able to control or upgrade the associated system, only communicate with it.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='neutral'>    function registerUnmanagedSystem(bytes32 id, address endpoint) external;</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>    /**</span>
 81 |     | <span class='neutral'>     * @notice Retrieves an associated system.</span>
 82 |     | <span class='neutral'>     * @param id The bytes32 identifier used to reference the associated system.</span>
 83 |     | <span class='neutral'>     * @return addr The external contract address of the associated system.</span>
 84 |     | <span class='neutral'>     * @return kind The type of associated system (managed ERC20, managed ERC721, unmanaged, etc - See the AssociatedSystem util).</span>
 85 |     | <span class='neutral'>     */</span>
 86 |     | <span class='neutral'>    function getAssociatedSystem(bytes32 id) external view returns (address addr, bytes32 kind);</span>
 87 |     | <span class='neutral'>}</span>
 88 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/IFeatureFlagModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Module for granular enabling and disabling of system features and functions.</span>
   6 |     | <span class='neutral'> *</span>
   7 |     | <span class='neutral'> * Interface functions that are controlled by a feature flag simply need to add this line to their body:</span>
   8 |     | <span class='neutral'> * `FeatureFlag.ensureAccessToFeature(FLAG_ID);`</span>
   9 |     | <span class='neutral'> *</span>
  10 |     | <span class='neutral'> * If such a line is not present in a function, then it is not controlled by a feature flag.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * If a feature flag is set and then removed forever, consider deleting the line mentioned above from the function&#39;s body.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='neutral'>interface IFeatureFlagModule {</span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @notice Emitted when general access has been given or removed for a feature.</span>
  17 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  18 |     | <span class='neutral'>     * @param allowAll True if the feature was allowed for everyone and false if it is only allowed for those included in the allowlist.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    event FeatureFlagAllowAllSet(bytes32 indexed feature, bool allowAll);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @notice Emitted when general access has been blocked for a feature.</span>
  24 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  25 |     | <span class='neutral'>     * @param denyAll True if the feature was blocked for everyone and false if it is only allowed for those included in the allowlist or if allowAll is set to true.</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='neutral'>    event FeatureFlagDenyAllSet(bytes32 indexed feature, bool denyAll);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /**</span>
  30 |     | <span class='neutral'>     * @notice Emitted when an address was given access to a feature.</span>
  31 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  32 |     | <span class='neutral'>     * @param account The address that was given access to the feature.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    event FeatureFlagAllowlistAdded(bytes32 indexed feature, address account);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @notice Emitted when access to a feature has been removed from an address.</span>
  38 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  39 |     | <span class='neutral'>     * @param account The address that no longer has access to the feature.</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    event FeatureFlagAllowlistRemoved(bytes32 indexed feature, address account);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @notice Emitted when the list of addresses which can block a feature has been updated</span>
  45 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  46 |     | <span class='neutral'>     * @param deniers The list of addresses which are allowed to block a feature</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    event FeatureFlagDeniersReset(bytes32 indexed feature, address[] deniers);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Enables or disables free access to a feature.</span>
  52 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  53 |     | <span class='neutral'>     * @param allowAll True to allow anyone to use the feature, false to fallback to the allowlist.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function setFeatureFlagAllowAll(bytes32 feature, bool allowAll) external;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @notice Enables or disables free access to a feature.</span>
  59 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  60 |     | <span class='neutral'>     * @param denyAll True to allow noone to use the feature, false to fallback to the allowlist.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function setFeatureFlagDenyAll(bytes32 feature, bool denyAll) external;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @notice Allows an address to use a feature.</span>
  66 |     | <span class='neutral'>     * @dev This function does nothing if the specified account is already on the allowlist.</span>
  67 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  68 |     | <span class='neutral'>     * @param account The address that is allowed to use the feature.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function addToFeatureFlagAllowlist(bytes32 feature, address account) external;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @notice Disallows an address from using a feature.</span>
  74 |     | <span class='neutral'>     * @dev This function does nothing if the specified account is already on the allowlist.</span>
  75 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  76 |     | <span class='neutral'>     * @param account The address that is disallowed from using the feature.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='neutral'>    function removeFromFeatureFlagAllowlist(bytes32 feature, address account) external;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @notice Sets addresses which can disable a feature (but not enable it). Overwrites any preexisting data.</span>
  82 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  83 |     | <span class='neutral'>     * @param deniers The addresses which should have the ability to unilaterally disable the feature</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    function setDeniers(bytes32 feature, address[] memory deniers) external;</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @notice Gets the list of address which can block a feature</span>
  89 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function getDeniers(bytes32 feature) external view returns (address[] memory);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @notice Determines if the given feature is freely allowed to all users.</span>
  95 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
  96 |     | <span class='neutral'>     * @return True if anyone is allowed to use the feature, false if per-user control is used.</span>
  97 |     | <span class='neutral'>     */</span>
  98 |     | <span class='neutral'>    function getFeatureFlagAllowAll(bytes32 feature) external view returns (bool);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @notice Determines if the given feature is denied to all users.</span>
 102 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
 103 |     | <span class='neutral'>     * @return True if noone is allowed to use the feature.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='neutral'>    function getFeatureFlagDenyAll(bytes32 feature) external view returns (bool);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @notice Returns a list of addresses that are allowed to use the specified feature.</span>
 109 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
 110 |     | <span class='neutral'>     * @return The queried list of addresses.</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    function getFeatureFlagAllowlist(bytes32 feature) external view returns (address[] memory);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @notice Determines if an address can use the specified feature.</span>
 116 |     | <span class='neutral'>     * @param feature The bytes32 id of the feature.</span>
 117 |     | <span class='neutral'>     * @param account The address that is being queried for access to the feature.</span>
 118 |     | <span class='neutral'>     * @return A boolean with the response to the query.</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='neutral'>    function isFeatureAllowed(bytes32 feature, address account) external view returns (bool);</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/IOwnerModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Module for giving a system owner based access control.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
  8 |     | <span class='neutral'>interface IOwnerModule {</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Module wrapping an ERC20 token implementation.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface ITokenModule is IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @notice Returns wether the token has been initialized.</span>
 12 |     | <span class='neutral'>     * @return A boolean with the result of the query.</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='neutral'>    function isInitialized() external view returns (bool);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @notice Initializes the token with name, symbol, and decimals.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function initialize(</span>
 20 |     | <span class='neutral'>        string memory tokenName,</span>
 21 |     | <span class='neutral'>        string memory tokenSymbol,</span>
 22 |     | <span class='neutral'>        uint8 tokenDecimals</span>
 23 |     | <span class='neutral'>    ) external;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @notice Allows the owner to mint tokens.</span>
 27 |     | <span class='neutral'>     * @param to The address to receive the newly minted tokens.</span>
 28 |     | <span class='neutral'>     * @param amount The amount of tokens to mint.</span>
 29 |     | <span class='neutral'>     */</span>
 30 |     | <span class='neutral'>    function mint(address to, uint256 amount) external;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @notice Allows the owner to burn tokens.</span>
 34 |     | <span class='neutral'>     * @param from The address whose tokens will be burnt.</span>
 35 |     | <span class='neutral'>     * @param amount The amount of tokens to burn.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function burn(address from, uint256 amount) external;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @notice Allows an address that holds tokens to provide allowance to another.</span>
 41 |     | <span class='neutral'>     * @param from The address that is providing allowance.</span>
 42 |     | <span class='neutral'>     * @param spender The address that is given allowance.</span>
 43 |     | <span class='neutral'>     * @param amount The amount of allowance being given.</span>
 44 |     | <span class='neutral'>     */</span>
 45 |     | <span class='neutral'>    function setAllowance(address from, address spender, uint256 amount) external;</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/CoreModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {OwnerModule} from &quot;./OwnerModule.sol&quot;;</span>
  5 |     | <span class='neutral'>import {UpgradeModule} from &quot;./UpgradeModule.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
  8 |     | <span class='unexecuted'>contract CoreModule is OwnerModule, UpgradeModule {</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/FeatureFlagModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../storage/FeatureFlag.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;../interfaces/IFeatureFlagModule.sol&quot;;</span>
   8 |     | <span class='neutral'>import {console2} from &quot;lib/forge-std/src/Test.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title Module for granular enabling and disabling of system features and functions.</span>
  12 |     | <span class='neutral'> * See IFeatureFlagModule.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>contract FeatureFlagModule is IFeatureFlagModule {</span>
  15 |     | <span class='neutral'>    using SetUtil for SetUtil.AddressSet;</span>
  16 |     | <span class='neutral'>    using FeatureFlag for FeatureFlag.Data;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='unexecuted'>    function setFeatureFlagAllowAll(bytes32 feature, bool allowAll) external override {</span>
  22 |     | <span class='unexecuted'>        console2.log(&quot;===== FeatureFlagModule::setFeatureFlagAllowAll START =====&quot;);</span>
  23 |     | <span class='unexecuted'>        console2.log(&quot;Before only owner&quot;);</span>
  24 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  25 |     | <span class='unexecuted'>        console2.log(&quot;After only owner&quot;);</span>
  26 |     | <span class='unexecuted'>        FeatureFlag.load(feature).allowAll = allowAll;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>        if (allowAll) {</span>
  29 |     | <span class='unexecuted'>            FeatureFlag.load(feature).denyAll = false;</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>        emit FeatureFlagAllowAllSet(feature, allowAll);</span>
  33 |     | <span class='unexecuted'>        console2.log(&quot;===== FeatureFlagModule::setFeatureFlagAllowAll END =====&quot;);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='unexecuted'>    function setFeatureFlagDenyAll(bytes32 feature, bool denyAll) external override {</span>
  40 |     | <span class='unexecuted'>        FeatureFlag.Data storage flag = FeatureFlag.load(feature);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        if (!denyAll || !flag.isDenier(ERC2771Context._msgSender())) {</span>
  43 |     | <span class='unexecuted'>            OwnableStorage.onlyOwner();</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>        flag.denyAll = denyAll;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        emit FeatureFlagDenyAllSet(feature, denyAll);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    function addToFeatureFlagAllowlist(bytes32 feature, address account) external override {</span>
  55 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        SetUtil.AddressSet storage permissionedAddresses = FeatureFlag</span>
  58 |     | <span class='unexecuted'>            .load(feature)</span>
  59 |     | <span class='neutral'>            .permissionedAddresses;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        if (!permissionedAddresses.contains(account)) {</span>
  62 |     | <span class='unexecuted'>            permissionedAddresses.add(account);</span>
  63 |     | <span class='unexecuted'>            emit FeatureFlagAllowlistAdded(feature, account);</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function removeFromFeatureFlagAllowlist(bytes32 feature, address account) external override {</span>
  71 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        SetUtil.AddressSet storage permissionedAddresses = FeatureFlag</span>
  74 |     | <span class='unexecuted'>            .load(feature)</span>
  75 |     | <span class='neutral'>            .permissionedAddresses;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>        if (permissionedAddresses.contains(account)) {</span>
  78 |     | <span class='unexecuted'>            FeatureFlag.load(feature).permissionedAddresses.remove(account);</span>
  79 |     | <span class='unexecuted'>            emit FeatureFlagAllowlistRemoved(feature, account);</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
  85 |     | <span class='neutral'>     */</span>
  86 |     | <span class='unexecuted'>    function setDeniers(bytes32 feature, address[] memory deniers) external override {</span>
  87 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
  88 |     | <span class='unexecuted'>        FeatureFlag.Data storage flag = FeatureFlag.load(feature);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // resize array (its really dumb how you have to do this)</span>
  91 |     | <span class='unexecuted'>        uint256 storageLen = flag.deniers.length;</span>
  92 |     | <span class='unexecuted'>        for (uint256 i = storageLen; i &gt; deniers.length; i--) {</span>
  93 |     | <span class='unexecuted'>            flag.deniers.pop();</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; deniers.length; i++) {</span>
  97 |     | <span class='unexecuted'>            if (i &gt;= storageLen) {</span>
  98 |     | <span class='unexecuted'>                flag.deniers.push(deniers[i]);</span>
  99 |     | <span class='neutral'>            } else {</span>
 100 |     | <span class='unexecuted'>                flag.deniers[i] = deniers[i];</span>
 101 |     | <span class='neutral'>            }</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        emit FeatureFlagDeniersReset(feature, deniers);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
 109 |     | <span class='neutral'>     */</span>
 110 |     | <span class='unexecuted'>    function getDeniers(bytes32 feature) external view override returns (address[] memory) {</span>
 111 |     | <span class='unexecuted'>        FeatureFlag.Data storage flag = FeatureFlag.load(feature);</span>
 112 |     | <span class='unexecuted'>        address[] memory addrs = new address[](flag.deniers.length);</span>
 113 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; addrs.length; i++) {</span>
 114 |     | <span class='unexecuted'>            addrs[i] = flag.deniers[i];</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        return addrs;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /**</span>
 121 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
 122 |     | <span class='neutral'>     */</span>
 123 |     | <span class='unexecuted'>    function getFeatureFlagAllowAll(bytes32 feature) external view override returns (bool) {</span>
 124 |     | <span class='unexecuted'>        return FeatureFlag.load(feature).allowAll;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /**</span>
 128 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
 129 |     | <span class='neutral'>     */</span>
 130 |     | <span class='unexecuted'>    function getFeatureFlagDenyAll(bytes32 feature) external view override returns (bool) {</span>
 131 |     | <span class='unexecuted'>        return FeatureFlag.load(feature).denyAll;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /**</span>
 135 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
 136 |     | <span class='neutral'>     */</span>
 137 |     | <span class='unexecuted'>    function getFeatureFlagAllowlist(</span>
 138 |     | <span class='neutral'>        bytes32 feature</span>
 139 |     | <span class='unexecuted'>    ) external view override returns (address[] memory) {</span>
 140 |     | <span class='unexecuted'>        return FeatureFlag.load(feature).permissionedAddresses.values();</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @inheritdoc IFeatureFlagModule</span>
 145 |     | <span class='neutral'>     */</span>
 146 |     | <span class='unexecuted'>    function isFeatureAllowed(</span>
 147 |     | <span class='neutral'>        bytes32 feature,</span>
 148 |     | <span class='neutral'>        address account</span>
 149 |     | <span class='unexecuted'>    ) external view override returns (bool) {</span>
 150 |     | <span class='unexecuted'>        return FeatureFlag.hasAccess(feature, account);</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'>}</span>
 153 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/OwnerModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/ownership/Ownable.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/initializable/InitializableMixin.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../interfaces/IOwnerModule.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title Module for giving a system owner based access control.</span>
 10 |     | <span class='neutral'> * See IOwnerModule.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>contract OwnerModule is Ownable, IOwnerModule {</span>
 13 |     | <span class='neutral'>    // solhint-disable-next-line no-empty-blocks</span>
 14 |     | <span class='unexecuted'>    constructor() Ownable(address(0)) {</span>
 15 |     | <span class='neutral'>        // empty intentionally</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // no impl intentionally</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/UpgradeModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract UpgradeModule is UUPSImplementation {</span>
  8 |     | <span class='unexecuted'>    function upgradeTo(address newImplementation) public override {</span>
  9 |     | <span class='unexecuted'>        OwnableStorage.onlyOwner();</span>
 10 |     | <span class='unexecuted'>        _upgradeTo(newImplementation);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/storage/FeatureFlag.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library FeatureFlag {</span>
  8 |     | <span class='neutral'>    using SetUtil for SetUtil.AddressSet;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    error FeatureUnavailable(bytes32 which);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct Data {</span>
 13 |     | <span class='neutral'>        bytes32 name;</span>
 14 |     | <span class='neutral'>        bool allowAll;</span>
 15 |     | <span class='neutral'>        bool denyAll;</span>
 16 |     | <span class='neutral'>        SetUtil.AddressSet permissionedAddresses;</span>
 17 |     | <span class='neutral'>        address[] deniers;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    function load(bytes32 featureName) internal pure returns (Data storage store) {</span>
 21 | *   | <span class='executed'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.core-modules.FeatureFlag&quot;, featureName));</span>
 22 |     | <span class='neutral'>        assembly {</span>
 23 |     | <span class='neutral'>            store.slot := s</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function ensureAccessToFeature(bytes32 feature) internal view {</span>
 28 | *   | <span class='executed'>        if (!hasAccess(feature, ERC2771Context._msgSender())) {</span>
 29 | *   | <span class='executed'>            revert FeatureUnavailable(feature);</span>
 30 |     | <span class='neutral'>        }</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function hasAccess(bytes32 feature, address value) internal view returns (bool) {</span>
 34 | *   | <span class='executed'>        Data storage store = FeatureFlag.load(feature);</span>
 35 |     | <span class='neutral'></span>
 36 | *   | <span class='executed'>        if (store.denyAll) {</span>
 37 |     | <span class='unexecuted'>            return false;</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'></span>
 40 | *   | <span class='executed'>        return store.allowAll || store.permissionedAddresses.contains(value);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function isDenier(Data storage self, address possibleDenier) internal view returns (bool) {</span>
 44 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; self.deniers.length; i++) {</span>
 45 |     | <span class='unexecuted'>            if (self.deniers[i] == possibleDenier) {</span>
 46 |     | <span class='unexecuted'>                return true;</span>
 47 |     | <span class='neutral'>            }</span>
 48 |     | <span class='neutral'>        }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>        return false;</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/ICollateralConfigurationModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../storage/CollateralConfiguration.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Module for configuring system wide collateral.</span>
  8 |     | <span class='neutral'> * @notice Allows the owner to configure collaterals at a system wide level.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface ICollateralConfigurationModule {</span>
 11 |     | <span class='neutral'>    /**</span>
 12 |     | <span class='neutral'>     * @notice Emitted when a collateral type’s configuration is created or updated.</span>
 13 |     | <span class='neutral'>     * @param collateralType The address of the collateral type that was just configured.</span>
 14 |     | <span class='neutral'>     * @param config The object with the newly configured details.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event CollateralConfigured(address indexed collateralType, CollateralConfiguration.Data config);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @notice Creates or updates the configuration for the given `collateralType`.</span>
 20 |     | <span class='neutral'>     * @param config The CollateralConfiguration object describing the new configuration.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * Requirements:</span>
 23 |     | <span class='neutral'>     *</span>
 24 |     | <span class='neutral'>     * - `ERC2771Context._msgSender()` must be the owner of the system.</span>
 25 |     | <span class='neutral'>     *</span>
 26 |     | <span class='neutral'>     * Emits a {CollateralConfigured} event.</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     */</span>
 29 |     | <span class='neutral'>    function configureCollateral(CollateralConfiguration.Data memory config) external;</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /**</span>
 32 |     | <span class='neutral'>     * @notice Returns a list of detailed information pertaining to all collateral types registered in the system.</span>
 33 |     | <span class='neutral'>     * @dev Optionally returns only those that are currently enabled.</span>
 34 |     | <span class='neutral'>     * @param hideDisabled Wether to hide disabled collaterals or just return the full list of collaterals in the system.</span>
 35 |     | <span class='neutral'>     * @return collaterals The list of collateral configuration objects set in the system.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function getCollateralConfigurations(</span>
 38 |     | <span class='neutral'>        bool hideDisabled</span>
 39 |     | <span class='neutral'>    ) external view returns (CollateralConfiguration.Data[] memory collaterals);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @notice Returns detailed information pertaining the specified collateral type.</span>
 43 |     | <span class='neutral'>     * @param collateralType The address for the collateral whose configuration is being queried.</span>
 44 |     | <span class='neutral'>     * @return collateral The configuration object describing the given collateral.</span>
 45 |     | <span class='neutral'>     */</span>
 46 |     | <span class='neutral'>    function getCollateralConfiguration(</span>
 47 |     | <span class='neutral'>        address collateralType</span>
 48 |     | <span class='neutral'>    ) external view returns (CollateralConfiguration.Data memory collateral);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /**</span>
 51 |     | <span class='neutral'>     * @notice Returns the current value of a specified collateral type.</span>
 52 |     | <span class='neutral'>     * @param collateralType The address for the collateral whose price is being queried.</span>
 53 |     | <span class='neutral'>     * @return priceD18 The price of the given collateral, denominated with 18 decimals of precision.</span>
 54 |     | <span class='neutral'>     */</span>
 55 |     | <span class='neutral'>    function getCollateralPrice(address collateralType) external view returns (uint256 priceD18);</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/ICollateralModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../storage/CollateralLock.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title Module for managing user collateral.</span>
   8 |     | <span class='neutral'> * @notice Allows users to deposit and withdraw collateral from the system.</span>
   9 |     | <span class='neutral'> */</span>
  10 |     | <span class='neutral'>interface ICollateralModule {</span>
  11 |     | <span class='neutral'>    /**</span>
  12 |     | <span class='neutral'>     * @notice Thrown when an interacting account does not have sufficient collateral for an operation (withdrawal, lock, etc).</span>
  13 |     | <span class='neutral'>     */</span>
  14 |     | <span class='neutral'>    error InsufficientAccountCollateral(uint256 amount);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @notice Emitted when `tokenAmount` of collateral of type `collateralType` is deposited to account `accountId` by `sender`.</span>
  18 |     | <span class='neutral'>     * @param accountId The id of the account that deposited collateral.</span>
  19 |     | <span class='neutral'>     * @param collateralType The address of the collateral that was deposited.</span>
  20 |     | <span class='neutral'>     * @param tokenAmount The amount of collateral that was deposited, denominated in the token&#39;s native decimal representation.</span>
  21 |     | <span class='neutral'>     * @param sender The address of the account that triggered the deposit.</span>
  22 |     | <span class='neutral'>     */</span>
  23 |     | <span class='neutral'>    event Deposited(</span>
  24 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  25 |     | <span class='neutral'>        address indexed collateralType,</span>
  26 |     | <span class='neutral'>        uint256 tokenAmount,</span>
  27 |     | <span class='neutral'>        address indexed sender</span>
  28 |     | <span class='neutral'>    );</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @notice Emitted when a lock is created on someone&#39;s account</span>
  32 |     | <span class='neutral'>     * @param accountId The id of the account that received a lock</span>
  33 |     | <span class='neutral'>     * @param collateralType The address of the collateral type that was locked</span>
  34 |     | <span class='neutral'>     * @param tokenAmount The amount of collateral that was locked, demoninated in system units (1e18)</span>
  35 |     | <span class='neutral'>     * @param expireTimestamp unix timestamp at which the lock is due to expire</span>
  36 |     | <span class='neutral'>     */</span>
  37 |     | <span class='neutral'>    event CollateralLockCreated(</span>
  38 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  39 |     | <span class='neutral'>        address indexed collateralType,</span>
  40 |     | <span class='neutral'>        uint256 tokenAmount,</span>
  41 |     | <span class='neutral'>        uint64 expireTimestamp</span>
  42 |     | <span class='neutral'>    );</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @notice Emitted when a lock is cleared from an account due to expiration</span>
  46 |     | <span class='neutral'>     * @param accountId The id of the account that has the expired lock</span>
  47 |     | <span class='neutral'>     * @param collateralType The address of the collateral type that was unlocked</span>
  48 |     | <span class='neutral'>     * @param tokenAmount The amount of collateral that was unlocked, demoninated in system units (1e18)</span>
  49 |     | <span class='neutral'>     * @param expireTimestamp unix timestamp at which the unlock is due to expire</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    event CollateralLockExpired(</span>
  52 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  53 |     | <span class='neutral'>        address indexed collateralType,</span>
  54 |     | <span class='neutral'>        uint256 tokenAmount,</span>
  55 |     | <span class='neutral'>        uint64 expireTimestamp</span>
  56 |     | <span class='neutral'>    );</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @notice Emitted when `tokenAmount` of collateral of type `collateralType` is withdrawn from account `accountId` by `sender`.</span>
  60 |     | <span class='neutral'>     * @param accountId The id of the account that withdrew collateral.</span>
  61 |     | <span class='neutral'>     * @param collateralType The address of the collateral that was withdrawn.</span>
  62 |     | <span class='neutral'>     * @param tokenAmount The amount of collateral that was withdrawn, denominated in the token&#39;s native decimal representation.</span>
  63 |     | <span class='neutral'>     * @param sender The address of the account that triggered the withdrawal.</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    event Withdrawn(</span>
  66 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  67 |     | <span class='neutral'>        address indexed collateralType,</span>
  68 |     | <span class='neutral'>        uint256 tokenAmount,</span>
  69 |     | <span class='neutral'>        address indexed sender</span>
  70 |     | <span class='neutral'>    );</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @notice Deposits `tokenAmount` of collateral of type `collateralType` into account `accountId`.</span>
  74 |     | <span class='neutral'>     * @dev Anyone can deposit into anyone&#39;s active account without restriction.</span>
  75 |     | <span class='neutral'>     * @param accountId The id of the account that is making the deposit.</span>
  76 |     | <span class='neutral'>     * @param collateralType The address of the token to be deposited.</span>
  77 |     | <span class='neutral'>     * @param tokenAmount The amount being deposited, denominated in the token&#39;s native decimal representation.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Emits a {Deposited} event.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function deposit(uint128 accountId, address collateralType, uint256 tokenAmount) external;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @notice Withdraws `tokenAmount` of collateral of type `collateralType` from account `accountId`.</span>
  85 |     | <span class='neutral'>     * @param accountId The id of the account that is making the withdrawal.</span>
  86 |     | <span class='neutral'>     * @param collateralType The address of the token to be withdrawn.</span>
  87 |     | <span class='neutral'>     * @param tokenAmount The amount being withdrawn, denominated in the token&#39;s native decimal representation.</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * Requirements:</span>
  90 |     | <span class='neutral'>     *</span>
  91 |     | <span class='neutral'>     * - `ERC2771Context._msgSender()` must be the owner of the account, have the `ADMIN` permission, or have the `WITHDRAW` permission.</span>
  92 |     | <span class='neutral'>     *</span>
  93 |     | <span class='neutral'>     * Emits a {Withdrawn} event.</span>
  94 |     | <span class='neutral'>     *</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='neutral'>    function withdraw(uint128 accountId, address collateralType, uint256 tokenAmount) external;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @notice Returns the total values pertaining to account `accountId` for `collateralType`.</span>
 100 |     | <span class='neutral'>     * @param accountId The id of the account whose collateral is being queried.</span>
 101 |     | <span class='neutral'>     * @param collateralType The address of the collateral type whose amount is being queried.</span>
 102 |     | <span class='neutral'>     * @return totalDeposited The total collateral deposited in the account, denominated with 18 decimals of precision.</span>
 103 |     | <span class='neutral'>     * @return totalAssigned The amount of collateral in the account that is delegated to pools, denominated with 18 decimals of precision.</span>
 104 |     | <span class='neutral'>     * @return totalLocked The amount of collateral in the account that cannot currently be undelegated from a pool, denominated with 18 decimals of precision.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    function getAccountCollateral(</span>
 107 |     | <span class='neutral'>        uint128 accountId,</span>
 108 |     | <span class='neutral'>        address collateralType</span>
 109 |     | <span class='neutral'>    ) external view returns (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @notice Returns the amount of collateral of type `collateralType` deposited with account `accountId` that can be withdrawn or delegated to pools.</span>
 113 |     | <span class='neutral'>     * @param accountId The id of the account whose collateral is being queried.</span>
 114 |     | <span class='neutral'>     * @param collateralType The address of the collateral type whose amount is being queried.</span>
 115 |     | <span class='neutral'>     * @return amountD18 The amount of collateral that is available for withdrawal or delegation, denominated with 18 decimals of precision.</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'>    function getAccountAvailableCollateral(</span>
 118 |     | <span class='neutral'>        uint128 accountId,</span>
 119 |     | <span class='neutral'>        address collateralType</span>
 120 |     | <span class='neutral'>    ) external view returns (uint256 amountD18);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @notice Clean expired locks from locked collateral arrays for an account/collateral type. It includes offset and items to prevent gas exhaustion. If both, offset and items, are 0 it will traverse the whole array (unlimited).</span>
 124 |     | <span class='neutral'>     * @param accountId The id of the account whose locks are being cleared.</span>
 125 |     | <span class='neutral'>     * @param collateralType The address of the collateral type to clean locks for.</span>
 126 |     | <span class='neutral'>     * @param offset The index of the first lock to clear.</span>
 127 |     | <span class='neutral'>     * @param count The number of slots to check for cleaning locks. Set to 0 to clean all locks at/after offset</span>
 128 |     | <span class='neutral'>     * @return cleared the number of locks that were actually expired (and therefore cleared)</span>
 129 |     | <span class='neutral'>     */</span>
 130 |     | <span class='neutral'>    function cleanExpiredLocks(</span>
 131 |     | <span class='neutral'>        uint128 accountId,</span>
 132 |     | <span class='neutral'>        address collateralType,</span>
 133 |     | <span class='neutral'>        uint256 offset,</span>
 134 |     | <span class='neutral'>        uint256 count</span>
 135 |     | <span class='neutral'>    ) external returns (uint256 cleared);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /**</span>
 138 |     | <span class='neutral'>     * @notice Get a list of locks existing in account. Lists all locks in storage, even if they are expired</span>
 139 |     | <span class='neutral'>     * @param accountId The id of the account whose locks we want to read</span>
 140 |     | <span class='neutral'>     * @param collateralType The address of the collateral type for locks we want to read</span>
 141 |     | <span class='neutral'>     * @param offset The index of the first lock to read</span>
 142 |     | <span class='neutral'>     * @param count The number of slots to check for cleaning locks. Set to 0 to read all locks after offset</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='neutral'>    function getLocks(</span>
 145 |     | <span class='neutral'>        uint128 accountId,</span>
 146 |     | <span class='neutral'>        address collateralType,</span>
 147 |     | <span class='neutral'>        uint256 offset,</span>
 148 |     | <span class='neutral'>        uint256 count</span>
 149 |     | <span class='neutral'>    ) external view returns (CollateralLock.Data[] memory locks);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    /**</span>
 152 |     | <span class='neutral'>     * @notice Create a new lock on the given account. you must have `admin` permission on the specified account to create a lock.</span>
 153 |     | <span class='neutral'>     * @dev Collateral can be withdrawn from the system if it is not assigned or delegated to a pool. Collateral locks are an additional restriction that applies on top of that. I.e. if collateral is not assigned to a pool, but has a lock, it cannot be withdrawn.</span>
 154 |     | <span class='neutral'>     * @dev Collateral locks are initially intended for the Synthetix v2 to v3 migration, but may be used in the future by the Spartan Council, for example, to create and hand off accounts whose withdrawals from the system are locked for a given amount of time.</span>
 155 |     | <span class='neutral'>     * @param accountId The id of the account for which a lock is to be created.</span>
 156 |     | <span class='neutral'>     * @param collateralType The address of the collateral type for which the lock will be created.</span>
 157 |     | <span class='neutral'>     * @param amount The amount of collateral tokens to wrap in the lock being created, denominated with 18 decimals of precision.</span>
 158 |     | <span class='neutral'>     * @param expireTimestamp The date in which the lock will become clearable.</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    function createLock(</span>
 161 |     | <span class='neutral'>        uint128 accountId,</span>
 162 |     | <span class='neutral'>        address collateralType,</span>
 163 |     | <span class='neutral'>        uint256 amount,</span>
 164 |     | <span class='neutral'>        uint64 expireTimestamp</span>
 165 |     | <span class='neutral'>    ) external;</span>
 166 |     | <span class='neutral'>}</span>
 167 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IMarketCollateralModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Module for allowing markets to directly increase their credit capacity by providing their own collateral.</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface IMarketCollateralModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Thrown when a user attempts to deposit more collateral than that allowed by a market.</span>
  10 |     | <span class='neutral'>     */</span>
  11 |     | <span class='neutral'>    error InsufficientMarketCollateralDepositable(</span>
  12 |     | <span class='neutral'>        uint128 marketId,</span>
  13 |     | <span class='neutral'>        address collateralType,</span>
  14 |     | <span class='neutral'>        uint256 tokenAmountToDeposit</span>
  15 |     | <span class='neutral'>    );</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @notice Thrown when a user attempts to withdraw more collateral from the market than what it has provided.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    error InsufficientMarketCollateralWithdrawable(</span>
  21 |     | <span class='neutral'>        uint128 marketId,</span>
  22 |     | <span class='neutral'>        address collateralType,</span>
  23 |     | <span class='neutral'>        uint256 tokenAmountToWithdraw</span>
  24 |     | <span class='neutral'>    );</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /**</span>
  27 |     | <span class='neutral'>     * @notice Emitted when `amount` of collateral of type `collateralType` is deposited to market `marketId` by `sender`.</span>
  28 |     | <span class='neutral'>     * @param marketId The id of the market in which collateral was deposited.</span>
  29 |     | <span class='neutral'>     * @param collateralType The address of the collateral that was directly deposited in the market.</span>
  30 |     | <span class='neutral'>     * @param tokenAmount The amount of tokens that were deposited, denominated in the token&#39;s native decimal representation.</span>
  31 |     | <span class='neutral'>     * @param sender The address that triggered the deposit.</span>
  32 |     | <span class='neutral'>     * @param creditCapacity Updated credit capacity of the market after depositing collateral.</span>
  33 |     | <span class='neutral'>     * @param netIssuance Updated net issuance.</span>
  34 |     | <span class='neutral'>     * @param depositedCollateralValue Updated deposited collateral value of the market.</span>
  35 |     | <span class='neutral'>     * @param reportedDebt Updated reported debt of the market after depositing collateral.</span>
  36 |     | <span class='neutral'>     */</span>
  37 |     | <span class='neutral'>    event MarketCollateralDeposited(</span>
  38 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  39 |     | <span class='neutral'>        address indexed collateralType,</span>
  40 |     | <span class='neutral'>        uint256 tokenAmount,</span>
  41 |     | <span class='neutral'>        address indexed sender,</span>
  42 |     | <span class='neutral'>        int128 creditCapacity,</span>
  43 |     | <span class='neutral'>        int128 netIssuance,</span>
  44 |     | <span class='neutral'>        uint256 depositedCollateralValue,</span>
  45 |     | <span class='neutral'>        uint256 reportedDebt</span>
  46 |     | <span class='neutral'>    );</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @notice Emitted when `amount` of collateral of type `collateralType` is withdrawn from market `marketId` by `sender`.</span>
  50 |     | <span class='neutral'>     * @param marketId The id of the market from which collateral was withdrawn.</span>
  51 |     | <span class='neutral'>     * @param collateralType The address of the collateral that was withdrawn from the market.</span>
  52 |     | <span class='neutral'>     * @param tokenAmount The amount of tokens that were withdrawn, denominated in the token&#39;s native decimal representation.</span>
  53 |     | <span class='neutral'>     * @param sender The address that triggered the withdrawal.</span>
  54 |     | <span class='neutral'>     * @param creditCapacity Updated credit capacity of the market after withdrawing.</span>
  55 |     | <span class='neutral'>     * @param netIssuance Updated net issuance.</span>
  56 |     | <span class='neutral'>     * @param depositedCollateralValue Updated deposited collateral value of the market.</span>
  57 |     | <span class='neutral'>     * @param reportedDebt Updated reported debt of the market after withdrawing collateral.</span>
  58 |     | <span class='neutral'>     */</span>
  59 |     | <span class='neutral'>    event MarketCollateralWithdrawn(</span>
  60 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  61 |     | <span class='neutral'>        address indexed collateralType,</span>
  62 |     | <span class='neutral'>        uint256 tokenAmount,</span>
  63 |     | <span class='neutral'>        address indexed sender,</span>
  64 |     | <span class='neutral'>        int128 creditCapacity,</span>
  65 |     | <span class='neutral'>        int128 netIssuance,</span>
  66 |     | <span class='neutral'>        uint256 depositedCollateralValue,</span>
  67 |     | <span class='neutral'>        uint256 reportedDebt</span>
  68 |     | <span class='neutral'>    );</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @notice Emitted when the system owner specifies the maximum depositable collateral of a given type in a given market.</span>
  72 |     | <span class='neutral'>     * @param marketId The id of the market for which the maximum was configured.</span>
  73 |     | <span class='neutral'>     * @param collateralType The address of the collateral for which the maximum was configured.</span>
  74 |     | <span class='neutral'>     * @param systemAmount The amount to which the maximum was set, denominated with 18 decimals of precision.</span>
  75 |     | <span class='neutral'>     * @param owner The owner of the system, which triggered the configuration change.</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='neutral'>    event MaximumMarketCollateralConfigured(</span>
  78 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  79 |     | <span class='neutral'>        address indexed collateralType,</span>
  80 |     | <span class='neutral'>        uint256 systemAmount,</span>
  81 |     | <span class='neutral'>        address indexed owner</span>
  82 |     | <span class='neutral'>    );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @notice Allows a market to deposit collateral.</span>
  86 |     | <span class='neutral'>     * @param marketId The id of the market in which the collateral was directly deposited.</span>
  87 |     | <span class='neutral'>     * @param collateralType The address of the collateral that was deposited in the market.</span>
  88 |     | <span class='neutral'>     * @param amount The amount of collateral that was deposited, denominated in the token&#39;s native decimal representation.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function depositMarketCollateral(</span>
  91 |     | <span class='neutral'>        uint128 marketId,</span>
  92 |     | <span class='neutral'>        address collateralType,</span>
  93 |     | <span class='neutral'>        uint256 amount</span>
  94 |     | <span class='neutral'>    ) external;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @notice Allows a market to withdraw collateral that it has previously deposited.</span>
  98 |     | <span class='neutral'>     * @param marketId The id of the market from which the collateral was withdrawn.</span>
  99 |     | <span class='neutral'>     * @param collateralType The address of the collateral that was withdrawn from the market.</span>
 100 |     | <span class='neutral'>     * @param amount The amount of collateral that was withdrawn, denominated in the token&#39;s native decimal representation.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function withdrawMarketCollateral(</span>
 103 |     | <span class='neutral'>        uint128 marketId,</span>
 104 |     | <span class='neutral'>        address collateralType,</span>
 105 |     | <span class='neutral'>        uint256 amount</span>
 106 |     | <span class='neutral'>    ) external;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @notice Allow the system owner to configure the maximum amount of a given collateral type that a specified market is allowed to deposit.</span>
 110 |     | <span class='neutral'>     * @param marketId The id of the market for which the maximum is to be configured.</span>
 111 |     | <span class='neutral'>     * @param collateralType The address of the collateral for which the maximum is to be applied.</span>
 112 |     | <span class='neutral'>     * @param amount The amount that is to be set as the new maximum, denominated with 18 decimals of precision.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function configureMaximumMarketCollateral(</span>
 115 |     | <span class='neutral'>        uint128 marketId,</span>
 116 |     | <span class='neutral'>        address collateralType,</span>
 117 |     | <span class='neutral'>        uint256 amount</span>
 118 |     | <span class='neutral'>    ) external;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /**</span>
 121 |     | <span class='neutral'>     * @notice Return the total maximum amount of a given collateral type that a specified market is allowed to deposit.</span>
 122 |     | <span class='neutral'>     * @param marketId The id of the market for which the maximum is being queried.</span>
 123 |     | <span class='neutral'>     * @param collateralType The address of the collateral for which the maximum is being queried.</span>
 124 |     | <span class='neutral'>     * @return amountD18 The maximum amount of collateral set for the market, denominated with 18 decimals of precision.</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='neutral'>    function getMaximumMarketCollateral(</span>
 127 |     | <span class='neutral'>        uint128 marketId,</span>
 128 |     | <span class='neutral'>        address collateralType</span>
 129 |     | <span class='neutral'>    ) external view returns (uint256 amountD18);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @notice Return the total amount of a given collateral type that a specified market has deposited.</span>
 133 |     | <span class='neutral'>     * @param marketId The id of the market for which the directly deposited collateral amount is being queried.</span>
 134 |     | <span class='neutral'>     * @param collateralType The address of the collateral for which the amount is being queried.</span>
 135 |     | <span class='neutral'>     * @return amountD18 The total amount of collateral of this type delegated to the market, denominated with 18 decimals of precision.</span>
 136 |     | <span class='neutral'>     */</span>
 137 |     | <span class='neutral'>    function getMarketCollateralAmount(</span>
 138 |     | <span class='neutral'>        uint128 marketId,</span>
 139 |     | <span class='neutral'>        address collateralType</span>
 140 |     | <span class='neutral'>    ) external view returns (uint256 amountD18);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @notice Return the total value of collateral that a specified market has deposited.</span>
 144 |     | <span class='neutral'>     * @param marketId The id of the market for which the directly deposited collateral amount is being queried.</span>
 145 |     | <span class='neutral'>     * @return valueD18 The total value of collateral deposited by the market, denominated with 18 decimals of precision.</span>
 146 |     | <span class='neutral'>     */</span>
 147 |     | <span class='neutral'>    function getMarketCollateralValue(uint128 marketId) external view returns (uint256 valueD18);</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IMarketManagerModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./external/IOracleManager.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title System-wide entry point for the management of markets connected to the system.</span>
   9 |     | <span class='neutral'> */</span>
  10 |     | <span class='neutral'>interface IMarketManagerModule {</span>
  11 |     | <span class='neutral'>    /**</span>
  12 |     | <span class='neutral'>     * @notice Thrown when a market does not have enough liquidity for a withdrawal.</span>
  13 |     | <span class='neutral'>     */</span>
  14 |     | <span class='neutral'>    error NotEnoughLiquidity(uint128 marketId, uint256 amount);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @notice Thrown when an attempt to register a market that does not conform to the IMarket interface is made.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    error IncorrectMarketInterface(address market);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * @notice Emitted when a new market is registered in the system.</span>
  23 |     | <span class='neutral'>     * @param market The address of the external market that was registered in the system.</span>
  24 |     | <span class='neutral'>     * @param marketId The id with which the market was registered in the system.</span>
  25 |     | <span class='neutral'>     * @param sender The account that trigger the registration of the market.</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='neutral'>    event MarketRegistered(</span>
  28 |     | <span class='neutral'>        address indexed market,</span>
  29 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  30 |     | <span class='neutral'>        address indexed sender</span>
  31 |     | <span class='neutral'>    );</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /**</span>
  34 |     | <span class='neutral'>     * @notice Emitted when a market deposits snxUSD in the system.</span>
  35 |     | <span class='neutral'>     * @param marketId The id of the market that deposited snxUSD in the system.</span>
  36 |     | <span class='neutral'>     * @param target The address of the account that provided the snxUSD in the deposit.</span>
  37 |     | <span class='neutral'>     * @param amount The amount of snxUSD deposited in the system, denominated with 18 decimals of precision.</span>
  38 |     | <span class='neutral'>     * @param market The address of the external market that is depositing.</span>
  39 |     | <span class='neutral'>     * @param creditCapacity Updated credit capacity of the market after depositing.</span>
  40 |     | <span class='neutral'>     * @param netIssuance Updated net issuance.</span>
  41 |     | <span class='neutral'>     * @param depositedCollateralValue Updated deposited collateral value of the market.</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    event MarketUsdDeposited(</span>
  44 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  45 |     | <span class='neutral'>        address indexed target,</span>
  46 |     | <span class='neutral'>        uint256 amount,</span>
  47 |     | <span class='neutral'>        address indexed market,</span>
  48 |     | <span class='neutral'>        int128 creditCapacity,</span>
  49 |     | <span class='neutral'>        int128 netIssuance,</span>
  50 |     | <span class='neutral'>        uint256 depositedCollateralValue</span>
  51 |     | <span class='neutral'>    );</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @notice Emitted when a market withdraws snxUSD from the system.</span>
  55 |     | <span class='neutral'>     * @param marketId The id of the market that withdrew snxUSD from the system.</span>
  56 |     | <span class='neutral'>     * @param target The address of the account that received the snxUSD in the withdrawal.</span>
  57 |     | <span class='neutral'>     * @param amount The amount of snxUSD withdrawn from the system, denominated with 18 decimals of precision.</span>
  58 |     | <span class='neutral'>     * @param market The address of the external market that is withdrawing.</span>
  59 |     | <span class='neutral'>     * @param creditCapacity Updated credit capacity of the market after withdrawing.</span>
  60 |     | <span class='neutral'>     * @param netIssuance Updated net issuance.</span>
  61 |     | <span class='neutral'>     * @param depositedCollateralValue Updated deposited collateral value of the market</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    event MarketUsdWithdrawn(</span>
  64 |     | <span class='neutral'>        uint128 indexed marketId,</span>
  65 |     | <span class='neutral'>        address indexed target,</span>
  66 |     | <span class='neutral'>        uint256 amount,</span>
  67 |     | <span class='neutral'>        address indexed market,</span>
  68 |     | <span class='neutral'>        int128 creditCapacity,</span>
  69 |     | <span class='neutral'>        int128 netIssuance,</span>
  70 |     | <span class='neutral'>        uint256 depositedCollateralValue</span>
  71 |     | <span class='neutral'>    );</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    event MarketSystemFeePaid(uint128 indexed marketId, uint256 feeAmount);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @notice Emitted when a market sets an updated minimum delegation time</span>
  77 |     | <span class='neutral'>     * @param marketId The id of the market that the setting is applied to</span>
  78 |     | <span class='neutral'>     * @param minDelegateTime The minimum amount of time between delegation changes</span>
  79 |     | <span class='neutral'>     */</span>
  80 |     | <span class='neutral'>    event SetMinDelegateTime(uint128 indexed marketId, uint32 minDelegateTime);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @notice Emitted when a market-specific minimum liquidity ratio is set</span>
  84 |     | <span class='neutral'>     * @param marketId The id of the market that the setting is applied to</span>
  85 |     | <span class='neutral'>     * @param minLiquidityRatio The new market-specific minimum liquidity ratio</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    event SetMarketMinLiquidityRatio(uint128 indexed marketId, uint256 minLiquidityRatio);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @notice Connects an external market to the system.</span>
  91 |     | <span class='neutral'>     * @dev Creates a Market object to track the external market, and returns the newly created market id.</span>
  92 |     | <span class='neutral'>     * @param market The address of the external market that is to be registered in the system.</span>
  93 |     | <span class='neutral'>     * @return newMarketId The id with which the market will be registered in the system.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function registerMarket(address market) external returns (uint128 newMarketId);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @notice Allows an external market connected to the system to deposit USD in the system.</span>
  99 |     | <span class='neutral'>     * @dev The system burns the incoming USD, increases the market&#39;s credit capacity, and reduces its issuance.</span>
 100 |     | <span class='neutral'>     * @dev See `IMarket`.</span>
 101 |     | <span class='neutral'>     * @param marketId The id of the market in which snxUSD will be deposited.</span>
 102 |     | <span class='neutral'>     * @param target The address of the account on who&#39;s behalf the deposit will be made.</span>
 103 |     | <span class='neutral'>     * @param amount The amount of snxUSD to be deposited, denominated with 18 decimals of precision.</span>
 104 |     | <span class='neutral'>     * @return feeAmount the amount of fees paid (billed as additional debt towards liquidity providers)</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    function depositMarketUsd(</span>
 107 |     | <span class='neutral'>        uint128 marketId,</span>
 108 |     | <span class='neutral'>        address target,</span>
 109 |     | <span class='neutral'>        uint256 amount</span>
 110 |     | <span class='neutral'>    ) external returns (uint256 feeAmount);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @notice Allows an external market connected to the system to withdraw snxUSD from the system.</span>
 114 |     | <span class='neutral'>     * @dev The system mints the requested snxUSD (provided that the market has sufficient credit), reduces the market&#39;s credit capacity, and increases its net issuance.</span>
 115 |     | <span class='neutral'>     * @dev See `IMarket`.</span>
 116 |     | <span class='neutral'>     * @param marketId The id of the market from which snxUSD will be withdrawn.</span>
 117 |     | <span class='neutral'>     * @param target The address of the account that will receive the withdrawn snxUSD.</span>
 118 |     | <span class='neutral'>     * @param amount The amount of snxUSD to be withdraw, denominated with 18 decimals of precision.</span>
 119 |     | <span class='neutral'>     * @return feeAmount the amount of fees paid (billed as additional debt towards liquidity providers)</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    function withdrawMarketUsd(</span>
 122 |     | <span class='neutral'>        uint128 marketId,</span>
 123 |     | <span class='neutral'>        address target,</span>
 124 |     | <span class='neutral'>        uint256 amount</span>
 125 |     | <span class='neutral'>    ) external returns (uint256 feeAmount);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /**</span>
 128 |     | <span class='neutral'>     * @notice Get the amount of fees paid in USD for a call to `depositMarketUsd` and `withdrawMarketUsd` for the given market and amount</span>
 129 |     | <span class='neutral'>     * @param marketId The market to check fees for</span>
 130 |     | <span class='neutral'>     * @param amount The amount deposited or withdrawn in USD</span>
 131 |     | <span class='neutral'>     * @return depositFeeAmount the amount of USD paid for a call to `depositMarketUsd`</span>
 132 |     | <span class='neutral'>     * @return withdrawFeeAmount the amount of USD paid for a call to `withdrawMarketUsd`</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function getMarketFees(</span>
 135 |     | <span class='neutral'>        uint128 marketId,</span>
 136 |     | <span class='neutral'>        uint256 amount</span>
 137 |     | <span class='neutral'>    ) external view returns (uint256 depositFeeAmount, uint256 withdrawFeeAmount);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @notice Returns the total withdrawable snxUSD amount for the specified market.</span>
 141 |     | <span class='neutral'>     * @param marketId The id of the market whose withdrawable USD amount is being queried.</span>
 142 |     | <span class='neutral'>     * @return withdrawableD18 The total amount of snxUSD that the market could withdraw at the time of the query, denominated with 18 decimals of precision.</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='neutral'>    function getWithdrawableMarketUsd(</span>
 145 |     | <span class='neutral'>        uint128 marketId</span>
 146 |     | <span class='neutral'>    ) external view returns (uint256 withdrawableD18);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @notice Returns the contract address for the specified market.</span>
 150 |     | <span class='neutral'>     * @param marketId The id of the market</span>
 151 |     | <span class='neutral'>     * @return marketAddress The contract address for the specified market</span>
 152 |     | <span class='neutral'>     */</span>
 153 |     | <span class='neutral'>    function getMarketAddress(uint128 marketId) external view returns (address marketAddress);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /**</span>
 156 |     | <span class='neutral'>     * @notice Returns the net issuance of the specified market (snxUSD withdrawn - snxUSD deposited).</span>
 157 |     | <span class='neutral'>     * @param marketId The id of the market whose net issuance is being queried.</span>
 158 |     | <span class='neutral'>     * @return issuanceD18 The net issuance of the market, denominated with 18 decimals of precision.</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    function getMarketNetIssuance(uint128 marketId) external view returns (int128 issuanceD18);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /**</span>
 163 |     | <span class='neutral'>     * @notice Returns the reported debt of the specified market.</span>
 164 |     | <span class='neutral'>     * @param marketId The id of the market whose reported debt is being queried.</span>
 165 |     | <span class='neutral'>     * @return reportedDebtD18 The market&#39;s reported debt, denominated with 18 decimals of precision.</span>
 166 |     | <span class='neutral'>     */</span>
 167 |     | <span class='neutral'>    function getMarketReportedDebt(</span>
 168 |     | <span class='neutral'>        uint128 marketId</span>
 169 |     | <span class='neutral'>    ) external view returns (uint256 reportedDebtD18);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    /**</span>
 172 |     | <span class='neutral'>     * @notice Returns the total debt of the specified market.</span>
 173 |     | <span class='neutral'>     * @param marketId The id of the market whose debt is being queried.</span>
 174 |     | <span class='neutral'>     * @return totalDebtD18 The total debt of the market, denominated with 18 decimals of precision.</span>
 175 |     | <span class='neutral'>     */</span>
 176 |     | <span class='neutral'>    function getMarketTotalDebt(uint128 marketId) external view returns (int256 totalDebtD18);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    /**</span>
 179 |     | <span class='neutral'>     * @notice Returns the total snxUSD value of the collateral for the specified market.</span>
 180 |     | <span class='neutral'>     * @param marketId The id of the market whose collateral is being queried.</span>
 181 |     | <span class='neutral'>     * @return valueD18 The market&#39;s total snxUSD value of collateral, denominated with 18 decimals of precision.</span>
 182 |     | <span class='neutral'>     */</span>
 183 |     | <span class='neutral'>    function getMarketCollateral(uint128 marketId) external view returns (uint256 valueD18);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /**</span>
 186 |     | <span class='neutral'>     * @notice Returns the value per share of the debt of the specified market.</span>
 187 |     | <span class='neutral'>     * @dev This is not a view function, and actually updates the entire debt distribution chain.</span>
 188 |     | <span class='neutral'>     * @param marketId The id of the market whose debt per share is being queried.</span>
 189 |     | <span class='neutral'>     * @return debtPerShareD18 The market&#39;s debt per share value, denominated with 18 decimals of precision.</span>
 190 |     | <span class='neutral'>     */</span>
 191 |     | <span class='neutral'>    function getMarketDebtPerShare(uint128 marketId) external returns (int256 debtPerShareD18);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    /**</span>
 194 |     | <span class='neutral'>     * @notice Returns whether the capacity of the specified market is locked.</span>
 195 |     | <span class='neutral'>     * @param marketId The id of the market whose capacity is being queried.</span>
 196 |     | <span class='neutral'>     * @return isLocked A boolean that is true if the market&#39;s capacity is locked at the time of the query.</span>
 197 |     | <span class='neutral'>     */</span>
 198 |     | <span class='neutral'>    function isMarketCapacityLocked(uint128 marketId) external view returns (bool isLocked);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /**</span>
 201 |     | <span class='neutral'>     * @notice Returns the USD token associated with this synthetix core system</span>
 202 |     | <span class='neutral'>     */</span>
 203 |     | <span class='neutral'>    function getUsdToken() external view returns (IERC20);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    /**</span>
 206 |     | <span class='neutral'>     * @notice Retrieve the systems&#39; configured oracle manager address</span>
 207 |     | <span class='neutral'>     */</span>
 208 |     | <span class='neutral'>    function getOracleManager() external view returns (IOracleManager);</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    /**</span>
 211 |     | <span class='neutral'>     * @notice Update a market&#39;s current debt registration with the system.</span>
 212 |     | <span class='neutral'>     * This function is provided as an escape hatch for pool griefing, preventing</span>
 213 |     | <span class='neutral'>     * overwhelming the system with a series of very small pools and creating high gas</span>
 214 |     | <span class='neutral'>     * costs to update an account.</span>
 215 |     | <span class='neutral'>     * @param marketId the id of the market that needs pools bumped</span>
 216 |     | <span class='neutral'>     * @return finishedDistributing whether or not all bumpable pools have been bumped and target price has been reached</span>
 217 |     | <span class='neutral'>     */</span>
 218 |     | <span class='neutral'>    function distributeDebtToPools(</span>
 219 |     | <span class='neutral'>        uint128 marketId,</span>
 220 |     | <span class='neutral'>        uint256 maxIter</span>
 221 |     | <span class='neutral'>    ) external returns (bool finishedDistributing);</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /**</span>
 224 |     | <span class='neutral'>     * @notice allows for a market to set its minimum delegation time. This is useful for preventing stakers from frontrunning rewards or losses</span>
 225 |     | <span class='neutral'>     * by limiting the frequency of `delegateCollateral` (or `setPoolConfiguration`) calls. By default, there is no minimum delegation time.</span>
 226 |     | <span class='neutral'>     * @param marketId the id of the market that wants to set delegation time.</span>
 227 |     | <span class='neutral'>     * @param minDelegateTime the minimum number of seconds between delegation calls. Note: this value must be less than the globally defined maximum minDelegateTime</span>
 228 |     | <span class='neutral'>     */</span>
 229 |     | <span class='neutral'>    function setMarketMinDelegateTime(uint128 marketId, uint32 minDelegateTime) external;</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    /**</span>
 232 |     | <span class='neutral'>     * @notice Retrieve the minimum delegation time of a market</span>
 233 |     | <span class='neutral'>     * @param marketId the id of the market</span>
 234 |     | <span class='neutral'>     */</span>
 235 |     | <span class='neutral'>    function getMarketMinDelegateTime(uint128 marketId) external view returns (uint32);</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @notice Allows the system owner (not the pool owner) to set a market-specific minimum liquidity ratio.</span>
 239 |     | <span class='neutral'>     * @param marketId the id of the market</span>
 240 |     | <span class='neutral'>     * @param minLiquidityRatio The new market-specific minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)</span>
 241 |     | <span class='neutral'>     */</span>
 242 |     | <span class='neutral'>    function setMinLiquidityRatio(uint128 marketId, uint256 minLiquidityRatio) external;</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    /**</span>
 245 |     | <span class='neutral'>     * @notice Retrieves the market-specific minimum liquidity ratio.</span>
 246 |     | <span class='neutral'>     * @param marketId the id of the market</span>
 247 |     | <span class='neutral'>     * @return minRatioD18 The current market-specific minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)</span>
 248 |     | <span class='neutral'>     */</span>
 249 |     | <span class='neutral'>    function getMinLiquidityRatio(uint128 marketId) external view returns (uint256 minRatioD18);</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function getMarketPools(</span>
 252 |     | <span class='neutral'>        uint128 marketId</span>
 253 |     | <span class='neutral'>    ) external returns (uint128[] memory inRangePoolIds, uint128[] memory outRangePoolIds);</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    function getMarketPoolDebtDistribution(</span>
 256 |     | <span class='neutral'>        uint128 marketId,</span>
 257 |     | <span class='neutral'>        uint128 poolId</span>
 258 |     | <span class='neutral'>    ) external returns (uint256 sharesD18, uint128 totalSharesD18, int128 valuePerShareD27);</span>
 259 |     | <span class='neutral'>}</span>
 260 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IPoolModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../storage/MarketConfiguration.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../storage/PoolCollateralConfiguration.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title Module for the creation and management of pools.</span>
   9 |     | <span class='neutral'> * @dev The pool owner can be specified during creation, can be transferred, and has credentials for configuring the pool.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface IPoolModule {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @notice Thrown when attempting to disconnect a market whose capacity is locked, and whose removal would cause a decrease in its associated pool&#39;s credit delegation proportion.</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    error CapacityLocked(uint256 marketId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @notice Gets fired when pool will be created.</span>
  19 |     | <span class='neutral'>     * @param poolId The id of the newly created pool.</span>
  20 |     | <span class='neutral'>     * @param owner The owner of the newly created pool.</span>
  21 |     | <span class='neutral'>     * @param sender The address that triggered the creation of the pool.</span>
  22 |     | <span class='neutral'>     */</span>
  23 |     | <span class='neutral'>    event PoolCreated(uint128 indexed poolId, address indexed owner, address indexed sender);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /**</span>
  26 |     | <span class='neutral'>     * @notice Gets fired when pool owner proposes a new owner.</span>
  27 |     | <span class='neutral'>     * @param poolId The id of the pool for which the nomination ocurred.</span>
  28 |     | <span class='neutral'>     * @param nominatedOwner The address that was nominated as the new owner of the pool.</span>
  29 |     | <span class='neutral'>     * @param owner The address of the current owner of the pool.</span>
  30 |     | <span class='neutral'>     */</span>
  31 |     | <span class='neutral'>    event PoolOwnerNominated(</span>
  32 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  33 |     | <span class='neutral'>        address indexed nominatedOwner,</span>
  34 |     | <span class='neutral'>        address indexed owner</span>
  35 |     | <span class='neutral'>    );</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='neutral'>     * @notice Gets fired when pool nominee accepts nomination.</span>
  39 |     | <span class='neutral'>     * @param poolId The id of the pool for which the owner nomination was accepted.</span>
  40 |     | <span class='neutral'>     * @param owner The address of the new owner of the pool, which accepted the nomination.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    event PoolOwnershipAccepted(uint128 indexed poolId, address indexed owner);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @notice Gets fired when pool owner revokes nomination.</span>
  46 |     | <span class='neutral'>     * @param poolId The id of the pool in which the nomination was revoked.</span>
  47 |     | <span class='neutral'>     * @param owner The current owner of the pool.</span>
  48 |     | <span class='neutral'>     */</span>
  49 |     | <span class='neutral'>    event PoolNominationRevoked(uint128 indexed poolId, address indexed owner);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @notice Gets fired when pool nominee renounces nomination.</span>
  53 |     | <span class='neutral'>     * @param poolId The id of the pool for which the owner nomination was renounced.</span>
  54 |     | <span class='neutral'>     * @param owner The current owner of the pool.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    event PoolNominationRenounced(uint128 indexed poolId, address indexed owner);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @notice Gets fired when pool owner renounces his own ownership.</span>
  60 |     | <span class='neutral'>     * @param poolId The id of the pool for which the owner nomination was renounced.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    event PoolOwnershipRenounced(uint128 indexed poolId, address indexed owner);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @notice Gets fired when pool name changes.</span>
  66 |     | <span class='neutral'>     * @param poolId The id of the pool whose name was updated.</span>
  67 |     | <span class='neutral'>     * @param name The new name of the pool.</span>
  68 |     | <span class='neutral'>     * @param sender The address that triggered the rename of the pool.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    event PoolNameUpdated(uint128 indexed poolId, string name, address indexed sender);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @notice Gets fired when pool gets configured.</span>
  74 |     | <span class='neutral'>     * @param poolId The id of the pool whose configuration was set.</span>
  75 |     | <span class='neutral'>     * @param markets Array of configuration data of the markets that were connected to the pool.</span>
  76 |     | <span class='neutral'>     * @param sender The address that triggered the pool configuration.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='neutral'>    event PoolConfigurationSet(</span>
  79 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  80 |     | <span class='neutral'>        MarketConfiguration.Data[] markets,</span>
  81 |     | <span class='neutral'>        address indexed sender</span>
  82 |     | <span class='neutral'>    );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    event PoolCollateralConfigurationUpdated(</span>
  85 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  86 |     | <span class='neutral'>        address collateralType,</span>
  87 |     | <span class='neutral'>        PoolCollateralConfiguration.Data config</span>
  88 |     | <span class='neutral'>    );</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @notice Emitted when a system-wide minimum liquidity ratio is set</span>
  92 |     | <span class='neutral'>     * @param minLiquidityRatio The new system-wide minimum liquidity ratio</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='neutral'>    event SetMinLiquidityRatio(uint256 minLiquidityRatio);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @notice Allows collaterals accepeted by the system to be accepeted by the pool by default</span>
  98 |     | <span class='neutral'>     * @param poolId The id of the pool.</span>
  99 |     | <span class='neutral'>     * @param disabled Shows if new collateral&#39;s will be dsiabled by default for the pool</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    event PoolCollateralDisabledByDefaultSet(uint128 poolId, bool disabled);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @notice Creates a pool with the requested pool id.</span>
 105 |     | <span class='neutral'>     * @param requestedPoolId The requested id for the new pool. Reverts if the id is not available.</span>
 106 |     | <span class='neutral'>     * @param owner The address that will own the newly created pool.</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='neutral'>    function createPool(uint128 requestedPoolId, address owner) external;</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @notice Allows the pool owner to configure the pool.</span>
 112 |     | <span class='neutral'>     * @dev The pool&#39;s configuration is composed of an array of MarketConfiguration objects, which describe which markets the pool provides liquidity to, in what proportion, and to what extent.</span>
 113 |     | <span class='neutral'>     * @dev Incoming market ids need to be provided in ascending order.</span>
 114 |     | <span class='neutral'>     * @param poolId The id of the pool whose configuration is being set.</span>
 115 |     | <span class='neutral'>     * @param marketDistribution The array of market configuration objects that define the list of markets that are connected to the system.</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'>    function setPoolConfiguration(</span>
 118 |     | <span class='neutral'>        uint128 poolId,</span>
 119 |     | <span class='neutral'>        MarketConfiguration.Data[] memory marketDistribution</span>
 120 |     | <span class='neutral'>    ) external;</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @notice Allows the pool owner to set the configuration of a specific collateral type for their pool.</span>
 124 |     | <span class='neutral'>     * @param poolId The id of the pool whose configuration is being set.</span>
 125 |     | <span class='neutral'>     * @param collateralType The collate</span>
 126 |     | <span class='neutral'>     * @param newConfig The config to set</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='neutral'>    function setPoolCollateralConfiguration(</span>
 129 |     | <span class='neutral'>        uint128 poolId,</span>
 130 |     | <span class='neutral'>        address collateralType,</span>
 131 |     | <span class='neutral'>        PoolCollateralConfiguration.Data memory newConfig</span>
 132 |     | <span class='neutral'>    ) external;</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /**</span>
 135 |     | <span class='neutral'>     * @notice Retrieves the pool configuration of a specific collateral type.</span>
 136 |     | <span class='neutral'>     * @param poolId The id of the pool whose configuration is being returned.</span>
 137 |     | <span class='neutral'>     * @param collateralType The address of the collateral.</span>
 138 |     | <span class='neutral'>     * @return config The PoolCollateralConfiguration object that describes the requested collateral configuration of the pool.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    function getPoolCollateralConfiguration(</span>
 141 |     | <span class='neutral'>        uint128 poolId,</span>
 142 |     | <span class='neutral'>        address collateralType</span>
 143 |     | <span class='neutral'>    ) external view returns (PoolCollateralConfiguration.Data memory config);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /**</span>
 146 |     | <span class='neutral'>     * @notice Allows collaterals accepeted by the system to be accepeted by the pool by default</span>
 147 |     | <span class='neutral'>     * @param poolId The id of the pool.</span>
 148 |     | <span class='neutral'>     * @param disabled If set to true new collaterals will be disabled for the pool.</span>
 149 |     | <span class='neutral'>     */</span>
 150 |     | <span class='neutral'>    function setPoolCollateralDisabledByDefault(uint128 poolId, bool disabled) external;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /**</span>
 153 |     | <span class='neutral'>     * @notice Retrieves the MarketConfiguration of the specified pool.</span>
 154 |     | <span class='neutral'>     * @param poolId The id of the pool whose configuration is being queried.</span>
 155 |     | <span class='neutral'>     * @return markets The array of MarketConfiguration objects that describe the pool&#39;s configuration.</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='neutral'>    function getPoolConfiguration(</span>
 158 |     | <span class='neutral'>        uint128 poolId</span>
 159 |     | <span class='neutral'>    ) external view returns (MarketConfiguration.Data[] memory markets);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @notice Allows the owner of the pool to set the pool&#39;s name.</span>
 163 |     | <span class='neutral'>     * @param poolId The id of the pool whose name is being set.</span>
 164 |     | <span class='neutral'>     * @param name The new name to give to the pool.</span>
 165 |     | <span class='neutral'>     */</span>
 166 |     | <span class='neutral'>    function setPoolName(uint128 poolId, string memory name) external;</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /**</span>
 169 |     | <span class='neutral'>     * @notice Returns the pool&#39;s name.</span>
 170 |     | <span class='neutral'>     * @param poolId The id of the pool whose name is being queried.</span>
 171 |     | <span class='neutral'>     * @return poolName The current name of the pool.</span>
 172 |     | <span class='neutral'>     */</span>
 173 |     | <span class='neutral'>    function getPoolName(uint128 poolId) external view returns (string memory poolName);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     * @notice Allows the current pool owner to nominate a new owner.</span>
 177 |     | <span class='neutral'>     * @param nominatedOwner The address to nominate os the new pool owner.</span>
 178 |     | <span class='neutral'>     * @param poolId The id whose ownership is being transferred.</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function nominatePoolOwner(address nominatedOwner, uint128 poolId) external;</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /**</span>
 183 |     | <span class='neutral'>     * @notice After a new pool owner has been nominated, allows it to accept the nomination and thus ownership of the pool.</span>
 184 |     | <span class='neutral'>     * @param poolId The id of the pool for which the caller is to accept ownership.</span>
 185 |     | <span class='neutral'>     */</span>
 186 |     | <span class='neutral'>    function acceptPoolOwnership(uint128 poolId) external;</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /**</span>
 189 |     | <span class='neutral'>     * @notice After a new pool owner has been nominated, allows it to reject the nomination.</span>
 190 |     | <span class='neutral'>     * @param poolId The id of the pool for which the new owner nomination is to be revoked.</span>
 191 |     | <span class='neutral'>     */</span>
 192 |     | <span class='neutral'>    function revokePoolNomination(uint128 poolId) external;</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /**</span>
 195 |     | <span class='neutral'>     * @notice Allows the current nominated owner to renounce the nomination.</span>
 196 |     | <span class='neutral'>     * @param poolId The id of the pool for which the caller is renouncing ownership nomination.</span>
 197 |     | <span class='neutral'>     */</span>
 198 |     | <span class='neutral'>    function renouncePoolNomination(uint128 poolId) external;</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /**</span>
 201 |     | <span class='neutral'>     * @notice Allows the current owner to renounce his ownership.</span>
 202 |     | <span class='neutral'>     * @param poolId The id of the pool for which the caller is renouncing ownership nomination.</span>
 203 |     | <span class='neutral'>     */</span>
 204 |     | <span class='neutral'>    function renouncePoolOwnership(uint128 poolId) external;</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    /**</span>
 207 |     | <span class='neutral'>     * @notice Returns the current pool owner.</span>
 208 |     | <span class='neutral'>     * @param poolId The id of the pool whose ownership is being queried.</span>
 209 |     | <span class='neutral'>     * @return owner The current owner of the pool.</span>
 210 |     | <span class='neutral'>     */</span>
 211 |     | <span class='neutral'>    function getPoolOwner(uint128 poolId) external view returns (address owner);</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @notice Returns the current nominated pool owner.</span>
 215 |     | <span class='neutral'>     * @param poolId The id of the pool whose nominated owner is being queried.</span>
 216 |     | <span class='neutral'>     * @return nominatedOwner The current nominated owner of the pool.</span>
 217 |     | <span class='neutral'>     */</span>
 218 |     | <span class='neutral'>    function getNominatedPoolOwner(uint128 poolId) external view returns (address nominatedOwner);</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /**</span>
 221 |     | <span class='neutral'>     * @notice Allows the system owner (not the pool owner) to set the system-wide minimum liquidity ratio.</span>
 222 |     | <span class='neutral'>     * @param minLiquidityRatio The new system-wide minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)</span>
 223 |     | <span class='neutral'>     */</span>
 224 |     | <span class='neutral'>    function setMinLiquidityRatio(uint256 minLiquidityRatio) external;</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /**</span>
 227 |     | <span class='neutral'>     @notice returns a pool minimum issuance ratio</span>
 228 |     | <span class='neutral'>     * @param poolId The id of the pool for to check the collateral for.</span>
 229 |     | <span class='neutral'>     * @param collateral The address of the collateral.</span>
 230 |     | <span class='neutral'>     */</span>
 231 |     | <span class='neutral'>    function getPoolCollateralIssuanceRatio(</span>
 232 |     | <span class='neutral'>        uint128 poolId,</span>
 233 |     | <span class='neutral'>        address collateral</span>
 234 |     | <span class='neutral'>    ) external view returns (uint256 issuanceRatioD18);</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    /**</span>
 237 |     | <span class='neutral'>     * @notice Retrieves the system-wide minimum liquidity ratio.</span>
 238 |     | <span class='neutral'>     * @return minRatioD18 The current system-wide minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)</span>
 239 |     | <span class='neutral'>     */</span>
 240 |     | <span class='neutral'>    function getMinLiquidityRatio() external view returns (uint256 minRatioD18);</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /**</span>
 243 |     | <span class='neutral'>     * @notice Distributes cached debt in a pool to its vaults and updates market credit capacities.</span>
 244 |     | <span class='neutral'>     * @param poolId the pool to rebalance</span>
 245 |     | <span class='neutral'>     * @param optionalCollateralType in addition to rebalancing the pool, calculate updated collaterals and debts for the specified vault</span>
 246 |     | <span class='neutral'>     */</span>
 247 |     | <span class='neutral'>    function rebalancePool(uint128 poolId, address optionalCollateralType) external;</span>
 248 |     | <span class='neutral'>}</span>
 249 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IRewardsManagerModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Module for connecting rewards distributors to vaults.</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface IRewardsManagerModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice Emitted when a reward distributor returns `false` from `payout` indicating a problem</span>
  10 |     | <span class='neutral'>     * preventing the payout from being executed. In this case, it is advised to check with the</span>
  11 |     | <span class='neutral'>     * project maintainers, and possibly try again in the future.</span>
  12 |     | <span class='neutral'>     * @param distributor the distributor which originated the issue</span>
  13 |     | <span class='neutral'>     */</span>
  14 |     | <span class='neutral'>    error RewardUnavailable(address distributor);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @notice Emitted when the pool owner or an existing reward distributor sets up rewards for vault participants.</span>
  18 |     | <span class='neutral'>     * @param poolId The id of the pool on which rewards were distributed.</span>
  19 |     | <span class='neutral'>     * @param collateralType The collateral type of the pool on which rewards were distributed.</span>
  20 |     | <span class='neutral'>     * @param distributor The reward distributor associated to the rewards that were distributed.</span>
  21 |     | <span class='neutral'>     * @param amount The amount of rewards that were distributed.</span>
  22 |     | <span class='neutral'>     * @param start The date one which the rewards will begin to be claimable.</span>
  23 |     | <span class='neutral'>     * @param duration The time in which all of the distributed rewards will be claimable.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event RewardsDistributed(</span>
  26 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  27 |     | <span class='neutral'>        address indexed collateralType,</span>
  28 |     | <span class='neutral'>        address distributor,</span>
  29 |     | <span class='neutral'>        uint256 amount,</span>
  30 |     | <span class='neutral'>        uint256 start,</span>
  31 |     | <span class='neutral'>        uint256 duration</span>
  32 |     | <span class='neutral'>    );</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @notice Emitted when a vault participant claims rewards.</span>
  36 |     | <span class='neutral'>     * @param accountId The id of the account that claimed the rewards.</span>
  37 |     | <span class='neutral'>     * @param poolId The id of the pool where the rewards were claimed.</span>
  38 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
  39 |     | <span class='neutral'>     * @param distributor The address of the rewards distributor associated with these rewards.</span>
  40 |     | <span class='neutral'>     * @param amount The amount of rewards that were claimed.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    event RewardsClaimed(</span>
  43 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  44 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  45 |     | <span class='neutral'>        address indexed collateralType,</span>
  46 |     | <span class='neutral'>        address distributor,</span>
  47 |     | <span class='neutral'>        uint256 amount</span>
  48 |     | <span class='neutral'>    );</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Emitted when a new rewards distributor is registered.</span>
  52 |     | <span class='neutral'>     * @param poolId The id of the pool whose reward distributor was registered.</span>
  53 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
  54 |     | <span class='neutral'>     * @param distributor The address of the newly registered reward distributor.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    event RewardsDistributorRegistered(</span>
  57 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  58 |     | <span class='neutral'>        address indexed collateralType,</span>
  59 |     | <span class='neutral'>        address indexed distributor</span>
  60 |     | <span class='neutral'>    );</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @notice Emitted when an already registered rewards distributor is removed.</span>
  64 |     | <span class='neutral'>     * @param poolId The id of the pool whose reward distributor was registered.</span>
  65 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
  66 |     | <span class='neutral'>     * @param distributor The address of the registered reward distributor.</span>
  67 |     | <span class='neutral'>     */</span>
  68 |     | <span class='neutral'>    event RewardsDistributorRemoved(</span>
  69 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  70 |     | <span class='neutral'>        address indexed collateralType,</span>
  71 |     | <span class='neutral'>        address indexed distributor</span>
  72 |     | <span class='neutral'>    );</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @notice Called by pool owner to register rewards for vault participants.</span>
  76 |     | <span class='neutral'>     * @param poolId The id of the pool whose rewards are to be managed by the specified distributor.</span>
  77 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
  78 |     | <span class='neutral'>     * @param distributor The address of the reward distributor to be registered.</span>
  79 |     | <span class='neutral'>     */</span>
  80 |     | <span class='neutral'>    function registerRewardsDistributor(</span>
  81 |     | <span class='neutral'>        uint128 poolId,</span>
  82 |     | <span class='neutral'>        address collateralType,</span>
  83 |     | <span class='neutral'>        address distributor</span>
  84 |     | <span class='neutral'>    ) external;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @notice Called by pool owner to remove a registered rewards distributor for vault participants.</span>
  88 |     | <span class='neutral'>     * WARNING: if you remove a rewards distributor, the same address can never be re-registered again. If you</span>
  89 |     | <span class='neutral'>     * simply want to turn off</span>
  90 |     | <span class='neutral'>     * rewards, call `distributeRewards` with 0 emission. If you need to completely reset the rewards distributor</span>
  91 |     | <span class='neutral'>     * again, create a new rewards distributor at a new address and register the new one.</span>
  92 |     | <span class='neutral'>     * This function is provided since the number of rewards distributors added to an account is finite,</span>
  93 |     | <span class='neutral'>     * so you can remove an unused rewards distributor if need be.</span>
  94 |     | <span class='neutral'>     * NOTE: unclaimed rewards can still be claimed after a rewards distributor is removed (though any</span>
  95 |     | <span class='neutral'>     * rewards-over-time will be halted)</span>
  96 |     | <span class='neutral'>     * @param poolId The id of the pool whose rewards are to be managed by the specified distributor.</span>
  97 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
  98 |     | <span class='neutral'>     * @param distributor The address of the reward distributor to be registered.</span>
  99 |     | <span class='neutral'>     */</span>
 100 |     | <span class='neutral'>    function removeRewardsDistributor(</span>
 101 |     | <span class='neutral'>        uint128 poolId,</span>
 102 |     | <span class='neutral'>        address collateralType,</span>
 103 |     | <span class='neutral'>        address distributor</span>
 104 |     | <span class='neutral'>    ) external;</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /**</span>
 107 |     | <span class='neutral'>     * @notice Called by a registered distributor to set up rewards for vault participants.</span>
 108 |     | <span class='neutral'>     * @dev Will revert if the caller is not a registered distributor.</span>
 109 |     | <span class='neutral'>     * @param poolId The id of the pool to distribute rewards to.</span>
 110 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
 111 |     | <span class='neutral'>     * @param amount The amount of rewards to be distributed.</span>
 112 |     | <span class='neutral'>     * @param start The date at which the rewards will begin to be claimable.</span>
 113 |     | <span class='neutral'>     * @param duration The period after which all distributed rewards will be claimable.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function distributeRewards(</span>
 116 |     | <span class='neutral'>        uint128 poolId,</span>
 117 |     | <span class='neutral'>        address collateralType,</span>
 118 |     | <span class='neutral'>        uint256 amount,</span>
 119 |     | <span class='neutral'>        uint64 start,</span>
 120 |     | <span class='neutral'>        uint32 duration</span>
 121 |     | <span class='neutral'>    ) external;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @notice Called by owner of a pool to set rewards for vault participants. This method</span>
 125 |     | <span class='neutral'>     * of reward setting is generally intended to only be used to recover from a case where the</span>
 126 |     | <span class='neutral'>     * distributor state is out of sync with the core system state, or if the distributor is only</span>
 127 |     | <span class='neutral'>     * able to payout and not capable of distributing its own rewards.</span>
 128 |     | <span class='neutral'>     * @dev Will revert if the caller is not the owner of the pool.</span>
 129 |     | <span class='neutral'>     * @param poolId The id of the pool to distribute rewards to.</span>
 130 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
 131 |     | <span class='neutral'>     * @param rewardsDistributor The address of the reward distributor which pays out the tokens.</span>
 132 |     | <span class='neutral'>     * @param amount The amount of rewards to be distributed.</span>
 133 |     | <span class='neutral'>     * @param start The date at which the rewards will begin to be claimable.</span>
 134 |     | <span class='neutral'>     * @param duration The period after which all distributed rewards will be claimable.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function distributeRewardsByOwner(</span>
 137 |     | <span class='neutral'>        uint128 poolId,</span>
 138 |     | <span class='neutral'>        address collateralType,</span>
 139 |     | <span class='neutral'>        address rewardsDistributor,</span>
 140 |     | <span class='neutral'>        uint256 amount,</span>
 141 |     | <span class='neutral'>        uint64 start,</span>
 142 |     | <span class='neutral'>        uint32 duration</span>
 143 |     | <span class='neutral'>    ) external;</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /**</span>
 146 |     | <span class='neutral'>     * @notice Allows a user with appropriate permissions to claim rewards associated with a position.</span>
 147 |     | <span class='neutral'>     * @param accountId The id of the account that is to claim the rewards.</span>
 148 |     | <span class='neutral'>     * @param poolId The id of the pool to claim rewards on.</span>
 149 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
 150 |     | <span class='neutral'>     * @param distributor The address of the rewards distributor associated with the rewards being claimed.</span>
 151 |     | <span class='neutral'>     * @return amountClaimedD18 The amount of rewards that were available for the account and thus claimed.</span>
 152 |     | <span class='neutral'>     */</span>
 153 |     | <span class='neutral'>    function claimRewards(</span>
 154 |     | <span class='neutral'>        uint128 accountId,</span>
 155 |     | <span class='neutral'>        uint128 poolId,</span>
 156 |     | <span class='neutral'>        address collateralType,</span>
 157 |     | <span class='neutral'>        address distributor</span>
 158 |     | <span class='neutral'>    ) external returns (uint256 amountClaimedD18);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @notice For a given position, return the rewards that can currently be claimed.</span>
 162 |     | <span class='neutral'>     * @param poolId The id of the pool being queried.</span>
 163 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
 164 |     | <span class='neutral'>     * @param accountId The id of the account whose available rewards are being queried.</span>
 165 |     | <span class='neutral'>     * @return claimableD18 An array of ids of the reward entries that are claimable by the position.</span>
 166 |     | <span class='neutral'>     * @return distributors An array with the addresses of the reward distributors associated with the claimable rewards.</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='neutral'>    function updateRewards(</span>
 169 |     | <span class='neutral'>        uint128 poolId,</span>
 170 |     | <span class='neutral'>        address collateralType,</span>
 171 |     | <span class='neutral'>        uint128 accountId</span>
 172 |     | <span class='neutral'>    ) external returns (uint256[] memory claimableD18, address[] memory distributors);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @notice Returns the number of individual units of amount emitted per second per share for the given poolId, collateralType, distributor vault.</span>
 176 |     | <span class='neutral'>     * @param poolId The id of the pool being queried.</span>
 177 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
 178 |     | <span class='neutral'>     * @param distributor The address of the rewards distributor associated with the rewards in question.</span>
 179 |     | <span class='neutral'>     * @return rateD18 The queried rewards rate.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='neutral'>    function getRewardRate(</span>
 182 |     | <span class='neutral'>        uint128 poolId,</span>
 183 |     | <span class='neutral'>        address collateralType,</span>
 184 |     | <span class='neutral'>        address distributor</span>
 185 |     | <span class='neutral'>    ) external view returns (uint256 rateD18);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @notice Returns the amount of claimable rewards for a given accountId for a vault distributor.</span>
 189 |     | <span class='neutral'>     * @param accountId The id of the account to look up rewards on.</span>
 190 |     | <span class='neutral'>     * @param poolId The id of the pool to claim rewards on.</span>
 191 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the pool&#39;s rewards.</span>
 192 |     | <span class='neutral'>     * @param distributor The address of the rewards distributor associated with the rewards being claimed.</span>
 193 |     | <span class='neutral'>     * @return rewardAmount The amount of available rewards that are available for the provided account.</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='neutral'>    function getAvailableRewards(</span>
 196 |     | <span class='neutral'>        uint128 accountId,</span>
 197 |     | <span class='neutral'>        uint128 poolId,</span>
 198 |     | <span class='neutral'>        address collateralType,</span>
 199 |     | <span class='neutral'>        address distributor</span>
 200 |     | <span class='neutral'>    ) external view returns (uint256 rewardAmount);</span>
 201 |     | <span class='neutral'>}</span>
 202 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IUtilsModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC165} from &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Module with assorted utility functions.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IUtilsModule is IERC165 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @notice Emitted when a new cross chain network becomes supported by the protocol</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    event NewSupportedCrossChainNetwork(uint64 newChainId);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @notice Configure CCIP addresses on the stablecoin.</span>
 17 |     | <span class='neutral'>     * @param ccipRouter The address on this chain to which CCIP messages will be sent or received.</span>
 18 |     | <span class='neutral'>     * @param ccipTokenPool The address where CCIP fees will be sent to when sending and receiving cross chain messages.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function configureChainlinkCrossChain(address ccipRouter, address ccipTokenPool) external;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @notice Used to add new cross chain networks to the protocol</span>
 24 |     | <span class='neutral'>     * Ignores a network if it matches the current chain id</span>
 25 |     | <span class='neutral'>     * Ignores a network if it has already been added</span>
 26 |     | <span class='neutral'>     * @param supportedNetworks array of all networks that are supported by the protocol</span>
 27 |     | <span class='neutral'>     * @param ccipSelectors the ccip &quot;selector&quot; which maps to the chain id on the same index. must be same length as `supportedNetworks`</span>
 28 |     | <span class='neutral'>     * @return numRegistered the number of networks that were actually registered</span>
 29 |     | <span class='neutral'>     */</span>
 30 |     | <span class='neutral'>    function setSupportedCrossChainNetworks(</span>
 31 |     | <span class='neutral'>        uint64[] memory supportedNetworks,</span>
 32 |     | <span class='neutral'>        uint64[] memory ccipSelectors</span>
 33 |     | <span class='neutral'>    ) external returns (uint256 numRegistered);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @notice Configure the system&#39;s single oracle manager address.</span>
 37 |     | <span class='neutral'>     * @param oracleManagerAddress The address of the oracle manager.</span>
 38 |     | <span class='neutral'>     */</span>
 39 |     | <span class='neutral'>    function configureOracleManager(address oracleManagerAddress) external;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @notice Configure a generic value in the KV system</span>
 43 |     | <span class='neutral'>     * @param k the key of the value to set</span>
 44 |     | <span class='neutral'>     * @param v the value that the key should be set to</span>
 45 |     | <span class='neutral'>     */</span>
 46 |     | <span class='neutral'>    function setConfig(bytes32 k, bytes32 v) external;</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @notice Read a generic value from the KV system</span>
 50 |     | <span class='neutral'>     * @param k the key to read</span>
 51 |     | <span class='neutral'>     * @return v the value set on the specified k</span>
 52 |     | <span class='neutral'>     */</span>
 53 |     | <span class='neutral'>    function getConfig(bytes32 k) external view returns (bytes32 v);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /**</span>
 56 |     | <span class='neutral'>     * @notice Read a UINT value from the KV system</span>
 57 |     | <span class='neutral'>     * @param k the key to read</span>
 58 |     | <span class='neutral'>     * @return v the value set on the specified k</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function getConfigUint(bytes32 k) external view returns (uint256 v);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    /**</span>
 63 |     | <span class='neutral'>     * @notice Read a Address value from the KV system</span>
 64 |     | <span class='neutral'>     * @param k the key to read</span>
 65 |     | <span class='neutral'>     * @return v the value set on the specified k</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    function getConfigAddress(bytes32 k) external view returns (address v);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    /**</span>
 70 |     | <span class='neutral'>     * @notice Checks if the address is the trusted forwarder</span>
 71 |     | <span class='neutral'>     * @param forwarder The address to check</span>
 72 |     | <span class='neutral'>     * @return Whether the address is the trusted forwarder</span>
 73 |     | <span class='neutral'>     */</span>
 74 |     | <span class='neutral'>    function isTrustedForwarder(address forwarder) external pure returns (bool);</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @notice Provides the address of the trusted forwarder</span>
 78 |     | <span class='neutral'>     * @return Address of the trusted forwarder</span>
 79 |     | <span class='neutral'>     */</span>
 80 |     | <span class='neutral'>    function getTrustedForwarder() external pure returns (address);</span>
 81 |     | <span class='neutral'>}</span>
 82 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IVaultModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Allows accounts to delegate collateral to a pool.</span>
   6 |     | <span class='neutral'> * @dev Delegation updates the account&#39;s position in the vault that corresponds to the associated pool and collateral type pair.</span>
   7 |     | <span class='neutral'> * @dev A pool contains one vault for each collateral type it supports, and vaults are not shared between pools.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IVaultModule {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @notice Thrown when attempting to delegate collateral to a vault with a leverage amount that is not supported by the system.</span>
  12 |     | <span class='neutral'>     */</span>
  13 |     | <span class='neutral'>    error InvalidLeverage(uint256 leverage);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @notice Thrown when attempting to delegate collateral to a market whose capacity is locked.</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='neutral'>    error CapacityLocked(uint256 marketId);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @notice Thrown when the specified new collateral amount to delegate to the vault equals the current existing amount.</span>
  22 |     | <span class='neutral'>     */</span>
  23 |     | <span class='neutral'>    error InvalidCollateralAmount();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /**</span>
  26 |     | <span class='neutral'>     * @notice Emitted when {sender} updates the delegation of collateral in the specified liquidity position.</span>
  27 |     | <span class='neutral'>     * @param accountId The id of the account whose position was updated.</span>
  28 |     | <span class='neutral'>     * @param poolId The id of the pool in which the position was updated.</span>
  29 |     | <span class='neutral'>     * @param collateralType The address of the collateral associated to the position.</span>
  30 |     | <span class='neutral'>     * @param amount The new amount of the position, denominated with 18 decimals of precision.</span>
  31 |     | <span class='neutral'>     * @param leverage The new leverage value of the position, denominated with 18 decimals of precision.</span>
  32 |     | <span class='neutral'>     * @param sender The address that triggered the update of the position.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    event DelegationUpdated(</span>
  35 |     | <span class='neutral'>        uint128 indexed accountId,</span>
  36 |     | <span class='neutral'>        uint128 indexed poolId,</span>
  37 |     | <span class='neutral'>        address collateralType,</span>
  38 |     | <span class='neutral'>        uint256 amount,</span>
  39 |     | <span class='neutral'>        uint256 leverage,</span>
  40 |     | <span class='neutral'>        address indexed sender</span>
  41 |     | <span class='neutral'>    );</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @notice Updates an account&#39;s delegated collateral amount for the specified pool and collateral type pair.</span>
  45 |     | <span class='neutral'>     * @param accountId The id of the account associated with the position that will be updated.</span>
  46 |     | <span class='neutral'>     * @param poolId The id of the pool associated with the position.</span>
  47 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the position.</span>
  48 |     | <span class='neutral'>     * @param amount The new amount of collateral delegated in the position, denominated with 18 decimals of precision.</span>
  49 |     | <span class='neutral'>     * @param leverage The new leverage amount used in the position, denominated with 18 decimals of precision.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * Requirements:</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * - `ERC2771Context._msgSender()` must be the owner of the account, have the `ADMIN` permission, or have the `DELEGATE` permission.</span>
  54 |     | <span class='neutral'>     * - If increasing the amount delegated, it must not exceed the available collateral (`getAccountAvailableCollateral`) associated with the account.</span>
  55 |     | <span class='neutral'>     * - If decreasing the amount delegated, the liquidity position must have a collateralization ratio greater than the target collateralization ratio for the corresponding collateral type.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * Emits a {DelegationUpdated} event.</span>
  58 |     | <span class='neutral'>     */</span>
  59 |     | <span class='neutral'>    function delegateCollateral(</span>
  60 |     | <span class='neutral'>        uint128 accountId,</span>
  61 |     | <span class='neutral'>        uint128 poolId,</span>
  62 |     | <span class='neutral'>        address collateralType,</span>
  63 |     | <span class='neutral'>        uint256 amount,</span>
  64 |     | <span class='neutral'>        uint256 leverage</span>
  65 |     | <span class='neutral'>    ) external;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @notice Returns the collateralization ratio of the specified liquidity position. If debt is negative, this function will return 0.</span>
  69 |     | <span class='neutral'>     * @dev Call this function using `callStatic` to treat it as a view function.</span>
  70 |     | <span class='neutral'>     * @dev The return value is a percentage with 18 decimals places.</span>
  71 |     | <span class='neutral'>     * @param accountId The id of the account whose collateralization ratio is being queried.</span>
  72 |     | <span class='neutral'>     * @param poolId The id of the pool in which the account&#39;s position is held.</span>
  73 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the queried position.</span>
  74 |     | <span class='neutral'>     * @return ratioD18 The collateralization ratio of the position (collateral / debt), denominated with 18 decimals of precision.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function getPositionCollateralRatio(</span>
  77 |     | <span class='neutral'>        uint128 accountId,</span>
  78 |     | <span class='neutral'>        uint128 poolId,</span>
  79 |     | <span class='neutral'>        address collateralType</span>
  80 |     | <span class='neutral'>    ) external returns (uint256 ratioD18);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @notice Returns the debt of the specified liquidity position. Credit is expressed as negative debt.</span>
  84 |     | <span class='neutral'>     * @dev This is not a view function, and actually updates the entire debt distribution chain.</span>
  85 |     | <span class='neutral'>     * @dev Call this function using `callStatic` to treat it as a view function.</span>
  86 |     | <span class='neutral'>     * @param accountId The id of the account being queried.</span>
  87 |     | <span class='neutral'>     * @param poolId The id of the pool in which the account&#39;s position is held.</span>
  88 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the queried position.</span>
  89 |     | <span class='neutral'>     * @return debtD18 The amount of debt held by the position, denominated with 18 decimals of precision.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function getPositionDebt(</span>
  92 |     | <span class='neutral'>        uint128 accountId,</span>
  93 |     | <span class='neutral'>        uint128 poolId,</span>
  94 |     | <span class='neutral'>        address collateralType</span>
  95 |     | <span class='neutral'>    ) external returns (int256 debtD18);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @notice Returns the amount of the collateral associated with the specified liquidity position.</span>
  99 |     | <span class='neutral'>     * @dev Call this function using `callStatic` to treat it as a view function.</span>
 100 |     | <span class='neutral'>     * @dev collateralAmount is represented as an integer with 18 decimals.</span>
 101 |     | <span class='neutral'>     * @param accountId The id of the account being queried.</span>
 102 |     | <span class='neutral'>     * @param poolId The id of the pool in which the account&#39;s position is held.</span>
 103 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the queried position.</span>
 104 |     | <span class='neutral'>     * @return collateralAmountD18 The amount of collateral used in the position, denominated with 18 decimals of precision.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    function getPositionCollateral(</span>
 107 |     | <span class='neutral'>        uint128 accountId,</span>
 108 |     | <span class='neutral'>        uint128 poolId,</span>
 109 |     | <span class='neutral'>        address collateralType</span>
 110 |     | <span class='neutral'>    ) external view returns (uint256 collateralAmountD18);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @notice Returns all information pertaining to a specified liquidity position in the vault module.</span>
 114 |     | <span class='neutral'>     * @param accountId The id of the account being queried.</span>
 115 |     | <span class='neutral'>     * @param poolId The id of the pool in which the account&#39;s position is held.</span>
 116 |     | <span class='neutral'>     * @param collateralType The address of the collateral used in the queried position.</span>
 117 |     | <span class='neutral'>     * @return collateralAmountD18 The amount of collateral used in the position, denominated with 18 decimals of precision.</span>
 118 |     | <span class='neutral'>     * @return collateralValueD18 The value of the collateral used in the position, denominated with 18 decimals of precision.</span>
 119 |     | <span class='neutral'>     * @return debtD18 The amount of debt held in the position, denominated with 18 decimals of precision.</span>
 120 |     | <span class='neutral'>     * @return collateralizationRatioD18 The collateralization ratio of the position (collateral / debt), denominated with 18 decimals of precision.</span>
 121 |     | <span class='neutral'>     **/</span>
 122 |     | <span class='neutral'>    function getPosition(</span>
 123 |     | <span class='neutral'>        uint128 accountId,</span>
 124 |     | <span class='neutral'>        uint128 poolId,</span>
 125 |     | <span class='neutral'>        address collateralType</span>
 126 |     | <span class='neutral'>    )</span>
 127 |     | <span class='neutral'>        external</span>
 128 |     | <span class='neutral'>        returns (</span>
 129 |     | <span class='neutral'>            uint256 collateralAmountD18,</span>
 130 |     | <span class='neutral'>            uint256 collateralValueD18,</span>
 131 |     | <span class='neutral'>            int256 debtD18,</span>
 132 |     | <span class='neutral'>            uint256 collateralizationRatioD18</span>
 133 |     | <span class='neutral'>        );</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @notice Returns the total debt (or credit) that the vault is responsible for. Credit is expressed as negative debt.</span>
 137 |     | <span class='neutral'>     * @dev This is not a view function, and actually updates the entire debt distribution chain.</span>
 138 |     | <span class='neutral'>     * @dev Call this function using `callStatic` to treat it as a view function.</span>
 139 |     | <span class='neutral'>     * @param poolId The id of the pool that owns the vault whose debt is being queried.</span>
 140 |     | <span class='neutral'>     * @param collateralType The address of the collateral of the associated vault.</span>
 141 |     | <span class='neutral'>     * @return debtD18 The overall debt of the vault, denominated with 18 decimals of precision.</span>
 142 |     | <span class='neutral'>     **/</span>
 143 |     | <span class='neutral'>    function getVaultDebt(uint128 poolId, address collateralType) external returns (int256 debtD18);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /**</span>
 146 |     | <span class='neutral'>     * @notice Returns the amount and value of the collateral held by the vault.</span>
 147 |     | <span class='neutral'>     * @dev Call this function using `callStatic` to treat it as a view function.</span>
 148 |     | <span class='neutral'>     * @dev collateralAmount is represented as an integer with 18 decimals.</span>
 149 |     | <span class='neutral'>     * @dev collateralValue is represented as an integer with the number of decimals specified by the collateralType.</span>
 150 |     | <span class='neutral'>     * @param poolId The id of the pool that owns the vault whose collateral is being queried.</span>
 151 |     | <span class='neutral'>     * @param collateralType The address of the collateral of the associated vault.</span>
 152 |     | <span class='neutral'>     * @return collateralAmountD18 The collateral amount of the vault, denominated with 18 decimals of precision.</span>
 153 |     | <span class='neutral'>     * @return collateralValueD18 The collateral value of the vault, denominated with 18 decimals of precision.</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function getVaultCollateral(</span>
 156 |     | <span class='neutral'>        uint128 poolId,</span>
 157 |     | <span class='neutral'>        address collateralType</span>
 158 |     | <span class='neutral'>    ) external view returns (uint256 collateralAmountD18, uint256 collateralValueD18);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @notice Returns the collateralization ratio of the vault. If debt is negative, this function will return 0.</span>
 162 |     | <span class='neutral'>     * @dev Call this function using `callStatic` to treat it as a view function.</span>
 163 |     | <span class='neutral'>     * @dev The return value is a percentage with 18 decimals places.</span>
 164 |     | <span class='neutral'>     * @param poolId The id of the pool that owns the vault whose collateralization ratio is being queried.</span>
 165 |     | <span class='neutral'>     * @param collateralType The address of the collateral of the associated vault.</span>
 166 |     | <span class='neutral'>     * @return ratioD18 The collateralization ratio of the vault, denominated with 18 decimals of precision.</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='neutral'>    function getVaultCollateralRatio(</span>
 169 |     | <span class='neutral'>        uint128 poolId,</span>
 170 |     | <span class='neutral'>        address collateralType</span>
 171 |     | <span class='neutral'>    ) external returns (uint256 ratioD18);</span>
 172 |     | <span class='neutral'>}</span>
 173 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/external/IMarket.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Interface for markets integrated with Synthetix</span>
  7 |     | <span class='neutral'>interface IMarket is IERC165 {</span>
  8 |     | <span class='neutral'>    /// @notice returns a human-readable name for a given market</span>
  9 |     | <span class='neutral'>    function name(uint128 marketId) external view returns (string memory);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @notice returns amount of USD that the market would try to mint if everything was withdrawn</span>
 12 |     | <span class='neutral'>    function reportedDebt(uint128 marketId) external view returns (uint256);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice prevents reduction of available credit capacity by specifying this amount, for which withdrawals will be disallowed</span>
 15 |     | <span class='neutral'>    function minimumCredit(uint128 marketId) external view returns (uint256);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/external/IOracleManager.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Effective interface for the oracle manager</span>
  7 |     | <span class='neutral'>// solhint-disable-next-line no-empty-blocks</span>
  8 |     | <span class='neutral'>interface IOracleManager is INodeModule {}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Interface a reward distributor.</span>
  7 |     | <span class='neutral'>interface IRewardDistributor is IERC165 {</span>
  8 |     | <span class='neutral'>    /// @notice Returns a human-readable name for the reward distributor</span>
  9 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @notice This function should revert if ERC2771Context._msgSender() is not the Synthetix CoreProxy address.</span>
 12 |     | <span class='neutral'>    /// @return whether or not the payout was executed</span>
 13 |     | <span class='neutral'>    function payout(</span>
 14 |     | <span class='neutral'>        uint128 accountId,</span>
 15 |     | <span class='neutral'>        uint128 poolId,</span>
 16 |     | <span class='neutral'>        address collateralType,</span>
 17 |     | <span class='neutral'>        address sender,</span>
 18 |     | <span class='neutral'>        uint256 amount</span>
 19 |     | <span class='neutral'>    ) external returns (bool);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice This function is called by the Synthetix Core Proxy whenever</span>
 22 |     | <span class='neutral'>    /// a position is updated on a pool which this distributor is registered</span>
 23 |     | <span class='neutral'>    function onPositionUpdated(</span>
 24 |     | <span class='neutral'>        uint128 accountId,</span>
 25 |     | <span class='neutral'>        uint128 poolId,</span>
 26 |     | <span class='neutral'>        address collateralType,</span>
 27 |     | <span class='neutral'>        uint256 newShares</span>
 28 |     | <span class='neutral'>    ) external;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Address to ERC-20 token distributed by this distributor, for display purposes only</span>
 31 |     | <span class='neutral'>    /// @dev Return address(0) if providing non ERC-20 rewards</span>
 32 |     | <span class='neutral'>    function token() external view returns (address);</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Account.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./AccountRBAC.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Collateral.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Pool.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &quot;../interfaces/ICollateralModule.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/**</span>
  14 |     | <span class='neutral'> * @title Object for tracking accounts with access control and collateral tracking.</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='unexecuted'>library Account {</span>
  17 |     | <span class='neutral'>    using AccountRBAC for AccountRBAC.Data;</span>
  18 |     | <span class='neutral'>    using Pool for Pool.Data;</span>
  19 |     | <span class='neutral'>    using Collateral for Collateral.Data;</span>
  20 |     | <span class='neutral'>    using SetUtil for SetUtil.UintSet;</span>
  21 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  22 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  23 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  24 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /**</span>
  27 |     | <span class='neutral'>     * @dev Thrown when the given target address does not have the given permission with the given account.</span>
  28 |     | <span class='neutral'>     */</span>
  29 |     | <span class='neutral'>    error PermissionDenied(uint128 accountId, bytes32 permission, address target);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @dev Thrown when an account cannot be found.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    error AccountNotFound(uint128 accountId);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @dev Thrown when the requested operation requires an activity timeout before the</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    error AccountActivityTimeoutPending(</span>
  40 |     | <span class='neutral'>        uint128 accountId,</span>
  41 |     | <span class='neutral'>        uint256 currentTime,</span>
  42 |     | <span class='neutral'>        uint256 requiredTime</span>
  43 |     | <span class='neutral'>    );</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct Data {</span>
  46 |     | <span class='neutral'>        /**</span>
  47 |     | <span class='neutral'>         * @dev Numeric identifier for the account. Must be unique.</span>
  48 |     | <span class='neutral'>         * @dev There cannot be an account with id zero (See ERC721._mint()).</span>
  49 |     | <span class='neutral'>         */</span>
  50 |     | <span class='neutral'>        uint128 id;</span>
  51 |     | <span class='neutral'>        /**</span>
  52 |     | <span class='neutral'>         * @dev Role based access control data for the account.</span>
  53 |     | <span class='neutral'>         */</span>
  54 |     | <span class='neutral'>        AccountRBAC.Data rbac;</span>
  55 |     | <span class='neutral'>        uint64 lastInteraction;</span>
  56 |     | <span class='neutral'>        uint64 __slotAvailableForFutureUse;</span>
  57 |     | <span class='neutral'>        uint128 __slot2AvailableForFutureUse;</span>
  58 |     | <span class='neutral'>        /**</span>
  59 |     | <span class='neutral'>         * @dev Address set of collaterals that are being used in the system by this account.</span>
  60 |     | <span class='neutral'>         */</span>
  61 |     | <span class='neutral'>        mapping(address =&gt; Collateral.Data) collaterals;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @dev Returns the account stored at the specified account id.</span>
  66 |     | <span class='neutral'>     */</span>
  67 | *   | <span class='executed'>    function load(uint128 id) internal pure returns (Data storage account) {</span>
  68 | *   | <span class='executed'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.synthetix.Account&quot;, id));</span>
  69 |     | <span class='neutral'>        assembly {</span>
  70 |     | <span class='neutral'>            account.slot := s</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Creates an account for the given id, and associates it to the given owner.</span>
  76 |     | <span class='neutral'>     *</span>
  77 |     | <span class='neutral'>     * Note: Will not fail if the account already exists, and if so, will overwrite the existing owner. Whatever calls this internal function must first check that the account doesn&#39;t exist before re-creating it.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='unexecuted'>    function create(uint128 id, address owner) internal returns (Data storage account) {</span>
  80 |     | <span class='unexecuted'>        account = load(id);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        account.id = id;</span>
  83 |     | <span class='unexecuted'>        account.rbac.owner = owner;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Reverts if the account does not exist with appropriate error. Otherwise, returns the account.</span>
  88 |     | <span class='neutral'>     */</span>
  89 | *   | <span class='executed'>    function exists(uint128 id) internal view returns (Data storage account) {</span>
  90 | *   | <span class='executed'>        Data storage a = load(id);</span>
  91 | *   | <span class='executed'>        if (a.rbac.owner == address(0)) {</span>
  92 | *   | <span class='executed'>            revert AccountNotFound(id);</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        return a;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev Given a collateral type, returns information about the total collateral assigned, deposited, and locked by the account</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function getCollateralTotals(</span>
 102 |     | <span class='neutral'>        Data storage self,</span>
 103 |     | <span class='neutral'>        address collateralType</span>
 104 |     | <span class='neutral'>    )</span>
 105 |     | <span class='neutral'>        internal</span>
 106 |     | <span class='neutral'>        view</span>
 107 |     | <span class='neutral'>        returns (uint256 totalDepositedD18, uint256 totalAssignedD18, uint256 totalLockedD18)</span>
 108 |     | <span class='neutral'>    {</span>
 109 |     | <span class='neutral'>        totalAssignedD18 = getAssignedCollateral(self, collateralType);</span>
 110 |     | <span class='neutral'>        totalDepositedD18 =</span>
 111 |     | <span class='neutral'>            totalAssignedD18 +</span>
 112 |     | <span class='neutral'>            self.collaterals[collateralType].amountAvailableForDelegationD18;</span>
 113 |     | <span class='neutral'>        totalLockedD18 = self.collaterals[collateralType].getTotalLocked();</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        return (totalDepositedD18, totalAssignedD18, totalLockedD18);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @dev Returns the total amount of collateral that has been delegated to pools by the account, for the given collateral type.</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    function getAssignedCollateral(</span>
 122 |     | <span class='neutral'>        Data storage self,</span>
 123 |     | <span class='neutral'>        address collateralType</span>
 124 |     | <span class='neutral'>    ) internal view returns (uint256) {</span>
 125 |     | <span class='neutral'>        uint256 totalAssignedD18 = 0;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        SetUtil.UintSet storage pools = self.collaterals[collateralType].pools;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        for (uint256 i = 1; i &lt;= pools.length(); i++) {</span>
 130 |     | <span class='neutral'>            uint128 poolIdx = pools.valueAt(i).to128();</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>            Pool.Data storage pool = Pool.load(poolIdx);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>            (uint256 collateralAmountD18, ) = pool.currentAccountCollateral(</span>
 135 |     | <span class='neutral'>                collateralType,</span>
 136 |     | <span class='neutral'>                self.id</span>
 137 |     | <span class='neutral'>            );</span>
 138 |     | <span class='neutral'>            totalAssignedD18 += collateralAmountD18;</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        return totalAssignedD18;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>    function recordInteraction(Data storage self) internal {</span>
 145 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
 146 | *   | <span class='executed'>        self.lastInteraction = uint64(block.timestamp);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Loads the Account object for the specified accountId,</span>
 151 |     | <span class='neutral'>     * and validates that sender has the specified permission. It also resets</span>
 152 |     | <span class='neutral'>     * the interaction timeout. These</span>
 153 |     | <span class='neutral'>     * are different actions but they are merged in a single function</span>
 154 |     | <span class='neutral'>     * because loading an account and checking for a permission is a very</span>
 155 |     | <span class='neutral'>     * common use case in other parts of the code.</span>
 156 |     | <span class='neutral'>     */</span>
 157 | *   | <span class='executed'>    function loadAccountAndValidatePermission(</span>
 158 |     | <span class='neutral'>        uint128 accountId,</span>
 159 |     | <span class='neutral'>        bytes32 permission</span>
 160 | *   | <span class='executed'>    ) internal returns (Data storage account) {</span>
 161 | *   | <span class='executed'>        account = Account.load(accountId);</span>
 162 |     | <span class='neutral'></span>
 163 | *   | <span class='executed'>        if (!account.rbac.authorized(permission, ERC2771Context._msgSender())) {</span>
 164 |     | <span class='unexecuted'>            revert PermissionDenied(accountId, permission, ERC2771Context._msgSender());</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'></span>
 167 | *   | <span class='executed'>        recordInteraction(account);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /**</span>
 171 |     | <span class='neutral'>     * @dev Loads the Account object for the specified accountId,</span>
 172 |     | <span class='neutral'>     * and validates that sender has the specified permission. It also resets</span>
 173 |     | <span class='neutral'>     * the interaction timeout. These</span>
 174 |     | <span class='neutral'>     * are different actions but they are merged in a single function</span>
 175 |     | <span class='neutral'>     * because loading an account and checking for a permission is a very</span>
 176 |     | <span class='neutral'>     * common use case in other parts of the code.</span>
 177 |     | <span class='neutral'>     */</span>
 178 |     | <span class='neutral'>    function loadAccountAndValidatePermissionAndTimeout(</span>
 179 |     | <span class='neutral'>        uint128 accountId,</span>
 180 |     | <span class='neutral'>        bytes32 permission,</span>
 181 |     | <span class='neutral'>        uint256 timeout</span>
 182 |     | <span class='neutral'>    ) internal view returns (Data storage account) {</span>
 183 |     | <span class='neutral'>        account = Account.load(accountId);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        if (!account.rbac.authorized(permission, ERC2771Context._msgSender())) {</span>
 186 |     | <span class='neutral'>            revert PermissionDenied(accountId, permission, ERC2771Context._msgSender());</span>
 187 |     | <span class='neutral'>        }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        uint256 endWaitingPeriod = account.lastInteraction + timeout;</span>
 190 |     | <span class='neutral'>        if (block.timestamp &lt; endWaitingPeriod) {</span>
 191 |     | <span class='neutral'>            revert AccountActivityTimeoutPending(accountId, block.timestamp, endWaitingPeriod);</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     * @dev Ensure that the account has the required amount of collateral funds remaining</span>
 197 |     | <span class='neutral'>     */</span>
 198 |     | <span class='neutral'>    function requireSufficientCollateral(</span>
 199 |     | <span class='neutral'>        uint128 accountId,</span>
 200 |     | <span class='neutral'>        address collateralType,</span>
 201 |     | <span class='neutral'>        uint256 amountD18</span>
 202 |     | <span class='neutral'>    ) internal view {</span>
 203 |     | <span class='neutral'>        if (</span>
 204 |     | <span class='neutral'>            Account.load(accountId).collaterals[collateralType].amountAvailableForDelegationD18 &lt;</span>
 205 |     | <span class='neutral'>            amountD18</span>
 206 |     | <span class='neutral'>        ) {</span>
 207 |     | <span class='neutral'>            revert ICollateralModule.InsufficientAccountCollateral(amountD18);</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'>}</span>
 211 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/AccountRBAC.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/errors/AddressError.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title Object for tracking an accounts permissions (role based access control).</span>
   9 |     | <span class='neutral'> */</span>
  10 |     | <span class='unexecuted'>library AccountRBAC {</span>
  11 |     | <span class='neutral'>    using SetUtil for SetUtil.Bytes32Set;</span>
  12 |     | <span class='neutral'>    using SetUtil for SetUtil.AddressSet;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /**</span>
  15 |     | <span class='neutral'>     * @dev All permissions used by the system</span>
  16 |     | <span class='neutral'>     * need to be hardcoded here.</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='neutral'>    bytes32 internal constant _ADMIN_PERMISSION = &quot;ADMIN&quot;;</span>
  19 |     | <span class='neutral'>    bytes32 internal constant _WITHDRAW_PERMISSION = &quot;WITHDRAW&quot;;</span>
  20 |     | <span class='neutral'>    bytes32 internal constant _DELEGATE_PERMISSION = &quot;DELEGATE&quot;;</span>
  21 |     | <span class='neutral'>    bytes32 internal constant _MINT_PERMISSION = &quot;MINT&quot;;</span>
  22 |     | <span class='neutral'>    bytes32 internal constant _REWARDS_PERMISSION = &quot;REWARDS&quot;;</span>
  23 |     | <span class='neutral'>    bytes32 internal constant _PERPS_MODIFY_COLLATERAL_PERMISSION = &quot;PERPS_MODIFY_COLLATERAL&quot;;</span>
  24 |     | <span class='neutral'>    bytes32 internal constant _PERPS_COMMIT_ASYNC_ORDER_PERMISSION = &quot;PERPS_COMMIT_ASYNC_ORDER&quot;;</span>
  25 |     | <span class='neutral'>    bytes32 internal constant _BURN_PERMISSION = &quot;BURN&quot;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Thrown when a permission specified by a user does not exist or is invalid.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    error InvalidPermission(bytes32 permission);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    struct Data {</span>
  33 |     | <span class='neutral'>        /**</span>
  34 |     | <span class='neutral'>         * @dev The owner of the account and admin of all permissions.</span>
  35 |     | <span class='neutral'>         */</span>
  36 |     | <span class='neutral'>        address owner;</span>
  37 |     | <span class='neutral'>        /**</span>
  38 |     | <span class='neutral'>         * @dev Set of permissions for each address enabled by the account.</span>
  39 |     | <span class='neutral'>         */</span>
  40 |     | <span class='neutral'>        mapping(address =&gt; SetUtil.Bytes32Set) permissions;</span>
  41 |     | <span class='neutral'>        /**</span>
  42 |     | <span class='neutral'>         * @dev Array of addresses that this account has given permissions to.</span>
  43 |     | <span class='neutral'>         */</span>
  44 |     | <span class='neutral'>        SetUtil.AddressSet permissionAddresses;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Reverts if the specified permission is unknown to the account RBAC system.</span>
  49 |     | <span class='neutral'>     */</span>
  50 |     | <span class='neutral'>    function isPermissionValid(bytes32 permission) internal pure {</span>
  51 |     | <span class='neutral'>        if (</span>
  52 |     | <span class='neutral'>            permission != AccountRBAC._WITHDRAW_PERMISSION &amp;&amp;</span>
  53 |     | <span class='neutral'>            permission != AccountRBAC._DELEGATE_PERMISSION &amp;&amp;</span>
  54 |     | <span class='neutral'>            permission != AccountRBAC._MINT_PERMISSION &amp;&amp;</span>
  55 |     | <span class='neutral'>            permission != AccountRBAC._ADMIN_PERMISSION &amp;&amp;</span>
  56 |     | <span class='neutral'>            permission != AccountRBAC._REWARDS_PERMISSION &amp;&amp;</span>
  57 |     | <span class='neutral'>            permission != AccountRBAC._PERPS_MODIFY_COLLATERAL_PERMISSION &amp;&amp;</span>
  58 |     | <span class='neutral'>            permission != AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION &amp;&amp;</span>
  59 |     | <span class='neutral'>            permission != AccountRBAC._BURN_PERMISSION</span>
  60 |     | <span class='neutral'>        ) {</span>
  61 |     | <span class='neutral'>            revert InvalidPermission(permission);</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Sets the owner of the account.</span>
  67 |     | <span class='neutral'>     */</span>
  68 |     | <span class='neutral'>    function setOwner(Data storage self, address owner) internal {</span>
  69 |     | <span class='neutral'>        self.owner = owner;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Grants a particular permission to the specified target address.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='unexecuted'>    function grantPermission(Data storage self, bytes32 permission, address target) internal {</span>
  76 |     | <span class='unexecuted'>        if (target == address(0)) {</span>
  77 |     | <span class='unexecuted'>            revert AddressError.ZeroAddress();</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        if (permission == &quot;&quot;) {</span>
  81 |     | <span class='unexecuted'>            revert InvalidPermission(&quot;&quot;);</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        if (!self.permissionAddresses.contains(target)) {</span>
  85 |     | <span class='unexecuted'>            self.permissionAddresses.add(target);</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        self.permissions[target].add(permission);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Revokes a particular permission from the specified target address.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='neutral'>    function revokePermission(Data storage self, bytes32 permission, address target) internal {</span>
  95 |     | <span class='neutral'>        self.permissions[target].remove(permission);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        if (self.permissions[target].length() == 0) {</span>
  98 |     | <span class='neutral'>            self.permissionAddresses.remove(target);</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Revokes all permissions for the specified target address.</span>
 104 |     | <span class='neutral'>     * @notice only removes permissions for the given address, not for the entire account</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    function revokeAllPermissions(Data storage self, address target) internal {</span>
 107 |     | <span class='neutral'>        bytes32[] memory permissions = self.permissions[target].values();</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        if (permissions.length == 0) {</span>
 110 |     | <span class='neutral'>            return;</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; permissions.length; i++) {</span>
 114 |     | <span class='neutral'>            self.permissions[target].remove(permissions[i]);</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        self.permissionAddresses.remove(target);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /**</span>
 121 |     | <span class='neutral'>     * @dev Returns wether the specified address has the given permission.</span>
 122 |     | <span class='neutral'>     */</span>
 123 |     | <span class='unexecuted'>    function hasPermission(</span>
 124 |     | <span class='neutral'>        Data storage self,</span>
 125 |     | <span class='neutral'>        bytes32 permission,</span>
 126 |     | <span class='neutral'>        address target</span>
 127 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 128 |     | <span class='unexecuted'>        return target != address(0) &amp;&amp; self.permissions[target].contains(permission);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev Returns wether the specified target address has the given permission, or has the high level admin permission.</span>
 133 |     | <span class='neutral'>     */</span>
 134 | *   | <span class='executed'>    function authorized(</span>
 135 |     | <span class='neutral'>        Data storage self,</span>
 136 |     | <span class='neutral'>        bytes32 permission,</span>
 137 |     | <span class='neutral'>        address target</span>
 138 | *   | <span class='executed'>    ) internal view returns (bool) {</span>
 139 | *   | <span class='executed'>        return ((target == self.owner) ||</span>
 140 | *   | <span class='executed'>            hasPermission(self, _ADMIN_PERMISSION, target) ||</span>
 141 | *   | <span class='executed'>            hasPermission(self, permission, target));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Collateral.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;./CollateralLock.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title Stores information about a deposited asset for a given account.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * Each account will have one of these objects for each type of collateral it deposited in the system.</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='unexecuted'>library Collateral {</span>
 15 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Thrown when a specified market is not found.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    error InsufficentAvailableCollateral(</span>
 21 |     | <span class='neutral'>        uint256 amountAvailableForDelegationD18,</span>
 22 |     | <span class='neutral'>        uint256 amountD18</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    struct Data {</span>
 26 |     | <span class='neutral'>        /**</span>
 27 |     | <span class='neutral'>         * @dev The amount that can be withdrawn or delegated in this collateral.</span>
 28 |     | <span class='neutral'>         */</span>
 29 |     | <span class='neutral'>        uint256 amountAvailableForDelegationD18;</span>
 30 |     | <span class='neutral'>        /**</span>
 31 |     | <span class='neutral'>         * @dev The pools to which this collateral delegates to.</span>
 32 |     | <span class='neutral'>         */</span>
 33 |     | <span class='neutral'>        SetUtil.UintSet pools;</span>
 34 |     | <span class='neutral'>        /**</span>
 35 |     | <span class='neutral'>         * @dev Marks portions of the collateral as locked,</span>
 36 |     | <span class='neutral'>         * until a given unlock date.</span>
 37 |     | <span class='neutral'>         *</span>
 38 |     | <span class='neutral'>         * Note: Locks apply to delegated collateral and to collateral not</span>
 39 |     | <span class='neutral'>         * assigned or delegated to a pool (see ICollateralModule).</span>
 40 |     | <span class='neutral'>         */</span>
 41 |     | <span class='neutral'>        CollateralLock.Data[] locks;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Increments the entry&#39;s availableCollateral.</span>
 46 |     | <span class='neutral'>     */</span>
 47 |     | <span class='neutral'>    function increaseAvailableCollateral(Data storage self, uint256 amountD18) internal {</span>
 48 |     | <span class='neutral'>        self.amountAvailableForDelegationD18 += amountD18;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /**</span>
 52 |     | <span class='neutral'>     * @dev Decrements the entry&#39;s availableCollateral.</span>
 53 |     | <span class='neutral'>     */</span>
 54 |     | <span class='neutral'>    function decreaseAvailableCollateral(Data storage self, uint256 amountD18) internal {</span>
 55 |     | <span class='neutral'>        if (self.amountAvailableForDelegationD18 &lt; amountD18) {</span>
 56 |     | <span class='neutral'>            revert InsufficentAvailableCollateral(self.amountAvailableForDelegationD18, amountD18);</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='neutral'>        self.amountAvailableForDelegationD18 -= amountD18;</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    /**</span>
 62 |     | <span class='neutral'>     * @dev Returns the total amount in this collateral entry that is locked.</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Sweeps through all existing locks and accumulates their amount,</span>
 65 |     | <span class='neutral'>     * if their unlock date is in the future.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    function getTotalLocked(Data storage self) internal view returns (uint256) {</span>
 68 |     | <span class='neutral'>        uint64 currentTime = block.timestamp.to64();</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>        uint256 lockedD18;</span>
 71 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; self.locks.length; i++) {</span>
 72 |     | <span class='neutral'>            CollateralLock.Data storage lock = self.locks[i];</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>            if (lock.lockExpirationTime &gt; currentTime) {</span>
 75 |     | <span class='neutral'>                lockedD18 += lock.amountD18;</span>
 76 |     | <span class='neutral'>            }</span>
 77 |     | <span class='neutral'>        }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>        return lockedD18;</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'>}</span>
 82 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/CollateralConfiguration.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/errors/ParameterError.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC20.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>import &quot;./OracleManager.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/**</span>
  15 |     | <span class='neutral'> * @title Tracks system-wide settings for each collateral type, as well as helper functions for it, such as retrieving its current price from the oracle manager.</span>
  16 |     | <span class='neutral'> */</span>
  17 |     | <span class='unexecuted'>library CollateralConfiguration {</span>
  18 |     | <span class='neutral'>    bytes32 private constant _SLOT_AVAILABLE_COLLATERALS =</span>
  19 |     | <span class='neutral'>        keccak256(</span>
  20 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.synthetix.CollateralConfiguration_availableCollaterals&quot;)</span>
  21 |     | <span class='neutral'>        );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    using SetUtil for SetUtil.AddressSet;</span>
  24 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  25 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Thrown when the token address of a collateral cannot be found.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    error CollateralNotFound();</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Thrown when deposits are disabled for the given collateral type.</span>
  34 |     | <span class='neutral'>     * @param collateralType The address of the collateral type for which depositing was disabled.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    error CollateralDepositDisabled(address collateralType);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Thrown when collateral ratio is not sufficient in a given operation in the system.</span>
  40 |     | <span class='neutral'>     * @param collateralValue The net USD value of the position.</span>
  41 |     | <span class='neutral'>     * @param debt The net USD debt of the position.</span>
  42 |     | <span class='neutral'>     * @param ratio The collateralization ratio of the position.</span>
  43 |     | <span class='neutral'>     * @param minRatio The minimum c-ratio which was not met. Could be issuance ratio or liquidation ratio, depending on the case.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    error InsufficientCollateralRatio(</span>
  46 |     | <span class='neutral'>        uint256 collateralValue,</span>
  47 |     | <span class='neutral'>        uint256 debt,</span>
  48 |     | <span class='neutral'>        uint256 ratio,</span>
  49 |     | <span class='neutral'>        uint256 minRatio</span>
  50 |     | <span class='neutral'>    );</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @dev Thrown when the amount being delegated is less than the minimum expected amount.</span>
  54 |     | <span class='neutral'>     * @param minDelegation The current minimum for deposits and delegation set to this collateral type.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    error InsufficientDelegation(uint256 minDelegation);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @dev Thrown when attempting to convert a token to the system amount and the conversion results in a loss of precision.</span>
  60 |     | <span class='neutral'>     * @param tokenAmount The amount of tokens that were attempted to be converted.</span>
  61 |     | <span class='neutral'>     * @param decimals The number of decimals of the token that was attempted to be converted.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    error PrecisionLost(uint256 tokenAmount, uint8 decimals);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    struct Data {</span>
  66 |     | <span class='neutral'>        /**</span>
  67 |     | <span class='neutral'>         * @dev Allows the owner to control deposits and delegation of collateral types.</span>
  68 |     | <span class='neutral'>         */</span>
  69 |     | <span class='neutral'>        bool depositingEnabled;</span>
  70 |     | <span class='neutral'>        /**</span>
  71 |     | <span class='neutral'>         * @dev System-wide collateralization ratio for issuance of snxUSD.</span>
  72 |     | <span class='neutral'>         * Accounts will not be able to mint snxUSD if they are below this issuance c-ratio.</span>
  73 |     | <span class='neutral'>         */</span>
  74 |     | <span class='neutral'>        uint256 issuanceRatioD18;</span>
  75 |     | <span class='neutral'>        /**</span>
  76 |     | <span class='neutral'>         * @dev System-wide collateralization ratio for liquidations of this collateral type.</span>
  77 |     | <span class='neutral'>         * Accounts below this c-ratio can be immediately liquidated.</span>
  78 |     | <span class='neutral'>         */</span>
  79 |     | <span class='neutral'>        uint256 liquidationRatioD18;</span>
  80 |     | <span class='neutral'>        /**</span>
  81 |     | <span class='neutral'>         * @dev Amount of tokens to award when an account is liquidated.</span>
  82 |     | <span class='neutral'>         */</span>
  83 |     | <span class='neutral'>        uint256 liquidationRewardD18;</span>
  84 |     | <span class='neutral'>        /**</span>
  85 |     | <span class='neutral'>         * @dev The oracle manager node id which reports the current price for this collateral type.</span>
  86 |     | <span class='neutral'>         */</span>
  87 |     | <span class='neutral'>        bytes32 oracleNodeId;</span>
  88 |     | <span class='neutral'>        /**</span>
  89 |     | <span class='neutral'>         * @dev The token address for this collateral type.</span>
  90 |     | <span class='neutral'>         */</span>
  91 |     | <span class='neutral'>        address tokenAddress;</span>
  92 |     | <span class='neutral'>        /**</span>
  93 |     | <span class='neutral'>         * @dev Minimum amount that accounts can delegate to pools.</span>
  94 |     | <span class='neutral'>         * Helps prevent spamming on the system.</span>
  95 |     | <span class='neutral'>         * Note: If zero, liquidationRewardD18 will be used.</span>
  96 |     | <span class='neutral'>         */</span>
  97 |     | <span class='neutral'>        uint256 minDelegationD18;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Loads the CollateralConfiguration object for the given collateral type.</span>
 102 |     | <span class='neutral'>     * @param token The address of the collateral type.</span>
 103 |     | <span class='neutral'>     * @return collateralConfiguration The CollateralConfiguration object.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='neutral'>    function load(address token) internal pure returns (Data storage collateralConfiguration) {</span>
 106 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.synthetix.CollateralConfiguration&quot;, token));</span>
 107 |     | <span class='neutral'>        assembly {</span>
 108 |     | <span class='neutral'>            collateralConfiguration.slot := s</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @dev Loads all available collateral types configured in the system.</span>
 114 |     | <span class='neutral'>     * @return availableCollaterals An array of addresses, one for each collateral type supported by the system.</span>
 115 |     | <span class='neutral'>     */</span>
 116 |     | <span class='neutral'>    function loadAvailableCollaterals()</span>
 117 |     | <span class='neutral'>        internal</span>
 118 |     | <span class='neutral'>        pure</span>
 119 |     | <span class='neutral'>        returns (SetUtil.AddressSet storage availableCollaterals)</span>
 120 |     | <span class='neutral'>    {</span>
 121 |     | <span class='neutral'>        bytes32 s = _SLOT_AVAILABLE_COLLATERALS;</span>
 122 |     | <span class='neutral'>        assembly {</span>
 123 |     | <span class='neutral'>            availableCollaterals.slot := s</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /**</span>
 128 |     | <span class='neutral'>     * @dev Configures a collateral type.</span>
 129 |     | <span class='neutral'>     * @param config The CollateralConfiguration object with all the settings for the collateral type being configured.</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='neutral'>    function set(Data memory config) internal {</span>
 132 |     | <span class='neutral'>        SetUtil.AddressSet storage collateralTypes = loadAvailableCollaterals();</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        if (!collateralTypes.contains(config.tokenAddress)) {</span>
 135 |     | <span class='neutral'>            collateralTypes.add(config.tokenAddress);</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        if (config.minDelegationD18 &lt; config.liquidationRewardD18) {</span>
 139 |     | <span class='neutral'>            revert ParameterError.InvalidParameter(</span>
 140 |     | <span class='neutral'>                &quot;minDelegation&quot;,</span>
 141 |     | <span class='neutral'>                &quot;must be greater than liquidationReward&quot;</span>
 142 |     | <span class='neutral'>            );</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        if (config.issuanceRatioD18 &lt;= 1e18) {</span>
 146 |     | <span class='neutral'>            revert ParameterError.InvalidParameter(&quot;issuanceRatioD18&quot;, &quot;must be greater than 100%&quot;);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        if (config.liquidationRatioD18 &lt;= 1e18) {</span>
 150 |     | <span class='neutral'>            revert ParameterError.InvalidParameter(</span>
 151 |     | <span class='neutral'>                &quot;liquidationRatioD18&quot;,</span>
 152 |     | <span class='neutral'>                &quot;must be greater than 100%&quot;</span>
 153 |     | <span class='neutral'>            );</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        if (config.issuanceRatioD18 &lt; config.liquidationRatioD18) {</span>
 157 |     | <span class='neutral'>            revert ParameterError.InvalidParameter(</span>
 158 |     | <span class='neutral'>                &quot;issuanceRatioD18&quot;,</span>
 159 |     | <span class='neutral'>                &quot;must be greater than liquidationRatioD18&quot;</span>
 160 |     | <span class='neutral'>            );</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        Data storage storedConfig = load(config.tokenAddress);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        storedConfig.tokenAddress = config.tokenAddress;</span>
 166 |     | <span class='neutral'>        storedConfig.issuanceRatioD18 = config.issuanceRatioD18;</span>
 167 |     | <span class='neutral'>        storedConfig.liquidationRatioD18 = config.liquidationRatioD18;</span>
 168 |     | <span class='neutral'>        storedConfig.oracleNodeId = config.oracleNodeId;</span>
 169 |     | <span class='neutral'>        storedConfig.liquidationRewardD18 = config.liquidationRewardD18;</span>
 170 |     | <span class='neutral'>        storedConfig.minDelegationD18 = config.minDelegationD18;</span>
 171 |     | <span class='neutral'>        storedConfig.depositingEnabled = config.depositingEnabled;</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Shows if a given collateral type is enabled for deposits and delegation.</span>
 176 |     | <span class='neutral'>     * @param token The address of the collateral being queried.</span>
 177 |     | <span class='neutral'>     */</span>
 178 |     | <span class='neutral'>    function collateralEnabled(address token) internal view {</span>
 179 |     | <span class='neutral'>        if (!load(token).depositingEnabled) {</span>
 180 |     | <span class='neutral'>            revert CollateralDepositDisabled(token);</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    /**</span>
 185 |     | <span class='neutral'>     * @dev Reverts if the amount being delegated is insufficient for the system.</span>
 186 |     | <span class='neutral'>     * @param token The address of the collateral type.</span>
 187 |     | <span class='neutral'>     * @param amountD18 The amount being checked for sufficient delegation.</span>
 188 |     | <span class='neutral'>     */</span>
 189 |     | <span class='neutral'>    function requireSufficientDelegation(address token, uint256 amountD18) internal view {</span>
 190 |     | <span class='neutral'>        CollateralConfiguration.Data storage config = load(token);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>        uint256 minDelegationD18 = config.minDelegationD18;</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>        if (minDelegationD18 == 0) {</span>
 195 |     | <span class='neutral'>            minDelegationD18 = config.liquidationRewardD18;</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        if (amountD18 &lt; minDelegationD18) {</span>
 199 |     | <span class='neutral'>            revert InsufficientDelegation(minDelegationD18);</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /**</span>
 204 |     | <span class='neutral'>     * @dev Returns the price of this collateral configuration object.</span>
 205 |     | <span class='neutral'>     * @param self The CollateralConfiguration object.</span>
 206 |     | <span class='neutral'>     * @param collateralAmount The amount of collateral to get the price for.</span>
 207 |     | <span class='neutral'>     * @return The price of the collateral with 18 decimals of precision.</span>
 208 |     | <span class='neutral'>     */</span>
 209 |     | <span class='neutral'>    function getCollateralPrice(</span>
 210 |     | <span class='neutral'>        Data storage self,</span>
 211 |     | <span class='neutral'>        uint256 collateralAmount</span>
 212 |     | <span class='neutral'>    ) internal view returns (uint256) {</span>
 213 |     | <span class='neutral'>        OracleManager.Data memory oracleManager = OracleManager.load();</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        bytes32[] memory runtimeKeys = new bytes32[](1);</span>
 216 |     | <span class='neutral'>        bytes32[] memory runtimeValues = new bytes32[](1);</span>
 217 |     | <span class='neutral'>        runtimeKeys[0] = bytes32(&quot;size&quot;);</span>
 218 |     | <span class='neutral'>        runtimeValues[0] = bytes32(collateralAmount);</span>
 219 |     | <span class='neutral'>        NodeOutput.Data memory node = INodeModule(oracleManager.oracleManagerAddress)</span>
 220 |     | <span class='neutral'>            .processWithRuntime(self.oracleNodeId, runtimeKeys, runtimeValues);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>        return node.price.toUint();</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    /**</span>
 226 |     | <span class='neutral'>     * @dev Reverts if the specified collateral and debt values produce a collateralization ratio which is below the amount required for new issuance of snxUSD.</span>
 227 |     | <span class='neutral'>     * @param self The CollateralConfiguration object whose collateral and settings are being queried.</span>
 228 |     | <span class='neutral'>     * @param debtD18 The debt component of the ratio.</span>
 229 |     | <span class='neutral'>     * @param collateralValueD18 The collateral component of the ratio.</span>
 230 |     | <span class='neutral'>     */</span>
 231 |     | <span class='neutral'>    function verifyIssuanceRatio(</span>
 232 |     | <span class='neutral'>        Data storage self,</span>
 233 |     | <span class='neutral'>        uint256 debtD18,</span>
 234 |     | <span class='neutral'>        uint256 collateralValueD18,</span>
 235 |     | <span class='neutral'>        uint256 minIssuanceRatioD18</span>
 236 |     | <span class='neutral'>    ) internal view {</span>
 237 |     | <span class='neutral'>        uint256 issuanceRatioD18 = self.issuanceRatioD18 &gt; minIssuanceRatioD18</span>
 238 |     | <span class='neutral'>            ? self.issuanceRatioD18</span>
 239 |     | <span class='neutral'>            : minIssuanceRatioD18;</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>        if (</span>
 242 |     | <span class='neutral'>            debtD18 != 0 &amp;&amp;</span>
 243 |     | <span class='neutral'>            (collateralValueD18 == 0 || collateralValueD18.divDecimal(debtD18) &lt; issuanceRatioD18)</span>
 244 |     | <span class='neutral'>        ) {</span>
 245 |     | <span class='neutral'>            revert InsufficientCollateralRatio(</span>
 246 |     | <span class='neutral'>                collateralValueD18,</span>
 247 |     | <span class='neutral'>                debtD18,</span>
 248 |     | <span class='neutral'>                collateralValueD18.divDecimal(debtD18),</span>
 249 |     | <span class='neutral'>                issuanceRatioD18</span>
 250 |     | <span class='neutral'>            );</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /**</span>
 255 |     | <span class='neutral'>     * @dev Converts token amounts with non-system decimal precisions, to 18 decimals of precision.</span>
 256 |     | <span class='neutral'>     * E.g: $TOKEN_A uses 6 decimals of precision, so this would upscale it by 12 decimals.</span>
 257 |     | <span class='neutral'>     * E.g: $TOKEN_B uses 20 decimals of precision, so this would downscale it by 2 decimals.</span>
 258 |     | <span class='neutral'>     * @param self The CollateralConfiguration object corresponding to the collateral type being converted.</span>
 259 |     | <span class='neutral'>     * @param tokenAmount The token amount, denominated in its native decimal precision.</span>
 260 |     | <span class='neutral'>     * @return amountD18 The converted amount, denominated in the system&#39;s 18 decimal precision.</span>
 261 |     | <span class='neutral'>     */</span>
 262 |     | <span class='neutral'>    function convertTokenToSystemAmount(</span>
 263 |     | <span class='neutral'>        Data storage self,</span>
 264 |     | <span class='neutral'>        uint256 tokenAmount</span>
 265 |     | <span class='neutral'>    ) internal view returns (uint256 amountD18) {</span>
 266 |     | <span class='neutral'>        // this extra condition is to prevent potentially malicious untrusted code from being executed on the next statement</span>
 267 |     | <span class='neutral'>        if (self.tokenAddress == address(0)) {</span>
 268 |     | <span class='neutral'>            revert CollateralNotFound();</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>        /// @dev this try-catch block assumes there is no malicious code in the token&#39;s fallback function</span>
 272 |     | <span class='neutral'>        try IERC20(self.tokenAddress).decimals() returns (uint8 decimals) {</span>
 273 |     | <span class='neutral'>            if (decimals == 18) {</span>
 274 |     | <span class='neutral'>                amountD18 = tokenAmount;</span>
 275 |     | <span class='neutral'>            } else if (decimals &lt; 18) {</span>
 276 |     | <span class='neutral'>                amountD18 = (tokenAmount * DecimalMath.UNIT) / (10 ** decimals);</span>
 277 |     | <span class='neutral'>            } else {</span>
 278 |     | <span class='neutral'>                // ensure no precision is lost when converting to 18 decimals</span>
 279 |     | <span class='neutral'>                if (tokenAmount % (10 ** (decimals - 18)) != 0) {</span>
 280 |     | <span class='neutral'>                    revert PrecisionLost(tokenAmount, decimals);</span>
 281 |     | <span class='neutral'>                }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>                // this will scale down the amount by the difference between the token&#39;s decimals and 18</span>
 284 |     | <span class='neutral'>                amountD18 = (tokenAmount * DecimalMath.UNIT) / (10 ** decimals);</span>
 285 |     | <span class='neutral'>            }</span>
 286 |     | <span class='neutral'>        } catch {</span>
 287 |     | <span class='neutral'>            // if the token doesn&#39;t have a decimals function, assume it&#39;s 18 decimals</span>
 288 |     | <span class='neutral'>            amountD18 = tokenAmount;</span>
 289 |     | <span class='neutral'>        }</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'>}</span>
 292 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/CollateralLock.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Represents a given amount of collateral locked until a given date.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library CollateralLock {</span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        /**</span>
 10 |     | <span class='neutral'>         * @dev The amount of collateral that has been locked.</span>
 11 |     | <span class='neutral'>         */</span>
 12 |     | <span class='neutral'>        uint128 amountD18;</span>
 13 |     | <span class='neutral'>        /**</span>
 14 |     | <span class='neutral'>         * @dev The date when the locked amount becomes unlocked.</span>
 15 |     | <span class='neutral'>         */</span>
 16 |     | <span class='neutral'>        uint64 lockExpirationTime;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Config.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title System wide configuration for anything</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library Config {</span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        uint256 __unused;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Returns a config value</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function read(bytes32 k, bytes32 zeroValue) internal view returns (bytes32 v) {</span>
 16 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;Config&quot;, k));</span>
 17 |     | <span class='neutral'>        assembly {</span>
 18 |     | <span class='neutral'>            v := sload(s)</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>        if (v == bytes32(0)) {</span>
 22 |     | <span class='neutral'>            v = zeroValue;</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function readUint(bytes32 k, uint256 zeroValue) internal view returns (uint256 v) {</span>
 27 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
 28 |     | <span class='neutral'>        return uint(read(k, bytes32(zeroValue)));</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function readAddress(bytes32 k, address zeroValue) internal view returns (address v) {</span>
 32 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
 33 |     | <span class='neutral'>        return address(uint160(readUint(k, uint160(zeroValue))));</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function put(bytes32 k, bytes32 v) internal {</span>
 37 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;Config&quot;, k));</span>
 38 |     | <span class='neutral'>        assembly {</span>
 39 |     | <span class='neutral'>            sstore(s, v)</span>
 40 |     | <span class='neutral'>        }</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Distribution.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./DistributionActor.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @title Data structure that allows you to track some global value, distributed amongst a set of actors.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * The total value can be scaled with a valuePerShare multiplier, and individual actor shares can be calculated as their amount of shares times this multiplier.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * Furthermore, changes in the value of individual actors can be tracked since their last update, by keeping track of the value of the multiplier, per user, upon each interaction. See DistributionActor.lastValuePerShare.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * A distribution is similar to a ScalableMapping, but it has the added functionality of being able to remember the previous value of the scalar multiplier for each actor.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * Whenever the shares of an actor of the distribution is updated, you get information about how the actor&#39;s total value changed since it was last updated.</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='unexecuted'>library Distribution {</span>
  21 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  22 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  23 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  24 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  25 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Thrown when an attempt is made to distribute value to a distribution</span>
  29 |     | <span class='neutral'>     * with no shares.</span>
  30 |     | <span class='neutral'>     */</span>
  31 |     | <span class='neutral'>    error EmptyDistribution();</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    struct Data {</span>
  34 |     | <span class='neutral'>        /**</span>
  35 |     | <span class='neutral'>         * @dev The total number of shares in the distribution.</span>
  36 |     | <span class='neutral'>         */</span>
  37 |     | <span class='neutral'>        uint128 totalSharesD18;</span>
  38 |     | <span class='neutral'>        /**</span>
  39 |     | <span class='neutral'>         * @dev The value per share of the distribution, represented as a high precision decimal.</span>
  40 |     | <span class='neutral'>         */</span>
  41 |     | <span class='neutral'>        int128 valuePerShareD27;</span>
  42 |     | <span class='neutral'>        /**</span>
  43 |     | <span class='neutral'>         * @dev Tracks individual actor information, such as how many shares an actor has, their lastValuePerShare, etc.</span>
  44 |     | <span class='neutral'>         */</span>
  45 |     | <span class='neutral'>        mapping(bytes32 =&gt; DistributionActor.Data) actorInfo;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Inflates or deflates the total value of the distribution by the given value.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * The value being distributed ultimately modifies the distribution&#39;s valuePerShare.</span>
  52 |     | <span class='neutral'>     */</span>
  53 |     | <span class='neutral'>    function distributeValue(Data storage self, int256 valueD18) internal {</span>
  54 |     | <span class='neutral'>        if (valueD18 == 0) {</span>
  55 |     | <span class='neutral'>            return;</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        uint256 totalSharesD18 = self.totalSharesD18;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        if (totalSharesD18 == 0) {</span>
  61 |     | <span class='neutral'>            revert EmptyDistribution();</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        int256 valueD45 = valueD18 * DecimalMath.UNIT_PRECISE_INT;</span>
  65 |     | <span class='neutral'>        int256 deltaValuePerShareD27 = valueD45 / totalSharesD18.toInt();</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        self.valuePerShareD27 += deltaValuePerShareD27.to128();</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Updates an actor&#39;s number of shares in the distribution to the specified amount.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * Whenever an actor&#39;s shares are changed in this way, we record the distribution&#39;s current valuePerShare into the actor&#39;s lastValuePerShare record.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * Returns the the amount by which the actors value changed since the last update.</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='neutral'>    function setActorShares(</span>
  78 |     | <span class='neutral'>        Data storage self,</span>
  79 |     | <span class='neutral'>        bytes32 actorId,</span>
  80 |     | <span class='neutral'>        uint256 newActorSharesD18</span>
  81 |     | <span class='neutral'>    ) internal returns (int256 valueChangeD18) {</span>
  82 |     | <span class='neutral'>        valueChangeD18 = getActorValueChange(self, actorId);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        DistributionActor.Data storage actor = self.actorInfo[actorId];</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        uint128 sharesUint128D18 = newActorSharesD18.to128();</span>
  87 |     | <span class='neutral'>        self.totalSharesD18 = self.totalSharesD18 + sharesUint128D18 - actor.sharesD18;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        actor.sharesD18 = sharesUint128D18;</span>
  90 |     | <span class='neutral'>        _updateLastValuePerShare(self, actor, newActorSharesD18);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Updates an actor&#39;s lastValuePerShare to the distribution&#39;s current valuePerShare, and</span>
  95 |     | <span class='neutral'>     * returns the change in value for the actor, since their last update.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function accumulateActor(</span>
  98 |     | <span class='neutral'>        Data storage self,</span>
  99 |     | <span class='neutral'>        bytes32 actorId</span>
 100 |     | <span class='neutral'>    ) internal returns (int256 valueChangeD18) {</span>
 101 |     | <span class='neutral'>        DistributionActor.Data storage actor = self.actorInfo[actorId];</span>
 102 |     | <span class='neutral'>        return _updateLastValuePerShare(self, actor, actor.sharesD18);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev Calculates how much an actor&#39;s value has changed since its shares were last updated.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * This change is calculated as:</span>
 109 |     | <span class='neutral'>     * Since `value = valuePerShare * shares`,</span>
 110 |     | <span class='neutral'>     * then `delta_value = valuePerShare_now * shares - valuePerShare_then * shares`,</span>
 111 |     | <span class='neutral'>     * which is `(valuePerShare_now - valuePerShare_then) * shares`,</span>
 112 |     | <span class='neutral'>     * or just `delta_valuePerShare * shares`.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function getActorValueChange(</span>
 115 |     | <span class='neutral'>        Data storage self,</span>
 116 |     | <span class='neutral'>        bytes32 actorId</span>
 117 |     | <span class='neutral'>    ) internal view returns (int256 valueChangeD18) {</span>
 118 |     | <span class='neutral'>        return _getActorValueChange(self, self.actorInfo[actorId]);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Returns the number of shares owned by an actor in the distribution.</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='neutral'>    function getActorShares(</span>
 125 |     | <span class='neutral'>        Data storage self,</span>
 126 |     | <span class='neutral'>        bytes32 actorId</span>
 127 |     | <span class='neutral'>    ) internal view returns (uint256 sharesD18) {</span>
 128 |     | <span class='neutral'>        return self.actorInfo[actorId].sharesD18;</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev Returns the distribution&#39;s value per share in normal precision (18 decimals).</span>
 133 |     | <span class='neutral'>     * @param self The distribution whose value per share is being queried.</span>
 134 |     | <span class='neutral'>     * @return The value per share in 18 decimal precision.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function getValuePerShare(Data storage self) internal view returns (int256) {</span>
 137 |     | <span class='neutral'>        return self.valuePerShareD27.to256().downscale(DecimalMath.PRECISION_FACTOR);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function _updateLastValuePerShare(</span>
 141 |     | <span class='neutral'>        Data storage self,</span>
 142 |     | <span class='neutral'>        DistributionActor.Data storage actor,</span>
 143 |     | <span class='neutral'>        uint256 newActorShares</span>
 144 |     | <span class='neutral'>    ) private returns (int256 valueChangeD18) {</span>
 145 |     | <span class='neutral'>        valueChangeD18 = _getActorValueChange(self, actor);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>        actor.lastValuePerShareD27 = newActorShares == 0</span>
 148 |     | <span class='neutral'>            ? SafeCastI128.zero()</span>
 149 |     | <span class='neutral'>            : self.valuePerShareD27;</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function _getActorValueChange(</span>
 153 |     | <span class='neutral'>        Data storage self,</span>
 154 |     | <span class='neutral'>        DistributionActor.Data storage actor</span>
 155 |     | <span class='neutral'>    ) private view returns (int256 valueChangeD18) {</span>
 156 |     | <span class='neutral'>        int256 deltaValuePerShareD27 = self.valuePerShareD27 - actor.lastValuePerShareD27;</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>        int256 changedValueD45 = deltaValuePerShareD27 * actor.sharesD18.toInt();</span>
 159 |     | <span class='neutral'>        valueChangeD18 = changedValueD45 / DecimalMath.UNIT_PRECISE_INT;</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'>}</span>
 162 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/DistributionActor.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Stores information for specific actors in a Distribution.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library DistributionActor {</span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        /**</span>
 10 |     | <span class='neutral'>         * @dev The actor&#39;s current number of shares in the associated distribution.</span>
 11 |     | <span class='neutral'>         */</span>
 12 |     | <span class='neutral'>        uint128 sharesD18;</span>
 13 |     | <span class='neutral'>        /**</span>
 14 |     | <span class='neutral'>         * @dev The value per share that the associated distribution had at the time that the actor&#39;s number of shares was last modified.</span>
 15 |     | <span class='neutral'>         *</span>
 16 |     | <span class='neutral'>         * Note: This is also a high precision decimal. See Distribution.valuePerShare.</span>
 17 |     | <span class='neutral'>         */</span>
 18 |     | <span class='neutral'>        int128 lastValuePerShareD27;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Market.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/HeapUtil.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./Distribution.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./CollateralConfiguration.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./MarketPoolInfo.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import &quot;../interfaces/external/IMarket.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @title Connects external contracts that implement the `IMarket` interface to the system.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * Pools provide credit capacity (collateral) to the markets, and are reciprocally exposed to the associated market&#39;s debt.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * The Market object&#39;s main responsibility is to track collateral provided by the pools that support it, and to trace their debt back to such pools.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library Market {</span>
  20 |     | <span class='neutral'>    using Distribution for Distribution.Data;</span>
  21 |     | <span class='neutral'>    using HeapUtil for HeapUtil.Data;</span>
  22 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  23 |     | <span class='neutral'>    using DecimalMath for uint128;</span>
  24 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  25 |     | <span class='neutral'>    using DecimalMath for int128;</span>
  26 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  27 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  28 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  29 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @dev Thrown when a specified market is not found.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    error MarketNotFound(uint128 marketId);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    struct Data {</span>
  37 |     | <span class='neutral'>        /**</span>
  38 |     | <span class='neutral'>         * @dev Numeric identifier for the market. Must be unique.</span>
  39 |     | <span class='neutral'>         * @dev There cannot be a market with id zero (See MarketCreator.create()). Id zero is used as a null market reference.</span>
  40 |     | <span class='neutral'>         */</span>
  41 |     | <span class='neutral'>        uint128 id;</span>
  42 |     | <span class='neutral'>        /**</span>
  43 |     | <span class='neutral'>         * @dev Address for the external contract that implements the `IMarket` interface, which this Market objects connects to.</span>
  44 |     | <span class='neutral'>         *</span>
  45 |     | <span class='neutral'>         * Note: This object is how the system tracks the market. The actual market is external to the system, i.e. its own contract.</span>
  46 |     | <span class='neutral'>         */</span>
  47 |     | <span class='neutral'>        address marketAddress;</span>
  48 |     | <span class='neutral'>        /**</span>
  49 |     | <span class='neutral'>         * @dev Issuance can be seen as how much USD the Market &quot;has issued&quot;, printed, or has asked the system to mint on its behalf.</span>
  50 |     | <span class='neutral'>         *</span>
  51 |     | <span class='neutral'>         * More precisely it can be seen as the net difference between the USD burnt and the USD minted by the market.</span>
  52 |     | <span class='neutral'>         *</span>
  53 |     | <span class='neutral'>         * More issuance means that the market owes more USD to the system.</span>
  54 |     | <span class='neutral'>         *</span>
  55 |     | <span class='neutral'>         * A market burns USD when users deposit it in exchange for some asset that the market offers.</span>
  56 |     | <span class='neutral'>         * The Market object calls `MarketManager.depositUSD()`, which burns the USD, and decreases its issuance.</span>
  57 |     | <span class='neutral'>         *</span>
  58 |     | <span class='neutral'>         * A market mints USD when users return the asset that the market offered and thus withdraw their USD.</span>
  59 |     | <span class='neutral'>         * The Market object calls `MarketManager.withdrawUSD()`, which mints the USD, and increases its issuance.</span>
  60 |     | <span class='neutral'>         *</span>
  61 |     | <span class='neutral'>         * Instead of burning, the Market object could transfer USD to and from the MarketManager, but minting and burning takes the USD out of circulation, which doesn&#39;t affect `totalSupply`, thus simplifying accounting.</span>
  62 |     | <span class='neutral'>         *</span>
  63 |     | <span class='neutral'>         * How much USD a market can mint depends on how much credit capacity is given to the market by the pools that support it, and reflected in `Market.capacity`.</span>
  64 |     | <span class='neutral'>         *</span>
  65 |     | <span class='neutral'>         */</span>
  66 |     | <span class='neutral'>        int128 netIssuanceD18;</span>
  67 |     | <span class='neutral'>        /**</span>
  68 |     | <span class='neutral'>         * @dev The total amount of USD that the market could withdraw if it were to immediately unwrap all its positions.</span>
  69 |     | <span class='neutral'>         *</span>
  70 |     | <span class='neutral'>         * The Market&#39;s credit capacity increases when the market burns USD, i.e. when it deposits USD in the MarketManager.</span>
  71 |     | <span class='neutral'>         *</span>
  72 |     | <span class='neutral'>         * It decreases when the market mints USD, i.e. when it withdraws USD from the MarketManager.</span>
  73 |     | <span class='neutral'>         *</span>
  74 |     | <span class='neutral'>         * The Market&#39;s credit capacity also depends on how much credit is given to it by the pools that support it.</span>
  75 |     | <span class='neutral'>         *</span>
  76 |     | <span class='neutral'>         * The Market&#39;s credit capacity also has a dependency on the external market reported debt as it will respond to that debt (and hence change the credit capacity if it increases or decreases)</span>
  77 |     | <span class='neutral'>         *</span>
  78 |     | <span class='neutral'>         * The credit capacity can go negative if all of the collateral provided by pools is exhausted, and there is market provided collateral available to consume. in this case, the debt is still being</span>
  79 |     | <span class='neutral'>         * appropriately assigned, but the market has a dynamic cap based on deposited collateral types.</span>
  80 |     | <span class='neutral'>         *</span>
  81 |     | <span class='neutral'>         */</span>
  82 |     | <span class='neutral'>        int128 creditCapacityD18;</span>
  83 |     | <span class='neutral'>        /**</span>
  84 |     | <span class='neutral'>         * @dev The total balance that the market had the last time that its debt was distributed.</span>
  85 |     | <span class='neutral'>         *</span>
  86 |     | <span class='neutral'>         * A Market&#39;s debt is distributed when the reported debt of its associated external market is rolled into the pools that provide credit capacity to it.</span>
  87 |     | <span class='neutral'>         */</span>
  88 |     | <span class='neutral'>        int128 lastDistributedMarketBalanceD18;</span>
  89 |     | <span class='neutral'>        /**</span>
  90 |     | <span class='neutral'>         * @dev A heap of pools for which the market has not yet hit its maximum credit capacity.</span>
  91 |     | <span class='neutral'>         *</span>
  92 |     | <span class='neutral'>         * The heap is ordered according to this market&#39;s max value per share setting in the pools that provide credit capacity to it. See `MarketConfiguration.maxDebtShareValue`.</span>
  93 |     | <span class='neutral'>         *</span>
  94 |     | <span class='neutral'>         * The heap&#39;s getMax() and extractMax() functions allow us to retrieve the pool with the lowest `maxDebtShareValue`, since its elements are inserted and prioritized by negating their `maxDebtShareValue`.</span>
  95 |     | <span class='neutral'>         *</span>
  96 |     | <span class='neutral'>         * Lower max values per share are on the top of the heap. I.e. the heap could look like this:</span>
  97 |     | <span class='neutral'>         *  .    -1</span>
  98 |     | <span class='neutral'>         *      / \</span>
  99 |     | <span class='neutral'>         *     /   \</span>
 100 |     | <span class='neutral'>         *    -2    \</span>
 101 |     | <span class='neutral'>         *   / \    -3</span>
 102 |     | <span class='neutral'>         * -4   -5</span>
 103 |     | <span class='neutral'>         *</span>
 104 |     | <span class='neutral'>         * TL;DR: This data structure allows us to easily find the pool with the lowest or &quot;most vulnerable&quot; max value per share and process it if its actual value per share goes beyond this limit.</span>
 105 |     | <span class='neutral'>         */</span>
 106 |     | <span class='neutral'>        HeapUtil.Data inRangePools;</span>
 107 |     | <span class='neutral'>        /**</span>
 108 |     | <span class='neutral'>         * @dev A heap of pools for which the market has hit its maximum credit capacity.</span>
 109 |     | <span class='neutral'>         *</span>
 110 |     | <span class='neutral'>         * Used to reconnect pools to the market, when it falls back below its maximum credit capacity.</span>
 111 |     | <span class='neutral'>         *</span>
 112 |     | <span class='neutral'>         * See inRangePools for why a heap is used here.</span>
 113 |     | <span class='neutral'>         */</span>
 114 |     | <span class='neutral'>        HeapUtil.Data outRangePools;</span>
 115 |     | <span class='neutral'>        /**</span>
 116 |     | <span class='neutral'>         * @dev A market&#39;s debt distribution connects markets to the debt distribution chain, in this case pools. Pools are actors in the market&#39;s debt distribution, where the amount of shares they possess depends on the amount of collateral they provide to the market. The value per share of this distribution depends on the total debt or balance of the market (netIssuance + reportedDebt).</span>
 117 |     | <span class='neutral'>         *</span>
 118 |     | <span class='neutral'>         * The debt distribution chain will move debt from the market into its connected pools.</span>
 119 |     | <span class='neutral'>         *</span>
 120 |     | <span class='neutral'>         * Actors: Pools.</span>
 121 |     | <span class='neutral'>         * Shares: The USD denominated credit capacity that the pool provides to the market.</span>
 122 |     | <span class='neutral'>         * Value per share: Debt per dollar of credit that the associated external market accrues.</span>
 123 |     | <span class='neutral'>         *</span>
 124 |     | <span class='neutral'>         */</span>
 125 |     | <span class='neutral'>        Distribution.Data poolsDebtDistribution;</span>
 126 |     | <span class='neutral'>        /**</span>
 127 |     | <span class='neutral'>         * @dev Additional info needed to remember pools when they are removed from the distribution (or subsequently re-added).</span>
 128 |     | <span class='neutral'>         */</span>
 129 |     | <span class='neutral'>        mapping(uint128 =&gt; MarketPoolInfo.Data) pools;</span>
 130 |     | <span class='neutral'>        /**</span>
 131 |     | <span class='neutral'>         * @dev Array of entries of market provided collateral.</span>
 132 |     | <span class='neutral'>         *</span>
 133 |     | <span class='neutral'>         * Markets may obtain additional liquidity, beyond that coming from depositors, by providing their own collateral.</span>
 134 |     | <span class='neutral'>         *</span>
 135 |     | <span class='neutral'>         */</span>
 136 |     | <span class='neutral'>        DepositedCollateral[] depositedCollateral;</span>
 137 |     | <span class='neutral'>        /**</span>
 138 |     | <span class='neutral'>         * @dev The maximum amount of market provided collateral, per type, that this market can deposit.</span>
 139 |     | <span class='neutral'>         */</span>
 140 |     | <span class='neutral'>        mapping(address =&gt; uint256) maximumDepositableD18;</span>
 141 |     | <span class='neutral'>        uint32 minDelegateTime;</span>
 142 |     | <span class='neutral'>        uint32 __reservedForLater1;</span>
 143 |     | <span class='neutral'>        uint64 __reservedForLater2;</span>
 144 |     | <span class='neutral'>        uint64 __reservedForLater3;</span>
 145 |     | <span class='neutral'>        uint64 __reservedForLater4;</span>
 146 |     | <span class='neutral'>        /**</span>
 147 |     | <span class='neutral'>         * @dev Market-specific override of the minimum liquidity ratio</span>
 148 |     | <span class='neutral'>         */</span>
 149 |     | <span class='neutral'>        uint256 minLiquidityRatioD18;</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /**</span>
 153 |     | <span class='neutral'>     * @dev Data structure that allows the Market to track the amount of market provided collateral, per type.</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    struct DepositedCollateral {</span>
 156 |     | <span class='neutral'>        address collateralType;</span>
 157 |     | <span class='neutral'>        uint256 amountD18;</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @dev Returns the market stored at the specified market id.</span>
 162 |     | <span class='neutral'>     */</span>
 163 |     | <span class='neutral'>    function load(uint128 id) internal pure returns (Data storage market) {</span>
 164 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.synthetix.Market&quot;, id));</span>
 165 |     | <span class='neutral'>        assembly {</span>
 166 |     | <span class='neutral'>            market.slot := s</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /**</span>
 171 |     | <span class='neutral'>     * @dev Queries the external market contract for the amount of debt it has issued.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * The reported debt of a market represents the amount of USD that the market would ask the system to mint, if all of its positions were to be immediately closed.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * The reported debt of a market is collateralized by the assets in the pools which back it.</span>
 176 |     | <span class='neutral'>     *</span>
 177 |     | <span class='neutral'>     * See the `IMarket` interface.</span>
 178 |     | <span class='neutral'>     */</span>
 179 |     | <span class='neutral'>    function getReportedDebt(Data storage self) internal view returns (uint256) {</span>
 180 |     | <span class='neutral'>        return IMarket(self.marketAddress).reportedDebt(self.id);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Queries the market for the amount of collateral which should be prevented from withdrawal.</span>
 185 |     | <span class='neutral'>     */</span>
 186 |     | <span class='neutral'>    function getLockedCreditCapacity(Data storage self) internal view returns (uint256) {</span>
 187 |     | <span class='neutral'>        return IMarket(self.marketAddress).minimumCredit(self.id);</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    /**</span>
 191 |     | <span class='neutral'>     * @dev Returns the total debt of the market.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * A market&#39;s total debt represents its debt plus its issuance, and thus represents the total outstanding debt of the market.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * Note: it also takes into account the deposited collateral value. See note in  getDepositedCollateralValue()</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * Example:</span>
 198 |     | <span class='neutral'>     * (1 EUR = 1.11 USD)</span>
 199 |     | <span class='neutral'>     * If an Euro market has received 100 USD to mint 90 EUR, its reported debt is 90 EUR or 100 USD, and its issuance is -100 USD.</span>
 200 |     | <span class='neutral'>     * Thus, its total balance is 100 USD of reported debt minus 100 USD of issuance, which is 0 USD.</span>
 201 |     | <span class='neutral'>     *</span>
 202 |     | <span class='neutral'>     * Additionally, the market&#39;s totalDebt might be affected by price fluctuations via reportedDebt, or fees.</span>
 203 |     | <span class='neutral'>     *</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function totalDebt(Data storage self) internal view returns (int256) {</span>
 206 |     | <span class='neutral'>        return</span>
 207 |     | <span class='neutral'>            getReportedDebt(self).toInt() +</span>
 208 |     | <span class='neutral'>            self.netIssuanceD18 -</span>
 209 |     | <span class='neutral'>            getDepositedCollateralValue(self).toInt();</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Returns the USD value for the total amount of collateral provided by the market itself.</span>
 214 |     | <span class='neutral'>     *</span>
 215 |     | <span class='neutral'>     * Note: This is not credit capacity provided by depositors through pools.</span>
 216 |     | <span class='neutral'>     */</span>
 217 |     | <span class='neutral'>    function getDepositedCollateralValue(Data storage self) internal view returns (uint256) {</span>
 218 |     | <span class='neutral'>        uint256 totalDepositedCollateralValueD18 = 0;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // Sweep all DepositedCollateral entries and aggregate their USD value.</span>
 221 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; self.depositedCollateral.length; i++) {</span>
 222 |     | <span class='neutral'>            DepositedCollateral memory entry = self.depositedCollateral[i];</span>
 223 |     | <span class='neutral'>            CollateralConfiguration.Data storage collateralConfiguration = CollateralConfiguration</span>
 224 |     | <span class='neutral'>                .load(entry.collateralType);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>            if (entry.amountD18 == 0) {</span>
 227 |     | <span class='neutral'>                continue;</span>
 228 |     | <span class='neutral'>            }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>            uint256 priceD18 = CollateralConfiguration.getCollateralPrice(</span>
 231 |     | <span class='neutral'>                collateralConfiguration,</span>
 232 |     | <span class='neutral'>                entry.amountD18</span>
 233 |     | <span class='neutral'>            );</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>            totalDepositedCollateralValueD18 += priceD18.mulDecimal(entry.amountD18);</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>        return totalDepositedCollateralValueD18;</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    /**</span>
 242 |     | <span class='neutral'>     * @dev Returns the amount of credit capacity that a certain pool provides to the market.</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>     * This credit capacity is obtained by reading the amount of shares that the pool has in the market&#39;s debt distribution, which represents the amount of USD denominated credit capacity that the pool has provided to the market.</span>
 245 |     | <span class='neutral'>     */</span>
 246 |     | <span class='neutral'>    function getPoolCreditCapacity(</span>
 247 |     | <span class='neutral'>        Data storage self,</span>
 248 |     | <span class='neutral'>        uint128 poolId</span>
 249 |     | <span class='neutral'>    ) internal view returns (uint256) {</span>
 250 |     | <span class='neutral'>        return self.poolsDebtDistribution.getActorShares(poolId.toBytes32());</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>    /**</span>
 254 |     | <span class='neutral'>     * @dev Given an amount of shares that represent USD credit capacity from a pool, and a maximum value per share, returns the potential contribution to credit capacity that these shares could accrue, if their value per share was to hit the maximum.</span>
 255 |     | <span class='neutral'>     *</span>
 256 |     | <span class='neutral'>     * The resulting value is calculated multiplying the amount of creditCapacity provided by the pool by the delta between the maxValue per share vs current value.</span>
 257 |     | <span class='neutral'>     *</span>
 258 |     | <span class='neutral'>     * This function is used when the Pools are rebalanced to adjust each pool credit capacity based on a change in the amount of shares provided and/or a new maxValue per share</span>
 259 |     | <span class='neutral'>     *</span>
 260 |     | <span class='neutral'>     */</span>
 261 |     | <span class='neutral'>    function getCreditCapacityContribution(</span>
 262 |     | <span class='neutral'>        Data storage self,</span>
 263 |     | <span class='neutral'>        uint256 creditCapacitySharesD18,</span>
 264 |     | <span class='neutral'>        int256 maxShareValueD18</span>
 265 |     | <span class='neutral'>    ) internal view returns (int256 contributionD18) {</span>
 266 |     | <span class='neutral'>        // Determine how much the current value per share deviates from the maximum.</span>
 267 |     | <span class='neutral'>        uint256 deltaValuePerShareD18 = (maxShareValueD18 -</span>
 268 |     | <span class='neutral'>            self.poolsDebtDistribution.getValuePerShare()).toUint();</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        return deltaValuePerShareD18.mulDecimal(creditCapacitySharesD18).toInt();</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    /**</span>
 274 |     | <span class='neutral'>     * @dev Returns true if the market&#39;s current capacity is below the amount of locked capacity.</span>
 275 |     | <span class='neutral'>     *</span>
 276 |     | <span class='neutral'>     */</span>
 277 |     | <span class='neutral'>    function isCapacityLocked(Data storage self) internal view returns (bool) {</span>
 278 |     | <span class='neutral'>        return self.creditCapacityD18 &lt; getLockedCreditCapacity(self).toInt();</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>    /**</span>
 282 |     | <span class='neutral'>     * @dev Gets any outstanding debt. Do not call this method except in tests</span>
 283 |     | <span class='neutral'>     *</span>
 284 |     | <span class='neutral'>     * Note: This function should only be used in tests!</span>
 285 |     | <span class='neutral'>     */</span>
 286 |     | <span class='neutral'>    // solhint-disable-next-line private-vars-leading-underscore, func-name-mixedcase</span>
 287 |     | <span class='neutral'>    function _testOnly_getOutstandingDebt(</span>
 288 |     | <span class='neutral'>        Data storage self,</span>
 289 |     | <span class='neutral'>        uint128 poolId</span>
 290 |     | <span class='neutral'>    ) internal returns (int256 debtChangeD18) {</span>
 291 |     | <span class='neutral'>        return</span>
 292 |     | <span class='neutral'>            self.pools[poolId].pendingDebtD18.toInt() +</span>
 293 |     | <span class='neutral'>            self.poolsDebtDistribution.accumulateActor(poolId.toBytes32());</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    /**</span>
 297 |     | <span class='neutral'>     * Returns the number of pools currently active in the market</span>
 298 |     | <span class='neutral'>     *</span>
 299 |     | <span class='neutral'>     * Note: this is test only</span>
 300 |     | <span class='neutral'>     */</span>
 301 |     | <span class='neutral'>    // solhint-disable-next-line private-vars-leading-underscore, func-name-mixedcase</span>
 302 |     | <span class='neutral'>    function _testOnly_inRangePools(Data storage self) internal view returns (uint256) {</span>
 303 |     | <span class='neutral'>        return self.inRangePools.size();</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    /**</span>
 307 |     | <span class='neutral'>     * Returns the number of pools currently active in the market</span>
 308 |     | <span class='neutral'>     *</span>
 309 |     | <span class='neutral'>     * Note: this is test only</span>
 310 |     | <span class='neutral'>     */</span>
 311 |     | <span class='neutral'>    // solhint-disable-next-line private-vars-leading-underscore, func-name-mixedcase</span>
 312 |     | <span class='neutral'>    function _testOnly_outRangePools(Data storage self) internal view returns (uint256) {</span>
 313 |     | <span class='neutral'>        return self.outRangePools.size();</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Returns the debt value per share</span>
 318 |     | <span class='neutral'>     */</span>
 319 |     | <span class='neutral'>    function getDebtPerShare(Data storage self) internal view returns (int256 debtPerShareD18) {</span>
 320 |     | <span class='neutral'>        return self.poolsDebtDistribution.getValuePerShare();</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>    /**</span>
 324 |     | <span class='neutral'>     * @dev Determine the amount of debt the pool would assume if its lastValue was updated</span>
 325 |     | <span class='neutral'>     * Needed for optimization.</span>
 326 |     | <span class='neutral'>     *</span>
 327 |     | <span class='neutral'>     * Called by a pool when it distributes its debt.</span>
 328 |     | <span class='neutral'>     *</span>
 329 |     | <span class='neutral'>     */</span>
 330 |     | <span class='neutral'>    function accumulateDebtChange(</span>
 331 |     | <span class='neutral'>        Data storage self,</span>
 332 |     | <span class='neutral'>        uint128 poolId</span>
 333 |     | <span class='neutral'>    ) internal returns (int256 debtChangeD18) {</span>
 334 |     | <span class='neutral'>        int256 changedValueD18 = self.poolsDebtDistribution.accumulateActor(poolId.toBytes32());</span>
 335 |     | <span class='neutral'>        debtChangeD18 = self.pools[poolId].pendingDebtD18.toInt() + changedValueD18;</span>
 336 |     | <span class='neutral'>        self.pools[poolId].pendingDebtD18 = 0;</span>
 337 |     | <span class='neutral'>    }</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    /**</span>
 340 |     | <span class='neutral'>     * @dev Wrapper that adjusts a pool&#39;s shares in the market&#39;s credit capacity, making sure that the market&#39;s outstanding debt is first passed on to its connected pools.</span>
 341 |     | <span class='neutral'>     *</span>
 342 |     | <span class='neutral'>     * Called by a pool when it distributes its debt.</span>
 343 |     | <span class='neutral'>     *</span>
 344 |     | <span class='neutral'>     */</span>
 345 |     | <span class='neutral'>    function rebalancePools(</span>
 346 |     | <span class='neutral'>        uint128 marketId,</span>
 347 |     | <span class='neutral'>        uint128 poolId,</span>
 348 |     | <span class='neutral'>        int256 maxDebtShareValueD18, // (in USD)</span>
 349 |     | <span class='neutral'>        uint256 newCreditCapacityD18 // in collateralValue (USD)</span>
 350 |     | <span class='neutral'>    ) internal returns (int256 debtChangeD18) {</span>
 351 |     | <span class='neutral'>        Data storage self = load(marketId);</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>        if (self.marketAddress == address(0)) {</span>
 354 |     | <span class='neutral'>            revert MarketNotFound(marketId);</span>
 355 |     | <span class='neutral'>        }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>        return adjustPoolShares(self, poolId, newCreditCapacityD18, maxDebtShareValueD18);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>    /**</span>
 361 |     | <span class='neutral'>     * @dev Called by pools when they modify the credit capacity provided to the market, as well as the maximum value per share they tolerate for the market.</span>
 362 |     | <span class='neutral'>     *</span>
 363 |     | <span class='neutral'>     * These two settings affect the market in the following ways:</span>
 364 |     | <span class='neutral'>     * - Updates the pool&#39;s shares in `poolsDebtDistribution`.</span>
 365 |     | <span class='neutral'>     * - Moves the pool in and out of inRangePools/outRangePools.</span>
 366 |     | <span class='neutral'>     * - Updates the market credit capacity property.</span>
 367 |     | <span class='neutral'>     */</span>
 368 |     | <span class='neutral'>    function adjustPoolShares(</span>
 369 |     | <span class='neutral'>        Data storage self,</span>
 370 |     | <span class='neutral'>        uint128 poolId,</span>
 371 |     | <span class='neutral'>        uint256 newCreditCapacityD18,</span>
 372 |     | <span class='neutral'>        int256 newPoolMaxShareValueD18</span>
 373 |     | <span class='neutral'>    ) internal returns (int256 debtChangeD18) {</span>
 374 |     | <span class='neutral'>        uint256 oldCreditCapacityD18 = getPoolCreditCapacity(self, poolId);</span>
 375 |     | <span class='neutral'>        int256 oldPoolMaxShareValueD18 = -self.inRangePools.getById(poolId).priority;</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>        // Sanity checks</span>
 378 |     | <span class='neutral'>        // require(oldPoolMaxShareValue == 0, &quot;value is not 0&quot;);</span>
 379 |     | <span class='neutral'>        // require(newPoolMaxShareValue == 0, &quot;new pool max share value is in fact set&quot;);</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>        self.pools[poolId].creditCapacityAmountD18 = newCreditCapacityD18.to128();</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>        int128 valuePerShareD18 = self.poolsDebtDistribution.getValuePerShare().to128();</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>        if (newCreditCapacityD18 == 0) {</span>
 386 |     | <span class='neutral'>            self.inRangePools.extractById(poolId);</span>
 387 |     | <span class='neutral'>            self.outRangePools.extractById(poolId);</span>
 388 |     | <span class='neutral'>        } else if (newPoolMaxShareValueD18 &lt; valuePerShareD18) {</span>
 389 |     | <span class='neutral'>            // this will ensure calculations below can correctly gauge shares changes</span>
 390 |     | <span class='neutral'>            newCreditCapacityD18 = 0;</span>
 391 |     | <span class='neutral'>            self.inRangePools.extractById(poolId);</span>
 392 |     | <span class='neutral'>            self.outRangePools.insert(poolId, newPoolMaxShareValueD18.to128());</span>
 393 |     | <span class='neutral'>        } else {</span>
 394 |     | <span class='neutral'>            self.inRangePools.insert(poolId, -newPoolMaxShareValueD18.to128());</span>
 395 |     | <span class='neutral'>            self.outRangePools.extractById(poolId);</span>
 396 |     | <span class='neutral'>        }</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>        int256 changedValueD18 = self.poolsDebtDistribution.setActorShares(</span>
 399 |     | <span class='neutral'>            poolId.toBytes32(),</span>
 400 |     | <span class='neutral'>            newCreditCapacityD18</span>
 401 |     | <span class='neutral'>        );</span>
 402 |     | <span class='neutral'>        debtChangeD18 = self.pools[poolId].pendingDebtD18.toInt() + changedValueD18;</span>
 403 |     | <span class='neutral'>        self.pools[poolId].pendingDebtD18 = 0;</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='neutral'>        // recalculate market capacity</span>
 406 |     | <span class='neutral'>        if (newPoolMaxShareValueD18 &gt; valuePerShareD18) {</span>
 407 |     | <span class='neutral'>            self.creditCapacityD18 += getCreditCapacityContribution(</span>
 408 |     | <span class='neutral'>                self,</span>
 409 |     | <span class='neutral'>                newCreditCapacityD18,</span>
 410 |     | <span class='neutral'>                newPoolMaxShareValueD18</span>
 411 |     | <span class='neutral'>            ).to128();</span>
 412 |     | <span class='neutral'>        }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>        if (oldPoolMaxShareValueD18 &gt; valuePerShareD18) {</span>
 415 |     | <span class='neutral'>            self.creditCapacityD18 -= getCreditCapacityContribution(</span>
 416 |     | <span class='neutral'>                self,</span>
 417 |     | <span class='neutral'>                oldCreditCapacityD18,</span>
 418 |     | <span class='neutral'>                oldPoolMaxShareValueD18</span>
 419 |     | <span class='neutral'>            ).to128();</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    /**</span>
 424 |     | <span class='neutral'>     * @dev Moves debt from the market into the pools that connect to it.</span>
 425 |     | <span class='neutral'>     *</span>
 426 |     | <span class='neutral'>     * This function should be called before any of the pools&#39; shares are modified in `poolsDebtDistribution`.</span>
 427 |     | <span class='neutral'>     *</span>
 428 |     | <span class='neutral'>     * Note: The parameter `maxIter` is used as an escape hatch to discourage griefing.</span>
 429 |     | <span class='neutral'>     */</span>
 430 |     | <span class='neutral'>    function distributeDebtToPools(</span>
 431 |     | <span class='neutral'>        Data storage self,</span>
 432 |     | <span class='neutral'>        uint256 maxIter</span>
 433 |     | <span class='neutral'>    ) internal returns (bool fullyDistributed) {</span>
 434 |     | <span class='neutral'>        // Get the current and last distributed market balances.</span>
 435 |     | <span class='neutral'>        // Note: The last distributed balance will be cached within this function&#39;s execution.</span>
 436 |     | <span class='neutral'>        int256 targetBalanceD18 = totalDebt(self);</span>
 437 |     | <span class='neutral'>        int256 outstandingBalanceD18 = targetBalanceD18 - self.lastDistributedMarketBalanceD18;</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>        (, bool exhausted) = bumpPools(self, outstandingBalanceD18, maxIter);</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='neutral'>        if (!exhausted &amp;&amp; self.poolsDebtDistribution.totalSharesD18 &gt; 0) {</span>
 442 |     | <span class='neutral'>            // cannot use `outstandingBalance` here because `self.lastDistributedMarketBalance`</span>
 443 |     | <span class='neutral'>            // may have changed after calling the bump functions above</span>
 444 |     | <span class='neutral'>            self.poolsDebtDistribution.distributeValue(</span>
 445 |     | <span class='neutral'>                targetBalanceD18 - self.lastDistributedMarketBalanceD18</span>
 446 |     | <span class='neutral'>            );</span>
 447 |     | <span class='neutral'>            self.lastDistributedMarketBalanceD18 = targetBalanceD18.to128();</span>
 448 |     | <span class='neutral'>        }</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'>        return !exhausted;</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    /**</span>
 454 |     | <span class='neutral'>     * @dev Determine the target valuePerShare of the poolsDebtDistribution, given the value that is yet to be distributed.</span>
 455 |     | <span class='neutral'>     */</span>
 456 |     | <span class='neutral'>    function getTargetValuePerShare(</span>
 457 |     | <span class='neutral'>        Market.Data storage self,</span>
 458 |     | <span class='neutral'>        int256 valueToDistributeD18</span>
 459 |     | <span class='neutral'>    ) internal view returns (int256 targetValuePerShareD18) {</span>
 460 |     | <span class='neutral'>        return</span>
 461 |     | <span class='neutral'>            self.poolsDebtDistribution.getValuePerShare() +</span>
 462 |     | <span class='neutral'>            (</span>
 463 |     | <span class='neutral'>                self.poolsDebtDistribution.totalSharesD18 &gt; 0</span>
 464 |     | <span class='neutral'>                    ? valueToDistributeD18.divDecimal(</span>
 465 |     | <span class='neutral'>                        self.poolsDebtDistribution.totalSharesD18.toInt()</span>
 466 |     | <span class='neutral'>                    ) // solhint-disable-next-line numcast/safe-cast</span>
 467 |     | <span class='neutral'>                    : int256(0)</span>
 468 |     | <span class='neutral'>            );</span>
 469 |     | <span class='neutral'>    }</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>    /**</span>
 472 |     | <span class='neutral'>     * @dev Finds pools for which this market&#39;s max value per share limit is hit, distributes their debt, and disconnects the market from them.</span>
 473 |     | <span class='neutral'>     *</span>
 474 |     | <span class='neutral'>     * The debt is distributed up to the limit of the max value per share that the pool tolerates on the market.</span>
 475 |     | <span class='neutral'>     */</span>
 476 |     | <span class='neutral'>    function bumpPools(</span>
 477 |     | <span class='neutral'>        Data storage self,</span>
 478 |     | <span class='neutral'>        int256 maxDistributedD18,</span>
 479 |     | <span class='neutral'>        uint256 maxIter</span>
 480 |     | <span class='neutral'>    ) internal returns (int256 actuallyDistributedD18, bool exhausted) {</span>
 481 |     | <span class='neutral'>        if (maxDistributedD18 == 0) {</span>
 482 |     | <span class='neutral'>            return (0, false);</span>
 483 |     | <span class='neutral'>        }</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='neutral'>        // Determine the direction based on the amount to be distributed.</span>
 486 |     | <span class='neutral'>        int128 k;</span>
 487 |     | <span class='neutral'>        HeapUtil.Data storage fromHeap;</span>
 488 |     | <span class='neutral'>        HeapUtil.Data storage toHeap;</span>
 489 |     | <span class='neutral'>        if (maxDistributedD18 &gt; 0) {</span>
 490 |     | <span class='neutral'>            k = 1;</span>
 491 |     | <span class='neutral'>            fromHeap = self.inRangePools;</span>
 492 |     | <span class='neutral'>            toHeap = self.outRangePools;</span>
 493 |     | <span class='neutral'>        } else {</span>
 494 |     | <span class='neutral'>            k = -1;</span>
 495 |     | <span class='neutral'>            fromHeap = self.outRangePools;</span>
 496 |     | <span class='neutral'>            toHeap = self.inRangePools;</span>
 497 |     | <span class='neutral'>        }</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>        // Note: This loop should rarely execute its main body. When it does, it only executes once for each pool that exceeds the limit since `distributeValue` is not run for most pools. Thus, market users are not hit with any overhead as a result of this.</span>
 500 |     | <span class='neutral'>        uint256 iters;</span>
 501 |     | <span class='neutral'>        for (iters = 0; iters &lt; maxIter; iters++) {</span>
 502 |     | <span class='neutral'>            // Exit if there are no pools that can be moved</span>
 503 |     | <span class='neutral'>            if (fromHeap.size() == 0) {</span>
 504 |     | <span class='neutral'>                break;</span>
 505 |     | <span class='neutral'>            }</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>            // Identify the pool with the lowest maximum value per share.</span>
 508 |     | <span class='neutral'>            HeapUtil.Node memory edgePool = fromHeap.getMax();</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>            // 2 cases where we want to break out of this loop</span>
 511 |     | <span class='neutral'>            if (</span>
 512 |     | <span class='neutral'>                // If there is no pool in range, and we are going down</span>
 513 |     | <span class='neutral'>                (maxDistributedD18 - actuallyDistributedD18 &gt; 0 &amp;&amp;</span>
 514 |     | <span class='neutral'>                    self.poolsDebtDistribution.totalSharesD18 == 0) ||</span>
 515 |     | <span class='neutral'>                // If there is a pool in ragne, and the lowest max value per share does not hit the limit, exit</span>
 516 |     | <span class='neutral'>                // Note: `-edgePool.priority` is actually the max value per share limit of the pool</span>
 517 |     | <span class='neutral'>                (self.poolsDebtDistribution.totalSharesD18 &gt; 0 &amp;&amp;</span>
 518 |     | <span class='neutral'>                    -edgePool.priority &gt;=</span>
 519 |     | <span class='neutral'>                    k * getTargetValuePerShare(self, (maxDistributedD18 - actuallyDistributedD18)))</span>
 520 |     | <span class='neutral'>            ) {</span>
 521 |     | <span class='neutral'>                break;</span>
 522 |     | <span class='neutral'>            }</span>
 523 |     | <span class='neutral'></span>
 524 |     | <span class='neutral'>            // The pool has hit its maximum value per share and needs to be removed.</span>
 525 |     | <span class='neutral'>            // Note: No need to update capacity because pool max share value = valuePerShare when this happens.</span>
 526 |     | <span class='neutral'>            togglePool(fromHeap, toHeap);</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>            // Distribute the market&#39;s debt to the limit, i.e. for that which exceeds the maximum value per share.</span>
 529 |     | <span class='neutral'>            if (self.poolsDebtDistribution.totalSharesD18 &gt; 0) {</span>
 530 |     | <span class='neutral'>                int256 debtToLimitD18 = self</span>
 531 |     | <span class='neutral'>                    .poolsDebtDistribution</span>
 532 |     | <span class='neutral'>                    .totalSharesD18</span>
 533 |     | <span class='neutral'>                    .toInt()</span>
 534 |     | <span class='neutral'>                    .mulDecimal(</span>
 535 |     | <span class='neutral'>                        -k * edgePool.priority - self.poolsDebtDistribution.getValuePerShare() // Diff between current value and max value per share.</span>
 536 |     | <span class='neutral'>                    );</span>
 537 |     | <span class='neutral'>                self.poolsDebtDistribution.distributeValue(debtToLimitD18);</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='neutral'>                // Update the global distributed and outstanding balances with the debt that was just distributed.</span>
 540 |     | <span class='neutral'>                actuallyDistributedD18 += debtToLimitD18;</span>
 541 |     | <span class='neutral'>            } else {</span>
 542 |     | <span class='neutral'>                self.poolsDebtDistribution.valuePerShareD27 = (-k * edgePool.priority)</span>
 543 |     | <span class='neutral'>                    .to256()</span>
 544 |     | <span class='neutral'>                    .upscale(DecimalMath.PRECISION_FACTOR)</span>
 545 |     | <span class='neutral'>                    .to128();</span>
 546 |     | <span class='neutral'>            }</span>
 547 |     | <span class='neutral'></span>
 548 |     | <span class='neutral'>            // Detach the market from this pool by removing the pool&#39;s shares from the market.</span>
 549 |     | <span class='neutral'>            // The pool will remain &quot;detached&quot; until the pool manager specifies a new poolsDebtDistribution.</span>
 550 |     | <span class='neutral'>            if (maxDistributedD18 &gt; 0) {</span>
 551 |     | <span class='neutral'>                // the below requires are only for sanity</span>
 552 |     | <span class='neutral'>                require(</span>
 553 |     | <span class='neutral'>                    self.poolsDebtDistribution.getActorShares(edgePool.id.toBytes32()) &gt; 0,</span>
 554 |     | <span class='neutral'>                    &quot;no shares before actor removal&quot;</span>
 555 |     | <span class='neutral'>                );</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>                uint256 newPoolDebtD18 = self</span>
 558 |     | <span class='neutral'>                    .poolsDebtDistribution</span>
 559 |     | <span class='neutral'>                    .setActorShares(edgePool.id.toBytes32(), 0)</span>
 560 |     | <span class='neutral'>                    .toUint();</span>
 561 |     | <span class='neutral'>                self.pools[edgePool.id].pendingDebtD18 += newPoolDebtD18.to128();</span>
 562 |     | <span class='neutral'>            } else {</span>
 563 |     | <span class='neutral'>                require(</span>
 564 |     | <span class='neutral'>                    self.poolsDebtDistribution.getActorShares(edgePool.id.toBytes32()) == 0,</span>
 565 |     | <span class='neutral'>                    &quot;actor has shares before add&quot;</span>
 566 |     | <span class='neutral'>                );</span>
 567 |     | <span class='neutral'></span>
 568 |     | <span class='neutral'>                self.poolsDebtDistribution.setActorShares(</span>
 569 |     | <span class='neutral'>                    edgePool.id.toBytes32(),</span>
 570 |     | <span class='neutral'>                    self.pools[edgePool.id].creditCapacityAmountD18</span>
 571 |     | <span class='neutral'>                );</span>
 572 |     | <span class='neutral'>            }</span>
 573 |     | <span class='neutral'>        }</span>
 574 |     | <span class='neutral'></span>
 575 |     | <span class='neutral'>        // Record the accumulated distributed balance.</span>
 576 |     | <span class='neutral'>        self.lastDistributedMarketBalanceD18 += actuallyDistributedD18.to128();</span>
 577 |     | <span class='neutral'></span>
 578 |     | <span class='neutral'>        exhausted = iters == maxIter;</span>
 579 |     | <span class='neutral'>    }</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='neutral'>    /**</span>
 582 |     | <span class='neutral'>     * @dev Moves a pool from one heap into another.</span>
 583 |     | <span class='neutral'>     */</span>
 584 |     | <span class='neutral'>    function togglePool(HeapUtil.Data storage from, HeapUtil.Data storage to) internal {</span>
 585 |     | <span class='neutral'>        HeapUtil.Node memory node = from.extractMax();</span>
 586 |     | <span class='neutral'>        to.insert(node.id, -node.priority);</span>
 587 |     | <span class='neutral'>    }</span>
 588 |     | <span class='neutral'></span>
 589 |     | <span class='neutral'>    /**</span>
 590 |     | <span class='neutral'>     * @dev Returns whether or not a pool is past its maxDebtPerShare configuration for this market</span>
 591 |     | <span class='neutral'>     */</span>
 592 |     | <span class='neutral'>    function isPoolInRange(Data storage self, uint128 poolId) internal view returns (bool) {</span>
 593 |     | <span class='neutral'>        return self.inRangePools.getById(poolId).id == poolId;</span>
 594 |     | <span class='neutral'>    }</span>
 595 |     | <span class='neutral'>}</span>
 596 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/MarketConfiguration.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Tracks a market&#39;s weight within a Pool, and its maximum debt.</span>
  6 |     | <span class='neutral'> *</span>
  7 |     | <span class='neutral'> * Each pool has an array of these, with one entry per market managed by the pool.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * A market&#39;s weight determines how much liquidity the pool provides to the market, and how much debt exposure the market gives the pool.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Weights are used to calculate percentages by adding all the weights in the pool and dividing the market&#39;s weight by the total weights.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * A market&#39;s maximum debt in a pool is indicated with a maximum debt value per share.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='unexecuted'>library MarketConfiguration {</span>
 16 |     | <span class='neutral'>    struct Data {</span>
 17 |     | <span class='neutral'>        /**</span>
 18 |     | <span class='neutral'>         * @dev Numeric identifier for the market.</span>
 19 |     | <span class='neutral'>         *</span>
 20 |     | <span class='neutral'>         * Must be unique, and in a list of `MarketConfiguration[]`, must be increasing.</span>
 21 |     | <span class='neutral'>         */</span>
 22 |     | <span class='neutral'>        uint128 marketId;</span>
 23 |     | <span class='neutral'>        /**</span>
 24 |     | <span class='neutral'>         * @dev The ratio of each market&#39;s `weight` to the pool&#39;s `totalWeights` determines the pro-rata share of the market to the pool&#39;s total liquidity.</span>
 25 |     | <span class='neutral'>         */</span>
 26 |     | <span class='neutral'>        uint128 weightD18;</span>
 27 |     | <span class='neutral'>        /**</span>
 28 |     | <span class='neutral'>         * @dev Maximum value per share that a pool will tolerate for this market.</span>
 29 |     | <span class='neutral'>         *</span>
 30 |     | <span class='neutral'>         * If the the limit is met, the markets exceeding debt will be distributed, and it will be disconnected from the pool that no longer provides credit to it.</span>
 31 |     | <span class='neutral'>         *</span>
 32 |     | <span class='neutral'>         * Note: This value will have no effect if the system wide limit is hit first. See `PoolConfiguration.minLiquidityRatioD18`.</span>
 33 |     | <span class='neutral'>         */</span>
 34 |     | <span class='neutral'>        int128 maxDebtShareValueD18;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/MarketPoolInfo.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Stores information regarding a pool&#39;s relationship to a market, such that it can be added or removed from a distribution</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library MarketPoolInfo {</span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        /**</span>
 10 |     | <span class='neutral'>         * @dev The credit capacity that this pool is providing to the relevant market. Needed to re-add the pool to the distribution when going back in range.</span>
 11 |     | <span class='neutral'>         */</span>
 12 |     | <span class='neutral'>        uint128 creditCapacityAmountD18;</span>
 13 |     | <span class='neutral'>        /**</span>
 14 |     | <span class='neutral'>         * @dev The amount of debt the pool has which hasn&#39;t been passed down the debt distribution chain yet.</span>
 15 |     | <span class='neutral'>         */</span>
 16 |     | <span class='neutral'>        uint128 pendingDebtD18;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/OracleManager.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Represents Oracle Manager</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library OracleManager {</span>
  8 |     | <span class='neutral'>    bytes32 private constant _SLOT_ORACLE_MANAGER =</span>
  9 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.synthetix.OracleManager&quot;));</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    struct Data {</span>
 12 |     | <span class='neutral'>        /**</span>
 13 |     | <span class='neutral'>         * @dev The oracle manager address.</span>
 14 |     | <span class='neutral'>         */</span>
 15 |     | <span class='neutral'>        address oracleManagerAddress;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Loads the singleton storage info about the oracle manager.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function load() internal pure returns (Data storage oracleManager) {</span>
 22 |     | <span class='neutral'>        bytes32 s = _SLOT_ORACLE_MANAGER;</span>
 23 |     | <span class='neutral'>        assembly {</span>
 24 |     | <span class='neutral'>            oracleManager.slot := s</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Pool.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./Config.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Distribution.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./MarketConfiguration.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Vault.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Market.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./PoolCollateralConfiguration.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./SystemPoolConfiguration.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./PoolCollateralConfiguration.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/errors/AccessError.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  15 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>/**</span>
  18 |     | <span class='neutral'> * @title Aggregates collateral from multiple users in order to provide liquidity to a configurable set of markets.</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> * The set of markets is configured as an array of MarketConfiguration objects, where the weight of the market can be specified. This weight, and the aggregated total weight of all the configured markets, determines how much collateral from the pool each market has, as well as in what proportion the market passes on debt to the pool and thus to all its users.</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * The pool tracks the collateral provided by users using an array of Vaults objects, for which there will be one per collateral type. Each vault tracks how much collateral each user has delegated to this pool, how much debt the user has because of minting USD, as well as how much corresponding debt the pool has passed on to the user.</span>
  23 |     | <span class='neutral'> */</span>
  24 |     | <span class='unexecuted'>library Pool {</span>
  25 |     | <span class='neutral'>    using CollateralConfiguration for CollateralConfiguration.Data;</span>
  26 |     | <span class='neutral'>    using Market for Market.Data;</span>
  27 |     | <span class='neutral'>    using Vault for Vault.Data;</span>
  28 |     | <span class='neutral'>    using VaultEpoch for VaultEpoch.Data;</span>
  29 |     | <span class='neutral'>    using Distribution for Distribution.Data;</span>
  30 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  31 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  32 |     | <span class='neutral'>    using DecimalMath for int128;</span>
  33 |     | <span class='neutral'>    using SafeCastAddress for address;</span>
  34 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  35 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  36 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  37 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Thrown when the specified pool is not found.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    error PoolNotFound(uint128 poolId);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Thrown when attempting to create a pool that already exists.</span>
  46 |     | <span class='neutral'>     */</span>
  47 |     | <span class='neutral'>    error PoolAlreadyExists(uint128 poolId);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev Thrown when min delegation time for a market connected to the pool has not elapsed</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    error MinDelegationTimeoutPending(uint128 poolId, uint32 timeRemaining);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @dev Thrown when pool has surpassed max collateral deposit</span>
  56 |     | <span class='neutral'>     */</span>
  57 |     | <span class='neutral'>    error PoolCollateralLimitExceeded(</span>
  58 |     | <span class='neutral'>        uint128 poolId,</span>
  59 |     | <span class='neutral'>        address collateralType,</span>
  60 |     | <span class='neutral'>        uint256 currentCollateral,</span>
  61 |     | <span class='neutral'>        uint256 maxCollateral</span>
  62 |     | <span class='neutral'>    );</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    bytes32 private constant _CONFIG_SET_MARKET_MIN_DELEGATE_MAX = &quot;setMarketMinDelegateTime_max&quot;;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    struct Data {</span>
  67 |     | <span class='neutral'>        /**</span>
  68 |     | <span class='neutral'>         * @dev Numeric identifier for the pool. Must be unique.</span>
  69 |     | <span class='neutral'>         * @dev A pool with id zero exists! (See Pool.loadExisting()). Users can delegate to this pool to be able to mint USD without being exposed to fluctuating debt.</span>
  70 |     | <span class='neutral'>         */</span>
  71 |     | <span class='neutral'>        uint128 id;</span>
  72 |     | <span class='neutral'>        /**</span>
  73 |     | <span class='neutral'>         * @dev Text identifier for the pool.</span>
  74 |     | <span class='neutral'>         *</span>
  75 |     | <span class='neutral'>         * Not required to be unique.</span>
  76 |     | <span class='neutral'>         */</span>
  77 |     | <span class='neutral'>        string name;</span>
  78 |     | <span class='neutral'>        /**</span>
  79 |     | <span class='neutral'>         * @dev Creator of the pool, which has configuration access rights for the pool.</span>
  80 |     | <span class='neutral'>         *</span>
  81 |     | <span class='neutral'>         * See onlyPoolOwner.</span>
  82 |     | <span class='neutral'>         */</span>
  83 |     | <span class='neutral'>        address owner;</span>
  84 |     | <span class='neutral'>        /**</span>
  85 |     | <span class='neutral'>         * @dev Allows the current pool owner to nominate a new owner, and thus transfer pool configuration credentials.</span>
  86 |     | <span class='neutral'>         */</span>
  87 |     | <span class='neutral'>        address nominatedOwner;</span>
  88 |     | <span class='neutral'>        /**</span>
  89 |     | <span class='neutral'>         * @dev Sum of all market weights.</span>
  90 |     | <span class='neutral'>         *</span>
  91 |     | <span class='neutral'>         * Market weights are tracked in `MarketConfiguration.weight`, one for each market. The ratio of each market&#39;s `weight` to the pool&#39;s `totalWeights` determines the pro-rata share of the market to the pool&#39;s total liquidity.</span>
  92 |     | <span class='neutral'>         *</span>
  93 |     | <span class='neutral'>         * Reciprocally, this pro-rata share also determines how much the pool is exposed to each market&#39;s debt.</span>
  94 |     | <span class='neutral'>         */</span>
  95 |     | <span class='neutral'>        uint128 totalWeightsD18;</span>
  96 |     | <span class='neutral'>        /**</span>
  97 |     | <span class='neutral'>         * @dev Accumulated cache value of all vault collateral debts</span>
  98 |     | <span class='neutral'>         */</span>
  99 |     | <span class='neutral'>        int128 totalVaultDebtsD18;</span>
 100 |     | <span class='neutral'>        /**</span>
 101 |     | <span class='neutral'>         * @dev Array of markets connected to this pool, and their configurations. I.e. weight, etc.</span>
 102 |     | <span class='neutral'>         *</span>
 103 |     | <span class='neutral'>         * See totalWeights.</span>
 104 |     | <span class='neutral'>         */</span>
 105 |     | <span class='neutral'>        MarketConfiguration.Data[] marketConfigurations;</span>
 106 |     | <span class='neutral'>        /**</span>
 107 |     | <span class='neutral'>         * @dev A pool&#39;s debt distribution connects pools to the debt distribution chain, i.e. vaults and markets. Vaults are actors in the pool&#39;s debt distribution, where the amount of shares they possess depends on the amount of collateral each vault delegates to the pool.</span>
 108 |     | <span class='neutral'>         *</span>
 109 |     | <span class='neutral'>         * The debt distribution chain will move debt from markets into this pools, and then from pools to vaults.</span>
 110 |     | <span class='neutral'>         *</span>
 111 |     | <span class='neutral'>         * Actors: Vaults.</span>
 112 |     | <span class='neutral'>         * Shares: USD value, proportional to the amount of collateral that the vault delegates to the pool.</span>
 113 |     | <span class='neutral'>         * Value per share: Debt per dollar of collateral. Depends on aggregated debt of connected markets.</span>
 114 |     | <span class='neutral'>         *</span>
 115 |     | <span class='neutral'>         */</span>
 116 |     | <span class='neutral'>        Distribution.Data vaultsDebtDistribution;</span>
 117 |     | <span class='neutral'>        /**</span>
 118 |     | <span class='neutral'>         * @dev Reference to all the vaults that provide liquidity to this pool.</span>
 119 |     | <span class='neutral'>         *</span>
 120 |     | <span class='neutral'>         * Each collateral type will have its own vault, specific to this pool. I.e. if two pools both use SNX collateral, each will have its own SNX vault.</span>
 121 |     | <span class='neutral'>         *</span>
 122 |     | <span class='neutral'>         * Vaults track user collateral and debt using a debt distribution, which is connected to the debt distribution chain.</span>
 123 |     | <span class='neutral'>         */</span>
 124 |     | <span class='neutral'>        mapping(address =&gt; Vault.Data) vaults;</span>
 125 |     | <span class='neutral'>        uint64 lastConfigurationTime;</span>
 126 |     | <span class='neutral'>        uint64 __reserved1;</span>
 127 |     | <span class='neutral'>        uint64 __reserved2;</span>
 128 |     | <span class='neutral'>        uint64 __reserved3;</span>
 129 |     | <span class='neutral'>        mapping(address =&gt; PoolCollateralConfiguration.Data) collateralConfigurations;</span>
 130 |     | <span class='neutral'>        /**</span>
 131 |     | <span class='neutral'>         * @dev A switch to make the pool opt-in for new collateral</span>
 132 |     | <span class='neutral'>         *</span>
 133 |     | <span class='neutral'>         * By default it&#39;s set to false, which means any new collateral accepeted by the system will be accpeted by the pool.</span>
 134 |     | <span class='neutral'>         *</span>
 135 |     | <span class='neutral'>         * If the pool owner sets this value to true, then new collaterals will be disabled for the pool unless a maxDeposit is set for a that collateral.</span>
 136 |     | <span class='neutral'>         */</span>
 137 |     | <span class='neutral'>        bool collateralDisabledByDefault;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @dev Returns the pool stored at the specified pool id.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='neutral'>    function load(uint128 id) internal pure returns (Data storage pool) {</span>
 144 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.synthetix.Pool&quot;, id));</span>
 145 |     | <span class='neutral'>        assembly {</span>
 146 |     | <span class='neutral'>            pool.slot := s</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /**</span>
 151 |     | <span class='neutral'>     * @dev Creates a pool for the given pool id, and assigns the caller as its owner.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * Reverts if the specified pool already exists.</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function create(uint128 id, address owner) internal returns (Pool.Data storage pool) {</span>
 156 |     | <span class='neutral'>        if (id == 0 || load(id).id == id) {</span>
 157 |     | <span class='neutral'>            revert PoolAlreadyExists(id);</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        pool = load(id);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        pool.id = id;</span>
 163 |     | <span class='neutral'>        pool.owner = owner;</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /**</span>
 167 |     | <span class='neutral'>     * @dev Ticker function that updates the debt distribution chain downwards, from markets into the pool, according to each market&#39;s weight.</span>
 168 |     | <span class='neutral'>     * IMPORTANT: debt must be distributed downstream before invoking this function.</span>
 169 |     | <span class='neutral'>     *</span>
 170 |     | <span class='neutral'>     * It updates the chain by performing these actions:</span>
 171 |     | <span class='neutral'>     * - Splits the pool&#39;s total liquidity of the pool into each market, pro-rata. The amount of shares that the pool has on each market depends on how much liquidity the pool provides to the market.</span>
 172 |     | <span class='neutral'>     * - Accumulates the change in debt value from each market into the pools own vault debt distribution&#39;s value per share.</span>
 173 |     | <span class='neutral'>     */</span>
 174 |     | <span class='neutral'>    function rebalanceMarketsInPool(Data storage self) internal {</span>
 175 |     | <span class='neutral'>        uint256 totalWeightsD18 = self.totalWeightsD18;</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>        if (totalWeightsD18 == 0) {</span>
 178 |     | <span class='neutral'>            return; // Nothing to rebalance.</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        // Read from storage once, before entering the loop below.</span>
 182 |     | <span class='neutral'>        // These values should not change while iterating through each market.</span>
 183 |     | <span class='neutral'>        uint256 totalCreditCapacityD18 = self.vaultsDebtDistribution.totalSharesD18;</span>
 184 |     | <span class='neutral'>        int128 debtPerShareD18 = totalCreditCapacityD18 &gt; 0 // solhint-disable-next-line numcast/safe-cast</span>
 185 |     | <span class='neutral'>            ? int256(self.totalVaultDebtsD18).divDecimal(totalCreditCapacityD18.toInt()).to128() // solhint-disable-next-line numcast/safe-cast</span>
 186 |     | <span class='neutral'>            : int128(0);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        uint256 systemMinLiquidityRatioD18 = SystemPoolConfiguration.load().minLiquidityRatioD18;</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // Loop through the pool&#39;s markets, applying market weights, and tracking how this changes the amount of debt that this pool is responsible for.</span>
 191 |     | <span class='neutral'>        // This debt extracted from markets is then applied to the pool&#39;s vault debt distribution, which thus exposes debt to the pool&#39;s vaults.</span>
 192 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; self.marketConfigurations.length; i++) {</span>
 193 |     | <span class='neutral'>            MarketConfiguration.Data storage marketConfiguration = self.marketConfigurations[i];</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>            uint256 weightD18 = marketConfiguration.weightD18;</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>            // Calculate each market&#39;s pro-rata USD liquidity.</span>
 198 |     | <span class='neutral'>            // Note: the factor `(weight / totalWeights)` is not deduped in the operations below to maintain numeric precision.</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>            uint256 marketCreditCapacityD18 = (totalCreditCapacityD18 * weightD18) /</span>
 201 |     | <span class='neutral'>                totalWeightsD18;</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>            Market.Data storage marketData = Market.load(marketConfiguration.marketId);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>            // Use market-specific minimum liquidity ratio if set, otherwise use system default.</span>
 206 |     | <span class='neutral'>            uint256 minLiquidityRatioD18 = marketData.minLiquidityRatioD18 &gt; 0</span>
 207 |     | <span class='neutral'>                ? marketData.minLiquidityRatioD18</span>
 208 |     | <span class='neutral'>                : systemMinLiquidityRatioD18;</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>            // Contain the pool imposed market&#39;s maximum debt share value.</span>
 211 |     | <span class='neutral'>            // Imposed by system.</span>
 212 |     | <span class='neutral'>            int256 effectiveMaxShareValueD18 = getSystemMaxValuePerShare(</span>
 213 |     | <span class='neutral'>                marketData.id,</span>
 214 |     | <span class='neutral'>                minLiquidityRatioD18,</span>
 215 |     | <span class='neutral'>                debtPerShareD18</span>
 216 |     | <span class='neutral'>            );</span>
 217 |     | <span class='neutral'>            // Imposed by pool.</span>
 218 |     | <span class='neutral'>            int256 configuredMaxShareValueD18 = marketConfiguration.maxDebtShareValueD18;</span>
 219 |     | <span class='neutral'>            effectiveMaxShareValueD18 = effectiveMaxShareValueD18 &lt; configuredMaxShareValueD18</span>
 220 |     | <span class='neutral'>                ? effectiveMaxShareValueD18</span>
 221 |     | <span class='neutral'>                : configuredMaxShareValueD18;</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>            // Update each market&#39;s corresponding credit capacity.</span>
 224 |     | <span class='neutral'>            // The returned value represents how much the market&#39;s debt changed after changing the shares of this pool actor, which is aggregated to later be passed on the pools debt distribution.</span>
 225 |     | <span class='neutral'>            Market.rebalancePools(</span>
 226 |     | <span class='neutral'>                marketConfiguration.marketId,</span>
 227 |     | <span class='neutral'>                self.id,</span>
 228 |     | <span class='neutral'>                effectiveMaxShareValueD18,</span>
 229 |     | <span class='neutral'>                marketCreditCapacityD18</span>
 230 |     | <span class='neutral'>            );</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    /**</span>
 235 |     | <span class='neutral'>     * @dev Determines the resulting maximum value per share for a market, according to a system-wide minimum liquidity ratio. This prevents markets from assigning more debt to pools than they have collateral to cover.</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * Note: There is a market-wide fail safe for each market at `MarketConfiguration.maxDebtShareValue`. The lower of the two values should be used.</span>
 238 |     | <span class='neutral'>     *</span>
 239 |     | <span class='neutral'>     * See `SystemPoolConfiguration.minLiquidityRatio`.</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='neutral'>    function getSystemMaxValuePerShare(</span>
 242 |     | <span class='neutral'>        uint128 marketId,</span>
 243 |     | <span class='neutral'>        uint256 minLiquidityRatioD18,</span>
 244 |     | <span class='neutral'>        int256 debtPerShareD18</span>
 245 |     | <span class='neutral'>    ) internal view returns (int256) {</span>
 246 |     | <span class='neutral'>        // Retrieve the current value per share of the market.</span>
 247 |     | <span class='neutral'>        Market.Data storage marketData = Market.load(marketId);</span>
 248 |     | <span class='neutral'>        int256 valuePerShareD18 = marketData.poolsDebtDistribution.getValuePerShare();</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>        // Calculate the margin of debt that the market would incur if it hit the system wide limit.</span>
 251 |     | <span class='neutral'>        uint256 marginD18 = minLiquidityRatioD18 == 0</span>
 252 |     | <span class='neutral'>            ? DecimalMath.UNIT</span>
 253 |     | <span class='neutral'>            : DecimalMath.UNIT.divDecimal(minLiquidityRatioD18);</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>        // The resulting maximum value per share is the distribution&#39;s value per share,</span>
 256 |     | <span class='neutral'>        // plus the margin to hit the limit, minus the current debt per share.</span>
 257 |     | <span class='neutral'>        return valuePerShareD18 + marginD18.toInt() - debtPerShareD18;</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /**</span>
 261 |     | <span class='neutral'>     * @dev Reverts if the pool does not exist with appropriate error. Otherwise, returns the pool.</span>
 262 |     | <span class='neutral'>     */</span>
 263 |     | <span class='neutral'>    function loadExisting(uint128 id) internal view returns (Data storage) {</span>
 264 |     | <span class='neutral'>        Data storage p = load(id);</span>
 265 |     | <span class='neutral'>        if (id != 0 &amp;&amp; p.id != id) {</span>
 266 |     | <span class='neutral'>            revert PoolNotFound(id);</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>        return p;</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    /**</span>
 273 |     | <span class='neutral'>     * @dev Returns true if the pool is exposed to the specified market.</span>
 274 |     | <span class='neutral'>     */</span>
 275 |     | <span class='neutral'>    function hasMarket(Data storage self, uint128 marketId) internal view returns (bool) {</span>
 276 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; self.marketConfigurations.length; i++) {</span>
 277 |     | <span class='neutral'>            if (</span>
 278 |     | <span class='neutral'>                self.marketConfigurations[i].marketId == marketId &amp;&amp;</span>
 279 |     | <span class='neutral'>                Market.load(marketId).isPoolInRange(self.id)</span>
 280 |     | <span class='neutral'>            ) {</span>
 281 |     | <span class='neutral'>                return true;</span>
 282 |     | <span class='neutral'>            }</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        return false;</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    /**</span>
 289 |     | <span class='neutral'>     * IMPORTANT: after this function, you should accumulateVaultDebt</span>
 290 |     | <span class='neutral'>     */</span>
 291 |     | <span class='neutral'>    function distributeDebtToVaults(</span>
 292 |     | <span class='neutral'>        Data storage self,</span>
 293 |     | <span class='neutral'>        address optionalCollateralType</span>
 294 |     | <span class='neutral'>    ) internal returns (int256 cumulativeDebtChange) {</span>
 295 |     | <span class='neutral'>        // Update each market&#39;s pro-rata liquidity and collect accumulated debt into the pool&#39;s debt distribution.</span>
 296 |     | <span class='neutral'>        uint128 myPoolId = self.id;</span>
 297 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; self.marketConfigurations.length; i++) {</span>
 298 |     | <span class='neutral'>            Market.Data storage market = Market.load(self.marketConfigurations[i].marketId);</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>            market.distributeDebtToPools(9999999999);</span>
 301 |     | <span class='neutral'>            cumulativeDebtChange += market.accumulateDebtChange(myPoolId);</span>
 302 |     | <span class='neutral'>        }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>        assignDebt(self, cumulativeDebtChange);</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>        // Transfer the debt change from the pool into the vault.</span>
 307 |     | <span class='neutral'>        if (optionalCollateralType != address(0)) {</span>
 308 |     | <span class='neutral'>            bytes32 actorId = optionalCollateralType.toBytes32();</span>
 309 |     | <span class='neutral'>            self.vaults[optionalCollateralType].distributeDebtToAccounts(</span>
 310 |     | <span class='neutral'>                self.vaultsDebtDistribution.accumulateActor(actorId)</span>
 311 |     | <span class='neutral'>            );</span>
 312 |     | <span class='neutral'>        }</span>
 313 |     | <span class='neutral'>    }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>    function assignDebt(Data storage self, int256 debtAmountD18) internal {</span>
 316 |     | <span class='neutral'>        // Accumulate the change in total liquidity, from the vault, into the pool.</span>
 317 |     | <span class='neutral'>        self.totalVaultDebtsD18 = self.totalVaultDebtsD18 + debtAmountD18.to128();</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>        self.vaultsDebtDistribution.distributeValue(debtAmountD18);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    function assignDebtToAccount(</span>
 323 |     | <span class='neutral'>        Data storage self,</span>
 324 |     | <span class='neutral'>        address collateralType,</span>
 325 |     | <span class='neutral'>        uint128 accountId,</span>
 326 |     | <span class='neutral'>        int256 debtAmountD18</span>
 327 |     | <span class='neutral'>    ) internal {</span>
 328 |     | <span class='neutral'>        self.totalVaultDebtsD18 = self.totalVaultDebtsD18 + debtAmountD18.to128();</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>        self.vaults[collateralType].currentEpoch().assignDebtToAccount(accountId, debtAmountD18);</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    /**</span>
 334 |     | <span class='neutral'>     * @dev Ticker function that updates the debt distribution chain for a specific collateral type downwards, from the pool into the corresponding the vault, according to changes in the collateral&#39;s price.</span>
 335 |     | <span class='neutral'>     * IMPORTANT: *should* call distributeDebtToVaults() to ensure that deltaDebtD18 is referencing the latest</span>
 336 |     | <span class='neutral'>     *</span>
 337 |     | <span class='neutral'>     * It updates the chain by performing these actions:</span>
 338 |     | <span class='neutral'>     * - Collects the latest price of the corresponding collateral and updates the vault&#39;s liquidity.</span>
 339 |     | <span class='neutral'>     * - Updates the vaults shares in the pool&#39;s debt distribution, according to the collateral provided by the vault.</span>
 340 |     | <span class='neutral'>     * - Updates the value per share of the vault&#39;s debt distribution.</span>
 341 |     | <span class='neutral'>     */</span>
 342 |     | <span class='neutral'>    function recalculateVaultCollateral(</span>
 343 |     | <span class='neutral'>        Data storage self,</span>
 344 |     | <span class='neutral'>        address collateralType</span>
 345 |     | <span class='neutral'>    ) internal returns (uint256 collateralPriceD18) {</span>
 346 |     | <span class='neutral'>        // Get the latest collateral price.</span>
 347 |     | <span class='neutral'>        collateralPriceD18 = CollateralConfiguration.load(collateralType).getCollateralPrice(</span>
 348 |     | <span class='neutral'>            DecimalMath.UNIT</span>
 349 |     | <span class='neutral'>        );</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>        // Changes in price update the corresponding vault&#39;s total collateral value as well as its liquidity (collateral - debt).</span>
 352 |     | <span class='neutral'>        (uint256 usdWeightD18, ) = self.vaults[collateralType].updateCreditCapacity(</span>
 353 |     | <span class='neutral'>            collateralPriceD18</span>
 354 |     | <span class='neutral'>        );</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>        // Update the vault&#39;s shares in the pool&#39;s debt distribution, according to the value of its collateral.</span>
 357 |     | <span class='neutral'>        self.vaultsDebtDistribution.setActorShares(collateralType.toBytes32(), usdWeightD18);</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>        // now that available vault collateral has been recalculated, we should also rebalance the pool markets</span>
 360 |     | <span class='neutral'>        rebalanceMarketsInPool(self);</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    /**</span>
 364 |     | <span class='neutral'>     * @dev Updates the debt distribution chain for this pool, and consolidates the given account&#39;s debt.</span>
 365 |     | <span class='neutral'>     */</span>
 366 |     | <span class='neutral'>    function updateAccountDebt(</span>
 367 |     | <span class='neutral'>        Data storage self,</span>
 368 |     | <span class='neutral'>        address collateralType,</span>
 369 |     | <span class='neutral'>        uint128 accountId</span>
 370 |     | <span class='neutral'>    ) internal returns (int256 debtD18) {</span>
 371 |     | <span class='neutral'>        distributeDebtToVaults(self, collateralType);</span>
 372 |     | <span class='neutral'>        return self.vaults[collateralType].consolidateAccountDebt(accountId);</span>
 373 |     | <span class='neutral'>    }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>    /**</span>
 376 |     | <span class='neutral'>     * @dev Clears all vault data for the specified collateral type.</span>
 377 |     | <span class='neutral'>     */</span>
 378 |     | <span class='neutral'>    function resetVault(Data storage self, address collateralType) internal {</span>
 379 |     | <span class='neutral'>        // Creates a new epoch in the vault, effectively zeroing out all values.</span>
 380 |     | <span class='neutral'>        self.vaults[collateralType].reset();</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        // Ensure that the vault&#39;s values update the debt distribution chain.</span>
 383 |     | <span class='neutral'>        recalculateVaultCollateral(self, collateralType);</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='neutral'>    /**</span>
 387 |     | <span class='neutral'>     * @dev Calculates the collateralization ratio of the vault that tracks the given collateral type.</span>
 388 |     | <span class='neutral'>     *</span>
 389 |     | <span class='neutral'>     * The c-ratio is the vault&#39;s share of the total debt of the pool, divided by the collateral it delegates to the pool.</span>
 390 |     | <span class='neutral'>     *</span>
 391 |     | <span class='neutral'>     * Note: This is not a view function. It updates the debt distribution chain before performing any calculations.</span>
 392 |     | <span class='neutral'>     */</span>
 393 |     | <span class='neutral'>    function currentVaultCollateralRatio(</span>
 394 |     | <span class='neutral'>        Data storage self,</span>
 395 |     | <span class='neutral'>        address collateralType</span>
 396 |     | <span class='neutral'>    ) internal returns (uint256) {</span>
 397 |     | <span class='neutral'>        int256 vaultDebtD18 = currentVaultDebt(self, collateralType);</span>
 398 |     | <span class='neutral'>        (, uint256 collateralValueD18) = currentVaultCollateral(self, collateralType);</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>        return vaultDebtD18 &gt; 0 ? collateralValueD18.divDecimal(vaultDebtD18.toUint()) : 0;</span>
 401 |     | <span class='neutral'>    }</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='neutral'>    /**</span>
 404 |     | <span class='neutral'>     * @dev Finds a connected market whose credit capacity has reached its locked limit.</span>
 405 |     | <span class='neutral'>     *</span>
 406 |     | <span class='neutral'>     * Note: Returns market zero (null market) if none is found.</span>
 407 |     | <span class='neutral'>     */</span>
 408 |     | <span class='neutral'>    function findMarketWithCapacityLocked(</span>
 409 |     | <span class='neutral'>        Data storage self</span>
 410 |     | <span class='neutral'>    ) internal view returns (Market.Data storage lockedMarket) {</span>
 411 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; self.marketConfigurations.length; i++) {</span>
 412 |     | <span class='neutral'>            Market.Data storage market = Market.load(self.marketConfigurations[i].marketId);</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>            if (market.isCapacityLocked()) {</span>
 415 |     | <span class='neutral'>                return market;</span>
 416 |     | <span class='neutral'>            }</span>
 417 |     | <span class='neutral'>        }</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>        // Market zero = null market.</span>
 420 |     | <span class='neutral'>        return Market.load(0);</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    function getRequiredMinDelegationTime(</span>
 424 |     | <span class='neutral'>        Data storage self</span>
 425 |     | <span class='neutral'>    ) internal view returns (uint32 requiredMinDelegateTime) {</span>
 426 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; self.marketConfigurations.length; i++) {</span>
 427 |     | <span class='neutral'>            uint32 marketMinDelegateTime = Market</span>
 428 |     | <span class='neutral'>                .load(self.marketConfigurations[i].marketId)</span>
 429 |     | <span class='neutral'>                .minDelegateTime;</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>            if (marketMinDelegateTime &gt; requiredMinDelegateTime) {</span>
 432 |     | <span class='neutral'>                requiredMinDelegateTime = marketMinDelegateTime;</span>
 433 |     | <span class='neutral'>            }</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
 437 |     | <span class='neutral'>        uint32 maxMinDelegateTime = uint32(</span>
 438 |     | <span class='neutral'>            Config.readUint(_CONFIG_SET_MARKET_MIN_DELEGATE_MAX, 86400 * 30)</span>
 439 |     | <span class='neutral'>        );</span>
 440 |     | <span class='neutral'>        return</span>
 441 |     | <span class='neutral'>            maxMinDelegateTime &lt; requiredMinDelegateTime</span>
 442 |     | <span class='neutral'>                ? maxMinDelegateTime</span>
 443 |     | <span class='neutral'>                : requiredMinDelegateTime;</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    /**</span>
 447 |     | <span class='neutral'>     * @dev Returns the debt of the vault that tracks the given collateral type.</span>
 448 |     | <span class='neutral'>     *</span>
 449 |     | <span class='neutral'>     * The vault&#39;s debt is the vault&#39;s share of the total debt of the pool, or its share of the total debt of the markets connected to the pool. The size of this share depends on how much collateral the pool provides to the pool.</span>
 450 |     | <span class='neutral'>     *</span>
 451 |     | <span class='neutral'>     * Note: This is not a view function. It updates the debt distribution chain before performing any calculations.</span>
 452 |     | <span class='neutral'>     */</span>
 453 |     | <span class='neutral'>    function currentVaultDebt(Data storage self, address collateralType) internal returns (int256) {</span>
 454 |     | <span class='neutral'>        // TODO: assert that all debts have been paid, otherwise vault cant be reset (its so critical here)</span>
 455 |     | <span class='neutral'>        distributeDebtToVaults(self, collateralType);</span>
 456 |     | <span class='neutral'>        rebalanceMarketsInPool(self);</span>
 457 |     | <span class='neutral'>        return self.vaults[collateralType].currentDebt();</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    /**</span>
 461 |     | <span class='neutral'>     * @dev Returns the total amount and value of the specified collateral delegated to this pool.</span>
 462 |     | <span class='neutral'>     */</span>
 463 |     | <span class='neutral'>    function currentVaultCollateral(</span>
 464 |     | <span class='neutral'>        Data storage self,</span>
 465 |     | <span class='neutral'>        address collateralType</span>
 466 |     | <span class='neutral'>    ) internal view returns (uint256 collateralAmountD18, uint256 collateralValueD18) {</span>
 467 |     | <span class='neutral'>        uint256 collateralPriceD18 = CollateralConfiguration</span>
 468 |     | <span class='neutral'>            .load(collateralType)</span>
 469 |     | <span class='neutral'>            .getCollateralPrice(collateralAmountD18);</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>        collateralAmountD18 = self.vaults[collateralType].currentCollateral();</span>
 472 |     | <span class='neutral'>        collateralValueD18 = collateralPriceD18.mulDecimal(collateralAmountD18);</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>    /**</span>
 476 |     | <span class='neutral'>     * @dev Returns the amount and value of collateral that the specified account has delegated to this pool.</span>
 477 |     | <span class='neutral'>     */</span>
 478 |     | <span class='neutral'>    function currentAccountCollateral(</span>
 479 |     | <span class='neutral'>        Data storage self,</span>
 480 |     | <span class='neutral'>        address collateralType,</span>
 481 |     | <span class='neutral'>        uint128 accountId</span>
 482 |     | <span class='neutral'>    ) internal view returns (uint256 collateralAmountD18, uint256 collateralValueD18) {</span>
 483 |     | <span class='neutral'>        collateralAmountD18 = self.vaults[collateralType].currentAccountCollateral(accountId);</span>
 484 |     | <span class='neutral'>        uint256 collateralPriceD18 = CollateralConfiguration</span>
 485 |     | <span class='neutral'>            .load(collateralType)</span>
 486 |     | <span class='neutral'>            .getCollateralPrice(collateralAmountD18);</span>
 487 |     | <span class='neutral'>        collateralValueD18 = collateralPriceD18.mulDecimal(collateralAmountD18);</span>
 488 |     | <span class='neutral'>    }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>    /**</span>
 491 |     | <span class='neutral'>     * @dev Returns the specified account&#39;s collateralization ratio (collateral / debt).</span>
 492 |     | <span class='neutral'>     * @dev If the account&#39;s debt is negative or zero, returns an &quot;infinite&quot; c-ratio.</span>
 493 |     | <span class='neutral'>     */</span>
 494 |     | <span class='neutral'>    function currentAccountCollateralRatio(</span>
 495 |     | <span class='neutral'>        Data storage self,</span>
 496 |     | <span class='neutral'>        address collateralType,</span>
 497 |     | <span class='neutral'>        uint128 accountId</span>
 498 |     | <span class='neutral'>    ) internal returns (uint256) {</span>
 499 |     | <span class='neutral'>        int256 positionDebtD18 = updateAccountDebt(self, collateralType, accountId);</span>
 500 |     | <span class='neutral'>        rebalanceMarketsInPool(self);</span>
 501 |     | <span class='neutral'>        if (positionDebtD18 &lt;= 0) {</span>
 502 |     | <span class='neutral'>            return type(uint256).max;</span>
 503 |     | <span class='neutral'>        }</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='neutral'>        (, uint256 positionCollateralValueD18) = currentAccountCollateral(</span>
 506 |     | <span class='neutral'>            self,</span>
 507 |     | <span class='neutral'>            collateralType,</span>
 508 |     | <span class='neutral'>            accountId</span>
 509 |     | <span class='neutral'>        );</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='neutral'>        return positionCollateralValueD18.divDecimal(positionDebtD18.toUint());</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    /**</span>
 515 |     | <span class='neutral'>     * @dev Reverts if the caller is not the owner of the specified pool.</span>
 516 |     | <span class='neutral'>     */</span>
 517 |     | <span class='neutral'>    function onlyPoolOwner(uint128 poolId, address caller) internal view {</span>
 518 |     | <span class='neutral'>        if (Pool.load(poolId).owner != caller) {</span>
 519 |     | <span class='neutral'>            revert AccessError.Unauthorized(caller);</span>
 520 |     | <span class='neutral'>        }</span>
 521 |     | <span class='neutral'>    }</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>    function requireMinDelegationTimeElapsed(</span>
 524 |     | <span class='neutral'>        Data storage self,</span>
 525 |     | <span class='neutral'>        uint64 lastDelegationTime</span>
 526 |     | <span class='neutral'>    ) internal view {</span>
 527 |     | <span class='neutral'>        uint32 requiredMinDelegationTime = getRequiredMinDelegationTime(self);</span>
 528 |     | <span class='neutral'>        if (block.timestamp &lt; lastDelegationTime + requiredMinDelegationTime) {</span>
 529 |     | <span class='neutral'>            revert MinDelegationTimeoutPending(</span>
 530 |     | <span class='neutral'>                self.id,</span>
 531 |     | <span class='neutral'>                // solhint-disable-next-line numcast/safe-cast</span>
 532 |     | <span class='neutral'>                uint32(lastDelegationTime + requiredMinDelegationTime - block.timestamp)</span>
 533 |     | <span class='neutral'>            );</span>
 534 |     | <span class='neutral'>        }</span>
 535 |     | <span class='neutral'>    }</span>
 536 |     | <span class='neutral'></span>
 537 |     | <span class='neutral'>    function checkPoolCollateralLimit(</span>
 538 |     | <span class='neutral'>        Data storage self,</span>
 539 |     | <span class='neutral'>        address collateralType,</span>
 540 |     | <span class='neutral'>        uint256 collateralAmountD18</span>
 541 |     | <span class='neutral'>    ) internal view {</span>
 542 |     | <span class='neutral'>        uint256 collateralLimitD18 = self</span>
 543 |     | <span class='neutral'>            .collateralConfigurations[collateralType]</span>
 544 |     | <span class='neutral'>            .collateralLimitD18;</span>
 545 |     | <span class='neutral'>        uint256 currentCollateral = self.vaults[collateralType].currentCollateral();</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>        if (</span>
 548 |     | <span class='neutral'>            (self.collateralDisabledByDefault &amp;&amp; collateralLimitD18 == 0) ||</span>
 549 |     | <span class='neutral'>            (collateralLimitD18 &gt; 0 &amp;&amp; currentCollateral + collateralAmountD18 &gt; collateralLimitD18)</span>
 550 |     | <span class='neutral'>        ) {</span>
 551 |     | <span class='neutral'>            revert PoolCollateralLimitExceeded(</span>
 552 |     | <span class='neutral'>                self.id,</span>
 553 |     | <span class='neutral'>                collateralType,</span>
 554 |     | <span class='neutral'>                currentCollateral + collateralAmountD18,</span>
 555 |     | <span class='neutral'>                collateralLimitD18</span>
 556 |     | <span class='neutral'>            );</span>
 557 |     | <span class='neutral'>        }</span>
 558 |     | <span class='neutral'>    }</span>
 559 |     | <span class='neutral'>}</span>
 560 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/PoolCollateralConfiguration.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library PoolCollateralConfiguration {</span>
  5 |     | <span class='neutral'>    bytes32 private constant _SLOT =</span>
  6 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.synthetix.PoolCollateralConfiguration&quot;));</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        uint256 collateralLimitD18;</span>
 10 |     | <span class='neutral'>        uint256 issuanceRatioD18;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/RewardDistribution.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/errors/ParameterError.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &quot;../interfaces/external/IRewardDistributor.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import &quot;./Distribution.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./RewardDistributionClaimStatus.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/**</span>
  14 |     | <span class='neutral'> * @title Used by vaults to track rewards for its participants. There will be one of these for each pool, collateral type, and distributor combination.</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='unexecuted'>library RewardDistribution {</span>
  17 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  18 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  19 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  20 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  21 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  22 |     | <span class='neutral'>    using SafeCastU64 for uint64;</span>
  23 |     | <span class='neutral'>    using SafeCastU32 for uint32;</span>
  24 |     | <span class='neutral'>    using SafeCastI32 for int32;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    struct Data {</span>
  27 |     | <span class='neutral'>        /**</span>
  28 |     | <span class='neutral'>         * @dev The 3rd party smart contract which holds/mints tokens for distributing rewards to vault participants.</span>
  29 |     | <span class='neutral'>         */</span>
  30 |     | <span class='neutral'>        IRewardDistributor distributor;</span>
  31 |     | <span class='neutral'>        /**</span>
  32 |     | <span class='neutral'>         * @dev Available slot.</span>
  33 |     | <span class='neutral'>         */</span>
  34 |     | <span class='neutral'>        uint128 __slotAvailableForFutureUse;</span>
  35 |     | <span class='neutral'>        /**</span>
  36 |     | <span class='neutral'>         * @dev The value of the rewards in this entry.</span>
  37 |     | <span class='neutral'>         */</span>
  38 |     | <span class='neutral'>        uint128 rewardPerShareD18;</span>
  39 |     | <span class='neutral'>        /**</span>
  40 |     | <span class='neutral'>         * @dev The status for each actor, regarding this distribution&#39;s entry.</span>
  41 |     | <span class='neutral'>         */</span>
  42 |     | <span class='neutral'>        mapping(uint256 =&gt; RewardDistributionClaimStatus.Data) claimStatus;</span>
  43 |     | <span class='neutral'>        /**</span>
  44 |     | <span class='neutral'>         * @dev Value to be distributed as rewards in a scheduled form.</span>
  45 |     | <span class='neutral'>         */</span>
  46 |     | <span class='neutral'>        int128 scheduledValueD18;</span>
  47 |     | <span class='neutral'>        /**</span>
  48 |     | <span class='neutral'>         * @dev Date at which the entry&#39;s rewards will begin to be claimable.</span>
  49 |     | <span class='neutral'>         *</span>
  50 |     | <span class='neutral'>         * Note: Set to &lt;= block.timestamp to distribute immediately to currently participating users.</span>
  51 |     | <span class='neutral'>         */</span>
  52 |     | <span class='neutral'>        uint64 start;</span>
  53 |     | <span class='neutral'>        /**</span>
  54 |     | <span class='neutral'>         * @dev Time span after the start date, in which the whole of the entry&#39;s rewards will become claimable.</span>
  55 |     | <span class='neutral'>         */</span>
  56 |     | <span class='neutral'>        uint32 duration;</span>
  57 |     | <span class='neutral'>        /**</span>
  58 |     | <span class='neutral'>         * @dev Date on which this distribution entry was last updated.</span>
  59 |     | <span class='neutral'>         */</span>
  60 |     | <span class='neutral'>        uint32 lastUpdate;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Distributes rewards into a new rewards distribution entry.</span>
  65 |     | <span class='neutral'>     *</span>
  66 |     | <span class='neutral'>     * Note: this function allows for more special cases such as distributing at a future date or distributing over time.</span>
  67 |     | <span class='neutral'>     * If you want to apply the distribution to the pool, call `distribute` with the return value. Otherwise, you can</span>
  68 |     | <span class='neutral'>     * record this independently as well.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function distribute(</span>
  71 |     | <span class='neutral'>        Data storage self,</span>
  72 |     | <span class='neutral'>        Distribution.Data storage dist,</span>
  73 |     | <span class='neutral'>        int256 amountD18,</span>
  74 |     | <span class='neutral'>        uint64 start,</span>
  75 |     | <span class='neutral'>        uint32 duration</span>
  76 |     | <span class='neutral'>    ) internal returns (int256 diffD18) {</span>
  77 |     | <span class='neutral'>        uint256 totalSharesD18 = dist.totalSharesD18;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        if (totalSharesD18 == 0) {</span>
  80 |     | <span class='neutral'>            revert ParameterError.InvalidParameter(</span>
  81 |     | <span class='neutral'>                &quot;amount&quot;,</span>
  82 |     | <span class='neutral'>                &quot;can&#39;t distribute to empty distribution&quot;</span>
  83 |     | <span class='neutral'>            );</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        uint256 curTime = block.timestamp;</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // Unlocks the entry&#39;s distributed amount into its value per share.</span>
  89 |     | <span class='neutral'>        diffD18 += updateEntry(self, totalSharesD18);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // If the current time is past the end of the entry&#39;s duration,</span>
  92 |     | <span class='neutral'>        // update any rewards which may have accrued since last run.</span>
  93 |     | <span class='neutral'>        // (instant distribution--immediately disperse amount).</span>
  94 |     | <span class='neutral'>        if (start + duration &lt;= curTime) {</span>
  95 |     | <span class='neutral'>            diffD18 += amountD18.divDecimal(totalSharesD18.toInt());</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>            self.lastUpdate = 0;</span>
  98 |     | <span class='neutral'>            self.start = 0;</span>
  99 |     | <span class='neutral'>            self.duration = 0;</span>
 100 |     | <span class='neutral'>            self.scheduledValueD18 = 0;</span>
 101 |     | <span class='neutral'>            // Else, schedule the amount to distribute.</span>
 102 |     | <span class='neutral'>        } else {</span>
 103 |     | <span class='neutral'>            self.scheduledValueD18 = amountD18.to128();</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>            self.start = start;</span>
 106 |     | <span class='neutral'>            self.duration = duration;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>            // The amount is actually the amount distributed already *plus* whatever has been specified now.</span>
 109 |     | <span class='neutral'>            self.lastUpdate = 0;</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>            diffD18 += updateEntry(self, totalSharesD18);</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /**</span>
 116 |     | <span class='neutral'>     * @dev Gets the total shares of a reward distribution entry.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function getEntry(</span>
 119 |     | <span class='neutral'>        Data storage self,</span>
 120 |     | <span class='neutral'>        uint256 totalSharesAmountD18</span>
 121 |     | <span class='neutral'>    ) internal view returns (int256) {</span>
 122 |     | <span class='neutral'>        // No balance if a pool is empty or if it has no rewards</span>
 123 |     | <span class='neutral'>        if (self.scheduledValueD18 == 0 || totalSharesAmountD18 == 0) {</span>
 124 |     | <span class='neutral'>            return 0;</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        uint256 curTime = block.timestamp;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        int256 valuePerShareChangeD18 = 0;</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>        // No balance if current time is before start time</span>
 132 |     | <span class='neutral'>        if (curTime &lt; self.start) {</span>
 133 |     | <span class='neutral'>            return 0;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // If the entry&#39;s duration is zero and its last update was before the start time,</span>
 137 |     | <span class='neutral'>        // consider the entry to be an instant distribution.</span>
 138 |     | <span class='neutral'>        if (self.duration == 0 &amp;&amp; self.lastUpdate &lt; self.start) {</span>
 139 |     | <span class='neutral'>            // Simply update the value per share to the total value divided by the total shares.</span>
 140 |     | <span class='neutral'>            valuePerShareChangeD18 = self.scheduledValueD18.to256().divDecimal(</span>
 141 |     | <span class='neutral'>                totalSharesAmountD18.toInt()</span>
 142 |     | <span class='neutral'>            );</span>
 143 |     | <span class='neutral'>            // Else, if the last update was before the end of the duration.</span>
 144 |     | <span class='neutral'>        } else if (self.lastUpdate &lt; self.start + self.duration) {</span>
 145 |     | <span class='neutral'>            // Determine how much was previously distributed.</span>
 146 |     | <span class='neutral'>            // If the last update is zero, then nothing was distributed,</span>
 147 |     | <span class='neutral'>            // otherwise the amount is proportional to the time elapsed since the start.</span>
 148 |     | <span class='neutral'>            int256 lastUpdateDistributedD18 = self.lastUpdate &lt; self.start</span>
 149 |     | <span class='neutral'>                ? SafeCastI128.zero()</span>
 150 |     | <span class='neutral'>                : (self.scheduledValueD18 * (self.lastUpdate - self.start).toInt()) /</span>
 151 |     | <span class='neutral'>                    self.duration.toInt();</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>            // If the current time is beyond the duration, then consider all scheduled value to be distributed.</span>
 154 |     | <span class='neutral'>            // Else, the amount distributed is proportional to the elapsed time.</span>
 155 |     | <span class='neutral'>            int256 curUpdateDistributedD18 = self.scheduledValueD18;</span>
 156 |     | <span class='neutral'>            if (curTime &lt; self.start + self.duration) {</span>
 157 |     | <span class='neutral'>                // Note: Not using an intermediate time ratio variable</span>
 158 |     | <span class='neutral'>                // in the following calculation to maintain precision.</span>
 159 |     | <span class='neutral'>                curUpdateDistributedD18 =</span>
 160 |     | <span class='neutral'>                    (curUpdateDistributedD18 * (curTime - self.start).toInt()) /</span>
 161 |     | <span class='neutral'>                    self.duration.toInt();</span>
 162 |     | <span class='neutral'>            }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>            // The final value per share change is the difference between what is to be distributed and what was distributed.</span>
 165 |     | <span class='neutral'>            valuePerShareChangeD18 = (curUpdateDistributedD18 - lastUpdateDistributedD18)</span>
 166 |     | <span class='neutral'>                .divDecimal(totalSharesAmountD18.toInt());</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        return valuePerShareChangeD18;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Updates the total shares of a reward distribution entry, and releases its unlocked value into its value per share, depending on the time elapsed since the start of the distribution&#39;s entry.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * Note: call every time before `totalShares` changes.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='neutral'>    function updateEntry(</span>
 178 |     | <span class='neutral'>        Data storage self,</span>
 179 |     | <span class='neutral'>        uint256 totalSharesAmountD18</span>
 180 |     | <span class='neutral'>    ) internal returns (int256) {</span>
 181 |     | <span class='neutral'>        // Cannot process distributed rewards if a pool is empty or if it has no rewards.</span>
 182 |     | <span class='neutral'>        if (self.scheduledValueD18 == 0 || totalSharesAmountD18 == 0) {</span>
 183 |     | <span class='neutral'>            return 0;</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        uint256 curTime = block.timestamp;</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        int256 valuePerShareChangeD18 = 0;</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // Cannot update an entry whose start date has not being reached.</span>
 191 |     | <span class='neutral'>        if (curTime &lt; self.start) {</span>
 192 |     | <span class='neutral'>            return 0;</span>
 193 |     | <span class='neutral'>        }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        // If the entry&#39;s duration is zero and its last update was before the start time,</span>
 196 |     | <span class='neutral'>        // consider the entry to be an instant distribution.</span>
 197 |     | <span class='neutral'>        if (self.duration == 0 &amp;&amp; self.lastUpdate &lt; self.start) {</span>
 198 |     | <span class='neutral'>            // Simply update the value per share to the total value divided by the total shares.</span>
 199 |     | <span class='neutral'>            valuePerShareChangeD18 = self.scheduledValueD18.to256().divDecimal(</span>
 200 |     | <span class='neutral'>                totalSharesAmountD18.toInt()</span>
 201 |     | <span class='neutral'>            );</span>
 202 |     | <span class='neutral'>            // Else, if the last update was before the end of the duration.</span>
 203 |     | <span class='neutral'>        } else if (self.lastUpdate &lt; self.start + self.duration) {</span>
 204 |     | <span class='neutral'>            // Determine how much was previously distributed.</span>
 205 |     | <span class='neutral'>            // If the last update is zero, then nothing was distributed,</span>
 206 |     | <span class='neutral'>            // otherwise the amount is proportional to the time elapsed since the start.</span>
 207 |     | <span class='neutral'>            int256 lastUpdateDistributedD18 = 0;</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>            if (self.lastUpdate &gt;= self.start) {</span>
 210 |     | <span class='neutral'>                // solhint-disable numcast/safe-cast</span>
 211 |     | <span class='neutral'>                lastUpdateDistributedD18 =</span>
 212 |     | <span class='neutral'>                    (int256(self.scheduledValueD18) * (self.lastUpdate - self.start).toInt()) /</span>
 213 |     | <span class='neutral'>                    self.duration.toInt();</span>
 214 |     | <span class='neutral'>                // solhint-enable numcast/safe-cast</span>
 215 |     | <span class='neutral'>            }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>            // If the current time is beyond the duration, then consider all scheduled value to be distributed.</span>
 218 |     | <span class='neutral'>            // Else, the amount distributed is proportional to the elapsed time.</span>
 219 |     | <span class='neutral'>            int256 curUpdateDistributedD18 = self.scheduledValueD18;</span>
 220 |     | <span class='neutral'>            if (curTime &lt; self.start + self.duration) {</span>
 221 |     | <span class='neutral'>                // Note: Not using an intermediate time ratio variable</span>
 222 |     | <span class='neutral'>                // in the following calculation to maintain precision.</span>
 223 |     | <span class='neutral'>                curUpdateDistributedD18 =</span>
 224 |     | <span class='neutral'>                    (curUpdateDistributedD18 * (curTime - self.start).toInt()) /</span>
 225 |     | <span class='neutral'>                    self.duration.toInt();</span>
 226 |     | <span class='neutral'>            }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>            // The final value per share change is the difference between what is to be distributed and what was distributed.</span>
 229 |     | <span class='neutral'>            valuePerShareChangeD18 = (curUpdateDistributedD18 - lastUpdateDistributedD18)</span>
 230 |     | <span class='neutral'>                .divDecimal(totalSharesAmountD18.toInt());</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>        self.lastUpdate = curTime.to32();</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>        return valuePerShareChangeD18;</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'>}</span>
 238 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/RewardDistributionClaimStatus.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Tracks information per actor within a RewardDistribution.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library RewardDistributionClaimStatus {</span>
  8 |     | <span class='neutral'>    struct Data {</span>
  9 |     | <span class='neutral'>        /**</span>
 10 |     | <span class='neutral'>         * @dev The last known reward per share for this actor.</span>
 11 |     | <span class='neutral'>         */</span>
 12 |     | <span class='neutral'>        uint128 lastRewardPerShareD18;</span>
 13 |     | <span class='neutral'>        /**</span>
 14 |     | <span class='neutral'>         * @dev The amount of rewards pending to be claimed by this actor.</span>
 15 |     | <span class='neutral'>         */</span>
 16 |     | <span class='neutral'>        uint128 pendingSendD18;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/ScalableMapping.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title Data structure that wraps a mapping with a scalar multiplier.</span>
   9 |     | <span class='neutral'> *</span>
  10 |     | <span class='neutral'> * If you wanted to modify all the values in a mapping by the same amount, you would normally have to loop through each entry in the mapping. This object allows you to modify all of them at once, by simply modifying the scalar multiplier.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * I.e. a regular mapping represents values like this:</span>
  13 |     | <span class='neutral'> * value = mapping[id]</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * And a scalable mapping represents values like this:</span>
  16 |     | <span class='neutral'> * value = mapping[id] * scalar</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * This reduces the number of computations needed for modifying the balances of N users from O(n) to O(1).</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'> * Note: Notice how users are tracked by a generic bytes32 id instead of an address. This allows the actors of the mapping not just to be addresses. They can be anything, for example a pool id, an account id, etc.</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * *********************</span>
  23 |     | <span class='neutral'> * Conceptual Examples</span>
  24 |     | <span class='neutral'> * *********************</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * 1) Socialization of collateral during a liquidation.</span>
  27 |     | <span class='neutral'> *</span>
  28 |     | <span class='neutral'> * Scalable mappings are very useful for &quot;socialization&quot; of collateral, that is, the re-distribution of collateral when an account is liquidated. Suppose 1000 ETH are liquidated, and would need to be distributed amongst 1000 depositors. With a regular mapping, every depositor&#39;s balance would have to be modified in a loop that iterates through every single one of them. With a scalable mapping, the scalar would simply need to be incremented so that the total value of the mapping increases by 1000 ETH.</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'> * 2) Socialization of debt during a liquidation.</span>
  31 |     | <span class='neutral'> *</span>
  32 |     | <span class='neutral'> * Similar to the socialization of collateral during a liquidation, the debt of the position that is being liquidated can be re-allocated using a scalable mapping with a single action. Supposing a scalable mapping tracks each user&#39;s debt in the system, and that 1000 sUSD has to be distributed amongst 1000 depositors, the debt data structure&#39;s scalar would simply need to be incremented so that the total value or debt of the distribution increments by 1000 sUSD.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='unexecuted'>library ScalableMapping {</span>
  36 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  37 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  38 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  39 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  40 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  41 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @dev Thrown when attempting to scale a mapping with an amount that is lower than its resolution.</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    error InsufficientMappedAmount();</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Thrown when attempting to scale a mapping with no shares.</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    error CannotScaleEmptyMapping();</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    struct Data {</span>
  54 |     | <span class='neutral'>        uint128 totalSharesD18;</span>
  55 |     | <span class='neutral'>        int128 scaleModifierD27;</span>
  56 |     | <span class='neutral'>        mapping(bytes32 =&gt; uint256) sharesD18;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Inflates or deflates the total value of the distribution by the given value.</span>
  61 |     | <span class='neutral'>     * @dev The incoming value is split per share, and used as a delta that is *added* to the existing scale modifier. The resulting scale modifier must be in the range [-1, type(int128).max).</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    function scale(Data storage self, int256 valueD18) internal {</span>
  64 |     | <span class='neutral'>        if (valueD18 == 0) {</span>
  65 |     | <span class='neutral'>            return;</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        uint256 totalSharesD18 = self.totalSharesD18;</span>
  69 |     | <span class='neutral'>        if (totalSharesD18 == 0) {</span>
  70 |     | <span class='neutral'>            revert CannotScaleEmptyMapping();</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        int256 valueD45 = valueD18 * DecimalMath.UNIT_PRECISE_INT;</span>
  74 |     | <span class='neutral'>        int256 deltaScaleModifierD27 = valueD45 / totalSharesD18.toInt();</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        self.scaleModifierD27 += deltaScaleModifierD27.to128();</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        if (self.scaleModifierD27 &lt; -DecimalMath.UNIT_PRECISE_INT) {</span>
  79 |     | <span class='neutral'>            revert InsufficientMappedAmount();</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Updates an actor&#39;s individual value in the distribution to the specified amount.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * The change in value is manifested in the distribution by changing the actor&#39;s number of shares in it, and thus the distribution&#39;s total number of shares.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * Returns the resulting amount of shares that the actor has after this change in value.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function set(</span>
  91 |     | <span class='neutral'>        Data storage self,</span>
  92 |     | <span class='neutral'>        bytes32 actorId,</span>
  93 |     | <span class='neutral'>        uint256 newActorValueD18</span>
  94 |     | <span class='neutral'>    ) internal returns (uint256 resultingSharesD18) {</span>
  95 |     | <span class='neutral'>        // Represent the actor&#39;s change in value by changing the actor&#39;s number of shares,</span>
  96 |     | <span class='neutral'>        // and keeping the distribution&#39;s scaleModifier constant.</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        resultingSharesD18 = getSharesForAmount(self, newActorValueD18);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // Modify the total shares with the actor&#39;s change in shares.</span>
 101 |     | <span class='neutral'>        self.totalSharesD18 = (self.totalSharesD18 + resultingSharesD18 - self.sharesD18[actorId])</span>
 102 |     | <span class='neutral'>            .to128();</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        self.sharesD18[actorId] = resultingSharesD18.to128();</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Returns the value owned by the actor in the distribution.</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * i.e. actor.shares * scaleModifier</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    function get(Data storage self, bytes32 actorId) internal view returns (uint256 valueD18) {</span>
 113 |     | <span class='neutral'>        uint256 totalSharesD18 = self.totalSharesD18;</span>
 114 |     | <span class='neutral'>        if (totalSharesD18 == 0) {</span>
 115 |     | <span class='neutral'>            return 0;</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        return (self.sharesD18[actorId] * totalAmount(self)) / totalSharesD18;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Returns the total value held in the distribution.</span>
 123 |     | <span class='neutral'>     *</span>
 124 |     | <span class='neutral'>     * i.e. totalShares * scaleModifier</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='neutral'>    function totalAmount(Data storage self) internal view returns (uint256 valueD18) {</span>
 127 |     | <span class='neutral'>        return</span>
 128 |     | <span class='neutral'>            ((self.scaleModifierD27 + DecimalMath.UNIT_PRECISE_INT).toUint() *</span>
 129 |     | <span class='neutral'>                self.totalSharesD18) / DecimalMath.UNIT_PRECISE;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function getSharesForAmount(</span>
 133 |     | <span class='neutral'>        Data storage self,</span>
 134 |     | <span class='neutral'>        uint256 amountD18</span>
 135 |     | <span class='neutral'>    ) internal view returns (uint256 sharesD18) {</span>
 136 |     | <span class='neutral'>        sharesD18 =</span>
 137 |     | <span class='neutral'>            (amountD18 * DecimalMath.UNIT_PRECISE) /</span>
 138 |     | <span class='neutral'>            (self.scaleModifierD27 + DecimalMath.UNIT_PRECISE_INT128).toUint();</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'>}</span>
 141 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/SystemPoolConfiguration.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title System wide configuration for pools.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library SystemPoolConfiguration {</span>
 10 |     | <span class='neutral'>    bytes32 private constant _SLOT_SYSTEM_POOL_CONFIGURATION =</span>
 11 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.synthetix.SystemPoolConfiguration&quot;));</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    struct Data {</span>
 14 |     | <span class='neutral'>        /**</span>
 15 |     | <span class='neutral'>         * @dev Owner specified system-wide limiting factor that prevents markets from minting too much debt, similar to the issuance ratio to a collateral type.</span>
 16 |     | <span class='neutral'>         *</span>
 17 |     | <span class='neutral'>         * Note: If zero, then this value defaults to 100%.</span>
 18 |     | <span class='neutral'>         */</span>
 19 |     | <span class='neutral'>        uint256 minLiquidityRatioD18;</span>
 20 |     | <span class='neutral'>        uint128 __reservedForFutureUse;</span>
 21 |     | <span class='neutral'>        /**</span>
 22 |     | <span class='neutral'>         * @dev Id of the main pool set by the system owner.</span>
 23 |     | <span class='neutral'>         */</span>
 24 |     | <span class='neutral'>        uint128 preferredPool;</span>
 25 |     | <span class='neutral'>        /**</span>
 26 |     | <span class='neutral'>         * @dev List of pools approved by the system owner.</span>
 27 |     | <span class='neutral'>         */</span>
 28 |     | <span class='neutral'>        SetUtil.UintSet approvedPools;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /**</span>
 32 |     | <span class='neutral'>     * @dev Returns the configuration singleton.</span>
 33 |     | <span class='neutral'>     */</span>
 34 |     | <span class='neutral'>    function load() internal pure returns (Data storage systemPoolConfiguration) {</span>
 35 |     | <span class='neutral'>        bytes32 s = _SLOT_SYSTEM_POOL_CONFIGURATION;</span>
 36 |     | <span class='neutral'>        assembly {</span>
 37 |     | <span class='neutral'>            systemPoolConfiguration.slot := s</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Vault.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./VaultEpoch.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./RewardDistribution.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SetUtil.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title Tracks collateral and debt distributions in a pool, for a specific collateral type.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * I.e. if a pool supports SNX and ETH collaterals, it will have an SNX Vault, and an ETH Vault.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * The Vault data structure is itself split into VaultEpoch sub-structures. This facilitates liquidations,</span>
  16 |     | <span class='neutral'> * so that whenever one occurs, a clean state of all data is achieved by simply incrementing the epoch index.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * It is recommended to understand VaultEpoch before understanding this object.</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='unexecuted'>library Vault {</span>
  21 |     | <span class='neutral'>    using VaultEpoch for VaultEpoch.Data;</span>
  22 |     | <span class='neutral'>    using Distribution for Distribution.Data;</span>
  23 |     | <span class='neutral'>    using RewardDistribution for RewardDistribution.Data;</span>
  24 |     | <span class='neutral'>    using ScalableMapping for ScalableMapping.Data;</span>
  25 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  26 |     | <span class='neutral'>    using DecimalMath for int128;</span>
  27 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  28 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  29 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  30 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  31 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  32 |     | <span class='neutral'>    using SetUtil for SetUtil.Bytes32Set;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @dev Thrown when a non-existent reward distributor is referenced</span>
  36 |     | <span class='neutral'>     */</span>
  37 |     | <span class='neutral'>    error RewardDistributorNotFound();</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct Data {</span>
  40 |     | <span class='neutral'>        /**</span>
  41 |     | <span class='neutral'>         * @dev The vault&#39;s current epoch number.</span>
  42 |     | <span class='neutral'>         *</span>
  43 |     | <span class='neutral'>         * Vault data is divided into epochs. An epoch changes when an entire vault is liquidated.</span>
  44 |     | <span class='neutral'>         */</span>
  45 |     | <span class='neutral'>        uint256 epoch;</span>
  46 |     | <span class='neutral'>        /**</span>
  47 |     | <span class='neutral'>         * @dev Unused property, maintained for backwards compatibility in storage layout.</span>
  48 |     | <span class='neutral'>         */</span>
  49 |     | <span class='neutral'>        // solhint-disable-next-line private-vars-leading-underscore</span>
  50 |     | <span class='neutral'>        bytes32 __slotAvailableForFutureUse;</span>
  51 |     | <span class='neutral'>        /**</span>
  52 |     | <span class='neutral'>         * @dev The previous debt of the vault, when `updateCreditCapacity` was last called by the Pool.</span>
  53 |     | <span class='neutral'>         */</span>
  54 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
  55 |     | <span class='neutral'>        int128 _unused_prevTotalDebtD18;</span>
  56 |     | <span class='neutral'>        /**</span>
  57 |     | <span class='neutral'>         * @dev Vault data for all the liquidation cycles divided into epochs.</span>
  58 |     | <span class='neutral'>         */</span>
  59 |     | <span class='neutral'>        mapping(uint256 =&gt; VaultEpoch.Data) epochData;</span>
  60 |     | <span class='neutral'>        /**</span>
  61 |     | <span class='neutral'>         * @dev Tracks available rewards, per user, for this vault.</span>
  62 |     | <span class='neutral'>         */</span>
  63 |     | <span class='neutral'>        mapping(bytes32 =&gt; RewardDistribution.Data) rewards;</span>
  64 |     | <span class='neutral'>        /**</span>
  65 |     | <span class='neutral'>         * @dev Tracks reward ids, for this vault.</span>
  66 |     | <span class='neutral'>         */</span>
  67 |     | <span class='neutral'>        SetUtil.Bytes32Set rewardIds;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    struct PositionSelector {</span>
  71 |     | <span class='neutral'>        uint128 accountId;</span>
  72 |     | <span class='neutral'>        uint128 poolId;</span>
  73 |     | <span class='neutral'>        address collateralType;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev Return&#39;s the VaultEpoch data for the current epoch.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='neutral'>    function currentEpoch(Data storage self) internal view returns (VaultEpoch.Data storage) {</span>
  80 |     | <span class='neutral'>        return self.epochData[self.epoch];</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Updates the vault&#39;s credit capacity as the value of its collateral minus its debt.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * Called as a ticker when users interact with pools, allowing pools to set</span>
  87 |     | <span class='neutral'>     * vaults&#39; credit capacity shares within them.</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * Returns the amount of collateral that this vault is providing in net USD terms.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function updateCreditCapacity(</span>
  92 |     | <span class='neutral'>        Data storage self,</span>
  93 |     | <span class='neutral'>        uint256 collateralPriceD18</span>
  94 |     | <span class='neutral'>    ) internal view returns (uint256 usdWeightD18, int256 totalDebtD18) {</span>
  95 |     | <span class='neutral'>        VaultEpoch.Data storage epochData = currentEpoch(self);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        usdWeightD18 = (epochData.collateralAmounts.totalAmount()).mulDecimal(collateralPriceD18);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        totalDebtD18 = epochData.totalDebt();</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        //self.prevTotalDebtD18 = totalDebtD18.to128();</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /**</span>
 105 |     | <span class='neutral'>     * @dev Updated the value per share of the current epoch&#39;s incoming debt distribution.</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function distributeDebtToAccounts(Data storage self, int256 debtChangeD18) internal {</span>
 108 |     | <span class='neutral'>        currentEpoch(self).distributeDebtToAccounts(debtChangeD18);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Consolidates an accounts debt.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function consolidateAccountDebt(</span>
 115 |     | <span class='neutral'>        Data storage self,</span>
 116 |     | <span class='neutral'>        uint128 accountId</span>
 117 |     | <span class='neutral'>    ) internal returns (int256) {</span>
 118 |     | <span class='neutral'>        return currentEpoch(self).consolidateAccountDebt(accountId);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    function updateRewards(</span>
 122 |     | <span class='neutral'>        Data storage self,</span>
 123 |     | <span class='neutral'>        uint128 accountId,</span>
 124 |     | <span class='neutral'>        uint128 poolId,</span>
 125 |     | <span class='neutral'>        address collateralType</span>
 126 |     | <span class='neutral'>    ) internal returns (uint256[] memory rewards, address[] memory distributors) {</span>
 127 |     | <span class='neutral'>        uint256 totalSharesD18 = currentEpoch(self).accountsDebtDistribution.totalSharesD18;</span>
 128 |     | <span class='neutral'>        uint256 actorSharesD18 = currentEpoch(self).accountsDebtDistribution.getActorShares(</span>
 129 |     | <span class='neutral'>            accountId.toBytes32()</span>
 130 |     | <span class='neutral'>        );</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        return</span>
 133 |     | <span class='neutral'>            updateRewards(</span>
 134 |     | <span class='neutral'>                self,</span>
 135 |     | <span class='neutral'>                PositionSelector(accountId, poolId, collateralType),</span>
 136 |     | <span class='neutral'>                totalSharesD18,</span>
 137 |     | <span class='neutral'>                actorSharesD18</span>
 138 |     | <span class='neutral'>            );</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /**</span>
 142 |     | <span class='neutral'>     * @dev Traverses available rewards for this vault, and updates an accounts</span>
 143 |     | <span class='neutral'>     * claim on them according to the amount of debt shares they have.</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function updateRewards(</span>
 146 |     | <span class='neutral'>        Data storage self,</span>
 147 |     | <span class='neutral'>        PositionSelector memory pos,</span>
 148 |     | <span class='neutral'>        uint256 totalSharesD18,</span>
 149 |     | <span class='neutral'>        uint256 actorSharesD18</span>
 150 |     | <span class='neutral'>    ) internal returns (uint256[] memory rewards, address[] memory distributors) {</span>
 151 |     | <span class='neutral'>        rewards = new uint256[](self.rewardIds.length());</span>
 152 |     | <span class='neutral'>        distributors = new address[](self.rewardIds.length());</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        uint256 numRewards = self.rewardIds.length();</span>
 155 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; numRewards; i++) {</span>
 156 |     | <span class='neutral'>            RewardDistribution.Data storage dist = self.rewards[self.rewardIds.valueAt(i + 1)];</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>            if (address(dist.distributor) == address(0)) {</span>
 159 |     | <span class='neutral'>                continue;</span>
 160 |     | <span class='neutral'>            }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>            distributors[i] = address(dist.distributor);</span>
 163 |     | <span class='neutral'>            rewards[i] = updateReward(</span>
 164 |     | <span class='neutral'>                self,</span>
 165 |     | <span class='neutral'>                pos,</span>
 166 |     | <span class='neutral'>                self.rewardIds.valueAt(i + 1),</span>
 167 |     | <span class='neutral'>                totalSharesD18,</span>
 168 |     | <span class='neutral'>                actorSharesD18</span>
 169 |     | <span class='neutral'>            );</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /**</span>
 174 |     | <span class='neutral'>     * @dev Traverses available rewards for this vault and the reward id, and returns an accounts</span>
 175 |     | <span class='neutral'>     * pending claim on them according to the amount of debt shares they have.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='neutral'>    function getReward(</span>
 178 |     | <span class='neutral'>        Data storage self,</span>
 179 |     | <span class='neutral'>        uint128 accountId,</span>
 180 |     | <span class='neutral'>        bytes32 rewardId</span>
 181 |     | <span class='neutral'>    ) internal view returns (uint256) {</span>
 182 |     | <span class='neutral'>        uint256 totalSharesD18 = currentEpoch(self).accountsDebtDistribution.totalSharesD18;</span>
 183 |     | <span class='neutral'>        uint256 actorSharesD18 = currentEpoch(self).accountsDebtDistribution.getActorShares(</span>
 184 |     | <span class='neutral'>            accountId.toBytes32()</span>
 185 |     | <span class='neutral'>        );</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        RewardDistribution.Data storage dist = self.rewards[rewardId];</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        if (address(dist.distributor) == address(0)) {</span>
 190 |     | <span class='neutral'>            revert RewardDistributorNotFound();</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>        uint256 currentRewardPerShare = dist.rewardPerShareD18;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        currentRewardPerShare += dist.getEntry(totalSharesD18).toUint().to128();</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        uint256 currentPending = dist.claimStatus[accountId].pendingSendD18 +</span>
 198 |     | <span class='neutral'>            actorSharesD18.mulDecimal(</span>
 199 |     | <span class='neutral'>                currentRewardPerShare - dist.claimStatus[accountId].lastRewardPerShareD18</span>
 200 |     | <span class='neutral'>            );</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        return currentPending;</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    /**</span>
 206 |     | <span class='neutral'>     * @dev Traverses available rewards for this vault and the reward id, and updates an accounts</span>
 207 |     | <span class='neutral'>     * claim on them according to the amount of debt shares they have.</span>
 208 |     | <span class='neutral'>     */</span>
 209 |     | <span class='neutral'>    function updateReward(</span>
 210 |     | <span class='neutral'>        Data storage self,</span>
 211 |     | <span class='neutral'>        PositionSelector memory pos,</span>
 212 |     | <span class='neutral'>        bytes32 rewardId,</span>
 213 |     | <span class='neutral'>        uint256 totalSharesD18,</span>
 214 |     | <span class='neutral'>        uint256 actorSharesD18</span>
 215 |     | <span class='neutral'>    ) internal returns (uint256) {</span>
 216 |     | <span class='neutral'>        RewardDistribution.Data storage dist = self.rewards[rewardId];</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>        if (address(dist.distributor) == address(0)) {</span>
 219 |     | <span class='neutral'>            revert RewardDistributorNotFound();</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>        dist.distributor.onPositionUpdated(</span>
 223 |     | <span class='neutral'>            pos.accountId,</span>
 224 |     | <span class='neutral'>            pos.poolId,</span>
 225 |     | <span class='neutral'>            pos.collateralType,</span>
 226 |     | <span class='neutral'>            actorSharesD18</span>
 227 |     | <span class='neutral'>        );</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>        dist.rewardPerShareD18 += dist.updateEntry(totalSharesD18).toUint().to128();</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>        dist.claimStatus[pos.accountId].pendingSendD18 += actorSharesD18</span>
 232 |     | <span class='neutral'>            .mulDecimal(</span>
 233 |     | <span class='neutral'>                dist.rewardPerShareD18 - dist.claimStatus[pos.accountId].lastRewardPerShareD18</span>
 234 |     | <span class='neutral'>            )</span>
 235 |     | <span class='neutral'>            .to128();</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>        dist.claimStatus[pos.accountId].lastRewardPerShareD18 = dist.rewardPerShareD18;</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>        return dist.claimStatus[pos.accountId].pendingSendD18;</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /**</span>
 243 |     | <span class='neutral'>     * @dev Increments the current epoch index, effectively producing a</span>
 244 |     | <span class='neutral'>     * completely blank new VaultEpoch data structure in the vault.</span>
 245 |     | <span class='neutral'>     */</span>
 246 |     | <span class='neutral'>    function reset(Data storage self) internal {</span>
 247 |     | <span class='neutral'>        self.epoch++;</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    /**</span>
 251 |     | <span class='neutral'>     * @dev Returns the vault&#39;s combined debt (consolidated and unconsolidated),</span>
 252 |     | <span class='neutral'>     * for the current epoch.</span>
 253 |     | <span class='neutral'>     */</span>
 254 |     | <span class='neutral'>    function currentDebt(Data storage self) internal view returns (int256) {</span>
 255 |     | <span class='neutral'>        return currentEpoch(self).totalDebt();</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    /**</span>
 259 |     | <span class='neutral'>     * @dev Returns the total value in the Vault&#39;s collateral distribution, for the current epoch.</span>
 260 |     | <span class='neutral'>     */</span>
 261 |     | <span class='neutral'>    function currentCollateral(Data storage self) internal view returns (uint256) {</span>
 262 |     | <span class='neutral'>        return currentEpoch(self).collateralAmounts.totalAmount();</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    /**</span>
 266 |     | <span class='neutral'>     * @dev Returns an account&#39;s collateral value in this vault&#39;s current epoch.</span>
 267 |     | <span class='neutral'>     */</span>
 268 |     | <span class='neutral'>    function currentAccountCollateral(</span>
 269 |     | <span class='neutral'>        Data storage self,</span>
 270 |     | <span class='neutral'>        uint128 accountId</span>
 271 |     | <span class='neutral'>    ) internal view returns (uint256) {</span>
 272 |     | <span class='neutral'>        return currentEpoch(self).getAccountCollateral(accountId);</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'>}</span>
 275 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/VaultEpoch.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./Distribution.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./ScalableMapping.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @title Tracks collateral and debt distributions in a pool, for a specific collateral type, in a given epoch.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * Collateral is tracked with a distribution as opposed to a regular mapping because liquidations cause collateral to be socialized. If collateral was tracked using a regular mapping, such socialization would be difficult and require looping through individual balances, or some other sort of complex and expensive mechanism. Distributions make socialization easy.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * Debt is also tracked in a distribution for the same reason, but it is additionally split in two distributions: incoming and consolidated debt.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * Incoming debt is modified when a liquidations occurs.</span>
  17 |     | <span class='neutral'> * Consolidated debt is updated when users interact with the system.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library VaultEpoch {</span>
  20 |     | <span class='neutral'>    using Distribution for Distribution.Data;</span>
  21 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  22 |     | <span class='neutral'>    using SafeCastU128 for uint128;</span>
  23 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  24 |     | <span class='neutral'>    using SafeCastI128 for int128;</span>
  25 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  26 |     | <span class='neutral'>    using ScalableMapping for ScalableMapping.Data;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    struct Data {</span>
  29 |     | <span class='neutral'>        /**</span>
  30 |     | <span class='neutral'>         * @dev Amount of debt in this Vault that is yet to be consolidated.</span>
  31 |     | <span class='neutral'>         *</span>
  32 |     | <span class='neutral'>         * E.g. when a given amount of debt is socialized during a liquidation, but it yet hasn&#39;t been rolled into</span>
  33 |     | <span class='neutral'>         * the consolidated debt distribution.</span>
  34 |     | <span class='neutral'>         */</span>
  35 |     | <span class='neutral'>        int128 unconsolidatedDebtD18;</span>
  36 |     | <span class='neutral'>        /**</span>
  37 |     | <span class='neutral'>         * @dev Amount of debt in this Vault that has been consolidated.</span>
  38 |     | <span class='neutral'>         */</span>
  39 |     | <span class='neutral'>        int128 totalConsolidatedDebtD18;</span>
  40 |     | <span class='neutral'>        /**</span>
  41 |     | <span class='neutral'>         * @dev Tracks incoming debt for each user.</span>
  42 |     | <span class='neutral'>         *</span>
  43 |     | <span class='neutral'>         * The value of shares in this distribution change as the associate market changes, i.e. price changes in an asset in</span>
  44 |     | <span class='neutral'>         * a spot market.</span>
  45 |     | <span class='neutral'>         *</span>
  46 |     | <span class='neutral'>         * Also, when debt is socialized in a liquidation, it is done onto this distribution. As users</span>
  47 |     | <span class='neutral'>         * interact with the system, their independent debt is consolidated or rolled into consolidatedDebtDist.</span>
  48 |     | <span class='neutral'>         */</span>
  49 |     | <span class='neutral'>        Distribution.Data accountsDebtDistribution;</span>
  50 |     | <span class='neutral'>        /**</span>
  51 |     | <span class='neutral'>         * @dev Tracks collateral delegated to this vault, for each user.</span>
  52 |     | <span class='neutral'>         *</span>
  53 |     | <span class='neutral'>         * Uses a distribution instead of a regular market because of the way collateral is socialized during liquidations.</span>
  54 |     | <span class='neutral'>         *</span>
  55 |     | <span class='neutral'>         * A regular mapping would require looping over the mapping of each account&#39;s collateral, or moving the liquidated</span>
  56 |     | <span class='neutral'>         * collateral into a place where it could later be claimed. With a distribution, liquidated collateral can be</span>
  57 |     | <span class='neutral'>         * socialized very easily.</span>
  58 |     | <span class='neutral'>         */</span>
  59 |     | <span class='neutral'>        ScalableMapping.Data collateralAmounts;</span>
  60 |     | <span class='neutral'>        /**</span>
  61 |     | <span class='neutral'>         * @dev Tracks consolidated debt for each user.</span>
  62 |     | <span class='neutral'>         *</span>
  63 |     | <span class='neutral'>         * Updated when users interact with the system, consolidating changes from the fluctuating accountsDebtDistribution,</span>
  64 |     | <span class='neutral'>         * and directly when users mint or burn USD, or repay debt.</span>
  65 |     | <span class='neutral'>         */</span>
  66 |     | <span class='neutral'>        mapping(uint256 =&gt; int256) consolidatedDebtAmountsD18;</span>
  67 |     | <span class='neutral'>        /**</span>
  68 |     | <span class='neutral'>         * @dev Tracks last time a user delegated to this vault.</span>
  69 |     | <span class='neutral'>         *</span>
  70 |     | <span class='neutral'>         * Needed to validate min delegation time compliance to prevent small scale debt pool frontrunning</span>
  71 |     | <span class='neutral'>         */</span>
  72 |     | <span class='neutral'>        mapping(uint128 =&gt; uint64) lastDelegationTime;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Updates the value per share of the incoming debt distribution.</span>
  77 |     | <span class='neutral'>     * Used for socialization during liquidations, and to bake in market changes.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Called from:</span>
  80 |     | <span class='neutral'>     * - LiquidationModule.liquidate</span>
  81 |     | <span class='neutral'>     * - Pool.recalculateVaultCollateral (ticker)</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    function distributeDebtToAccounts(Data storage self, int256 debtChangeD18) internal {</span>
  84 |     | <span class='neutral'>        self.accountsDebtDistribution.distributeValue(debtChangeD18);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // Cache total debt here.</span>
  87 |     | <span class='neutral'>        // Will roll over to individual users as they interact with the system.</span>
  88 |     | <span class='neutral'>        self.unconsolidatedDebtD18 += debtChangeD18.to128();</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Adjusts the debt associated with `accountId` by `amountD18`.</span>
  93 |     | <span class='neutral'>     * Used to add or remove debt from/to a specific account, instead of all accounts at once (use distributeDebtToAccounts for that)</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function assignDebtToAccount(</span>
  96 |     | <span class='neutral'>        Data storage self,</span>
  97 |     | <span class='neutral'>        uint128 accountId,</span>
  98 |     | <span class='neutral'>        int256 amountD18</span>
  99 |     | <span class='neutral'>    ) internal returns (int256 newDebtD18) {</span>
 100 |     | <span class='neutral'>        int256 currentDebtD18 = self.consolidatedDebtAmountsD18[accountId];</span>
 101 |     | <span class='neutral'>        self.consolidatedDebtAmountsD18[accountId] += amountD18;</span>
 102 |     | <span class='neutral'>        self.totalConsolidatedDebtD18 += amountD18.to128();</span>
 103 |     | <span class='neutral'>        return currentDebtD18 + amountD18;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /**</span>
 107 |     | <span class='neutral'>     * @dev Consolidates user debt as they interact with the system.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * Fluctuating debt is moved from incoming to consolidated debt.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Called as a ticker from various parts of the system, usually whenever the</span>
 112 |     | <span class='neutral'>     * real debt of a user needs to be known.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function consolidateAccountDebt(</span>
 115 |     | <span class='neutral'>        Data storage self,</span>
 116 |     | <span class='neutral'>        uint128 accountId</span>
 117 |     | <span class='neutral'>    ) internal returns (int256 currentDebtD18) {</span>
 118 |     | <span class='neutral'>        int256 newDebtD18 = self.accountsDebtDistribution.accumulateActor(accountId.toBytes32());</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        currentDebtD18 = assignDebtToAccount(self, accountId, newDebtD18);</span>
 121 |     | <span class='neutral'>        self.unconsolidatedDebtD18 -= newDebtD18.to128();</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev Updates a user&#39;s collateral value, and sets their exposure to debt</span>
 126 |     | <span class='neutral'>     * according to the collateral they delegated and the leverage used.</span>
 127 |     | <span class='neutral'>     *</span>
 128 |     | <span class='neutral'>     * Called whenever a user&#39;s collateral changes.</span>
 129 |     | <span class='neutral'>     */</span>
 130 |     | <span class='neutral'>    function updateAccountPosition(</span>
 131 |     | <span class='neutral'>        Data storage self,</span>
 132 |     | <span class='neutral'>        uint128 accountId,</span>
 133 |     | <span class='neutral'>        uint256 collateralAmountD18,</span>
 134 |     | <span class='neutral'>        uint256 leverageD18</span>
 135 |     | <span class='neutral'>    ) internal {</span>
 136 |     | <span class='neutral'>        bytes32 actorId = accountId.toBytes32();</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // Ensure account debt is consolidated before we do next things.</span>
 139 |     | <span class='neutral'>        consolidateAccountDebt(self, accountId);</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        self.collateralAmounts.set(actorId, collateralAmountD18);</span>
 142 |     | <span class='neutral'>        self.accountsDebtDistribution.setActorShares(</span>
 143 |     | <span class='neutral'>            actorId,</span>
 144 |     | <span class='neutral'>            self.collateralAmounts.sharesD18[actorId].mulDecimal(leverageD18)</span>
 145 |     | <span class='neutral'>        );</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Returns the vault&#39;s total debt in this epoch, including the debt</span>
 150 |     | <span class='neutral'>     * that hasn&#39;t yet been consolidated into individual accounts.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    function totalDebt(Data storage self) internal view returns (int256) {</span>
 153 |     | <span class='neutral'>        return self.unconsolidatedDebtD18 + self.totalConsolidatedDebtD18;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /**</span>
 157 |     | <span class='neutral'>     * @dev Returns an account&#39;s value in the Vault&#39;s collateral distribution.</span>
 158 |     | <span class='neutral'>     */</span>
 159 |     | <span class='neutral'>    function getAccountCollateral(</span>
 160 |     | <span class='neutral'>        Data storage self,</span>
 161 |     | <span class='neutral'>        uint128 accountId</span>
 162 |     | <span class='neutral'>    ) internal view returns (uint256 amountD18) {</span>
 163 |     | <span class='neutral'>        return self.collateralAmounts.get(accountId.toBytes32());</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'>}</span>
 166 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../storage/NodeOutput.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../storage/NodeDefinition.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title Module for managing nodes</span>
  8 |     | <span class='neutral'>interface INodeModule {</span>
  9 |     | <span class='neutral'>    /**</span>
 10 |     | <span class='neutral'>     * @notice Thrown when the specified nodeId has not been registered in the system.</span>
 11 |     | <span class='neutral'>     */</span>
 12 |     | <span class='neutral'>    error NodeNotRegistered(bytes32 nodeId);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @notice Thrown when a node is registered without a valid definition.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    error InvalidNodeDefinition(NodeDefinition.Data nodeType);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @notice Emitted when `registerNode` is called.</span>
 21 |     | <span class='neutral'>     * @param nodeId The id of the registered node.</span>
 22 |     | <span class='neutral'>     * @param nodeType The nodeType assigned to this node.</span>
 23 |     | <span class='neutral'>     * @param parameters The parameters assigned to this node.</span>
 24 |     | <span class='neutral'>     * @param parents The parents assigned to this node.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    event NodeRegistered(</span>
 27 |     | <span class='neutral'>        bytes32 nodeId,</span>
 28 |     | <span class='neutral'>        NodeDefinition.NodeType nodeType,</span>
 29 |     | <span class='neutral'>        bytes parameters,</span>
 30 |     | <span class='neutral'>        bytes32[] parents</span>
 31 |     | <span class='neutral'>    );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /**</span>
 34 |     | <span class='neutral'>     * @notice Registers a node</span>
 35 |     | <span class='neutral'>     * @param nodeType The nodeType assigned to this node.</span>
 36 |     | <span class='neutral'>     * @param parameters The parameters assigned to this node.</span>
 37 |     | <span class='neutral'>     * @param parents The parents assigned to this node.</span>
 38 |     | <span class='neutral'>     * @return nodeId The id of the registered node.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    function registerNode(</span>
 41 |     | <span class='neutral'>        NodeDefinition.NodeType nodeType,</span>
 42 |     | <span class='neutral'>        bytes memory parameters,</span>
 43 |     | <span class='neutral'>        bytes32[] memory parents</span>
 44 |     | <span class='neutral'>    ) external returns (bytes32 nodeId);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @notice Returns the ID of a node, whether or not it has been registered.</span>
 48 |     | <span class='neutral'>     * @param parents The parents assigned to this node.</span>
 49 |     | <span class='neutral'>     * @param nodeType The nodeType assigned to this node.</span>
 50 |     | <span class='neutral'>     * @param parameters The parameters assigned to this node.</span>
 51 |     | <span class='neutral'>     * @return nodeId The id of the node.</span>
 52 |     | <span class='neutral'>     */</span>
 53 |     | <span class='neutral'>    function getNodeId(</span>
 54 |     | <span class='neutral'>        NodeDefinition.NodeType nodeType,</span>
 55 |     | <span class='neutral'>        bytes memory parameters,</span>
 56 |     | <span class='neutral'>        bytes32[] memory parents</span>
 57 |     | <span class='neutral'>    ) external pure returns (bytes32 nodeId);</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /**</span>
 60 |     | <span class='neutral'>     * @notice Returns a node&#39;s definition (type, parameters, and parents)</span>
 61 |     | <span class='neutral'>     * @param nodeId The node ID</span>
 62 |     | <span class='neutral'>     * @return node The node&#39;s definition data</span>
 63 |     | <span class='neutral'>     */</span>
 64 |     | <span class='neutral'>    function getNode(bytes32 nodeId) external pure returns (NodeDefinition.Data memory node);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    /**</span>
 67 |     | <span class='neutral'>     * @notice Returns a node current output data</span>
 68 |     | <span class='neutral'>     * @param nodeId The node ID</span>
 69 |     | <span class='neutral'>     * @return node The node&#39;s output data</span>
 70 |     | <span class='neutral'>     */</span>
 71 |     | <span class='neutral'>    function process(bytes32 nodeId) external view returns (NodeOutput.Data memory node);</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /**</span>
 74 |     | <span class='neutral'>     * @notice Returns a node current output data</span>
 75 |     | <span class='neutral'>     * @param nodeId The node ID</span>
 76 |     | <span class='neutral'>     * @param runtimeKeys Keys corresponding to runtime values which could be used by the node graph</span>
 77 |     | <span class='neutral'>     * @param runtimeValues The values used by the node graph</span>
 78 |     | <span class='neutral'>     * @return node The node&#39;s output data</span>
 79 |     | <span class='neutral'>     */</span>
 80 |     | <span class='neutral'>    function processWithRuntime(</span>
 81 |     | <span class='neutral'>        bytes32 nodeId,</span>
 82 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 83 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 84 |     | <span class='neutral'>    ) external view returns (NodeOutput.Data memory node);</span>
 85 |     | <span class='neutral'>}</span>
 86 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IAggregatorV3Interface.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Interface an aggregator needs to adhere.</span>
  5 |     | <span class='neutral'>interface IAggregatorV3Interface {</span>
  6 |     | <span class='neutral'>    /// @notice decimals used by the aggregator</span>
  7 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    /// @notice aggregator&#39;s description</span>
 10 |     | <span class='neutral'>    function description() external view returns (string memory);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice aggregator&#39;s version</span>
 13 |     | <span class='neutral'>    function version() external view returns (uint256);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    // getRoundData and latestRoundData should both raise &quot;No data present&quot;</span>
 16 |     | <span class='neutral'>    // if they do not have data to report, instead of returning unset values</span>
 17 |     | <span class='neutral'>    // which could be misinterpreted as actual reported values.</span>
 18 |     | <span class='neutral'>    /// @notice get&#39;s round data for requested id</span>
 19 |     | <span class='neutral'>    function getRoundData(</span>
 20 |     | <span class='neutral'>        uint80 id</span>
 21 |     | <span class='neutral'>    )</span>
 22 |     | <span class='neutral'>        external</span>
 23 |     | <span class='neutral'>        view</span>
 24 |     | <span class='neutral'>        returns (</span>
 25 |     | <span class='neutral'>            uint80 roundId,</span>
 26 |     | <span class='neutral'>            int256 answer,</span>
 27 |     | <span class='neutral'>            uint256 startedAt,</span>
 28 |     | <span class='neutral'>            uint256 updatedAt,</span>
 29 |     | <span class='neutral'>            uint80 answeredInRound</span>
 30 |     | <span class='neutral'>        );</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /// @notice get&#39;s latest round data</span>
 33 |     | <span class='neutral'>    function latestRoundData()</span>
 34 |     | <span class='neutral'>        external</span>
 35 |     | <span class='neutral'>        view</span>
 36 |     | <span class='neutral'>        returns (</span>
 37 |     | <span class='neutral'>            uint80 roundId,</span>
 38 |     | <span class='neutral'>            int256 answer,</span>
 39 |     | <span class='neutral'>            uint256 startedAt,</span>
 40 |     | <span class='neutral'>            uint256 updatedAt,</span>
 41 |     | <span class='neutral'>            uint80 answeredInRound</span>
 42 |     | <span class='neutral'>        );</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IExternalNode.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../../storage/NodeOutput.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../storage/NodeDefinition.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @title Interface for an external node</span>
 10 |     | <span class='neutral'>interface IExternalNode is IERC165 {</span>
 11 |     | <span class='neutral'>    function process(</span>
 12 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs,</span>
 13 |     | <span class='neutral'>        bytes memory parameters,</span>
 14 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 15 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 16 |     | <span class='neutral'>    ) external view returns (NodeOutput.Data memory);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) external returns (bool);</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IPyth.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: Apache-2.0</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Consume prices from the Pyth Network (https://pyth.network/).</span>
   5 |     | <span class='neutral'>/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.</span>
   6 |     | <span class='neutral'>/// @author Pyth Data Association</span>
   7 |     | <span class='neutral'>interface IPyth {</span>
   8 |     | <span class='neutral'>    /// @dev Emitted when an update for price feed with `id` is processed successfully.</span>
   9 |     | <span class='neutral'>    /// @param id The Pyth Price Feed ID.</span>
  10 |     | <span class='neutral'>    /// @param fresh True if the price update is more recent and stored.</span>
  11 |     | <span class='neutral'>    /// @param chainId ID of the source chain that the batch price update containing this price.</span>
  12 |     | <span class='neutral'>    /// This value comes from Wormhole, and you can find the corresponding chains at https://docs.wormholenetwork.com/wormhole/contracts.</span>
  13 |     | <span class='neutral'>    /// @param sequenceNumber Sequence number of the batch price update containing this price.</span>
  14 |     | <span class='neutral'>    /// @param lastPublishTime Publish time of the previously stored price.</span>
  15 |     | <span class='neutral'>    /// @param publishTime Publish time of the given price update.</span>
  16 |     | <span class='neutral'>    /// @param price Price of the given price update.</span>
  17 |     | <span class='neutral'>    /// @param conf Confidence interval of the given price update.</span>
  18 |     | <span class='neutral'>    event PriceFeedUpdate(</span>
  19 |     | <span class='neutral'>        bytes32 indexed id,</span>
  20 |     | <span class='neutral'>        bool indexed fresh,</span>
  21 |     | <span class='neutral'>        uint16 chainId,</span>
  22 |     | <span class='neutral'>        uint64 sequenceNumber,</span>
  23 |     | <span class='neutral'>        uint256 lastPublishTime,</span>
  24 |     | <span class='neutral'>        uint256 publishTime,</span>
  25 |     | <span class='neutral'>        int64 price,</span>
  26 |     | <span class='neutral'>        uint64 conf</span>
  27 |     | <span class='neutral'>    );</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /// @dev Emitted when a batch price update is processed successfully.</span>
  30 |     | <span class='neutral'>    /// @param chainId ID of the source chain that the batch price update comes from.</span>
  31 |     | <span class='neutral'>    /// @param sequenceNumber Sequence number of the batch price update.</span>
  32 |     | <span class='neutral'>    /// @param batchSize Number of prices within the batch price update.</span>
  33 |     | <span class='neutral'>    /// @param freshPricesInBatch Number of prices that were more recent and were stored.</span>
  34 |     | <span class='neutral'>    event BatchPriceFeedUpdate(</span>
  35 |     | <span class='neutral'>        uint16 chainId,</span>
  36 |     | <span class='neutral'>        uint64 sequenceNumber,</span>
  37 |     | <span class='neutral'>        uint256 batchSize,</span>
  38 |     | <span class='neutral'>        uint256 freshPricesInBatch</span>
  39 |     | <span class='neutral'>    );</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @dev Emitted when a call to `updatePriceFeeds` is processed successfully.</span>
  42 |     | <span class='neutral'>    /// @param sender Sender of the call (`msg.sender`).</span>
  43 |     | <span class='neutral'>    /// @param batchCount Number of batches that this function processed.</span>
  44 |     | <span class='neutral'>    /// @param fee Amount of paid fee for updating the prices.</span>
  45 |     | <span class='neutral'>    event UpdatePriceFeeds(address indexed sender, uint256 batchCount, uint256 fee);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time</span>
  48 |     | <span class='neutral'>    function getValidTimePeriod() external view returns (uint256 validTimePeriod);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Returns the price and confidence interval.</span>
  51 |     | <span class='neutral'>    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.</span>
  52 |     | <span class='neutral'>    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.</span>
  53 |     | <span class='neutral'>    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.</span>
  54 |     | <span class='neutral'>    function getPrice(bytes32 id) external view returns (PythStructs.Price memory price);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @notice Returns the exponentially-weighted moving average price and confidence interval.</span>
  57 |     | <span class='neutral'>    /// @dev Reverts if the EMA price is not available.</span>
  58 |     | <span class='neutral'>    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.</span>
  59 |     | <span class='neutral'>    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.</span>
  60 |     | <span class='neutral'>    function getEmaPrice(bytes32 id) external view returns (PythStructs.Price memory price);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /// @notice Returns the price of a price feed without any sanity checks.</span>
  63 |     | <span class='neutral'>    /// @dev This function returns the most recent price update in this contract without any recency checks.</span>
  64 |     | <span class='neutral'>    /// This function is unsafe as the returned price update may be arbitrarily far in the past.</span>
  65 |     | <span class='neutral'>    ///</span>
  66 |     | <span class='neutral'>    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is</span>
  67 |     | <span class='neutral'>    /// sufficiently recent for their application. If you are considering using this function, it may be</span>
  68 |     | <span class='neutral'>    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.</span>
  69 |     | <span class='neutral'>    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.</span>
  70 |     | <span class='neutral'>    function getPriceUnsafe(bytes32 id) external view returns (PythStructs.Price memory price);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /// @notice Returns the price that is no older than `age` seconds of the current time.</span>
  73 |     | <span class='neutral'>    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in</span>
  74 |     | <span class='neutral'>    /// applications that require a sufficiently-recent price. Reverts if the price wasn&#39;t updated sufficiently</span>
  75 |     | <span class='neutral'>    /// recently.</span>
  76 |     | <span class='neutral'>    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.</span>
  77 |     | <span class='neutral'>    function getPriceNoOlderThan(</span>
  78 |     | <span class='neutral'>        bytes32 id,</span>
  79 |     | <span class='neutral'>        uint256 age</span>
  80 |     | <span class='neutral'>    ) external view returns (PythStructs.Price memory price);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.</span>
  83 |     | <span class='neutral'>    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.</span>
  84 |     | <span class='neutral'>    /// However, if the price is not recent this function returns the latest available price.</span>
  85 |     | <span class='neutral'>    ///</span>
  86 |     | <span class='neutral'>    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that</span>
  87 |     | <span class='neutral'>    /// the returned price is recent or useful for any particular application.</span>
  88 |     | <span class='neutral'>    ///</span>
  89 |     | <span class='neutral'>    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is</span>
  90 |     | <span class='neutral'>    /// sufficiently recent for their application. If you are considering using this function, it may be</span>
  91 |     | <span class='neutral'>    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.</span>
  92 |     | <span class='neutral'>    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.</span>
  93 |     | <span class='neutral'>    function getEmaPriceUnsafe(bytes32 id) external view returns (PythStructs.Price memory price);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds</span>
  96 |     | <span class='neutral'>    /// of the current time.</span>
  97 |     | <span class='neutral'>    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in</span>
  98 |     | <span class='neutral'>    /// applications that require a sufficiently-recent price. Reverts if the price wasn&#39;t updated sufficiently</span>
  99 |     | <span class='neutral'>    /// recently.</span>
 100 |     | <span class='neutral'>    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.</span>
 101 |     | <span class='neutral'>    function getEmaPriceNoOlderThan(</span>
 102 |     | <span class='neutral'>        bytes32 id,</span>
 103 |     | <span class='neutral'>        uint256 age</span>
 104 |     | <span class='neutral'>    ) external view returns (PythStructs.Price memory price);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /// @notice Update price feeds with given update messages.</span>
 107 |     | <span class='neutral'>    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling</span>
 108 |     | <span class='neutral'>    /// `getUpdateFee` with the length of the `updateData` array.</span>
 109 |     | <span class='neutral'>    /// Prices will be updated if they are more recent than the current stored prices.</span>
 110 |     | <span class='neutral'>    /// The call will succeed even if the update is not the most recent.</span>
 111 |     | <span class='neutral'>    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.</span>
 112 |     | <span class='neutral'>    /// @param updateData Array of price update data.</span>
 113 |     | <span class='neutral'>    function updatePriceFeeds(bytes[] calldata updateData) external payable;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is</span>
 116 |     | <span class='neutral'>    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the</span>
 117 |     | <span class='neutral'>    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.</span>
 118 |     | <span class='neutral'>    ///</span>
 119 |     | <span class='neutral'>    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling</span>
 120 |     | <span class='neutral'>    /// `getUpdateFee` with the length of the `updateData` array.</span>
 121 |     | <span class='neutral'>    ///</span>
 122 |     | <span class='neutral'>    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime</span>
 123 |     | <span class='neutral'>    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have</span>
 124 |     | <span class='neutral'>    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.</span>
 125 |     | <span class='neutral'>    /// Otherwise, it calls updatePriceFeeds method to update the prices.</span>
 126 |     | <span class='neutral'>    ///</span>
 127 |     | <span class='neutral'>    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.</span>
 128 |     | <span class='neutral'>    /// @param updateData Array of price update data.</span>
 129 |     | <span class='neutral'>    /// @param priceIds Array of price ids.</span>
 130 |     | <span class='neutral'>    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`</span>
 131 |     | <span class='neutral'>    function updatePriceFeedsIfNecessary(</span>
 132 |     | <span class='neutral'>        bytes[] calldata updateData,</span>
 133 |     | <span class='neutral'>        bytes32[] calldata priceIds,</span>
 134 |     | <span class='neutral'>        uint64[] calldata publishTimes</span>
 135 |     | <span class='neutral'>    ) external payable;</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /// @notice Returns the required fee to update an array of price updates.</span>
 138 |     | <span class='neutral'>    /// @param updateData Array of price update data.</span>
 139 |     | <span class='neutral'>    /// @return feeAmount The required fee in Wei.</span>
 140 |     | <span class='neutral'>    function getUpdateFee(bytes[] calldata updateData) external view returns (uint256 feeAmount);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are</span>
 143 |     | <span class='neutral'>    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,</span>
 144 |     | <span class='neutral'>    /// this method will return the first update.</span>
 145 |     | <span class='neutral'>    ///</span>
 146 |     | <span class='neutral'>    ///</span>
 147 |     | <span class='neutral'>    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is</span>
 148 |     | <span class='neutral'>    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.</span>
 149 |     | <span class='neutral'>    /// @param updateData Array of price update data.</span>
 150 |     | <span class='neutral'>    /// @param priceIds Array of price ids.</span>
 151 |     | <span class='neutral'>    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.</span>
 152 |     | <span class='neutral'>    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.</span>
 153 |     | <span class='neutral'>    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).</span>
 154 |     | <span class='neutral'>    function parsePriceFeedUpdatesUnique(</span>
 155 |     | <span class='neutral'>        bytes[] calldata updateData,</span>
 156 |     | <span class='neutral'>        bytes32[] calldata priceIds,</span>
 157 |     | <span class='neutral'>        uint64 minPublishTime,</span>
 158 |     | <span class='neutral'>        uint64 maxPublishTime</span>
 159 |     | <span class='neutral'>    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);</span>
 160 |     | <span class='neutral'>}</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>contract PythStructs {</span>
 163 |     | <span class='neutral'>    // A price with a degree of uncertainty, represented as a price +- a confidence interval.</span>
 164 |     | <span class='neutral'>    //</span>
 165 |     | <span class='neutral'>    // The confidence interval roughly corresponds to the standard error of a normal distribution.</span>
 166 |     | <span class='neutral'>    // Both the price and confidence are stored in a fixed-point numeric representation,</span>
 167 |     | <span class='neutral'>    // `x * (10^expo)`, where `expo` is the exponent.</span>
 168 |     | <span class='neutral'>    //</span>
 169 |     | <span class='neutral'>    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how</span>
 170 |     | <span class='neutral'>    // to how this price safely.</span>
 171 |     | <span class='neutral'>    struct Price {</span>
 172 |     | <span class='neutral'>        // Price</span>
 173 |     | <span class='neutral'>        int64 price;</span>
 174 |     | <span class='neutral'>        // Confidence interval around the price</span>
 175 |     | <span class='neutral'>        uint64 conf;</span>
 176 |     | <span class='neutral'>        // Price exponent</span>
 177 |     | <span class='neutral'>        int32 expo;</span>
 178 |     | <span class='neutral'>        // Unix timestamp describing when the price was published</span>
 179 |     | <span class='neutral'>        uint256 publishTime;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    // PriceFeed represents a current aggregate price from pyth publisher feeds.</span>
 183 |     | <span class='neutral'>    struct PriceFeed {</span>
 184 |     | <span class='neutral'>        // The price ID.</span>
 185 |     | <span class='neutral'>        bytes32 id;</span>
 186 |     | <span class='neutral'>        // Latest available price</span>
 187 |     | <span class='neutral'>        Price price;</span>
 188 |     | <span class='neutral'>        // Latest available exponentially-weighted moving average price</span>
 189 |     | <span class='neutral'>        Price emaPrice;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'>}</span>
 192 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IUniswapV3Pool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Apache-2.0</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUniswapV3Pool {</span>
  5 |     | <span class='neutral'>    function observe(</span>
  6 |     | <span class='neutral'>        uint32[] calldata secondsAgos</span>
  7 |     | <span class='neutral'>    )</span>
  8 |     | <span class='neutral'>        external</span>
  9 |     | <span class='neutral'>        view</span>
 10 |     | <span class='neutral'>        returns (</span>
 11 |     | <span class='neutral'>            int56[] memory tickCumulatives,</span>
 12 |     | <span class='neutral'>            uint160[] memory secondsPerLiquidityCumulativeX128s</span>
 13 |     | <span class='neutral'>        );</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ChainlinkNode.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;../storage/NodeDefinition.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../storage/NodeOutput.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../interfaces/external/IAggregatorV3Interface.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library ChainlinkNode {</span>
  12 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  13 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  14 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    uint256 public constant PRECISION = 18;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    function process(</span>
  19 |     | <span class='neutral'>        bytes memory parameters</span>
  20 |     | <span class='neutral'>    ) internal view returns (NodeOutput.Data memory nodeOutput) {</span>
  21 |     | <span class='neutral'>        (address chainlinkAddr, uint256 twapTimeInterval, uint8 decimals) = abi.decode(</span>
  22 |     | <span class='neutral'>            parameters,</span>
  23 |     | <span class='neutral'>            (address, uint256, uint8)</span>
  24 |     | <span class='neutral'>        );</span>
  25 |     | <span class='neutral'>        IAggregatorV3Interface chainlink = IAggregatorV3Interface(chainlinkAddr);</span>
  26 |     | <span class='neutral'>        (uint80 roundId, int256 price, , uint256 updatedAt, ) = chainlink.latestRoundData();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        int256 finalPrice = twapTimeInterval == 0</span>
  29 |     | <span class='neutral'>            ? price</span>
  30 |     | <span class='neutral'>            : getTwapPrice(chainlink, roundId, price, twapTimeInterval);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        finalPrice = decimals &gt; PRECISION</span>
  33 |     | <span class='neutral'>            ? finalPrice.downscale(decimals - PRECISION)</span>
  34 |     | <span class='neutral'>            : finalPrice.upscale(PRECISION - decimals);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        return NodeOutput.Data(finalPrice, updatedAt, 0, 0);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    function getTwapPrice(</span>
  40 |     | <span class='neutral'>        IAggregatorV3Interface chainlink,</span>
  41 |     | <span class='neutral'>        uint80 latestRoundId,</span>
  42 |     | <span class='neutral'>        int256 latestPrice,</span>
  43 |     | <span class='neutral'>        uint256 twapTimeInterval</span>
  44 |     | <span class='neutral'>    ) internal view returns (int256 price) {</span>
  45 |     | <span class='neutral'>        int256 priceSum = latestPrice;</span>
  46 |     | <span class='neutral'>        uint256 priceCount = 1;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        uint256 startTime = block.timestamp - twapTimeInterval;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        while (latestRoundId &gt; 0) {</span>
  51 |     | <span class='neutral'>            try chainlink.getRoundData(--latestRoundId) returns (</span>
  52 |     | <span class='neutral'>                uint80,</span>
  53 |     | <span class='neutral'>                int256 answer,</span>
  54 |     | <span class='neutral'>                uint256,</span>
  55 |     | <span class='neutral'>                uint256 updatedAt,</span>
  56 |     | <span class='neutral'>                uint80</span>
  57 |     | <span class='neutral'>            ) {</span>
  58 |     | <span class='neutral'>                if (updatedAt &lt; startTime) {</span>
  59 |     | <span class='neutral'>                    break;</span>
  60 |     | <span class='neutral'>                }</span>
  61 |     | <span class='neutral'>                priceSum += answer;</span>
  62 |     | <span class='neutral'>                priceCount++;</span>
  63 |     | <span class='neutral'>            } catch {</span>
  64 |     | <span class='neutral'>                break;</span>
  65 |     | <span class='neutral'>            }</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        return priceSum / priceCount.toInt();</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal view returns (bool valid) {</span>
  72 |     | <span class='neutral'>        // Must have no parents</span>
  73 |     | <span class='neutral'>        if (nodeDefinition.parents.length &gt; 0) {</span>
  74 |     | <span class='neutral'>            return false;</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
  78 |     | <span class='neutral'>        if (nodeDefinition.parameters.length != 32 * 3) {</span>
  79 |     | <span class='neutral'>            return false;</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        (address chainlinkAddr, , uint8 decimals) = abi.decode(</span>
  83 |     | <span class='neutral'>            nodeDefinition.parameters,</span>
  84 |     | <span class='neutral'>            (address, uint256, uint8)</span>
  85 |     | <span class='neutral'>        );</span>
  86 |     | <span class='neutral'>        IAggregatorV3Interface chainlink = IAggregatorV3Interface(chainlinkAddr);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // Must return latestRoundData without error</span>
  89 |     | <span class='neutral'>        chainlink.latestRoundData();</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // Must return decimals that match the definition</span>
  92 |     | <span class='neutral'>        if (decimals != chainlink.decimals()) {</span>
  93 |     | <span class='neutral'>            return false;</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        return true;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'>}</span>
  99 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ConstantNode.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../storage/NodeDefinition.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../storage/NodeOutput.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library ConstantNode {</span>
  8 |     | <span class='neutral'>    function process(</span>
  9 |     | <span class='neutral'>        bytes memory parameters</span>
 10 |     | <span class='neutral'>    ) internal view returns (NodeOutput.Data memory nodeOutput) {</span>
 11 |     | <span class='neutral'>        return NodeOutput.Data(abi.decode(parameters, (int256)), block.timestamp, 0, 0);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {</span>
 15 |     | <span class='neutral'>        // Must have no parents</span>
 16 |     | <span class='neutral'>        if (nodeDefinition.parents.length &gt; 0) {</span>
 17 |     | <span class='neutral'>            return false;</span>
 18 |     | <span class='neutral'>        }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
 21 |     | <span class='neutral'>        if (nodeDefinition.parameters.length &lt; 32) {</span>
 22 |     | <span class='neutral'>            return false;</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>        return true;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ExternalNode.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../storage/NodeDefinition.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../storage/NodeOutput.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../interfaces/external/IExternalNode.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>library ExternalNode {</span>
 11 |     | <span class='neutral'>    function process(</span>
 12 |     | <span class='neutral'>        NodeOutput.Data[] memory prices,</span>
 13 |     | <span class='neutral'>        bytes memory parameters,</span>
 14 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 15 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 16 |     | <span class='neutral'>    ) internal view returns (NodeOutput.Data memory nodeOutput) {</span>
 17 |     | <span class='neutral'>        IExternalNode externalNode = IExternalNode(abi.decode(parameters, (address)));</span>
 18 |     | <span class='neutral'>        return externalNode.process(prices, parameters, runtimeKeys, runtimeValues);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal returns (bool valid) {</span>
 22 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
 23 |     | <span class='neutral'>        if (nodeDefinition.parameters.length &lt; 32) {</span>
 24 |     | <span class='neutral'>            return false;</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        address externalNode = abi.decode(nodeDefinition.parameters, (address));</span>
 28 |     | <span class='neutral'>        if (!ERC165Helper.safeSupportsInterface(externalNode, type(IExternalNode).interfaceId)) {</span>
 29 |     | <span class='neutral'>            return false;</span>
 30 |     | <span class='neutral'>        }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>        if (!IExternalNode(externalNode).isValid(nodeDefinition)) {</span>
 33 |     | <span class='neutral'>            return false;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>        return true;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/PriceDeviationCircuitBreakerNode.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;../storage/NodeDefinition.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../storage/NodeOutput.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>library PriceDeviationCircuitBreakerNode {</span>
 11 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
 12 |     | <span class='neutral'>    using DecimalMath for int256;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    error DeviationToleranceExceeded(int256 deviation);</span>
 15 |     | <span class='neutral'>    error InvalidInputPrice();</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function process(</span>
 18 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs,</span>
 19 |     | <span class='neutral'>        bytes memory parameters</span>
 20 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory nodeOutput) {</span>
 21 |     | <span class='neutral'>        uint256 deviationTolerance = abi.decode(parameters, (uint256));</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>        int256 primaryPrice = parentNodeOutputs[0].price;</span>
 24 |     | <span class='neutral'>        int256 comparisonPrice = parentNodeOutputs[1].price;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>        if (primaryPrice != comparisonPrice) {</span>
 27 |     | <span class='neutral'>            int256 difference = abs(primaryPrice - comparisonPrice).upscale(18);</span>
 28 |     | <span class='neutral'>            if (</span>
 29 |     | <span class='neutral'>                primaryPrice == 0 || deviationTolerance.toInt() &lt; (difference / abs(primaryPrice))</span>
 30 |     | <span class='neutral'>            ) {</span>
 31 |     | <span class='neutral'>                if (parentNodeOutputs.length &gt; 2) {</span>
 32 |     | <span class='neutral'>                    return parentNodeOutputs[2];</span>
 33 |     | <span class='neutral'>                } else {</span>
 34 |     | <span class='neutral'>                    if (primaryPrice == 0) {</span>
 35 |     | <span class='neutral'>                        revert InvalidInputPrice();</span>
 36 |     | <span class='neutral'>                    } else {</span>
 37 |     | <span class='neutral'>                        revert DeviationToleranceExceeded(difference / abs(primaryPrice));</span>
 38 |     | <span class='neutral'>                    }</span>
 39 |     | <span class='neutral'>                }</span>
 40 |     | <span class='neutral'>            }</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>        return parentNodeOutputs[0];</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function abs(int256 x) private pure returns (int256 result) {</span>
 47 |     | <span class='neutral'>        return x &gt;= 0 ? x : -x;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {</span>
 51 |     | <span class='neutral'>        // Must have 2-3 parents</span>
 52 |     | <span class='neutral'>        if (!(nodeDefinition.parents.length == 2 || nodeDefinition.parents.length == 3)) {</span>
 53 |     | <span class='neutral'>            return false;</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
 57 |     | <span class='neutral'>        if (nodeDefinition.parameters.length != 32) {</span>
 58 |     | <span class='neutral'>            return false;</span>
 59 |     | <span class='neutral'>        }</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>        return true;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ReducerNode.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;../storage/NodeDefinition.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../storage/NodeOutput.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library ReducerNode {</span>
  11 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  12 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  13 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    error UnsupportedOperation(Operations operation);</span>
  16 |     | <span class='neutral'>    error InvalidPrice(int256 price);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    enum Operations {</span>
  19 |     | <span class='neutral'>        RECENT,</span>
  20 |     | <span class='neutral'>        MIN,</span>
  21 |     | <span class='neutral'>        MAX,</span>
  22 |     | <span class='neutral'>        MEAN,</span>
  23 |     | <span class='neutral'>        MEDIAN,</span>
  24 |     | <span class='neutral'>        MUL,</span>
  25 |     | <span class='neutral'>        DIV,</span>
  26 |     | <span class='neutral'>        MULDECIMAL,</span>
  27 |     | <span class='neutral'>        DIVDECIMAL</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function process(</span>
  31 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs,</span>
  32 |     | <span class='neutral'>        bytes memory parameters</span>
  33 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory nodeOutput) {</span>
  34 |     | <span class='neutral'>        Operations operation = abi.decode(parameters, (Operations));</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        if (operation == Operations.RECENT) {</span>
  37 |     | <span class='neutral'>            return recent(parentNodeOutputs);</span>
  38 |     | <span class='neutral'>        }</span>
  39 |     | <span class='neutral'>        if (operation == Operations.MIN) {</span>
  40 |     | <span class='neutral'>            return min(parentNodeOutputs);</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>        if (operation == Operations.MAX) {</span>
  43 |     | <span class='neutral'>            return max(parentNodeOutputs);</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'>        if (operation == Operations.MEAN) {</span>
  46 |     | <span class='neutral'>            return mean(parentNodeOutputs);</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='neutral'>        if (operation == Operations.MEDIAN) {</span>
  49 |     | <span class='neutral'>            return median(parentNodeOutputs);</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'>        if (operation == Operations.MUL) {</span>
  52 |     | <span class='neutral'>            return mul(parentNodeOutputs);</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'>        if (operation == Operations.DIV) {</span>
  55 |     | <span class='neutral'>            return div(parentNodeOutputs);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>        if (operation == Operations.MULDECIMAL) {</span>
  58 |     | <span class='neutral'>            return mulDecimal(parentNodeOutputs);</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'>        if (operation == Operations.DIVDECIMAL) {</span>
  61 |     | <span class='neutral'>            return divDecimal(parentNodeOutputs);</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        revert UnsupportedOperation(operation);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function median(</span>
  68 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
  69 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory medianPrice) {</span>
  70 |     | <span class='neutral'>        quickSort(parentNodeOutputs, SafeCastI256.zero(), (parentNodeOutputs.length - 1).toInt());</span>
  71 |     | <span class='neutral'>        if (parentNodeOutputs.length % 2 == 0) {</span>
  72 |     | <span class='neutral'>            NodeOutput.Data[] memory middleSet = new NodeOutput.Data[](2);</span>
  73 |     | <span class='neutral'>            middleSet[0] = parentNodeOutputs[(parentNodeOutputs.length / 2) - 1];</span>
  74 |     | <span class='neutral'>            middleSet[1] = parentNodeOutputs[(parentNodeOutputs.length / 2)];</span>
  75 |     | <span class='neutral'>            return mean(middleSet);</span>
  76 |     | <span class='neutral'>        } else {</span>
  77 |     | <span class='neutral'>            return parentNodeOutputs[parentNodeOutputs.length / 2];</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function mean(</span>
  82 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
  83 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory meanPrice) {</span>
  84 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; parentNodeOutputs.length; i++) {</span>
  85 |     | <span class='neutral'>            meanPrice.price += parentNodeOutputs[i].price;</span>
  86 |     | <span class='neutral'>            meanPrice.timestamp += parentNodeOutputs[i].timestamp;</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        meanPrice.price = meanPrice.price / parentNodeOutputs.length.toInt();</span>
  90 |     | <span class='neutral'>        meanPrice.timestamp = meanPrice.timestamp / parentNodeOutputs.length;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function recent(</span>
  94 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
  95 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory recentPrice) {</span>
  96 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; parentNodeOutputs.length; i++) {</span>
  97 |     | <span class='neutral'>            if (parentNodeOutputs[i].timestamp &gt; recentPrice.timestamp) {</span>
  98 |     | <span class='neutral'>                recentPrice = parentNodeOutputs[i];</span>
  99 |     | <span class='neutral'>            }</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function max(</span>
 104 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
 105 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory maxPrice) {</span>
 106 |     | <span class='neutral'>        maxPrice = parentNodeOutputs[0];</span>
 107 |     | <span class='neutral'>        for (uint256 i = 1; i &lt; parentNodeOutputs.length; i++) {</span>
 108 |     | <span class='neutral'>            if (parentNodeOutputs[i].price &gt; maxPrice.price) {</span>
 109 |     | <span class='neutral'>                maxPrice = parentNodeOutputs[i];</span>
 110 |     | <span class='neutral'>            }</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function min(</span>
 115 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
 116 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory minPrice) {</span>
 117 |     | <span class='neutral'>        minPrice = parentNodeOutputs[0];</span>
 118 |     | <span class='neutral'>        for (uint256 i = 1; i &lt; parentNodeOutputs.length; i++) {</span>
 119 |     | <span class='neutral'>            if (parentNodeOutputs[i].price &lt; minPrice.price) {</span>
 120 |     | <span class='neutral'>                minPrice = parentNodeOutputs[i];</span>
 121 |     | <span class='neutral'>            }</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function mul(</span>
 126 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
 127 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory mulPrice) {</span>
 128 |     | <span class='neutral'>        mulPrice.price = parentNodeOutputs[0].price;</span>
 129 |     | <span class='neutral'>        mulPrice.timestamp = parentNodeOutputs[0].timestamp;</span>
 130 |     | <span class='neutral'>        for (uint256 i = 1; i &lt; parentNodeOutputs.length; i++) {</span>
 131 |     | <span class='neutral'>            mulPrice.price *= parentNodeOutputs[i].price;</span>
 132 |     | <span class='neutral'>            mulPrice.timestamp += parentNodeOutputs[i].timestamp;</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'>        mulPrice.timestamp = mulPrice.timestamp / parentNodeOutputs.length;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    function div(</span>
 138 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
 139 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory divPrice) {</span>
 140 |     | <span class='neutral'>        divPrice.price = parentNodeOutputs[0].price;</span>
 141 |     | <span class='neutral'>        divPrice.timestamp = parentNodeOutputs[0].timestamp;</span>
 142 |     | <span class='neutral'>        for (uint256 i = 1; i &lt; parentNodeOutputs.length; i++) {</span>
 143 |     | <span class='neutral'>            if (parentNodeOutputs[i].price == 0) {</span>
 144 |     | <span class='neutral'>                revert InvalidPrice(parentNodeOutputs[i].price);</span>
 145 |     | <span class='neutral'>            }</span>
 146 |     | <span class='neutral'>            divPrice.price /= parentNodeOutputs[i].price;</span>
 147 |     | <span class='neutral'>            divPrice.timestamp += parentNodeOutputs[i].timestamp;</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='neutral'>        divPrice.timestamp = divPrice.timestamp / parentNodeOutputs.length;</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function mulDecimal(</span>
 153 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
 154 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory mulPrice) {</span>
 155 |     | <span class='neutral'>        mulPrice.price = parentNodeOutputs[0].price;</span>
 156 |     | <span class='neutral'>        mulPrice.timestamp = parentNodeOutputs[0].timestamp;</span>
 157 |     | <span class='neutral'>        for (uint256 i = 1; i &lt; parentNodeOutputs.length; i++) {</span>
 158 |     | <span class='neutral'>            mulPrice.price = mulPrice.price.mulDecimal(parentNodeOutputs[i].price);</span>
 159 |     | <span class='neutral'>            mulPrice.timestamp += parentNodeOutputs[i].timestamp;</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>        mulPrice.timestamp = mulPrice.timestamp / parentNodeOutputs.length;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function divDecimal(</span>
 165 |     | <span class='neutral'>        NodeOutput.Data[] memory parentNodeOutputs</span>
 166 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory divPrice) {</span>
 167 |     | <span class='neutral'>        divPrice.price = parentNodeOutputs[0].price;</span>
 168 |     | <span class='neutral'>        divPrice.timestamp = parentNodeOutputs[0].timestamp;</span>
 169 |     | <span class='neutral'>        for (uint256 i = 1; i &lt; parentNodeOutputs.length; i++) {</span>
 170 |     | <span class='neutral'>            if (parentNodeOutputs[i].price == 0) {</span>
 171 |     | <span class='neutral'>                revert InvalidPrice(parentNodeOutputs[i].price);</span>
 172 |     | <span class='neutral'>            }</span>
 173 |     | <span class='neutral'>            divPrice.price = divPrice.price.divDecimal(parentNodeOutputs[i].price);</span>
 174 |     | <span class='neutral'>            divPrice.timestamp += parentNodeOutputs[i].timestamp;</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'>        divPrice.timestamp = divPrice.timestamp / parentNodeOutputs.length;</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    function quickSort(NodeOutput.Data[] memory arr, int256 left, int256 right) internal pure {</span>
 180 |     | <span class='neutral'>        int256 i = left;</span>
 181 |     | <span class='neutral'>        int256 j = right;</span>
 182 |     | <span class='neutral'>        if (i == j) return;</span>
 183 |     | <span class='neutral'>        int256 pivot = arr[(left + (right - left) / 2).toUint()].price;</span>
 184 |     | <span class='neutral'>        while (i &lt;= j) {</span>
 185 |     | <span class='neutral'>            while (arr[i.toUint()].price &lt; pivot) i++;</span>
 186 |     | <span class='neutral'>            while (pivot &lt; arr[j.toUint()].price) j--;</span>
 187 |     | <span class='neutral'>            if (i &lt;= j) {</span>
 188 |     | <span class='neutral'>                (arr[i.toUint()], arr[j.toUint()]) = (arr[j.toUint()], arr[i.toUint()]);</span>
 189 |     | <span class='neutral'>                i++;</span>
 190 |     | <span class='neutral'>                j--;</span>
 191 |     | <span class='neutral'>            }</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'>        if (left &lt; j) quickSort(arr, left, j);</span>
 194 |     | <span class='neutral'>        if (i &lt; right) quickSort(arr, i, right);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {</span>
 198 |     | <span class='neutral'>        // Must have at least 2 parents</span>
 199 |     | <span class='neutral'>        if (nodeDefinition.parents.length &lt; 2) {</span>
 200 |     | <span class='neutral'>            return false;</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
 204 |     | <span class='neutral'>        if (nodeDefinition.parameters.length != 32) {</span>
 205 |     | <span class='neutral'>            return false;</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        // Must have valid operation</span>
 209 |     | <span class='neutral'>        uint256 operationId = abi.decode(nodeDefinition.parameters, (uint256));</span>
 210 |     | <span class='neutral'>        if (operationId &gt; 8) {</span>
 211 |     | <span class='neutral'>            return false;</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>        return true;</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'>}</span>
 217 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/StalenessCircuitBreakerNode.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {SafeCastBytes32} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  5 |     | <span class='neutral'>import {NodeDefinition} from &quot;../storage/NodeDefinition.sol&quot;;</span>
  6 |     | <span class='neutral'>import {NodeOutput} from &quot;../storage/NodeOutput.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library StalenessCircuitBreakerNode {</span>
  9 |     | <span class='neutral'>    using SafeCastBytes32 for bytes32;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    error StalenessToleranceExceeded();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function process(</span>
 14 |     | <span class='neutral'>        NodeDefinition.Data memory nodeDefinition,</span>
 15 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 16 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 17 |     | <span class='neutral'>    ) internal view returns (NodeOutput.Data memory nodeOutput) {</span>
 18 |     | <span class='neutral'>        uint256 stalenessTolerance = abi.decode(nodeDefinition.parameters, (uint256));</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; runtimeKeys.length; i++) {</span>
 21 |     | <span class='neutral'>            if (runtimeKeys[i] == &quot;stalenessTolerance&quot;) {</span>
 22 |     | <span class='neutral'>                stalenessTolerance = runtimeValues[i].toUint();</span>
 23 |     | <span class='neutral'>                break;</span>
 24 |     | <span class='neutral'>            }</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        bytes32 priceNodeId = nodeDefinition.parents[0];</span>
 28 |     | <span class='neutral'>        NodeOutput.Data memory priceNodeOutput = NodeDefinition.process(</span>
 29 |     | <span class='neutral'>            priceNodeId,</span>
 30 |     | <span class='neutral'>            runtimeKeys,</span>
 31 |     | <span class='neutral'>            runtimeValues</span>
 32 |     | <span class='neutral'>        );</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        if (block.timestamp - priceNodeOutput.timestamp &lt;= stalenessTolerance) {</span>
 35 |     | <span class='neutral'>            return priceNodeOutput;</span>
 36 |     | <span class='neutral'>        } else if (nodeDefinition.parents.length == 1) {</span>
 37 |     | <span class='neutral'>            revert StalenessToleranceExceeded();</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>        // If there are two parents, return the output of the second parent (which in this case, should revert with OracleDataRequired)</span>
 40 |     | <span class='neutral'>        return NodeDefinition.process(nodeDefinition.parents[1], runtimeKeys, runtimeValues);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {</span>
 44 |     | <span class='neutral'>        // Must have 1-2 parents</span>
 45 |     | <span class='neutral'>        if (!(nodeDefinition.parents.length == 1 || nodeDefinition.parents.length == 2)) {</span>
 46 |     | <span class='neutral'>            return false;</span>
 47 |     | <span class='neutral'>        }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
 50 |     | <span class='neutral'>        if (nodeDefinition.parameters.length != 32) {</span>
 51 |     | <span class='neutral'>            return false;</span>
 52 |     | <span class='neutral'>        }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>        return true;</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/UniswapNode.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/interfaces/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &quot;../utils/FullMath.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../utils/TickMath.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>import &quot;../storage/NodeDefinition.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../storage/NodeOutput.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;../interfaces/external/IUniswapV3Pool.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>library UniswapNode {</span>
  16 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  17 |     | <span class='neutral'>    using SafeCastU160 for uint160;</span>
  18 |     | <span class='neutral'>    using SafeCastU56 for uint56;</span>
  19 |     | <span class='neutral'>    using SafeCastU32 for uint32;</span>
  20 |     | <span class='neutral'>    using SafeCastI56 for int56;</span>
  21 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    uint8 public constant PRECISION = 18;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function process(</span>
  28 |     | <span class='neutral'>        bytes memory parameters</span>
  29 |     | <span class='neutral'>    ) internal view returns (NodeOutput.Data memory nodeOutput) {</span>
  30 |     | <span class='neutral'>        (</span>
  31 |     | <span class='neutral'>            address token,</span>
  32 |     | <span class='neutral'>            address stablecoin,</span>
  33 |     | <span class='neutral'>            uint8 decimalsToken,</span>
  34 |     | <span class='neutral'>            uint8 decimalsStablecoin,</span>
  35 |     | <span class='neutral'>            address pool,</span>
  36 |     | <span class='neutral'>            uint32 secondsAgo</span>
  37 |     | <span class='neutral'>        ) = abi.decode(parameters, (address, address, uint8, uint8, address, uint32));</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        uint32[] memory secondsAgos = new uint32[](2);</span>
  40 |     | <span class='neutral'>        secondsAgos[0] = secondsAgo;</span>
  41 |     | <span class='neutral'>        secondsAgos[1] = 0;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondsAgos);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        int24 tick = (tickCumulativesDelta / secondsAgo.to56().toInt()).to24();</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        if (tickCumulativesDelta &lt; 0 &amp;&amp; (tickCumulativesDelta % secondsAgo.to256().toInt() != 0)) {</span>
  50 |     | <span class='neutral'>            tick--;</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>        uint256 baseAmount = 10 ** PRECISION;</span>
  54 |     | <span class='neutral'>        int256 price = getQuoteAtTick(tick, baseAmount, token, stablecoin).toInt();</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
  57 |     | <span class='neutral'>        int256 scale = uint256(decimalsToken).toInt() - uint256(decimalsStablecoin).toInt();</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        int256 finalPrice = scale &gt; 0</span>
  60 |     | <span class='neutral'>            ? price.upscale(scale.toUint())</span>
  61 |     | <span class='neutral'>            : price.downscale((-scale).toUint());</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        return NodeOutput.Data(finalPrice, block.timestamp, 0, 0);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function getQuoteAtTick(</span>
  67 |     | <span class='neutral'>        int24 tick,</span>
  68 |     | <span class='neutral'>        uint256 baseAmount,</span>
  69 |     | <span class='neutral'>        address baseToken,</span>
  70 |     | <span class='neutral'>        address quoteToken</span>
  71 |     | <span class='neutral'>    ) internal pure returns (uint256 quoteAmount) {</span>
  72 |     | <span class='neutral'>        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // Calculate quoteAmount with better precision if it doesn&#39;t overflow when multiplied by itself</span>
  75 |     | <span class='neutral'>        if (sqrtRatioX96 &lt;= type(uint128).max) {</span>
  76 |     | <span class='neutral'>            uint256 ratioX192 = sqrtRatioX96.to256() * sqrtRatioX96;</span>
  77 |     | <span class='neutral'>            quoteAmount = baseToken &lt; quoteToken</span>
  78 |     | <span class='neutral'>                ? FullMath.mulDiv(ratioX192, baseAmount, 1 &lt;&lt; 192)</span>
  79 |     | <span class='neutral'>                : FullMath.mulDiv(1 &lt;&lt; 192, baseAmount, ratioX192);</span>
  80 |     | <span class='neutral'>        } else {</span>
  81 |     | <span class='neutral'>            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 &lt;&lt; 64);</span>
  82 |     | <span class='neutral'>            quoteAmount = baseToken &lt; quoteToken</span>
  83 |     | <span class='neutral'>                ? FullMath.mulDiv(ratioX128, baseAmount, 1 &lt;&lt; 128)</span>
  84 |     | <span class='neutral'>                : FullMath.mulDiv(1 &lt;&lt; 128, baseAmount, ratioX128);</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal view returns (bool valid) {</span>
  89 |     | <span class='neutral'>        // Must have no parents</span>
  90 |     | <span class='neutral'>        if (nodeDefinition.parents.length &gt; 0) {</span>
  91 |     | <span class='neutral'>            return false;</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
  95 |     | <span class='neutral'>        if (nodeDefinition.parameters.length != 192) {</span>
  96 |     | <span class='neutral'>            return false;</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        (</span>
 100 |     | <span class='neutral'>            address token,</span>
 101 |     | <span class='neutral'>            address stablecoin,</span>
 102 |     | <span class='neutral'>            uint8 decimalsToken,</span>
 103 |     | <span class='neutral'>            uint8 decimalsStablecoin,</span>
 104 |     | <span class='neutral'>            address pool,</span>
 105 |     | <span class='neutral'>            uint32 secondsAgo</span>
 106 |     | <span class='neutral'>        ) = abi.decode(</span>
 107 |     | <span class='neutral'>                nodeDefinition.parameters,</span>
 108 |     | <span class='neutral'>                (address, address, uint8, uint8, address, uint32)</span>
 109 |     | <span class='neutral'>            );</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>        if (IERC20(token).decimals() != decimalsToken) {</span>
 112 |     | <span class='neutral'>            return false;</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        if (IERC20(stablecoin).decimals() != decimalsStablecoin) {</span>
 116 |     | <span class='neutral'>            return false;</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        address poolToken0 = IUniswapV3Pool(pool).token0();</span>
 120 |     | <span class='neutral'>        address poolToken1 = IUniswapV3Pool(pool).token1();</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        if (</span>
 123 |     | <span class='neutral'>            !(poolToken0 == token &amp;&amp; poolToken1 == stablecoin) &amp;&amp;</span>
 124 |     | <span class='neutral'>            !(poolToken0 == stablecoin &amp;&amp; poolToken1 == token)</span>
 125 |     | <span class='neutral'>        ) {</span>
 126 |     | <span class='neutral'>            return false;</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        if (decimalsToken &gt; 18 || decimalsStablecoin &gt; 18) {</span>
 130 |     | <span class='neutral'>            return false;</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        if (secondsAgo == 0) {</span>
 134 |     | <span class='neutral'>            return false;</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>        // Must call relevant function without error</span>
 138 |     | <span class='neutral'>        uint32[] memory secondsAgos = new uint32[](2);</span>
 139 |     | <span class='neutral'>        secondsAgos[0] = secondsAgo;</span>
 140 |     | <span class='neutral'>        secondsAgos[1] = 0;</span>
 141 |     | <span class='neutral'>        IUniswapV3Pool(pool).observe(secondsAgos);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        return true;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/pyth/PythNode.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;../../storage/NodeDefinition.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../../storage/NodeOutput.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../interfaces/external/IPyth.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>library PythNode {</span>
 12 |     | <span class='neutral'>    using DecimalMath for int64;</span>
 13 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    int256 public constant PRECISION = 18;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function process(</span>
 18 |     | <span class='neutral'>        bytes memory parameters</span>
 19 |     | <span class='neutral'>    ) internal view returns (NodeOutput.Data memory nodeOutput) {</span>
 20 |     | <span class='neutral'>        (address pythAddress, bytes32 priceFeedId, bool useEma) = abi.decode(</span>
 21 |     | <span class='neutral'>            parameters,</span>
 22 |     | <span class='neutral'>            (address, bytes32, bool)</span>
 23 |     | <span class='neutral'>        );</span>
 24 |     | <span class='neutral'>        IPyth pyth = IPyth(pythAddress);</span>
 25 |     | <span class='neutral'>        PythStructs.Price memory pythData = useEma</span>
 26 |     | <span class='neutral'>            ? pyth.getEmaPriceUnsafe(priceFeedId)</span>
 27 |     | <span class='neutral'>            : pyth.getPriceUnsafe(priceFeedId);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>        int256 factor = PRECISION + pythData.expo;</span>
 30 |     | <span class='neutral'>        int256 price = factor &gt; 0</span>
 31 |     | <span class='neutral'>            ? pythData.price.upscale(factor.toUint())</span>
 32 |     | <span class='neutral'>            : pythData.price.downscale((-factor).toUint());</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        return NodeOutput.Data(price, pythData.publishTime, 0, 0);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal view returns (bool valid) {</span>
 38 |     | <span class='neutral'>        // Must have no parents</span>
 39 |     | <span class='neutral'>        if (nodeDefinition.parents.length &gt; 0) {</span>
 40 |     | <span class='neutral'>            return false;</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
 44 |     | <span class='neutral'>        if (nodeDefinition.parameters.length != 32 * 3) {</span>
 45 |     | <span class='neutral'>            return false;</span>
 46 |     | <span class='neutral'>        }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>        (address pythAddress, bytes32 priceFeedId, bool useEma) = abi.decode(</span>
 49 |     | <span class='neutral'>            nodeDefinition.parameters,</span>
 50 |     | <span class='neutral'>            (address, bytes32, bool)</span>
 51 |     | <span class='neutral'>        );</span>
 52 |     | <span class='neutral'>        IPyth pyth = IPyth(pythAddress);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>        // Must return relevant function without error</span>
 55 |     | <span class='neutral'>        useEma ? pyth.getEmaPriceUnsafe(priceFeedId) : pyth.getPriceUnsafe(priceFeedId);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>        return true;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/pyth/PythOffchainLookupNode.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;../../storage/NodeDefinition.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../../storage/NodeOutput.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>library PythOffchainLookupNode {</span>
 11 |     | <span class='neutral'>    using DecimalMath for int64;</span>
 12 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    error OracleDataRequired(address oracleContract, bytes oracleQuery);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    int256 public constant PRECISION = 18;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function process(</span>
 19 |     | <span class='neutral'>        bytes memory parameters,</span>
 20 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 21 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 22 |     | <span class='neutral'>    ) internal pure returns (NodeOutput.Data memory) {</span>
 23 |     | <span class='neutral'>        (address pythAddress, bytes32 priceId, uint256 stalenessTolerance) = abi.decode(</span>
 24 |     | <span class='neutral'>            parameters,</span>
 25 |     | <span class='neutral'>            (address, bytes32, uint256)</span>
 26 |     | <span class='neutral'>        );</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; runtimeKeys.length; i++) {</span>
 29 |     | <span class='neutral'>            if (runtimeKeys[i] == &quot;stalenessTolerance&quot;) {</span>
 30 |     | <span class='neutral'>                // solhint-disable-next-line numcast/safe-cast</span>
 31 |     | <span class='neutral'>                stalenessTolerance = uint256(runtimeValues[i]);</span>
 32 |     | <span class='neutral'>            }</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>        bytes32[] memory priceIds = new bytes32[](1);</span>
 36 |     | <span class='neutral'>        priceIds[0] = priceId;</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>        // In the future Pyth revert data will have the following</span>
 39 |     | <span class='neutral'>        // Query schema:</span>
 40 |     | <span class='neutral'>        //</span>
 41 |     | <span class='neutral'>        // Enum PythQuery {</span>
 42 |     | <span class='neutral'>        //  Latest = 0 {</span>
 43 |     | <span class='neutral'>        //    bytes32[] priceIds,</span>
 44 |     | <span class='neutral'>        //  },</span>
 45 |     | <span class='neutral'>        //  NoOlderThan = 1 {</span>
 46 |     | <span class='neutral'>        //    uint64 stalenessTolerance,</span>
 47 |     | <span class='neutral'>        //    bytes32[] priceIds,</span>
 48 |     | <span class='neutral'>        //  },</span>
 49 |     | <span class='neutral'>        //  Benchmark = 2 {</span>
 50 |     | <span class='neutral'>        //    uint64 publishTime,</span>
 51 |     | <span class='neutral'>        //    bytes32[] priceIds,</span>
 52 |     | <span class='neutral'>        //  }</span>
 53 |     | <span class='neutral'>        // }</span>
 54 |     | <span class='neutral'>        //</span>
 55 |     | <span class='neutral'>        // This contract only implements the PythQuery::NoOlderThan</span>
 56 |     | <span class='neutral'>        revert OracleDataRequired(</span>
 57 |     | <span class='neutral'>            pythAddress,</span>
 58 |     | <span class='neutral'>            abi.encode(</span>
 59 |     | <span class='neutral'>                // solhint-disable-next-line numcast/safe-cast</span>
 60 |     | <span class='neutral'>                uint8(1), // PythQuery::NoOlderThan tag</span>
 61 |     | <span class='neutral'>                // solhint-disable-next-line numcast/safe-cast</span>
 62 |     | <span class='neutral'>                uint64(stalenessTolerance),</span>
 63 |     | <span class='neutral'>                priceIds</span>
 64 |     | <span class='neutral'>            )</span>
 65 |     | <span class='neutral'>        );</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {</span>
 69 |     | <span class='neutral'>        // Must have no parents</span>
 70 |     | <span class='neutral'>        if (nodeDefinition.parents.length &gt; 0) {</span>
 71 |     | <span class='neutral'>            return false;</span>
 72 |     | <span class='neutral'>        }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>        // Must have correct length of parameters data</span>
 75 |     | <span class='neutral'>        if (nodeDefinition.parameters.length != 32 * 3) {</span>
 76 |     | <span class='neutral'>            return false;</span>
 77 |     | <span class='neutral'>        }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>        abi.decode(nodeDefinition.parameters, (address, bytes32, uint256));</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='neutral'>        return true;</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/storage/NodeDefinition.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ParameterError} from &quot;@synthetixio/core-contracts/contracts/errors/ParameterError.sol&quot;;</span>
   5 |     | <span class='neutral'>import {NodeOutput} from &quot;./NodeOutput.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;../nodes/ReducerNode.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../nodes/ExternalNode.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../nodes/pyth/PythNode.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../nodes/pyth/PythOffchainLookupNode.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../nodes/ChainlinkNode.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../nodes/PriceDeviationCircuitBreakerNode.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;../nodes/StalenessCircuitBreakerNode.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;../nodes/UniswapNode.sol&quot;;</span>
  15 |     | <span class='neutral'>import &quot;../nodes/ConstantNode.sol&quot;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>library NodeDefinition {</span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @notice Thrown when a node cannot be processed</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='neutral'>    error UnprocessableNode(bytes32 nodeId);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    enum NodeType {</span>
  24 |     | <span class='neutral'>        NONE,</span>
  25 |     | <span class='neutral'>        REDUCER,</span>
  26 |     | <span class='neutral'>        EXTERNAL,</span>
  27 |     | <span class='neutral'>        CHAINLINK,</span>
  28 |     | <span class='neutral'>        UNISWAP,</span>
  29 |     | <span class='neutral'>        PYTH,</span>
  30 |     | <span class='neutral'>        PRICE_DEVIATION_CIRCUIT_BREAKER,</span>
  31 |     | <span class='neutral'>        STALENESS_CIRCUIT_BREAKER,</span>
  32 |     | <span class='neutral'>        CONSTANT,</span>
  33 |     | <span class='neutral'>        PYTH_OFFCHAIN_LOOKUP // works in conjunction with PYTH node</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    struct Data {</span>
  37 |     | <span class='neutral'>        /**</span>
  38 |     | <span class='neutral'>         * @dev Oracle node type enum</span>
  39 |     | <span class='neutral'>         */</span>
  40 |     | <span class='neutral'>        NodeType nodeType;</span>
  41 |     | <span class='neutral'>        /**</span>
  42 |     | <span class='neutral'>         * @dev Node parameters, specific to each node type</span>
  43 |     | <span class='neutral'>         */</span>
  44 |     | <span class='neutral'>        bytes parameters;</span>
  45 |     | <span class='neutral'>        /**</span>
  46 |     | <span class='neutral'>         * @dev Parent node IDs, if any</span>
  47 |     | <span class='neutral'>         */</span>
  48 |     | <span class='neutral'>        bytes32[] parents;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @dev Returns the node stored at the specified node ID.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function load(bytes32 id) internal pure returns (Data storage node) {</span>
  55 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.oracle-manager.Node&quot;, id));</span>
  56 |     | <span class='neutral'>        assembly {</span>
  57 |     | <span class='neutral'>            node.slot := s</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @dev Register a new node for a given node definition. The resulting node is a function of the definition.</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function create(</span>
  65 |     | <span class='neutral'>        Data memory nodeDefinition</span>
  66 |     | <span class='neutral'>    ) internal returns (NodeDefinition.Data storage node, bytes32 id) {</span>
  67 |     | <span class='neutral'>        id = getId(nodeDefinition);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        node = load(id);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        node.nodeType = nodeDefinition.nodeType;</span>
  72 |     | <span class='neutral'>        node.parameters = nodeDefinition.parameters;</span>
  73 |     | <span class='neutral'>        node.parents = nodeDefinition.parents;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev Returns a node ID based on its definition</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='neutral'>    function getId(Data memory nodeDefinition) internal pure returns (bytes32 id) {</span>
  80 |     | <span class='neutral'>        return</span>
  81 |     | <span class='neutral'>            keccak256(</span>
  82 |     | <span class='neutral'>                abi.encode(</span>
  83 |     | <span class='neutral'>                    nodeDefinition.nodeType,</span>
  84 |     | <span class='neutral'>                    nodeDefinition.parameters,</span>
  85 |     | <span class='neutral'>                    nodeDefinition.parents</span>
  86 |     | <span class='neutral'>                )</span>
  87 |     | <span class='neutral'>            );</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Returns the output of a specified node.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function process(</span>
  94 |     | <span class='neutral'>        bytes32 nodeId,</span>
  95 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
  96 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
  97 |     | <span class='neutral'>    ) internal view returns (NodeOutput.Data memory price) {</span>
  98 |     | <span class='neutral'>        if (runtimeKeys.length != runtimeValues.length) {</span>
  99 |     | <span class='neutral'>            revert ParameterError.InvalidParameter(</span>
 100 |     | <span class='neutral'>                &quot;runtimeValues&quot;,</span>
 101 |     | <span class='neutral'>                &quot;must be same length as runtimeKeys&quot;</span>
 102 |     | <span class='neutral'>            );</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        Data storage nodeDefinition = load(nodeId);</span>
 106 |     | <span class='neutral'>        NodeType nodeType = nodeDefinition.nodeType;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        if (nodeType == NodeType.REDUCER) {</span>
 109 |     | <span class='neutral'>            return</span>
 110 |     | <span class='neutral'>                ReducerNode.process(</span>
 111 |     | <span class='neutral'>                    _processParentNodeOutputs(nodeDefinition, runtimeKeys, runtimeValues),</span>
 112 |     | <span class='neutral'>                    nodeDefinition.parameters</span>
 113 |     | <span class='neutral'>                );</span>
 114 |     | <span class='neutral'>        } else if (nodeType == NodeType.EXTERNAL) {</span>
 115 |     | <span class='neutral'>            return</span>
 116 |     | <span class='neutral'>                ExternalNode.process(</span>
 117 |     | <span class='neutral'>                    _processParentNodeOutputs(nodeDefinition, runtimeKeys, runtimeValues),</span>
 118 |     | <span class='neutral'>                    nodeDefinition.parameters,</span>
 119 |     | <span class='neutral'>                    runtimeKeys,</span>
 120 |     | <span class='neutral'>                    runtimeValues</span>
 121 |     | <span class='neutral'>                );</span>
 122 |     | <span class='neutral'>        } else if (nodeType == NodeType.CHAINLINK) {</span>
 123 |     | <span class='neutral'>            return ChainlinkNode.process(nodeDefinition.parameters);</span>
 124 |     | <span class='neutral'>        } else if (nodeType == NodeType.UNISWAP) {</span>
 125 |     | <span class='neutral'>            return UniswapNode.process(nodeDefinition.parameters);</span>
 126 |     | <span class='neutral'>        } else if (nodeType == NodeType.PYTH) {</span>
 127 |     | <span class='neutral'>            return PythNode.process(nodeDefinition.parameters);</span>
 128 |     | <span class='neutral'>        } else if (nodeType == NodeType.PYTH_OFFCHAIN_LOOKUP) {</span>
 129 |     | <span class='neutral'>            return</span>
 130 |     | <span class='neutral'>                PythOffchainLookupNode.process(</span>
 131 |     | <span class='neutral'>                    nodeDefinition.parameters,</span>
 132 |     | <span class='neutral'>                    runtimeKeys,</span>
 133 |     | <span class='neutral'>                    runtimeValues</span>
 134 |     | <span class='neutral'>                );</span>
 135 |     | <span class='neutral'>        } else if (nodeType == NodeType.PRICE_DEVIATION_CIRCUIT_BREAKER) {</span>
 136 |     | <span class='neutral'>            return</span>
 137 |     | <span class='neutral'>                PriceDeviationCircuitBreakerNode.process(</span>
 138 |     | <span class='neutral'>                    _processParentNodeOutputs(nodeDefinition, runtimeKeys, runtimeValues),</span>
 139 |     | <span class='neutral'>                    nodeDefinition.parameters</span>
 140 |     | <span class='neutral'>                );</span>
 141 |     | <span class='neutral'>        } else if (nodeType == NodeType.STALENESS_CIRCUIT_BREAKER) {</span>
 142 |     | <span class='neutral'>            return StalenessCircuitBreakerNode.process(nodeDefinition, runtimeKeys, runtimeValues);</span>
 143 |     | <span class='neutral'>        } else if (nodeType == NodeType.CONSTANT) {</span>
 144 |     | <span class='neutral'>            return ConstantNode.process(nodeDefinition.parameters);</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>        revert UnprocessableNode(nodeId);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev helper function that calls process on parent nodes.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    function _processParentNodeOutputs(</span>
 153 |     | <span class='neutral'>        Data storage nodeDefinition,</span>
 154 |     | <span class='neutral'>        bytes32[] memory runtimeKeys,</span>
 155 |     | <span class='neutral'>        bytes32[] memory runtimeValues</span>
 156 |     | <span class='neutral'>    ) private view returns (NodeOutput.Data[] memory parentNodeOutputs) {</span>
 157 |     | <span class='neutral'>        parentNodeOutputs = new NodeOutput.Data[](nodeDefinition.parents.length);</span>
 158 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; nodeDefinition.parents.length; i++) {</span>
 159 |     | <span class='neutral'>            parentNodeOutputs[i] = process(nodeDefinition.parents[i], runtimeKeys, runtimeValues);</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'>}</span>
 163 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library NodeOutput {</span>
  5 |     | <span class='neutral'>    struct Data {</span>
  6 |     | <span class='neutral'>        /**</span>
  7 |     | <span class='neutral'>         * @dev Price returned from the oracle node, expressed with 18 decimals of precision</span>
  8 |     | <span class='neutral'>         */</span>
  9 |     | <span class='neutral'>        int256 price;</span>
 10 |     | <span class='neutral'>        /**</span>
 11 |     | <span class='neutral'>         * @dev Timestamp associated with the price</span>
 12 |     | <span class='neutral'>         */</span>
 13 |     | <span class='neutral'>        uint256 timestamp;</span>
 14 |     | <span class='neutral'>        // solhint-disable-next-line private-vars-leading-underscore</span>
 15 |     | <span class='neutral'>        uint256 __slotAvailableForFutureUse1;</span>
 16 |     | <span class='neutral'>        // solhint-disable-next-line private-vars-leading-underscore</span>
 17 |     | <span class='neutral'>        uint256 __slotAvailableForFutureUse2;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/utils/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title Contains 512-bit math functions</span>
   7 |     | <span class='neutral'>/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision</span>
   8 |     | <span class='neutral'>/// @dev Handles &quot;phantom overflow&quot; i.e., allows multiplication and division where an intermediate value overflows 256 bits</span>
   9 |     | <span class='unexecuted'>library FullMath {</span>
  10 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  11 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  14 |     | <span class='neutral'>    /// @param a The multiplicand</span>
  15 |     | <span class='neutral'>    /// @param b The multiplier</span>
  16 |     | <span class='neutral'>    /// @param denominator The divisor</span>
  17 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
  18 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
  19 |     | <span class='neutral'>    function mulDiv(</span>
  20 |     | <span class='neutral'>        uint256 a,</span>
  21 |     | <span class='neutral'>        uint256 b,</span>
  22 |     | <span class='neutral'>        uint256 denominator</span>
  23 |     | <span class='neutral'>    ) internal pure returns (uint256 result) {</span>
  24 |     | <span class='neutral'>        // 512-bit multiply [prod1 prod0] = a * b</span>
  25 |     | <span class='neutral'>        // Compute the product mod 2**256 and mod 2**256 - 1</span>
  26 |     | <span class='neutral'>        // then use the Chinese Remainder Theorem to reconstruct</span>
  27 |     | <span class='neutral'>        // the 512 bit result. The result is stored in two 256</span>
  28 |     | <span class='neutral'>        // variables such that product = prod1 * 2**256 + prod0</span>
  29 |     | <span class='neutral'>        uint256 prod0; // Least significant 256 bits of the product</span>
  30 |     | <span class='neutral'>        uint256 prod1; // Most significant 256 bits of the product</span>
  31 |     | <span class='neutral'>        assembly {</span>
  32 |     | <span class='neutral'>            let mm := mulmod(a, b, not(0))</span>
  33 |     | <span class='neutral'>            prod0 := mul(a, b)</span>
  34 |     | <span class='neutral'>            prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  35 |     | <span class='neutral'>        }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        // Handle non-overflow cases, 256 by 256 division</span>
  38 |     | <span class='neutral'>        if (prod1 == 0) {</span>
  39 |     | <span class='neutral'>            require(denominator &gt; 0, &quot;Handle non-overflow cases&quot;);</span>
  40 |     | <span class='neutral'>            assembly {</span>
  41 |     | <span class='neutral'>                result := div(prod0, denominator)</span>
  42 |     | <span class='neutral'>            }</span>
  43 |     | <span class='neutral'>            return result;</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // Make sure the result is less than 2**256.</span>
  47 |     | <span class='neutral'>        // Also prevents denominator == 0</span>
  48 |     | <span class='neutral'>        require(denominator &gt; prod1, &quot;prevents denominator == 0&quot;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  51 |     | <span class='neutral'>        // 512 by 256 division.</span>
  52 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // Make division exact by subtracting the remainder from [prod1 prod0]</span>
  55 |     | <span class='neutral'>        // Compute remainder using mulmod</span>
  56 |     | <span class='neutral'>        uint256 remainder;</span>
  57 |     | <span class='neutral'>        assembly {</span>
  58 |     | <span class='neutral'>            remainder := mulmod(a, b, denominator)</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'>        // Subtract 256 bit number from 512 bit number</span>
  61 |     | <span class='neutral'>        assembly {</span>
  62 |     | <span class='neutral'>            prod1 := sub(prod1, gt(remainder, prod0))</span>
  63 |     | <span class='neutral'>            prod0 := sub(prod0, remainder)</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // Factor powers of two out of denominator</span>
  67 |     | <span class='neutral'>        // Compute largest power of two divisor of denominator.</span>
  68 |     | <span class='neutral'>        // Always &gt;= 1.</span>
  69 |     | <span class='neutral'>        uint256 twos = (-denominator.toInt() &amp; denominator.toInt()).toUint();</span>
  70 |     | <span class='neutral'>        // Divide denominator by power of two</span>
  71 |     | <span class='neutral'>        assembly {</span>
  72 |     | <span class='neutral'>            denominator := div(denominator, twos)</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // Divide [prod1 prod0] by the factors of two</span>
  76 |     | <span class='neutral'>        assembly {</span>
  77 |     | <span class='neutral'>            prod0 := div(prod0, twos)</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>        // Shift in bits from prod1 into prod0. For this we need</span>
  80 |     | <span class='neutral'>        // to flip `twos` such that it is 2**256 / twos.</span>
  81 |     | <span class='neutral'>        // If twos is zero, then it becomes one</span>
  82 |     | <span class='neutral'>        assembly {</span>
  83 |     | <span class='neutral'>            twos := add(div(sub(0, twos), twos), 1)</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'>        prod0 |= prod1 * twos;</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        // Invert denominator mod 2**256</span>
  88 |     | <span class='neutral'>        // Now that denominator is an odd number, it has an inverse</span>
  89 |     | <span class='neutral'>        // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  90 |     | <span class='neutral'>        // Compute the inverse by starting with a seed that is correct</span>
  91 |     | <span class='neutral'>        // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
  92 |     | <span class='neutral'>        uint256 inv = (3 * denominator) ^ 2;</span>
  93 |     | <span class='neutral'>        // Now use Newton-Raphson iteration to improve the precision.</span>
  94 |     | <span class='neutral'>        // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  95 |     | <span class='neutral'>        // arithmetic, doubling the correct bits in each step.</span>
  96 |     | <span class='neutral'>        inv *= 2 - denominator * inv; // inverse mod 2**8</span>
  97 |     | <span class='neutral'>        inv *= 2 - denominator * inv; // inverse mod 2**16</span>
  98 |     | <span class='neutral'>        inv *= 2 - denominator * inv; // inverse mod 2**32</span>
  99 |     | <span class='neutral'>        inv *= 2 - denominator * inv; // inverse mod 2**64</span>
 100 |     | <span class='neutral'>        inv *= 2 - denominator * inv; // inverse mod 2**128</span>
 101 |     | <span class='neutral'>        inv *= 2 - denominator * inv; // inverse mod 2**256</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        // Because the division is now exact we can divide by multiplying</span>
 104 |     | <span class='neutral'>        // with the modular inverse of denominator. This will give us the</span>
 105 |     | <span class='neutral'>        // correct result modulo 2**256. Since the precoditions guarantee</span>
 106 |     | <span class='neutral'>        // that the outcome is less than 2**256, this is the final result.</span>
 107 |     | <span class='neutral'>        // We don&#39;t need to compute the high bits of the result and prod1</span>
 108 |     | <span class='neutral'>        // is no longer required.</span>
 109 |     | <span class='neutral'>        result = prod0 * inv;</span>
 110 |     | <span class='neutral'>        return result;</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
 114 |     | <span class='neutral'>    /// @param a The multiplicand</span>
 115 |     | <span class='neutral'>    /// @param b The multiplier</span>
 116 |     | <span class='neutral'>    /// @param denominator The divisor</span>
 117 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
 118 |     | <span class='neutral'>    function mulDivRoundingUp(</span>
 119 |     | <span class='neutral'>        uint256 a,</span>
 120 |     | <span class='neutral'>        uint256 b,</span>
 121 |     | <span class='neutral'>        uint256 denominator</span>
 122 |     | <span class='neutral'>    ) internal pure returns (uint256 result) {</span>
 123 |     | <span class='neutral'>        result = mulDiv(a, b, denominator);</span>
 124 |     | <span class='neutral'>        if (mulmod(a, b, denominator) &gt; 0) {</span>
 125 |     | <span class='neutral'>            require(result &lt; type(uint256).max, &quot;result more than max&quot;);</span>
 126 |     | <span class='neutral'>            result++;</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/utils/TickMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title Math library for computing sqrt prices from ticks and vice versa</span>
   7 |     | <span class='neutral'>/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports</span>
   8 |     | <span class='neutral'>/// prices between 2**-128 and 2**128</span>
   9 |     | <span class='unexecuted'>library TickMath {</span>
  10 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
  11 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  12 |     | <span class='neutral'>    using SafeCastI24 for int24;</span>
  13 |     | <span class='neutral'>    using SafeCastU160 for uint160;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128</span>
  16 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;</span>
  17 |     | <span class='neutral'>    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128</span>
  18 |     | <span class='neutral'>    int24 internal constant MAX_TICK = -MIN_TICK;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)</span>
  21 |     | <span class='neutral'>    uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
  22 |     | <span class='neutral'>    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)</span>
  23 |     | <span class='neutral'>    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96</span>
  26 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick</span>
  27 |     | <span class='neutral'>    /// @param tick The input tick for the above formula</span>
  28 |     | <span class='neutral'>    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
  29 |     | <span class='neutral'>    /// at the given tick</span>
  30 |     | <span class='neutral'>    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {</span>
  31 |     | <span class='neutral'>        uint256 absTick = tick &lt; 0 ? (-tick.to256()).toUint() : tick.to256().toUint();</span>
  32 |     | <span class='neutral'>        require(absTick &lt;= MAX_TICK.to256().toUint(), &quot;T&quot;);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>        uint256 ratio = absTick &amp; 0x1 != 0</span>
  35 |     | <span class='neutral'>            ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
  36 |     | <span class='neutral'>            : 0x100000000000000000000000000000000;</span>
  37 |     | <span class='neutral'>        if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
  38 |     | <span class='neutral'>        if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
  39 |     | <span class='neutral'>        if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
  40 |     | <span class='neutral'>        if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
  41 |     | <span class='neutral'>        if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
  42 |     | <span class='neutral'>        if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
  43 |     | <span class='neutral'>        if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
  44 |     | <span class='neutral'>        if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
  45 |     | <span class='neutral'>        if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
  46 |     | <span class='neutral'>        if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
  47 |     | <span class='neutral'>        if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
  48 |     | <span class='neutral'>        if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
  49 |     | <span class='neutral'>        if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
  50 |     | <span class='neutral'>        if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
  51 |     | <span class='neutral'>        if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
  52 |     | <span class='neutral'>        if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
  53 |     | <span class='neutral'>        if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
  54 |     | <span class='neutral'>        if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
  55 |     | <span class='neutral'>        if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
  60 |     | <span class='neutral'>        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span>
  61 |     | <span class='neutral'>        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span>
  62 |     | <span class='neutral'>        sqrtPriceX96 = ((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1)).to160();</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio</span>
  66 |     | <span class='neutral'>    /// @dev Throws in case sqrtPriceX96 &lt; MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may</span>
  67 |     | <span class='neutral'>    /// ever return.</span>
  68 |     | <span class='neutral'>    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96</span>
  69 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio</span>
  70 |     | <span class='neutral'>    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {</span>
  71 |     | <span class='neutral'>        // second inequality must be &lt; because the price can never reach the price at the max tick</span>
  72 |     | <span class='neutral'>        require(sqrtPriceX96 &gt;= MIN_SQRT_RATIO &amp;&amp; sqrtPriceX96 &lt; MAX_SQRT_RATIO, &quot;R&quot;);</span>
  73 |     | <span class='neutral'>        uint256 ratio = sqrtPriceX96.to256() &lt;&lt; 32;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        uint256 r = ratio;</span>
  76 |     | <span class='neutral'>        uint256 msb = 0;</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        assembly {</span>
  79 |     | <span class='neutral'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
  80 |     | <span class='neutral'>            msb := or(msb, f)</span>
  81 |     | <span class='neutral'>            r := shr(f, r)</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>        assembly {</span>
  84 |     | <span class='neutral'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
  85 |     | <span class='neutral'>            msb := or(msb, f)</span>
  86 |     | <span class='neutral'>            r := shr(f, r)</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'>        assembly {</span>
  89 |     | <span class='neutral'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
  90 |     | <span class='neutral'>            msb := or(msb, f)</span>
  91 |     | <span class='neutral'>            r := shr(f, r)</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>        assembly {</span>
  94 |     | <span class='neutral'>            let f := shl(4, gt(r, 0xFFFF))</span>
  95 |     | <span class='neutral'>            msb := or(msb, f)</span>
  96 |     | <span class='neutral'>            r := shr(f, r)</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>        assembly {</span>
  99 |     | <span class='neutral'>            let f := shl(3, gt(r, 0xFF))</span>
 100 |     | <span class='neutral'>            msb := or(msb, f)</span>
 101 |     | <span class='neutral'>            r := shr(f, r)</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'>        assembly {</span>
 104 |     | <span class='neutral'>            let f := shl(2, gt(r, 0xF))</span>
 105 |     | <span class='neutral'>            msb := or(msb, f)</span>
 106 |     | <span class='neutral'>            r := shr(f, r)</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>        assembly {</span>
 109 |     | <span class='neutral'>            let f := shl(1, gt(r, 0x3))</span>
 110 |     | <span class='neutral'>            msb := or(msb, f)</span>
 111 |     | <span class='neutral'>            r := shr(f, r)</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>        assembly {</span>
 114 |     | <span class='neutral'>            let f := gt(r, 0x1)</span>
 115 |     | <span class='neutral'>            msb := or(msb, f)</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 119 |     | <span class='neutral'>        else r = ratio &lt;&lt; (127 - msb);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        int256 _log2 = (msb.toInt() - 128) &lt;&lt; 64;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        assembly {</span>
 124 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 125 |     | <span class='neutral'>            let f := shr(128, r)</span>
 126 |     | <span class='neutral'>            _log2 := or(_log2, shl(63, f))</span>
 127 |     | <span class='neutral'>            r := shr(f, r)</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>        assembly {</span>
 130 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 131 |     | <span class='neutral'>            let f := shr(128, r)</span>
 132 |     | <span class='neutral'>            _log2 := or(_log2, shl(62, f))</span>
 133 |     | <span class='neutral'>            r := shr(f, r)</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>        assembly {</span>
 136 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 137 |     | <span class='neutral'>            let f := shr(128, r)</span>
 138 |     | <span class='neutral'>            _log2 := or(_log2, shl(61, f))</span>
 139 |     | <span class='neutral'>            r := shr(f, r)</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>        assembly {</span>
 142 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 143 |     | <span class='neutral'>            let f := shr(128, r)</span>
 144 |     | <span class='neutral'>            _log2 := or(_log2, shl(60, f))</span>
 145 |     | <span class='neutral'>            r := shr(f, r)</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>        assembly {</span>
 148 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 149 |     | <span class='neutral'>            let f := shr(128, r)</span>
 150 |     | <span class='neutral'>            _log2 := or(_log2, shl(59, f))</span>
 151 |     | <span class='neutral'>            r := shr(f, r)</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 155 |     | <span class='neutral'>            let f := shr(128, r)</span>
 156 |     | <span class='neutral'>            _log2 := or(_log2, shl(58, f))</span>
 157 |     | <span class='neutral'>            r := shr(f, r)</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'>        assembly {</span>
 160 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 161 |     | <span class='neutral'>            let f := shr(128, r)</span>
 162 |     | <span class='neutral'>            _log2 := or(_log2, shl(57, f))</span>
 163 |     | <span class='neutral'>            r := shr(f, r)</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>        assembly {</span>
 166 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 167 |     | <span class='neutral'>            let f := shr(128, r)</span>
 168 |     | <span class='neutral'>            _log2 := or(_log2, shl(56, f))</span>
 169 |     | <span class='neutral'>            r := shr(f, r)</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>        assembly {</span>
 172 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 173 |     | <span class='neutral'>            let f := shr(128, r)</span>
 174 |     | <span class='neutral'>            _log2 := or(_log2, shl(55, f))</span>
 175 |     | <span class='neutral'>            r := shr(f, r)</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>        assembly {</span>
 178 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 179 |     | <span class='neutral'>            let f := shr(128, r)</span>
 180 |     | <span class='neutral'>            _log2 := or(_log2, shl(54, f))</span>
 181 |     | <span class='neutral'>            r := shr(f, r)</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>        assembly {</span>
 184 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 185 |     | <span class='neutral'>            let f := shr(128, r)</span>
 186 |     | <span class='neutral'>            _log2 := or(_log2, shl(53, f))</span>
 187 |     | <span class='neutral'>            r := shr(f, r)</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'>        assembly {</span>
 190 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 191 |     | <span class='neutral'>            let f := shr(128, r)</span>
 192 |     | <span class='neutral'>            _log2 := or(_log2, shl(52, f))</span>
 193 |     | <span class='neutral'>            r := shr(f, r)</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='neutral'>        assembly {</span>
 196 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 197 |     | <span class='neutral'>            let f := shr(128, r)</span>
 198 |     | <span class='neutral'>            _log2 := or(_log2, shl(51, f))</span>
 199 |     | <span class='neutral'>            r := shr(f, r)</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>        assembly {</span>
 202 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 203 |     | <span class='neutral'>            let f := shr(128, r)</span>
 204 |     | <span class='neutral'>            _log2 := or(_log2, shl(50, f))</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        int256 logSqrt10001 = _log2 * 255738958999603826347141; // 128.128 number</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        int24 tickLow = (logSqrt10001 - 3402992956809132418596140100660247210).to24() &gt;&gt; 128;</span>
 210 |     | <span class='neutral'>        int24 tickHi = (logSqrt10001 + 291339464771989622907027621153398088495).to24() &gt;&gt; 128;</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>        if (tickLow == tickHi) {</span>
 213 |     | <span class='neutral'>            tick = tickLow;</span>
 214 |     | <span class='neutral'>        } else {</span>
 215 |     | <span class='neutral'>            tick = getSqrtRatioAtTick(tickHi) &lt;= sqrtPriceX96 ? tickHi : tickLow;</span>
 216 |     | <span class='neutral'>        }</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'>}</span>
 219 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/rewards-distributor/src/RewardsDistributor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>// solhint-disable meta-transactions/no-msg-sender</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {IRewardDistributor} from &quot;@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IRewardsManagerModule} from &quot;@synthetixio/main/contracts/interfaces/IRewardsManagerModule.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IPoolModule} from &quot;@synthetixio/main/contracts/interfaces/IPoolModule.sol&quot;;</span>
   8 |     | <span class='neutral'>import {AccessError} from &quot;@synthetixio/core-contracts/contracts/errors/AccessError.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ParameterError} from &quot;@synthetixio/core-contracts/contracts/errors/ParameterError.sol&quot;;</span>
  10 |     | <span class='neutral'>import {ERC20Helper} from &quot;@synthetixio/core-contracts/contracts/token/ERC20Helper.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IERC165} from &quot;@synthetixio/core-contracts/contracts/interfaces/IERC165.sol&quot;;</span>
  12 |     | <span class='neutral'>import {IERC20} from &quot;@synthetixio/core-contracts/contracts/interfaces/IERC20.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>contract RewardsDistributor is IRewardDistributor {</span>
  15 |     | <span class='neutral'>    error NotEnoughRewardsLeft(uint256 amountRequested, uint256 amountLeft);</span>
  16 |     | <span class='neutral'>    error NotEnoughBalance(uint256 amountRequested, uint256 currentBalance);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    using ERC20Helper for address;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    address public rewardManager;</span>
  21 |     | <span class='unexecuted'>    uint128 public poolId;</span>
  22 |     | <span class='unexecuted'>    address public collateralType;</span>
  23 |     | <span class='unexecuted'>    address public payoutToken;</span>
  24 |     | <span class='unexecuted'>    string public name;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    uint256 public precision;</span>
  27 |     | <span class='unexecuted'>    uint256 public constant SYSTEM_PRECISION = 10 ** 18;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    bool public shouldFailPayout;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // Internal tracking for the remaining rewards, it keeps value in payoutToken precision</span>
  32 |     | <span class='unexecuted'>    uint256 public rewardsAmount = 0;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    constructor(</span>
  35 |     | <span class='neutral'>        address rewardManager_,</span>
  36 |     | <span class='neutral'>        uint128 poolId_,</span>
  37 |     | <span class='neutral'>        address collateralType_,</span>
  38 |     | <span class='neutral'>        address payoutToken_,</span>
  39 |     | <span class='neutral'>        uint8 payoutTokenDecimals_,</span>
  40 |     | <span class='neutral'>        string memory name_</span>
  41 |     | <span class='neutral'>    ) {</span>
  42 |     | <span class='unexecuted'>        rewardManager = rewardManager_; // Synthetix CoreProxy</span>
  43 |     | <span class='unexecuted'>        poolId = poolId_;</span>
  44 |     | <span class='unexecuted'>        collateralType = collateralType_;</span>
  45 |     | <span class='unexecuted'>        payoutToken = payoutToken_;</span>
  46 |     | <span class='unexecuted'>        name = name_;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        (bool success, bytes memory data) = payoutToken_.staticcall(</span>
  49 |     | <span class='unexecuted'>            abi.encodeWithSignature(&quot;decimals()&quot;)</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>        if (success &amp;&amp; data.length &gt; 0 &amp;&amp; abi.decode(data, (uint8)) != payoutTokenDecimals_) {</span>
  53 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(</span>
  54 |     | <span class='neutral'>                &quot;payoutTokenDecimals&quot;,</span>
  55 |     | <span class='neutral'>                &quot;Specified token decimals do not match actual token decimals&quot;</span>
  56 |     | <span class='neutral'>            );</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>        // Fallback to the specified token decimals skipping the check if token does not support decimals method</span>
  59 |     | <span class='unexecuted'>        precision = 10 ** payoutTokenDecimals_;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function token() public view returns (address) {</span>
  63 |     | <span class='unexecuted'>        return payoutToken;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function setShouldFailPayout(bool shouldFailPayout_) external {</span>
  67 |     | <span class='unexecuted'>        if (msg.sender != IPoolModule(rewardManager).getPoolOwner(poolId)) {</span>
  68 |     | <span class='unexecuted'>            revert AccessError.Unauthorized(msg.sender);</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='unexecuted'>        shouldFailPayout = shouldFailPayout_;</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    function payout(</span>
  74 |     | <span class='neutral'>        uint128, // accountId,</span>
  75 |     | <span class='neutral'>        uint128 poolId_,</span>
  76 |     | <span class='neutral'>        address collateralType_,</span>
  77 |     | <span class='neutral'>        address payoutTarget_, // msg.sender of claimRewards() call, payout target address</span>
  78 |     | <span class='neutral'>        uint256 payoutAmount_</span>
  79 |     | <span class='unexecuted'>    ) external returns (bool) {</span>
  80 |     | <span class='unexecuted'>        if (shouldFailPayout) {</span>
  81 |     | <span class='unexecuted'>            return false;</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>        // IMPORTANT: In production, this function should revert if msg.sender is not the Synthetix CoreProxy address.</span>
  84 |     | <span class='unexecuted'>        if (msg.sender != rewardManager) {</span>
  85 |     | <span class='unexecuted'>            revert AccessError.Unauthorized(msg.sender);</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='unexecuted'>        if (poolId_ != poolId) {</span>
  88 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(</span>
  89 |     | <span class='neutral'>                &quot;poolId&quot;,</span>
  90 |     | <span class='neutral'>                &quot;Pool does not match the rewards pool&quot;</span>
  91 |     | <span class='neutral'>            );</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='unexecuted'>        if (collateralType_ != collateralType) {</span>
  94 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(</span>
  95 |     | <span class='neutral'>                &quot;collateralType&quot;,</span>
  96 |     | <span class='neutral'>                &quot;Collateral does not match the rewards token&quot;</span>
  97 |     | <span class='neutral'>            );</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // payoutAmount_ is always in 18 decimals precision, adjust actual payout amount to match payout token decimals</span>
 101 |     | <span class='unexecuted'>        uint256 adjustedAmount = (payoutAmount_ * precision) / SYSTEM_PRECISION;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        if (adjustedAmount &gt; rewardsAmount) {</span>
 104 |     | <span class='unexecuted'>            revert NotEnoughRewardsLeft(adjustedAmount, rewardsAmount);</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='unexecuted'>        rewardsAmount = rewardsAmount - adjustedAmount;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        payoutToken.safeTransfer(payoutTarget_, adjustedAmount);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>        return true;</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>    function distributeRewards(</span>
 114 |     | <span class='neutral'>        uint128 poolId_,</span>
 115 |     | <span class='neutral'>        address collateralType_,</span>
 116 |     | <span class='neutral'>        uint256 amount_,</span>
 117 |     | <span class='neutral'>        uint64 start_,</span>
 118 |     | <span class='neutral'>        uint32 duration_</span>
 119 |     | <span class='unexecuted'>    ) public {</span>
 120 |     | <span class='unexecuted'>        _checkDistributeSender();</span>
 121 |     | <span class='unexecuted'>        if (poolId_ != poolId) {</span>
 122 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(</span>
 123 |     | <span class='neutral'>                &quot;poolId&quot;,</span>
 124 |     | <span class='neutral'>                &quot;Pool does not match the rewards pool&quot;</span>
 125 |     | <span class='neutral'>            );</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='unexecuted'>        if (collateralType_ != collateralType) {</span>
 128 |     | <span class='unexecuted'>            revert ParameterError.InvalidParameter(</span>
 129 |     | <span class='neutral'>                &quot;collateralType&quot;,</span>
 130 |     | <span class='neutral'>                &quot;Collateral does not match the rewards token&quot;</span>
 131 |     | <span class='neutral'>            );</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        rewardsAmount = rewardsAmount + amount_;</span>
 135 |     | <span class='unexecuted'>        uint256 balance = IERC20(payoutToken).balanceOf(address(this));</span>
 136 |     | <span class='unexecuted'>        if (rewardsAmount &gt; balance) {</span>
 137 |     | <span class='unexecuted'>            revert NotEnoughBalance(amount_, balance);</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>        // amount_ is in payout token decimals precision, adjust actual distribution amount to 18 decimals that core is making its calculations in</span>
 141 |     | <span class='neutral'>        // this is necessary to avoid rounding issues when doing actual payouts</span>
 142 |     | <span class='unexecuted'>        uint256 adjustedAmount = (amount_ * SYSTEM_PRECISION) / precision;</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        IRewardsManagerModule(rewardManager).distributeRewards(</span>
 145 |     | <span class='neutral'>            poolId_,</span>
 146 |     | <span class='neutral'>            collateralType_,</span>
 147 |     | <span class='neutral'>            adjustedAmount,</span>
 148 |     | <span class='neutral'>            start_,</span>
 149 |     | <span class='neutral'>            duration_</span>
 150 |     | <span class='neutral'>        );</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function onPositionUpdated(</span>
 154 |     | <span class='neutral'>        uint128, // accountId,</span>
 155 |     | <span class='neutral'>        uint128, // poolId,</span>
 156 |     | <span class='neutral'>        address, // collateralType,</span>
 157 |     | <span class='neutral'>        uint256 // actorSharesD18</span>
 158 |     | <span class='neutral'>    ) external {} // solhint-disable-line no-empty-blocks</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 162 |     | <span class='neutral'>     */</span>
 163 |     | <span class='unexecuted'>    function supportsInterface(</span>
 164 |     | <span class='neutral'>        bytes4 interfaceId</span>
 165 |     | <span class='unexecuted'>    ) public view virtual override(IERC165) returns (bool) {</span>
 166 |     | <span class='unexecuted'>        return</span>
 167 |     | <span class='unexecuted'>            interfaceId == type(IRewardDistributor).interfaceId ||</span>
 168 |     | <span class='unexecuted'>            interfaceId == this.supportsInterface.selector;</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function _checkDistributeSender() internal view virtual {</span>
 172 |     | <span class='unexecuted'>        if (msg.sender != IPoolModule(rewardManager).getPoolOwner(poolId)) {</span>
 173 |     | <span class='unexecuted'>            revert AccessError.Unauthorized(msg.sender);</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'>}</span>
 177 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/IAtomicOrderModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {OrderFees} from &quot;../storage/OrderFees.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Price} from &quot;../storage/Price.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title Module for atomic buy and sell orders for traders.</span>
   9 |     | <span class='neutral'> */</span>
  10 |     | <span class='neutral'>interface IAtomicOrderModule {</span>
  11 |     | <span class='neutral'>    /**</span>
  12 |     | <span class='neutral'>     * @notice Thrown when trade is charging more USD than the max amount specified by the trader.</span>
  13 |     | <span class='neutral'>     * @dev Used in buyExactOut</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    error ExceedsMaxUsdAmount(uint256 maxUsdAmount, uint256 usdAmountCharged);</span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @notice Thrown when trade is charging more synth than the max amount specified by the trader.</span>
  18 |     | <span class='neutral'>     * @dev Used in sellExactOut</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    error ExceedsMaxSynthAmount(uint256 maxSynthAmount, uint256 synthAmountCharged);</span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * @notice Thrown when a trade doesn&#39;t meet minimum expected return amount.</span>
  23 |     | <span class='neutral'>     */</span>
  24 |     | <span class='neutral'>    error InsufficientAmountReceived(uint256 expected, uint256 current);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /**</span>
  27 |     | <span class='neutral'>     * @notice Thrown when the sell price is higher than the buy price</span>
  28 |     | <span class='neutral'>     */</span>
  29 |     | <span class='neutral'>    error InvalidPrices();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @notice Gets fired when buy trade is complete</span>
  33 |     | <span class='neutral'>     * @param synthMarketId Id of the market used for the trade.</span>
  34 |     | <span class='neutral'>     * @param synthReturned Synth received on the trade based on amount provided by trader.</span>
  35 |     | <span class='neutral'>     * @param fees breakdown of all fees incurred for transaction.</span>
  36 |     | <span class='neutral'>     * @param collectedFees Fees collected by the configured FeeCollector for the market (rest of the fees are deposited to market manager).</span>
  37 |     | <span class='neutral'>     * @param referrer Optional address of the referrer, for fee share</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    event SynthBought(</span>
  40 |     | <span class='neutral'>        uint256 indexed synthMarketId,</span>
  41 |     | <span class='neutral'>        uint256 synthReturned,</span>
  42 |     | <span class='neutral'>        OrderFees.Data fees,</span>
  43 |     | <span class='neutral'>        uint256 collectedFees,</span>
  44 |     | <span class='neutral'>        address referrer,</span>
  45 |     | <span class='neutral'>        uint256 price</span>
  46 |     | <span class='neutral'>    );</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @notice Gets fired when sell trade is complete</span>
  50 |     | <span class='neutral'>     * @param synthMarketId Id of the market used for the trade.</span>
  51 |     | <span class='neutral'>     * @param amountReturned Amount of snxUSD returned to user based on synth provided by trader.</span>
  52 |     | <span class='neutral'>     * @param fees breakdown of all fees incurred for transaction.</span>
  53 |     | <span class='neutral'>     * @param collectedFees Fees collected by the configured FeeCollector for the market (rest of the fees are deposited to market manager).</span>
  54 |     | <span class='neutral'>     * @param referrer Optional address of the referrer, for fee share</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    event SynthSold(</span>
  57 |     | <span class='neutral'>        uint256 indexed synthMarketId,</span>
  58 |     | <span class='neutral'>        uint256 amountReturned,</span>
  59 |     | <span class='neutral'>        OrderFees.Data fees,</span>
  60 |     | <span class='neutral'>        uint256 collectedFees,</span>
  61 |     | <span class='neutral'>        address referrer,</span>
  62 |     | <span class='neutral'>        uint256 price</span>
  63 |     | <span class='neutral'>    );</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @notice Initiates a buy trade returning synth for the specified amountUsd.</span>
  67 |     | <span class='neutral'>     * @dev Transfers the specified amountUsd, collects fees through configured fee collector, returns synth to the trader.</span>
  68 |     | <span class='neutral'>     * @dev Leftover fees not collected get deposited into the market manager to improve market PnL.</span>
  69 |     | <span class='neutral'>     * @dev Uses the buyFeedId configured for the market.</span>
  70 |     | <span class='neutral'>     * @param synthMarketId Id of the market used for the trade.</span>
  71 |     | <span class='neutral'>     * @param amountUsd Amount of snxUSD trader is providing allowance for the trade.</span>
  72 |     | <span class='neutral'>     * @param minAmountReceived Min Amount of synth is expected the trader to receive otherwise the transaction will revert.</span>
  73 |     | <span class='neutral'>     * @param referrer Optional address of the referrer, for fee share</span>
  74 |     | <span class='neutral'>     * @return synthAmount Synth received on the trade based on amount provided by trader.</span>
  75 |     | <span class='neutral'>     * @return fees breakdown of all the fees incurred for the transaction.</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='neutral'>    function buyExactIn(</span>
  78 |     | <span class='neutral'>        uint128 synthMarketId,</span>
  79 |     | <span class='neutral'>        uint256 amountUsd,</span>
  80 |     | <span class='neutral'>        uint256 minAmountReceived,</span>
  81 |     | <span class='neutral'>        address referrer</span>
  82 |     | <span class='neutral'>    ) external returns (uint256 synthAmount, OrderFees.Data memory fees);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @notice  alias for buyExactIn</span>
  86 |     | <span class='neutral'>     * @param   marketId  (see buyExactIn)</span>
  87 |     | <span class='neutral'>     * @param   usdAmount  (see buyExactIn)</span>
  88 |     | <span class='neutral'>     * @param   minAmountReceived  (see buyExactIn)</span>
  89 |     | <span class='neutral'>     * @param   referrer  (see buyExactIn)</span>
  90 |     | <span class='neutral'>     * @return  synthAmount  (see buyExactIn)</span>
  91 |     | <span class='neutral'>     * @return  fees  (see buyExactIn)</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function buy(</span>
  94 |     | <span class='neutral'>        uint128 marketId,</span>
  95 |     | <span class='neutral'>        uint256 usdAmount,</span>
  96 |     | <span class='neutral'>        uint256 minAmountReceived,</span>
  97 |     | <span class='neutral'>        address referrer</span>
  98 |     | <span class='neutral'>    ) external returns (uint256 synthAmount, OrderFees.Data memory fees);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @notice  user provides the synth amount they&#39;d like to buy, and the function charges the USD amount which includes fees</span>
 102 |     | <span class='neutral'>     * @dev     the inverse of buyExactIn</span>
 103 |     | <span class='neutral'>     * @param   synthMarketId  market id value</span>
 104 |     | <span class='neutral'>     * @param   synthAmount  the amount of synth the trader wants to buy</span>
 105 |     | <span class='neutral'>     * @param   maxUsdAmount  max amount the trader is willing to pay for the specified synth</span>
 106 |     | <span class='neutral'>     * @param   referrer  optional address of the referrer, for fee share</span>
 107 |     | <span class='neutral'>     * @return  usdAmountCharged  amount of USD charged for the trade</span>
 108 |     | <span class='neutral'>     * @return  fees  breakdown of all the fees incurred for the transaction</span>
 109 |     | <span class='neutral'>     */</span>
 110 |     | <span class='neutral'>    function buyExactOut(</span>
 111 |     | <span class='neutral'>        uint128 synthMarketId,</span>
 112 |     | <span class='neutral'>        uint256 synthAmount,</span>
 113 |     | <span class='neutral'>        uint256 maxUsdAmount,</span>
 114 |     | <span class='neutral'>        address referrer</span>
 115 |     | <span class='neutral'>    ) external returns (uint256 usdAmountCharged, OrderFees.Data memory fees);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @notice  quote for buyExactIn.  same parameters and return values as buyExactIn</span>
 119 |     | <span class='neutral'>     * @param   synthMarketId  market id value</span>
 120 |     | <span class='neutral'>     * @param   usdAmount  amount of USD to use for the trade</span>
 121 |     | <span class='neutral'>     * @param   stalenessTolerance  this enum determines what staleness tolerance to use</span>
 122 |     | <span class='neutral'>     * @return  synthAmount  return amount of synth given the USD amount - fees</span>
 123 |     | <span class='neutral'>     * @return  fees  breakdown of all the quoted fees for the buy txn</span>
 124 |     | <span class='neutral'>     */</span>
 125 |     | <span class='neutral'>    function quoteBuyExactIn(</span>
 126 |     | <span class='neutral'>        uint128 synthMarketId,</span>
 127 |     | <span class='neutral'>        uint256 usdAmount,</span>
 128 |     | <span class='neutral'>        Price.Tolerance stalenessTolerance</span>
 129 |     | <span class='neutral'>    ) external view returns (uint256 synthAmount, OrderFees.Data memory fees);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @notice  quote for buyExactOut.  same parameters and return values as buyExactOut</span>
 133 |     | <span class='neutral'>     * @param   synthMarketId  market id value</span>
 134 |     | <span class='neutral'>     * @param   synthAmount  amount of synth requested</span>
 135 |     | <span class='neutral'>     * @param   stalenessTolerance  this enum determines what staleness tolerance to use</span>
 136 |     | <span class='neutral'>     * @return  usdAmountCharged  USD amount charged for the synth requested - fees</span>
 137 |     | <span class='neutral'>     * @return  fees  breakdown of all the quoted fees for the buy txn</span>
 138 |     | <span class='neutral'>     */</span>
 139 |     | <span class='neutral'>    function quoteBuyExactOut(</span>
 140 |     | <span class='neutral'>        uint128 synthMarketId,</span>
 141 |     | <span class='neutral'>        uint256 synthAmount,</span>
 142 |     | <span class='neutral'>        Price.Tolerance stalenessTolerance</span>
 143 |     | <span class='neutral'>    ) external view returns (uint256 usdAmountCharged, OrderFees.Data memory);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /**</span>
 146 |     | <span class='neutral'>     * @notice Initiates a sell trade returning snxUSD for the specified amount of synth (sellAmount)</span>
 147 |     | <span class='neutral'>     * @dev Transfers the specified synth, collects fees through configured fee collector, returns snxUSD to the trader.</span>
 148 |     | <span class='neutral'>     * @dev Leftover fees not collected get deposited into the market manager to improve market PnL.</span>
 149 |     | <span class='neutral'>     * @param synthMarketId Id of the market used for the trade.</span>
 150 |     | <span class='neutral'>     * @param sellAmount Amount of synth provided by trader for trade into snxUSD.</span>
 151 |     | <span class='neutral'>     * @param minAmountReceived Min Amount of snxUSD trader expects to receive for the trade</span>
 152 |     | <span class='neutral'>     * @param referrer Optional address of the referrer, for fee share</span>
 153 |     | <span class='neutral'>     * @return returnAmount Amount of snxUSD returned to user</span>
 154 |     | <span class='neutral'>     * @return fees breakdown of all the fees incurred for the transaction.</span>
 155 |     | <span class='neutral'>     */</span>
 156 |     | <span class='neutral'>    function sellExactIn(</span>
 157 |     | <span class='neutral'>        uint128 synthMarketId,</span>
 158 |     | <span class='neutral'>        uint256 sellAmount,</span>
 159 |     | <span class='neutral'>        uint256 minAmountReceived,</span>
 160 |     | <span class='neutral'>        address referrer</span>
 161 |     | <span class='neutral'>    ) external returns (uint256 returnAmount, OrderFees.Data memory fees);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @notice  initiates a trade where trader specifies USD amount they&#39;d like to receive</span>
 165 |     | <span class='neutral'>     * @dev     the inverse of sellExactIn</span>
 166 |     | <span class='neutral'>     * @param   marketId  synth market id</span>
 167 |     | <span class='neutral'>     * @param   usdAmount  amount of USD trader wants to receive</span>
 168 |     | <span class='neutral'>     * @param   maxSynthAmount  max amount of synth trader is willing to use to receive the specified USD amount</span>
 169 |     | <span class='neutral'>     * @param   referrer  optional address of the referrer, for fee share</span>
 170 |     | <span class='neutral'>     * @return  synthToBurn amount of synth charged for the specified usd amount</span>
 171 |     | <span class='neutral'>     * @return  fees breakdown of all the fees incurred for the transaction</span>
 172 |     | <span class='neutral'>     */</span>
 173 |     | <span class='neutral'>    function sellExactOut(</span>
 174 |     | <span class='neutral'>        uint128 marketId,</span>
 175 |     | <span class='neutral'>        uint256 usdAmount,</span>
 176 |     | <span class='neutral'>        uint256 maxSynthAmount,</span>
 177 |     | <span class='neutral'>        address referrer</span>
 178 |     | <span class='neutral'>    ) external returns (uint256 synthToBurn, OrderFees.Data memory fees);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /**</span>
 181 |     | <span class='neutral'>     * @notice  alias for sellExactIn</span>
 182 |     | <span class='neutral'>     * @param   marketId  (see sellExactIn)</span>
 183 |     | <span class='neutral'>     * @param   synthAmount  (see sellExactIn)</span>
 184 |     | <span class='neutral'>     * @param   minUsdAmount  (see sellExactIn)</span>
 185 |     | <span class='neutral'>     * @param   referrer  (see sellExactIn)</span>
 186 |     | <span class='neutral'>     * @return  usdAmountReceived  (see sellExactIn)</span>
 187 |     | <span class='neutral'>     * @return  fees  (see sellExactIn)</span>
 188 |     | <span class='neutral'>     */</span>
 189 |     | <span class='neutral'>    function sell(</span>
 190 |     | <span class='neutral'>        uint128 marketId,</span>
 191 |     | <span class='neutral'>        uint256 synthAmount,</span>
 192 |     | <span class='neutral'>        uint256 minUsdAmount,</span>
 193 |     | <span class='neutral'>        address referrer</span>
 194 |     | <span class='neutral'>    ) external returns (uint256 usdAmountReceived, OrderFees.Data memory fees);</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    /**</span>
 197 |     | <span class='neutral'>     * @notice  quote for sellExactIn</span>
 198 |     | <span class='neutral'>     * @dev     returns expected USD amount trader would receive for the specified synth amount</span>
 199 |     | <span class='neutral'>     * @param   marketId  synth market id</span>
 200 |     | <span class='neutral'>     * @param   synthAmount  synth amount trader is providing for the trade</span>
 201 |     | <span class='neutral'>     * @param   stalenessTolerance  this enum determines what staleness tolerance to use</span>
 202 |     | <span class='neutral'>     * @return  returnAmount  amount of USD expected back</span>
 203 |     | <span class='neutral'>     * @return  fees  breakdown of all the quoted fees for the txn</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function quoteSellExactIn(</span>
 206 |     | <span class='neutral'>        uint128 marketId,</span>
 207 |     | <span class='neutral'>        uint256 synthAmount,</span>
 208 |     | <span class='neutral'>        Price.Tolerance stalenessTolerance</span>
 209 |     | <span class='neutral'>    ) external view returns (uint256 returnAmount, OrderFees.Data memory fees);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /**</span>
 212 |     | <span class='neutral'>     * @notice  quote for sellExactOut</span>
 213 |     | <span class='neutral'>     * @dev     returns expected synth amount expected from trader for the requested USD amount</span>
 214 |     | <span class='neutral'>     * @param   marketId  synth market id</span>
 215 |     | <span class='neutral'>     * @param   usdAmount  USD amount trader wants to receive</span>
 216 |     | <span class='neutral'>     * @param   stalenessTolerance  this enum determines what staleness tolerance to use</span>
 217 |     | <span class='neutral'>     * @return  synthToBurn  amount of synth expected from trader</span>
 218 |     | <span class='neutral'>     * @return  fees  breakdown of all the quoted fees for the txn</span>
 219 |     | <span class='neutral'>     */</span>
 220 |     | <span class='neutral'>    function quoteSellExactOut(</span>
 221 |     | <span class='neutral'>        uint128 marketId,</span>
 222 |     | <span class='neutral'>        uint256 usdAmount,</span>
 223 |     | <span class='neutral'>        Price.Tolerance stalenessTolerance</span>
 224 |     | <span class='neutral'>    ) external view returns (uint256 synthToBurn, OrderFees.Data memory fees);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /**</span>
 227 |     | <span class='neutral'>     * @notice  gets the current market skew</span>
 228 |     | <span class='neutral'>     * @param   marketId  synth market id</span>
 229 |     | <span class='neutral'>     * @return  marketSkew  the skew</span>
 230 |     | <span class='neutral'>     */</span>
 231 |     | <span class='neutral'>    function getMarketSkew(uint128 marketId) external view returns (int256 marketSkew);</span>
 232 |     | <span class='neutral'>}</span>
 233 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/IMarketConfigurationModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Module for market-specific configuration.</span>
   6 |     | <span class='neutral'> */</span>
   7 |     | <span class='neutral'>interface IMarketConfigurationModule {</span>
   8 |     | <span class='neutral'>    /**</span>
   9 |     | <span class='neutral'>     * @notice thrown when wrap + unwrap fees are being set to a negative value in total</span>
  10 |     | <span class='neutral'>     */</span>
  11 |     | <span class='neutral'>    error InvalidWrapperFees();</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /**</span>
  14 |     | <span class='neutral'>     * @notice emitted when market utilization fees are set for specified market</span>
  15 |     | <span class='neutral'>     * @param synthMarketId market id</span>
  16 |     | <span class='neutral'>     * @param utilizationFeeRate utilization fee rate value</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='neutral'>    event MarketUtilizationFeesSet(uint256 indexed synthMarketId, uint256 utilizationFeeRate);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @notice emitted when the skew scale is set for a market</span>
  22 |     | <span class='neutral'>     * @param synthMarketId market id</span>
  23 |     | <span class='neutral'>     * @param skewScale skew scale value</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event MarketSkewScaleSet(uint256 indexed synthMarketId, uint256 skewScale);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @notice emitted when the collateral leverage is set for a market</span>
  29 |     | <span class='neutral'>     * @param synthMarketId market id</span>
  30 |     | <span class='neutral'>     * @param collateralLeverage leverage value</span>
  31 |     | <span class='neutral'>     */</span>
  32 |     | <span class='neutral'>    event CollateralLeverageSet(uint256 indexed synthMarketId, uint256 collateralLeverage);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @notice emitted when the fixed fee for atomic orders is set.</span>
  36 |     | <span class='neutral'>     * @param synthMarketId market id</span>
  37 |     | <span class='neutral'>     * @param atomicFixedFee fee value</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    event AtomicFixedFeeSet(uint256 indexed synthMarketId, uint256 atomicFixedFee);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @notice emitted when the fixed fee for async orders is set.</span>
  43 |     | <span class='neutral'>     * @param synthMarketId market id</span>
  44 |     | <span class='neutral'>     * @param asyncFixedFee fee value</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    event AsyncFixedFeeSet(uint256 indexed synthMarketId, uint256 asyncFixedFee);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @notice emitted when the fixed fee is set for a given transactor</span>
  50 |     | <span class='neutral'>     * @dev this overrides the async/atomic fixed fees for a given transactor</span>
  51 |     | <span class='neutral'>     * @param synthMarketId Id of the market to set the fees for.</span>
  52 |     | <span class='neutral'>     * @param transactor fixed fee for the transactor (overrides the global fixed fee)</span>
  53 |     | <span class='neutral'>     * @param fixedFeeAmount the fixed fee for the corresponding market, and transactor</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    event TransactorFixedFeeSet(</span>
  56 |     | <span class='neutral'>        uint256 indexed synthMarketId,</span>
  57 |     | <span class='neutral'>        address transactor,</span>
  58 |     | <span class='neutral'>        uint256 fixedFeeAmount</span>
  59 |     | <span class='neutral'>    );</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @notice emitted when custom fee collector is set for a given market</span>
  63 |     | <span class='neutral'>     * @param synthMarketId Id of the market to set the collector for.</span>
  64 |     | <span class='neutral'>     * @param feeCollector the address of the fee collector to set.</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    event FeeCollectorSet(uint256 indexed synthMarketId, address feeCollector);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @notice emitted when wrapper fees are set for a given market</span>
  70 |     | <span class='neutral'>     * @param synthMarketId Id of the market to set the wrapper fees.</span>
  71 |     | <span class='neutral'>     * @param wrapFee wrapping fee in %, 18 decimals. Can be negative.</span>
  72 |     | <span class='neutral'>     * @param unwrapFee unwrapping fee in %, 18 decimals. Can be negative.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='neutral'>    event WrapperFeesSet(uint256 indexed synthMarketId, int256 wrapFee, int256 unwrapFee);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @notice Emitted when the share percentage for a referrer address has been updated.</span>
  78 |     | <span class='neutral'>     * @param marketId Id of the market</span>
  79 |     | <span class='neutral'>     * @param referrer The address of the referrer</span>
  80 |     | <span class='neutral'>     * @param sharePercentage The new share percentage for the referrer</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    event ReferrerShareUpdated(uint128 indexed marketId, address referrer, uint256 sharePercentage);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @notice Thrown when the fee collector does not implement the IFeeCollector interface</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    error InvalidFeeCollectorInterface(address invalidFeeCollector);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @notice gets the atomic fixed fee for a given market</span>
  91 |     | <span class='neutral'>     * @param synthMarketId Id of the market the fee applies to.</span>
  92 |     | <span class='neutral'>     * @return atomicFixedFee fixed fee amount represented in bips with 18 decimals.</span>
  93 |     | <span class='neutral'>     * @return asyncFixedFee fixed fee amount represented in bips with 18 decimals.</span>
  94 |     | <span class='neutral'>     * @return wrapFee wrapping fee in %, 18 decimals. Can be negative.</span>
  95 |     | <span class='neutral'>     * @return unwrapFee unwrapping fee in %, 18 decimals. Can be negative.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function getMarketFees(</span>
  98 |     | <span class='neutral'>        uint128 synthMarketId</span>
  99 |     | <span class='neutral'>    )</span>
 100 |     | <span class='neutral'>        external</span>
 101 |     | <span class='neutral'>        returns (uint256 atomicFixedFee, uint256 asyncFixedFee, int256 wrapFee, int256 unwrapFee);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @notice sets the atomic fixed fee for a given market</span>
 105 |     | <span class='neutral'>     * @dev only marketOwner can set the fee</span>
 106 |     | <span class='neutral'>     * @param synthMarketId Id of the market the fee applies to.</span>
 107 |     | <span class='neutral'>     * @param atomicFixedFee fixed fee amount represented in bips with 18 decimals.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    function setAtomicFixedFee(uint128 synthMarketId, uint256 atomicFixedFee) external;</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @notice sets the async fixed fee for a given market</span>
 113 |     | <span class='neutral'>     * @dev only marketOwner can set the fee</span>
 114 |     | <span class='neutral'>     * @param synthMarketId Id of the market the fee applies to.</span>
 115 |     | <span class='neutral'>     * @param asyncFixedFee fixed fee amount represented in bips with 18 decimals.</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'>    function setAsyncFixedFee(uint128 synthMarketId, uint256 asyncFixedFee) external;</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @notice sets the skew scale for a given market</span>
 121 |     | <span class='neutral'>     * @dev only marketOwner can set the skew scale</span>
 122 |     | <span class='neutral'>     * @param synthMarketId Id of the market the skew scale applies to.</span>
 123 |     | <span class='neutral'>     * @param skewScale max amount of synth which makes the skew 100%. the fee is derived as a % of the max value.  100% premium means outstanding synth == skewScale.</span>
 124 |     | <span class='neutral'>     */</span>
 125 |     | <span class='neutral'>    function setMarketSkewScale(uint128 synthMarketId, uint256 skewScale) external;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /**</span>
 128 |     | <span class='neutral'>     * @notice gets the skew scale for a given market</span>
 129 |     | <span class='neutral'>     * @param synthMarketId Id of the market the skew scale applies to.</span>
 130 |     | <span class='neutral'>     * @return skewScale max amount of synth which makes the skew 100%. the fee is derived as a % of the max value.  100% premium means outstanding synth == skewScale.</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    function getMarketSkewScale(uint128 synthMarketId) external view returns (uint256 skewScale);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /**</span>
 135 |     | <span class='neutral'>     * @notice sets the market utilization fee for a given market</span>
 136 |     | <span class='neutral'>     * @dev only marketOwner can set the fee</span>
 137 |     | <span class='neutral'>     * @dev 100% utilization means the fee is 0.  120% utilization means the fee is 20% * this fee rate (in bips).</span>
 138 |     | <span class='neutral'>     * @param synthMarketId Id of the market the utilization fee applies to.</span>
 139 |     | <span class='neutral'>     * @param utilizationFeeRate the rate is represented in bips with 18 decimals and is the rate at which fee increases based on the % above 100% utilization of the delegated collateral for the market.</span>
 140 |     | <span class='neutral'>     */</span>
 141 |     | <span class='neutral'>    function setMarketUtilizationFees(uint128 synthMarketId, uint256 utilizationFeeRate) external;</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @notice gets the market utilization fee for a given market</span>
 145 |     | <span class='neutral'>     * @dev 100% utilization means the fee is 0.  120% utilization means the fee is 20% * this fee rate (in bips).</span>
 146 |     | <span class='neutral'>     * @param synthMarketId Id of the market the utilization fee applies to.</span>
 147 |     | <span class='neutral'>     * @return utilizationFeeRate the rate is represented in bips with 18 decimals and is the rate at which fee increases based on the % above 100% utilization of the delegated collateral for the market.</span>
 148 |     | <span class='neutral'>     */</span>
 149 |     | <span class='neutral'>    function getMarketUtilizationFees(</span>
 150 |     | <span class='neutral'>        uint128 synthMarketId</span>
 151 |     | <span class='neutral'>    ) external view returns (uint256 utilizationFeeRate);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /**</span>
 154 |     | <span class='neutral'>     * @notice sets the collateral leverage for a given market</span>
 155 |     | <span class='neutral'>     * @dev only marketOwner can set the leverage</span>
 156 |     | <span class='neutral'>     * @dev this leverage value is a value applied to delegated collateral which is compared to outstanding synth to determine utilization of market, and locked amounts</span>
 157 |     | <span class='neutral'>     * @param synthMarketId Id of the market the collateral leverage applies to.</span>
 158 |     | <span class='neutral'>     * @param collateralLeverage the leverage is represented as % with 18 decimals. 1 = 1x leverage</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    function setCollateralLeverage(uint128 synthMarketId, uint256 collateralLeverage) external;</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /**</span>
 163 |     | <span class='neutral'>     * @notice gets the collateral leverage for a given market</span>
 164 |     | <span class='neutral'>     * @dev this leverage value is a value applied to delegated collateral which is compared to outstanding synth to determine utilization of market, and locked amounts</span>
 165 |     | <span class='neutral'>     * @param synthMarketId Id of the market the collateral leverage applies to.</span>
 166 |     | <span class='neutral'>     * @return collateralLeverage the leverage is represented as % with 18 decimals. 1 = 1x leverage</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='neutral'>    function getCollateralLeverage(</span>
 169 |     | <span class='neutral'>        uint128 synthMarketId</span>
 170 |     | <span class='neutral'>    ) external view returns (uint256 collateralLeverage);</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @notice sets the fixed fee for a given market and transactor</span>
 174 |     | <span class='neutral'>     * @dev overrides both the atomic and async fixed fees</span>
 175 |     | <span class='neutral'>     * @dev only marketOwner can set the fee</span>
 176 |     | <span class='neutral'>     * @dev especially useful for direct integrations where configured traders get a discount</span>
 177 |     | <span class='neutral'>     * @param synthMarketId Id of the market the custom transactor fee applies to.</span>
 178 |     | <span class='neutral'>     * @param transactor address of the trader getting discounted fees.</span>
 179 |     | <span class='neutral'>     * @param fixedFeeAmount the fixed fee applying to the provided transactor.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='neutral'>    function setCustomTransactorFees(</span>
 182 |     | <span class='neutral'>        uint128 synthMarketId,</span>
 183 |     | <span class='neutral'>        address transactor,</span>
 184 |     | <span class='neutral'>        uint256 fixedFeeAmount</span>
 185 |     | <span class='neutral'>    ) external;</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @notice gets the fixed fee for a given market and transactor</span>
 189 |     | <span class='neutral'>     * @dev overrides both the atomic and async fixed fees</span>
 190 |     | <span class='neutral'>     * @dev especially useful for direct integrations where configured traders get a discount</span>
 191 |     | <span class='neutral'>     * @param synthMarketId Id of the market the custom transactor fee applies to.</span>
 192 |     | <span class='neutral'>     * @param transactor address of the trader getting discounted fees.</span>
 193 |     | <span class='neutral'>     * @return fixedFeeAmount the fixed fee applying to the provided transactor.</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='neutral'>    function getCustomTransactorFees(</span>
 196 |     | <span class='neutral'>        uint128 synthMarketId,</span>
 197 |     | <span class='neutral'>        address transactor</span>
 198 |     | <span class='neutral'>    ) external view returns (uint256 fixedFeeAmount);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /**</span>
 201 |     | <span class='neutral'>     * @notice sets a custom fee collector for a given market</span>
 202 |     | <span class='neutral'>     * @dev only marketOwner can set the fee collector</span>
 203 |     | <span class='neutral'>     * @dev a use case here would be if the market owner wants to collect the fees via this contract and distribute via rewards distributor to SNX holders for example.</span>
 204 |     | <span class='neutral'>     * @dev if fee collector is not set, the fees are deposited into the market manager.</span>
 205 |     | <span class='neutral'>     * @param synthMarketId Id of the market the fee collector applies to.</span>
 206 |     | <span class='neutral'>     * @param feeCollector address of the fee collector inheriting the IFeeCollector interface.</span>
 207 |     | <span class='neutral'>     */</span>
 208 |     | <span class='neutral'>    function setFeeCollector(uint128 synthMarketId, address feeCollector) external;</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    /**</span>
 211 |     | <span class='neutral'>     * @notice gets a custom fee collector for a given market</span>
 212 |     | <span class='neutral'>     * @param synthMarketId Id of the market the fee collector applies to.</span>
 213 |     | <span class='neutral'>     * @return feeCollector address of the fee collector inheriting the IFeeCollector interface.</span>
 214 |     | <span class='neutral'>     */</span>
 215 |     | <span class='neutral'>    function getFeeCollector(uint128 synthMarketId) external view returns (address feeCollector);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /**</span>
 218 |     | <span class='neutral'>     * @notice sets wrapper related fees.</span>
 219 |     | <span class='neutral'>     * @dev only marketOwner can set the wrapper fees</span>
 220 |     | <span class='neutral'>     * @dev fees can be negative.  this is a way to unwind the wrapper if needed by providing incentives.</span>
 221 |     | <span class='neutral'>     * @param synthMarketId Id of the market the wrapper fees apply to.</span>
 222 |     | <span class='neutral'>     * @param wrapFee wrapping fee in %, 18 decimals. Can be negative.</span>
 223 |     | <span class='neutral'>     * @param unwrapFee unwrapping fee in %, 18 decimals. Can be negative.</span>
 224 |     | <span class='neutral'>     */</span>
 225 |     | <span class='neutral'>    function setWrapperFees(uint128 synthMarketId, int256 wrapFee, int256 unwrapFee) external;</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    /**</span>
 228 |     | <span class='neutral'>     * @notice Update the referral share percentage for a given market</span>
 229 |     | <span class='neutral'>     * @param marketId id of the market</span>
 230 |     | <span class='neutral'>     * @param referrer The address of the referrer</span>
 231 |     | <span class='neutral'>     * @param sharePercentage The new share percentage for the referrer</span>
 232 |     | <span class='neutral'>     */</span>
 233 |     | <span class='neutral'>    function updateReferrerShare(</span>
 234 |     | <span class='neutral'>        uint128 marketId,</span>
 235 |     | <span class='neutral'>        address referrer,</span>
 236 |     | <span class='neutral'>        uint256 sharePercentage</span>
 237 |     | <span class='neutral'>    ) external;</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /**</span>
 240 |     | <span class='neutral'>     * @notice get the referral share percentage for a given market</span>
 241 |     | <span class='neutral'>     * @param marketId id of the market</span>
 242 |     | <span class='neutral'>     * @param referrer The address of the referrer</span>
 243 |     | <span class='neutral'>     * @return sharePercentage The new share percentage for the referrer</span>
 244 |     | <span class='neutral'>     */</span>
 245 |     | <span class='neutral'>    function getReferrerShare(</span>
 246 |     | <span class='neutral'>        uint128 marketId,</span>
 247 |     | <span class='neutral'>        address referrer</span>
 248 |     | <span class='neutral'>    ) external view returns (uint256 sharePercentage);</span>
 249 |     | <span class='neutral'>}</span>
 250 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/ISpotMarketFactoryModule.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IMarket} from &quot;@synthetixio/main/contracts/interfaces/external/IMarket.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ISynthetixSystem} from &quot;./external/ISynthetixSystem.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Price} from &quot;../storage/Price.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @title Module for spot market factory</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface ISpotMarketFactoryModule is IMarket {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @notice Thrown when an address tries to accept market ownership but has not been nominated.</span>
  14 |     | <span class='neutral'>     * @param addr The address that is trying to accept ownership.</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    error NotNominated(address addr);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @notice Thrown when createSynth is called with zero-address synth owner</span>
  20 |     | <span class='neutral'>     */</span>
  21 |     | <span class='neutral'>    error InvalidMarketOwner();</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @notice Gets fired when the synthetix is set</span>
  25 |     | <span class='neutral'>     * @param synthetix address of the synthetix core contract</span>
  26 |     | <span class='neutral'>     * @param usdTokenAddress address of the USDToken contract</span>
  27 |     | <span class='neutral'>     * @param oracleManager address of the Oracle Manager contract</span>
  28 |     | <span class='neutral'>     */</span>
  29 |     | <span class='neutral'>    event SynthetixSystemSet(address synthetix, address usdTokenAddress, address oracleManager);</span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @notice Gets fired when the synth implementation is set</span>
  32 |     | <span class='neutral'>     * @param synthImplementation address of the synth implementation</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    event SynthImplementationSet(address synthImplementation);</span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @notice Gets fired when the synth is registered as a market.</span>
  37 |     | <span class='neutral'>     * @param synthMarketId Id of the synth market that was created</span>
  38 |     | <span class='neutral'>     * @param synthTokenAddress address of the newly created synth token</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    event SynthRegistered(uint256 indexed synthMarketId, address synthTokenAddress);</span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @notice Gets fired when the synth&#39;s implementation is updated on the corresponding proxy.</span>
  43 |     | <span class='neutral'>     * @param proxy the synth proxy servicing the latest implementation</span>
  44 |     | <span class='neutral'>     * @param implementation the latest implementation of the synth</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    event SynthImplementationUpgraded(</span>
  47 |     | <span class='neutral'>        uint256 indexed synthMarketId,</span>
  48 |     | <span class='neutral'>        address indexed proxy,</span>
  49 |     | <span class='neutral'>        address implementation</span>
  50 |     | <span class='neutral'>    );</span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @notice Gets fired when the market&#39;s price feeds are updated, compatible with oracle manager</span>
  53 |     | <span class='neutral'>     * @param buyFeedId the oracle manager feed id for the buy price</span>
  54 |     | <span class='neutral'>     * @param sellFeedId the oracle manager feed id for the sell price</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    event SynthPriceDataUpdated(</span>
  57 |     | <span class='neutral'>        uint256 indexed synthMarketId,</span>
  58 |     | <span class='neutral'>        bytes32 indexed buyFeedId,</span>
  59 |     | <span class='neutral'>        bytes32 indexed sellFeedId,</span>
  60 |     | <span class='neutral'>        uint256 strictStalenessTolerance</span>
  61 |     | <span class='neutral'>    );</span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @notice Gets fired when the market&#39;s price feeds are updated, compatible with oracle manager</span>
  64 |     | <span class='neutral'>     * @param marketId Id of the synth market</span>
  65 |     | <span class='neutral'>     * @param rate the new decay rate (1e16 means 1% decay per year)</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='neutral'>    event DecayRateUpdated(uint128 indexed marketId, uint256 rate);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @notice Emitted when an address has been nominated.</span>
  71 |     | <span class='neutral'>     * @param marketId id of the market</span>
  72 |     | <span class='neutral'>     * @param newOwner The address that has been nominated.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='neutral'>    event MarketOwnerNominated(uint128 indexed marketId, address newOwner);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @notice Emitted when market nominee renounces nomination.</span>
  78 |     | <span class='neutral'>     * @param marketId id of the market</span>
  79 |     | <span class='neutral'>     * @param nominee The address that has been nominated.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    event MarketNominationRenounced(uint128 indexed marketId, address nominee);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @notice Emitted when the owner of the market has changed.</span>
  85 |     | <span class='neutral'>     * @param marketId id of the market</span>
  86 |     | <span class='neutral'>     * @param oldOwner The previous owner of the market.</span>
  87 |     | <span class='neutral'>     * @param newOwner The new owner of the market.</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    event MarketOwnerChanged(uint128 indexed marketId, address oldOwner, address newOwner);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @notice Sets the v3 synthetix core system.</span>
  93 |     | <span class='neutral'>     * @dev Pulls in the USDToken and oracle manager from the synthetix core system and sets those appropriately.</span>
  94 |     | <span class='neutral'>     * @param synthetix synthetix v3 core system address</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='neutral'>    function setSynthetix(ISynthetixSystem synthetix) external;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @notice When a new synth is created, this is the erc20 implementation that is used.</span>
 100 |     | <span class='neutral'>     * @param synthImplementation erc20 implementation address</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function setSynthImplementation(address synthImplementation) external;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /**</span>
 105 |     | <span class='neutral'>     * @notice Creates a new synth market with synthetix v3 core system via market manager</span>
 106 |     | <span class='neutral'>     * @dev The synth is created using the initial synth implementation and creates a proxy for future upgrades of the synth implementation.</span>
 107 |     | <span class='neutral'>     * @dev Sets up the market owner who can update configuration for the synth.</span>
 108 |     | <span class='neutral'>     * @param tokenName name of synth (i.e Synthetix ETH)</span>
 109 |     | <span class='neutral'>     * @param tokenSymbol symbol of synth (i.e snxETH)</span>
 110 |     | <span class='neutral'>     * @param synthOwner owner of the market that&#39;s created.</span>
 111 |     | <span class='neutral'>     * @return synthMarketId id of the synth market that was created</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='neutral'>    function createSynth(</span>
 114 |     | <span class='neutral'>        string memory tokenName,</span>
 115 |     | <span class='neutral'>        string memory tokenSymbol,</span>
 116 |     | <span class='neutral'>        address synthOwner</span>
 117 |     | <span class='neutral'>    ) external returns (uint128 synthMarketId);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @notice Get the proxy address of the synth for the provided marketId</span>
 121 |     | <span class='neutral'>     * @dev Uses associated systems module to retrieve the token address.</span>
 122 |     | <span class='neutral'>     * @param marketId id of the market</span>
 123 |     | <span class='neutral'>     * @return synthAddress address of the proxy for the synth</span>
 124 |     | <span class='neutral'>     */</span>
 125 |     | <span class='neutral'>    function getSynth(uint128 marketId) external view returns (address synthAddress);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /**</span>
 128 |     | <span class='neutral'>     * @notice Get the implementation address of the synth for the provided marketId.</span>
 129 |     | <span class='neutral'>     * This address should not be used directly--use `getSynth` instead</span>
 130 |     | <span class='neutral'>     * @dev Uses associated systems module to retrieve the token address.</span>
 131 |     | <span class='neutral'>     * @param marketId id of the market</span>
 132 |     | <span class='neutral'>     * @return implAddress address of the proxy for the synth</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function getSynthImpl(uint128 marketId) external view returns (address implAddress);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /**</span>
 137 |     | <span class='neutral'>     * @notice Update the price data for a given market.</span>
 138 |     | <span class='neutral'>     * @dev Only the market owner can call this function.</span>
 139 |     | <span class='neutral'>     * @param marketId id of the market</span>
 140 |     | <span class='neutral'>     * @param buyFeedId the oracle manager buy feed node id</span>
 141 |     | <span class='neutral'>     * @param sellFeedId the oracle manager sell feed node id</span>
 142 |     | <span class='neutral'>     * @param strictPriceStalenessTolerance configurable price staleness tolerance used for transacting</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='neutral'>    function updatePriceData(</span>
 145 |     | <span class='neutral'>        uint128 marketId,</span>
 146 |     | <span class='neutral'>        bytes32 buyFeedId,</span>
 147 |     | <span class='neutral'>        bytes32 sellFeedId,</span>
 148 |     | <span class='neutral'>        uint256 strictPriceStalenessTolerance</span>
 149 |     | <span class='neutral'>    ) external;</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    /**</span>
 152 |     | <span class='neutral'>     * @notice Gets the price data for a given market.</span>
 153 |     | <span class='neutral'>     * @dev Only the market owner can call this function.</span>
 154 |     | <span class='neutral'>     * @param marketId id of the market</span>
 155 |     | <span class='neutral'>     * @return buyFeedId the oracle manager buy feed node id</span>
 156 |     | <span class='neutral'>     * @return sellFeedId the oracle manager sell feed node id</span>
 157 |     | <span class='neutral'>     * @return strictPriceStalenessTolerance configurable price staleness tolerance used for transacting</span>
 158 |     | <span class='neutral'>     */</span>
 159 |     | <span class='neutral'>    function getPriceData(</span>
 160 |     | <span class='neutral'>        uint128 marketId</span>
 161 |     | <span class='neutral'>    )</span>
 162 |     | <span class='neutral'>        external</span>
 163 |     | <span class='neutral'>        view</span>
 164 |     | <span class='neutral'>        returns (bytes32 buyFeedId, bytes32 sellFeedId, uint256 strictPriceStalenessTolerance);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /**</span>
 167 |     | <span class='neutral'>     * @notice upgrades the synth implementation to the current implementation for the specified market.</span>
 168 |     | <span class='neutral'>     * Anyone who is willing and able to spend the gas can call this method.</span>
 169 |     | <span class='neutral'>     * @dev The synth implementation is upgraded via the proxy.</span>
 170 |     | <span class='neutral'>     * @param marketId id of the market</span>
 171 |     | <span class='neutral'>     */</span>
 172 |     | <span class='neutral'>    function upgradeSynthImpl(uint128 marketId) external;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @notice Allows market to adjust decay rate of the synth</span>
 176 |     | <span class='neutral'>     * @param marketId the market to update the synth decay rate for</span>
 177 |     | <span class='neutral'>     * @param rate APY to decay of the synth to decay by, as a 18 decimal ratio</span>
 178 |     | <span class='neutral'>     */</span>
 179 |     | <span class='neutral'>    function setDecayRate(uint128 marketId, uint256 rate) external;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    /**</span>
 182 |     | <span class='neutral'>     * @notice Allows the current market owner to nominate a new owner.</span>
 183 |     | <span class='neutral'>     * @dev The nominated owner will have to call `acceptOwnership` in a separate transaction in order to finalize the action and become the new contract owner.</span>
 184 |     | <span class='neutral'>     * @param synthMarketId synth market id value</span>
 185 |     | <span class='neutral'>     * @param newNominatedOwner The address that is to become nominated.</span>
 186 |     | <span class='neutral'>     */</span>
 187 |     | <span class='neutral'>    function nominateMarketOwner(uint128 synthMarketId, address newNominatedOwner) external;</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @notice Allows a nominated address to accept ownership of the market.</span>
 191 |     | <span class='neutral'>     * @dev Reverts if the caller is not nominated.</span>
 192 |     | <span class='neutral'>     * @param synthMarketId synth market id value</span>
 193 |     | <span class='neutral'>     */</span>
 194 |     | <span class='neutral'>    function acceptMarketOwnership(uint128 synthMarketId) external;</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    /**</span>
 197 |     | <span class='neutral'>     * @notice Allows a nominated address to renounce ownership of the market.</span>
 198 |     | <span class='neutral'>     * @dev Reverts if the caller is not nominated.</span>
 199 |     | <span class='neutral'>     * @param synthMarketId synth market id value</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='neutral'>    function renounceMarketNomination(uint128 synthMarketId) external;</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /**</span>
 204 |     | <span class='neutral'>     * @notice Allows the market owner to renounce his ownership.</span>
 205 |     | <span class='neutral'>     * @dev Reverts if the caller is not the owner.</span>
 206 |     | <span class='neutral'>     * @param synthMarketId synth market id value</span>
 207 |     | <span class='neutral'>     */</span>
 208 |     | <span class='neutral'>    function renounceMarketOwnership(uint128 synthMarketId) external;</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    /**</span>
 211 |     | <span class='neutral'>     * @notice Returns market owner.</span>
 212 |     | <span class='neutral'>     * @param synthMarketId synth market id value</span>
 213 |     | <span class='neutral'>     */</span>
 214 |     | <span class='neutral'>    function getMarketOwner(uint128 synthMarketId) external view returns (address);</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    /**</span>
 217 |     | <span class='neutral'>     * @notice Returns nominated market owner.</span>
 218 |     | <span class='neutral'>     * @param synthMarketId synth market id value</span>
 219 |     | <span class='neutral'>     */</span>
 220 |     | <span class='neutral'>    function getNominatedMarketOwner(uint128 synthMarketId) external view returns (address);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /**</span>
 223 |     | <span class='neutral'>     * @notice Get current price based on type of transaction and tolerance</span>
 224 |     | <span class='neutral'>     * @param marketId synth market id value</span>
 225 |     | <span class='neutral'>     * @param transactionType type of txn</span>
 226 |     | <span class='neutral'>     * @param priceTolerance staleness tolerance to use for price</span>
 227 |     | <span class='neutral'>     * @return price current price of the synth</span>
 228 |     | <span class='neutral'>     */</span>
 229 |     | <span class='neutral'>    function indexPrice(</span>
 230 |     | <span class='neutral'>        uint128 marketId,</span>
 231 |     | <span class='neutral'>        uint128 transactionType,</span>
 232 |     | <span class='neutral'>        Price.Tolerance priceTolerance</span>
 233 |     | <span class='neutral'>    ) external view returns (uint256 price);</span>
 234 |     | <span class='neutral'>}</span>
 235 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/external/ISynthetixSystem.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-modules/contracts/interfaces/IAssociatedSystemsModule.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@synthetixio/main/contracts/interfaces/IMarketManagerModule.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@synthetixio/main/contracts/interfaces/IMarketCollateralModule.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@synthetixio/main/contracts/interfaces/IUtilsModule.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>// solhint-disable no-empty-blocks</span>
 10 |     | <span class='neutral'>interface ISynthetixSystem is</span>
 11 |     | <span class='neutral'>    IAssociatedSystemsModule,</span>
 12 |     | <span class='neutral'>    IMarketCollateralModule,</span>
 13 |     | <span class='neutral'>    IMarketManagerModule,</span>
 14 |     | <span class='neutral'>    IUtilsModule</span>
 15 |     | <span class='neutral'>{}</span>
 16 |     | <span class='neutral'>// solhint-enable no-empty-blocks</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/storage/OrderFees.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {SafeCastU256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @notice  A convenience library that includes a Data struct which is used to track fees across different trade types</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library OrderFees {</span>
 10 |     | <span class='neutral'>    using SafeCastU256 for uint256;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct Data {</span>
 13 |     | <span class='neutral'>        uint256 fixedFees;</span>
 14 |     | <span class='neutral'>        uint256 utilizationFees;</span>
 15 |     | <span class='neutral'>        int256 skewFees;</span>
 16 |     | <span class='neutral'>        int256 wrapperFees;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function total(Data memory self) internal pure returns (int256 amount) {</span>
 20 |     | <span class='neutral'>        return</span>
 21 |     | <span class='neutral'>            self.fixedFees.toInt() +</span>
 22 |     | <span class='neutral'>            self.utilizationFees.toInt() +</span>
 23 |     | <span class='neutral'>            self.skewFees +</span>
 24 |     | <span class='neutral'>            self.wrapperFees;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/storage/Price.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {INodeModule} from &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
   5 |     | <span class='neutral'>import {NodeOutput} from &quot;@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol&quot;;</span>
   6 |     | <span class='neutral'>import {DecimalMath} from &quot;@synthetixio/core-contracts/contracts/utils/DecimalMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import {SafeCastI256} from &quot;@synthetixio/core-contracts/contracts/utils/SafeCast.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SpotMarketFactory} from &quot;./SpotMarketFactory.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Transaction} from &quot;../utils/TransactionUtil.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @title Price storage for a specific synth market.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>library Price {</span>
  15 |     | <span class='neutral'>    using DecimalMath for int256;</span>
  16 |     | <span class='neutral'>    using DecimalMath for uint256;</span>
  17 |     | <span class='neutral'>    using SafeCastI256 for int256;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    enum Tolerance {</span>
  20 |     | <span class='neutral'>        DEFAULT,</span>
  21 |     | <span class='neutral'>        STRICT</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct Data {</span>
  25 |     | <span class='neutral'>        /**</span>
  26 |     | <span class='neutral'>         * @dev The oracle manager node id used for buy transactions.</span>
  27 |     | <span class='neutral'>         */</span>
  28 |     | <span class='neutral'>        bytes32 buyFeedId;</span>
  29 |     | <span class='neutral'>        /**</span>
  30 |     | <span class='neutral'>         * @dev The oracle manager node id used for all non-buy transactions.</span>
  31 |     | <span class='neutral'>         * @dev also used to for calculating reported debt</span>
  32 |     | <span class='neutral'>         */</span>
  33 |     | <span class='neutral'>        bytes32 sellFeedId;</span>
  34 |     | <span class='neutral'>        /**</span>
  35 |     | <span class='neutral'>         * @dev configurable staleness tolerance to use when fetching prices.</span>
  36 |     | <span class='neutral'>         */</span>
  37 |     | <span class='neutral'>        uint256 strictStalenessTolerance;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function load(uint128 marketId) internal pure returns (Data storage price) {</span>
  41 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.spot-market.Price&quot;, marketId));</span>
  42 |     | <span class='neutral'>        assembly {</span>
  43 |     | <span class='neutral'>            price.slot := s</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    function getCurrentPrice(</span>
  48 |     | <span class='neutral'>        uint128 marketId,</span>
  49 |     | <span class='neutral'>        Transaction.Type transactionType,</span>
  50 |     | <span class='neutral'>        Tolerance priceTolerance</span>
  51 |     | <span class='neutral'>    ) internal view returns (uint256 price) {</span>
  52 |     | <span class='neutral'>        Data storage self = load(marketId);</span>
  53 |     | <span class='neutral'>        SpotMarketFactory.Data storage factory = SpotMarketFactory.load();</span>
  54 |     | <span class='neutral'>        bytes32 feedId = Transaction.isBuy(transactionType) ? self.buyFeedId : self.sellFeedId;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        NodeOutput.Data memory output;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        if (priceTolerance == Tolerance.STRICT) {</span>
  59 |     | <span class='neutral'>            bytes32[] memory runtimeKeys = new bytes32[](1);</span>
  60 |     | <span class='neutral'>            bytes32[] memory runtimeValues = new bytes32[](1);</span>
  61 |     | <span class='neutral'>            runtimeKeys[0] = bytes32(&quot;stalenessTolerance&quot;);</span>
  62 |     | <span class='neutral'>            runtimeValues[0] = bytes32(self.strictStalenessTolerance);</span>
  63 |     | <span class='neutral'>            output = INodeModule(factory.oracle).processWithRuntime(</span>
  64 |     | <span class='neutral'>                feedId,</span>
  65 |     | <span class='neutral'>                runtimeKeys,</span>
  66 |     | <span class='neutral'>                runtimeValues</span>
  67 |     | <span class='neutral'>            );</span>
  68 |     | <span class='neutral'>        } else {</span>
  69 |     | <span class='neutral'>            output = INodeModule(factory.oracle).process(feedId);</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        price = output.price.toUint();</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Updates price feeds.  Function resides in SpotMarketFactory to update these values.</span>
  77 |     | <span class='neutral'>     * Only market owner can update these values.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='neutral'>    function update(</span>
  80 |     | <span class='neutral'>        Data storage self,</span>
  81 |     | <span class='neutral'>        bytes32 buyFeedId,</span>
  82 |     | <span class='neutral'>        bytes32 sellFeedId,</span>
  83 |     | <span class='neutral'>        uint256 strictStalenessTolerance</span>
  84 |     | <span class='neutral'>    ) internal {</span>
  85 |     | <span class='neutral'>        self.buyFeedId = buyFeedId;</span>
  86 |     | <span class='neutral'>        self.sellFeedId = sellFeedId;</span>
  87 |     | <span class='neutral'>        self.strictStalenessTolerance = strictStalenessTolerance;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Utility function that returns the amount denominated with 18 decimals of precision.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function scale(int256 amount, uint256 decimals) internal pure returns (int256 scaledAmount) {</span>
  94 |     | <span class='neutral'>        return (decimals &gt; 18 ? amount.downscale(decimals - 18) : amount.upscale(18 - decimals));</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @dev Utility function that receive amount with 18 decimals</span>
  99 |     | <span class='neutral'>     * returns the amount denominated with number of decimals as arg of 18.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function scaleTo(int256 amount, uint256 decimals) internal pure returns (int256 scaledAmount) {</span>
 102 |     | <span class='neutral'>        return (decimals &gt; 18 ? amount.upscale(decimals - 18) : amount.downscale(18 - decimals));</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'>}</span>
 105 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/storage/SpotMarketFactory.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ITokenModule} from &quot;@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol&quot;;</span>
  6 |     | <span class='neutral'>import {INodeModule} from &quot;@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol&quot;;</span>
  7 |     | <span class='neutral'>import {ISynthetixSystem} from &quot;../interfaces/external/ISynthetixSystem.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title Main factory library that registers synths.  Also houses global configuration for all synths.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>library SpotMarketFactory {</span>
 13 |     | <span class='neutral'>    bytes32 private constant _SLOT_SPOT_MARKET_FACTORY =</span>
 14 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.spot-market.SpotMarketFactory&quot;));</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    error OnlyMarketOwner(address marketOwner, address sender);</span>
 17 |     | <span class='neutral'>    error InvalidMarket(uint128 marketId);</span>
 18 |     | <span class='neutral'>    error InvalidSynthImplementation(uint256 synthImplementation);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    struct Data {</span>
 21 |     | <span class='neutral'>        /**</span>
 22 |     | <span class='neutral'>         * @dev snxUSD token address</span>
 23 |     | <span class='neutral'>         */</span>
 24 |     | <span class='neutral'>        ITokenModule usdToken;</span>
 25 |     | <span class='neutral'>        /**</span>
 26 |     | <span class='neutral'>         * @dev oracle manager address used for price feeds</span>
 27 |     | <span class='neutral'>         */</span>
 28 |     | <span class='neutral'>        INodeModule oracle;</span>
 29 |     | <span class='neutral'>        /**</span>
 30 |     | <span class='neutral'>         * @dev Synthetix core v3 proxy</span>
 31 |     | <span class='neutral'>         */</span>
 32 |     | <span class='neutral'>        ISynthetixSystem synthetix;</span>
 33 |     | <span class='neutral'>        /**</span>
 34 |     | <span class='neutral'>         * @dev erc20 synth implementation address.  associated systems creates a proxy backed by this implementation.</span>
 35 |     | <span class='neutral'>         */</span>
 36 |     | <span class='neutral'>        address synthImplementation;</span>
 37 |     | <span class='neutral'>        /**</span>
 38 |     | <span class='neutral'>         * @dev mapping of marketId to marketOwner</span>
 39 |     | <span class='neutral'>         */</span>
 40 |     | <span class='neutral'>        mapping(uint128 =&gt; address) marketOwners;</span>
 41 |     | <span class='neutral'>        /**</span>
 42 |     | <span class='neutral'>         * @dev mapping of marketId to marketNominatedOwner</span>
 43 |     | <span class='neutral'>         */</span>
 44 |     | <span class='neutral'>        mapping(uint128 =&gt; address) nominatedMarketOwners;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function load() internal pure returns (Data storage spotMarketFactory) {</span>
 48 |     | <span class='neutral'>        bytes32 s = _SLOT_SPOT_MARKET_FACTORY;</span>
 49 |     | <span class='neutral'>        assembly {</span>
 50 |     | <span class='neutral'>            spotMarketFactory.slot := s</span>
 51 |     | <span class='neutral'>        }</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @notice ensures synth implementation is set before creating synth</span>
 56 |     | <span class='neutral'>     */</span>
 57 |     | <span class='neutral'>    function checkSynthImplemention(Data storage self) internal view {</span>
 58 |     | <span class='neutral'>        if (self.synthImplementation == address(0)) {</span>
 59 |     | <span class='neutral'>            revert InvalidSynthImplementation(0);</span>
 60 |     | <span class='neutral'>        }</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    /**</span>
 64 |     | <span class='neutral'>     * @notice only owner of market passes check, otherwise reverts</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function onlyMarketOwner(Data storage self, uint128 marketId) internal view {</span>
 67 |     | <span class='neutral'>        address marketOwner = self.marketOwners[marketId];</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>        if (marketOwner != ERC2771Context._msgSender()) {</span>
 70 |     | <span class='neutral'>            revert OnlyMarketOwner(marketOwner, ERC2771Context._msgSender());</span>
 71 |     | <span class='neutral'>        }</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /**</span>
 75 |     | <span class='neutral'>     * @notice validates market id by checking that an owner exists for the market</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function validateMarket(Data storage self, uint128 marketId) internal view {</span>
 78 |     | <span class='neutral'>        if (self.marketOwners[marketId] == address(0)) {</span>
 79 |     | <span class='neutral'>            revert InvalidMarket(marketId);</span>
 80 |     | <span class='neutral'>        }</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='neutral'>    /**</span>
 84 |     | <span class='neutral'>     * @dev first creates an allowance entry in usdToken for market manager, then deposits snxUSD amount into mm.</span>
 85 |     | <span class='neutral'>     */</span>
 86 |     | <span class='neutral'>    function depositToMarketManager(Data storage self, uint128 marketId, uint256 amount) internal {</span>
 87 |     | <span class='neutral'>        self.usdToken.approve(address(this), amount);</span>
 88 |     | <span class='neutral'>        self.synthetix.depositMarketUsd(marketId, address(this), amount);</span>
 89 |     | <span class='neutral'>    }</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/utils/TransactionUtil.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title Transaction types supported by the spot market system</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='unexecuted'>library Transaction {</span>
  8 |     | <span class='neutral'>    error InvalidAsyncTransactionType(Type transactionType);</span>
  9 |     | <span class='neutral'>    error InvalidTransactionTypeIndex(uint128 txnType);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    enum Type {</span>
 12 |     | <span class='neutral'>        NULL, // reserved for 0 (default value)</span>
 13 |     | <span class='neutral'>        BUY,</span>
 14 |     | <span class='neutral'>        SELL,</span>
 15 |     | <span class='neutral'>        ASYNC_BUY,</span>
 16 |     | <span class='neutral'>        ASYNC_SELL,</span>
 17 |     | <span class='neutral'>        WRAP,</span>
 18 |     | <span class='neutral'>        UNWRAP</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function loadValidTransactionType(uint128 txnType) internal pure returns (Type) {</span>
 22 |     | <span class='neutral'>        // solhint-disable-next-line numcast/safe-cast</span>
 23 |     | <span class='neutral'>        uint128 txnTypeMax = uint128(Type.UNWRAP);</span>
 24 |     | <span class='neutral'>        if (txnType &gt; txnTypeMax) {</span>
 25 |     | <span class='neutral'>            revert InvalidTransactionTypeIndex(txnType);</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        return Type(txnType);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function validateAsyncTransaction(Type orderType) internal pure {</span>
 32 |     | <span class='neutral'>        if (orderType != Type.ASYNC_BUY &amp;&amp; orderType != Type.ASYNC_SELL) {</span>
 33 |     | <span class='neutral'>            revert InvalidAsyncTransactionType(orderType);</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function isBuy(Type orderType) internal pure returns (bool) {</span>
 38 |     | <span class='neutral'>        return orderType == Type.BUY || orderType == Type.ASYNC_BUY;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function isSell(Type orderType) internal pure returns (bool) {</span>
 42 |     | <span class='neutral'>        return orderType == Type.SELL || orderType == Type.ASYNC_SELL;</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    function isWrapper(Type orderType) internal pure returns (bool) {</span>
 46 |     | <span class='neutral'>        return orderType == Type.WRAP || orderType == Type.UNWRAP;</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    function isAsync(Type orderType) internal pure returns (bool) {</span>
 50 |     | <span class='neutral'>        return orderType == Type.ASYNC_BUY || orderType == Type.ASYNC_SELL;</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/storage.dump.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.8.11 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol:OwnableStorage</span>
    5 |     | <span class='unexecuted'>library OwnableStorage {</span>
    6 |     | <span class='neutral'>    bytes32 private constant _SLOT_OWNABLE_STORAGE =</span>
    7 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.core-contracts.Ownable&quot;));</span>
    8 |     | <span class='neutral'>    struct Data {</span>
    9 |     | <span class='neutral'>        address owner;</span>
   10 |     | <span class='neutral'>        address nominatedOwner;</span>
   11 |     | <span class='neutral'>    }</span>
   12 |     | <span class='neutral'>    function load() internal pure returns (Data storage store) {</span>
   13 |     | <span class='neutral'>        bytes32 s = _SLOT_OWNABLE_STORAGE;</span>
   14 |     | <span class='neutral'>        assembly {</span>
   15 |     | <span class='neutral'>            store.slot := s</span>
   16 |     | <span class='neutral'>        }</span>
   17 |     | <span class='neutral'>    }</span>
   18 |     | <span class='neutral'>}</span>
   19 |     | <span class='neutral'></span>
   20 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-contracts/contracts/proxy/ProxyStorage.sol:ProxyStorage</span>
   21 |     | <span class='unexecuted'>contract ProxyStorage {</span>
   22 |     | <span class='neutral'>    bytes32 private constant _SLOT_PROXY_STORAGE =</span>
   23 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.core-contracts.Proxy&quot;));</span>
   24 |     | <span class='neutral'>    struct ProxyStore {</span>
   25 |     | <span class='neutral'>        address implementation;</span>
   26 |     | <span class='neutral'>        bool simulatingUpgrade;</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'>    function _proxyStore() internal pure returns (ProxyStore storage store) {</span>
   29 |     | <span class='neutral'>        bytes32 s = _SLOT_PROXY_STORAGE;</span>
   30 |     | <span class='neutral'>        assembly {</span>
   31 |     | <span class='neutral'>            store.slot := s</span>
   32 |     | <span class='neutral'>        }</span>
   33 |     | <span class='neutral'>    }</span>
   34 |     | <span class='neutral'>}</span>
   35 |     | <span class='neutral'></span>
   36 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-contracts/contracts/utils/DecimalMath.sol:DecimalMath</span>
   37 |     | <span class='unexecuted'>library DecimalMath {</span>
   38 |     | <span class='unexecuted'>    uint256 public constant UNIT = 1e18;</span>
   39 |     | <span class='neutral'>    int256 public constant UNIT_INT = int256(UNIT);</span>
   40 |     | <span class='unexecuted'>    uint128 public constant UNIT_UINT128 = uint128(UNIT);</span>
   41 |     | <span class='unexecuted'>    int128 public constant UNIT_INT128 = int128(UNIT_INT);</span>
   42 |     | <span class='unexecuted'>    uint256 public constant UNIT_PRECISE = 1e27;</span>
   43 |     | <span class='unexecuted'>    int256 public constant UNIT_PRECISE_INT = int256(UNIT_PRECISE);</span>
   44 |     | <span class='unexecuted'>    int128 public constant UNIT_PRECISE_INT128 = int128(UNIT_PRECISE_INT);</span>
   45 |     | <span class='unexecuted'>    uint256 public constant PRECISION_FACTOR = 9;</span>
   46 |     | <span class='neutral'>}</span>
   47 |     | <span class='neutral'></span>
   48 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-contracts/contracts/utils/ERC2771Context.sol:ERC2771Context</span>
   49 |     | <span class='unexecuted'>library ERC2771Context {</span>
   50 |     | <span class='neutral'>    address private constant TRUSTED_FORWARDER =</span>
   51 |     | <span class='neutral'>        0xE2C5658cC5C448B48141168f3e475dF8f65A1e3e;</span>
   52 |     | <span class='neutral'>}</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-contracts/contracts/utils/HeapUtil.sol:HeapUtil</span>
   55 |     | <span class='unexecuted'>library HeapUtil {</span>
   56 |     | <span class='neutral'>    uint256 private constant _ROOT_INDEX = 1;</span>
   57 |     | <span class='neutral'>    struct Data {</span>
   58 |     | <span class='neutral'>        uint128 idCount;</span>
   59 |     | <span class='neutral'>        Node[] nodes;</span>
   60 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) indices;</span>
   61 |     | <span class='neutral'>    }</span>
   62 |     | <span class='neutral'>    struct Node {</span>
   63 |     | <span class='neutral'>        uint128 id;</span>
   64 |     | <span class='neutral'>        int128 priority;</span>
   65 |     | <span class='neutral'>    }</span>
   66 |     | <span class='neutral'>}</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-contracts/contracts/utils/SetUtil.sol:SetUtil</span>
   69 |     | <span class='unexecuted'>library SetUtil {</span>
   70 |     | <span class='neutral'>    struct UintSet {</span>
   71 |     | <span class='neutral'>        Bytes32Set raw;</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'>    struct AddressSet {</span>
   74 |     | <span class='neutral'>        Bytes32Set raw;</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'>    struct Bytes32Set {</span>
   77 |     | <span class='neutral'>        bytes32[] _values;</span>
   78 |     | <span class='neutral'>        mapping(bytes32 =&gt; uint256) _positions;</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'>}</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-modules/contracts/storage/AssociatedSystem.sol:AssociatedSystem</span>
   83 |     | <span class='unexecuted'>library AssociatedSystem {</span>
   84 |     | <span class='unexecuted'>    bytes32 public constant KIND_ERC20 = &quot;erc20&quot;;</span>
   85 |     | <span class='unexecuted'>    bytes32 public constant KIND_ERC721 = &quot;erc721&quot;;</span>
   86 |     | <span class='unexecuted'>    bytes32 public constant KIND_UNMANAGED = &quot;unmanaged&quot;;</span>
   87 |     | <span class='neutral'>    struct Data {</span>
   88 |     | <span class='neutral'>        address proxy;</span>
   89 |     | <span class='neutral'>        address impl;</span>
   90 |     | <span class='neutral'>        bytes32 kind;</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'>    function load(bytes32 id) internal pure returns (Data storage store) {</span>
   93 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
   94 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.core-modules.AssociatedSystem&quot;, id)</span>
   95 |     | <span class='neutral'>        );</span>
   96 |     | <span class='neutral'>        assembly {</span>
   97 |     | <span class='neutral'>            store.slot := s</span>
   98 |     | <span class='neutral'>        }</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'>}</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>// @custom:artifact @synthetixio/core-modules/contracts/storage/FeatureFlag.sol:FeatureFlag</span>
  103 |     | <span class='unexecuted'>library FeatureFlag {</span>
  104 |     | <span class='neutral'>    struct Data {</span>
  105 |     | <span class='neutral'>        bytes32 name;</span>
  106 |     | <span class='neutral'>        bool allowAll;</span>
  107 |     | <span class='neutral'>        bool denyAll;</span>
  108 |     | <span class='neutral'>        SetUtil.AddressSet permissionedAddresses;</span>
  109 |     | <span class='neutral'>        address[] deniers;</span>
  110 |     | <span class='neutral'>    }</span>
  111 |     | <span class='neutral'>    function load(</span>
  112 |     | <span class='neutral'>        bytes32 featureName</span>
  113 |     | <span class='neutral'>    ) internal pure returns (Data storage store) {</span>
  114 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  115 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.core-modules.FeatureFlag&quot;, featureName)</span>
  116 |     | <span class='neutral'>        );</span>
  117 |     | <span class='neutral'>        assembly {</span>
  118 |     | <span class='neutral'>            store.slot := s</span>
  119 |     | <span class='neutral'>        }</span>
  120 |     | <span class='neutral'>    }</span>
  121 |     | <span class='neutral'>}</span>
  122 |     | <span class='neutral'></span>
  123 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/Account.sol:Account</span>
  124 |     | <span class='unexecuted'>library Account {</span>
  125 |     | <span class='neutral'>    struct Data {</span>
  126 |     | <span class='neutral'>        uint128 id;</span>
  127 |     | <span class='neutral'>        AccountRBAC.Data rbac;</span>
  128 |     | <span class='neutral'>        uint64 lastInteraction;</span>
  129 |     | <span class='neutral'>        uint64 __slotAvailableForFutureUse;</span>
  130 |     | <span class='neutral'>        uint128 __slot2AvailableForFutureUse;</span>
  131 |     | <span class='neutral'>        mapping(address =&gt; Collateral.Data) collaterals;</span>
  132 |     | <span class='neutral'>    }</span>
  133 |     | <span class='neutral'>    function load(uint128 id) internal pure returns (Data storage account) {</span>
  134 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.synthetix.Account&quot;, id));</span>
  135 |     | <span class='neutral'>        assembly {</span>
  136 |     | <span class='neutral'>            account.slot := s</span>
  137 |     | <span class='neutral'>        }</span>
  138 |     | <span class='neutral'>    }</span>
  139 |     | <span class='neutral'>}</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/AccountRBAC.sol:AccountRBAC</span>
  142 |     | <span class='unexecuted'>library AccountRBAC {</span>
  143 |     | <span class='neutral'>    bytes32 internal constant _ADMIN_PERMISSION = &quot;ADMIN&quot;;</span>
  144 |     | <span class='neutral'>    bytes32 internal constant _WITHDRAW_PERMISSION = &quot;WITHDRAW&quot;;</span>
  145 |     | <span class='neutral'>    bytes32 internal constant _DELEGATE_PERMISSION = &quot;DELEGATE&quot;;</span>
  146 |     | <span class='neutral'>    bytes32 internal constant _MINT_PERMISSION = &quot;MINT&quot;;</span>
  147 |     | <span class='neutral'>    bytes32 internal constant _REWARDS_PERMISSION = &quot;REWARDS&quot;;</span>
  148 |     | <span class='neutral'>    bytes32 internal constant _PERPS_MODIFY_COLLATERAL_PERMISSION =</span>
  149 |     | <span class='neutral'>        &quot;PERPS_MODIFY_COLLATERAL&quot;;</span>
  150 |     | <span class='neutral'>    bytes32 internal constant _PERPS_COMMIT_ASYNC_ORDER_PERMISSION =</span>
  151 |     | <span class='neutral'>        &quot;PERPS_COMMIT_ASYNC_ORDER&quot;;</span>
  152 |     | <span class='neutral'>    bytes32 internal constant _BURN_PERMISSION = &quot;BURN&quot;;</span>
  153 |     | <span class='neutral'>    struct Data {</span>
  154 |     | <span class='neutral'>        address owner;</span>
  155 |     | <span class='neutral'>        mapping(address =&gt; SetUtil.Bytes32Set) permissions;</span>
  156 |     | <span class='neutral'>        SetUtil.AddressSet permissionAddresses;</span>
  157 |     | <span class='neutral'>    }</span>
  158 |     | <span class='neutral'>}</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/Collateral.sol:Collateral</span>
  161 |     | <span class='unexecuted'>library Collateral {</span>
  162 |     | <span class='neutral'>    struct Data {</span>
  163 |     | <span class='neutral'>        uint256 amountAvailableForDelegationD18;</span>
  164 |     | <span class='neutral'>        SetUtil.UintSet pools;</span>
  165 |     | <span class='neutral'>        CollateralLock.Data[] locks;</span>
  166 |     | <span class='neutral'>    }</span>
  167 |     | <span class='neutral'>}</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/CollateralConfiguration.sol:CollateralConfiguration</span>
  170 |     | <span class='unexecuted'>library CollateralConfiguration {</span>
  171 |     | <span class='neutral'>    bytes32 private constant _SLOT_AVAILABLE_COLLATERALS =</span>
  172 |     | <span class='neutral'>        keccak256(</span>
  173 |     | <span class='neutral'>            abi.encode(</span>
  174 |     | <span class='neutral'>                &quot;io.synthetix.synthetix.CollateralConfiguration_availableCollaterals&quot;</span>
  175 |     | <span class='neutral'>            )</span>
  176 |     | <span class='neutral'>        );</span>
  177 |     | <span class='neutral'>    struct Data {</span>
  178 |     | <span class='neutral'>        bool depositingEnabled;</span>
  179 |     | <span class='neutral'>        uint256 issuanceRatioD18;</span>
  180 |     | <span class='neutral'>        uint256 liquidationRatioD18;</span>
  181 |     | <span class='neutral'>        uint256 liquidationRewardD18;</span>
  182 |     | <span class='neutral'>        bytes32 oracleNodeId;</span>
  183 |     | <span class='neutral'>        address tokenAddress;</span>
  184 |     | <span class='neutral'>        uint256 minDelegationD18;</span>
  185 |     | <span class='neutral'>    }</span>
  186 |     | <span class='neutral'>    function load(</span>
  187 |     | <span class='neutral'>        address token</span>
  188 |     | <span class='neutral'>    ) internal pure returns (Data storage collateralConfiguration) {</span>
  189 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  190 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.synthetix.CollateralConfiguration&quot;, token)</span>
  191 |     | <span class='neutral'>        );</span>
  192 |     | <span class='neutral'>        assembly {</span>
  193 |     | <span class='neutral'>            collateralConfiguration.slot := s</span>
  194 |     | <span class='neutral'>        }</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'>    function loadAvailableCollaterals()</span>
  197 |     | <span class='neutral'>        internal</span>
  198 |     | <span class='neutral'>        pure</span>
  199 |     | <span class='neutral'>        returns (SetUtil.AddressSet storage availableCollaterals)</span>
  200 |     | <span class='neutral'>    {</span>
  201 |     | <span class='neutral'>        bytes32 s = _SLOT_AVAILABLE_COLLATERALS;</span>
  202 |     | <span class='neutral'>        assembly {</span>
  203 |     | <span class='neutral'>            availableCollaterals.slot := s</span>
  204 |     | <span class='neutral'>        }</span>
  205 |     | <span class='neutral'>    }</span>
  206 |     | <span class='neutral'>}</span>
  207 |     | <span class='neutral'></span>
  208 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/CollateralLock.sol:CollateralLock</span>
  209 |     | <span class='unexecuted'>library CollateralLock {</span>
  210 |     | <span class='neutral'>    struct Data {</span>
  211 |     | <span class='neutral'>        uint128 amountD18;</span>
  212 |     | <span class='neutral'>        uint64 lockExpirationTime;</span>
  213 |     | <span class='neutral'>    }</span>
  214 |     | <span class='neutral'>}</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/Config.sol:Config</span>
  217 |     | <span class='unexecuted'>library Config {</span>
  218 |     | <span class='neutral'>    struct Data {</span>
  219 |     | <span class='neutral'>        uint256 __unused;</span>
  220 |     | <span class='neutral'>    }</span>
  221 |     | <span class='neutral'>}</span>
  222 |     | <span class='neutral'></span>
  223 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/Distribution.sol:Distribution</span>
  224 |     | <span class='unexecuted'>library Distribution {</span>
  225 |     | <span class='neutral'>    struct Data {</span>
  226 |     | <span class='neutral'>        uint128 totalSharesD18;</span>
  227 |     | <span class='neutral'>        int128 valuePerShareD27;</span>
  228 |     | <span class='neutral'>        mapping(bytes32 =&gt; DistributionActor.Data) actorInfo;</span>
  229 |     | <span class='neutral'>    }</span>
  230 |     | <span class='neutral'>}</span>
  231 |     | <span class='neutral'></span>
  232 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/DistributionActor.sol:DistributionActor</span>
  233 |     | <span class='unexecuted'>library DistributionActor {</span>
  234 |     | <span class='neutral'>    struct Data {</span>
  235 |     | <span class='neutral'>        uint128 sharesD18;</span>
  236 |     | <span class='neutral'>        int128 lastValuePerShareD27;</span>
  237 |     | <span class='neutral'>    }</span>
  238 |     | <span class='neutral'>}</span>
  239 |     | <span class='neutral'></span>
  240 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/Market.sol:Market</span>
  241 |     | <span class='unexecuted'>library Market {</span>
  242 |     | <span class='neutral'>    struct Data {</span>
  243 |     | <span class='neutral'>        uint128 id;</span>
  244 |     | <span class='neutral'>        address marketAddress;</span>
  245 |     | <span class='neutral'>        int128 netIssuanceD18;</span>
  246 |     | <span class='neutral'>        int128 creditCapacityD18;</span>
  247 |     | <span class='neutral'>        int128 lastDistributedMarketBalanceD18;</span>
  248 |     | <span class='neutral'>        HeapUtil.Data inRangePools;</span>
  249 |     | <span class='neutral'>        HeapUtil.Data outRangePools;</span>
  250 |     | <span class='neutral'>        Distribution.Data poolsDebtDistribution;</span>
  251 |     | <span class='neutral'>        mapping(uint128 =&gt; MarketPoolInfo.Data) pools;</span>
  252 |     | <span class='neutral'>        DepositedCollateral[] depositedCollateral;</span>
  253 |     | <span class='neutral'>        mapping(address =&gt; uint256) maximumDepositableD18;</span>
  254 |     | <span class='neutral'>        uint32 minDelegateTime;</span>
  255 |     | <span class='neutral'>        uint32 __reservedForLater1;</span>
  256 |     | <span class='neutral'>        uint64 __reservedForLater2;</span>
  257 |     | <span class='neutral'>        uint64 __reservedForLater3;</span>
  258 |     | <span class='neutral'>        uint64 __reservedForLater4;</span>
  259 |     | <span class='neutral'>        uint256 minLiquidityRatioD18;</span>
  260 |     | <span class='neutral'>    }</span>
  261 |     | <span class='neutral'>    struct DepositedCollateral {</span>
  262 |     | <span class='neutral'>        address collateralType;</span>
  263 |     | <span class='neutral'>        uint256 amountD18;</span>
  264 |     | <span class='neutral'>    }</span>
  265 |     | <span class='neutral'>    function load(uint128 id) internal pure returns (Data storage market) {</span>
  266 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.synthetix.Market&quot;, id));</span>
  267 |     | <span class='neutral'>        assembly {</span>
  268 |     | <span class='neutral'>            market.slot := s</span>
  269 |     | <span class='neutral'>        }</span>
  270 |     | <span class='neutral'>    }</span>
  271 |     | <span class='neutral'>}</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/MarketConfiguration.sol:MarketConfiguration</span>
  274 |     | <span class='unexecuted'>library MarketConfiguration {</span>
  275 |     | <span class='neutral'>    struct Data {</span>
  276 |     | <span class='neutral'>        uint128 marketId;</span>
  277 |     | <span class='neutral'>        uint128 weightD18;</span>
  278 |     | <span class='neutral'>        int128 maxDebtShareValueD18;</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'>}</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/MarketPoolInfo.sol:MarketPoolInfo</span>
  283 |     | <span class='unexecuted'>library MarketPoolInfo {</span>
  284 |     | <span class='neutral'>    struct Data {</span>
  285 |     | <span class='neutral'>        uint128 creditCapacityAmountD18;</span>
  286 |     | <span class='neutral'>        uint128 pendingDebtD18;</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'>}</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/OracleManager.sol:OracleManager</span>
  291 |     | <span class='unexecuted'>library OracleManager {</span>
  292 |     | <span class='neutral'>    bytes32 private constant _SLOT_ORACLE_MANAGER =</span>
  293 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.synthetix.OracleManager&quot;));</span>
  294 |     | <span class='neutral'>    struct Data {</span>
  295 |     | <span class='neutral'>        address oracleManagerAddress;</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'>    function load() internal pure returns (Data storage oracleManager) {</span>
  298 |     | <span class='neutral'>        bytes32 s = _SLOT_ORACLE_MANAGER;</span>
  299 |     | <span class='neutral'>        assembly {</span>
  300 |     | <span class='neutral'>            oracleManager.slot := s</span>
  301 |     | <span class='neutral'>        }</span>
  302 |     | <span class='neutral'>    }</span>
  303 |     | <span class='neutral'>}</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/Pool.sol:Pool</span>
  306 |     | <span class='unexecuted'>library Pool {</span>
  307 |     | <span class='neutral'>    bytes32 private constant _CONFIG_SET_MARKET_MIN_DELEGATE_MAX =</span>
  308 |     | <span class='neutral'>        &quot;setMarketMinDelegateTime_max&quot;;</span>
  309 |     | <span class='neutral'>    struct Data {</span>
  310 |     | <span class='neutral'>        uint128 id;</span>
  311 |     | <span class='neutral'>        string name;</span>
  312 |     | <span class='neutral'>        address owner;</span>
  313 |     | <span class='neutral'>        address nominatedOwner;</span>
  314 |     | <span class='neutral'>        uint128 totalWeightsD18;</span>
  315 |     | <span class='neutral'>        int128 totalVaultDebtsD18;</span>
  316 |     | <span class='neutral'>        MarketConfiguration.Data[] marketConfigurations;</span>
  317 |     | <span class='neutral'>        Distribution.Data vaultsDebtDistribution;</span>
  318 |     | <span class='neutral'>        mapping(address =&gt; Vault.Data) vaults;</span>
  319 |     | <span class='neutral'>        uint64 lastConfigurationTime;</span>
  320 |     | <span class='neutral'>        uint64 __reserved1;</span>
  321 |     | <span class='neutral'>        uint64 __reserved2;</span>
  322 |     | <span class='neutral'>        uint64 __reserved3;</span>
  323 |     | <span class='neutral'>        mapping(address =&gt; PoolCollateralConfiguration.Data) collateralConfigurations;</span>
  324 |     | <span class='neutral'>        bool collateralDisabledByDefault;</span>
  325 |     | <span class='neutral'>    }</span>
  326 |     | <span class='neutral'>    function load(uint128 id) internal pure returns (Data storage pool) {</span>
  327 |     | <span class='neutral'>        bytes32 s = keccak256(abi.encode(&quot;io.synthetix.synthetix.Pool&quot;, id));</span>
  328 |     | <span class='neutral'>        assembly {</span>
  329 |     | <span class='neutral'>            pool.slot := s</span>
  330 |     | <span class='neutral'>        }</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'>}</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/PoolCollateralConfiguration.sol:PoolCollateralConfiguration</span>
  335 |     | <span class='unexecuted'>library PoolCollateralConfiguration {</span>
  336 |     | <span class='neutral'>    bytes32 private constant _SLOT =</span>
  337 |     | <span class='neutral'>        keccak256(</span>
  338 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.synthetix.PoolCollateralConfiguration&quot;)</span>
  339 |     | <span class='neutral'>        );</span>
  340 |     | <span class='neutral'>    struct Data {</span>
  341 |     | <span class='neutral'>        uint256 collateralLimitD18;</span>
  342 |     | <span class='neutral'>        uint256 issuanceRatioD18;</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'>}</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/RewardDistribution.sol:RewardDistribution</span>
  347 |     | <span class='unexecuted'>library RewardDistribution {</span>
  348 |     | <span class='neutral'>    struct Data {</span>
  349 |     | <span class='neutral'>        address distributor;</span>
  350 |     | <span class='neutral'>        uint128 __slotAvailableForFutureUse;</span>
  351 |     | <span class='neutral'>        uint128 rewardPerShareD18;</span>
  352 |     | <span class='neutral'>        mapping(uint256 =&gt; RewardDistributionClaimStatus.Data) claimStatus;</span>
  353 |     | <span class='neutral'>        int128 scheduledValueD18;</span>
  354 |     | <span class='neutral'>        uint64 start;</span>
  355 |     | <span class='neutral'>        uint32 duration;</span>
  356 |     | <span class='neutral'>        uint32 lastUpdate;</span>
  357 |     | <span class='neutral'>    }</span>
  358 |     | <span class='neutral'>}</span>
  359 |     | <span class='neutral'></span>
  360 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/RewardDistributionClaimStatus.sol:RewardDistributionClaimStatus</span>
  361 |     | <span class='unexecuted'>library RewardDistributionClaimStatus {</span>
  362 |     | <span class='neutral'>    struct Data {</span>
  363 |     | <span class='neutral'>        uint128 lastRewardPerShareD18;</span>
  364 |     | <span class='neutral'>        uint128 pendingSendD18;</span>
  365 |     | <span class='neutral'>    }</span>
  366 |     | <span class='neutral'>}</span>
  367 |     | <span class='neutral'></span>
  368 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/ScalableMapping.sol:ScalableMapping</span>
  369 |     | <span class='unexecuted'>library ScalableMapping {</span>
  370 |     | <span class='neutral'>    struct Data {</span>
  371 |     | <span class='neutral'>        uint128 totalSharesD18;</span>
  372 |     | <span class='neutral'>        int128 scaleModifierD27;</span>
  373 |     | <span class='neutral'>        mapping(bytes32 =&gt; uint256) sharesD18;</span>
  374 |     | <span class='neutral'>    }</span>
  375 |     | <span class='neutral'>}</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/SystemPoolConfiguration.sol:SystemPoolConfiguration</span>
  378 |     | <span class='unexecuted'>library SystemPoolConfiguration {</span>
  379 |     | <span class='neutral'>    bytes32 private constant _SLOT_SYSTEM_POOL_CONFIGURATION =</span>
  380 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.synthetix.SystemPoolConfiguration&quot;));</span>
  381 |     | <span class='neutral'>    struct Data {</span>
  382 |     | <span class='neutral'>        uint256 minLiquidityRatioD18;</span>
  383 |     | <span class='neutral'>        uint128 __reservedForFutureUse;</span>
  384 |     | <span class='neutral'>        uint128 preferredPool;</span>
  385 |     | <span class='neutral'>        SetUtil.UintSet approvedPools;</span>
  386 |     | <span class='neutral'>    }</span>
  387 |     | <span class='neutral'>    function load()</span>
  388 |     | <span class='neutral'>        internal</span>
  389 |     | <span class='neutral'>        pure</span>
  390 |     | <span class='neutral'>        returns (Data storage systemPoolConfiguration)</span>
  391 |     | <span class='neutral'>    {</span>
  392 |     | <span class='neutral'>        bytes32 s = _SLOT_SYSTEM_POOL_CONFIGURATION;</span>
  393 |     | <span class='neutral'>        assembly {</span>
  394 |     | <span class='neutral'>            systemPoolConfiguration.slot := s</span>
  395 |     | <span class='neutral'>        }</span>
  396 |     | <span class='neutral'>    }</span>
  397 |     | <span class='neutral'>}</span>
  398 |     | <span class='neutral'></span>
  399 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/Vault.sol:Vault</span>
  400 |     | <span class='unexecuted'>library Vault {</span>
  401 |     | <span class='neutral'>    struct Data {</span>
  402 |     | <span class='neutral'>        uint256 epoch;</span>
  403 |     | <span class='neutral'>        bytes32 __slotAvailableForFutureUse;</span>
  404 |     | <span class='neutral'>        int128 _unused_prevTotalDebtD18;</span>
  405 |     | <span class='neutral'>        mapping(uint256 =&gt; VaultEpoch.Data) epochData;</span>
  406 |     | <span class='neutral'>        mapping(bytes32 =&gt; RewardDistribution.Data) rewards;</span>
  407 |     | <span class='neutral'>        SetUtil.Bytes32Set rewardIds;</span>
  408 |     | <span class='neutral'>    }</span>
  409 |     | <span class='neutral'>    struct PositionSelector {</span>
  410 |     | <span class='neutral'>        uint128 accountId;</span>
  411 |     | <span class='neutral'>        uint128 poolId;</span>
  412 |     | <span class='neutral'>        address collateralType;</span>
  413 |     | <span class='neutral'>    }</span>
  414 |     | <span class='neutral'>}</span>
  415 |     | <span class='neutral'></span>
  416 |     | <span class='neutral'>// @custom:artifact @synthetixio/main/contracts/storage/VaultEpoch.sol:VaultEpoch</span>
  417 |     | <span class='unexecuted'>library VaultEpoch {</span>
  418 |     | <span class='neutral'>    struct Data {</span>
  419 |     | <span class='neutral'>        int128 unconsolidatedDebtD18;</span>
  420 |     | <span class='neutral'>        int128 totalConsolidatedDebtD18;</span>
  421 |     | <span class='neutral'>        Distribution.Data accountsDebtDistribution;</span>
  422 |     | <span class='neutral'>        ScalableMapping.Data collateralAmounts;</span>
  423 |     | <span class='neutral'>        mapping(uint256 =&gt; int256) consolidatedDebtAmountsD18;</span>
  424 |     | <span class='neutral'>        mapping(uint128 =&gt; uint64) lastDelegationTime;</span>
  425 |     | <span class='neutral'>    }</span>
  426 |     | <span class='neutral'>}</span>
  427 |     | <span class='neutral'></span>
  428 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/interfaces/external/IPyth.sol:PythStructs</span>
  429 |     | <span class='unexecuted'>contract PythStructs {</span>
  430 |     | <span class='neutral'>    struct Price {</span>
  431 |     | <span class='neutral'>        int64 price;</span>
  432 |     | <span class='neutral'>        uint64 conf;</span>
  433 |     | <span class='neutral'>        int32 expo;</span>
  434 |     | <span class='neutral'>        uint256 publishTime;</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'>    struct PriceFeed {</span>
  437 |     | <span class='neutral'>        bytes32 id;</span>
  438 |     | <span class='neutral'>        Price price;</span>
  439 |     | <span class='neutral'>        Price emaPrice;</span>
  440 |     | <span class='neutral'>    }</span>
  441 |     | <span class='neutral'>}</span>
  442 |     | <span class='neutral'></span>
  443 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/nodes/ChainlinkNode.sol:ChainlinkNode</span>
  444 |     | <span class='unexecuted'>library ChainlinkNode {</span>
  445 |     | <span class='unexecuted'>    uint256 public constant PRECISION = 18;</span>
  446 |     | <span class='neutral'>}</span>
  447 |     | <span class='neutral'></span>
  448 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/nodes/ReducerNode.sol:ReducerNode</span>
  449 |     | <span class='unexecuted'>library ReducerNode {</span>
  450 |     | <span class='neutral'>    enum Operations {</span>
  451 |     | <span class='neutral'>        RECENT,</span>
  452 |     | <span class='neutral'>        MIN,</span>
  453 |     | <span class='neutral'>        MAX,</span>
  454 |     | <span class='neutral'>        MEAN,</span>
  455 |     | <span class='neutral'>        MEDIAN,</span>
  456 |     | <span class='neutral'>        MUL,</span>
  457 |     | <span class='neutral'>        DIV,</span>
  458 |     | <span class='neutral'>        MULDECIMAL,</span>
  459 |     | <span class='neutral'>        DIVDECIMAL</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'>}</span>
  462 |     | <span class='neutral'></span>
  463 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/nodes/UniswapNode.sol:UniswapNode</span>
  464 |     | <span class='unexecuted'>library UniswapNode {</span>
  465 |     | <span class='unexecuted'>    uint8 public constant PRECISION = 18;</span>
  466 |     | <span class='neutral'>}</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/nodes/pyth/PythNode.sol:PythNode</span>
  469 |     | <span class='unexecuted'>library PythNode {</span>
  470 |     | <span class='unexecuted'>    int256 public constant PRECISION = 18;</span>
  471 |     | <span class='neutral'>}</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/nodes/pyth/PythOffchainLookupNode.sol:PythOffchainLookupNode</span>
  474 |     | <span class='unexecuted'>library PythOffchainLookupNode {</span>
  475 |     | <span class='unexecuted'>    int256 public constant PRECISION = 18;</span>
  476 |     | <span class='neutral'>}</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/storage/NodeDefinition.sol:NodeDefinition</span>
  479 |     | <span class='unexecuted'>library NodeDefinition {</span>
  480 |     | <span class='neutral'>    enum NodeType {</span>
  481 |     | <span class='neutral'>        NONE,</span>
  482 |     | <span class='neutral'>        REDUCER,</span>
  483 |     | <span class='neutral'>        EXTERNAL,</span>
  484 |     | <span class='neutral'>        CHAINLINK,</span>
  485 |     | <span class='neutral'>        UNISWAP,</span>
  486 |     | <span class='neutral'>        PYTH,</span>
  487 |     | <span class='neutral'>        PRICE_DEVIATION_CIRCUIT_BREAKER,</span>
  488 |     | <span class='neutral'>        STALENESS_CIRCUIT_BREAKER,</span>
  489 |     | <span class='neutral'>        CONSTANT,</span>
  490 |     | <span class='neutral'>        PYTH_OFFCHAIN_LOOKUP</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'>    struct Data {</span>
  493 |     | <span class='neutral'>        NodeType nodeType;</span>
  494 |     | <span class='neutral'>        bytes parameters;</span>
  495 |     | <span class='neutral'>        bytes32[] parents;</span>
  496 |     | <span class='neutral'>    }</span>
  497 |     | <span class='neutral'>    function load(bytes32 id) internal pure returns (Data storage node) {</span>
  498 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  499 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.oracle-manager.Node&quot;, id)</span>
  500 |     | <span class='neutral'>        );</span>
  501 |     | <span class='neutral'>        assembly {</span>
  502 |     | <span class='neutral'>            node.slot := s</span>
  503 |     | <span class='neutral'>        }</span>
  504 |     | <span class='neutral'>    }</span>
  505 |     | <span class='neutral'>}</span>
  506 |     | <span class='neutral'></span>
  507 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/storage/NodeOutput.sol:NodeOutput</span>
  508 |     | <span class='unexecuted'>library NodeOutput {</span>
  509 |     | <span class='neutral'>    struct Data {</span>
  510 |     | <span class='neutral'>        int256 price;</span>
  511 |     | <span class='neutral'>        uint256 timestamp;</span>
  512 |     | <span class='neutral'>        uint256 __slotAvailableForFutureUse1;</span>
  513 |     | <span class='neutral'>        uint256 __slotAvailableForFutureUse2;</span>
  514 |     | <span class='neutral'>    }</span>
  515 |     | <span class='neutral'>}</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>// @custom:artifact @synthetixio/oracle-manager/contracts/utils/TickMath.sol:TickMath</span>
  518 |     | <span class='unexecuted'>library TickMath {</span>
  519 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;</span>
  520 |     | <span class='neutral'>    int24 internal constant MAX_TICK = -MIN_TICK;</span>
  521 |     | <span class='neutral'>    uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
  522 |     | <span class='neutral'>    uint160 internal constant MAX_SQRT_RATIO =</span>
  523 |     | <span class='neutral'>        1461446703485210103287273052203988822378723970342;</span>
  524 |     | <span class='neutral'>}</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>// @custom:artifact @synthetixio/rewards-distributor/src/RewardsDistributor.sol:RewardsDistributor</span>
  527 |     | <span class='unexecuted'>contract RewardsDistributor {</span>
  528 |     | <span class='unexecuted'>    uint256 public constant SYSTEM_PRECISION = 10 ** 18;</span>
  529 |     | <span class='neutral'>}</span>
  530 |     | <span class='neutral'></span>
  531 |     | <span class='neutral'>// @custom:artifact @synthetixio/spot-market/contracts/storage/OrderFees.sol:OrderFees</span>
  532 |     | <span class='unexecuted'>library OrderFees {</span>
  533 |     | <span class='neutral'>    struct Data {</span>
  534 |     | <span class='neutral'>        uint256 fixedFees;</span>
  535 |     | <span class='neutral'>        uint256 utilizationFees;</span>
  536 |     | <span class='neutral'>        int256 skewFees;</span>
  537 |     | <span class='neutral'>        int256 wrapperFees;</span>
  538 |     | <span class='neutral'>    }</span>
  539 |     | <span class='neutral'>}</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>// @custom:artifact @synthetixio/spot-market/contracts/storage/Price.sol:Price</span>
  542 |     | <span class='unexecuted'>library Price {</span>
  543 |     | <span class='neutral'>    enum Tolerance {</span>
  544 |     | <span class='neutral'>        DEFAULT,</span>
  545 |     | <span class='neutral'>        STRICT</span>
  546 |     | <span class='neutral'>    }</span>
  547 |     | <span class='neutral'>    struct Data {</span>
  548 |     | <span class='neutral'>        bytes32 buyFeedId;</span>
  549 |     | <span class='neutral'>        bytes32 sellFeedId;</span>
  550 |     | <span class='neutral'>        uint256 strictStalenessTolerance;</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'>    function load(uint128 marketId) internal pure returns (Data storage price) {</span>
  553 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  554 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.spot-market.Price&quot;, marketId)</span>
  555 |     | <span class='neutral'>        );</span>
  556 |     | <span class='neutral'>        assembly {</span>
  557 |     | <span class='neutral'>            price.slot := s</span>
  558 |     | <span class='neutral'>        }</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'>}</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>// @custom:artifact @synthetixio/spot-market/contracts/storage/SpotMarketFactory.sol:SpotMarketFactory</span>
  563 |     | <span class='unexecuted'>library SpotMarketFactory {</span>
  564 |     | <span class='neutral'>    bytes32 private constant _SLOT_SPOT_MARKET_FACTORY =</span>
  565 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.spot-market.SpotMarketFactory&quot;));</span>
  566 |     | <span class='neutral'>    struct Data {</span>
  567 |     | <span class='neutral'>        address usdToken;</span>
  568 |     | <span class='neutral'>        address oracle;</span>
  569 |     | <span class='neutral'>        address synthetix;</span>
  570 |     | <span class='neutral'>        address synthImplementation;</span>
  571 |     | <span class='neutral'>        mapping(uint128 =&gt; address) marketOwners;</span>
  572 |     | <span class='neutral'>        mapping(uint128 =&gt; address) nominatedMarketOwners;</span>
  573 |     | <span class='neutral'>    }</span>
  574 |     | <span class='neutral'>    function load() internal pure returns (Data storage spotMarketFactory) {</span>
  575 |     | <span class='neutral'>        bytes32 s = _SLOT_SPOT_MARKET_FACTORY;</span>
  576 |     | <span class='neutral'>        assembly {</span>
  577 |     | <span class='neutral'>            spotMarketFactory.slot := s</span>
  578 |     | <span class='neutral'>        }</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'>}</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>// @custom:artifact @synthetixio/spot-market/contracts/utils/TransactionUtil.sol:Transaction</span>
  583 |     | <span class='unexecuted'>library Transaction {</span>
  584 |     | <span class='neutral'>    enum Type {</span>
  585 |     | <span class='neutral'>        NULL,</span>
  586 |     | <span class='neutral'>        BUY,</span>
  587 |     | <span class='neutral'>        SELL,</span>
  588 |     | <span class='neutral'>        ASYNC_BUY,</span>
  589 |     | <span class='neutral'>        ASYNC_SELL,</span>
  590 |     | <span class='neutral'>        WRAP,</span>
  591 |     | <span class='neutral'>        UNWRAP</span>
  592 |     | <span class='neutral'>    }</span>
  593 |     | <span class='neutral'>}</span>
  594 |     | <span class='neutral'></span>
  595 |     | <span class='neutral'>// @custom:artifact contracts/interfaces/IAsyncOrderCancelModule.sol:IAsyncOrderCancelModule</span>
  596 |     | <span class='neutral'>interface IAsyncOrderCancelModule {</span>
  597 |     | <span class='neutral'>    struct CancelOrderRuntime {</span>
  598 |     | <span class='neutral'>        uint128 marketId;</span>
  599 |     | <span class='neutral'>        uint128 accountId;</span>
  600 |     | <span class='neutral'>        int128 sizeDelta;</span>
  601 |     | <span class='neutral'>        uint256 settlementReward;</span>
  602 |     | <span class='neutral'>        uint256 fillPrice;</span>
  603 |     | <span class='neutral'>        uint256 acceptablePrice;</span>
  604 |     | <span class='neutral'>    }</span>
  605 |     | <span class='neutral'>}</span>
  606 |     | <span class='neutral'></span>
  607 |     | <span class='neutral'>// @custom:artifact contracts/interfaces/IAsyncOrderSettlementPythModule.sol:IAsyncOrderSettlementPythModule</span>
  608 |     | <span class='neutral'>interface IAsyncOrderSettlementPythModule {</span>
  609 |     | <span class='neutral'>    struct SettleOrderRuntime {</span>
  610 |     | <span class='neutral'>        uint128 marketId;</span>
  611 |     | <span class='neutral'>        uint128 accountId;</span>
  612 |     | <span class='neutral'>        int128 sizeDelta;</span>
  613 |     | <span class='neutral'>        int256 pnl;</span>
  614 |     | <span class='neutral'>        uint256 chargedInterest;</span>
  615 |     | <span class='neutral'>        int256 accruedFunding;</span>
  616 |     | <span class='neutral'>        uint256 settlementReward;</span>
  617 |     | <span class='neutral'>        uint256 fillPrice;</span>
  618 |     | <span class='neutral'>        uint256 totalFees;</span>
  619 |     | <span class='neutral'>        uint256 referralFees;</span>
  620 |     | <span class='neutral'>        uint256 feeCollectorFees;</span>
  621 |     | <span class='neutral'>        Position.Data newPosition;</span>
  622 |     | <span class='neutral'>        MarketUpdate.Data updateData;</span>
  623 |     | <span class='neutral'>        uint256 synthDeductionIterator;</span>
  624 |     | <span class='neutral'>        uint128[] deductedSynthIds;</span>
  625 |     | <span class='neutral'>        uint256[] deductedAmount;</span>
  626 |     | <span class='neutral'>        int256 chargedAmount;</span>
  627 |     | <span class='neutral'>        uint256 newAccountDebt;</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'>}</span>
  630 |     | <span class='neutral'></span>
  631 |     | <span class='neutral'>// @custom:artifact contracts/interfaces/IPerpsMarketModule.sol:IPerpsMarketModule</span>
  632 |     | <span class='neutral'>interface IPerpsMarketModule {</span>
  633 |     | <span class='neutral'>    struct MarketSummary {</span>
  634 |     | <span class='neutral'>        int256 skew;</span>
  635 |     | <span class='neutral'>        uint256 size;</span>
  636 |     | <span class='neutral'>        uint256 maxOpenInterest;</span>
  637 |     | <span class='neutral'>        int256 currentFundingRate;</span>
  638 |     | <span class='neutral'>        int256 currentFundingVelocity;</span>
  639 |     | <span class='neutral'>        uint256 indexPrice;</span>
  640 |     | <span class='neutral'>    }</span>
  641 |     | <span class='neutral'>}</span>
  642 |     | <span class='neutral'></span>
  643 |     | <span class='neutral'>// @custom:artifact contracts/modules/LiquidationModule.sol:LiquidationModule</span>
  644 |     | <span class='unexecuted'>contract LiquidationModule {</span>
  645 |     | <span class='neutral'>    struct LiquidateAccountRuntime {</span>
  646 |     | <span class='neutral'>        uint128 accountId;</span>
  647 |     | <span class='neutral'>        uint256 totalFlaggingRewards;</span>
  648 |     | <span class='neutral'>        uint256 totalLiquidated;</span>
  649 |     | <span class='neutral'>        bool accountFullyLiquidated;</span>
  650 |     | <span class='neutral'>        uint256 totalLiquidationCost;</span>
  651 |     | <span class='neutral'>        uint256 price;</span>
  652 |     | <span class='neutral'>        uint128 positionMarketId;</span>
  653 |     | <span class='neutral'>        uint256 loopIterator;</span>
  654 |     | <span class='neutral'>    }</span>
  655 |     | <span class='neutral'>}</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>// @custom:artifact contracts/modules/PerpsMarketFactoryModule.sol:PerpsMarketFactoryModule</span>
  658 |     | <span class='unexecuted'>contract PerpsMarketFactoryModule {</span>
  659 |     | <span class='neutral'>    bytes32 private constant _ACCOUNT_TOKEN_SYSTEM = &quot;accountNft&quot;;</span>
  660 |     | <span class='neutral'>}</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>// @custom:artifact contracts/storage/AsyncOrder.sol:AsyncOrder</span>
  663 |     | <span class='unexecuted'>library AsyncOrder {</span>
  664 |     | <span class='neutral'>    struct Data {</span>
  665 |     | <span class='neutral'>        uint256 commitmentTime;</span>
  666 |     | <span class='neutral'>        OrderCommitmentRequest request;</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'>    struct OrderCommitmentRequest {</span>
  669 |     | <span class='neutral'>        uint128 marketId;</span>
  670 |     | <span class='neutral'>        uint128 accountId;</span>
  671 |     | <span class='neutral'>        int128 sizeDelta;</span>
  672 |     | <span class='neutral'>        uint128 settlementStrategyId;</span>
  673 |     | <span class='neutral'>        uint256 acceptablePrice;</span>
  674 |     | <span class='neutral'>        bytes32 trackingCode;</span>
  675 |     | <span class='neutral'>        address referrer;</span>
  676 |     | <span class='neutral'>    }</span>
  677 |     | <span class='neutral'>    struct SimulateDataRuntime {</span>
  678 |     | <span class='neutral'>        bool isEligible;</span>
  679 |     | <span class='neutral'>        int128 sizeDelta;</span>
  680 |     | <span class='neutral'>        uint128 accountId;</span>
  681 |     | <span class='neutral'>        uint128 marketId;</span>
  682 |     | <span class='neutral'>        uint256 fillPrice;</span>
  683 |     | <span class='neutral'>        uint256 orderFees;</span>
  684 |     | <span class='neutral'>        uint256 availableMargin;</span>
  685 |     | <span class='neutral'>        uint256 currentLiquidationMargin;</span>
  686 |     | <span class='neutral'>        uint256 accumulatedLiquidationRewards;</span>
  687 |     | <span class='neutral'>        uint256 currentLiquidationReward;</span>
  688 |     | <span class='neutral'>        int128 newPositionSize;</span>
  689 |     | <span class='neutral'>        uint256 newNotionalValue;</span>
  690 |     | <span class='neutral'>        int256 currentAvailableMargin;</span>
  691 |     | <span class='neutral'>        uint256 requiredInitialMargin;</span>
  692 |     | <span class='neutral'>        uint256 initialRequiredMargin;</span>
  693 |     | <span class='neutral'>        uint256 totalRequiredMargin;</span>
  694 |     | <span class='neutral'>        Position.Data newPosition;</span>
  695 |     | <span class='neutral'>        bytes32 trackingCode;</span>
  696 |     | <span class='neutral'>    }</span>
  697 |     | <span class='neutral'>    struct RequiredMarginWithNewPositionRuntime {</span>
  698 |     | <span class='neutral'>        uint256 newRequiredMargin;</span>
  699 |     | <span class='neutral'>        uint256 oldRequiredMargin;</span>
  700 |     | <span class='neutral'>        uint256 requiredMarginForNewPosition;</span>
  701 |     | <span class='neutral'>        uint256 accumulatedLiquidationRewards;</span>
  702 |     | <span class='neutral'>        uint256 maxNumberOfWindows;</span>
  703 |     | <span class='neutral'>        uint256 numberOfWindows;</span>
  704 |     | <span class='neutral'>        uint256 requiredRewardMargin;</span>
  705 |     | <span class='neutral'>    }</span>
  706 |     | <span class='neutral'>    function load(</span>
  707 |     | <span class='neutral'>        uint128 accountId</span>
  708 |     | <span class='neutral'>    ) internal pure returns (Data storage order) {</span>
  709 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  710 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.perps-market.AsyncOrder&quot;, accountId)</span>
  711 |     | <span class='neutral'>        );</span>
  712 |     | <span class='neutral'>        assembly {</span>
  713 |     | <span class='neutral'>            order.slot := s</span>
  714 |     | <span class='neutral'>        }</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'>}</span>
  717 |     | <span class='neutral'></span>
  718 |     | <span class='neutral'>// @custom:artifact contracts/storage/GlobalPerpsMarket.sol:GlobalPerpsMarket</span>
  719 |     | <span class='unexecuted'>library GlobalPerpsMarket {</span>
  720 |     | <span class='neutral'>    bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET =</span>
  721 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.perps-market.GlobalPerpsMarket&quot;));</span>
  722 |     | <span class='neutral'>    struct Data {</span>
  723 |     | <span class='neutral'>        SetUtil.UintSet liquidatableAccounts;</span>
  724 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) collateralAmounts;</span>
  725 |     | <span class='neutral'>        SetUtil.UintSet activeCollateralTypes;</span>
  726 |     | <span class='neutral'>        SetUtil.UintSet activeMarkets;</span>
  727 |     | <span class='neutral'>        uint256 totalAccountsDebt;</span>
  728 |     | <span class='neutral'>    }</span>
  729 |     | <span class='neutral'>    function load() internal pure returns (Data storage marketData) {</span>
  730 |     | <span class='neutral'>        bytes32 s = _SLOT_GLOBAL_PERPS_MARKET;</span>
  731 |     | <span class='neutral'>        assembly {</span>
  732 |     | <span class='neutral'>            marketData.slot := s</span>
  733 |     | <span class='neutral'>        }</span>
  734 |     | <span class='neutral'>    }</span>
  735 |     | <span class='neutral'>}</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>// @custom:artifact contracts/storage/GlobalPerpsMarketConfiguration.sol:GlobalPerpsMarketConfiguration</span>
  738 |     | <span class='unexecuted'>library GlobalPerpsMarketConfiguration {</span>
  739 |     | <span class='neutral'>    bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION =</span>
  740 |     | <span class='neutral'>        keccak256(</span>
  741 |     | <span class='neutral'>            abi.encode(</span>
  742 |     | <span class='neutral'>                &quot;io.synthetix.perps-market.GlobalPerpsMarketConfiguration&quot;</span>
  743 |     | <span class='neutral'>            )</span>
  744 |     | <span class='neutral'>        );</span>
  745 |     | <span class='neutral'>    struct Data {</span>
  746 |     | <span class='neutral'>        address feeCollector;</span>
  747 |     | <span class='neutral'>        mapping(address =&gt; uint256) referrerShare;</span>
  748 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) __unused_1;</span>
  749 |     | <span class='neutral'>        uint128[] __unused_2;</span>
  750 |     | <span class='neutral'>        uint256 minKeeperRewardUsd;</span>
  751 |     | <span class='neutral'>        uint256 maxKeeperRewardUsd;</span>
  752 |     | <span class='neutral'>        uint128 maxPositionsPerAccount;</span>
  753 |     | <span class='neutral'>        uint128 maxCollateralsPerAccount;</span>
  754 |     | <span class='neutral'>        uint256 minKeeperProfitRatioD18;</span>
  755 |     | <span class='neutral'>        uint256 maxKeeperScalingRatioD18;</span>
  756 |     | <span class='neutral'>        SetUtil.UintSet supportedCollateralTypes;</span>
  757 |     | <span class='neutral'>        uint128 lowUtilizationInterestRateGradient;</span>
  758 |     | <span class='neutral'>        uint128 interestRateGradientBreakpoint;</span>
  759 |     | <span class='neutral'>        uint128 highUtilizationInterestRateGradient;</span>
  760 |     | <span class='neutral'>        uint128 collateralLiquidateRewardRatioD18;</span>
  761 |     | <span class='neutral'>        address rewardDistributorImplementation;</span>
  762 |     | <span class='neutral'>    }</span>
  763 |     | <span class='neutral'>    function load() internal pure returns (Data storage globalMarketConfig) {</span>
  764 |     | <span class='neutral'>        bytes32 s = _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION;</span>
  765 |     | <span class='neutral'>        assembly {</span>
  766 |     | <span class='neutral'>            globalMarketConfig.slot := s</span>
  767 |     | <span class='neutral'>        }</span>
  768 |     | <span class='neutral'>    }</span>
  769 |     | <span class='neutral'>}</span>
  770 |     | <span class='neutral'></span>
  771 |     | <span class='neutral'>// @custom:artifact contracts/storage/InterestRate.sol:InterestRate</span>
  772 |     | <span class='unexecuted'>library InterestRate {</span>
  773 |     | <span class='neutral'>    uint256 private constant AVERAGE_SECONDS_PER_YEAR = 31557600;</span>
  774 |     | <span class='neutral'>    bytes32 private constant _SLOT_INTEREST_RATE =</span>
  775 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.perps-market.InterestRate&quot;));</span>
  776 |     | <span class='neutral'>    struct Data {</span>
  777 |     | <span class='neutral'>        uint256 interestAccrued;</span>
  778 |     | <span class='neutral'>        uint128 interestRate;</span>
  779 |     | <span class='neutral'>        uint256 lastTimestamp;</span>
  780 |     | <span class='neutral'>    }</span>
  781 |     | <span class='neutral'>    function load() internal pure returns (Data storage interestRate) {</span>
  782 |     | <span class='neutral'>        bytes32 s = _SLOT_INTEREST_RATE;</span>
  783 |     | <span class='neutral'>        assembly {</span>
  784 |     | <span class='neutral'>            interestRate.slot := s</span>
  785 |     | <span class='neutral'>        }</span>
  786 |     | <span class='neutral'>    }</span>
  787 |     | <span class='neutral'>}</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>// @custom:artifact contracts/storage/KeeperCosts.sol:KeeperCosts</span>
  790 |     | <span class='unexecuted'>library KeeperCosts {</span>
  791 |     | <span class='neutral'>    uint256 private constant KIND_SETTLEMENT = 0;</span>
  792 |     | <span class='neutral'>    uint256 private constant KIND_FLAG = 1;</span>
  793 |     | <span class='neutral'>    uint256 private constant KIND_LIQUIDATE = 2;</span>
  794 |     | <span class='neutral'>    struct Data {</span>
  795 |     | <span class='neutral'>        bytes32 keeperCostNodeId;</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'>    function load() internal pure returns (Data storage price) {</span>
  798 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  799 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.perps-market.KeeperCosts&quot;)</span>
  800 |     | <span class='neutral'>        );</span>
  801 |     | <span class='neutral'>        assembly {</span>
  802 |     | <span class='neutral'>            price.slot := s</span>
  803 |     | <span class='neutral'>        }</span>
  804 |     | <span class='neutral'>    }</span>
  805 |     | <span class='neutral'>}</span>
  806 |     | <span class='neutral'></span>
  807 |     | <span class='neutral'>// @custom:artifact contracts/storage/Liquidation.sol:Liquidation</span>
  808 |     | <span class='unexecuted'>library Liquidation {</span>
  809 |     | <span class='neutral'>    struct Data {</span>
  810 |     | <span class='neutral'>        uint128 amount;</span>
  811 |     | <span class='neutral'>        uint256 timestamp;</span>
  812 |     | <span class='neutral'>    }</span>
  813 |     | <span class='neutral'>}</span>
  814 |     | <span class='neutral'></span>
  815 |     | <span class='neutral'>// @custom:artifact contracts/storage/LiquidationAssetManager.sol:LiquidationAssetManager</span>
  816 |     | <span class='unexecuted'>library LiquidationAssetManager {</span>
  817 |     | <span class='neutral'>    struct Data {</span>
  818 |     | <span class='neutral'>        uint128 id;</span>
  819 |     | <span class='neutral'>        address distributor;</span>
  820 |     | <span class='neutral'>        address[] poolDelegatedCollateralTypes;</span>
  821 |     | <span class='neutral'>    }</span>
  822 |     | <span class='neutral'>}</span>
  823 |     | <span class='neutral'></span>
  824 |     | <span class='neutral'>// @custom:artifact contracts/storage/MarketUpdate.sol:MarketUpdate</span>
  825 |     | <span class='unexecuted'>library MarketUpdate {</span>
  826 |     | <span class='neutral'>    struct Data {</span>
  827 |     | <span class='neutral'>        uint128 marketId;</span>
  828 |     | <span class='neutral'>        uint128 interestRate;</span>
  829 |     | <span class='neutral'>        int256 skew;</span>
  830 |     | <span class='neutral'>        uint256 size;</span>
  831 |     | <span class='neutral'>        int256 currentFundingRate;</span>
  832 |     | <span class='neutral'>        int256 currentFundingVelocity;</span>
  833 |     | <span class='neutral'>    }</span>
  834 |     | <span class='neutral'>}</span>
  835 |     | <span class='neutral'></span>
  836 |     | <span class='neutral'>// @custom:artifact contracts/storage/OrderFee.sol:OrderFee</span>
  837 |     | <span class='unexecuted'>library OrderFee {</span>
  838 |     | <span class='neutral'>    struct Data {</span>
  839 |     | <span class='neutral'>        uint256 makerFee;</span>
  840 |     | <span class='neutral'>        uint256 takerFee;</span>
  841 |     | <span class='neutral'>    }</span>
  842 |     | <span class='neutral'>}</span>
  843 |     | <span class='neutral'></span>
  844 |     | <span class='neutral'>// @custom:artifact contracts/storage/PerpsAccount.sol:PerpsAccount</span>
  845 |     | <span class='unexecuted'>library PerpsAccount {</span>
  846 |     | <span class='neutral'>    struct Data {</span>
  847 |     | <span class='neutral'>        mapping(uint128 =&gt; uint256) collateralAmounts;</span>
  848 |     | <span class='neutral'>        uint128 id;</span>
  849 |     | <span class='neutral'>        SetUtil.UintSet activeCollateralTypes;</span>
  850 |     | <span class='neutral'>        SetUtil.UintSet openPositionMarketIds;</span>
  851 |     | <span class='neutral'>        uint256 debt;</span>
  852 |     | <span class='neutral'>    }</span>
  853 |     | <span class='neutral'>    function load(uint128 id) internal pure returns (Data storage account) {</span>
  854 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  855 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.perps-market.Account&quot;, id)</span>
  856 |     | <span class='neutral'>        );</span>
  857 |     | <span class='neutral'>        assembly {</span>
  858 |     | <span class='neutral'>            account.slot := s</span>
  859 |     | <span class='neutral'>        }</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'>}</span>
  862 |     | <span class='neutral'></span>
  863 |     | <span class='neutral'>// @custom:artifact contracts/storage/PerpsCollateralConfiguration.sol:PerpsCollateralConfiguration</span>
  864 |     | <span class='unexecuted'>library PerpsCollateralConfiguration {</span>
  865 |     | <span class='neutral'>    struct Data {</span>
  866 |     | <span class='neutral'>        uint128 id;</span>
  867 |     | <span class='neutral'>        uint256 maxAmount;</span>
  868 |     | <span class='neutral'>        uint256 upperLimitDiscount;</span>
  869 |     | <span class='neutral'>        uint256 lowerLimitDiscount;</span>
  870 |     | <span class='neutral'>        uint256 discountScalar;</span>
  871 |     | <span class='neutral'>        LiquidationAssetManager.Data lam;</span>
  872 |     | <span class='neutral'>    }</span>
  873 |     | <span class='neutral'>    function load(</span>
  874 |     | <span class='neutral'>        uint128 collateralId</span>
  875 |     | <span class='neutral'>    ) internal pure returns (Data storage collateralConfig) {</span>
  876 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  877 |     | <span class='neutral'>            abi.encode(</span>
  878 |     | <span class='neutral'>                &quot;io.synthetix.perps-market.CollateralConfiguration&quot;,</span>
  879 |     | <span class='neutral'>                collateralId</span>
  880 |     | <span class='neutral'>            )</span>
  881 |     | <span class='neutral'>        );</span>
  882 |     | <span class='neutral'>        assembly {</span>
  883 |     | <span class='neutral'>            collateralConfig.slot := s</span>
  884 |     | <span class='neutral'>        }</span>
  885 |     | <span class='neutral'>    }</span>
  886 |     | <span class='neutral'>}</span>
  887 |     | <span class='neutral'></span>
  888 |     | <span class='neutral'>// @custom:artifact contracts/storage/PerpsMarket.sol:PerpsMarket</span>
  889 |     | <span class='unexecuted'>library PerpsMarket {</span>
  890 |     | <span class='neutral'>    struct Data {</span>
  891 |     | <span class='neutral'>        string name;</span>
  892 |     | <span class='neutral'>        string symbol;</span>
  893 |     | <span class='neutral'>        uint128 id;</span>
  894 |     | <span class='neutral'>        int256 skew;</span>
  895 |     | <span class='neutral'>        uint256 size;</span>
  896 |     | <span class='neutral'>        int256 lastFundingRate;</span>
  897 |     | <span class='neutral'>        int256 lastFundingValue;</span>
  898 |     | <span class='neutral'>        uint256 lastFundingTime;</span>
  899 |     | <span class='neutral'>        uint128 __unused_1;</span>
  900 |     | <span class='neutral'>        uint128 __unused_2;</span>
  901 |     | <span class='neutral'>        int256 debtCorrectionAccumulator;</span>
  902 |     | <span class='neutral'>        mapping(uint256 =&gt; AsyncOrder.Data) asyncOrders;</span>
  903 |     | <span class='neutral'>        mapping(uint256 =&gt; Position.Data) positions;</span>
  904 |     | <span class='neutral'>        Liquidation.Data[] liquidationData;</span>
  905 |     | <span class='neutral'>    }</span>
  906 |     | <span class='neutral'>    struct PositionDataRuntime {</span>
  907 |     | <span class='neutral'>        uint256 currentPrice;</span>
  908 |     | <span class='neutral'>        int256 sizeDelta;</span>
  909 |     | <span class='neutral'>        int256 fundingDelta;</span>
  910 |     | <span class='neutral'>        int256 notionalDelta;</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'>    function load(</span>
  913 |     | <span class='neutral'>        uint128 marketId</span>
  914 |     | <span class='neutral'>    ) internal pure returns (Data storage market) {</span>
  915 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  916 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.perps-market.PerpsMarket&quot;, marketId)</span>
  917 |     | <span class='neutral'>        );</span>
  918 |     | <span class='neutral'>        assembly {</span>
  919 |     | <span class='neutral'>            market.slot := s</span>
  920 |     | <span class='neutral'>        }</span>
  921 |     | <span class='neutral'>    }</span>
  922 |     | <span class='neutral'>}</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>// @custom:artifact contracts/storage/PerpsMarketConfiguration.sol:PerpsMarketConfiguration</span>
  925 |     | <span class='unexecuted'>library PerpsMarketConfiguration {</span>
  926 |     | <span class='neutral'>    struct Data {</span>
  927 |     | <span class='neutral'>        OrderFee.Data orderFees;</span>
  928 |     | <span class='neutral'>        SettlementStrategy.Data[] settlementStrategies;</span>
  929 |     | <span class='neutral'>        uint256 maxMarketSize;</span>
  930 |     | <span class='neutral'>        uint256 maxFundingVelocity;</span>
  931 |     | <span class='neutral'>        uint256 skewScale;</span>
  932 |     | <span class='neutral'>        uint256 initialMarginRatioD18;</span>
  933 |     | <span class='neutral'>        uint256 maintenanceMarginScalarD18;</span>
  934 |     | <span class='neutral'>        uint256 lockedOiRatioD18;</span>
  935 |     | <span class='neutral'>        uint256 maxLiquidationLimitAccumulationMultiplier;</span>
  936 |     | <span class='neutral'>        uint256 maxSecondsInLiquidationWindow;</span>
  937 |     | <span class='neutral'>        uint256 flagRewardRatioD18;</span>
  938 |     | <span class='neutral'>        uint256 minimumPositionMargin;</span>
  939 |     | <span class='neutral'>        uint256 minimumInitialMarginRatioD18;</span>
  940 |     | <span class='neutral'>        uint256 maxLiquidationPd;</span>
  941 |     | <span class='neutral'>        address endorsedLiquidator;</span>
  942 |     | <span class='neutral'>        uint256 maxMarketValue;</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'>    function load(uint128 marketId) internal pure returns (Data storage store) {</span>
  945 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  946 |     | <span class='neutral'>            abi.encode(</span>
  947 |     | <span class='neutral'>                &quot;io.synthetix.perps-market.PerpsMarketConfiguration&quot;,</span>
  948 |     | <span class='neutral'>                marketId</span>
  949 |     | <span class='neutral'>            )</span>
  950 |     | <span class='neutral'>        );</span>
  951 |     | <span class='neutral'>        assembly {</span>
  952 |     | <span class='neutral'>            store.slot := s</span>
  953 |     | <span class='neutral'>        }</span>
  954 |     | <span class='neutral'>    }</span>
  955 |     | <span class='neutral'>}</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>// @custom:artifact contracts/storage/PerpsMarketFactory.sol:PerpsMarketFactory</span>
  958 |     | <span class='unexecuted'>library PerpsMarketFactory {</span>
  959 |     | <span class='neutral'>    bytes32 private constant _SLOT_PERPS_MARKET_FACTORY =</span>
  960 |     | <span class='neutral'>        keccak256(abi.encode(&quot;io.synthetix.perps-market.PerpsMarketFactory&quot;));</span>
  961 |     | <span class='neutral'>    struct Data {</span>
  962 |     | <span class='neutral'>        address oracle;</span>
  963 |     | <span class='neutral'>        address usdToken;</span>
  964 |     | <span class='neutral'>        address synthetix;</span>
  965 |     | <span class='neutral'>        address spotMarket;</span>
  966 |     | <span class='neutral'>        uint128 perpsMarketId;</span>
  967 |     | <span class='neutral'>        string name;</span>
  968 |     | <span class='neutral'>        address liquidationAssetManager;</span>
  969 |     | <span class='neutral'>    }</span>
  970 |     | <span class='neutral'>    function load() internal pure returns (Data storage perpsMarketFactory) {</span>
  971 |     | <span class='neutral'>        bytes32 s = _SLOT_PERPS_MARKET_FACTORY;</span>
  972 |     | <span class='neutral'>        assembly {</span>
  973 |     | <span class='neutral'>            perpsMarketFactory.slot := s</span>
  974 |     | <span class='neutral'>        }</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'>}</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>// @custom:artifact contracts/storage/PerpsPrice.sol:PerpsPrice</span>
  979 |     | <span class='unexecuted'>library PerpsPrice {</span>
  980 |     | <span class='neutral'>    uint256 private constant ONE_MONTH = 2592000;</span>
  981 |     | <span class='neutral'>    enum Tolerance {</span>
  982 |     | <span class='neutral'>        DEFAULT,</span>
  983 |     | <span class='neutral'>        STRICT,</span>
  984 |     | <span class='neutral'>        ONE_MONTH</span>
  985 |     | <span class='neutral'>    }</span>
  986 |     | <span class='neutral'>    struct Data {</span>
  987 |     | <span class='neutral'>        bytes32 feedId;</span>
  988 |     | <span class='neutral'>        uint256 strictStalenessTolerance;</span>
  989 |     | <span class='neutral'>    }</span>
  990 |     | <span class='neutral'>    function load(uint128 marketId) internal pure returns (Data storage price) {</span>
  991 |     | <span class='neutral'>        bytes32 s = keccak256(</span>
  992 |     | <span class='neutral'>            abi.encode(&quot;io.synthetix.perps-market.Price&quot;, marketId)</span>
  993 |     | <span class='neutral'>        );</span>
  994 |     | <span class='neutral'>        assembly {</span>
  995 |     | <span class='neutral'>            price.slot := s</span>
  996 |     | <span class='neutral'>        }</span>
  997 |     | <span class='neutral'>    }</span>
  998 |     | <span class='neutral'>}</span>
  999 |     | <span class='neutral'></span>
 1000 |     | <span class='neutral'>// @custom:artifact contracts/storage/Position.sol:Position</span>
 1001 |     | <span class='unexecuted'>library Position {</span>
 1002 |     | <span class='neutral'>    struct Data {</span>
 1003 |     | <span class='neutral'>        uint128 marketId;</span>
 1004 |     | <span class='neutral'>        int128 size;</span>
 1005 |     | <span class='neutral'>        uint128 latestInteractionPrice;</span>
 1006 |     | <span class='neutral'>        int128 latestInteractionFunding;</span>
 1007 |     | <span class='neutral'>        uint256 latestInterestAccrued;</span>
 1008 |     | <span class='neutral'>    }</span>
 1009 |     | <span class='neutral'>}</span>
 1010 |     | <span class='neutral'></span>
 1011 |     | <span class='neutral'>// @custom:artifact contracts/storage/SettlementStrategy.sol:SettlementStrategy</span>
 1012 |     | <span class='unexecuted'>library SettlementStrategy {</span>
 1013 |     | <span class='neutral'>    enum Type {</span>
 1014 |     | <span class='neutral'>        PYTH</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'>    struct Data {</span>
 1017 |     | <span class='neutral'>        Type strategyType;</span>
 1018 |     | <span class='neutral'>        uint256 settlementDelay;</span>
 1019 |     | <span class='neutral'>        uint256 settlementWindowDuration;</span>
 1020 |     | <span class='neutral'>        address priceVerificationContract;</span>
 1021 |     | <span class='neutral'>        bytes32 feedId;</span>
 1022 |     | <span class='neutral'>        uint256 settlementReward;</span>
 1023 |     | <span class='neutral'>        bool disabled;</span>
 1024 |     | <span class='neutral'>        uint256 commitmentPriceDelay;</span>
 1025 |     | <span class='neutral'>    }</span>
 1026 |     | <span class='neutral'>}</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>// @custom:artifact contracts/utils/BigNumber.sol:BigNumber</span>
 1029 |     | <span class='unexecuted'>library BigNumber {</span>
 1030 |     | <span class='neutral'>    uint256 internal constant CHUNK_SIZE = 2 ** 255;</span>
 1031 |     | <span class='neutral'>    struct Data {</span>
 1032 |     | <span class='neutral'>        uint256[] chunks;</span>
 1033 |     | <span class='neutral'>    }</span>
 1034 |     | <span class='neutral'>    struct Snapshot {</span>
 1035 |     | <span class='neutral'>        uint256 currentChunkId;</span>
 1036 |     | <span class='neutral'>        uint256 valueAtChunk;</span>
 1037 |     | <span class='neutral'>    }</span>
 1038 |     | <span class='neutral'>}</span>
 1039 |     | <span class='neutral'></span>
 1040 |     | <span class='neutral'>// @custom:artifact contracts/utils/Flags.sol:Flags</span>
 1041 |     | <span class='unexecuted'>library Flags {</span>
 1042 |     | <span class='unexecuted'>    bytes32 public constant PERPS_SYSTEM = &quot;perpsSystem&quot;;</span>
 1043 |     | <span class='unexecuted'>    bytes32 public constant CREATE_MARKET = &quot;createMarket&quot;;</span>
 1044 |     | <span class='neutral'>}</span>
 1045 |     | <span class='neutral'></span>

</code>
<br />

