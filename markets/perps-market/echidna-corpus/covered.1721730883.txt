/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/Proxy.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {UUPSProxyWithOwner} from "@synthetixio/core-contracts/contracts/proxy/UUPSProxyWithOwner.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * Synthetix V3 Perps Factory -- Proxy Contract
  8 |     |  *
  9 |     |  * Visit https://usecannon.com/packages/synthetix-perps-market to interact with this protocol
 10 |     |  */
 11 | *   | contract Proxy is UUPSProxyWithOwner {
 12 |     |     // solhint-disable-next-line no-empty-blocks
 13 |     |     constructor(
 14 |     |         address firstImplementation,
 15 |     |         address initialOwner
 16 |     |     ) UUPSProxyWithOwner(firstImplementation, initialOwner) {}
 17 |     | }
 18 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/Fuzz.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./FuzzModules.sol";
  5 |     | 
  6 | *r  | contract Fuzz is FuzzModules {
  7 |     |     constructor() payable {
  8 |     |         setup();
  9 |     |         setupActors();
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzAdmin.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./helper/preconditions/PreconditionsAdmin.sol";
   5 |     | import "./helper/postconditions/PostconditionsAdmin.sol";
   6 |     | 
   7 |     | contract FuzzAdmin is PreconditionsAdmin, PostconditionsAdmin {
   8 | *   |     function fuzz_mintUSDToSynthetix(uint256 amount) public {
   9 | *   |         amount = mintUSDToSynthetixPreconditions(amount);
  10 |     | 
  11 | *   |         v3Mock.mintUSDToSynthetix(amount);
  12 |     |     }
  13 |     | 
  14 | *   |     function fuzz_burnUSDFromSynthetix(uint256 amount) public {
  15 | *   |         amount = burnUSDFromSynthetixPreconditions(amount);
  16 |     | 
  17 | *r  |         v3Mock.burnUSDFromSynthetix(amount);
  18 |     |     }
  19 |     | 
  20 |     |     event DebugPrice(int256 p, string s);
  21 |     | 
  22 | *   |     function fuzz_changeWETHPythPrice(int64 newPrice) public {
  23 | *   |         ChangePythPriceParams memory params = changeWETHPythPricePreconditions(
  24 | *   |             newPrice
  25 |     |         );
  26 | *   |         fl.gt(
  27 | *   |             params.newPrice,
  28 |     |             0,
  29 |     |             "fuzz_changeWETHPythPrice AFTER CHANGED PRICE"
  30 |     |         );
  31 |     | 
  32 | *   |         pythWrapper.setBenchmarkPrice(WETH_FEED_ID, params.newPrice);
  33 |     | 
  34 |     |         changePythPricePostconditions(params.id, params.newPrice);
  35 |     |     }
  36 |     | 
  37 | *   |     function fuzz_changeWBTCPythPrice(int64 newPrice) public {
  38 | *   |         ChangePythPriceParams memory params = changeWBTCPythPricePreconditions(
  39 | *   |             newPrice
  40 |     |         );
  41 | *   |         fl.gt(
  42 | *   |             params.newPrice,
  43 |     |             0,
  44 |     |             "fuzz_changeWBTCPythPrice AFTER CHANGED PRICE"
  45 |     |         );
  46 |     | 
  47 | *   |         pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, params.newPrice);
  48 |     | 
  49 |     |         changePythPricePostconditions(params.id, params.newPrice);
  50 |     |     }
  51 |     | 
  52 |     |     event OM(bytes32 node, string s);
  53 |     | 
  54 | *   |     function fuzz_changeOracleManagerPrice(
  55 |     |         uint256 nodeIndex,
  56 |     |         int256 newPrice
  57 |     |     ) public {
  58 | *   |         (
  59 | *   |             int256 newClampedPrice,
  60 | *   |             bytes32 nodeId
  61 | *   |         ) = changeOracleManagerPricePreconditions(nodeIndex, newPrice);
  62 | *   |         fl.gt(
  63 |     |             newClampedPrice,
  64 |     |             0,
  65 |     |             "fuzz_changeOracleManagerPrice CLAMPED PRICE NEGATIVE!"
  66 |     |         );
  67 |     | 
  68 | *   |         mockOracleManager.changePrice(nodeId, newClampedPrice);
  69 |     | 
  70 | *   |         changeOracleManagerPricePostconditions(nodeId, newClampedPrice);
  71 |     |     }
  72 |     | 
  73 | *   |     function fuzz_delegateCollateral(
  74 |     |         uint128 accountId,
  75 |     |         uint128 poolId,
  76 |     |         uint256 collateralIndex,
  77 |     |         uint256 newCollateralAmountD18,
  78 |     |         uint256 leverage
  79 | *   |     ) public {
  80 | *   |         (
  81 | *   |             uint256 clampedNewCollateralAmountD18,
  82 | *   |             address collateralType,
  83 | *   |             uint128 marketId
  84 | *   |         ) = delegateCollateralPreconditions(
  85 | *   |                 newCollateralAmountD18,
  86 | *   |                 collateralIndex
  87 |     |             );
  88 |     | 
  89 | *r  |         vaultModuleMock.delegateCollateral(
  90 |     |             accountId,
  91 |     |             poolId,
  92 |     |             collateralType,
  93 |     |             clampedNewCollateralAmountD18,
  94 |     |             leverage,
  95 |     |             marketId
  96 |     |         );
  97 |     |     }
  98 |     | 
  99 | *   |     function fuzz_crashWBTCPythPrice(uint loops) public {
 100 | *   |         loops = fl.clamp(loops, 1, 20);
 101 |     |         ChangePythPriceParams memory params;
 102 | *   |         for (uint i; i < loops; i++) {
 103 | *   |             params = crashWBTCPythPricePreconditions();
 104 |     | 
 105 | *   |             pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, params.newPrice);
 106 |     |         }
 107 |     |         fl.gt(
 108 |     |             params.newPrice,
 109 |     |             0,
 110 |     |             "fuzz_crashWBTCPythPrice AFTER CHANGED PRICE"
 111 |     |         );
 112 |     | 
 113 |     |         changePythPricePostconditions(params.id, params.newPrice);
 114 |     |     }
 115 |     | 
 116 | *   |     function fuzz_pumpWBTCPythPrice(uint loops) public {
 117 | *   |         loops = fl.clamp(loops, 1, 20);
 118 |     | 
 119 |     |         ChangePythPriceParams memory params;
 120 | *   |         for (uint i; i < loops; i++) {
 121 | *   |             params = pumpWBTCPythPricePreconditions();
 122 |     | 
 123 | *   |             pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, params.newPrice);
 124 |     |         }
 125 | *   |         fl.gt(
 126 | *   |             params.newPrice,
 127 |     |             0,
 128 |     |             "fuzz_crashWBTCPythPrice AFTER CHANGED PRICE"
 129 |     |         );
 130 |     | 
 131 |     |         changePythPricePostconditions(params.id, params.newPrice);
 132 |     |     }
 133 |     | 
 134 | *   |     function fuzz_crashWETHPythPrice(uint loops) public {
 135 | *   |         loops = fl.clamp(loops, 1, 20);
 136 |     | 
 137 |     |         ChangePythPriceParams memory params;
 138 | *   |         for (uint i; i < loops; i++) {
 139 | *   |             params = crashWETHPythPricePreconditions();
 140 |     | 
 141 | *   |             pythWrapper.setBenchmarkPrice(WETH_FEED_ID, params.newPrice);
 142 |     |         }
 143 | *   |         fl.gt(
 144 | *   |             params.newPrice,
 145 |     |             0,
 146 |     |             "fuzz_crashWETHPythPrice AFTER CHANGED PRICE"
 147 |     |         );
 148 |     | 
 149 | *   |         changePythPricePostconditions(params.id, params.newPrice);
 150 |     |     }
 151 |     | 
 152 | *   |     function fuzz_pumpWETHPythPrice(uint loops) public {
 153 | *   |         loops = fl.clamp(loops, 1, 20);
 154 |     | 
 155 |     |         ChangePythPriceParams memory params;
 156 | *   |         for (uint i; i < loops; i++) {
 157 | *   |             params = pumpWETHPythPricePreconditions();
 158 |     | 
 159 | *   |             pythWrapper.setBenchmarkPrice(WETH_FEED_ID, params.newPrice);
 160 |     |         }
 161 |     |         fl.gt(
 162 |     |             params.newPrice,
 163 |     |             0,
 164 |     |             "fuzz_crashWETHPythPrice AFTER CHANGED PRICE"
 165 |     |         );
 166 |     | 
 167 |     |         changePythPricePostconditions(params.id, params.newPrice);
 168 |     |     }
 169 |     | }
 170 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzGuidedModule.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./FuzzLiquidationModule.sol";
   5 |     | import "./FuzzOrderModule.sol";
   6 |     | import "./FuzzAdmin.sol";
   7 |     | import "./FuzzPerpsAccountModule.sol";
   8 |     | 
   9 |     | contract FuzzGuidedModule is
  10 |     |     FuzzLiquidationModule,
  11 |     |     FuzzPerpsAccountModule,
  12 |     |     FuzzOrderModule,
  13 |     |     FuzzAdmin
  14 |     | {
  15 | *   |     function fuzz_guided_depositAndShort() public {
  16 | *   |         fuzz_modifyCollateral(1e18, 1);
  17 | *   |         fuzz_commitOrder(-2e18, type(uint256).max - 1); //-1 is weth short
  18 |     |     }
  19 |     | 
  20 | *   |     function fuzz_guided_createDebt_LiquidateMarginOnly(
  21 |     |         bool isWETH,
  22 |     |         int amountToDeposit
  23 | *   |     ) public {
  24 | *   |         uint collateralId = isWETH ? 1 : 2;
  25 | *r  |         amountToDeposit = fl.clamp(amountToDeposit, 1, type(int64).max);
  26 |     | 
  27 | *   |         getPendingOrders(currentActor);
  28 | *   |         closeAllPositions(userToAccountIds[currentActor]);
  29 | *   |         repayDebt();
  30 | *   |         fuzz_withdrawAllCollateral(
  31 | *   |             userToAccountIds[currentActor],
  32 |     |             true,
  33 |     |             true,
  34 |     |             true
  35 |     |         );
  36 | *   |         fuzz_modifyCollateral(amountToDeposit, collateralId);
  37 |     | 
  38 | *   |         (bool success, bytes memory returnData) = perps.call(
  39 | *   |             abi.encodeWithSelector(
  40 |     |                 perpsAccountModuleImpl.getCollateralAmount.selector,
  41 | *   |                 userToAccountIds[currentActor],
  42 |     |                 collateralId
  43 |     |             )
  44 |     |         );
  45 | *   |         require(success);
  46 | *   |         uint256 amount = abi.decode(returnData, (uint256));
  47 | *   |         fl.log(
  48 |     |             "Currect collateral amount afrer withdrawal and deposits",
  49 |     |             amount
  50 |     |         );
  51 |     | 
  52 | *r  |         require(amount > 0, "User needs some collateral");
  53 |     | 
  54 | *   |         fuzz_commitOrder(
  55 | *   |             int128(uint128(amount) * 2),
  56 | *   |             isWETH ? type(uint256).max - 1 : type(uint256).max //maxprice + marketId
  57 |     |         );
  58 | *   |         fuzz_settleOrder();
  59 | *   |         isWETH
  60 | *   |             ? fuzz_crashWETHPythPrice(uint(amountToDeposit))
  61 | *   |             : fuzz_crashWBTCPythPrice(uint(amountToDeposit));
  62 | *   |         fuzz_commitOrder((int128(uint128(amount * 2)) * -1), isWETH ? 6 : 5); //maxprice + marketId
  63 | *   |         fuzz_settleOrder();
  64 | *   |         isWETH ? fuzz_crashWETHPythPrice(20) : fuzz_crashWBTCPythPrice(20);
  65 | *   |         fuzz_liquidateMarginOnly();
  66 |     |     }
  67 |     | 
  68 | *   |     function repayDebt() public returns (int256 debt) {
  69 | *   |         (bool success, bytes memory returnData) = perps.call(
  70 | *   |             abi.encodeWithSelector(
  71 |     |                 perpsAccountModuleImpl.debt.selector,
  72 | *   |                 userToAccountIds[currentActor]
  73 |     |             )
  74 |     |         );
  75 | *r  |         require(success);
  76 | *   |         debt = abi.decode(returnData, (int256));
  77 | *   |         if (debt > 0) {
  78 | *   |             fuzz_payDebt(uint128(int128(debt)));
  79 |     |         }
  80 |     |     }
  81 |     | 
  82 | *   |     function getPendingOrders(address user) internal {
  83 | *   |         uint128 accountId = userToAccountIds[user];
  84 |     | 
  85 |     |         // Get the order
  86 | *   |         (bool success, bytes memory returnData) = perps.call(
  87 | *   |             abi.encodeWithSelector(
  88 |     |                 asyncOrderModuleImpl.getOrder.selector,
  89 |     |                 accountId
  90 |     |             )
  91 |     |         );
  92 | *   |         require(success);
  93 | *   |         AsyncOrder.Data memory order = abi.decode(
  94 | *   |             returnData,
  95 |     |             (AsyncOrder.Data)
  96 |     |         );
  97 |     | 
  98 |     |         // Check if the order is expired
  99 | *   |         (success, returnData) = perps.call(
 100 | *   |             abi.encodeWithSelector(
 101 |     |                 mockLensModuleImpl.isOrderExpired.selector,
 102 |     |                 accountId
 103 |     |             )
 104 |     |         );
 105 | *   |         require(success);
 106 | *   |         bool isOrderExpired = abi.decode(returnData, (bool));
 107 |     | 
 108 |     |         // Validate the order
 109 | *   |         require(
 110 | *   |             order.request.sizeDelta == 0 || isOrderExpired,
 111 |     |             "No unsettled orders"
 112 |     |         );
 113 |     |     }
 114 | *   |     function closeAllPositions(uint128 accountId) internal {
 115 | *   |         uint128[] memory marketIds = new uint128[](2);
 116 | *   |         marketIds[0] = 1; // WETH market
 117 | *   |         marketIds[1] = 2; // WBTC market
 118 |     | 
 119 | *   |         for (uint i = 0; i < marketIds.length; i++) {
 120 | *   |             uint128 marketId = marketIds[i];
 121 | *   |             bool isWETH = (marketId == 1);
 122 |     | 
 123 |     |             // Get open position
 124 | *   |             (bool success, bytes memory returnData) = perps.call(
 125 | *   |                 abi.encodeWithSelector(
 126 |     |                     perpsAccountModuleImpl.getOpenPosition.selector,
 127 |     |                     accountId,
 128 |     |                     marketId
 129 |     |                 )
 130 |     |             );
 131 | *   |             require(success);
 132 |     | 
 133 | *   |             (
 134 | *   |                 int256 totalPnl,
 135 | *   |                 int256 accruedFunding,
 136 | *   |                 int128 positionSize,
 137 | *   |                 uint256 owedInterest
 138 | *   |             ) = abi.decode(returnData, (int256, int256, int128, uint256));
 139 |     | 
 140 |     |             // If position size is not zero, close the position
 141 | *   |             if (positionSize != 0) {
 142 | *   |                 vm.prank(accountIdToUser[accountId]);
 143 | *   |                 fuzz_commitOrder(
 144 | *   |                     int128(uint128(positionSize)) * -1,
 145 | *   |                     isWETH ? 6 : 5 // 6 for WETH (marketId 1), 5 for WBTC (marketId 2)
 146 |     |                 );
 147 |     | 
 148 |     |                 // Settle the order
 149 | *   |                 fuzz_settleOrder();
 150 |     |             }
 151 |     |         }
 152 |     |     }
 153 |     | 
 154 | *   |     function fuzz_withdrawAllCollateral(
 155 |     |         uint128 accountId,
 156 |     |         bool weth,
 157 |     |         bool wbtc,
 158 |     |         bool huge
 159 |     |     ) internal {
 160 | *   |         uint128[] memory collateralIds = new uint128[](3);
 161 | *   |         uint8 collateralCount = 0;
 162 |     | 
 163 | *   |         if (weth) {
 164 | *   |             collateralIds[collateralCount] = 1;
 165 | *   |             collateralCount++;
 166 |     |         }
 167 | *   |         if (wbtc) {
 168 | *   |             collateralIds[collateralCount] = 2;
 169 | *   |             collateralCount++;
 170 |     |         }
 171 | *   |         if (huge) {
 172 | *   |             collateralIds[collateralCount] = 3;
 173 | *   |             collateralCount++;
 174 |     |         }
 175 |     | 
 176 | *   |         for (uint i = 0; i < collateralCount; i++) {
 177 | *   |             uint128 collateralId = collateralIds[i];
 178 |     |             // Get collateral amount
 179 | *   |             (bool success, bytes memory returnData) = perps.call(
 180 | *   |                 abi.encodeWithSelector(
 181 |     |                     perpsAccountModuleImpl.getCollateralAmount.selector,
 182 |     |                     accountId,
 183 |     |                     collateralId
 184 |     |                 )
 185 |     |             );
 186 | *   |             require(success);
 187 | *   |             uint256 amount = abi.decode(returnData, (uint256));
 188 | *   |             if (amount > 0) {
 189 | *   |                 vm.prank(accountIdToUser[accountId]);
 190 | *   |                 (success, returnData) = perps.call(
 191 | *   |                     abi.encodeWithSelector(
 192 | *   |                         perpsAccountModuleImpl.modifyCollateral.selector,
 193 | *   |                         accountId,
 194 | *   |                         collateralId,
 195 | *   |                         -int256(amount)
 196 |     |                     )
 197 |     |                 );
 198 | *   |                 require(success);
 199 |     |             }
 200 |     |         }
 201 |     |     }
 202 |     | }
 203 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzLiquidationModule.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./FuzzSetup.sol";
  5 |     | import "./helper/preconditions/PreconditionsLiquidationModule.sol";
  6 |     | import "./helper/postconditions/PostconditionsLiquidationModule.sol";
  7 |     | import "./util/FunctionCalls.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title FuzzLiquidationModule
 11 |     |  * @author 0xScourgedev
 12 |     |  * @notice Fuzz handlers for LiquidationModule
 13 |     |  */
 14 |     | contract FuzzLiquidationModule is PreconditionsLiquidationModule, PostconditionsLiquidationModule {
 15 |     |     event Debug(string s);
 16 |     |     event LogBytes(bytes data);
 17 |     | 
 18 | *   |     function fuzz_liquidatePosition() public setCurrentActor {
 19 | *   |         LiquidatePositionParams memory params = liquidatePositionPreconditions();
 20 |     | 
 21 |     |         address[] memory actorsToUpdate = new address[](2);
 22 |     |         actorsToUpdate[0] = currentActor; //This is liquidator
 23 |     |         actorsToUpdate[1] = params.user;
 24 |     | 
 25 |     |         _before(actorsToUpdate);
 26 |     | 
 27 |     |         (bool success, bytes memory returnData) = _liquidatePositionCall(params.accountId);
 28 |     | 
 29 | *   |         liquidatePositionPostconditions(
 30 |     |             success,
 31 |     |             returnData,
 32 |     |             actorsToUpdate,
 33 |     |             params.user,
 34 |     |             currentActor,
 35 |     |             params.accountId
 36 |     |         );
 37 |     |     }
 38 |     | 
 39 | *   |     function fuzz_liquidateMarginOnly() public setCurrentActor {
 40 | *   |         LiquidateMarginOnlyParams memory params = liquidateMarginOnlyPreconditions();
 41 |     | 
 42 | *   |         address[] memory actorsToUpdate = new address[](2);
 43 | *   |         actorsToUpdate[0] = currentActor; //This is liquidator
 44 | *   |         actorsToUpdate[1] = params.user;
 45 |     | 
 46 | *   |         _before(actorsToUpdate);
 47 |     | 
 48 | *   |         (bool success, bytes memory returnData) = _liquidateMarginOnlyCall(params.accountId);
 49 |     | 
 50 | *   |         liquidateMarginOnlyPostconditions(
 51 | *   |             success,
 52 | *   |             returnData,
 53 | *   |             actorsToUpdate,
 54 | *   |             params.user,
 55 | *   |             params.accountId
 56 |     |         );
 57 |     |     }
 58 |     | 
 59 | *   |     function fuzz_liquidateFlagged(uint8 maxNumberOfAccounts) public {
 60 | *   |         LiquidateFlaggedParams memory params = liquidateFlaggedPreconditions(maxNumberOfAccounts);
 61 |     | 
 62 |     |         address[] memory actorsToUpdate = new address[](2);
 63 |     |         actorsToUpdate[0] = currentActor; //This is liquidator
 64 |     | 
 65 |     |         _before(actorsToUpdate);
 66 |     | 
 67 |     |         (bool success, bytes memory returnData) = _liquidateFlaggedCall(params.numberOfAccounts);
 68 |     | 
 69 | *   |         liquidateFlaggedPostconditions(success, returnData, actorsToUpdate, params.flaggedAccounts);
 70 |     |     }
 71 |     | 
 72 | *   |     function fuzz_liquidateFlaggedAccounts(uint8 maxNumberOfAccounts) public {
 73 | *   |         LiquidateFlaggedParams memory params = liquidateFlaggedPreconditions(maxNumberOfAccounts);
 74 |     | 
 75 |     |         address[] memory actorsToUpdate = new address[](2);
 76 |     |         actorsToUpdate[0] = currentActor; //This is liquidator
 77 |     | 
 78 |     |         _before(actorsToUpdate);
 79 |     | 
 80 |     |         (bool success, bytes memory returnData) = _liquidateFlaggedAccountsCall(
 81 |     |             params.flaggedAccounts
 82 |     |         );
 83 |     | 
 84 |     |         luquidateFlaggedAccountsPostconditions(
 85 |     |             success,
 86 |     |             returnData,
 87 |     |             actorsToUpdate,
 88 |     |             params.flaggedAccounts
 89 |     |         );
 90 |     |     }
 91 |     | }
 92 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzModules.sol
 1 |     | // SPDX-License-Identifier: GPL-3.0
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | import "./FuzzGuidedModule.sol";
 5 |     | 
 6 |     | contract FuzzModules is FuzzGuidedModule {}
 7 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzOrderModule.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./FuzzSetup.sol";
   5 |     | import "./helper/preconditions/PreconditionsOrderModule.sol";
   6 |     | import "./helper/postconditions/PostconditionsOrderModule.sol";
   7 |     | import "./util/FunctionCalls.sol";
   8 |     | import "../storage/Position.sol";
   9 |     | 
  10 |     | contract FuzzOrderModule is PreconditionsOrderModule, PostconditionsOrderModule {
  11 | *   |     mapping(uint128 accountId => CommitOrderParams params) public pendingOrder;
  12 |     | 
  13 | *   |     function fuzz_commitOrder(int128 sizeDelta, uint256 acceptablePrice) public setCurrentActor {
  14 | *   |         console2.log("===== FuzzOrderModule::fuzz_commitOrder START =====");
  15 |     | 
  16 | *   |         address[] memory actorsToUpdate = new address[](1);
  17 | *   |         actorsToUpdate[0] = currentActor;
  18 | *   |         console2.log("===== _currentActor  =====", msg.sender);
  19 |     | 
  20 | *   |         bytes32 trackingCode;
  21 | *   |         address referrer;
  22 | *   |         int128 positionSize;
  23 | *   |         console.log("msg.sender", msg.sender);
  24 | *   |         console2.log("===== _before START =====");
  25 | *   |         _before(actorsToUpdate);
  26 | *   |         console.log("msg.sender", msg.sender);
  27 |     | 
  28 | *   |         console2.log("===== _before END =====");
  29 |     | 
  30 | *   |         console2.log("===== commitOrderPreconditions START =====");
  31 | *   |         CommitOrderParams memory params = commitOrderPreconditions(
  32 | *   |             sizeDelta,
  33 | *   |             acceptablePrice,
  34 | *   |             trackingCode,
  35 | *   |             referrer
  36 |     |         );
  37 |     | 
  38 |     |         // require(pendingOrder[params.accountId].accountId == uint128(0), "User has a pending order");
  39 |     | 
  40 | *   |         console.log("msg.sender", msg.sender);
  41 |     | 
  42 | *   |         console2.log("===== commitOrderPreconditions END =====");
  43 |     | 
  44 | *   |         positionSize = params.marketId == 1
  45 | *   |             ? states[0].actorStates[params.accountId].wethMarket.positionSize
  46 | *   |             : states[0].actorStates[params.accountId].wbtcMarket.positionSize;
  47 |     | 
  48 |     |         
  49 |     |         // Close position entirely.
  50 | *   |         if (acceptablePrice % 5 == 0 && positionSize != 0) {
  51 | *   |             params.sizeDelta = positionSize * -1;
  52 |     |         }
  53 | *   |         console2.log("===== _commitOrderCall START =====");
  54 |     | 
  55 | *   |         (bool success, bytes memory returnData) = _commitOrderCall(
  56 | *   |             params.accountId,
  57 | *   |             params.marketId,
  58 | *   |             params.sizeDelta,
  59 | *   |             params.acceptablePrice,
  60 | *   |             params.settlementStrategyId,
  61 | *   |             params.trackingCode,
  62 | *   |             params.referrer
  63 |     |         );
  64 | *   |         console2.log("===== _commitOrderCall END =====");
  65 | *   |         console2.log("===== commitOrderPostconditions START =====");
  66 |     | 
  67 |     | 
  68 | *   |         commitOrderPostconditions(
  69 | *   |             success,
  70 | *   |             returnData,
  71 | *   |             actorsToUpdate,
  72 | *   |             params.accountId,
  73 | *   |             params.marketId
  74 |     |         );
  75 |     | 
  76 | *   |         pendingOrder[params.accountId] = params;
  77 | *   |         console2.log("===== commitOrderPostconditions END =====");
  78 |     | 
  79 | *   |         console2.log("===== FuzzOrderModule::fuzz_commitOrder END =====");
  80 |     |     }
  81 |     | 
  82 | *   |     function fuzz_settleOrder() public setCurrentActor {
  83 | *   |         vm.warp(block.timestamp + 6);
  84 | *   |         SettleOrderParams memory params = settleOrderPreconditions();
  85 |     | 
  86 | *   |         address[] memory actorsToUpdate = new address[](2);
  87 | *   |         actorsToUpdate[0] = currentActor;
  88 | *   |         actorsToUpdate[1] = params.settleUser;
  89 |     | 
  90 | *   |         _before(actorsToUpdate);
  91 |     | 
  92 | *   |         fl.log(">>>>>>CURRENT ACTOR:", currentActor);
  93 | *   |         (bool success, bytes memory returnData) = _settleOrderCall(
  94 | *   |             actorsToUpdate[1],
  95 | *   |             params.accountId
  96 |     |         );
  97 |     |         // if (success && (params.sizeDelta < 0)) {
  98 |     |         //     fl.eq(params.sizeDelta, 0, "SO SIZE NEGATIVE SETTLED");
  99 |     |         // }
 100 |     | 
 101 | *   |         settleOrderPostconditions(
 102 |     |             success,
 103 |     |             returnData,
 104 | *   |             actorsToUpdate,
 105 | *   |             params.settleUser,
 106 | *   |             params.accountId,
 107 | *   |             pendingOrder[params.accountId].marketId
 108 |     |         );
 109 | *   |         delete pendingOrder[params.accountId];
 110 |     |     }
 111 |     | 
 112 | *   |     function fuzz_cancelOrder(uint8 cancelUser) public setCurrentActor {
 113 | *   |         vm.warp(block.timestamp + 6); //TODO:
 114 | *   |         CancelOrderParams memory params = cancelOrderPreconditions(cancelUser);
 115 |     | 
 116 | *   |         address[] memory actorsToUpdate = new address[](2);
 117 | *   |         actorsToUpdate[0] = currentActor;
 118 | *   |         actorsToUpdate[1] = params.cancelUser;
 119 |     | 
 120 | *   |         _before(actorsToUpdate);
 121 |     | 
 122 | *   |         (bool success, bytes memory returnData) = _cancelOrderCall(
 123 | *   |             actorsToUpdate[1],
 124 | *   |             params.accountId
 125 |     |         );
 126 |     | 
 127 | *   |         cancelOrderPostconditions(
 128 | *   |             success,
 129 | *   |             returnData,
 130 | *   |             actorsToUpdate,
 131 | *   |             params.cancelUser,
 132 | *   |             params.accountId
 133 |     |         );
 134 | *   |         delete pendingOrder[params.accountId];
 135 |     |     }
 136 |     | }
 137 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzPerpsAccountModule.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./helper/preconditions/PreconditionsPerpsAccountModule.sol";
  5 |     | import "./helper/postconditions/PostconditionsPerpsAccountModule.sol";
  6 |     | import "./util/FunctionCalls.sol";
  7 |     | 
  8 |     | contract FuzzPerpsAccountModule is
  9 |     |     PreconditionsPerpsAccountModule,
 10 |     |     PostconditionsPerpsAccountModule
 11 |     | {
 12 |     |     event DebugPerpsAccount(string s);
 13 | *   |     function fuzz_modifyCollateral(
 14 |     |         int256 amountDelta,
 15 |     |         uint collateralTokenIndex
 16 | *   |     ) public setCurrentActor {
 17 | *   |         ModifyCollateralParams memory params = modifyCollateralPreconditions(
 18 | *   |             amountDelta,
 19 | *   |             collateralTokenIndex
 20 |     |         );
 21 | *   |         address[] memory actorsToUpdate = new address[](1);
 22 | *   |         actorsToUpdate[0] = currentActor;
 23 | *   |         emit DebugPerpsAccount("HERE#1");
 24 | *   |         _before(actorsToUpdate);
 25 | *   |         emit DebugPerpsAccount("HERE#2");
 26 |     | 
 27 | *   |         (bool success, bytes memory returnData) = _modifyCollateralCall(
 28 | *   |             params.accountId,
 29 | *   |             params.collateralId,
 30 | *   |             params.amountDelta
 31 |     |         );
 32 | *   |         emit DebugPerpsAccount("HERE#3");
 33 |     | 
 34 | *   |         modifyCollateralPostconditions(
 35 | *   |             params.amountDelta,
 36 | *   |             success,
 37 | *   |             returnData,
 38 | *   |             actorsToUpdate,
 39 | *   |             params.collateralAddress,
 40 | *   |             params.accountId
 41 |     |         );
 42 | *   |         emit DebugPerpsAccount("HERE#4");
 43 |     |     }
 44 |     | 
 45 | *   |     function fuzz_payDebt(uint128 amount) public setCurrentActor {
 46 | *   |         PayDebtParams memory params = payDebtPreconditions(amount);
 47 |     | 
 48 | *   |         address[] memory actorsToUpdate = new address[](1);
 49 | *   |         actorsToUpdate[0] = currentActor;
 50 |     | 
 51 | *   |         _before(actorsToUpdate);
 52 |     | 
 53 | *   |         (bool success, bytes memory returnData) = _payDebtCall(params.accountId, params.amount);
 54 |     | 
 55 | *   |         payDebtPostconditions(success, returnData, actorsToUpdate, params.accountId);
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/FuzzSetup.sol
    1 |     | // SPDX-License-Identifier: GPL-3.0
    2 |     | pragma solidity ^0.8.0;
    3 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
    4 |     | import {MarketConfiguration} from "../../storage.dump.sol";
    5 |     | import {Flags} from "../utils/Flags.sol";
    6 |     | import {AccountRBAC} from "@synthetixio/main/contracts/storage/AccountRBAC.sol";
    7 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
    8 |     | 
    9 |     | import "./helper/FuzzStorageVariables.sol";
   10 |     | contract FuzzSetup is FuzzBase, FuzzStorageVariables {
   11 |     |     function setup() internal {
   12 |     |         //Foundry comparibility
   13 |     |         checkCaller = new CheckCaller();
   14 |     | 
   15 |     |         router = new MockRouter();
   16 |     |         perps = address(new Proxy(address(router), address(this)));
   17 |     | 
   18 |     |         deployImplementations();
   19 |     | 
   20 |     |         addAsyncOrderModuleSels();
   21 |     |         addAsyncOrderCancelModuleSels();
   22 |     |         addAsyncOrderSettlementPythModuleSels();
   23 |     |         addCollateralConfigurationModuleSels();
   24 |     |         addGlobalPerpsMarketModuleSels();
   25 |     |         addMarketConfigurationModuleSels();
   26 |     |         addPerpsAccountModuleSels();
   27 |     |         addPerpsMarketFactoryModuleSels();
   28 |     |         addPerpsMarketModuleSels();
   29 |     |         addLiquidationModuleSels();
   30 |     |         addMockLensModuleSels();
   31 |     |         addFeatureFlagModuleSels();
   32 |     |         addMockModuleSels();
   33 |     |         addMockPythERC7412WrapperSels();
   34 |     |         //bootstrap()
   35 |     |         setPythPriceFeed();
   36 |     |         addWETHSettlementStrategy();
   37 |     |         addWBTCSettlementStrategy();
   38 |     |         addHUGESettlementStrategy();
   39 |     |         setSnxUSDCollateralConfiguration();
   40 |     |         setWETHCollateralConfiguration();
   41 |     |         setWBTCCollateralConfiguration();
   42 |     |         setHUGECollateralConfiguration();
   43 |     |         registerWETHDistributor();
   44 |     |         registerWBTCDistributor();
   45 |     |         registerHugeDistributor();
   46 |     |         setSynthMaketIdAndAddresses();
   47 |     | 
   48 |     |         //bootstrapPerpsMarkets()
   49 |     |         addToFeatureFlagAllowlist();
   50 |     |         enableAllFeatureFlags();
   51 |     |         initializePerpsMarketFactory();
   52 |     |         setPerpsMarketName();
   53 |     |         setCreateMarketWETH();
   54 |     |         setCreateMarketWBTC();
   55 |     |         setCreateMarketHUGE();
   56 |     |         setUpdatePriceDataWETH();
   57 |     |         setUpdatePriceDataWBTC();
   58 |     |         setUpdatePriceDataHUGE();
   59 |     |         setFundingParametersWETH();
   60 |     |         setFundingParametersWBTC();
   61 |     |         setFundingParametersHUGE();
   62 |     |         setMaxMarketSizeWETH();
   63 |     |         setMaxMarketSizeWBTC();
   64 |     |         setMaxMarketSizeHUGE();
   65 |     |         setMaxMarketValueWETH();
   66 |     |         setMaxMarketValueWBTC();
   67 |     |         setMaxMarketValueHUGE();
   68 |     |         setOrderFeesWETH();
   69 |     |         setOrderFeesWBTC();
   70 |     |         setOrderFeesHUGE();
   71 |     |         setLiquidationParametersWETH();
   72 |     |         setLiquidationParametersWBTC();
   73 |     |         setLiquidationParametersHUGE();
   74 |     |         setMaxLiquidationParametersWETH();
   75 |     |         setMaxLiquidationParametersWBTC();
   76 |     |         setMaxLiquidationParametersHUGE();
   77 |     |         createKeeperCostNode();
   78 |     |         updateKeeperCostNodeId();
   79 |     |         createAccounts();
   80 |     |         grantAccountPermissions();
   81 |     |         setMaxCollateralsPerAccount();
   82 |     |         setPerpMarketFactoryModuleImplInVault();
   83 |     |         setupActors();
   84 |     |     }
   85 |     | 
   86 |     |     function deployImplementations() private {
   87 |     |         sUSDTokenMock = new MockERC20("sUSD Token", "sUSD", 18);
   88 |     |         wethTokenMock = new MockERC20("weth Token", "WETH", 18);
   89 |     |         wbtcTokenMock = new MockERC20("wbtc Token", "WBTC", 18);
   90 |     |         hugePrecisionTokenMock = new MockERC20(
   91 |     |             "Huge Precision Token",
   92 |     |             "HUGE",
   93 |     |             30
   94 |     |         );
   95 |     | 
   96 |     |         v3Mock = new MockSynthetixV3();
   97 |     | 
   98 |     |         deployMockOracleManager();
   99 |     |         deployMockSpotMarket();
  100 |     |         deployMockPythERC7412Wrapper();
  101 |     | 
  102 |     |         setOracleManager();
  103 |     |         setMockSynthetixUSDToken();
  104 |     |         setMockWethToken();
  105 |     |         setMockWbtcToken();
  106 |     |         setMockhugeToken();
  107 |     | 
  108 |     |         coreModuleImpl = new CoreModule();
  109 |     | 
  110 |     |         asyncOrderCancelModuleImpl = new AsyncOrderCancelModule();
  111 |     |         asyncOrderModuleImpl = new AsyncOrderModule();
  112 |     |         asyncOrderSettlementPythModuleImpl = new AsyncOrderSettlementPythModule();
  113 |     |         collateralConfigurationModuleImpl = new CollateralConfigurationModule();
  114 |     |         featureFlagModuleImpl = new FeatureFlagModule();
  115 |     |         globalPerpsMarketModuleImpl = new GlobalPerpsMarketModule();
  116 |     |         liquidationModuleImpl = new LiquidationModule();
  117 |     |         marketConfigurationModuleImpl = new MarketConfigurationModule();
  118 |     |         perpsAccountModuleImpl = new PerpsAccountModule();
  119 |     |         perpsMarketFactoryModuleImpl = new PerpsMarketFactoryModule();
  120 |     |         perpsMarketModuleImpl = new PerpsMarketModule();
  121 |     | 
  122 |     |         //Mocks
  123 |     |         mockModuleImpl = new MockModule();
  124 |     |         mockPyth = new MockPyth();
  125 |     | 
  126 |     |         rewardWETHDistributorMock = new MockRewardDistributor(
  127 |     |             v3Mock,
  128 |     |             REWARD_DISTRIBUTOR_WETH_POOL_ID,
  129 |     |             1 //WETH
  130 |     |         );
  131 |     |         rewardWBTCDistributorMock = new MockRewardDistributor(
  132 |     |             v3Mock,
  133 |     |             REWARD_DISTRIBUTOR_WBTC_POOL_ID,
  134 |     |             2 //WBTC
  135 |     |         );
  136 |     |         rewardHUGEDistributorMock = new MockRewardDistributor(
  137 |     |             v3Mock,
  138 |     |             REWARD_DISTRIBUTOR_HUGE_POOL_ID,
  139 |     |             3 //WBTC
  140 |     |         );
  141 |     | 
  142 |     |         vaultModuleMock = new MockVaultModule(v3Mock, perps);
  143 |     |         mockLensModuleImpl = new MockLensModule();
  144 |     |     }
  145 |     | 
  146 |     |     function deployMockPythERC7412Wrapper() private {
  147 |     |         pythWrapper = new MockPythERC7412Wrapper(address(mockOracleManager));
  148 |     |         pythWrapper.setBenchmarkPrice(WETH_FEED_ID, 3_000e18);
  149 |     |         pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, 10_000e18);
  150 |     |     }
  151 |     | 
  152 |     |     function deployMockOracleManager() private {
  153 |     |         bytes32[] memory initialIds = new bytes32[](4);
  154 |     |         int256[] memory initialPrices = new int256[](4);
  155 |     | 
  156 |     |         initialIds[0] = SUSD_ORACLE_NODE_ID;
  157 |     |         initialIds[1] = WETH_ORACLE_NODE_ID;
  158 |     |         initialIds[2] = WBTC_ORACLE_NODE_ID;
  159 |     |         initialIds[3] = KEEPER_NODE_ID;
  160 |     | 
  161 |     |         initialPrices[0] = 1e18;
  162 |     |         initialPrices[1] = 3_000e18;
  163 |     |         initialPrices[2] = 10_000e18;
  164 |     |         initialPrices[3] = 1e18;
  165 |     | 
  166 |     |         tokenChainlinkNode[address(sUSDTokenMock)] = SUSD_ORACLE_NODE_ID;
  167 |     |         tokenChainlinkNode[address(wethTokenMock)] = WETH_ORACLE_NODE_ID;
  168 |     |         tokenChainlinkNode[address(wbtcTokenMock)] = WBTC_ORACLE_NODE_ID;
  169 |     |         tokenChainlinkNode[
  170 |     |             address(hugePrecisionTokenMock)
  171 |     |         ] = HUGE_ORACLE_NODE_ID;
  172 |     | 
  173 |     |         mockOracleManager = new MockOracleManager(initialIds, initialPrices);
  174 |     |     }
  175 |     | 
  176 |     |     function deployMockSpotMarket() private {
  177 |     |         spot = new MockSpotMarket(
  178 |     |             v3Mock,
  179 |     |             mockOracleManager,
  180 |     |             address(wethTokenMock),
  181 |     |             WETH_MARKET_SKEW_SCALE,
  182 |     |             address(wbtcTokenMock),
  183 |     |             WBTC_MARKET_SKEW_SCALE,
  184 |     |             address(hugePrecisionTokenMock),
  185 |     |             HUGE_MARKET_SKEW_SCALE,
  186 |     |             WETH_ORACLE_NODE_ID,
  187 |     |             WBTC_ORACLE_NODE_ID,
  188 |     |             HUGE_ORACLE_NODE_ID
  189 |     |         );
  190 |     |     }
  191 |     | 
  192 |     |     function setOracleManager() private {
  193 |     |         v3Mock.setOracleManager(address(mockOracleManager));
  194 |     |     }
  195 |     | 
  196 |     |     function setMockSynthetixUSDToken() private {
  197 |     |         v3Mock.setUSDToken(address(sUSDTokenMock), SUSD_ORACLE_NODE_ID);
  198 |     |     }
  199 |     | 
  200 |     |     function setMockWethToken() private {
  201 |     |         v3Mock.setWethToken(address(wethTokenMock), WETH_ORACLE_NODE_ID);
  202 |     |     }
  203 |     | 
  204 |     |     function setMockWbtcToken() private {
  205 |     |         v3Mock.setWbtcToken(address(wbtcTokenMock), WBTC_ORACLE_NODE_ID);
  206 |     |     }
  207 |     |     function setMockhugeToken() private {
  208 |     |         v3Mock.setHugeToken(
  209 |     |             address(hugePrecisionTokenMock),
  210 |     |             HUGE_ORACLE_NODE_ID
  211 |     |         );
  212 |     |     }
  213 |     | 
  214 |     |     function addLiquidationModuleSels() private {
  215 |     |         (bool success, ) = perps.call(
  216 |     |             abi.encodeWithSelector(
  217 |     |                 router.addFunctionAndImplementation.selector,
  218 |     |                 liquidationModuleImpl.liquidate.selector,
  219 |     |                 address(liquidationModuleImpl)
  220 |     |             )
  221 |     |         );
  222 |     |         assert(success);
  223 |     | 
  224 |     |         (success, ) = perps.call(
  225 |     |             abi.encodeWithSelector(
  226 |     |                 router.addFunctionAndImplementation.selector,
  227 |     |                 liquidationModuleImpl.liquidateMarginOnly.selector,
  228 |     |                 address(liquidationModuleImpl)
  229 |     |             )
  230 |     |         );
  231 |     |         assert(success);
  232 |     | 
  233 |     |         (success, ) = perps.call(
  234 |     |             abi.encodeWithSelector(
  235 |     |                 router.addFunctionAndImplementation.selector,
  236 |     |                 liquidationModuleImpl.liquidateFlagged.selector,
  237 |     |                 address(liquidationModuleImpl)
  238 |     |             )
  239 |     |         );
  240 |     |         assert(success);
  241 |     | 
  242 |     |         (success, ) = perps.call(
  243 |     |             abi.encodeWithSelector(
  244 |     |                 router.addFunctionAndImplementation.selector,
  245 |     |                 liquidationModuleImpl.liquidateFlaggedAccounts.selector,
  246 |     |                 address(liquidationModuleImpl)
  247 |     |             )
  248 |     |         );
  249 |     |         assert(success);
  250 |     | 
  251 |     |         (success, ) = perps.call(
  252 |     |             abi.encodeWithSelector(
  253 |     |                 router.addFunctionAndImplementation.selector,
  254 |     |                 liquidationModuleImpl.flaggedAccounts.selector,
  255 |     |                 address(liquidationModuleImpl)
  256 |     |             )
  257 |     |         );
  258 |     |         assert(success);
  259 |     | 
  260 |     |         (success, ) = perps.call(
  261 |     |             abi.encodeWithSelector(
  262 |     |                 router.addFunctionAndImplementation.selector,
  263 |     |                 liquidationModuleImpl.canLiquidate.selector,
  264 |     |                 address(liquidationModuleImpl)
  265 |     |             )
  266 |     |         );
  267 |     |         assert(success);
  268 |     | 
  269 |     |         (success, ) = perps.call(
  270 |     |             abi.encodeWithSelector(
  271 |     |                 router.addFunctionAndImplementation.selector,
  272 |     |                 liquidationModuleImpl.canLiquidateMarginOnly.selector,
  273 |     |                 address(liquidationModuleImpl)
  274 |     |             )
  275 |     |         );
  276 |     |         assert(success);
  277 |     | 
  278 |     |         (success, ) = perps.call(
  279 |     |             abi.encodeWithSelector(
  280 |     |                 router.addFunctionAndImplementation.selector,
  281 |     |                 liquidationModuleImpl.liquidationCapacity.selector,
  282 |     |                 address(liquidationModuleImpl)
  283 |     |             )
  284 |     |         );
  285 |     |         assert(success);
  286 |     |     }
  287 |     |     function addAsyncOrderModuleSels() private {
  288 |     |         (bool success, ) = perps.call(
  289 |     |             abi.encodeWithSelector(
  290 |     |                 router.addFunctionAndImplementation.selector,
  291 |     |                 asyncOrderModuleImpl.commitOrder.selector,
  292 |     |                 address(asyncOrderModuleImpl)
  293 |     |             )
  294 |     |         );
  295 |     |         assert(success);
  296 |     | 
  297 |     |         (success, ) = perps.call(
  298 |     |             abi.encodeWithSelector(
  299 |     |                 router.addFunctionAndImplementation.selector,
  300 |     |                 asyncOrderModuleImpl.getOrder.selector,
  301 |     |                 address(asyncOrderModuleImpl)
  302 |     |             )
  303 |     |         );
  304 |     |         assert(success);
  305 |     | 
  306 |     |         (success, ) = perps.call(
  307 |     |             abi.encodeWithSelector(
  308 |     |                 router.addFunctionAndImplementation.selector,
  309 |     |                 asyncOrderModuleImpl.computeOrderFees.selector,
  310 |     |                 address(asyncOrderModuleImpl)
  311 |     |             )
  312 |     |         );
  313 |     |         assert(success);
  314 |     | 
  315 |     |         (success, ) = perps.call(
  316 |     |             abi.encodeWithSelector(
  317 |     |                 router.addFunctionAndImplementation.selector,
  318 |     |                 asyncOrderModuleImpl.computeOrderFeesWithPrice.selector,
  319 |     |                 address(asyncOrderModuleImpl)
  320 |     |             )
  321 |     |         );
  322 |     |         assert(success);
  323 |     | 
  324 |     |         (success, ) = perps.call(
  325 |     |             abi.encodeWithSelector(
  326 |     |                 router.addFunctionAndImplementation.selector,
  327 |     |                 asyncOrderModuleImpl.getSettlementRewardCost.selector,
  328 |     |                 address(asyncOrderModuleImpl)
  329 |     |             )
  330 |     |         );
  331 |     |         assert(success);
  332 |     | 
  333 |     |         (success, ) = perps.call(
  334 |     |             abi.encodeWithSelector(
  335 |     |                 router.addFunctionAndImplementation.selector,
  336 |     |                 asyncOrderModuleImpl.requiredMarginForOrder.selector,
  337 |     |                 address(asyncOrderModuleImpl)
  338 |     |             )
  339 |     |         );
  340 |     |         assert(success);
  341 |     | 
  342 |     |         (success, ) = perps.call(
  343 |     |             abi.encodeWithSelector(
  344 |     |                 router.addFunctionAndImplementation.selector,
  345 |     |                 asyncOrderModuleImpl.requiredMarginForOrderWithPrice.selector,
  346 |     |                 address(asyncOrderModuleImpl)
  347 |     |             )
  348 |     |         );
  349 |     |         assert(success);
  350 |     |     }
  351 |     |     function addAsyncOrderCancelModuleSels() private {
  352 |     |         (bool success, ) = perps.call(
  353 |     |             abi.encodeWithSelector(
  354 |     |                 router.addFunctionAndImplementation.selector,
  355 |     |                 asyncOrderCancelModuleImpl.cancelOrder.selector,
  356 |     |                 address(asyncOrderCancelModuleImpl)
  357 |     |             )
  358 |     |         );
  359 |     |         assert(success);
  360 |     |     }
  361 |     | 
  362 |     |     function addMockPythERC7412WrapperSels() private {
  363 |     |         pythWrapper.setBenchmarkPrice(WETH_FEED_ID, 3_000e18);
  364 |     |         pythWrapper.setBenchmarkPrice(WBTC_FEED_ID, 10_000e18);
  365 |     |     }
  366 |     | 
  367 |     |     function addAsyncOrderSettlementPythModuleSels() private {
  368 |     |         (bool success, ) = perps.call(
  369 |     |             abi.encodeWithSelector(
  370 |     |                 router.addFunctionAndImplementation.selector,
  371 |     |                 asyncOrderSettlementPythModuleImpl.settleOrder.selector,
  372 |     |                 address(asyncOrderSettlementPythModuleImpl)
  373 |     |             )
  374 |     |         );
  375 |     |         assert(success);
  376 |     |     }
  377 |     | 
  378 |     |     function addCollateralConfigurationModuleSels() private {
  379 |     |         (bool success, ) = perps.call(
  380 |     |             abi.encodeWithSelector(
  381 |     |                 router.addFunctionAndImplementation.selector,
  382 |     |                 collateralConfigurationModuleImpl
  383 |     |                     .setCollateralConfiguration
  384 |     |                     .selector,
  385 |     |                 address(collateralConfigurationModuleImpl)
  386 |     |             )
  387 |     |         );
  388 |     |         assert(success);
  389 |     | 
  390 |     |         (success, ) = perps.call(
  391 |     |             abi.encodeWithSelector(
  392 |     |                 router.addFunctionAndImplementation.selector,
  393 |     |                 collateralConfigurationModuleImpl
  394 |     |                     .getCollateralConfiguration
  395 |     |                     .selector,
  396 |     |                 address(collateralConfigurationModuleImpl)
  397 |     |             )
  398 |     |         );
  399 |     |         assert(success);
  400 |     | 
  401 |     |         (success, ) = perps.call(
  402 |     |             abi.encodeWithSelector(
  403 |     |                 router.addFunctionAndImplementation.selector,
  404 |     |                 collateralConfigurationModuleImpl
  405 |     |                     .getCollateralConfigurationFull
  406 |     |                     .selector,
  407 |     |                 address(collateralConfigurationModuleImpl)
  408 |     |             )
  409 |     |         );
  410 |     |         assert(success);
  411 |     | 
  412 |     |         (success, ) = perps.call(
  413 |     |             abi.encodeWithSelector(
  414 |     |                 router.addFunctionAndImplementation.selector,
  415 |     |                 collateralConfigurationModuleImpl
  416 |     |                     .setCollateralLiquidateRewardRatio
  417 |     |                     .selector,
  418 |     |                 address(collateralConfigurationModuleImpl)
  419 |     |             )
  420 |     |         );
  421 |     |         assert(success);
  422 |     | 
  423 |     |         (success, ) = perps.call(
  424 |     |             abi.encodeWithSelector(
  425 |     |                 router.addFunctionAndImplementation.selector,
  426 |     |                 collateralConfigurationModuleImpl
  427 |     |                     .getCollateralLiquidateRewardRatio
  428 |     |                     .selector,
  429 |     |                 address(collateralConfigurationModuleImpl)
  430 |     |             )
  431 |     |         );
  432 |     |         assert(success);
  433 |     | 
  434 |     |         (success, ) = perps.call(
  435 |     |             abi.encodeWithSelector(
  436 |     |                 router.addFunctionAndImplementation.selector,
  437 |     |                 collateralConfigurationModuleImpl.registerDistributor.selector,
  438 |     |                 address(collateralConfigurationModuleImpl)
  439 |     |             )
  440 |     |         );
  441 |     |         assert(success);
  442 |     | 
  443 |     |         (success, ) = perps.call(
  444 |     |             abi.encodeWithSelector(
  445 |     |                 router.addFunctionAndImplementation.selector,
  446 |     |                 collateralConfigurationModuleImpl.isRegistered.selector,
  447 |     |                 address(collateralConfigurationModuleImpl)
  448 |     |             )
  449 |     |         );
  450 |     |         assert(success);
  451 |     | 
  452 |     |         (success, ) = perps.call(
  453 |     |             abi.encodeWithSelector(
  454 |     |                 router.addFunctionAndImplementation.selector,
  455 |     |                 collateralConfigurationModuleImpl
  456 |     |                     .getRegisteredDistributor
  457 |     |                     .selector,
  458 |     |                 address(collateralConfigurationModuleImpl)
  459 |     |             )
  460 |     |         );
  461 |     |         assert(success);
  462 |     |     }
  463 |     | 
  464 |     |     function addGlobalPerpsMarketModuleSels() private {
  465 |     |         (bool success, ) = perps.call(
  466 |     |             abi.encodeWithSelector(
  467 |     |                 router.addFunctionAndImplementation.selector,
  468 |     |                 globalPerpsMarketModuleImpl.getSupportedCollaterals.selector,
  469 |     |                 address(globalPerpsMarketModuleImpl)
  470 |     |             )
  471 |     |         );
  472 |     |         assert(success);
  473 |     | 
  474 |     |         (success, ) = perps.call(
  475 |     |             abi.encodeWithSelector(
  476 |     |                 router.addFunctionAndImplementation.selector,
  477 |     |                 globalPerpsMarketModuleImpl.setKeeperRewardGuards.selector,
  478 |     |                 address(globalPerpsMarketModuleImpl)
  479 |     |             )
  480 |     |         );
  481 |     |         assert(success);
  482 |     | 
  483 |     |         (success, ) = perps.call(
  484 |     |             abi.encodeWithSelector(
  485 |     |                 router.addFunctionAndImplementation.selector,
  486 |     |                 globalPerpsMarketModuleImpl.getKeeperRewardGuards.selector,
  487 |     |                 address(globalPerpsMarketModuleImpl)
  488 |     |             )
  489 |     |         );
  490 |     |         assert(success);
  491 |     | 
  492 |     |         (success, ) = perps.call(
  493 |     |             abi.encodeWithSelector(
  494 |     |                 router.addFunctionAndImplementation.selector,
  495 |     |                 globalPerpsMarketModuleImpl.totalGlobalCollateralValue.selector,
  496 |     |                 address(globalPerpsMarketModuleImpl)
  497 |     |             )
  498 |     |         );
  499 |     |         assert(success);
  500 |     | 
  501 |     |         (success, ) = perps.call(
  502 |     |             abi.encodeWithSelector(
  503 |     |                 router.addFunctionAndImplementation.selector,
  504 |     |                 globalPerpsMarketModuleImpl.globalCollateralValue.selector,
  505 |     |                 address(globalPerpsMarketModuleImpl)
  506 |     |             )
  507 |     |         );
  508 |     |         assert(success);
  509 |     | 
  510 |     |         (success, ) = perps.call(
  511 |     |             abi.encodeWithSelector(
  512 |     |                 router.addFunctionAndImplementation.selector,
  513 |     |                 globalPerpsMarketModuleImpl.setFeeCollector.selector,
  514 |     |                 address(globalPerpsMarketModuleImpl)
  515 |     |             )
  516 |     |         );
  517 |     |         assert(success);
  518 |     | 
  519 |     |         (success, ) = perps.call(
  520 |     |             abi.encodeWithSelector(
  521 |     |                 router.addFunctionAndImplementation.selector,
  522 |     |                 globalPerpsMarketModuleImpl.getFeeCollector.selector,
  523 |     |                 address(globalPerpsMarketModuleImpl)
  524 |     |             )
  525 |     |         );
  526 |     |         assert(success);
  527 |     | 
  528 |     |         (success, ) = perps.call(
  529 |     |             abi.encodeWithSelector(
  530 |     |                 router.addFunctionAndImplementation.selector,
  531 |     |                 globalPerpsMarketModuleImpl.updateKeeperCostNodeId.selector,
  532 |     |                 address(globalPerpsMarketModuleImpl)
  533 |     |             )
  534 |     |         );
  535 |     |         assert(success);
  536 |     | 
  537 |     |         (success, ) = perps.call(
  538 |     |             abi.encodeWithSelector(
  539 |     |                 router.addFunctionAndImplementation.selector,
  540 |     |                 globalPerpsMarketModuleImpl.getKeeperCostNodeId.selector,
  541 |     |                 address(globalPerpsMarketModuleImpl)
  542 |     |             )
  543 |     |         );
  544 |     |         assert(success);
  545 |     | 
  546 |     |         (success, ) = perps.call(
  547 |     |             abi.encodeWithSelector(
  548 |     |                 router.addFunctionAndImplementation.selector,
  549 |     |                 globalPerpsMarketModuleImpl.updateReferrerShare.selector,
  550 |     |                 address(globalPerpsMarketModuleImpl)
  551 |     |             )
  552 |     |         );
  553 |     |         assert(success);
  554 |     | 
  555 |     |         (success, ) = perps.call(
  556 |     |             abi.encodeWithSelector(
  557 |     |                 router.addFunctionAndImplementation.selector,
  558 |     |                 globalPerpsMarketModuleImpl.getReferrerShare.selector,
  559 |     |                 address(globalPerpsMarketModuleImpl)
  560 |     |             )
  561 |     |         );
  562 |     |         assert(success);
  563 |     | 
  564 |     |         (success, ) = perps.call(
  565 |     |             abi.encodeWithSelector(
  566 |     |                 router.addFunctionAndImplementation.selector,
  567 |     |                 globalPerpsMarketModuleImpl.getMarkets.selector,
  568 |     |                 address(globalPerpsMarketModuleImpl)
  569 |     |             )
  570 |     |         );
  571 |     |         assert(success);
  572 |     | 
  573 |     |         (success, ) = perps.call(
  574 |     |             abi.encodeWithSelector(
  575 |     |                 router.addFunctionAndImplementation.selector,
  576 |     |                 globalPerpsMarketModuleImpl.setPerAccountCaps.selector,
  577 |     |                 address(globalPerpsMarketModuleImpl)
  578 |     |             )
  579 |     |         );
  580 |     |         assert(success);
  581 |     | 
  582 |     |         (success, ) = perps.call(
  583 |     |             abi.encodeWithSelector(
  584 |     |                 router.addFunctionAndImplementation.selector,
  585 |     |                 globalPerpsMarketModuleImpl.getPerAccountCaps.selector,
  586 |     |                 address(globalPerpsMarketModuleImpl)
  587 |     |             )
  588 |     |         );
  589 |     |         assert(success);
  590 |     | 
  591 |     |         (success, ) = perps.call(
  592 |     |             abi.encodeWithSelector(
  593 |     |                 router.addFunctionAndImplementation.selector,
  594 |     |                 globalPerpsMarketModuleImpl.setInterestRateParameters.selector,
  595 |     |                 address(globalPerpsMarketModuleImpl)
  596 |     |             )
  597 |     |         );
  598 |     |         assert(success);
  599 |     | 
  600 |     |         (success, ) = perps.call(
  601 |     |             abi.encodeWithSelector(
  602 |     |                 router.addFunctionAndImplementation.selector,
  603 |     |                 globalPerpsMarketModuleImpl.getInterestRateParameters.selector,
  604 |     |                 address(globalPerpsMarketModuleImpl)
  605 |     |             )
  606 |     |         );
  607 |     |         assert(success);
  608 |     | 
  609 |     |         (success, ) = perps.call(
  610 |     |             abi.encodeWithSelector(
  611 |     |                 router.addFunctionAndImplementation.selector,
  612 |     |                 globalPerpsMarketModuleImpl.updateInterestRate.selector,
  613 |     |                 address(globalPerpsMarketModuleImpl)
  614 |     |             )
  615 |     |         );
  616 |     |         assert(success);
  617 |     |     }
  618 |     | 
  619 |     |     function addMarketConfigurationModuleSels() private {
  620 |     |         (bool success, ) = perps.call(
  621 |     |             abi.encodeWithSelector(
  622 |     |                 router.addFunctionAndImplementation.selector,
  623 |     |                 marketConfigurationModuleImpl.addSettlementStrategy.selector,
  624 |     |                 address(marketConfigurationModuleImpl)
  625 |     |             )
  626 |     |         );
  627 |     |         assert(success);
  628 |     | 
  629 |     |         (success, ) = perps.call(
  630 |     |             abi.encodeWithSelector(
  631 |     |                 router.addFunctionAndImplementation.selector,
  632 |     |                 marketConfigurationModuleImpl.setSettlementStrategy.selector,
  633 |     |                 address(marketConfigurationModuleImpl)
  634 |     |             )
  635 |     |         );
  636 |     |         assert(success);
  637 |     | 
  638 |     |         (success, ) = perps.call(
  639 |     |             abi.encodeWithSelector(
  640 |     |                 router.addFunctionAndImplementation.selector,
  641 |     |                 marketConfigurationModuleImpl
  642 |     |                     .setSettlementStrategyEnabled
  643 |     |                     .selector,
  644 |     |                 address(marketConfigurationModuleImpl)
  645 |     |             )
  646 |     |         );
  647 |     |         assert(success);
  648 |     | 
  649 |     |         (success, ) = perps.call(
  650 |     |             abi.encodeWithSelector(
  651 |     |                 router.addFunctionAndImplementation.selector,
  652 |     |                 marketConfigurationModuleImpl.setOrderFees.selector,
  653 |     |                 address(marketConfigurationModuleImpl)
  654 |     |             )
  655 |     |         );
  656 |     |         assert(success);
  657 |     | 
  658 |     |         (success, ) = perps.call(
  659 |     |             abi.encodeWithSelector(
  660 |     |                 router.addFunctionAndImplementation.selector,
  661 |     |                 marketConfigurationModuleImpl.updatePriceData.selector,
  662 |     |                 address(marketConfigurationModuleImpl)
  663 |     |             )
  664 |     |         );
  665 |     |         assert(success);
  666 |     | 
  667 |     |         (success, ) = perps.call(
  668 |     |             abi.encodeWithSelector(
  669 |     |                 router.addFunctionAndImplementation.selector,
  670 |     |                 marketConfigurationModuleImpl.getPriceData.selector,
  671 |     |                 address(marketConfigurationModuleImpl)
  672 |     |             )
  673 |     |         );
  674 |     |         assert(success);
  675 |     | 
  676 |     |         (success, ) = perps.call(
  677 |     |             abi.encodeWithSelector(
  678 |     |                 router.addFunctionAndImplementation.selector,
  679 |     |                 marketConfigurationModuleImpl.setMaxMarketSize.selector,
  680 |     |                 address(marketConfigurationModuleImpl)
  681 |     |             )
  682 |     |         );
  683 |     |         assert(success);
  684 |     | 
  685 |     |         (success, ) = perps.call(
  686 |     |             abi.encodeWithSelector(
  687 |     |                 router.addFunctionAndImplementation.selector,
  688 |     |                 marketConfigurationModuleImpl.setMaxMarketValue.selector,
  689 |     |                 address(marketConfigurationModuleImpl)
  690 |     |             )
  691 |     |         );
  692 |     |         assert(success);
  693 |     | 
  694 |     |         (success, ) = perps.call(
  695 |     |             abi.encodeWithSelector(
  696 |     |                 router.addFunctionAndImplementation.selector,
  697 |     |                 marketConfigurationModuleImpl.setFundingParameters.selector,
  698 |     |                 address(marketConfigurationModuleImpl)
  699 |     |             )
  700 |     |         );
  701 |     |         assert(success);
  702 |     | 
  703 |     |         (success, ) = perps.call(
  704 |     |             abi.encodeWithSelector(
  705 |     |                 router.addFunctionAndImplementation.selector,
  706 |     |                 marketConfigurationModuleImpl
  707 |     |                     .setMaxLiquidationParameters
  708 |     |                     .selector,
  709 |     |                 address(marketConfigurationModuleImpl)
  710 |     |             )
  711 |     |         );
  712 |     |         assert(success);
  713 |     | 
  714 |     |         (success, ) = perps.call(
  715 |     |             abi.encodeWithSelector(
  716 |     |                 router.addFunctionAndImplementation.selector,
  717 |     |                 marketConfigurationModuleImpl.setLiquidationParameters.selector,
  718 |     |                 address(marketConfigurationModuleImpl)
  719 |     |             )
  720 |     |         );
  721 |     |         assert(success);
  722 |     | 
  723 |     |         (success, ) = perps.call(
  724 |     |             abi.encodeWithSelector(
  725 |     |                 router.addFunctionAndImplementation.selector,
  726 |     |                 marketConfigurationModuleImpl.setLockedOiRatio.selector,
  727 |     |                 address(marketConfigurationModuleImpl)
  728 |     |             )
  729 |     |         );
  730 |     |         assert(success);
  731 |     | 
  732 |     |         (success, ) = perps.call(
  733 |     |             abi.encodeWithSelector(
  734 |     |                 router.addFunctionAndImplementation.selector,
  735 |     |                 marketConfigurationModuleImpl.getSettlementStrategy.selector,
  736 |     |                 address(marketConfigurationModuleImpl)
  737 |     |             )
  738 |     |         );
  739 |     |         assert(success);
  740 |     | 
  741 |     |         (success, ) = perps.call(
  742 |     |             abi.encodeWithSelector(
  743 |     |                 router.addFunctionAndImplementation.selector,
  744 |     |                 marketConfigurationModuleImpl
  745 |     |                     .getMaxLiquidationParameters
  746 |     |                     .selector,
  747 |     |                 address(marketConfigurationModuleImpl)
  748 |     |             )
  749 |     |         );
  750 |     |         assert(success);
  751 |     | 
  752 |     |         (success, ) = perps.call(
  753 |     |             abi.encodeWithSelector(
  754 |     |                 router.addFunctionAndImplementation.selector,
  755 |     |                 marketConfigurationModuleImpl.getLiquidationParameters.selector,
  756 |     |                 address(marketConfigurationModuleImpl)
  757 |     |             )
  758 |     |         );
  759 |     |         assert(success);
  760 |     | 
  761 |     |         (success, ) = perps.call(
  762 |     |             abi.encodeWithSelector(
  763 |     |                 router.addFunctionAndImplementation.selector,
  764 |     |                 marketConfigurationModuleImpl.getFundingParameters.selector,
  765 |     |                 address(marketConfigurationModuleImpl)
  766 |     |             )
  767 |     |         );
  768 |     |         assert(success);
  769 |     | 
  770 |     |         (success, ) = perps.call(
  771 |     |             abi.encodeWithSelector(
  772 |     |                 router.addFunctionAndImplementation.selector,
  773 |     |                 marketConfigurationModuleImpl.getMaxMarketSize.selector,
  774 |     |                 address(marketConfigurationModuleImpl)
  775 |     |             )
  776 |     |         );
  777 |     |         assert(success);
  778 |     | 
  779 |     |         (success, ) = perps.call(
  780 |     |             abi.encodeWithSelector(
  781 |     |                 router.addFunctionAndImplementation.selector,
  782 |     |                 marketConfigurationModuleImpl.getMaxMarketValue.selector,
  783 |     |                 address(marketConfigurationModuleImpl)
  784 |     |             )
  785 |     |         );
  786 |     |         assert(success);
  787 |     | 
  788 |     |         (success, ) = perps.call(
  789 |     |             abi.encodeWithSelector(
  790 |     |                 router.addFunctionAndImplementation.selector,
  791 |     |                 marketConfigurationModuleImpl.getOrderFees.selector,
  792 |     |                 address(marketConfigurationModuleImpl)
  793 |     |             )
  794 |     |         );
  795 |     |         assert(success);
  796 |     | 
  797 |     |         (success, ) = perps.call(
  798 |     |             abi.encodeWithSelector(
  799 |     |                 router.addFunctionAndImplementation.selector,
  800 |     |                 marketConfigurationModuleImpl.getLockedOiRatio.selector,
  801 |     |                 address(marketConfigurationModuleImpl)
  802 |     |             )
  803 |     |         );
  804 |     |         assert(success);
  805 |     |     }
  806 |     | 
  807 |     |     function addPerpsAccountModuleSels() private {
  808 |     |         (bool success, ) = perps.call(
  809 |     |             abi.encodeWithSelector(
  810 |     |                 router.addFunctionAndImplementation.selector,
  811 |     |                 perpsAccountModuleImpl.modifyCollateral.selector,
  812 |     |                 address(perpsAccountModuleImpl)
  813 |     |             )
  814 |     |         );
  815 |     |         assert(success);
  816 |     | 
  817 |     |         (success, ) = perps.call(
  818 |     |             abi.encodeWithSelector(
  819 |     |                 router.addFunctionAndImplementation.selector,
  820 |     |                 perpsAccountModuleImpl.debt.selector,
  821 |     |                 address(perpsAccountModuleImpl)
  822 |     |             )
  823 |     |         );
  824 |     |         assert(success);
  825 |     | 
  826 |     |         (success, ) = perps.call(
  827 |     |             abi.encodeWithSelector(
  828 |     |                 router.addFunctionAndImplementation.selector,
  829 |     |                 perpsAccountModuleImpl.payDebt.selector,
  830 |     |                 address(perpsAccountModuleImpl)
  831 |     |             )
  832 |     |         );
  833 |     |         assert(success);
  834 |     | 
  835 |     |         (success, ) = perps.call(
  836 |     |             abi.encodeWithSelector(
  837 |     |                 router.addFunctionAndImplementation.selector,
  838 |     |                 perpsAccountModuleImpl.totalCollateralValue.selector,
  839 |     |                 address(perpsAccountModuleImpl)
  840 |     |             )
  841 |     |         );
  842 |     |         assert(success);
  843 |     | 
  844 |     |         (success, ) = perps.call(
  845 |     |             abi.encodeWithSelector(
  846 |     |                 router.addFunctionAndImplementation.selector,
  847 |     |                 perpsAccountModuleImpl.totalAccountOpenInterest.selector,
  848 |     |                 address(perpsAccountModuleImpl)
  849 |     |             )
  850 |     |         );
  851 |     |         assert(success);
  852 |     | 
  853 |     |         (success, ) = perps.call(
  854 |     |             abi.encodeWithSelector(
  855 |     |                 router.addFunctionAndImplementation.selector,
  856 |     |                 perpsAccountModuleImpl.getOpenPosition.selector,
  857 |     |                 address(perpsAccountModuleImpl)
  858 |     |             )
  859 |     |         );
  860 |     |         assert(success);
  861 |     | 
  862 |     |         (success, ) = perps.call(
  863 |     |             abi.encodeWithSelector(
  864 |     |                 router.addFunctionAndImplementation.selector,
  865 |     |                 perpsAccountModuleImpl.getOpenPositionSize.selector,
  866 |     |                 address(perpsAccountModuleImpl)
  867 |     |             )
  868 |     |         );
  869 |     |         assert(success);
  870 |     | 
  871 |     |         (success, ) = perps.call(
  872 |     |             abi.encodeWithSelector(
  873 |     |                 router.addFunctionAndImplementation.selector,
  874 |     |                 perpsAccountModuleImpl.getAvailableMargin.selector,
  875 |     |                 address(perpsAccountModuleImpl)
  876 |     |             )
  877 |     |         );
  878 |     |         assert(success);
  879 |     | 
  880 |     |         (success, ) = perps.call(
  881 |     |             abi.encodeWithSelector(
  882 |     |                 router.addFunctionAndImplementation.selector,
  883 |     |                 perpsAccountModuleImpl.getWithdrawableMargin.selector,
  884 |     |                 address(perpsAccountModuleImpl)
  885 |     |             )
  886 |     |         );
  887 |     |         assert(success);
  888 |     | 
  889 |     |         (success, ) = perps.call(
  890 |     |             abi.encodeWithSelector(
  891 |     |                 router.addFunctionAndImplementation.selector,
  892 |     |                 perpsAccountModuleImpl.getRequiredMargins.selector,
  893 |     |                 address(perpsAccountModuleImpl)
  894 |     |             )
  895 |     |         );
  896 |     |         assert(success);
  897 |     | 
  898 |     |         (success, ) = perps.call(
  899 |     |             abi.encodeWithSelector(
  900 |     |                 router.addFunctionAndImplementation.selector,
  901 |     |                 perpsAccountModuleImpl.getCollateralAmount.selector,
  902 |     |                 address(perpsAccountModuleImpl)
  903 |     |             )
  904 |     |         );
  905 |     |         assert(success);
  906 |     | 
  907 |     |         (success, ) = perps.call(
  908 |     |             abi.encodeWithSelector(
  909 |     |                 router.addFunctionAndImplementation.selector,
  910 |     |                 perpsAccountModuleImpl.getAccountCollateralIds.selector,
  911 |     |                 address(perpsAccountModuleImpl)
  912 |     |             )
  913 |     |         );
  914 |     |         assert(success);
  915 |     | 
  916 |     |         (success, ) = perps.call(
  917 |     |             abi.encodeWithSelector(
  918 |     |                 router.addFunctionAndImplementation.selector,
  919 |     |                 perpsAccountModuleImpl.getAccountOpenPositions.selector,
  920 |     |                 address(perpsAccountModuleImpl)
  921 |     |             )
  922 |     |         );
  923 |     |         assert(success);
  924 |     |     }
  925 |     | 
  926 |     |     function addPerpsMarketFactoryModuleSels() private {
  927 |     |         (bool success, ) = perps.call(
  928 |     |             abi.encodeWithSelector(
  929 |     |                 router.addFunctionAndImplementation.selector,
  930 |     |                 perpsMarketFactoryModuleImpl.initializeFactory.selector,
  931 |     |                 address(perpsMarketFactoryModuleImpl)
  932 |     |             )
  933 |     |         );
  934 |     |         assert(success);
  935 |     | 
  936 |     |         (success, ) = perps.call(
  937 |     |             abi.encodeWithSelector(
  938 |     |                 router.addFunctionAndImplementation.selector,
  939 |     |                 perpsMarketFactoryModuleImpl.setPerpsMarketName.selector,
  940 |     |                 address(perpsMarketFactoryModuleImpl)
  941 |     |             )
  942 |     |         );
  943 |     |         assert(success);
  944 |     | 
  945 |     |         (success, ) = perps.call(
  946 |     |             abi.encodeWithSelector(
  947 |     |                 router.addFunctionAndImplementation.selector,
  948 |     |                 perpsMarketFactoryModuleImpl.createMarket.selector,
  949 |     |                 address(perpsMarketFactoryModuleImpl)
  950 |     |             )
  951 |     |         );
  952 |     |         assert(success);
  953 |     | 
  954 |     |         (success, ) = perps.call(
  955 |     |             abi.encodeWithSelector(
  956 |     |                 router.addFunctionAndImplementation.selector,
  957 |     |                 perpsMarketFactoryModuleImpl.name.selector,
  958 |     |                 address(perpsMarketFactoryModuleImpl)
  959 |     |             )
  960 |     |         );
  961 |     |         assert(success);
  962 |     | 
  963 |     |         (success, ) = perps.call(
  964 |     |             abi.encodeWithSelector(
  965 |     |                 router.addFunctionAndImplementation.selector,
  966 |     |                 perpsMarketFactoryModuleImpl.reportedDebt.selector,
  967 |     |                 address(perpsMarketFactoryModuleImpl)
  968 |     |             )
  969 |     |         );
  970 |     |         assert(success);
  971 |     | 
  972 |     |         (success, ) = perps.call(
  973 |     |             abi.encodeWithSelector(
  974 |     |                 router.addFunctionAndImplementation.selector,
  975 |     |                 perpsMarketFactoryModuleImpl.minimumCredit.selector,
  976 |     |                 address(perpsMarketFactoryModuleImpl)
  977 |     |             )
  978 |     |         );
  979 |     |         assert(success);
  980 |     | 
  981 |     |         (success, ) = perps.call(
  982 |     |             abi.encodeWithSelector(
  983 |     |                 router.addFunctionAndImplementation.selector,
  984 |     |                 perpsMarketFactoryModuleImpl.interestRate.selector,
  985 |     |                 address(perpsMarketFactoryModuleImpl)
  986 |     |             )
  987 |     |         );
  988 |     |         assert(success);
  989 |     | 
  990 |     |         (success, ) = perps.call(
  991 |     |             abi.encodeWithSelector(
  992 |     |                 router.addFunctionAndImplementation.selector,
  993 |     |                 perpsMarketFactoryModuleImpl.utilizationRate.selector,
  994 |     |                 address(perpsMarketFactoryModuleImpl)
  995 |     |             )
  996 |     |         );
  997 |     |         assert(success);
  998 |     | 
  999 |     |         (success, ) = perps.call(
 1000 |     |             abi.encodeWithSelector(
 1001 |     |                 router.addFunctionAndImplementation.selector,
 1002 |     |                 perpsMarketFactoryModuleImpl.supportsInterface.selector,
 1003 |     |                 address(perpsMarketFactoryModuleImpl)
 1004 |     |             )
 1005 |     |         );
 1006 |     |         assert(success);
 1007 |     |     }
 1008 |     | 
 1009 |     |     function addPerpsMarketModuleSels() private {
 1010 |     |         (bool success, ) = perps.call(
 1011 |     |             abi.encodeWithSelector(
 1012 |     |                 router.addFunctionAndImplementation.selector,
 1013 |     |                 perpsMarketModuleImpl.metadata.selector,
 1014 |     |                 address(perpsMarketModuleImpl)
 1015 |     |             )
 1016 |     |         );
 1017 |     |         assert(success);
 1018 |     | 
 1019 |     |         (success, ) = perps.call(
 1020 |     |             abi.encodeWithSelector(
 1021 |     |                 router.addFunctionAndImplementation.selector,
 1022 |     |                 perpsMarketModuleImpl.skew.selector,
 1023 |     |                 address(perpsMarketModuleImpl)
 1024 |     |             )
 1025 |     |         );
 1026 |     |         assert(success);
 1027 |     | 
 1028 |     |         (success, ) = perps.call(
 1029 |     |             abi.encodeWithSelector(
 1030 |     |                 router.addFunctionAndImplementation.selector,
 1031 |     |                 perpsMarketModuleImpl.size.selector,
 1032 |     |                 address(perpsMarketModuleImpl)
 1033 |     |             )
 1034 |     |         );
 1035 |     |         assert(success);
 1036 |     | 
 1037 |     |         (success, ) = perps.call(
 1038 |     |             abi.encodeWithSelector(
 1039 |     |                 router.addFunctionAndImplementation.selector,
 1040 |     |                 perpsMarketModuleImpl.maxOpenInterest.selector,
 1041 |     |                 address(perpsMarketModuleImpl)
 1042 |     |             )
 1043 |     |         );
 1044 |     |         assert(success);
 1045 |     | 
 1046 |     |         (success, ) = perps.call(
 1047 |     |             abi.encodeWithSelector(
 1048 |     |                 router.addFunctionAndImplementation.selector,
 1049 |     |                 perpsMarketModuleImpl.currentFundingRate.selector,
 1050 |     |                 address(perpsMarketModuleImpl)
 1051 |     |             )
 1052 |     |         );
 1053 |     |         assert(success);
 1054 |     | 
 1055 |     |         (success, ) = perps.call(
 1056 |     |             abi.encodeWithSelector(
 1057 |     |                 router.addFunctionAndImplementation.selector,
 1058 |     |                 perpsMarketModuleImpl.currentFundingVelocity.selector,
 1059 |     |                 address(perpsMarketModuleImpl)
 1060 |     |             )
 1061 |     |         );
 1062 |     |         assert(success);
 1063 |     | 
 1064 |     |         (success, ) = perps.call(
 1065 |     |             abi.encodeWithSelector(
 1066 |     |                 router.addFunctionAndImplementation.selector,
 1067 |     |                 perpsMarketModuleImpl.indexPrice.selector,
 1068 |     |                 address(perpsMarketModuleImpl)
 1069 |     |             )
 1070 |     |         );
 1071 |     |         assert(success);
 1072 |     | 
 1073 |     |         (success, ) = perps.call(
 1074 |     |             abi.encodeWithSelector(
 1075 |     |                 router.addFunctionAndImplementation.selector,
 1076 |     |                 perpsMarketModuleImpl.fillPrice.selector,
 1077 |     |                 address(perpsMarketModuleImpl)
 1078 |     |             )
 1079 |     |         );
 1080 |     |         assert(success);
 1081 |     | 
 1082 |     |         (success, ) = perps.call(
 1083 |     |             abi.encodeWithSelector(
 1084 |     |                 router.addFunctionAndImplementation.selector,
 1085 |     |                 perpsMarketModuleImpl.getMarketSummary.selector,
 1086 |     |                 address(perpsMarketModuleImpl)
 1087 |     |             )
 1088 |     |         );
 1089 |     |         assert(success);
 1090 |     |     }
 1091 |     | 
 1092 |     |     function addMockModuleSels() private {
 1093 |     |         (bool success, ) = perps.call(
 1094 |     |             abi.encodeWithSelector(
 1095 |     |                 router.addFunctionAndImplementation.selector,
 1096 |     |                 mockModuleImpl.createAccount.selector,
 1097 |     |                 address(mockModuleImpl)
 1098 |     |             )
 1099 |     |         );
 1100 |     |         assert(success);
 1101 |     | 
 1102 |     |         (success, ) = perps.call(
 1103 |     |             abi.encodeWithSelector(
 1104 |     |                 router.addFunctionAndImplementation.selector,
 1105 |     |                 mockModuleImpl.grantPermission.selector,
 1106 |     |                 address(mockModuleImpl)
 1107 |     |             )
 1108 |     |         );
 1109 |     |         assert(success);
 1110 |     |     }
 1111 |     | 
 1112 |     |     function addFeatureFlagModuleSels() private {
 1113 |     |         (bool success, ) = perps.call(
 1114 |     |             abi.encodeWithSelector(
 1115 |     |                 router.addFunctionAndImplementation.selector,
 1116 |     |                 featureFlagModuleImpl.setFeatureFlagAllowAll.selector,
 1117 |     |                 address(featureFlagModuleImpl)
 1118 |     |             )
 1119 |     |         );
 1120 |     |         assert(success);
 1121 |     | 
 1122 |     |         (success, ) = perps.call(
 1123 |     |             abi.encodeWithSelector(
 1124 |     |                 router.addFunctionAndImplementation.selector,
 1125 |     |                 featureFlagModuleImpl.setFeatureFlagDenyAll.selector,
 1126 |     |                 address(featureFlagModuleImpl)
 1127 |     |             )
 1128 |     |         );
 1129 |     |         assert(success);
 1130 |     | 
 1131 |     |         (success, ) = perps.call(
 1132 |     |             abi.encodeWithSelector(
 1133 |     |                 router.addFunctionAndImplementation.selector,
 1134 |     |                 featureFlagModuleImpl.addToFeatureFlagAllowlist.selector,
 1135 |     |                 address(featureFlagModuleImpl)
 1136 |     |             )
 1137 |     |         );
 1138 |     |         assert(success);
 1139 |     | 
 1140 |     |         (success, ) = perps.call(
 1141 |     |             abi.encodeWithSelector(
 1142 |     |                 router.addFunctionAndImplementation.selector,
 1143 |     |                 featureFlagModuleImpl.removeFromFeatureFlagAllowlist.selector,
 1144 |     |                 address(featureFlagModuleImpl)
 1145 |     |             )
 1146 |     |         );
 1147 |     |         assert(success);
 1148 |     | 
 1149 |     |         (success, ) = perps.call(
 1150 |     |             abi.encodeWithSelector(
 1151 |     |                 router.addFunctionAndImplementation.selector,
 1152 |     |                 featureFlagModuleImpl.setDeniers.selector,
 1153 |     |                 address(featureFlagModuleImpl)
 1154 |     |             )
 1155 |     |         );
 1156 |     |         assert(success);
 1157 |     | 
 1158 |     |         (success, ) = perps.call(
 1159 |     |             abi.encodeWithSelector(
 1160 |     |                 router.addFunctionAndImplementation.selector,
 1161 |     |                 featureFlagModuleImpl.getDeniers.selector,
 1162 |     |                 address(featureFlagModuleImpl)
 1163 |     |             )
 1164 |     |         );
 1165 |     |         assert(success);
 1166 |     | 
 1167 |     |         (success, ) = perps.call(
 1168 |     |             abi.encodeWithSelector(
 1169 |     |                 router.addFunctionAndImplementation.selector,
 1170 |     |                 featureFlagModuleImpl.getFeatureFlagAllowAll.selector,
 1171 |     |                 address(featureFlagModuleImpl)
 1172 |     |             )
 1173 |     |         );
 1174 |     |         assert(success);
 1175 |     | 
 1176 |     |         (success, ) = perps.call(
 1177 |     |             abi.encodeWithSelector(
 1178 |     |                 router.addFunctionAndImplementation.selector,
 1179 |     |                 featureFlagModuleImpl.getFeatureFlagDenyAll.selector,
 1180 |     |                 address(featureFlagModuleImpl)
 1181 |     |             )
 1182 |     |         );
 1183 |     |         assert(success);
 1184 |     | 
 1185 |     |         (success, ) = perps.call(
 1186 |     |             abi.encodeWithSelector(
 1187 |     |                 router.addFunctionAndImplementation.selector,
 1188 |     |                 featureFlagModuleImpl.getFeatureFlagAllowlist.selector,
 1189 |     |                 address(featureFlagModuleImpl)
 1190 |     |             )
 1191 |     |         );
 1192 |     |         assert(success);
 1193 |     | 
 1194 |     |         (success, ) = perps.call(
 1195 |     |             abi.encodeWithSelector(
 1196 |     |                 router.addFunctionAndImplementation.selector,
 1197 |     |                 featureFlagModuleImpl.isFeatureAllowed.selector,
 1198 |     |                 address(featureFlagModuleImpl)
 1199 |     |             )
 1200 |     |         );
 1201 |     |         assert(success);
 1202 |     |     }
 1203 |     | 
 1204 |     |     function addMockLensModuleSels() private {
 1205 |     |         (bool success, ) = perps.call(
 1206 |     |             abi.encodeWithSelector(
 1207 |     |                 router.addFunctionAndImplementation.selector,
 1208 |     |                 mockLensModuleImpl.isOrderExpired.selector,
 1209 |     |                 address(mockLensModuleImpl)
 1210 |     |             )
 1211 |     |         );
 1212 |     |         assert(success);
 1213 |     | 
 1214 |     |         (success, ) = perps.call(
 1215 |     |             abi.encodeWithSelector(
 1216 |     |                 router.addFunctionAndImplementation.selector,
 1217 |     |                 mockLensModuleImpl.getOrder.selector,
 1218 |     |                 address(mockLensModuleImpl)
 1219 |     |             )
 1220 |     |         );
 1221 |     |         assert(success);
 1222 |     | 
 1223 |     |         (success, ) = perps.call(
 1224 |     |             abi.encodeWithSelector(
 1225 |     |                 router.addFunctionAndImplementation.selector,
 1226 |     |                 mockLensModuleImpl.getSettlementRewardCost.selector,
 1227 |     |                 address(mockLensModuleImpl)
 1228 |     |             )
 1229 |     |         );
 1230 |     |         assert(success);
 1231 |     | 
 1232 |     |         (success, ) = perps.call(
 1233 |     |             abi.encodeWithSelector(
 1234 |     |                 router.addFunctionAndImplementation.selector,
 1235 |     |                 mockLensModuleImpl.calculateFillPrice.selector,
 1236 |     |                 address(mockLensModuleImpl)
 1237 |     |             )
 1238 |     |         );
 1239 |     |         assert(success);
 1240 |     | 
 1241 |     |         (success, ) = perps.call(
 1242 |     |             abi.encodeWithSelector(
 1243 |     |                 router.addFunctionAndImplementation.selector,
 1244 |     |                 mockLensModuleImpl.getOpenPositionMarketIds.selector,
 1245 |     |                 address(mockLensModuleImpl)
 1246 |     |             )
 1247 |     |         );
 1248 |     |         assert(success);
 1249 |     |         (success, ) = perps.call(
 1250 |     |             abi.encodeWithSelector(
 1251 |     |                 router.addFunctionAndImplementation.selector,
 1252 |     |                 mockLensModuleImpl.getGlobalCollateralTypes.selector,
 1253 |     |                 address(mockLensModuleImpl)
 1254 |     |             )
 1255 |     |         );
 1256 |     |         assert(success);
 1257 |     |     }
 1258 |     | 
 1259 |     |     function enableAllFeatureFlags() private {
 1260 |     |         (bool success, ) = perps.call(
 1261 |     |             abi.encodeWithSelector(
 1262 |     |                 featureFlagModuleImpl.setFeatureFlagAllowAll.selector,
 1263 |     |                 Flags.PERPS_SYSTEM,
 1264 |     |                 true
 1265 |     |             )
 1266 |     |         );
 1267 |     |         assert(success);
 1268 |     | 
 1269 |     |         (success, ) = perps.call(
 1270 |     |             abi.encodeWithSelector(
 1271 |     |                 featureFlagModuleImpl.setFeatureFlagAllowAll.selector,
 1272 |     |                 Flags.CREATE_MARKET,
 1273 |     |                 true
 1274 |     |             )
 1275 |     |         );
 1276 |     |         assert(success);
 1277 |     |     }
 1278 |     | 
 1279 |     |     function addWETHSettlementStrategy() private {
 1280 |     |         (bool success, ) = perps.call(
 1281 |     |             abi.encodeWithSelector(
 1282 |     |                 marketConfigurationModuleImpl.addSettlementStrategy.selector,
 1283 |     |                 1, // marketId
 1284 |     |                 SettlementStrategy.Data({
 1285 |     |                     strategyType: WETH_SETTLEMENT_STRATEGY_TYPE,
 1286 |     |                     settlementDelay: WETH_SETTLEMENT_DELAY,
 1287 |     |                     settlementWindowDuration: WETH_SETTLEMENT_WINDOW_DURATION,
 1288 |     |                     priceVerificationContract: address(pythWrapper),
 1289 |     |                     feedId: WETH_FEED_ID,
 1290 |     |                     settlementReward: WETH_SETTLEMENT_REWARD,
 1291 |     |                     disabled: WETH_DISABLED,
 1292 |     |                     commitmentPriceDelay: WETH_COMMITMENT_PRICE_DELAY
 1293 |     |                 })
 1294 |     |             )
 1295 |     |         );
 1296 |     |         assert(success);
 1297 |     |     }
 1298 |     | 
 1299 |     |     function addWBTCSettlementStrategy() private {
 1300 |     |         (bool success, ) = perps.call(
 1301 |     |             abi.encodeWithSelector(
 1302 |     |                 marketConfigurationModuleImpl.addSettlementStrategy.selector,
 1303 |     |                 2, // marketId
 1304 |     |                 SettlementStrategy.Data({
 1305 |     |                     strategyType: WBTC_SETTLEMENT_STRATEGY_TYPE,
 1306 |     |                     settlementDelay: WBTC_SETTLEMENT_DELAY,
 1307 |     |                     settlementWindowDuration: WBTC_SETTLEMENT_WINDOW_DURATION,
 1308 |     |                     priceVerificationContract: address(pythWrapper),
 1309 |     |                     feedId: WBTC_FEED_ID,
 1310 |     |                     settlementReward: WBTC_SETTLEMENT_REWARD,
 1311 |     |                     disabled: WBTC_DISABLED,
 1312 |     |                     commitmentPriceDelay: WBTC_COMMITMENT_PRICE_DELAY
 1313 |     |                 })
 1314 |     |             )
 1315 |     |         );
 1316 |     |         assert(success);
 1317 |     |     }
 1318 |     |     function addHUGESettlementStrategy() private {
 1319 |     |         (bool success, ) = perps.call(
 1320 |     |             abi.encodeWithSelector(
 1321 |     |                 marketConfigurationModuleImpl.addSettlementStrategy.selector,
 1322 |     |                 3, // marketId
 1323 |     |                 SettlementStrategy.Data({
 1324 |     |                     strategyType: HUGE_SETTLEMENT_STRATEGY_TYPE,
 1325 |     |                     settlementDelay: HUGE_SETTLEMENT_DELAY,
 1326 |     |                     settlementWindowDuration: HUGE_SETTLEMENT_WINDOW_DURATION,
 1327 |     |                     priceVerificationContract: address(pythWrapper),
 1328 |     |                     feedId: HUGE_FEED_ID,
 1329 |     |                     settlementReward: HUGE_SETTLEMENT_REWARD,
 1330 |     |                     disabled: HUGE_DISABLED,
 1331 |     |                     commitmentPriceDelay: HUGE_COMMITMENT_PRICE_DELAY
 1332 |     |                 })
 1333 |     |             )
 1334 |     |         );
 1335 |     |         assert(success);
 1336 |     |     }
 1337 |     | 
 1338 |     |     function initializePerpsMarketFactory() private {
 1339 |     |         (
 1340 |     |             bool success, //returns supermarket id
 1341 |     | 
 1342 |     |         ) = perps.call(
 1343 |     |                 abi.encodeWithSelector(
 1344 |     |                     perpsMarketFactoryModuleImpl.initializeFactory.selector,
 1345 |     |                     address(v3Mock),
 1346 |     |                     address(spot) //TODO: reckeck
 1347 |     |                 )
 1348 |     |             );
 1349 |     |         assert(success);
 1350 |     |     }
 1351 |     | 
 1352 |     |     function createKeeperCostNode() private {
 1353 |     |         mockGasPriceNode = new MockGasPriceNode();
 1354 |     | 
 1355 |     |         (bool success, ) = address(mockGasPriceNode).call(
 1356 |     |             abi.encodeWithSelector(
 1357 |     |                 mockGasPriceNode.setCosts.selector,
 1358 |     |                 KEEPER_SETTLEMENT_COST,
 1359 |     |                 KEEPER_FLAG_COST,
 1360 |     |                 KEEPER_LIQUIDATE_COST
 1361 |     |             )
 1362 |     |         );
 1363 |     |         assert(success);
 1364 |     |     }
 1365 |     |     function updateKeeperCostNodeId() private {
 1366 |     |         (bool success, ) = perps.call(
 1367 |     |             abi.encodeWithSelector(
 1368 |     |                 globalPerpsMarketModuleImpl.updateKeeperCostNodeId.selector,
 1369 |     |                 KEEPER_NODE_ID
 1370 |     |             )
 1371 |     |         );
 1372 |     |         assert(success);
 1373 |     |     }
 1374 |     | 
 1375 |     |     function setSnxUSDCollateralConfiguration() private {
 1376 |     |         (bool success, ) = perps.call(
 1377 |     |             abi.encodeWithSelector(
 1378 |     |                 collateralConfigurationModuleImpl
 1379 |     |                     .setCollateralConfiguration
 1380 |     |                     .selector,
 1381 |     |                 SNX_USD_COLLATERAL_ID,
 1382 |     |                 SNX_USD_MAX_COLLATERAL_AMOUNT,
 1383 |     |                 SNX_USD_UPPER_LIMIT_DISCOUNT,
 1384 |     |                 SNX_USD_LOWER_LIMIT_DISCOUNT,
 1385 |     |                 SNX_USD_DISCOUNT_SCALAR
 1386 |     |             )
 1387 |     |         );
 1388 |     |         assert(success);
 1389 |     |     }
 1390 |     | 
 1391 |     |     function setWETHCollateralConfiguration() private {
 1392 |     |         (bool success, ) = perps.call(
 1393 |     |             abi.encodeWithSelector(
 1394 |     |                 collateralConfigurationModuleImpl
 1395 |     |                     .setCollateralConfiguration
 1396 |     |                     .selector,
 1397 |     |                 WETH_COLLATERAL_ID,
 1398 |     |                 WETH_MAX_COLLATERAL_AMOUNT,
 1399 |     |                 WETH_UPPER_LIMIT_DISCOUNT,
 1400 |     |                 WETH_LOWER_LIMIT_DISCOUNT,
 1401 |     |                 WETH_DISCOUNT_SCALAR
 1402 |     |             )
 1403 |     |         );
 1404 |     |         assert(success);
 1405 |     |     }
 1406 |     | 
 1407 |     |     function setWBTCCollateralConfiguration() private {
 1408 |     |         (bool success, ) = perps.call(
 1409 |     |             abi.encodeWithSelector(
 1410 |     |                 collateralConfigurationModuleImpl
 1411 |     |                     .setCollateralConfiguration
 1412 |     |                     .selector,
 1413 |     |                 WBTC_COLLATERAL_ID,
 1414 |     |                 WBTC_MAX_COLLATERAL_AMOUNT,
 1415 |     |                 WBTC_UPPER_LIMIT_DISCOUNT,
 1416 |     |                 WBTC_LOWER_LIMIT_DISCOUNT,
 1417 |     |                 WBTC_DISCOUNT_SCALAR
 1418 |     |             )
 1419 |     |         );
 1420 |     |         assert(success);
 1421 |     |     }
 1422 |     | 
 1423 |     |     function setHUGECollateralConfiguration() private {
 1424 |     |         (bool success, ) = perps.call(
 1425 |     |             abi.encodeWithSelector(
 1426 |     |                 collateralConfigurationModuleImpl
 1427 |     |                     .setCollateralConfiguration
 1428 |     |                     .selector,
 1429 |     |                 HUGE_COLLATERAL_ID,
 1430 |     |                 HUGE_MAX_COLLATERAL_AMOUNT,
 1431 |     |                 HUGE_UPPER_LIMIT_DISCOUNT,
 1432 |     |                 HUGE_LOWER_LIMIT_DISCOUNT,
 1433 |     |                 HUGE_DISCOUNT_SCALAR
 1434 |     |             )
 1435 |     |         );
 1436 |     |         assert(success);
 1437 |     |     }
 1438 |     | 
 1439 |     |     function registerWETHDistributor() private {
 1440 |     |         address[] memory poolDelegatedCollateralTypes = new address[](1);
 1441 |     |         poolDelegatedCollateralTypes[0] = address(wethTokenMock);
 1442 |     | 
 1443 |     |         (bool success, ) = perps.call(
 1444 |     |             abi.encodeWithSelector(
 1445 |     |                 collateralConfigurationModuleImpl.registerDistributor.selector,
 1446 |     |                 address(wethTokenMock),
 1447 |     |                 address(rewardWETHDistributorMock),
 1448 |     |                 1, // collateralId WETH
 1449 |     |                 poolDelegatedCollateralTypes
 1450 |     |             )
 1451 |     |         );
 1452 |     |         assert(success);
 1453 |     |     }
 1454 |     | 
 1455 |     |     function registerWBTCDistributor() private {
 1456 |     |         address[] memory poolDelegatedCollateralTypes = new address[](1);
 1457 |     |         poolDelegatedCollateralTypes[0] = address(wbtcTokenMock);
 1458 |     | 
 1459 |     |         (bool success, ) = perps.call(
 1460 |     |             abi.encodeWithSelector(
 1461 |     |                 collateralConfigurationModuleImpl.registerDistributor.selector,
 1462 |     |                 address(wbtcTokenMock),
 1463 |     |                 address(rewardWBTCDistributorMock),
 1464 |     |                 2, // collateralId WBTC
 1465 |     |                 poolDelegatedCollateralTypes
 1466 |     |             )
 1467 |     |         );
 1468 |     |         assert(success);
 1469 |     |     }
 1470 |     | 
 1471 |     |     function registerHugeDistributor() private {
 1472 |     |         address[] memory poolDelegatedCollateralTypes = new address[](1);
 1473 |     |         poolDelegatedCollateralTypes[0] = address(hugePrecisionTokenMock);
 1474 |     | 
 1475 |     |         (bool success, ) = perps.call(
 1476 |     |             abi.encodeWithSelector(
 1477 |     |                 collateralConfigurationModuleImpl.registerDistributor.selector,
 1478 |     |                 address(hugePrecisionTokenMock),
 1479 |     |                 address(rewardHUGEDistributorMock),
 1480 |     |                 3, // collateralId HUGE
 1481 |     |                 poolDelegatedCollateralTypes
 1482 |     |             )
 1483 |     |         );
 1484 |     |         assert(success);
 1485 |     |     }
 1486 |     | 
 1487 |     |     function setSynthMaketIdAndAddresses() private {
 1488 |     |         uint[] memory synthIds = new uint[](3);
 1489 |     |         synthIds[0] = 1; //starting from 1 (typical dev comment :)
 1490 |     |         synthIds[1] = 2;
 1491 |     |         synthIds[2] = 3;
 1492 |     | 
 1493 |     |         address[] memory synthAddresses = new address[](3);
 1494 |     |         synthAddresses[0] = address(wethTokenMock);
 1495 |     |         synthAddresses[1] = address(wbtcTokenMock);
 1496 |     |         synthAddresses[2] = address(hugePrecisionTokenMock);
 1497 |     | 
 1498 |     |         (bool success, ) = address(spot).call(
 1499 |     |             abi.encodeWithSelector(
 1500 |     |                 spot.setSynthForMarketId.selector,
 1501 |     |                 synthIds,
 1502 |     |                 synthAddresses
 1503 |     |             )
 1504 |     |         );
 1505 |     |         assert(success);
 1506 |     |     }
 1507 |     | 
 1508 |     |     function addToFeatureFlagAllowlist() private {
 1509 |     |         (bool success, ) = perps.call(
 1510 |     |             abi.encodeWithSelector(
 1511 |     |                 featureFlagModuleImpl.addToFeatureFlagAllowlist.selector,
 1512 |     |                 bytes32("createPool"),
 1513 |     |                 address(this)
 1514 |     |             )
 1515 |     |         );
 1516 |     |         assert(success);
 1517 |     |     }
 1518 |     | 
 1519 |     |     function createAccounts() private {
 1520 |     |         (bool success, ) = perps.call(
 1521 |     |             abi.encodeWithSelector(
 1522 |     |                 mockModuleImpl.createAccount.selector,
 1523 |     |                 uint128(1),
 1524 |     |                 USER1
 1525 |     |             )
 1526 |     |         );
 1527 |     |         assert(success);
 1528 |     | 
 1529 |     |         (success, ) = perps.call(
 1530 |     |             abi.encodeWithSelector(
 1531 |     |                 mockModuleImpl.createAccount.selector,
 1532 |     |                 uint128(2),
 1533 |     |                 USER2
 1534 |     |             )
 1535 |     |         );
 1536 |     |         assert(success);
 1537 |     | 
 1538 |     |         (success, ) = perps.call(
 1539 |     |             abi.encodeWithSelector(
 1540 |     |                 mockModuleImpl.createAccount.selector,
 1541 |     |                 uint128(3),
 1542 |     |                 USER3
 1543 |     |             )
 1544 |     |         );
 1545 |     |         assert(success);
 1546 |     |     }
 1547 |     |     event MsgSender(address sender);
 1548 |     |     function grantAccountPermissions() private {
 1549 |     |         vm.prank(USER1);
 1550 |     |         (bool success, ) = perps.call(
 1551 |     |             abi.encodeWithSelector(
 1552 |     |                 mockModuleImpl.grantPermission.selector,
 1553 |     |                 uint128(1),
 1554 |     |                 AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION,
 1555 |     |                 USER1
 1556 |     |             )
 1557 |     |         );
 1558 |     |         assert(success);
 1559 |     | 
 1560 |     |         vm.prank(USER2);
 1561 |     |         (success, ) = perps.call(
 1562 |     |             abi.encodeWithSelector(
 1563 |     |                 mockModuleImpl.grantPermission.selector,
 1564 |     |                 uint128(2),
 1565 |     |                 AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION,
 1566 |     |                 USER2
 1567 |     |             )
 1568 |     |         );
 1569 |     |         assert(success);
 1570 |     | 
 1571 |     |         vm.prank(USER3);
 1572 |     |         console2.log("Msg sender in setup", msg.sender);
 1573 |     |         (success, ) = perps.call(
 1574 |     |             abi.encodeWithSelector(
 1575 |     |                 mockModuleImpl.grantPermission.selector,
 1576 |     |                 uint128(3),
 1577 |     |                 AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION,
 1578 |     |                 USER3
 1579 |     |             )
 1580 |     |         );
 1581 |     |         assert(success);
 1582 |     |     }
 1583 |     | 
 1584 |     |     function setMaxCollateralsPerAccount() private {
 1585 |     |         (bool success, bytes memory returnData) = perps.call(
 1586 |     |             abi.encodeWithSelector(
 1587 |     |                 globalPerpsMarketModuleImpl.setPerAccountCaps.selector,
 1588 |     |                 MAX_POSITIONS_PER_ACCOUNT,
 1589 |     |                 MAX_COLLATERALS_PER_ACCOUNT
 1590 |     |             )
 1591 |     |         );
 1592 |     |         assert(success);
 1593 |     |     }
 1594 |     | 
 1595 |     |     function setupActors() internal {
 1596 |     |         setupAccountIds();
 1597 |     | 
 1598 |     |         bool success;
 1599 |     |         address[] memory targets = new address[](2);
 1600 |     |         targets[0] = address(perps);
 1601 |     |         targets[1] = address(v3Mock);
 1602 |     | 
 1603 |     |         tokens.push(sUSDTokenMock);
 1604 |     |         tokens.push(wethTokenMock);
 1605 |     |         tokens.push(wbtcTokenMock);
 1606 |     |         tokens.push(hugePrecisionTokenMock);
 1607 |     | 
 1608 |     |         for (uint8 i = 0; i < USERS.length; i++) {
 1609 |     |             address user = USERS[i];
 1610 |     |             (success, ) = address(user).call{value: INITIAL_BALANCE}("");
 1611 |     |             assert(success);
 1612 |     | 
 1613 |     |             for (uint8 j = 0; j < tokens.length; j++) {
 1614 |     |                 tokens[j].mint(
 1615 |     |                     user,
 1616 |     |                     INITIAL_TOKEN_BALANCE * (10 ** tokens[j].decimals())
 1617 |     |                 );
 1618 |     |                 for (uint8 k = 0; k < targets.length; k++) {
 1619 |     |                     vm.prank(user);
 1620 |     |                     tokens[j].approve(targets[k], type(uint128).max);
 1621 |     |                 }
 1622 |     |             }
 1623 |     |         }
 1624 |     | 
 1625 |     |         _depositInitialAmounts(1, 0, 10_000e18);
 1626 |     |     }
 1627 |     | 
 1628 |     |     function setupAccountIds() internal {
 1629 |     |         userToAccountIds[USER1] = uint128(1);
 1630 |     |         userToAccountIds[USER2] = uint128(2);
 1631 |     |         userToAccountIds[USER3] = uint128(3);
 1632 |     |         accountIdToUser[uint128(1)] = USER1;
 1633 |     |         accountIdToUser[uint128(2)] = USER2;
 1634 |     |         accountIdToUser[uint128(3)] = USER3;
 1635 |     |     }
 1636 |     | 
 1637 |     |     function setPythPriceFeed() private {
 1638 |     |         // Add price feeds
 1639 |     |         addPriceFeed(
 1640 |     |             WETH_PYTH_PRICE_FEED_ID,
 1641 |     |             WETH_STARTING_PRICE,
 1642 |     |             WETH_STARTING_CONF,
 1643 |     |             WETH_STARTING_EXPO
 1644 |     |         );
 1645 |     |         addPriceFeed(
 1646 |     |             WBTC_PYTH_PRICE_FEED_ID,
 1647 |     |             WBTC_STARTING_PRICE,
 1648 |     |             WBTC_STARTING_CONF,
 1649 |     |             WBTC_STARTING_EXPO
 1650 |     |         );
 1651 |     |         addPriceFeed(
 1652 |     |             HUGE_PYTH_PRICE_FEED_ID,
 1653 |     |             HUGE_STARTING_PRICE,
 1654 |     |             HUGE_STARTING_CONF,
 1655 |     |             HUGE_STARTING_EXPO
 1656 |     |         );
 1657 |     | 
 1658 |     |         // Set oracle nodes
 1659 |     |         oracleNodes[WETH_ORACLE_NODE_ID] = WETH_PYTH_PRICE_FEED_ID;
 1660 |     |         oracleNodes[WBTC_ORACLE_NODE_ID] = WBTC_PYTH_PRICE_FEED_ID;
 1661 |     |         oracleNodes[HUGE_ORACLE_NODE_ID] = HUGE_PYTH_PRICE_FEED_ID;
 1662 |     | 
 1663 |     |         oracleNodes[WETH_PYTH_PRICE_FEED_ID] = WETH_ORACLE_NODE_ID;
 1664 |     |         oracleNodes[WBTC_ORACLE_NODE_ID] = WBTC_ORACLE_NODE_ID;
 1665 |     |         oracleNodes[HUGE_ORACLE_NODE_ID] = HUGE_ORACLE_NODE_ID;
 1666 |     |     }
 1667 |     | 
 1668 |     |     function addPriceFeed(
 1669 |     |         bytes32 id,
 1670 |     |         int64 startingPrice,
 1671 |     |         uint64 startingConf,
 1672 |     |         int32 startingExpo
 1673 |     |     ) private {
 1674 |     |         (bool success, ) = address(mockPyth).call(
 1675 |     |             abi.encodeWithSelector(
 1676 |     |                 mockPyth.addPriceFeed.selector,
 1677 |     |                 id,
 1678 |     |                 startingPrice,
 1679 |     |                 startingConf,
 1680 |     |                 startingExpo
 1681 |     |             )
 1682 |     |         );
 1683 |     |         assert(success);
 1684 |     |     }
 1685 |     | 
 1686 |     |     function setPythRequiredFee() private {
 1687 |     |         mockPyth.setRequiredFee(100);
 1688 |     |     }
 1689 |     | 
 1690 |     |     function setUpdatePriceDataWETH() private {
 1691 |     |         (bool success, ) = perps.call(
 1692 |     |             abi.encodeWithSelector(
 1693 |     |                 marketConfigurationModuleImpl.updatePriceData.selector,
 1694 |     |                 1,
 1695 |     |                 WETH_PYTH_PRICE_FEED_ID,
 1696 |     |                 STRICT_PRICE_TOLERANCE
 1697 |     |             )
 1698 |     |         );
 1699 |     |         assert(success);
 1700 |     |     }
 1701 |     | 
 1702 |     |     function setUpdatePriceDataWBTC() private {
 1703 |     |         (bool success, ) = perps.call(
 1704 |     |             abi.encodeWithSelector(
 1705 |     |                 marketConfigurationModuleImpl.updatePriceData.selector,
 1706 |     |                 2,
 1707 |     |                 WBTC_PYTH_PRICE_FEED_ID,
 1708 |     |                 STRICT_PRICE_TOLERANCE
 1709 |     |             )
 1710 |     |         );
 1711 |     |         assert(success);
 1712 |     |     }
 1713 |     | 
 1714 |     |     function setUpdatePriceDataHUGE() private {
 1715 |     |         (bool success, ) = perps.call(
 1716 |     |             abi.encodeWithSelector(
 1717 |     |                 marketConfigurationModuleImpl.updatePriceData.selector,
 1718 |     |                 3,
 1719 |     |                 HUGE_PYTH_PRICE_FEED_ID,
 1720 |     |                 STRICT_PRICE_TOLERANCE
 1721 |     |             )
 1722 |     |         );
 1723 |     |         assert(success);
 1724 |     |     }
 1725 |     |     //from test/integration/bootstrap/bootstrapPerpsMarkets.ts
 1726 |     |     function setFundingParametersWETH() private {
 1727 |     |         (bool success, ) = perps.call(
 1728 |     |             abi.encodeWithSelector(
 1729 |     |                 marketConfigurationModuleImpl.setFundingParameters.selector,
 1730 |     |                 1,
 1731 |     |                 WETH_SKEW_SCALE,
 1732 |     |                 WETH_MAX_FUNDING_VELOCITY
 1733 |     |             )
 1734 |     |         );
 1735 |     |         assert(success);
 1736 |     |     }
 1737 |     | 
 1738 |     |     function setFundingParametersWBTC() private {
 1739 |     |         (bool success, ) = perps.call(
 1740 |     |             abi.encodeWithSelector(
 1741 |     |                 marketConfigurationModuleImpl.setFundingParameters.selector,
 1742 |     |                 2,
 1743 |     |                 WBTC_SKEW_SCALE,
 1744 |     |                 WBTC_MAX_FUNDING_VELOCITY
 1745 |     |             )
 1746 |     |         );
 1747 |     |         assert(success);
 1748 |     |     }
 1749 |     | 
 1750 |     |     function setFundingParametersHUGE() private {
 1751 |     |         (bool success, ) = perps.call(
 1752 |     |             abi.encodeWithSelector(
 1753 |     |                 marketConfigurationModuleImpl.setFundingParameters.selector,
 1754 |     |                 3,
 1755 |     |                 HUGE_SKEW_SCALE,
 1756 |     |                 HUGE_MAX_FUNDING_VELOCITY
 1757 |     |             )
 1758 |     |         );
 1759 |     |         assert(success);
 1760 |     |     }
 1761 |     | 
 1762 |     |     function setMaxMarketSizeWETH() private {
 1763 |     |         (bool success, ) = perps.call(
 1764 |     |             abi.encodeWithSelector(
 1765 |     |                 marketConfigurationModuleImpl.setMaxMarketSize.selector,
 1766 |     |                 1, // WETH market ID hardcoded
 1767 |     |                 WETH_MAX_MARKET_SIZE
 1768 |     |             )
 1769 |     |         );
 1770 |     |         assert(success);
 1771 |     |     }
 1772 |     |     function setMaxMarketSizeWBTC() private {
 1773 |     |         (bool success, ) = perps.call(
 1774 |     |             abi.encodeWithSelector(
 1775 |     |                 marketConfigurationModuleImpl.setMaxMarketSize.selector,
 1776 |     |                 2, // WBTC market ID hardcoded
 1777 |     |                 WBTC_MAX_MARKET_SIZE
 1778 |     |             )
 1779 |     |         );
 1780 |     |         assert(success);
 1781 |     |     }
 1782 |     |     function setMaxMarketSizeHUGE() private {
 1783 |     |         (bool success, ) = perps.call(
 1784 |     |             abi.encodeWithSelector(
 1785 |     |                 marketConfigurationModuleImpl.setMaxMarketSize.selector,
 1786 |     |                 3, // WBTC market ID hardcoded
 1787 |     |                 HUGE_MAX_MARKET_SIZE
 1788 |     |             )
 1789 |     |         );
 1790 |     |         assert(success);
 1791 |     |     }
 1792 |     | 
 1793 |     |     function setMaxMarketValueWETH() private {
 1794 |     |         (bool success, ) = perps.call(
 1795 |     |             abi.encodeWithSelector(
 1796 |     |                 marketConfigurationModuleImpl.setMaxMarketValue.selector,
 1797 |     |                 1, // WETH market ID hardcoded
 1798 |     |                 WETH_MAX_MARKET_VALUE
 1799 |     |             )
 1800 |     |         );
 1801 |     |         assert(success);
 1802 |     |     }
 1803 |     | 
 1804 |     |     function setMaxMarketValueWBTC() private {
 1805 |     |         (bool success, ) = perps.call(
 1806 |     |             abi.encodeWithSelector(
 1807 |     |                 marketConfigurationModuleImpl.setMaxMarketValue.selector,
 1808 |     |                 2, // WBTC market ID hardcoded
 1809 |     |                 WBTC_MAX_MARKET_VALUE
 1810 |     |             )
 1811 |     |         );
 1812 |     |         assert(success);
 1813 |     |     }
 1814 |     | 
 1815 |     |     function setMaxMarketValueHUGE() private {
 1816 |     |         (bool success, ) = perps.call(
 1817 |     |             abi.encodeWithSelector(
 1818 |     |                 marketConfigurationModuleImpl.setMaxMarketValue.selector,
 1819 |     |                 3, // WBTC market ID hardcoded
 1820 |     |                 HUGE_MAX_MARKET_VALUE
 1821 |     |             )
 1822 |     |         );
 1823 |     |         assert(success);
 1824 |     |     }
 1825 |     | 
 1826 |     |     function setOrderFeesWETH() private {
 1827 |     |         (bool success, ) = perps.call(
 1828 |     |             abi.encodeWithSelector(
 1829 |     |                 marketConfigurationModuleImpl.setOrderFees.selector,
 1830 |     |                 1, // WETH market ID hardcoded
 1831 |     |                 WETH_MAKER_FEE_RATIO,
 1832 |     |                 WETH_TAKER_FEE_RATIO
 1833 |     |             )
 1834 |     |         );
 1835 |     |         assert(success);
 1836 |     |     }
 1837 |     | 
 1838 |     |     function setOrderFeesWBTC() private {
 1839 |     |         (bool success, ) = perps.call(
 1840 |     |             abi.encodeWithSelector(
 1841 |     |                 marketConfigurationModuleImpl.setOrderFees.selector,
 1842 |     |                 2, // WBTC market ID hardcoded
 1843 |     |                 WBTC_MAKER_FEE_RATIO,
 1844 |     |                 WBTC_TAKER_FEE_RATIO
 1845 |     |             )
 1846 |     |         );
 1847 |     |         assert(success);
 1848 |     |     }
 1849 |     |     function setOrderFeesHUGE() private {
 1850 |     |         (bool success, ) = perps.call(
 1851 |     |             abi.encodeWithSelector(
 1852 |     |                 marketConfigurationModuleImpl.setOrderFees.selector,
 1853 |     |                 3, // WBTC market ID hardcoded
 1854 |     |                 HUGE_MAKER_FEE_RATIO,
 1855 |     |                 HUGE_TAKER_FEE_RATIO
 1856 |     |             )
 1857 |     |         );
 1858 |     |         assert(success);
 1859 |     |     }
 1860 |     | 
 1861 |     |     function setLiquidationParametersWETH() private {
 1862 |     |         (bool success, ) = perps.call(
 1863 |     |             abi.encodeWithSelector(
 1864 |     |                 marketConfigurationModuleImpl.setLiquidationParameters.selector,
 1865 |     |                 1,
 1866 |     |                 WETH_INITIAL_MARGIN_FRACTION,
 1867 |     |                 WETH_MINIMUM_INITIAL_MARGIN_RATIO,
 1868 |     |                 WETH_MAINTENANCE_MARGIN_SCALAR,
 1869 |     |                 WETH_LIQUIDATION_REWARD_RATIO,
 1870 |     |                 WETH_MINIMUM_POSITION_MARGIN
 1871 |     |             )
 1872 |     |         );
 1873 |     |         assert(success);
 1874 |     |     }
 1875 |     | 
 1876 |     |     function setLiquidationParametersWBTC() private {
 1877 |     |         (bool success, ) = perps.call(
 1878 |     |             abi.encodeWithSelector(
 1879 |     |                 marketConfigurationModuleImpl.setLiquidationParameters.selector,
 1880 |     |                 2,
 1881 |     |                 WBTC_INITIAL_MARGIN_FRACTION,
 1882 |     |                 WBTC_MINIMUM_INITIAL_MARGIN_RATIO,
 1883 |     |                 WBTC_MAINTENANCE_MARGIN_SCALAR,
 1884 |     |                 WBTC_LIQUIDATION_REWARD_RATIO,
 1885 |     |                 WBTC_MINIMUM_POSITION_MARGIN
 1886 |     |             )
 1887 |     |         );
 1888 |     |         assert(success);
 1889 |     |     }
 1890 |     |     function setLiquidationParametersHUGE() private {
 1891 |     |         (bool success, ) = perps.call(
 1892 |     |             abi.encodeWithSelector(
 1893 |     |                 marketConfigurationModuleImpl.setLiquidationParameters.selector,
 1894 |     |                 3,
 1895 |     |                 HUGE_INITIAL_MARGIN_FRACTION,
 1896 |     |                 HUGE_MINIMUM_INITIAL_MARGIN_RATIO,
 1897 |     |                 HUGE_MAINTENANCE_MARGIN_SCALAR,
 1898 |     |                 HUGE_LIQUIDATION_REWARD_RATIO,
 1899 |     |                 HUGE_MINIMUM_POSITION_MARGIN
 1900 |     |             )
 1901 |     |         );
 1902 |     |         assert(success);
 1903 |     |     }
 1904 |     | 
 1905 |     |     function setMaxLiquidationParametersWETH() private {
 1906 |     |         (bool success, ) = perps.call(
 1907 |     |             abi.encodeWithSelector(
 1908 |     |                 marketConfigurationModuleImpl
 1909 |     |                     .setMaxLiquidationParameters
 1910 |     |                     .selector,
 1911 |     |                 1,
 1912 |     |                 WETH_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER,
 1913 |     |                 WETH_MAX_SECONDS_IN_LIQUIDATION_WINDOW,
 1914 |     |                 WETH_MAX_LIQUIDATION_PD,
 1915 |     |                 WETH_ENDORSED_LIQUIDATOR
 1916 |     |             )
 1917 |     |         );
 1918 |     |         assert(success);
 1919 |     |     }
 1920 |     | 
 1921 |     |     function setMaxLiquidationParametersWBTC() private {
 1922 |     |         (bool success, ) = perps.call(
 1923 |     |             abi.encodeWithSelector(
 1924 |     |                 marketConfigurationModuleImpl
 1925 |     |                     .setMaxLiquidationParameters
 1926 |     |                     .selector,
 1927 |     |                 2,
 1928 |     |                 WBTC_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER,
 1929 |     |                 WBTC_MAX_SECONDS_IN_LIQUIDATION_WINDOW,
 1930 |     |                 WBTC_MAX_LIQUIDATION_PD,
 1931 |     |                 WBTC_ENDORSED_LIQUIDATOR
 1932 |     |             )
 1933 |     |         );
 1934 |     |         assert(success);
 1935 |     |     }
 1936 |     |     function setMaxLiquidationParametersHUGE() private {
 1937 |     |         (bool success, ) = perps.call(
 1938 |     |             abi.encodeWithSelector(
 1939 |     |                 marketConfigurationModuleImpl
 1940 |     |                     .setMaxLiquidationParameters
 1941 |     |                     .selector,
 1942 |     |                 3,
 1943 |     |                 HUGE_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER,
 1944 |     |                 HUGE_MAX_SECONDS_IN_LIQUIDATION_WINDOW,
 1945 |     |                 HUGE_MAX_LIQUIDATION_PD,
 1946 |     |                 HUGE_ENDORSED_LIQUIDATOR
 1947 |     |             )
 1948 |     |         );
 1949 |     |         assert(success);
 1950 |     |     }
 1951 |     |     function setPerpsMarketName() private {
 1952 |     |         (bool success, ) = perps.call(
 1953 |     |             abi.encodeWithSelector(
 1954 |     |                 perpsMarketFactoryModuleImpl.setPerpsMarketName.selector,
 1955 |     |                 "SuperMarket"
 1956 |     |             )
 1957 |     |         );
 1958 |     |         assert(success);
 1959 |     |     }
 1960 |     | 
 1961 |     |     function setCreateMarketWETH() private {
 1962 |     |         (bool success, ) = perps.call(
 1963 |     |             abi.encodeWithSelector(
 1964 |     |                 perpsMarketFactoryModuleImpl.createMarket.selector,
 1965 |     |                 1, //requestedMarketId
 1966 |     |                 "WETH/USD", //marketName
 1967 |     |                 "WETHUSD" //marketSymbol
 1968 |     |             )
 1969 |     |         );
 1970 |     |         assert(success);
 1971 |     |         collateralToMarketId[address(wethTokenMock)] = 1;
 1972 |     |     }
 1973 |     |     function setPerpMarketFactoryModuleImplInVault() private {
 1974 |     |         vaultModuleMock.setPerpMarketFactoryModuleImpl(
 1975 |     |             perpsMarketFactoryModuleImpl
 1976 |     |         );
 1977 |     |     }
 1978 |     | 
 1979 |     |     function setCreateMarketWBTC() private {
 1980 |     |         (bool success, ) = perps.call(
 1981 |     |             abi.encodeWithSelector(
 1982 |     |                 perpsMarketFactoryModuleImpl.createMarket.selector,
 1983 |     |                 2, //requestedMarketId
 1984 |     |                 "WBTC/USD", //marketName
 1985 |     |                 "WBTCUSD" //marketSymbol
 1986 |     |             )
 1987 |     |         );
 1988 |     |         assert(success);
 1989 |     |         collateralToMarketId[address(wbtcTokenMock)] = 2;
 1990 |     |     }
 1991 |     | 
 1992 |     |     function setCreateMarketHUGE() private {
 1993 |     |         (bool success, ) = perps.call(
 1994 |     |             abi.encodeWithSelector(
 1995 |     |                 perpsMarketFactoryModuleImpl.createMarket.selector,
 1996 |     |                 3, //requestedMarketId
 1997 |     |                 "HUGE/USD", //marketName
 1998 |     |                 "HUGEUSD" //marketSymbol
 1999 |     |             )
 2000 |     |         );
 2001 |     |         assert(success);
 2002 |     |         collateralToMarketId[address(wbtcTokenMock)] = 2;
 2003 |     |     }
 2004 |     | 
 2005 | *   |     function _getRandomCollateralToken(
 2006 |     |         uint256 collateralTokenIndex
 2007 | *   |     ) internal returns (address) {
 2008 | *   |         (bool success, bytes memory data) = perps.call(
 2009 | *   |             abi.encodeWithSelector(
 2010 |     |                 globalPerpsMarketModuleImpl.getSupportedCollaterals.selector
 2011 |     |             )
 2012 |     |         );
 2013 | *   |         assert(success);
 2014 | *   |         uint256[] memory supportedCollaterals = abi.decode(data, (uint256[]));
 2015 |     |         // assert(supportedCollaterals.length == 3);
 2016 |     | 
 2017 | *   |         uint256 clampedIndex = collateralTokenIndex %
 2018 | *   |             supportedCollaterals.length;
 2019 | *   |         address collateral;
 2020 | *   |         if (clampedIndex == 0) collateral = address(sUSDTokenMock);
 2021 | *   |         else if (clampedIndex == 1) collateral = address(wethTokenMock);
 2022 | *   |         else collateral = address(wbtcTokenMock);
 2023 | *   |         return collateral;
 2024 |     |         // TODO: Cleanup.
 2025 |     |         // return supportedCollaterals[clampedIndex]; //== 1 ? address(wethTokenMock) : address(wbtcTokenMock);
 2026 |     |     }
 2027 |     | 
 2028 | *   |     function _getRandomNodeId(
 2029 |     |         uint256 nodeIndex
 2030 | *   |     ) internal returns (bytes32 nodeId) {
 2031 |     |         // first oracle nodeId is sUSD, ignore because its price shouldn't change
 2032 | *   |         nodeIndex = (nodeIndex % mockOracleManager.getActiveNodesLength()) + 1;
 2033 | *r  |         nodeId = mockOracleManager.activeNodes(nodeIndex);
 2034 |     |     }
 2035 |     | 
 2036 |     |     function _depositInitialAmounts(
 2037 |     |         uint128 accountId,
 2038 |     |         uint128 collateralId,
 2039 |     |         int delta
 2040 |     |     ) internal {
 2041 |     |         address user;
 2042 |     |         if (accountId == 1) {
 2043 |     |             user = USER1;
 2044 |     |         } else if (accountId == 2) {
 2045 |     |             user = USER2;
 2046 |     |         } else {
 2047 |     |             user = USER3;
 2048 |     |         }
 2049 |     |         vm.prank(user);
 2050 |     |         (bool success, bytes memory returnData) = perps.call(
 2051 |     |             abi.encodeWithSelector(
 2052 |     |                 perpsAccountModuleImpl.modifyCollateral.selector,
 2053 |     |                 accountId,
 2054 |     |                 collateralId,
 2055 |     |                 delta
 2056 |     |             )
 2057 |     |         );
 2058 |     |         if (!success) {
 2059 |     |             if (returnData.length > 0) {
 2060 |     |                 string memory errorMessage = abi.decode(returnData, (string));
 2061 |     |                 revert(errorMessage);
 2062 |     |             } else {
 2063 |     |                 revert("Call to perps contract failed");
 2064 |     |             }
 2065 |     |         }
 2066 |     |     }
 2067 |     | }
 2068 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/BeforeAfter.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | import "../FuzzSetup.sol";
   4 |     | import {AsyncOrder} from "../../storage/AsyncOrder.sol";
   5 |     | import {MathUtil} from "../../utils/MathUtil.sol";
   6 |     | import {LiquidationCoverage} from "./logicalCoverage/LiquidationCoverage.sol";
   7 |     | import {OrderCoverage} from "./logicalCoverage/OrderCoverage.sol";
   8 |     | import {PositionCoverage} from "./logicalCoverage/PositionCoverage.sol";
   9 |     | import {MarketCoverage} from "./logicalCoverage/MarketCoverage.sol";
  10 |     | import {GlobalCoverage} from "./logicalCoverage/GlobalCoverage.sol";
  11 |     | 
  12 |     | import {console2} from "lib/forge-std/src/Test.sol";
  13 |     | 
  14 |     | abstract contract BeforeAfter is
  15 |     |     FuzzSetup,
  16 |     |     LiquidationCoverage,
  17 |     |     OrderCoverage,
  18 |     |     PositionCoverage,
  19 |     |     MarketCoverage,
  20 |     |     GlobalCoverage
  21 |     | {
  22 |     |     mapping(uint8 => State) states;
  23 |     |     struct PositionVars {
  24 |     |         // Position.Data position; getting separately instead
  25 |     |         int256 totalPnl;
  26 |     |         int256 accruedFunding;
  27 |     |         int128 positionSize;
  28 |     |         uint256 owedInterest;
  29 |     |     }
  30 |     | 
  31 |     |     struct MarketVars {
  32 |     |         int256 skew;
  33 |     |         uint256 marketSize;
  34 |     |         uint256 liquidationCapacity;
  35 |     |         uint128 marketSkew;
  36 |     |     }
  37 |     | 
  38 |     |     struct State {
  39 |     |         // account => actorStates
  40 |     |         mapping(uint128 => ActorStates) actorStates;
  41 |     |         MarketVars wethMarket;
  42 |     |         MarketVars wbtcMarket;
  43 |     |         MarketVars hugeMarket;
  44 |     |         uint128[] globalCollateralTypes;
  45 |     |         uint256 depositedSusdCollateral;
  46 |     |         uint256 depositedWethCollateral;
  47 |     |         uint256 depositedWbtcCollateral;
  48 |     |         uint depositedHUGECollateral;
  49 |     |         int256 totalCollateralValueUsd;
  50 |     |         uint256 marketSizeGhost;
  51 |     |         uint256 delegatedCollateralValueUsd; //get with lens
  52 |     |         uint128 currentUtilizationAccruedComputed; //get with lens
  53 |     |         uint256 utilizationRate; //perpsMarketFactoryModuleImpl.utilizationRate
  54 |     |         uint256 delegatedCollateral; //perpsMarketFactoryModuleImpl.utilizationRate
  55 |     |         uint256 lockedCredit; //perpsMarketFactoryModuleImpl.utilizationRate
  56 |     |         int256 reportedDebt;
  57 |     |         int256 reportedDebtGhost;
  58 |     |         int256 totalCollateralValueUsdGhost;
  59 |     |         uint256 minimumCredit;
  60 |     |         int128 skew;
  61 |     |     }
  62 |     | 
  63 |     |     struct ActorStates {
  64 |     |         bool isPositionLiquidatable;
  65 |     |         bool isPositionLiquidatablePassing;
  66 |     |         bool isMarginLiquidatable;
  67 |     |         uint128 debt;
  68 |     |         uint256[] collateralIds; //perpsAccountModuleImpl.getAccountCollateralIds
  69 |     |         uint256 collateralAmountSUSD; //perpsAccountModuleImpl.getCollateralAmount
  70 |     |         uint256 collateralAmountWETH; //perpsAccountModuleImpl.getCollateralAmount
  71 |     |         uint256 collateralAmountWBTC; //perpsAccountModuleImpl.getCollateralAmount
  72 |     |         uint256 collateralAmountHUGE; //perpsAccountModuleImpl.getCollateralAmount
  73 |     |         uint256 totalCollateralValue; //perpsAccountModuleImpl.totalCollateralValue
  74 |     |         int128 sizeDelta;
  75 |     |         bool isOrderExpired;
  76 |     |         uint256 fillPriceWETH;
  77 |     |         uint256 fillPriceWBTC;
  78 |     |         uint256 sUSDBalance;
  79 |     |         int256 availableMargin; //perpsAccountModuleImpl.getAvailableMargin
  80 |     |         uint256 requiredInitialMargin; //perpsAccountModuleImpl.getRequiredMargins
  81 |     |         uint256 requiredMaintenanceMargin; //perpsAccountModuleImpl.getRequiredMargins
  82 |     |         uint256 marginKeeperFee; //perpsAccountModuleImpl.getRequiredMargins
  83 |     |         uint256 depositedWethCollateral;
  84 |     |         uint256 depositedSusdCollateral;
  85 |     |         uint128[] activeCollateralTypes;
  86 |     |         uint128[] openPositionMarketIds;
  87 |     |         PositionVars wethMarket; //TODO:rename to position
  88 |     |         PositionVars wbtcMarket;
  89 |     |     }
  90 |     | 
  91 |     |     struct StackCache {
  92 |     |         uint256 capacity;
  93 |     |         uint256 maxLiquidationInWindow;
  94 |     |         uint256 latestLiquidationTimestamp;
  95 |     |         int256 totalPnl;
  96 |     |         int256 accruedFunding;
  97 |     |         int128 positionSize;
  98 |     |         uint256 owedInterest;
  99 |     |         int256 skew;
 100 |     |         uint256 marketSkew;
 101 |     |         uint256 marketSize;
 102 |     |         uint256 rate;
 103 |     |         uint256 delegatedCollateral;
 104 |     |         uint256 lockedCredit;
 105 |     |         int256 availableMargin;
 106 |     |         uint256 requiredInitialMargin;
 107 |     |         uint256 requiredMaintenanceMargin;
 108 |     |         uint256 maxLiquidationReward;
 109 |     |         bool isOrderExpired;
 110 |     |         address collateralToken;
 111 |     |         int256 amount;
 112 |     |         bytes32 nodeId;
 113 |     |         int256 price;
 114 |     |         int256 value;
 115 |     |         int256 totalCollateralValueUsdGhost;
 116 |     |         uint128 accountId;
 117 |     |         int256 collateralValueUsd;
 118 |     |         int256 pricePnL;
 119 |     |         int256 pendingFunding;
 120 |     |         int256 debtUsd;
 121 |     |         int256 reportedDebtGhost;
 122 |     |         uint256 marketSizeGhost;
 123 |     |         int256 userReportedDebt;
 124 |     |         uint256 fillPriceWETH;
 125 |     |         uint256 fillPriceWBTC;
 126 |     |         uint256 orderFeesWBTC;
 127 |     |         uint256 orderFeesWETH;
 128 |     |         uint256 positionSizeSum;
 129 |     |     }
 130 |     | 
 131 |     |     event DebugSize(int size, address a, string s);
 132 |     |     event DebugSize(int size, address a, uint128 account, string s);
 133 |     | 
 134 | *   |     function _before(address[] memory actors) internal {
 135 | *   |         _setStates(0, actors);
 136 |     | 
 137 |     |         if (DEBUG) debugBefore(actors);
 138 |     |     }
 139 |     | 
 140 | *   |     function _after(address[] memory actors) internal {
 141 | *   |         _setStates(1, actors);
 142 |     | 
 143 |     |         if (DEBUG) debugAfter(actors);
 144 |     |     }
 145 | *   |     function _setStates(uint8 callNum, address[] memory actors) internal {
 146 | *   |         for (uint256 i = 0; i < ACCOUNTS.length; i++) {
 147 | *   |             _setActorState(callNum, ACCOUNTS[i], accountIdToUser[ACCOUNTS[i]]);
 148 |     |         }
 149 |     | 
 150 |     |         // Set states here that are independent from actors
 151 |     |     }
 152 | *   |     function _setActorState(
 153 |     |         uint8 callNum,
 154 |     |         uint128 accountId,
 155 |     |         address actor
 156 |     |     ) internal {
 157 | *   |         console2.log("===== BeforeAfter::_setActorState START ===== ");
 158 | *   |         StackCache memory cache;
 159 |     | 
 160 | *   |         resetGhostVariables(callNum);
 161 | *   |         getLiquidationValues(callNum, accountId, cache);
 162 | *   |         getCollateralInfo(callNum, accountId, cache);
 163 | *   |         getOrderInfo(callNum, accountId, cache);
 164 | *   |         getPositionInfo(callNum, accountId, cache);
 165 | *   |         getMarketInfo(callNum, cache);
 166 | *   |         getGlobalCollateralValues(callNum, cache);
 167 | *   |         calculateTotalCollateralValueGhost(callNum, cache);
 168 | *   |         getUtilizationInfo(callNum, cache);
 169 | *   |         getMarginInfo(callNum, accountId, cache);
 170 | *   |         calculateReportedDebtGhost(callNum, cache);
 171 |     | 
 172 | *   |         console2.log("===== BeforeAfter::_setActorState END ===== ");
 173 |     |     }
 174 |     | 
 175 | *   |     function resetGhostVariables(uint8 callNum) private {
 176 | *   |         states[callNum].totalCollateralValueUsdGhost = 0;
 177 | *   |         states[callNum].reportedDebtGhost = 0;
 178 | *   |         states[callNum].marketSizeGhost = 0;
 179 |     |     }
 180 |     | 
 181 | *   |     function getLiquidationValues(
 182 |     |         uint8 callNum,
 183 |     |         uint128 accountId,
 184 |     |         StackCache memory cache
 185 |     |     ) private {
 186 | *   |         (bool success, bytes memory returnData) = perps.call(
 187 | *   |             abi.encodeWithSelector(
 188 |     |                 liquidationModuleImpl.canLiquidate.selector,
 189 |     |                 accountId
 190 |     |             )
 191 |     |         );
 192 | *   |         states[callNum]
 193 |     |             .actorStates[accountId]
 194 |     |             .isPositionLiquidatablePassing = success;
 195 | *   |         fl.log("SUCC VALUE:", success);
 196 | *   |         fl.log("ACCOUNT ID:", accountId);
 197 | *   |         fl.log("CALL NUM:", callNum);
 198 |     |         // fl.t(false, "!passing success");
 199 | *   |         states[callNum].actorStates[accountId].isPositionLiquidatable = abi
 200 | *   |             .decode(returnData, (bool));
 201 |     | 
 202 | *   |         (success, returnData) = perps.call(
 203 | *   |             abi.encodeWithSelector(
 204 |     |                 liquidationModuleImpl.canLiquidateMarginOnly.selector,
 205 |     |                 accountId
 206 |     |             )
 207 |     |         );
 208 | *   |         assert(success);
 209 | *   |         states[callNum].actorStates[accountId].isMarginLiquidatable = abi
 210 | *   |             .decode(returnData, (bool));
 211 |     | 
 212 | *   |         _logLiquidatableCoverage(
 213 | *   |             states[callNum].actorStates[accountId].isPositionLiquidatable,
 214 | *   |             states[callNum].actorStates[accountId].isMarginLiquidatable
 215 |     |         );
 216 |     |     }
 217 |     | 
 218 | *   |     function getCollateralInfo(
 219 |     |         uint8 callNum,
 220 |     |         uint128 accountId,
 221 |     |         StackCache memory cache
 222 |     |     ) private {
 223 | *   |         (bool success, bytes memory returnData) = perps.call(
 224 | *   |             abi.encodeWithSelector(
 225 |     |                 perpsAccountModuleImpl.getAccountCollateralIds.selector,
 226 |     |                 accountId
 227 |     |             )
 228 |     |         );
 229 | *   |         assert(success);
 230 | *   |         states[callNum].actorStates[accountId].collateralIds = abi.decode(
 231 | *   |             returnData,
 232 |     |             (uint256[])
 233 |     |         );
 234 |     | 
 235 | *   |         getCollateralAmount(callNum, accountId, 0, cache);
 236 | *   |         getCollateralAmount(callNum, accountId, 1, cache);
 237 | *   |         getCollateralAmount(callNum, accountId, 2, cache);
 238 | *   |         getCollateralAmount(callNum, accountId, 3, cache);
 239 |     | 
 240 | *   |         (success, returnData) = perps.call(
 241 | *   |             abi.encodeWithSelector(
 242 |     |                 perpsAccountModuleImpl.totalCollateralValue.selector,
 243 |     |                 accountId
 244 |     |             )
 245 |     |         );
 246 | *   |         assert(success);
 247 | *   |         states[callNum].actorStates[accountId].totalCollateralValue = abi
 248 | *   |             .decode(returnData, (uint256));
 249 |     | 
 250 |     |         // Coverage check at the end
 251 | *   |         _logCollateralIdsCoverage(
 252 | *   |             states[callNum].actorStates[accountId].collateralIds // from map
 253 |     |         );
 254 |     | 
 255 |     |         // Additional coverage for collateral amounts and total value
 256 | *   |         _logCollateralAmountsCoverage(
 257 | *   |             states[callNum].actorStates[accountId].collateralAmountSUSD, // from map
 258 | *   |             states[callNum].actorStates[accountId].collateralAmountWETH, // from map
 259 | *   |             states[callNum].actorStates[accountId].collateralAmountWBTC, // from map
 260 |     |             // states[callNum].actorStates[accountId].collateralAmountHUGE, // from map TODO: add huge
 261 | *   |             states[callNum].actorStates[accountId].totalCollateralValue // from map
 262 |     |         );
 263 |     |     }
 264 |     | 
 265 | *   |     function getCollateralAmount(
 266 |     |         uint8 callNum,
 267 |     |         uint128 accountId,
 268 |     |         uint256 collateralId,
 269 |     |         StackCache memory cache
 270 | *   |     ) private {
 271 | *   |         (bool success, bytes memory returnData) = perps.call(
 272 | *   |             abi.encodeWithSelector(
 273 |     |                 perpsAccountModuleImpl.getCollateralAmount.selector,
 274 |     |                 accountId,
 275 |     |                 collateralId
 276 |     |             )
 277 |     |         );
 278 | *   |         assert(success);
 279 | *   |         uint256 amount = abi.decode(returnData, (uint256));
 280 |     | 
 281 | *   |         if (collateralId == 0) {
 282 | *   |             states[callNum]
 283 |     |                 .actorStates[accountId]
 284 |     |                 .collateralAmountSUSD = amount;
 285 | *   |         } else if (collateralId == 1) {
 286 | *   |             states[callNum]
 287 |     |                 .actorStates[accountId]
 288 |     |                 .collateralAmountWETH = amount;
 289 | *   |         } else if (collateralId == 2) {
 290 | *   |             states[callNum]
 291 |     |                 .actorStates[accountId]
 292 |     |                 .collateralAmountWBTC = amount;
 293 | *   |         } else if (collateralId == 3) {
 294 | *   |             states[callNum]
 295 |     |                 .actorStates[accountId]
 296 |     |                 .collateralAmountHUGE = amount;
 297 |     |         }
 298 |     |     }
 299 |     | 
 300 | *   |     function getOrderInfo(
 301 |     |         uint8 callNum,
 302 |     |         uint128 accountId,
 303 |     |         StackCache memory cache
 304 |     |     ) private {
 305 | *   |         (bool success, bytes memory returnData) = perps.call(
 306 | *   |             abi.encodeWithSelector(
 307 |     |                 perpsAccountModuleImpl.debt.selector,
 308 |     |                 accountId
 309 |     |             )
 310 |     |         );
 311 | *   |         assert(success);
 312 | *   |         states[callNum].actorStates[accountId].debt = abi.decode(
 313 | *   |             returnData,
 314 |     |             (uint128)
 315 |     |         );
 316 |     | 
 317 | *   |         (success, returnData) = perps.call(
 318 | *   |             abi.encodeWithSelector(
 319 |     |                 asyncOrderModuleImpl.getOrder.selector,
 320 |     |                 accountId
 321 |     |             )
 322 |     |         );
 323 | *   |         assert(success);
 324 | *   |         AsyncOrder.Data memory order = abi.decode(
 325 | *   |             returnData,
 326 |     |             (AsyncOrder.Data)
 327 |     |         );
 328 | *   |         states[callNum].actorStates[accountId].sizeDelta = order
 329 |     |             .request
 330 |     |             .sizeDelta;
 331 |     | 
 332 | *   |         (success, returnData) = perps.call(
 333 | *   |             abi.encodeWithSelector(
 334 |     |                 mockLensModuleImpl.isOrderExpired.selector,
 335 |     |                 accountId
 336 |     |             )
 337 |     |         );
 338 | *   |         assert(success);
 339 | *   |         cache.isOrderExpired = abi.decode(returnData, (bool));
 340 | *   |         states[callNum].actorStates[accountId].isOrderExpired = cache
 341 |     |             .isOrderExpired;
 342 |     | 
 343 | *   |         getOrderFees(callNum, accountId, 1, WETH_PYTH_PRICE_FEED_ID, cache);
 344 | *   |         getOrderFees(callNum, accountId, 2, WBTC_PYTH_PRICE_FEED_ID, cache);
 345 |     | 
 346 | *   |         states[callNum].actorStates[accountId].sUSDBalance = sUSDTokenMock
 347 | *   |             .balanceOf(accountIdToUser[accountId]);
 348 |     | 
 349 | *   |         _logOrderInfoCoverage(
 350 | *   |             states[callNum].actorStates[accountId].debt,
 351 | *   |             states[callNum].actorStates[accountId].sizeDelta,
 352 | *   |             states[callNum].actorStates[accountId].isOrderExpired,
 353 | *   |             states[callNum].actorStates[accountId].fillPriceWETH,
 354 | *   |             states[callNum].actorStates[accountId].fillPriceWBTC,
 355 |     |             states[callNum].actorStates[accountId].sUSDBalance
 356 |     |         );
 357 |     |     }
 358 |     | 
 359 | *   |     function getOrderFees(
 360 |     |         uint8 callNum,
 361 |     |         uint128 accountId,
 362 |     |         uint256 marketId,
 363 |     |         bytes32 priceFeedId,
 364 |     |         StackCache memory cache
 365 | *   |     ) private {
 366 | *   |         (bool success, bytes memory returnData) = perps.call(
 367 | *   |             abi.encodeWithSelector(
 368 | *   |                 asyncOrderModuleImpl.computeOrderFeesWithPrice.selector,
 369 | *   |                 marketId,
 370 | *   |                 states[callNum].actorStates[accountId].sizeDelta,
 371 | *   |                 pythWrapper.getBenchmarkPrice(priceFeedId, 0)
 372 |     |             )
 373 |     |         );
 374 | *   |         assert(success);
 375 | *   |         (uint256 orderFees, uint256 fillPrice) = abi.decode(
 376 | *   |             returnData,
 377 |     |             (uint256, uint256)
 378 |     |         );
 379 | *   |         if (marketId == 1) {
 380 | *   |             states[callNum].actorStates[accountId].fillPriceWETH = fillPrice;
 381 | *   |         } else if (marketId == 2) {
 382 | *   |             states[callNum].actorStates[accountId].fillPriceWBTC = fillPrice;
 383 |     |         }
 384 |     |     }
 385 |     | 
 386 | *   |     function getPositionInfo(
 387 |     |         uint8 callNum,
 388 |     |         uint128 accountId,
 389 |     |         StackCache memory cache
 390 |     |     ) private {
 391 | *   |         getOpenPosition(callNum, accountId, 1, cache);
 392 | *   |         getOpenPosition(callNum, accountId, 2, cache);
 393 |     | 
 394 | *   |         (bool success, bytes memory returnData) = perps.call(
 395 | *   |             abi.encodeWithSelector(
 396 |     |                 mockLensModuleImpl.getOpenPositionMarketIds.selector,
 397 |     |                 accountId
 398 |     |             )
 399 |     |         );
 400 |     | 
 401 | *   |         assert(success);
 402 |     | 
 403 | *   |         states[callNum].actorStates[accountId].openPositionMarketIds = abi
 404 | *   |             .decode(returnData, (uint128[]));
 405 |     | 
 406 | *   |         (success, returnData) = perps.call(
 407 | *   |             abi.encodeWithSelector(
 408 |     |                 mockLensModuleImpl.getGlobalCollateralTypes.selector,
 409 |     |                 accountId
 410 |     |             )
 411 |     |         );
 412 |     | 
 413 | *   |         assert(success);
 414 |     | 
 415 | *   |         states[callNum].actorStates[accountId].activeCollateralTypes = abi
 416 | *   |             .decode(returnData, (uint128[]));
 417 |     | 
 418 | *   |         (success, returnData) = perps.call(
 419 | *   |             abi.encodeWithSelector(
 420 |     |                 mockLensModuleImpl.getGlobalCollateralTypes.selector
 421 |     |             )
 422 |     |         );
 423 |     | 
 424 | *   |         assert(success);
 425 | *   |         states[callNum].globalCollateralTypes = abi.decode(
 426 | *   |             returnData,
 427 |     |             (uint128[])
 428 |     |         );
 429 |     | 
 430 | *   |         _logPositionInfoCoverage(
 431 | *   |             states[callNum].actorStates[accountId].wethMarket.totalPnl,
 432 | *   |             states[callNum].actorStates[accountId].wethMarket.accruedFunding,
 433 | *   |             states[callNum].actorStates[accountId].wethMarket.positionSize,
 434 | *   |             states[callNum].actorStates[accountId].wethMarket.owedInterest,
 435 | *   |             states[callNum].actorStates[accountId].wbtcMarket.totalPnl,
 436 | *   |             states[callNum].actorStates[accountId].wbtcMarket.accruedFunding,
 437 | *   |             states[callNum].actorStates[accountId].wbtcMarket.positionSize,
 438 | *   |             states[callNum].actorStates[accountId].wbtcMarket.owedInterest
 439 |     |         );
 440 |     |     }
 441 |     | 
 442 | *   |     function getOpenPosition(
 443 |     |         uint8 callNum,
 444 |     |         uint128 accountId,
 445 |     |         uint256 marketId,
 446 |     |         StackCache memory cache
 447 |     |     ) private {
 448 | *   |         (bool success, bytes memory returnData) = perps.call(
 449 | *   |             abi.encodeWithSelector(
 450 |     |                 perpsAccountModuleImpl.getOpenPosition.selector,
 451 |     |                 accountId,
 452 |     |                 marketId
 453 |     |             )
 454 |     |         );
 455 | *   |         assert(success);
 456 | *   |         (
 457 | *   |             cache.totalPnl,
 458 | *   |             cache.accruedFunding,
 459 | *   |             cache.positionSize,
 460 | *   |             cache.owedInterest
 461 | *   |         ) = abi.decode(returnData, (int256, int256, int128, uint256));
 462 |     | 
 463 | *   |         console2.log("Debug position size", cache.positionSize);
 464 |     | 
 465 | *   |         if (marketId == 1) {
 466 | *   |             states[callNum].actorStates[accountId].wethMarket.totalPnl = cache
 467 |     |                 .totalPnl;
 468 | *   |             states[callNum]
 469 |     |                 .actorStates[accountId]
 470 |     |                 .wethMarket
 471 | *   |                 .accruedFunding = cache.accruedFunding;
 472 | *   |             states[callNum]
 473 |     |                 .actorStates[accountId]
 474 |     |                 .wethMarket
 475 | *   |                 .positionSize = cache.positionSize;
 476 | *   |             states[callNum]
 477 |     |                 .actorStates[accountId]
 478 |     |                 .wethMarket
 479 | *   |                 .owedInterest = cache.owedInterest;
 480 | *   |         } else if (marketId == 2) {
 481 | *   |             states[callNum].actorStates[accountId].wbtcMarket.totalPnl = cache
 482 |     |                 .totalPnl;
 483 | *   |             states[callNum]
 484 |     |                 .actorStates[accountId]
 485 |     |                 .wbtcMarket
 486 | *   |                 .accruedFunding = cache.accruedFunding;
 487 | *   |             states[callNum]
 488 |     |                 .actorStates[accountId]
 489 |     |                 .wbtcMarket
 490 | *   |                 .positionSize = cache.positionSize;
 491 | *   |             states[callNum]
 492 |     |                 .actorStates[accountId]
 493 |     |                 .wbtcMarket
 494 | *   |                 .owedInterest = cache.owedInterest;
 495 |     |         }
 496 |     |     }
 497 |     | 
 498 | *   |     function getMarketInfo(uint8 callNum, StackCache memory cache) private {
 499 | *   |         getLiquidationCapacity(callNum, 1, cache);
 500 | *   |         getLiquidationCapacity(callNum, 2, cache);
 501 | *   |         getLiquidationCapacity(callNum, 3, cache);
 502 |     | 
 503 | *   |         getMarketSize(callNum, 1, cache);
 504 | *   |         getMarketSize(callNum, 2, cache);
 505 | *   |         getMarketSize(callNum, 3, cache);
 506 |     | 
 507 | *   |         getMarketSkew(callNum, 1, cache);
 508 | *   |         getMarketSkew(callNum, 2, cache);
 509 | *   |         getMarketSkew(callNum, 3, cache);
 510 |     | 
 511 | *   |         _logMarketInfoCoverage(
 512 | *   |             states[callNum].wethMarket.liquidationCapacity,
 513 | *   |             states[callNum].wbtcMarket.liquidationCapacity,
 514 |     |             // states[callNum].hugeMarket.liquidationCapacity, //not sure if a huge precision tokens is aplicable for the protocol
 515 | *   |             states[callNum].wethMarket.marketSize,
 516 | *   |             states[callNum].wbtcMarket.marketSize
 517 |     |             // states[callNum].hugeMarket.marketSize,
 518 |     |             // states[callNum].wbtcMarket.skew,
 519 |     |             // states[callNum].wethMarket.skew
 520 |     |             // states[callNum].hugeMarket.skew
 521 |     |         );
 522 |     |     }
 523 |     | 
 524 | *   |     function getLiquidationCapacity(
 525 |     |         uint8 callNum,
 526 |     |         uint256 marketId,
 527 |     |         StackCache memory cache
 528 | *   |     ) private {
 529 | *   |         (bool success, bytes memory returnData) = perps.call(
 530 | *   |             abi.encodeWithSelector(
 531 |     |                 liquidationModuleImpl.liquidationCapacity.selector,
 532 |     |                 marketId
 533 |     |             )
 534 |     |         );
 535 | *   |         assert(success);
 536 | *   |         (
 537 |     |             cache.capacity,
 538 | *   |             cache.maxLiquidationInWindow,
 539 | *   |             cache.latestLiquidationTimestamp
 540 | *   |         ) = abi.decode(returnData, (uint256, uint256, uint256));
 541 | *   |         if (marketId == 1) {
 542 | *   |             states[callNum].wethMarket.liquidationCapacity = cache.capacity;
 543 | *   |         } else if (marketId == 2) {
 544 | *   |             states[callNum].wbtcMarket.liquidationCapacity = cache.capacity;
 545 |     |         }
 546 |     |     }
 547 |     | 
 548 | *   |     function getMarketSize(
 549 |     |         uint8 callNum,
 550 |     |         uint256 marketId,
 551 |     |         StackCache memory cache
 552 | *   |     ) private {
 553 | *   |         (bool success, bytes memory returnData) = perps.call(
 554 | *   |             abi.encodeWithSelector(
 555 |     |                 perpsMarketModuleImpl.size.selector,
 556 |     |                 marketId
 557 |     |             )
 558 |     |         );
 559 | *   |         assert(success);
 560 | *   |         cache.marketSize = abi.decode(returnData, (uint256));
 561 | *   |         if (marketId == 1) {
 562 | *   |             states[callNum].wethMarket.marketSize = cache.marketSize;
 563 | *   |         } else if (marketId == 2) {
 564 | *   |             states[callNum].wbtcMarket.marketSize = cache.marketSize;
 565 |     |         }
 566 |     |     }
 567 |     | 
 568 | *   |     function getMarketSkew(
 569 |     |         uint8 callNum,
 570 |     |         uint256 marketId,
 571 |     |         StackCache memory cache
 572 | *   |     ) private {
 573 | *   |         (bool success, bytes memory returnData) = perps.call(
 574 | *   |             abi.encodeWithSelector(
 575 |     |                 perpsMarketModuleImpl.skew.selector,
 576 |     |                 marketId
 577 |     |             )
 578 |     |         );
 579 | *   |         assert(success);
 580 | *   |         cache.skew = abi.decode(returnData, (int256));
 581 | *   |         if (marketId == 1) {
 582 | *   |             states[callNum].wethMarket.skew = cache.skew;
 583 | *   |         } else if (marketId == 2) {
 584 | *   |             states[callNum].wbtcMarket.skew = cache.skew;
 585 | *   |         } else if (marketId == 3) {
 586 | *   |             states[callNum].hugeMarket.skew = cache.skew;
 587 |     |         }
 588 |     |     }
 589 | *   |     function getGlobalCollateralValues(
 590 |     |         uint8 callNum,
 591 |     |         StackCache memory cache
 592 |     |     ) private {
 593 | *   |         getGlobalCollateralValue(callNum, 0);
 594 | *   |         getGlobalCollateralValue(callNum, 1);
 595 | *   |         getGlobalCollateralValue(callNum, 2);
 596 | *   |         getGlobalCollateralValue(callNum, 3);
 597 |     | 
 598 | *   |         (bool success, bytes memory returnData) = perps.call(
 599 | *   |             abi.encodeWithSelector(
 600 |     |                 globalPerpsMarketModuleImpl.totalGlobalCollateralValue.selector
 601 |     |             )
 602 |     |         );
 603 | *   |         assert(success);
 604 | *   |         uint256 totalCollateralValue = abi.decode(returnData, (uint256));
 605 | *   |         states[callNum].totalCollateralValueUsd = int256(totalCollateralValue);
 606 |     | 
 607 | *   |         _logGlobalCollateralValuesCoverage(
 608 | *   |             states[callNum].depositedSusdCollateral,
 609 | *   |             states[callNum].depositedWethCollateral,
 610 | *   |             states[callNum].depositedWbtcCollateral,
 611 |     |             // states[callNum].depositedHUGECollateral,
 612 |     |             states[callNum].totalCollateralValueUsd,
 613 | *   |             states[callNum].totalCollateralValueUsdGhost,
 614 | *   |             states[callNum].skew
 615 |     |         );
 616 |     |     }
 617 |     | 
 618 | *   |     function getGlobalCollateralValue(
 619 |     |         uint8 callNum,
 620 |     |         uint256 collateralId
 621 | *   |     ) private {
 622 | *   |         (bool success, bytes memory returnData) = perps.call(
 623 | *   |             abi.encodeWithSelector(
 624 |     |                 globalPerpsMarketModuleImpl.globalCollateralValue.selector,
 625 |     |                 collateralId
 626 |     |             )
 627 |     |         );
 628 | *   |         assert(success);
 629 | *   |         uint256 collateralValue = abi.decode(returnData, (uint256));
 630 | *   |         if (collateralId == 0) {
 631 | *   |             states[callNum].depositedSusdCollateral = collateralValue;
 632 | *   |         } else if (collateralId == 1) {
 633 | *   |             states[callNum].depositedWethCollateral = collateralValue;
 634 | *   |         } else if (collateralId == 2) {
 635 | *   |             states[callNum].depositedWbtcCollateral = collateralValue;
 636 | *   |         } else if (collateralId == 3) {
 637 | *   |             states[callNum].depositedHUGECollateral = collateralValue;
 638 |     |         }
 639 |     |     }
 640 |     | 
 641 | *   |     function calculateTotalCollateralValueGhost(
 642 |     |         uint8 callNum,
 643 |     |         StackCache memory cache
 644 |     |     ) private {
 645 | *   |         cache.totalCollateralValueUsdGhost = 0;
 646 | *   |         for (uint256 i = 0; i < USERS.length; i++) {
 647 | *   |             cache.accountId = userToAccountIds[USERS[i]];
 648 | *   |             cache
 649 | *   |                 .totalCollateralValueUsdGhost += calculateCollateralValueForAccount(
 650 | *   |                 callNum,
 651 |     |                 cache.accountId,
 652 |     |                 cache
 653 |     |             );
 654 |     |         }
 655 | *   |         states[callNum].totalCollateralValueUsdGhost = cache
 656 |     |             .totalCollateralValueUsdGhost;
 657 |     |     }
 658 |     | 
 659 | *   |     function calculateCollateralValueForAccount(
 660 |     |         uint8 callNum,
 661 |     |         uint128 accountId,
 662 |     |         StackCache memory cache
 663 | *   |     ) private view returns (int256) {
 664 |     |         int256 totalValue = 0;
 665 | *   |         totalValue += calculateCollateralValueForToken(
 666 | *   |             callNum,
 667 | *   |             accountId,
 668 |     |             0,
 669 | *   |             1e18,
 670 | *   |             cache
 671 |     |         );
 672 | *   |         totalValue += calculateCollateralValueForToken(
 673 | *   |             callNum,
 674 | *   |             accountId,
 675 | *   |             1,
 676 | *   |             pythWrapper.getBenchmarkPrice(WETH_FEED_ID, 0),
 677 | *   |             cache
 678 |     |         );
 679 | *   |         totalValue += calculateCollateralValueForToken(
 680 | *   |             callNum,
 681 | *   |             accountId,
 682 | *   |             2,
 683 | *   |             pythWrapper.getBenchmarkPrice(WBTC_FEED_ID, 0),
 684 |     |             cache
 685 |     |         );
 686 |     |         return totalValue;
 687 |     |     }
 688 |     | 
 689 | *   |     function calculateCollateralValueForToken(
 690 |     |         uint8 callNum,
 691 |     |         uint128 accountId,
 692 |     |         uint256 collateralId,
 693 |     |         int256 price,
 694 |     |         StackCache memory cache
 695 | *   |     ) private view returns (int256) {
 696 | *   |         int256 amount;
 697 | *   |         if (collateralId == 0) {
 698 |     |             amount = int256(
 699 | *   |                 states[callNum].actorStates[accountId].collateralAmountSUSD
 700 |     |             );
 701 | *   |         } else if (collateralId == 1) {
 702 |     |             amount = int256(
 703 | *   |                 states[callNum].actorStates[accountId].collateralAmountWETH
 704 |     |             );
 705 | *   |         } else if (collateralId == 2) {
 706 |     |             amount = int256(
 707 | *   |                 states[callNum].actorStates[accountId].collateralAmountWBTC
 708 |     |             );
 709 |     |         }
 710 | *   |         return (price * amount) / 1e18;
 711 |     |     }
 712 |     | 
 713 | *   |     function getUtilizationInfo(
 714 |     |         uint8 callNum,
 715 |     |         StackCache memory cache
 716 |     |     ) private {
 717 | *   |         (bool success, bytes memory returnData) = perps.call(
 718 | *   |             abi.encodeWithSelector(
 719 |     |                 perpsMarketFactoryModuleImpl.minimumCredit.selector,
 720 |     |                 1
 721 |     |             )
 722 |     |         );
 723 | *   |         assert(success);
 724 | *   |         states[callNum].minimumCredit = abi.decode(returnData, (uint256));
 725 |     | 
 726 | *   |         (success, returnData) = perps.staticcall(
 727 | *   |             abi.encodeWithSelector(
 728 |     |                 perpsMarketFactoryModuleImpl.utilizationRate.selector
 729 |     |             )
 730 |     |         );
 731 | *   |         assert(success);
 732 | *   |         (cache.rate, cache.delegatedCollateral, cache.lockedCredit) = abi
 733 | *   |             .decode(returnData, (uint256, uint256, uint256));
 734 | *   |         states[callNum].utilizationRate = cache.rate;
 735 | *   |         states[callNum].delegatedCollateral = cache.delegatedCollateral;
 736 | *   |         states[callNum].lockedCredit = cache.lockedCredit;
 737 |     | 
 738 | *   |         _logUtilizationInfoCoverage(
 739 | *   |             states[callNum].minimumCredit,
 740 |     |             states[callNum].utilizationRate,
 741 |     |             states[callNum].delegatedCollateral,
 742 |     |             states[callNum].lockedCredit
 743 |     |         );
 744 |     |     }
 745 |     | 
 746 | *   |     function getMarginInfo(
 747 |     |         uint8 callNum,
 748 |     |         uint128 accountId,
 749 |     |         StackCache memory cache
 750 |     |     ) private {
 751 | *   |         (bool success, bytes memory returnData) = perps.staticcall(
 752 | *   |             abi.encodeWithSelector(
 753 |     |                 perpsAccountModuleImpl.getAvailableMargin.selector,
 754 |     |                 accountId
 755 |     |             )
 756 |     |         );
 757 | *   |         assert(success);
 758 | *   |         cache.availableMargin = abi.decode(returnData, (int256));
 759 | *   |         states[callNum].actorStates[accountId].availableMargin = cache
 760 |     |             .availableMargin;
 761 |     | 
 762 | *   |         (success, returnData) = perps.staticcall(
 763 | *   |             abi.encodeWithSelector(
 764 |     |                 perpsAccountModuleImpl.getRequiredMargins.selector,
 765 |     |                 accountId
 766 |     |             )
 767 |     |         );
 768 | *   |         assert(success);
 769 | *   |         (
 770 | *   |             cache.requiredInitialMargin,
 771 | *   |             cache.requiredMaintenanceMargin,
 772 | *   |             cache.maxLiquidationReward
 773 | *   |         ) = abi.decode(returnData, (uint256, uint256, uint256));
 774 | *   |         states[callNum].actorStates[accountId].requiredInitialMargin = cache
 775 |     |             .requiredInitialMargin;
 776 | *   |         states[callNum].actorStates[accountId].requiredMaintenanceMargin = cache
 777 |     |             .requiredMaintenanceMargin;
 778 | *   |         states[callNum].actorStates[accountId].marginKeeperFee = cache
 779 |     |             .maxLiquidationReward;
 780 |     | 
 781 | *   |         _logMarginInfoCoverage(
 782 | *   |             states[callNum].actorStates[accountId].availableMargin,
 783 |     |             states[callNum].actorStates[accountId].requiredInitialMargin,
 784 |     |             states[callNum].actorStates[accountId].requiredMaintenanceMargin,
 785 |     |             states[callNum].actorStates[accountId].marginKeeperFee
 786 |     |         );
 787 |     |     }
 788 |     | 
 789 | *   |     function calculateReportedDebtGhost(
 790 |     |         uint8 callNum,
 791 |     |         StackCache memory cache
 792 |     |     ) private {
 793 | *   |         cache.reportedDebtGhost = 0;
 794 | *   |         cache.marketSizeGhost = 0;
 795 |     | 
 796 | *   |         for (uint256 i = 0; i < USERS.length; i++) {
 797 | *   |             cache.accountId = userToAccountIds[USERS[i]];
 798 | *   |             (
 799 | *   |                 cache.collateralValueUsd,
 800 | *   |                 cache.pricePnL,
 801 | *   |                 cache.pendingFunding,
 802 | *   |                 cache.debtUsd,
 803 | *   |                 cache.positionSizeSum
 804 | *   |             ) = getAccountValues(callNum, cache.accountId); //sum markets
 805 |     | 
 806 | *   |             cache.userReportedDebt =
 807 | *   |                 (cache.collateralValueUsd +
 808 |     |                     cache.pricePnL +
 809 |     |                     cache.pendingFunding) -
 810 |     |                 cache.debtUsd;
 811 | *   |             cache.reportedDebtGhost += cache.userReportedDebt;
 812 | *   |             cache.marketSizeGhost += cache.positionSizeSum;
 813 |     | 
 814 | *   |             _logReportedDebtGhostCoverage(
 815 | *   |                 cache.reportedDebtGhost,
 816 | *   |                 cache.marketSizeGhost
 817 |     |             );
 818 |     | 
 819 | *   |             emit DebugSize(
 820 | *   |                 int256(cache.positionSizeSum),
 821 | *   |                 USERS[i],
 822 | *   |                 cache.accountId,
 823 |     |                 "Total position size"
 824 |     |             );
 825 |     |         }
 826 |     |         /*
 827 |     |         //positions.sum(p.collateralUsd + p.pricePnL + p.pendingFunding - p.pendingUtilization - p.debtUsd)";
 828 |     |          int256 totalDebt = collateralValue.toInt() +
 829 |     |                 totalMarketDebt -
 830 |     |                 globalMarket.totalAccountsDebt.toInt();
 831 |     | 
 832 |     |             */
 833 | *   |         if (cache.reportedDebtGhost < 0) cache.reportedDebtGhost = 0; // Reported Debt Cannot Go Negative
 834 |     | 
 835 |     |         // Store the calculated values in the state
 836 | *   |         states[callNum].reportedDebtGhost = cache.reportedDebtGhost;
 837 | *   |         states[callNum].marketSizeGhost = cache.marketSizeGhost;
 838 |     | 
 839 | *   |         console2.log("reportedDebtGhost", states[callNum].reportedDebtGhost);
 840 | *   |         console2.log("marketSizeGhost", states[callNum].marketSizeGhost);
 841 |     |     }
 842 |     | 
 843 | *   |     function getAccountValues(
 844 |     |         uint8 callNum,
 845 |     |         uint128 accountId
 846 | *   |     ) private returns (int256, int256, int256, int256, uint256) {
 847 |     |         int256 collateralValueUsd;
 848 |     |         int256 pricePnL = 0;
 849 |     |         int256 pendingFunding = 0;
 850 |     |         int256 debtUsd;
 851 |     |         uint256 positionSizeSum = 0;
 852 |     | 
 853 | *   |         (bool success, bytes memory returnData) = perps.call(
 854 | *   |             abi.encodeWithSelector(
 855 |     |                 perpsAccountModuleImpl.totalCollateralValue.selector,
 856 |     |                 accountId
 857 |     |             )
 858 |     |         );
 859 | *   |         assert(success);
 860 | *   |         collateralValueUsd = int256(abi.decode(returnData, (uint256)));
 861 |     | 
 862 | *   |         for (uint128 marketId = 1; marketId <= 2; marketId++) {
 863 | *   |             (success, returnData) = perps.call(
 864 | *   |                 abi.encodeWithSelector(
 865 | *   |                     perpsAccountModuleImpl.getOpenPosition.selector,
 866 | *   |                     accountId,
 867 | *   |                     marketId
 868 |     |                 )
 869 |     |             );
 870 | *   |             assert(success);
 871 | *   |             (
 872 | *   |                 int256 totalPnl,
 873 | *   |                 int256 accruedFunding,
 874 | *   |                 int128 positionSize,
 875 |     | 
 876 | *   |             ) = abi.decode(returnData, (int256, int256, int128, uint256));
 877 |     | 
 878 | *   |             pricePnL += totalPnl;
 879 | *   |             pendingFunding += accruedFunding;
 880 | *   |             positionSizeSum += uint256(MathUtil.abs(positionSize));
 881 |     |         }
 882 |     | 
 883 | *   |         (success, returnData) = perps.call(
 884 | *   |             abi.encodeWithSelector(
 885 | *   |                 perpsAccountModuleImpl.debt.selector,
 886 |     |                 accountId
 887 |     |             )
 888 |     |         );
 889 | *   |         assert(success);
 890 | *   |         debtUsd = abi.decode(returnData, (int256));
 891 |     | 
 892 |     |         return (
 893 | *   |             collateralValueUsd,
 894 | *   |             pricePnL,
 895 | *   |             pendingFunding,
 896 |     |             debtUsd,
 897 |     |             positionSizeSum
 898 |     |         );
 899 |     |     }
 900 |     | 
 901 |     |     function debugBefore(address[] memory actors) internal {
 902 |     |         debugState(0, actors);
 903 |     |     }
 904 |     | 
 905 |     |     function debugAfter(address[] memory actors) internal {
 906 |     |         debugState(1, actors);
 907 |     |     }
 908 |     | 
 909 |     |     function debugState(uint8 callNum, address[] memory actors) internal {
 910 |     |         for (uint256 i = 0; i < actors.length; i++) {
 911 |     |             debugActorState(callNum, actors[i]);
 912 |     |         }
 913 |     |     }
 914 |     | 
 915 |     |     function debugActorState(uint8 callNum, address actor) internal {
 916 |     |         fl.log("Actor: ", actor);
 917 |     |     }
 918 |     | }
 919 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/FuzzStorageVariables.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import "../util/FuzzConstants.sol";
   6 |     | import "../util/CheckCaller.sol";
   7 |     | 
   8 |     | import {MockRouter} from "../mocks/MockRouter.sol";
   9 |     | import {MockSynthetixV3} from "../mocks/MockSynthetixV3.sol";
  10 |     | import {Proxy} from "../../Proxy.sol";
  11 |     | import {MockOracleManager} from "../mocks/MockOracleManager.sol";
  12 |     | import {MockERC20} from "../mocks/MockERC20.sol";
  13 |     | import {MockOracleManager} from "../mocks/MockOracleManager.sol";
  14 |     | import {CoreModule} from "../../modules/CoreModule.sol";
  15 |     | import {AsyncOrderCancelModule} from "../../modules/AsyncOrderCancelModule.sol";
  16 |     | import {AsyncOrderModule} from "../../modules/AsyncOrderModule.sol";
  17 |     | import {AsyncOrderSettlementPythModule} from "../../modules/AsyncOrderSettlementPythModule.sol";
  18 |     | import {CollateralConfigurationModule} from "../../modules/CollateralConfigurationModule.sol";
  19 |     | import {FeatureFlagModule} from "../../modules/FeatureFlagModule.sol";
  20 |     | import {GlobalPerpsMarketModule} from "../../modules/GlobalPerpsMarketModule.sol";
  21 |     | import {LiquidationModule} from "../../modules/LiquidationModule.sol";
  22 |     | import {MarketConfigurationModule} from "../../modules/MarketConfigurationModule.sol";
  23 |     | import {PerpsAccountModule} from "../../modules/PerpsAccountModule.sol";
  24 |     | import {PerpsMarketFactoryModule} from "../../modules/PerpsMarketFactoryModule.sol";
  25 |     | import {PerpsMarketModule} from "../../modules/PerpsMarketModule.sol";
  26 |     | 
  27 |     | import {MockModule} from "../mocks/MockModule.sol";
  28 |     | import {MockPyth} from "../mocks/MockPyth.sol";
  29 |     | import {MockPythERC7412Wrapper} from "../../mocks/MockPythERC7412Wrapper.sol";
  30 |     | import {MockRewardDistributor} from "../mocks/MockRewardDistributor.sol";
  31 |     | import {MockSpotMarket} from "../mocks/MockSpotMarket.sol";
  32 |     | import {MockVaultModule} from "../mocks/MockVaultModule.sol";
  33 |     | import {MockLensModule} from "../mocks/MockLensModule.sol";
  34 |     | 
  35 |     | import {MockGasPriceNode} from "../../mocks/MockGasPriceNode.sol";
  36 |     | 
  37 |     | import "lib/forge-std/src/Test.sol";
  38 |     | 
  39 |     | contract FuzzStorageVariables is FuzzConstants, Test {
  40 |     |     //Foundry compatibility
  41 |     |     bool isFoundry;
  42 |     |     bool guidedDone;
  43 |     |     CheckCaller checkCaller;
  44 |     | 
  45 |     |     // Echidna settings
  46 |     |     address internal currentActor;
  47 |     |     bool internal _setActor = true;
  48 |     | 
  49 |     |     // user => accountId
  50 |     |     mapping(address => uint128) userToAccountIds;
  51 |     |     mapping(uint128 => address) accountIdToUser;
  52 |     |     // pythNodeId => chainlinkNodeId, chainlinkNodeId => pythNodeId
  53 |     |     mapping(bytes32 node1 => bytes32 node2) oracleNodes;
  54 |     |     // collateralToken => chainlink nodeId
  55 |     |     mapping(address collateralToken => bytes32 nodeId) tokenChainlinkNode;
  56 | *   |     mapping(address => uint256) public collateralToMarketId;
  57 |     | 
  58 |     |     MockERC20[] internal tokens;
  59 |     | 
  60 |     |     // All of the deployed contracts
  61 |     |     address internal perps;
  62 |     |     MockRouter internal router;
  63 |     |     MockSpotMarket internal spot;
  64 |     |     MockSynthetixV3 internal v3Mock;
  65 |     | 
  66 |     |     CoreModule internal coreModuleImpl;
  67 |     | 
  68 |     |     AsyncOrderCancelModule internal asyncOrderCancelModuleImpl;
  69 |     |     AsyncOrderModule internal asyncOrderModuleImpl;
  70 |     |     AsyncOrderSettlementPythModule internal asyncOrderSettlementPythModuleImpl;
  71 |     |     CollateralConfigurationModule internal collateralConfigurationModuleImpl;
  72 |     |     FeatureFlagModule internal featureFlagModuleImpl;
  73 |     |     GlobalPerpsMarketModule internal globalPerpsMarketModuleImpl;
  74 |     |     LiquidationModule internal liquidationModuleImpl;
  75 |     |     MarketConfigurationModule internal marketConfigurationModuleImpl;
  76 |     |     PerpsAccountModule internal perpsAccountModuleImpl;
  77 |     |     PerpsMarketFactoryModule internal perpsMarketFactoryModuleImpl;
  78 |     |     PerpsMarketModule internal perpsMarketModuleImpl;
  79 |     |     // PoolModule internal poolModuleImpl;
  80 |     | 
  81 |     |     MockModule internal mockModuleImpl;
  82 |     |     MockOracleManager internal mockOracleManager;
  83 |     |     MockERC20 internal sUSDTokenMock;
  84 |     |     MockERC20 internal wethTokenMock;
  85 |     |     MockERC20 internal wbtcTokenMock;
  86 |     |     MockERC20 internal hugePrecisionTokenMock;
  87 |     |     MockPyth internal mockPyth;
  88 |     |     MockPythERC7412Wrapper internal pythWrapper;
  89 |     |     MockRewardDistributor internal rewardWETHDistributorMock;
  90 |     |     MockRewardDistributor internal rewardWBTCDistributorMock;
  91 |     |     MockRewardDistributor internal rewardHUGEDistributorMock;
  92 |     |     MockGasPriceNode internal mockGasPriceNode;
  93 |     |     MockVaultModule internal vaultModuleMock;
  94 |     |     MockLensModule internal mockLensModuleImpl;
  95 |     |     // bool modifyCalled;
  96 |     |     // bool commitCalled;
  97 |     |     // address commitCaller;
  98 |     |     uint128 latestAvailableId = 4;
  99 |     | }
 100 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/GlobalCoverage.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   4 |     | 
   5 |     | contract GlobalCoverage is FuzzBase {
   6 | *   |     function _logGlobalCollateralValuesCoverage(
   7 |     |         uint256 depositedSusdCollateral,
   8 |     |         uint256 depositedWethCollateral,
   9 |     |         uint256 depositedWbtcCollateral,
  10 |     |         int256 totalCollateralValueUsd,
  11 |     |         int256 totalCollateralValueUsdGhost,
  12 |     |         int128 skew
  13 |     |     ) internal {
  14 | *   |         _logSusdCollateralCoverage(depositedSusdCollateral);
  15 | *   |         _logWethCollateralCoverage(depositedWethCollateral);
  16 | *   |         _logWbtcCollateralCoverage(depositedWbtcCollateral);
  17 | *   |         _logTotalCollateralValueCoverage(totalCollateralValueUsd, totalCollateralValueUsdGhost);
  18 | *   |         _logSkewCoverage(skew);
  19 |     |     }
  20 |     | 
  21 | *   |     function _logSusdCollateralCoverage(uint256 depositedSusdCollateral) internal {
  22 | *   |         if (depositedSusdCollateral == 0) {
  23 |     |             fl.log("No SUSD collateral deposited");
  24 | *   |         } else if (depositedSusdCollateral <= 1000e18) {
  25 | *   |             fl.log("Low SUSD collateral (0-1000)");
  26 | *   |         } else if (depositedSusdCollateral <= 10000e18) {
  27 |     |             fl.log("Medium SUSD collateral (1000-10000)");
  28 | *   |         } else if (depositedSusdCollateral <= 100000e18) {
  29 | *   |             fl.log("High SUSD collateral (10000-100000)");
  30 |     |         } else {
  31 | *   |             fl.log("Very high SUSD collateral (>100000)");
  32 |     |         }
  33 |     |     }
  34 |     | 
  35 | *   |     function _logWethCollateralCoverage(uint256 depositedWethCollateral) internal {
  36 | *   |         if (depositedWethCollateral == 0) {
  37 | *   |             fl.log("No WETH collateral deposited");
  38 | *   |         } else if (depositedWethCollateral <= 10e18) {
  39 | *   |             fl.log("Low WETH collateral (0-10)");
  40 | *   |         } else if (depositedWethCollateral <= 100e18) {
  41 | *   |             fl.log("Medium WETH collateral (10-100)");
  42 | *   |         } else if (depositedWethCollateral <= 1000e18) {
  43 |     |             fl.log("High WETH collateral (100-1000)");
  44 |     |         } else {
  45 | *   |             fl.log("Very high WETH collateral (>1000)");
  46 |     |         }
  47 |     |     }
  48 |     | 
  49 | *   |     function _logWbtcCollateralCoverage(uint256 depositedWbtcCollateral) internal {
  50 | *   |         if (depositedWbtcCollateral == 0) {
  51 | *   |             fl.log("No WBTC collateral deposited");
  52 | *   |         } else if (depositedWbtcCollateral <= 1e8) {
  53 | *   |             fl.log("Low WBTC collateral (0-1)");
  54 | *   |         } else if (depositedWbtcCollateral <= 10e8) {
  55 |     |             fl.log("Medium WBTC collateral (1-10)");
  56 | *   |         } else if (depositedWbtcCollateral <= 100e8) {
  57 | *   |             fl.log("High WBTC collateral (10-100)");
  58 |     |         } else {
  59 | *   |             fl.log("Very high WBTC collateral (>100)");
  60 |     |         }
  61 |     |     }
  62 |     | 
  63 | *   |     function _logTotalCollateralValueCoverage(
  64 |     |         int256 totalCollateralValueUsd,
  65 |     |         int256 totalCollateralValueUsdGhost
  66 |     |     ) internal {
  67 | *   |         if (totalCollateralValueUsd == 0) {
  68 | *   |             fl.log("No total collateral value");
  69 | *   |         } else if (totalCollateralValueUsd <= 10000e18) {
  70 |     |             fl.log("Low total collateral value (0-10000)");
  71 | *   |         } else if (totalCollateralValueUsd <= 100000e18) {
  72 | *   |             fl.log("Medium total collateral value (10000-100000)");
  73 | *   |         } else if (totalCollateralValueUsd <= 1000000e18) {
  74 | *   |             fl.log("High total collateral value (100000-1000000)");
  75 |     |         } else {
  76 | *   |             fl.log("Very high total collateral value (>1000000)");
  77 |     |         }
  78 |     | 
  79 | *   |         if (totalCollateralValueUsd == totalCollateralValueUsdGhost) {
  80 | *   |             fl.log("Total collateral value matches ghost value");
  81 | *   |         } else if (totalCollateralValueUsd > totalCollateralValueUsdGhost) {
  82 | *   |             fl.log("Total collateral value higher than ghost value");
  83 |     |         } else {
  84 |     |             fl.log("Total collateral value lower than ghost value");
  85 |     |         }
  86 |     | 
  87 | *   |         int256 difference = totalCollateralValueUsd - totalCollateralValueUsdGhost;
  88 | *   |         if (difference == 0) {
  89 | *   |             fl.log("No difference between total and ghost collateral values");
  90 | *   |         } else if (abs(difference) <= 100e18) {
  91 |     |             fl.log("Small difference between total and ghost collateral values (0-100)");
  92 | *   |         } else if (abs(difference) <= 1000e18) {
  93 |     |             fl.log("Medium difference between total and ghost collateral values (100-1000)");
  94 |     |         } else {
  95 | *   |             fl.log("Large difference between total and ghost collateral values (>1000)");
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 | *   |     function _logSkewCoverage(int128 skew) internal {
 100 | *   |         if (skew == 0) {
 101 | *   |             fl.log("No market skew");
 102 |     |         } else if (skew > 0) {
 103 |     |             if (skew <= 1000e18) {
 104 |     |                 fl.log("Small positive market skew (0-1000)");
 105 |     |             } else if (skew <= 10000e18) {
 106 |     |                 fl.log("Medium positive market skew (1000-10000)");
 107 |     |             } else {
 108 |     |                 fl.log("Large positive market skew (>10000)");
 109 |     |             }
 110 |     |         } else {
 111 |     |             if (skew >= -1000e18) {
 112 |     |                 fl.log("Small negative market skew (0 to -1000)");
 113 |     |             } else if (skew >= -10000e18) {
 114 |     |                 fl.log("Medium negative market skew (-1000 to -10000)");
 115 |     |             } else {
 116 |     |                 fl.log("Large negative market skew (<-10000)");
 117 |     |             }
 118 |     |         }
 119 |     |     }
 120 | *   |     function _logUtilizationInfoCoverage(
 121 |     |         uint256 minimumCredit,
 122 |     |         uint256 utilizationRate,
 123 |     |         uint256 delegatedCollateral,
 124 |     |         uint256 lockedCredit
 125 |     |     ) internal {
 126 |     |         // Minimum Credit Coverage
 127 | *   |         if (minimumCredit == 0) {
 128 | *   |             fl.log("No minimum credit set");
 129 | *   |         } else if (minimumCredit <= 1000e18) {
 130 | *   |             fl.log("Low minimum credit (0-1000)");
 131 | *   |         } else if (minimumCredit <= 10000e18) {
 132 |     |             fl.log("Medium minimum credit (1000-10000)");
 133 |     |         } else {
 134 | *   |             fl.log("High minimum credit (>10000)");
 135 |     |         }
 136 |     | 
 137 |     |         // Utilization Rate Coverage
 138 | *   |         if (utilizationRate == 0) {
 139 | *   |             fl.log("No utilization");
 140 | *   |         } else if (utilizationRate <= 2000) {
 141 |     |             // Assuming utilization rate is in basis points (0.01% = 1)
 142 | *   |             fl.log("Low utilization rate (0-20%)");
 143 | *   |         } else if (utilizationRate <= 5000) {
 144 |     |             fl.log("Medium utilization rate (20-50%)");
 145 | *   |         } else if (utilizationRate <= 8000) {
 146 |     |             fl.log("High utilization rate (50-80%)");
 147 |     |         } else {
 148 | *   |             fl.log("Very high utilization rate (>80%)");
 149 |     |         }
 150 |     | 
 151 |     |         // Delegated Collateral Coverage
 152 | *   |         if (delegatedCollateral == 0) {
 153 | *   |             fl.log("No delegated collateral");
 154 | *   |         } else if (delegatedCollateral <= 1000e18) {
 155 | *   |             fl.log("Low delegated collateral (0-1000)");
 156 | *   |         } else if (delegatedCollateral <= 10000e18) {
 157 | *   |             fl.log("Medium delegated collateral (1000-10000)");
 158 |     |         } else {
 159 | *   |             fl.log("High delegated collateral (>10000)");
 160 |     |         }
 161 |     | 
 162 |     |         // Locked Credit Coverage
 163 | *   |         if (lockedCredit == 0) {
 164 | *   |             fl.log("No locked credit");
 165 | *   |         } else if (lockedCredit <= 1000e18) {
 166 | *   |             fl.log("Low locked credit (0-1000)");
 167 | *   |         } else if (lockedCredit <= 10000e18) {
 168 |     |             fl.log("Medium locked credit (1000-10000)");
 169 |     |         } else {
 170 | *   |             fl.log("High locked credit (>10000)");
 171 |     |         }
 172 |     | 
 173 |     |         // Relationship between delegated collateral and locked credit
 174 | *   |         if (delegatedCollateral > lockedCredit) {
 175 | *   |             fl.log("Delegated collateral exceeds locked credit");
 176 | *   |         } else if (delegatedCollateral < lockedCredit) {
 177 | *   |             fl.log("Locked credit exceeds delegated collateral");
 178 |     |         } else {
 179 |     |             fl.log("Delegated collateral equals locked credit");
 180 |     |         }
 181 |     |     }
 182 |     | 
 183 | *   |     function _logMarginInfoCoverage(
 184 |     |         int256 availableMargin,
 185 |     |         uint256 requiredInitialMargin,
 186 |     |         uint256 requiredMaintenanceMargin,
 187 |     |         uint256 maxLiquidationReward
 188 |     |     ) internal {
 189 |     |         // Available Margin Coverage
 190 | *   |         if (availableMargin < 0) {
 191 | *   |             fl.log("Negative available margin");
 192 | *   |         } else if (availableMargin == 0) {
 193 | *   |             fl.log("Zero available margin");
 194 | *   |         } else if (availableMargin <= 1000e18) {
 195 | *   |             fl.log("Low available margin (0-1000)");
 196 | *   |         } else if (availableMargin <= 10000e18) {
 197 | *   |             fl.log("Medium available margin (1000-10000)");
 198 |     |         } else {
 199 | *   |             fl.log("High available margin (>10000)");
 200 |     |         }
 201 |     | 
 202 |     |         // Required Initial Margin Coverage
 203 | *   |         if (requiredInitialMargin == 0) {
 204 | *   |             fl.log("No required initial margin");
 205 | *   |         } else if (requiredInitialMargin <= 1000e18) {
 206 |     |             fl.log("Low required initial margin (0-1000)");
 207 | *   |         } else if (requiredInitialMargin <= 10000e18) {
 208 | *   |             fl.log("Medium required initial margin (1000-10000)");
 209 |     |         } else {
 210 | *   |             fl.log("High required initial margin (>10000)");
 211 |     |         }
 212 |     | 
 213 |     |         // Required Maintenance Margin Coverage
 214 | *   |         if (requiredMaintenanceMargin == 0) {
 215 | *   |             fl.log("No required maintenance margin");
 216 | *   |         } else if (requiredMaintenanceMargin <= 500e18) {
 217 |     |             fl.log("Low required maintenance margin (0-500)");
 218 | *   |         } else if (requiredMaintenanceMargin <= 5000e18) {
 219 | *   |             fl.log("Medium required maintenance margin (500-5000)");
 220 |     |         } else {
 221 | *   |             fl.log("High required maintenance margin (>5000)");
 222 |     |         }
 223 |     | 
 224 |     |         // Max Liquidation Reward Coverage
 225 | *   |         if (maxLiquidationReward == 0) {
 226 | *   |             fl.log("No max liquidation reward");
 227 |     |         } else if (maxLiquidationReward <= 10e18) {
 228 |     |             fl.log("Low max liquidation reward (0-10)");
 229 | *   |         } else if (maxLiquidationReward <= 100e18) {
 230 |     |             fl.log("Medium max liquidation reward (10-100)");
 231 |     |         } else {
 232 |     |             fl.log("High max liquidation reward (>100)");
 233 |     |         }
 234 |     | 
 235 |     |         // Relationship between margins
 236 | *   |         if (int256(requiredInitialMargin) > availableMargin) {
 237 | *   |             fl.log("Available margin below required initial margin");
 238 | *   |         } else if (int256(requiredMaintenanceMargin) > availableMargin) {
 239 |     |             fl.log("Available margin below required maintenance margin");
 240 |     |         } else {
 241 | *   |             fl.log("Available margin above both required margins");
 242 |     |         }
 243 |     |     }
 244 |     | 
 245 | *   |     function _logReportedDebtGhostCoverage(
 246 |     |         int256 reportedDebtGhost,
 247 |     |         uint256 marketSizeGhost
 248 |     |     ) internal {
 249 |     |         // Reported Debt Ghost Coverage
 250 | *   |         if (reportedDebtGhost == 0) {
 251 | *   |             fl.log("No reported debt ghost");
 252 | *   |         } else if (reportedDebtGhost > 0) {
 253 | *   |             if (reportedDebtGhost <= 1000e18) {
 254 | *   |                 fl.log("Low positive reported debt ghost (0-1000)");
 255 | *   |             } else if (reportedDebtGhost <= 10000e18) {
 256 | *   |                 fl.log("Medium positive reported debt ghost (1000-10000)");
 257 |     |             } else {
 258 | *   |                 fl.log("High positive reported debt ghost (>10000)");
 259 |     |             }
 260 |     |         } else {
 261 | *   |             if (reportedDebtGhost >= -1000e18) {
 262 |     |                 fl.log("Low negative reported debt ghost (0 to -1000)");
 263 | *   |             } else if (reportedDebtGhost >= -10000e18) {
 264 | *   |                 fl.log("Medium negative reported debt ghost (-1000 to -10000)");
 265 |     |             } else {
 266 | *   |                 fl.log("High negative reported debt ghost (<-10000)");
 267 |     |             }
 268 |     |         }
 269 |     | 
 270 |     |         // Market Size Ghost Coverage
 271 | *   |         if (marketSizeGhost == 0) {
 272 | *   |             fl.log("No market size ghost");
 273 | *   |         } else if (marketSizeGhost <= 1000e18) {
 274 | *   |             fl.log("Low market size ghost (0-1000)");
 275 | *   |         } else if (marketSizeGhost <= 10000e18) {
 276 | *   |             fl.log("Medium market size ghost (1000-10000)");
 277 |     |         } else {
 278 |     |             fl.log("High market size ghost (>10000)");
 279 |     |         }
 280 |     | 
 281 |     |         // Relationship between reported debt ghost and market size ghost
 282 | *   |         if (abs(reportedDebtGhost) > int256(marketSizeGhost)) {
 283 | *   |             fl.log("Absolute reported debt ghost exceeds market size ghost");
 284 |     |         } else {
 285 |     |             fl.log("Market size ghost exceeds or equals absolute reported debt ghost");
 286 |     |         }
 287 |     |     }
 288 |     |     // Helper function to get absolute value of int256
 289 | *   |     function abs(int256 x) private pure returns (int256) {
 290 | *   |         return x >= 0 ? x : -x;
 291 |     |     }
 292 |     | }
 293 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/LiquidationCoverage.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   4 |     | 
   5 |     | contract LiquidationCoverage is FuzzBase {
   6 | *   |     function _logLiquidatableCoverage(
   7 |     |         bool isPositionLiquidatable,
   8 |     |         bool isMarginLiquidatable
   9 |     |     ) internal {
  10 | *   |         if (isPositionLiquidatable && isMarginLiquidatable) {
  11 | *   |             fl.log("Both position and margin are liquidatable");
  12 | *   |         } else if (isPositionLiquidatable) {
  13 | *   |             fl.log("Only position is liquidatable");
  14 | *   |         } else if (isMarginLiquidatable) {
  15 |     |             fl.log("Only margin is liquidatable");
  16 |     |         } else {
  17 | *   |             fl.log("Neither position nor margin is liquidatable");
  18 |     |         }
  19 |     |     }
  20 |     | 
  21 | *   |     function _logCollateralIdsCoverage(uint256[] memory collateralIds) internal {
  22 | *   |         if (collateralIds.length == 0) {
  23 | *   |             fl.log("No collateral IDs");
  24 | *   |         } else if (collateralIds.length == 1) {
  25 | *   |             fl.log("One collateral ID");
  26 | *   |         } else if (collateralIds.length == 2) {
  27 | *   |             fl.log("Two collateral IDs");
  28 | *   |         } else if (collateralIds.length == 3) {
  29 | *   |             fl.log("Three collateral IDs");
  30 |     |         } else {
  31 |     |             fl.log("More than three collateral IDs");
  32 |     |         }
  33 |     | 
  34 | *   |         for (uint256 i = 0; i < collateralIds.length; i++) {
  35 | *   |             if (collateralIds[i] == 0) {
  36 | *   |                 fl.log("Collateral ID 0 (SUSD) present");
  37 | *   |             } else if (collateralIds[i] == 1) {
  38 | *   |                 fl.log("Collateral ID 1 (WETH) present");
  39 | *   |             } else if (collateralIds[i] == 2) {
  40 | *   |                 fl.log("Collateral ID 2 (WBTC) present");
  41 |     |             } else {
  42 |     |                 fl.log("Unknown collateral ID present");
  43 |     |             }
  44 |     |         }
  45 |     |     }
  46 |     | 
  47 | *   |     function _logCollateralAmountsCoverage(
  48 |     |         uint256 susdAmount,
  49 |     |         uint256 wethAmount,
  50 |     |         uint256 wbtcAmount,
  51 |     |         uint256 totalValue
  52 |     |     ) internal {
  53 |     |         // SUSD coverage
  54 | *   |         if (susdAmount == 0) {
  55 | *   |             fl.log("No SUSD collateral");
  56 | *   |         } else if (susdAmount > 0 && susdAmount <= 100e18) {
  57 | *   |             fl.log("SUSD collateral between 0 and 100");
  58 | *   |         } else if (susdAmount > 100e18 && susdAmount <= 1000e18) {
  59 |     |             fl.log("SUSD collateral between 100 and 1,000");
  60 | *   |         } else if (susdAmount > 1000e18 && susdAmount <= 10000e18) {
  61 | *   |             fl.log("SUSD collateral between 1,000 and 10,000");
  62 |     |         } else {
  63 | *   |             fl.log("SUSD collateral greater than 10,000");
  64 |     |         }
  65 |     | 
  66 |     |         // WETH coverage
  67 | *   |         if (wethAmount == 0) {
  68 | *   |             fl.log("No WETH collateral");
  69 | *   |         } else if (wethAmount > 0 && wethAmount <= 1e18) {
  70 | *   |             fl.log("WETH collateral between 0 and 1");
  71 | *   |         } else if (wethAmount > 1e18 && wethAmount <= 10e18) {
  72 | *   |             fl.log("WETH collateral between 1 and 10");
  73 | *   |         } else if (wethAmount > 10e18 && wethAmount <= 100e18) {
  74 | *   |             fl.log("WETH collateral between 10 and 100");
  75 |     |         } else {
  76 | *   |             fl.log("WETH collateral greater than 100");
  77 |     |         }
  78 |     | 
  79 |     |         // WBTC coverage (assuming 8 decimal places)
  80 | *   |         if (wbtcAmount == 0) {
  81 | *   |             fl.log("No WBTC collateral");
  82 | *   |         } else if (wbtcAmount > 0 && wbtcAmount <= 1e8) {
  83 | *   |             fl.log("WBTC collateral between 0 and 1");
  84 | *   |         } else if (wbtcAmount > 1e8 && wbtcAmount <= 10e8) {
  85 |     |             fl.log("WBTC collateral between 1 and 10");
  86 | *   |         } else if (wbtcAmount > 10e8 && wbtcAmount <= 100e8) {
  87 | *   |             fl.log("WBTC collateral between 10 and 100");
  88 |     |         } else {
  89 | *   |             fl.log("WBTC collateral greater than 100");
  90 |     |         }
  91 |     | 
  92 |     |         // Total collateral value coverage
  93 | *   |         if (totalValue == 0) {
  94 | *   |             fl.log("Total collateral value is zero");
  95 | *   |         } else if (totalValue > 0 && totalValue <= 100e18) {
  96 | *   |             fl.log("Total collateral value between 0 and 100 ETH");
  97 | *   |         } else if (totalValue > 100e18 && totalValue <= 1000e18) {
  98 | *   |             fl.log("Total collateral value between 100 and 1,000 ETH");
  99 | *   |         } else if (totalValue > 1000e18 && totalValue <= 10000e18) {
 100 | *   |             fl.log("Total collateral value between 1,000 and 10,000 ETH");
 101 | *   |         } else if (totalValue > 10000e18 && totalValue <= 100000e18) {
 102 | *   |             fl.log("Total collateral value between 10,000 and 100,000 ETH");
 103 |     |         } else {
 104 | *   |             fl.log("Total collateral value greater than 100,000 ETH");
 105 |     |         }
 106 |     | 
 107 |     |         // Composition coverage
 108 | *   |         if (susdAmount > 0 && wethAmount > 0 && wbtcAmount > 0) {
 109 | *   |             fl.log("All three collateral types present");
 110 | *   |         } else if (susdAmount > 0 && wethAmount > 0) {
 111 | *   |             fl.log("SUSD and WETH collateral present");
 112 | *   |         } else if (susdAmount > 0 && wbtcAmount > 0) {
 113 | *   |             fl.log("SUSD and WBTC collateral present");
 114 | *   |         } else if (wethAmount > 0 && wbtcAmount > 0) {
 115 | *   |             fl.log("WETH and WBTC collateral present");
 116 | *   |         } else if (susdAmount > 0) {
 117 | *   |             fl.log("Only SUSD collateral present");
 118 | *   |         } else if (wethAmount > 0) {
 119 | *   |             fl.log("Only WETH collateral present");
 120 | *   |         } else if (wbtcAmount > 0) {
 121 | *   |             fl.log("Only WBTC collateral present");
 122 |     |         } else {
 123 | *   |             fl.log("No collateral present");
 124 |     |         }
 125 |     | 
 126 |     |         // Dominant collateral type
 127 | *   |         if (susdAmount > wethAmount && susdAmount > wbtcAmount) {
 128 | *   |             fl.log("SUSD is the dominant collateral type");
 129 | *   |         } else if (wethAmount > susdAmount && wethAmount > wbtcAmount) {
 130 | *   |             fl.log("WETH is the dominant collateral type");
 131 | *   |         } else if (wbtcAmount > susdAmount && wbtcAmount > wethAmount) {
 132 | *   |             fl.log("WBTC is the dominant collateral type");
 133 |     |         } else {
 134 | *   |             fl.log("No single dominant collateral type");
 135 |     |         }
 136 |     |     }
 137 |     | }
 138 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/MarketCoverage.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   4 |     | 
   5 |     | contract MarketCoverage is FuzzBase {
   6 | *   |     function _logMarketInfoCoverage(
   7 |     |         uint256 wethLiquidationCapacity,
   8 |     |         uint256 wbtcLiquidationCapacity,
   9 |     |         uint256 wethMarketSize,
  10 |     |         uint256 wbtcMarketSize
  11 |     |     ) internal {
  12 | *   |         _logWETHMarketCoverage(wethLiquidationCapacity, wethMarketSize);
  13 |     | 
  14 | *   |         _logWBTCMarketCoverage(wbtcLiquidationCapacity, wbtcMarketSize);
  15 |     | 
  16 |     |         // Combined Market Analysis
  17 | *   |         _logCombinedMarketAnalysis(
  18 | *   |             wethLiquidationCapacity,
  19 | *   |             wbtcLiquidationCapacity,
  20 | *   |             wethMarketSize,
  21 | *   |             wbtcMarketSize
  22 |     |         );
  23 |     |     }
  24 |     | 
  25 | *   |     function _logWETHMarketCoverage(
  26 |     |         uint256 liquidationCapacity,
  27 |     |         uint256 marketSize
  28 |     |     ) internal {
  29 |     |         // Liquidation Capacity Coverage for WETH
  30 | *   |         if (liquidationCapacity == 0) {
  31 | *   |             fl.log("WETH market: No liquidation capacity");
  32 | *   |         } else if (liquidationCapacity <= 1e18) {
  33 |     |             fl.log("WETH market: Low liquidation capacity (0-1)");
  34 | *   |         } else if (liquidationCapacity <= 10e18) {
  35 | *   |             fl.log("WETH market: Medium liquidation capacity (1-10)");
  36 | *   |         } else if (liquidationCapacity <= 100e18) {
  37 |     |             fl.log("WETH market: High liquidation capacity (10-100)");
  38 |     |         } else {
  39 |     |             fl.log("WETH market: Very high liquidation capacity (>100)");
  40 |     |         }
  41 |     | 
  42 |     |         // Market Size Coverage for WETH
  43 | *   |         if (marketSize == 0) {
  44 | *   |             fl.log("WETH market: Empty market");
  45 | *   |         } else if (marketSize <= 1000e18) {
  46 | *   |             fl.log("WETH market: Small market size (0-1000)");
  47 |     |         } else if (marketSize <= 10000e18) {
  48 |     |             fl.log("WETH market: Medium market size (1000-10000)");
  49 |     |         } else if (marketSize <= 100000e18) {
  50 |     |             fl.log("WETH market: Large market size (10000-100000)");
  51 |     |         } else {
  52 |     |             fl.log("WETH market: Very large market size (>100000)");
  53 |     |         }
  54 |     |     }
  55 |     | 
  56 | *   |     function _logWBTCMarketCoverage(
  57 |     |         uint256 liquidationCapacity,
  58 |     |         uint256 marketSize
  59 |     |     ) internal {
  60 |     |         // Liquidation Capacity Coverage for WBTC
  61 | *   |         if (liquidationCapacity == 0) {
  62 | *   |             fl.log("WBTC market: No liquidation capacity");
  63 | *   |         } else if (liquidationCapacity <= 1e18) {
  64 |     |             fl.log("WBTC market: Low liquidation capacity (0-1)");
  65 | *   |         } else if (liquidationCapacity <= 10e18) {
  66 | *   |             fl.log("WBTC market: Medium liquidation capacity (1-10)");
  67 | *   |         } else if (liquidationCapacity <= 100e18) {
  68 |     |             fl.log("WBTC market: High liquidation capacity (10-100)");
  69 |     |         } else {
  70 |     |             fl.log("WBTC market: Very high liquidation capacity (>100)");
  71 |     |         }
  72 |     | 
  73 |     |         // Market Size Coverage for WBTC
  74 | *   |         if (marketSize == 0) {
  75 | *   |             fl.log("WBTC market: Empty market");
  76 | *   |         } else if (marketSize <= 1000e18) {
  77 | *   |             fl.log("WBTC market: Small market size (0-1000)");
  78 | *   |         } else if (marketSize <= 10000e18) {
  79 | *   |             fl.log("WBTC market: Medium market size (1000-10000)");
  80 |     |         } else if (marketSize <= 100000e18) {
  81 |     |             fl.log("WBTC market: Large market size (10000-100000)");
  82 |     |         } else {
  83 |     |             fl.log("WBTC market: Very large market size (>100000)");
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 | *   |     function _logCombinedMarketAnalysis(
  88 |     |         uint256 wethLiquidationCapacity,
  89 |     |         uint256 wbtcLiquidationCapacity,
  90 |     |         uint256 wethMarketSize,
  91 |     |         uint256 wbtcMarketSize
  92 |     |     ) internal {
  93 |     |         // Compare liquidation capacities
  94 | *   |         if (wethLiquidationCapacity > wbtcLiquidationCapacity) {
  95 |     |             fl.log("WETH market has higher liquidation capacity");
  96 | *   |         } else if (wbtcLiquidationCapacity > wethLiquidationCapacity) {
  97 |     |             fl.log("WBTC market has higher liquidation capacity");
  98 |     |         } else {
  99 | *   |             fl.log("Both markets have equal liquidation capacity");
 100 |     |         }
 101 |     | 
 102 |     |         // Compare market sizes
 103 | *   |         if (wethMarketSize > wbtcMarketSize) {
 104 | *   |             fl.log("WETH market is larger");
 105 | *   |         } else if (wbtcMarketSize > wethMarketSize) {
 106 | *   |             fl.log("WBTC market is larger");
 107 |     |         } else {
 108 | *   |             fl.log("Both markets are of equal size");
 109 |     |         }
 110 |     | 
 111 |     |         // Analyze total market size
 112 | *   |         uint256 totalMarketSize = uint256(wethMarketSize) +
 113 | *   |             uint256(wbtcMarketSize);
 114 | *   |         if (totalMarketSize == 0) {
 115 | *   |             fl.log("Both markets are empty");
 116 | *   |         } else if (totalMarketSize <= 10000e18) {
 117 | *   |             fl.log("Small total market size across both markets");
 118 |     |         } else if (totalMarketSize <= 100000e18) {
 119 |     |             fl.log("Medium total market size across both markets");
 120 |     |         } else {
 121 |     |             fl.log("Large total market size across both markets");
 122 |     |         }
 123 |     |     }
 124 |     | }
 125 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/OrderCoverage.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   4 |     | 
   5 |     | contract OrderCoverage is FuzzBase {
   6 | *   |     function _logOrderInfoCoverage(
   7 |     |         uint128 debt,
   8 |     |         int128 sizeDelta,
   9 |     |         bool isOrderExpired,
  10 |     |         uint256 fillPriceWETH,
  11 |     |         uint256 fillPriceWBTC,
  12 |     |         uint256 sUSDBalance
  13 |     |     ) internal {
  14 |     |         // Debt coverage
  15 | *   |         if (debt == 0) {
  16 | *   |             fl.log("No debt");
  17 | *   |         } else if (debt > 0 && debt <= 100e18) {
  18 | *   |             fl.log("Debt between 0 and 100");
  19 | *   |         } else if (debt > 100e18 && debt <= 1000e18) {
  20 | *   |             fl.log("Debt between 100 and 1,000");
  21 | *   |         } else if (debt > 1000e18 && debt <= 10000e18) {
  22 | *   |             fl.log("Debt between 1,000 and 10,000");
  23 |     |         } else {
  24 | *   |             fl.log("Debt greater than 10,000");
  25 |     |         }
  26 |     | 
  27 |     |         // Size delta coverage
  28 | *   |         if (sizeDelta == 0) {
  29 | *   |             fl.log("No size delta");
  30 | *   |         } else if (sizeDelta > 0) {
  31 | *   |             if (sizeDelta <= 1e18) {
  32 | *   |                 fl.log("Positive size delta between 0 and 1");
  33 | *   |             } else if (sizeDelta <= 10e18) {
  34 | *   |                 fl.log("Positive size delta between 1 and 10");
  35 |     |             } else {
  36 | *   |                 fl.log("Positive size delta greater than 10");
  37 |     |             }
  38 |     |         } else {
  39 | *   |             if (sizeDelta >= -1e18) {
  40 | *   |                 fl.log("Negative size delta between 0 and -1");
  41 | *   |             } else if (sizeDelta >= -10e18) {
  42 | *   |                 fl.log("Negative size delta between -1 and -10");
  43 |     |             } else {
  44 | *   |                 fl.log("Negative size delta less than -10");
  45 |     |             }
  46 |     |         }
  47 |     | 
  48 |     |         // Order expiration coverage
  49 | *   |         if (isOrderExpired) {
  50 | *   |             fl.log("Order is expired");
  51 |     |         } else {
  52 | *   |             fl.log("Order is not expired");
  53 |     |         }
  54 |     | 
  55 |     |         // Fill price WETH coverage
  56 | *   |         if (fillPriceWETH == 0) {
  57 | *   |             fl.log("No WETH fill price");
  58 | *   |         } else if (fillPriceWETH > 0 && fillPriceWETH <= 1000e18) {
  59 | *   |             fl.log("WETH fill price between 0 and 1,000");
  60 | *   |         } else if (fillPriceWETH > 1000e18 && fillPriceWETH <= 2000e18) {
  61 | *   |             fl.log("WETH fill price between 1,000 and 2,000");
  62 |     |         } else {
  63 | *   |             fl.log("WETH fill price greater than 2,000");
  64 |     |         }
  65 |     | 
  66 |     |         // Fill price WBTC coverage
  67 | *   |         if (fillPriceWBTC == 0) {
  68 | *   |             fl.log("No WBTC fill price");
  69 | *   |         } else if (fillPriceWBTC > 0 && fillPriceWBTC <= 10000e18) {
  70 | *   |             fl.log("WBTC fill price between 0 and 10,000");
  71 | *   |         } else if (fillPriceWBTC > 10000e18 && fillPriceWBTC <= 20000e18) {
  72 | *   |             fl.log("WBTC fill price between 10,000 and 20,000");
  73 |     |         } else {
  74 | *   |             fl.log("WBTC fill price greater than 20,000");
  75 |     |         }
  76 |     | 
  77 |     |         // sUSD balance coverage
  78 | *   |         if (sUSDBalance == 0) {
  79 |     |             fl.log("No sUSD balance");
  80 | *   |         } else if (sUSDBalance > 0 && sUSDBalance <= 100e18) {
  81 |     |             fl.log("sUSD balance between 0 and 100");
  82 | *   |         } else if (sUSDBalance > 100e18 && sUSDBalance <= 1000e18) {
  83 |     |             fl.log("sUSD balance between 100 and 1,000");
  84 | *   |         } else if (sUSDBalance > 1000e18 && sUSDBalance <= 10000e18) {
  85 |     |             fl.log("sUSD balance between 1,000 and 10,000");
  86 |     |         } else {
  87 | *   |             fl.log("sUSD balance greater than 10,000");
  88 |     |         }
  89 |     | 
  90 |     |         // Order type coverage (based on sizeDelta and debt)
  91 | *   |         if (sizeDelta > 0 && debt > 0) {
  92 | *   |             fl.log("Long position with debt");
  93 | *   |         } else if (sizeDelta > 0 && debt == 0) {
  94 | *   |             fl.log("Long position without debt");
  95 | *   |         } else if (sizeDelta < 0 && debt > 0) {
  96 | *   |             fl.log("Short position with debt");
  97 | *   |         } else if (sizeDelta < 0 && debt == 0) {
  98 | *   |             fl.log("Short position without debt");
  99 | *   |         } else if (sizeDelta == 0 && debt > 0) {
 100 | *   |             fl.log("No position but has debt");
 101 |     |         } else {
 102 | *   |             fl.log("No position and no debt");
 103 |     |         }
 104 |     | 
 105 |     |         // Price comparison (if both prices are available)
 106 | *   |         if (fillPriceWETH > 0 && fillPriceWBTC > 0) {
 107 | *   |             if (fillPriceWETH > fillPriceWBTC) {
 108 | *   |                 fl.log("WETH fill price is higher than WBTC fill price");
 109 | *   |             } else if (fillPriceWBTC > fillPriceWETH) {
 110 | *   |                 fl.log("WBTC fill price is higher than WETH fill price");
 111 |     |             } else {
 112 | *   |                 fl.log("WETH and WBTC fill prices are equal");
 113 |     |             }
 114 |     |         }
 115 |     |     }
 116 |     | }
 117 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/logicalCoverage/PositionCoverage.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   4 |     | 
   5 |     | contract PositionCoverage is FuzzBase {
   6 | *   |     function _logPositionInfoCoverage(
   7 |     |         int256 wethTotalPnl,
   8 |     |         int256 wethAccruedFunding,
   9 |     |         int128 wethPositionSize,
  10 |     |         uint256 wethOwedInterest,
  11 |     |         int256 wbtcTotalPnl,
  12 |     |         int256 wbtcAccruedFunding,
  13 |     |         int128 wbtcPositionSize,
  14 |     |         uint256 wbtcOwedInterest
  15 |     |     ) internal {
  16 |     |         // WETH market coverage
  17 | *   |         _logWethMarketCoverage(
  18 | *   |             wethTotalPnl,
  19 | *   |             wethAccruedFunding,
  20 | *   |             wethPositionSize,
  21 | *   |             wethOwedInterest
  22 |     |         );
  23 |     | 
  24 |     |         // WBTC market coverage
  25 | *   |         _logWbtcMarketCoverage(
  26 | *   |             wbtcTotalPnl,
  27 | *   |             wbtcAccruedFunding,
  28 | *   |             wbtcPositionSize,
  29 | *   |             wbtcOwedInterest
  30 |     |         );
  31 |     | 
  32 |     |         // Combined market analysis
  33 | *   |         _logCombinedMarketAnalysis(
  34 | *   |             wethPositionSize,
  35 | *   |             wbtcPositionSize,
  36 | *   |             wethTotalPnl,
  37 | *   |             wbtcTotalPnl,
  38 | *   |             wethOwedInterest,
  39 | *   |             wbtcOwedInterest
  40 |     |         );
  41 |     |     }
  42 |     | 
  43 | *   |     function _logWethMarketCoverage(
  44 |     |         int256 totalPnl,
  45 |     |         int256 accruedFunding,
  46 |     |         int128 positionSize,
  47 |     |         uint256 owedInterest
  48 |     |     ) internal {
  49 |     |         // WETH Position size coverage
  50 | *   |         if (positionSize == 0) {
  51 | *   |             fl.log("WETH market: No open position");
  52 | *   |         } else if (positionSize > 0) {
  53 | *   |             if (positionSize <= 0.1e18) {
  54 | *   |                 fl.log("WETH market: Long position between 0 and 0.1");
  55 | *   |             } else if (positionSize <= 1e18) {
  56 |     |                 fl.log("WETH market: Long position between 0.1 and 1");
  57 | *   |             } else if (positionSize <= 10e18) {
  58 | *   |                 fl.log("WETH market: Long position between 1 and 10");
  59 | *   |             } else if (positionSize <= 100e18) {
  60 | *   |                 fl.log("WETH market: Long position between 10 and 100");
  61 |     |             } else {
  62 |     |                 fl.log("WETH market: Long position greater than 100");
  63 |     |             }
  64 |     |         } else {
  65 | *   |             if (positionSize >= -0.1e18) {
  66 |     |                 fl.log("WETH market: Short position between 0 and -0.1");
  67 | *   |             } else if (positionSize >= -1e18) {
  68 |     |                 fl.log("WETH market: Short position between -0.1 and -1");
  69 | *   |             } else if (positionSize >= -10e18) {
  70 | *   |                 fl.log("WETH market: Short position between -1 and -10");
  71 | *   |             } else if (positionSize >= -100e18) {
  72 |     |                 fl.log("WETH market: Short position between -10 and -100");
  73 |     |             } else {
  74 |     |                 fl.log("WETH market: Short position less than -100");
  75 |     |             }
  76 |     |         }
  77 |     | 
  78 |     |         // WETH Total PnL coverage
  79 | *   |         if (totalPnl == 0) {
  80 | *   |             fl.log("WETH market: Zero PnL");
  81 | *   |         } else if (totalPnl > 0) {
  82 | *   |             if (totalPnl <= 0.1e18) {
  83 | *   |                 fl.log("WETH market: Profit between 0 and 0.1");
  84 | *   |             } else if (totalPnl <= 1e18) {
  85 | *   |                 fl.log("WETH market: Profit between 0.1 and 1");
  86 | *   |             } else if (totalPnl <= 10e18) {
  87 | *   |                 fl.log("WETH market: Profit between 1 and 10");
  88 | *   |             } else if (totalPnl <= 100e18) {
  89 | *   |                 fl.log("WETH market: Profit between 10 and 100");
  90 |     |             } else {
  91 | *   |                 fl.log("WETH market: Profit greater than 100");
  92 |     |             }
  93 |     |         } else {
  94 | *   |             if (totalPnl >= -0.1e18) {
  95 | *   |                 fl.log("WETH market: Loss between 0 and -0.1");
  96 | *   |             } else if (totalPnl >= -1e18) {
  97 | *   |                 fl.log("WETH market: Loss between -0.1 and -1");
  98 | *   |             } else if (totalPnl >= -10e18) {
  99 | *   |                 fl.log("WETH market: Loss between -1 and -10");
 100 | *   |             } else if (totalPnl >= -100e18) {
 101 | *   |                 fl.log("WETH market: Loss between -10 and -100");
 102 |     |             } else {
 103 | *   |                 fl.log("WETH market: Loss less than -100");
 104 |     |             }
 105 |     |         }
 106 |     | 
 107 |     |         // WETH Accrued funding coverage
 108 | *   |         if (accruedFunding == 0) {
 109 | *   |             fl.log("WETH market: No accrued funding");
 110 |     |         } else if (accruedFunding > 0) {
 111 |     |             if (accruedFunding <= 0.01e18) {
 112 |     |                 fl.log(
 113 |     |                     "WETH market: Positive accrued funding between 0 and 0.01"
 114 |     |                 );
 115 |     |             } else if (accruedFunding <= 0.1e18) {
 116 |     |                 fl.log(
 117 |     |                     "WETH market: Positive accrued funding between 0.01 and 0.1"
 118 |     |                 );
 119 |     |             } else if (accruedFunding <= 1e18) {
 120 |     |                 fl.log(
 121 |     |                     "WETH market: Positive accrued funding between 0.1 and 1"
 122 |     |                 );
 123 |     |             } else {
 124 |     |                 fl.log("WETH market: Positive accrued funding greater than 1");
 125 |     |             }
 126 |     |         } else {
 127 |     |             if (accruedFunding >= -0.01e18) {
 128 |     |                 fl.log(
 129 |     |                     "WETH market: Negative accrued funding between 0 and -0.01"
 130 |     |                 );
 131 |     |             } else if (accruedFunding >= -0.1e18) {
 132 |     |                 fl.log(
 133 |     |                     "WETH market: Negative accrued funding between -0.01 and -0.1"
 134 |     |                 );
 135 | *   |             } else if (accruedFunding >= -1e18) {
 136 |     |                 fl.log(
 137 |     |                     "WETH market: Negative accrued funding between -0.1 and -1"
 138 |     |                 );
 139 |     |             } else {
 140 |     |                 fl.log("WETH market: Negative accrued funding less than -1");
 141 |     |             }
 142 |     |         }
 143 |     | 
 144 |     |         // WETH Owed interest coverage
 145 | *   |         if (owedInterest == 0) {
 146 | *   |             fl.log("WETH market: No owed interest");
 147 |     |         } else if (owedInterest <= 0.01e18) {
 148 |     |             fl.log("WETH market: Owed interest between 0 and 0.01");
 149 |     |         } else if (owedInterest <= 0.1e18) {
 150 |     |             fl.log("WETH market: Owed interest between 0.01 and 0.1");
 151 |     |         } else if (owedInterest <= 1e18) {
 152 |     |             fl.log("WETH market: Owed interest between 0.1 and 1");
 153 |     |         } else if (owedInterest <= 10e18) {
 154 |     |             fl.log("WETH market: Owed interest between 1 and 10");
 155 |     |         } else {
 156 |     |             fl.log("WETH market: Owed interest greater than 10");
 157 |     |         }
 158 |     |     }
 159 |     | 
 160 | *   |     function _logWbtcMarketCoverage(
 161 |     |         int256 totalPnl,
 162 |     |         int256 accruedFunding,
 163 |     |         int128 positionSize,
 164 |     |         uint256 owedInterest
 165 |     |     ) internal {
 166 |     |         // WBTC Position size coverage
 167 | *   |         if (positionSize == 0) {
 168 | *   |             fl.log("WBTC market: No open position");
 169 | *   |         } else if (positionSize > 0) {
 170 | *   |             if (positionSize <= 0.01e8) {
 171 | *   |                 fl.log("WBTC market: Long position between 0 and 0.01");
 172 | *   |             } else if (positionSize <= 0.1e8) {
 173 | *   |                 fl.log("WBTC market: Long position between 0.01 and 0.1");
 174 | *   |             } else if (positionSize <= 1e8) {
 175 |     |                 fl.log("WBTC market: Long position between 0.1 and 1");
 176 | *   |             } else if (positionSize <= 10e8) {
 177 |     |                 fl.log("WBTC market: Long position between 1 and 10");
 178 |     |             } else {
 179 | *   |                 fl.log("WBTC market: Long position greater than 10");
 180 |     |             }
 181 |     |         } else {
 182 |     |             if (positionSize >= -0.01e8) {
 183 |     |                 fl.log("WBTC market: Short position between 0 and -0.01");
 184 |     |             } else if (positionSize >= -0.1e8) {
 185 |     |                 fl.log("WBTC market: Short position between -0.01 and -0.1");
 186 |     |             } else if (positionSize >= -1e8) {
 187 |     |                 fl.log("WBTC market: Short position between -0.1 and -1");
 188 | *   |             } else if (positionSize >= -10e8) {
 189 |     |                 fl.log("WBTC market: Short position between -1 and -10");
 190 |     |             } else {
 191 |     |                 fl.log("WBTC market: Short position less than -10");
 192 |     |             }
 193 |     |         }
 194 |     | 
 195 |     |         // WBTC Total PnL coverage
 196 | *   |         if (totalPnl == 0) {
 197 | *   |             fl.log("WBTC market: Zero PnL");
 198 | *   |         } else if (totalPnl > 0) {
 199 | *   |             if (totalPnl <= 0.01e8) {
 200 | *   |                 fl.log("WBTC market: Profit between 0 and 0.01");
 201 | *   |             } else if (totalPnl <= 0.1e8) {
 202 | *   |                 fl.log("WBTC market: Profit between 0.01 and 0.1");
 203 | *   |             } else if (totalPnl <= 1e8) {
 204 | *   |                 fl.log("WBTC market: Profit between 0.1 and 1");
 205 | *   |             } else if (totalPnl <= 10e8) {
 206 | *   |                 fl.log("WBTC market: Profit between 1 and 10");
 207 |     |             } else {
 208 | *   |                 fl.log("WBTC market: Profit greater than 10");
 209 |     |             }
 210 |     |         } else {
 211 | *   |             if (totalPnl >= -0.01e8) {
 212 |     |                 fl.log("WBTC market: Loss between 0 and -0.01");
 213 | *   |             } else if (totalPnl >= -0.1e8) {
 214 | *   |                 fl.log("WBTC market: Loss between -0.01 and -0.1");
 215 | *   |             } else if (totalPnl >= -1e8) {
 216 | *   |                 fl.log("WBTC market: Loss between -0.1 and -1");
 217 | *   |             } else if (totalPnl >= -10e8) {
 218 | *   |                 fl.log("WBTC market: Loss between -1 and -10");
 219 |     |             } else {
 220 | *   |                 fl.log("WBTC market: Loss less than -10");
 221 |     |             }
 222 |     |         }
 223 |     | 
 224 |     |         // WBTC Accrued funding coverage
 225 | *   |         if (accruedFunding == 0) {
 226 | *   |             fl.log("WBTC market: No accrued funding");
 227 |     |         } else if (accruedFunding > 0) {
 228 |     |             if (accruedFunding <= 0.001e8) {
 229 |     |                 fl.log(
 230 |     |                     "WBTC market: Positive accrued funding between 0 and 0.001"
 231 |     |                 );
 232 |     |             } else if (accruedFunding <= 0.01e8) {
 233 |     |                 fl.log(
 234 |     |                     "WBTC market: Positive accrued funding between 0.001 and 0.01"
 235 |     |                 );
 236 |     |             } else if (accruedFunding <= 0.1e8) {
 237 |     |                 fl.log(
 238 |     |                     "WBTC market: Positive accrued funding between 0.01 and 0.1"
 239 |     |                 );
 240 |     |             } else {
 241 |     |                 fl.log(
 242 |     |                     "WBTC market: Positive accrued funding greater than 0.1"
 243 |     |                 );
 244 |     |             }
 245 |     |         } else {
 246 |     |             if (accruedFunding >= -0.001e8) {
 247 |     |                 fl.log(
 248 |     |                     "WBTC market: Negative accrued funding between 0 and -0.001"
 249 |     |                 );
 250 |     |             } else if (accruedFunding >= -0.01e8) {
 251 |     |                 fl.log(
 252 |     |                     "WBTC market: Negative accrued funding between -0.001 and -0.01"
 253 |     |                 );
 254 | *   |             } else if (accruedFunding >= -0.1e8) {
 255 |     |                 fl.log(
 256 |     |                     "WBTC market: Negative accrued funding between -0.01 and -0.1"
 257 |     |                 );
 258 |     |             } else {
 259 |     |                 fl.log("WBTC market: Negative accrued funding less than -0.1");
 260 |     |             }
 261 |     |         }
 262 |     | 
 263 |     |         // WBTC Owed interest coverage
 264 | *   |         if (owedInterest == 0) {
 265 | *   |             fl.log("WBTC market: No owed interest");
 266 |     |         } else if (owedInterest <= 0.001e8) {
 267 |     |             fl.log("WBTC market: Owed interest between 0 and 0.001");
 268 |     |         } else if (owedInterest <= 0.01e8) {
 269 |     |             fl.log("WBTC market: Owed interest between 0.001 and 0.01");
 270 |     |         } else if (owedInterest <= 0.1e8) {
 271 |     |             fl.log("WBTC market: Owed interest between 0.01 and 0.1");
 272 |     |         } else if (owedInterest <= 1e8) {
 273 |     |             fl.log("WBTC market: Owed interest between 0.1 and 1");
 274 |     |         } else {
 275 |     |             fl.log("WBTC market: Owed interest greater than 1");
 276 |     |         }
 277 |     |     }
 278 |     | 
 279 | *   |     function _logCombinedMarketAnalysis(
 280 |     |         int128 wethPositionSize,
 281 |     |         int128 wbtcPositionSize,
 282 |     |         int256 wethTotalPnl,
 283 |     |         int256 wbtcTotalPnl,
 284 |     |         uint256 wethOwedInterest,
 285 |     |         uint256 wbtcOwedInterest
 286 |     |     ) internal {
 287 | *   |         if (wethPositionSize != 0 && wbtcPositionSize != 0) {
 288 | *   |             fl.log("Positions open in both WETH and WBTC markets");
 289 | *   |             if (
 290 | *   |                 (wethPositionSize > 0 && wbtcPositionSize > 0) ||
 291 | *   |                 (wethPositionSize < 0 && wbtcPositionSize < 0)
 292 |     |             ) {
 293 | *   |                 fl.log("Both positions are in the same direction");
 294 |     |             } else {
 295 | *   |                 fl.log("Positions are in opposite directions");
 296 |     |             }
 297 | *   |         } else if (wethPositionSize != 0) {
 298 | *   |             fl.log("Position open only in WETH market");
 299 | *   |         } else if (wbtcPositionSize != 0) {
 300 | *   |             fl.log("Position open only in WBTC market");
 301 |     |         } else {
 302 | *   |             fl.log("No open positions in either market");
 303 |     |         }
 304 |     | 
 305 |     |         // Total PnL analysis
 306 | *   |         int256 totalPnl = wethTotalPnl + wbtcTotalPnl;
 307 | *   |         if (totalPnl > 0) {
 308 | *   |             fl.log("Overall position is profitable");
 309 | *   |             if (wethTotalPnl > 0 && wbtcTotalPnl > 0) {
 310 | *   |                 fl.log("Both markets are profitable");
 311 |     |             } else {
 312 | *   |                 fl.log("One market is profitable, the other is at a loss");
 313 |     |             }
 314 | *   |         } else if (totalPnl < 0) {
 315 | *   |             fl.log("Overall position is at a loss");
 316 | *   |             if (wethTotalPnl < 0 && wbtcTotalPnl < 0) {
 317 | *   |                 fl.log("Both markets are at a loss");
 318 |     |             } else {
 319 | *   |                 fl.log("One market is at a loss, the other is profitable");
 320 |     |             }
 321 |     |         } else {
 322 | *   |             fl.log("Overall position has zero PnL");
 323 |     |         }
 324 |     | 
 325 |     |         // Total owed interest analysis
 326 |     |         // Total owed interest analysis
 327 | *   |         uint256 totalOwedInterest = wethOwedInterest + wbtcOwedInterest;
 328 | *   |         if (totalOwedInterest == 0) {
 329 | *   |             fl.log("No owed interest in either market");
 330 |     |         } else {
 331 |     |             fl.log("Owed interest present");
 332 |     |             if (wethOwedInterest > 0 && wbtcOwedInterest > 0) {
 333 |     |                 fl.log("Both markets have owed interest");
 334 |     |             } else if (wethOwedInterest > 0) {
 335 |     |                 fl.log("Only WETH market has owed interest");
 336 |     |             } else {
 337 |     |                 fl.log("Only WBTC market has owed interest");
 338 |     |             }
 339 |     | 
 340 |     |             if (totalOwedInterest <= 0.01e18) {
 341 |     |                 fl.log("Total owed interest between 0 and 0.01");
 342 |     |             } else if (totalOwedInterest <= 0.1e18) {
 343 |     |                 fl.log("Total owed interest between 0.01 and 0.1");
 344 |     |             } else if (totalOwedInterest <= 1e18) {
 345 |     |                 fl.log("Total owed interest between 0.1 and 1");
 346 |     |             } else if (totalOwedInterest <= 10e18) {
 347 |     |                 fl.log("Total owed interest between 1 and 10");
 348 |     |             } else {
 349 |     |                 fl.log("Total owed interest greater than 10");
 350 |     |             }
 351 |     | 
 352 |     |             if (wethOwedInterest > wbtcOwedInterest) {
 353 |     |                 fl.log("WETH market has higher owed interest");
 354 | *   |             } else if (wbtcOwedInterest > wethOwedInterest) {
 355 |     |                 fl.log("WBTC market has higher owed interest");
 356 |     |             } else {
 357 |     |                 fl.log("Both markets have equal owed interest");
 358 |     |             }
 359 |     |         }
 360 |     | 
 361 |     |         // Position size comparison
 362 | *   |         if (wethPositionSize != 0 && wbtcPositionSize != 0) {
 363 | *   |             if (abs(wethPositionSize) > abs(wbtcPositionSize)) {
 364 | *   |                 fl.log("WETH position size is larger");
 365 | *   |             } else if (abs(wbtcPositionSize) > abs(wethPositionSize)) {
 366 | *   |                 fl.log("WBTC position size is larger");
 367 |     |             } else {
 368 |     |                 fl.log("Both positions have equal size");
 369 |     |             }
 370 |     |         }
 371 |     | 
 372 |     |         // PnL comparison
 373 | *   |         if (wethTotalPnl != 0 || wbtcTotalPnl != 0) {
 374 | *   |             if (wethTotalPnl > wbtcTotalPnl) {
 375 | *   |                 fl.log("WETH market has higher PnL");
 376 | *   |             } else if (wbtcTotalPnl > wethTotalPnl) {
 377 | *   |                 fl.log("WBTC market has higher PnL");
 378 |     |             } else {
 379 |     |                 fl.log("Both markets have equal PnL");
 380 |     |             }
 381 |     |         }
 382 |     | 
 383 |     |         // Overall market status
 384 | *   |         if (
 385 | *   |             wethPositionSize == 0 &&
 386 | *   |             wbtcPositionSize == 0 &&
 387 | *   |             totalOwedInterest == 0
 388 |     |         ) {
 389 | *   |             fl.log("No active positions or owed interest in either market");
 390 | *   |         } else if (wethPositionSize != 0 || wbtcPositionSize != 0) {
 391 | *   |             if (totalPnl > 0 && totalOwedInterest == 0) {
 392 | *   |                 fl.log("Profitable position(s) with no owed interest");
 393 | *   |             } else if (totalPnl > 0 && totalOwedInterest > 0) {
 394 |     |                 fl.log("Profitable position(s) with owed interest");
 395 | *   |             } else if (totalPnl < 0 && totalOwedInterest == 0) {
 396 | *   |                 fl.log("Loss-making position(s) with no owed interest");
 397 | *   |             } else if (totalPnl < 0 && totalOwedInterest > 0) {
 398 |     |                 fl.log("Loss-making position(s) with owed interest");
 399 | *   |             } else if (totalPnl == 0 && totalOwedInterest > 0) {
 400 |     |                 fl.log("Neutral position(s) with owed interest");
 401 |     |             } else {
 402 | *   |                 fl.log("Neutral position(s) with no owed interest");
 403 |     |             }
 404 |     |         } else {
 405 |     |             fl.log("No active positions but owed interest present");
 406 |     |         }
 407 |     |     }
 408 |     | 
 409 |     |     // Helper function to get absolute value of int128
 410 | *   |     function abs(int128 x) private pure returns (int128) {
 411 | *   |         return x >= 0 ? x : -x;
 412 |     |     }
 413 |     | }
 414 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsAdmin.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | abstract contract PostconditionsAdmin is PostconditionsBase {
  7 |     |     /// NOTE: changes chainlink price to correspond to pyth price
  8 | *   |     function changePythPricePostconditions(bytes32 nodeId, int256 newPrice) internal {
  9 | *   |         int256 newPriceWithPrecision = int256(newPrice); //TODO: recheck //* 1e10; // account for 1e18 precision in chainlink oracle
 10 | *   |         bytes32 chainlinkNodeId = oracleNodes[nodeId];
 11 |     | 
 12 | *   |         bool isIncrease = newPrice % 2 == 0;
 13 |     | 
 14 |     |         // only change the chainlink oracle price for index tokens
 15 | *   |         if (chainlinkNodeId != bytes32(0)) {
 16 | *   |             int256 newPriceWithVariance;
 17 | *   |             int256 priceDivergenceBps = fl.clamp(newPrice, 0, PRICE_DIVERGENCE_BPS_256);
 18 | *   |             if (isIncrease) {
 19 | *   |                 newPriceWithVariance = (newPrice * (priceDivergenceBps + INT_ONE_HUNDRED_BP)) / INT_ONE_HUNDRED_BP;
 20 |     |             }
 21 |     |             else {
 22 | *   |                 newPriceWithVariance = (newPrice * (INT_ONE_HUNDRED_BP - priceDivergenceBps)) / INT_ONE_HUNDRED_BP;
 23 |     |             }
 24 | *   |             mockOracleManager.changePrice(chainlinkNodeId, newPriceWithVariance);
 25 |     |         }
 26 |     |     }
 27 |     | 
 28 |     |     /// @notice changes pyth price to correspond to chainlink price
 29 | *   |     function changeOracleManagerPricePostconditions(bytes32 nodeId, int256 newPrice) internal {
 30 | *   |         bytes32 pythNodeId = oracleNodes[nodeId];
 31 |     | 
 32 | *   |         bool isIncrease = newPrice % 2 == 0;
 33 |     | 
 34 |     |         // only change the pyth oracle price for index tokens
 35 | *   |         if (pythNodeId != bytes32(0)) {
 36 | *   |             int256 newPriceWithVariance;
 37 | *   |             int256 priceDivergenceBps = fl.clamp(newPrice, 0, PRICE_DIVERGENCE_BPS_256);
 38 | *   |             if (isIncrease) {
 39 | *   |                 newPriceWithVariance = (newPrice * (priceDivergenceBps + INT_ONE_HUNDRED_BP)) / INT_ONE_HUNDRED_BP;
 40 |     |             }
 41 |     |             else {
 42 | *   |                 newPriceWithVariance = (newPrice * (INT_ONE_HUNDRED_BP - priceDivergenceBps)) / INT_ONE_HUNDRED_BP;
 43 |     |             }
 44 | *   |             mockPyth.changePrice(pythNodeId, int64(newPriceWithVariance));
 45 | *   |             pythWrapper.setBenchmarkPrice(pythNodeId, newPriceWithVariance);
 46 |     |         }
 47 |     |     }
 48 |     | }
 49 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsBase.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../../properties/Properties.sol";
  5 |     | 
  6 |     | abstract contract PostconditionsBase is Properties {
  7 | *   |     function onSuccessInvariantsGeneral(
  8 |     |         bytes memory returnData,
  9 |     |         uint128 account
 10 |     |     ) internal {
 11 | *   |         fl.log(">>ACCOUNT FOR onSuccessInvariantsGeneral", account);
 12 | *   |         invariant_LIQ_01(account);
 13 |     |         // @audit Review this assertion for perps market.
 14 |     |         // invariant_ORD_11();
 15 |     |         // invariant_MGN_08(); //TODO: percEq
 16 | *   |         invariant_ORD_19(account);
 17 |     |     }
 18 |     | 
 19 |     |     function onFailInvariantsGeneral(bytes memory returnData) internal {}
 20 |     | }
 21 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsLiquidationModule.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | abstract contract PostconditionsLiquidationModule is PostconditionsBase {
  7 |     |     function liquidatePositionPostconditions(
  8 |     |         bool success,
  9 |     |         bytes memory returnData,
 10 |     |         address[] memory actorsToUpdate,
 11 |     |         address flaggedUser,
 12 |     |         address liquidator,
 13 |     |         uint128 accountIds
 14 |     |     ) internal {
 15 | *   |         if (success) {
 16 |     |             _after(actorsToUpdate);
 17 |     |             // invariant_LIQ_03();
 18 |     |             // @audit-ok This assertion is supposed to fail to show a user can be liquidated in such a scenario.
 19 |     |             // invariant_LIQ_08();
 20 |     |             invariant_LIQ_09(accountIds);
 21 |     |             invariant_LIQ_11(accountIds);
 22 | *   |             onSuccessInvariantsGeneral(returnData, accountIds);
 23 |     |         } else {
 24 |     |             onFailInvariantsGeneral(returnData);
 25 |     |         }
 26 |     |     }
 27 |     | 
 28 | *   |     function liquidateMarginOnlyPostconditions(
 29 |     |         bool success,
 30 |     |         bytes memory returnData,
 31 |     |         address[] memory actorsToUpdate,
 32 |     |         address flaggedUser,
 33 |     |         uint128 accountId
 34 |     |     ) internal {
 35 | *   |         if (success) {
 36 | *   |             _after(actorsToUpdate);
 37 | *   |             onSuccessInvariantsGeneral(returnData, accountId);
 38 |     |         } else {
 39 |     |             onFailInvariantsGeneral(returnData);
 40 |     |         }
 41 |     |     }
 42 |     | 
 43 |     |     function liquidateFlaggedPostconditions(
 44 |     |         bool success,
 45 |     |         bytes memory returnData,
 46 |     |         address[] memory actorsToUpdate,
 47 |     |         uint[] memory flaggedAccounts
 48 |     |     ) internal {
 49 | *   |         if (success) {
 50 |     |             _after(actorsToUpdate);
 51 |     |             for (uint i = 0; i < flaggedAccounts.length; i++) {
 52 |     |                 onSuccessInvariantsGeneral(
 53 |     |                     returnData,
 54 |     |                     uint128(flaggedAccounts[i])
 55 |     |                 );
 56 |     |             }
 57 |     |         } else {
 58 | *   |             onFailInvariantsGeneral(returnData);
 59 |     |         }
 60 |     |     }
 61 |     | 
 62 |     |     function luquidateFlaggedAccountsPostconditions(
 63 |     |         bool success,
 64 |     |         bytes memory returnData,
 65 |     |         address[] memory actorsToUpdate,
 66 |     |         uint[] memory flaggedAccounts
 67 |     |     ) internal {
 68 |     |         if (success) {
 69 |     |             _after(actorsToUpdate);
 70 |     |             for (uint i = 0; i < flaggedAccounts.length; i++) {
 71 |     |                 onSuccessInvariantsGeneral(
 72 |     |                     returnData,
 73 |     |                     uint128(flaggedAccounts[i])
 74 |     |                 );
 75 |     |             }
 76 |     |         } else {
 77 |     |             onFailInvariantsGeneral(returnData);
 78 |     |         }
 79 |     |     }
 80 |     | }
 81 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsOrderModule.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | abstract contract PostconditionsOrderModule is PostconditionsBase {
  7 | *   |     function commitOrderPostconditions(
  8 |     |         bool success,
  9 |     |         bytes memory returnData,
 10 |     |         address[] memory actorsToUpdate,
 11 |     |         uint128 accountId,
 12 |     |         uint128 commitOrderPostconditions
 13 |     |     ) internal {
 14 | *   |         if (success) {
 15 | *   |             _after(actorsToUpdate);
 16 | *   |             invariant_ORD_01(accountId);
 17 | *   |             invariant_ORD_15(accountId);
 18 | *   |             onSuccessInvariantsGeneral(returnData, accountId);
 19 |     |         } else {
 20 |     |             onFailInvariantsGeneral(returnData);
 21 |     |         }
 22 |     |     }
 23 |     | 
 24 |     |     //TODO: after settle
 25 |     | 
 26 | *   |     function settleOrderPostconditions(
 27 |     |         bool success,
 28 |     |         bytes memory returnData,
 29 |     |         address[] memory actorsToUpdate,
 30 |     |         address settleUser,
 31 |     |         uint128 accountId,
 32 |     |         uint128 marketId
 33 |     |     ) internal {
 34 | *   |         if (success) {
 35 | *   |             _after(actorsToUpdate);
 36 |     | 
 37 | *   |             invariant_ORD_02(accountId);
 38 |     |             // invariant_ORD_03(accountId);
 39 |     |             // TODO: This assertion was failing due to Foundry using default sender. Default sender 0x18 did not have an account, so balance was always 0.
 40 |     |             // modifier setCurrentActor was modified, but should be given another look to prevent Foundry override.
 41 |     |             // fl.log("CURRENT ACTOR ACCOUNT ID SETTLE:", userToAccountIds[currentActor]);
 42 |     |             // fl.log("CURRENT ACTOR SETTLE:", currentActor);
 43 | *   |             invariant_ORD_04(userToAccountIds[currentActor]);
 44 |     |             // @audit ORD-06 assertion fails. Looks like a valid break.
 45 |     |             // invariant_ORD_06(accountId, marketId);
 46 |     |             // @audit ORD-07 assertion fails. Looks like a valid break.
 47 |     |             // invariant_ORD_07();
 48 | *   |             invariant_ORD_08(accountId);
 49 |     |             // TODO: Properly handle markets for this invariant. BeforeAfter changes required.
 50 | *   |             invariant_ORD_09(accountId, marketId);
 51 | *   |             invariant_ORD_12(accountId);
 52 |     |             // invariant_ORD_18(accountId, marketId); //TODO:
 53 |     | 
 54 | *   |             onSuccessInvariantsGeneral(returnData, accountId);
 55 |     |         } else {
 56 |     |             onFailInvariantsGeneral(returnData);
 57 |     |         }
 58 |     |     }
 59 |     | 
 60 | *   |     function cancelOrderPostconditions(
 61 |     |         bool success,
 62 |     |         bytes memory returnData,
 63 |     |         address[] memory actorsToUpdate,
 64 |     |         address cancelUser,
 65 |     |         uint128 accountId
 66 |     |     ) internal {
 67 | *   |         if (success) {
 68 |     |             _after(actorsToUpdate);
 69 |     |             if (cancelUser != currentActor) {
 70 |     |                 // @audit This assertion fails.
 71 |     |                 invariant_ORD_05(userToAccountIds[currentActor]);
 72 |     |             }
 73 |     |             // @audit ORD-16 assertion fails. Looks like valid break.
 74 |     |             // invariant_ORD_16(userToAccountIds[cancelUser]);
 75 |     |             onSuccessInvariantsGeneral(returnData, accountId);
 76 |     |         } else {
 77 |     |             onFailInvariantsGeneral(returnData);
 78 |     |         }
 79 |     |     }
 80 |     | }
 81 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/postconditions/PostconditionsPerpsAccountModule.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | abstract contract PostconditionsPerpsAccountModule is PostconditionsBase {
  7 |     |     event DebugPost(string s);
  8 | *   |     function modifyCollateralPostconditions(
  9 |     |         int256 amountDelta,
 10 |     |         bool success,
 11 |     |         bytes memory returnData,
 12 |     |         address[] memory actorsToUpdate,
 13 |     |         address collateral,
 14 |     |         uint128 accountId
 15 | *   |     ) internal {
 16 | *   |         uint collateralId = collateral == address(wethTokenMock)
 17 | *   |             ? 1
 18 | *   |             : collateral == address(wbtcTokenMock)
 19 | *   |                 ? 2
 20 | *   |                 : 0; //SUSD
 21 |     | 
 22 | *   |         if (success) {
 23 | *   |             emit DebugPost("modifyCollateralPostconditions HERE#1");
 24 | *   |             _after(actorsToUpdate);
 25 | *   |             emit DebugPost("modifyCollateralPostconditions HERE#2");
 26 |     | 
 27 | *   |             if (amountDelta < 0) {
 28 |     |                 invariant_MGN_01(accountId);
 29 |     |                 invariant_MGN_12(accountId, collateralId);
 30 | *   |                 invariant_MGN_13(amountDelta, collateral);
 31 |     |             }
 32 | *   |             emit DebugPost("modifyCollateralPostconditions HERE#3");
 33 | *   |             invariant_MGN_03(accountId);
 34 | *   |             invariant_MGN_04(accountId);
 35 | *   |             invariant_MGN_05(amountDelta, collateral);
 36 | *   |             invariant_MGN_06(amountDelta, collateral);
 37 | *   |             invariant_MGN_13(amountDelta, collateral);
 38 |     | 
 39 | *   |             emit DebugPost("modifyCollateralPostconditions HERE#MGN_13");
 40 |     | 
 41 |     |             // invariant_MGN_07();
 42 |     | 
 43 | *   |             onSuccessInvariantsGeneral(returnData, accountId);
 44 | *   |             emit DebugPost("modifyCollateralPostconditions HERE#4");
 45 |     |         } else {
 46 |     |             onFailInvariantsGeneral(returnData);
 47 |     |         }
 48 |     |     }
 49 |     | 
 50 | *   |     function payDebtPostconditions(
 51 |     |         bool success,
 52 |     |         bytes memory returnData,
 53 |     |         address[] memory actorsToUpdate,
 54 |     |         uint128 accountId
 55 |     |     ) internal {
 56 | *   |         if (success) {
 57 | *   |             _after(actorsToUpdate);
 58 |     |             // invariant_MGN_07();
 59 | *   |             onSuccessInvariantsGeneral(returnData, accountId);
 60 |     |         } else {
 61 |     |             onFailInvariantsGeneral(returnData);
 62 |     |         }
 63 |     |     }
 64 |     | }
 65 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsAdmin.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PreconditionsBase.sol";
   5 |     | 
   6 |     | abstract contract PreconditionsAdmin is PreconditionsBase {
   7 |     |     struct ChangePythPriceParams {
   8 |     |         int256 newPrice;
   9 |     |         bytes32 id;
  10 |     |     }
  11 | *   |     function mintUSDToSynthetixPreconditions(uint256 amount) internal returns (uint256) {
  12 | *   |         uint256 currentBalance = sUSDTokenMock.balanceOf(address(v3Mock));
  13 | *   |         if (currentBalance == 0) return amount;
  14 |     |         return
  15 | *   |             fl.clamp(
  16 | *   |                 amount,
  17 |     |                 1,
  18 | *   |                 (currentBalance * UINT_MAX_SYNTHETIX_USD_CHANGE_BP) / UINT_ONE_HUNDRED_BP
  19 |     |             );
  20 |     |     }
  21 |     | 
  22 | *   |     function burnUSDFromSynthetixPreconditions(uint256 amount) internal returns (uint256) {
  23 | *   |         uint256 currentBalance = sUSDTokenMock.balanceOf(address(v3Mock));
  24 | *   |         return
  25 | *r  |             fl.clamp(
  26 | *   |                 amount,
  27 |     |                 1,
  28 | *   |                 (currentBalance * UINT_MAX_SYNTHETIX_USD_CHANGE_BP) / UINT_ONE_HUNDRED_BP
  29 |     |             );
  30 |     |     }
  31 |     |     event DebugPricePre(int256 p, string s);
  32 |     | 
  33 | *   |     function changeOracleManagerPricePreconditions(
  34 |     |         uint256 nodeIndex,
  35 |     |         int256 newPrice
  36 | *   |     ) internal returns (int256 clampedPrice, bytes32 nodeId) {
  37 |     |         // clamp nodeId to one of the active collaterals, ignores sUSD node to keep it constant
  38 | *   |         nodeId = _getRandomNodeId(nodeIndex);
  39 |     | 
  40 | *   |         int256 currentPrice = mockOracleManager.process(nodeId).price;
  41 |     | 
  42 | *   |         int256 minBound = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /
  43 |     |             INT_ONE_HUNDRED_BP; // -20%
  44 | *   |         int256 maxBound = (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) /
  45 |     |             INT_ONE_HUNDRED_BP; // +20%
  46 |     | 
  47 | *   |         if (minBound < 500e18) {
  48 | *   |             minBound = 500e18; // min ETH price $500
  49 |     |         }
  50 |     | 
  51 | *   |         if (maxBound < minBound) {
  52 | *   |             maxBound = minBound;
  53 |     |         }
  54 |     | 
  55 | *r  |         clampedPrice = fl.clamp(newPrice, minBound, maxBound);
  56 |     |     }
  57 |     | 
  58 | *   |     function changeWETHPythPricePreconditions(
  59 |     |         int64 newPrice
  60 |     |     ) internal returns (ChangePythPriceParams memory) {
  61 | *   |         int256 currentPrice = pythWrapper.getBenchmarkPrice(
  62 |     |             WETH_FEED_ID,
  63 |     |             0 //uint64 requestedTime, irrelevant for mock
  64 |     |         );
  65 |     | 
  66 | *   |         int256 minBound = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /
  67 |     |             INT_ONE_HUNDRED_BP; // -20%
  68 | *   |         int256 maxBound = (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) /
  69 |     |             INT_ONE_HUNDRED_BP; // +20%
  70 |     | 
  71 | *   |         if (minBound < 500e18) {
  72 | *   |             minBound = 500e18; // min ETH price $500
  73 |     |         }
  74 |     | 
  75 | *   |         if (maxBound < minBound) {
  76 |     |             maxBound = minBound;
  77 |     |         }
  78 |     | 
  79 | *   |         int clampedPrice = fl.clamp(newPrice, minBound, maxBound);
  80 |     | 
  81 | *   |         fl.log("changeWETHPythPricePreconditions::newPrice", clampedPrice);
  82 |     | 
  83 | *   |         return ChangePythPriceParams({newPrice: clampedPrice, id: WETH_FEED_ID});
  84 |     |     }
  85 |     | 
  86 | *   |     function changeWBTCPythPricePreconditions(
  87 |     |         int64 newPrice
  88 |     |     ) internal returns (ChangePythPriceParams memory) {
  89 | *   |         int256 currentPrice = pythWrapper.getBenchmarkPrice(WBTC_FEED_ID, 0);
  90 | *   |         emit DebugPricing(currentPrice, "CURRENT PRICE");
  91 |     | 
  92 | *   |         int256 minBound = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /
  93 |     |             INT_ONE_HUNDRED_BP; // -20%
  94 | *   |         int256 maxBound = (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) /
  95 |     |             INT_ONE_HUNDRED_BP; // +20%
  96 |     | 
  97 | *   |         if (minBound < 500e18) {
  98 | *   |             minBound = 500e18; // min WBTC price $500
  99 |     |         }
 100 |     | 
 101 | *   |         if (maxBound < minBound) {
 102 |     |             maxBound = minBound;
 103 |     |         }
 104 |     | 
 105 | *   |         int clampedPrice = fl.clamp(newPrice, minBound, maxBound);
 106 |     | 
 107 | *   |         fl.log("changeWBTCPythPricePreconditions::newPrice", clampedPrice);
 108 |     | 
 109 | *   |         return ChangePythPriceParams({newPrice: clampedPrice, id: WBTC_FEED_ID});
 110 |     |     }
 111 |     | 
 112 | *   |     function crashWETHPythPricePreconditions() internal returns (ChangePythPriceParams memory) {
 113 | *   |         int256 currentPrice = pythWrapper.getBenchmarkPrice(WETH_FEED_ID, 0);
 114 |     | 
 115 | *   |         int256 newPrice = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /
 116 |     |             INT_ONE_HUNDRED_BP;
 117 | *   |         int256 clampedPrice = newPrice < int(500e18) ? int(500e18) : newPrice;
 118 |     | 
 119 | *   |         return ChangePythPriceParams({newPrice: clampedPrice, id: WETH_FEED_ID});
 120 |     |     }
 121 |     | 
 122 | *   |     function pumpWETHPythPricePreconditions() internal returns (ChangePythPriceParams memory) {
 123 | *   |         int256 currentPrice = pythWrapper.getBenchmarkPrice(
 124 |     |             WETH_FEED_ID,
 125 |     |             0 //uint64 requestedTime, irrelevant for mock
 126 |     |         );
 127 |     | 
 128 | *   |         return
 129 | *   |             ChangePythPriceParams({
 130 |     |                 newPrice: int256(
 131 | *   |                     (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) / INT_ONE_HUNDRED_BP
 132 |     |                 ),
 133 |     |                 id: WETH_FEED_ID
 134 |     |             });
 135 |     |     }
 136 |     | 
 137 |     |     event DebugPricing(int256 p, string s);
 138 | *   |     function crashWBTCPythPricePreconditions() internal returns (ChangePythPriceParams memory) {
 139 | *   |         int256 currentPrice = pythWrapper.getBenchmarkPrice(WBTC_FEED_ID, 0);
 140 |     | 
 141 | *   |         int256 newPrice = (currentPrice * (INT_ONE_HUNDRED_BP - INT_MAX_CHANGE_BP)) /
 142 |     |             INT_ONE_HUNDRED_BP;
 143 | *   |         int256 clampedPrice = newPrice < int(500e18) ? int(500e18) : newPrice;
 144 |     | 
 145 | *   |         return ChangePythPriceParams({newPrice: clampedPrice, id: WBTC_FEED_ID});
 146 |     |     }
 147 |     | 
 148 | *   |     function pumpWBTCPythPricePreconditions() internal returns (ChangePythPriceParams memory) {
 149 | *   |         int256 currentPrice = pythWrapper.getBenchmarkPrice(
 150 |     |             WBTC_FEED_ID,
 151 |     |             0 //uint64 requestedTime, irrelevant for mock
 152 |     |         );
 153 |     | 
 154 | *   |         return
 155 | *   |             ChangePythPriceParams({
 156 |     |                 newPrice: int256(
 157 | *   |                     (currentPrice * (INT_ONE_HUNDRED_BP + INT_MAX_CHANGE_BP)) / INT_ONE_HUNDRED_BP
 158 |     |                 ),
 159 |     |                 id: WBTC_FEED_ID
 160 |     |             });
 161 |     |     }
 162 |     | 
 163 | *   |     function delegateCollateralPreconditions(
 164 |     |         uint256 newCollateralAmountD18,
 165 |     |         uint256 collateralTokenIndex
 166 |     |     )
 167 |     |         internal
 168 | *   |         returns (uint256 clampedNewCollateralAmountD18, address collateralToken, uint128 marketId)
 169 |     |     {
 170 | *   |         clampedNewCollateralAmountD18 = fl.clamp(newCollateralAmountD18, 1, 100_000_000);
 171 | *   |         collateralToken = _getRandomCollateralToken(collateralTokenIndex);
 172 | *   |         marketId = collateralTokenIndex % 2 == 0 ? 1 : 2;
 173 |     |     }
 174 |     | 
 175 |     |     function max(int256 x, int256 y) internal pure returns (int256) {
 176 |     |         return x < y ? y : x;
 177 |     |     }
 178 |     | 
 179 |     |     function max(uint256 x, uint256 y) internal pure returns (uint256) {
 180 |     |         return x < y ? y : x;
 181 |     |     }
 182 |     | }
 183 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsBase.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../../util/FunctionCalls.sol";
  5 |     | import "../BeforeAfter.sol";
  6 |     | 
  7 |     | abstract contract PreconditionsBase is FunctionCalls, BeforeAfter {
  8 |     |     modifier setCurrentActor() {
  9 |     |         // if (_setActor) {
 10 |     |         //     currentActor = checkCaller.checkCaller();
 11 |     |         // }
 12 |     |         // if (isFoundry) {
 13 |     |         //     // fl.log("IS FOUNDRY"); <--this emit break vm.prank()
 14 |     |         //     if (_setActor) {
 15 |     |         //         currentActor = checkCaller.checkCaller();
 16 |     |         //     }
 17 |     |         // } else {
 18 |     |         //     fl.log("NOT IS FOUNDRY");
 19 |     | 
 20 | *   |         if (_setActor) {
 21 |     |             // require(guidedDone);
 22 | *   |             currentActor = USERS[block.timestamp % (USERS.length)];
 23 |     |             // currentActor = msg.sender;
 24 | *   |             fl.log("================================");
 25 | *   |             fl.log("CURRENT MSG>SENDRR:", msg.sender);
 26 | *   |             vm.prank(currentActor);
 27 |     |         }
 28 |     |         // }
 29 |     |         _;
 30 |     |     }
 31 |     | }
 32 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsLiquidationModule.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PreconditionsBase.sol";
   5 |     | 
   6 |     | abstract contract PreconditionsLiquidationModule is PreconditionsBase {
   7 |     |     struct LiquidateMarginOnlyParams {
   8 |     |         address user;
   9 |     |         uint128 accountId;
  10 |     |     }
  11 |     | 
  12 |     |     struct LiquidatePositionParams {
  13 |     |         address user;
  14 |     |         uint128 accountId;
  15 |     |     }
  16 |     | 
  17 |     |     struct LiquidateFlaggedParams {
  18 |     |         uint numberOfAccounts;
  19 |     |         uint[] flaggedAccounts;
  20 |     |     }
  21 |     | 
  22 | *   |     function liquidatePositionPreconditions()
  23 |     |         internal
  24 |     |         returns (LiquidatePositionParams memory)
  25 |     |     {
  26 | *   |         address userToLiquidate;
  27 | *   |         uint128 accountToLiquidate;
  28 |     |         // search users array for one is eligible for liquidation
  29 | *   |         for (uint128 i; i < ACCOUNTS.length; i++) {
  30 | *   |             console2.log("Checking account:", i);
  31 |     | 
  32 | *   |             (bool success, bytes memory returnData) = perps.call(
  33 | *   |                 abi.encodeWithSelector(
  34 |     |                     liquidationModuleImpl.canLiquidate.selector,
  35 |     |                     i
  36 |     |                 )
  37 |     |             );
  38 | *   |             assert(success);
  39 |     | 
  40 | *   |             bool isEligible = abi.decode(returnData, (bool));
  41 |     | 
  42 | *   |             if (isEligible) {
  43 |     |                 accountToLiquidate = i;
  44 |     |                 break;
  45 |     |             }
  46 |     | 
  47 | *   |             if (i == ACCOUNTS.length - 1) {
  48 | *   |                 require(false, "no flagged users to liquidate");
  49 |     |             }
  50 |     |         }
  51 |     | 
  52 |     |         return
  53 |     |             LiquidatePositionParams({
  54 |     |                 user: accountIdToUser[accountToLiquidate],
  55 |     |                 accountId: accountToLiquidate
  56 |     |             });
  57 |     |     }
  58 |     | 
  59 | *   |     function liquidateMarginOnlyPreconditions()
  60 |     |         internal
  61 |     |         returns (LiquidateMarginOnlyParams memory)
  62 |     |     {
  63 | *   |         uint128 accountToLiquidate;
  64 | *   |         for (uint128 i; i < ACCOUNTS.length; i++) {
  65 | *   |             console2.log("Checking account for margin-only liquidation:", i);
  66 |     | 
  67 | *   |             (bool success, bytes memory returnData) = perps.call(
  68 | *   |                 abi.encodeWithSelector(
  69 |     |                     liquidationModuleImpl.canLiquidateMarginOnly.selector,
  70 |     |                     i
  71 |     |                 )
  72 |     |             );
  73 | *   |             assert(success);
  74 |     | 
  75 | *   |             bool isEligible = abi.decode(returnData, (bool));
  76 |     | 
  77 | *   |             if (isEligible) {
  78 | *   |                 accountToLiquidate = i;
  79 | *   |                 break;
  80 |     |             }
  81 |     | 
  82 | *   |             if (i == ACCOUNTS.length - 1) {
  83 | *   |                 require(false, "no flagged users to liquidate margin-only");
  84 |     |             }
  85 |     |         }
  86 |     | 
  87 |     |         return
  88 | *   |             LiquidateMarginOnlyParams({
  89 | *   |                 user: accountIdToUser[accountToLiquidate],
  90 |     |                 accountId: accountToLiquidate
  91 |     |             });
  92 |     |     }
  93 |     | 
  94 | *   |     function liquidateFlaggedPreconditions(
  95 |     |         uint8 maxNumberOfAccounts
  96 |     |     ) internal returns (LiquidateFlaggedParams memory) {
  97 | *   |         uint numberOfAccounts = fl.clamp(
  98 | *   |             maxNumberOfAccounts,
  99 |     |             0,
 100 | *   |             (ACCOUNTS.length - 1)
 101 |     |         );
 102 | *   |         uint256 liquidatableAccountsCount = 0;
 103 | *   |         uint256[] memory liquidatableAccounts = new uint256[](ACCOUNTS.length);
 104 |     | 
 105 | *   |         for (uint128 i; i < ACCOUNTS.length; i++) {
 106 | *   |             console2.log("Checking account:", i);
 107 |     | 
 108 | *   |             (bool success, bytes memory returnData) = perps.call(
 109 | *   |                 abi.encodeWithSelector(
 110 |     |                     liquidationModuleImpl.canLiquidate.selector,
 111 |     |                     i
 112 |     |                 )
 113 |     |             );
 114 | *   |             assert(success);
 115 |     | 
 116 | *   |             bool isEligible = abi.decode(returnData, (bool));
 117 |     | 
 118 | *   |             if (isEligible) {
 119 |     |                 liquidatableAccounts[liquidatableAccountsCount] = i;
 120 |     |                 liquidatableAccountsCount++;
 121 |     |             }
 122 |     |         }
 123 |     | 
 124 | *   |         require(liquidatableAccountsCount > 0, "No accounts to liquidate");
 125 |     | 
 126 |     |         uint256[] memory finalLiquidatableAccounts = new uint256[](
 127 |     |             liquidatableAccountsCount
 128 |     |         );
 129 |     |         for (uint256 i = 0; i < liquidatableAccountsCount; i++) {
 130 |     |             finalLiquidatableAccounts[i] = liquidatableAccounts[i];
 131 |     |         }
 132 |     | 
 133 |     |         return
 134 |     |             LiquidateFlaggedParams({
 135 |     |                 numberOfAccounts: uint128(
 136 |     |                     fl.min(numberOfAccounts, liquidatableAccountsCount)
 137 |     |                 ),
 138 |     |                 flaggedAccounts: finalLiquidatableAccounts
 139 |     |             });
 140 |     |     }
 141 |     | }
 142 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsOrderModule.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {AsyncOrder} from "../../../storage/AsyncOrder.sol";
   5 |     | 
   6 |     | import "./PreconditionsBase.sol";
   7 |     | 
   8 |     | abstract contract PreconditionsOrderModule is PreconditionsBase {
   9 |     |     struct CommitOrderParams {
  10 |     |         uint128 accountId;
  11 |     |         uint128 marketId;
  12 |     |         int128 sizeDelta;
  13 |     |         uint256 acceptablePrice;
  14 |     |         uint128 settlementStrategyId;
  15 |     |         bytes32 trackingCode;
  16 |     |         address referrer;
  17 |     |     }
  18 |     | 
  19 |     |     struct SettleOrderParams {
  20 |     |         address settleUser;
  21 |     |         uint128 accountId;
  22 |     |     }
  23 |     | 
  24 |     |     struct CancelOrderParams {
  25 |     |         address cancelUser;
  26 |     |         uint128 accountId;
  27 |     |     }
  28 |     | 
  29 | *   |     function commitOrderPreconditions(
  30 |     |         int128 sizeDelta,
  31 |     |         uint256 acceptablePrice,
  32 |     |         bytes32 trackingCode,
  33 |     |         address referrer
  34 |     |     ) internal returns (CommitOrderParams memory) {
  35 | *   |         console2.log(
  36 |     |             "===== PreconditionsOrderModule:commitOrderPreconditions START ====="
  37 |     |         );
  38 |     | 
  39 | *   |         uint128 settlementStrategyId = 0; //@coverage:limiter currently employing only one settlement strategy
  40 | *   |         console2.log("===== uint128 account  START =====");
  41 | *   |         console2.log("currentActor", currentActor);
  42 | *   |         console2.log("current msg.sender", msg.sender);
  43 |     | 
  44 | *   |         console2.log("acceptablePrice", acceptablePrice);
  45 |     | 
  46 | *   |         uint128 accountIds = userToAccountIds[currentActor];
  47 |     |         uint128 account = userToAccountIds[currentActor];
  48 | *   |         console2.log("===== uint128 account  END =====");
  49 |     | 
  50 | *   |         uint128 marketId = acceptablePrice % 2 == 0 ? 1 : 2;
  51 | *   |         console2.log("===== Constructing CommitOrderParams START =====");
  52 |     | 
  53 | *   |         console2.log("account", account);
  54 | *   |         console2.log("marketId", marketId);
  55 |     | 
  56 | *   |         int128 clampedSizeDelta = int128(
  57 | *   |             fl.clamp(
  58 | *   |                 sizeDelta,
  59 | *   |                 -int128(
  60 | *   |                     marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE
  61 |     |                 ),
  62 |     |                 int128(
  63 | *   |                     marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE
  64 |     |                 )
  65 |     |             )
  66 |     |         );
  67 | *   |         console2.log("clampedSizeDelta", clampedSizeDelta);
  68 |     | 
  69 | *   |         console2.log("WETH_MAX_MARKET_SIZE", WETH_MAX_MARKET_SIZE);
  70 | *   |         console2.log("WBTC_MAX_MARKET_SIZE", WBTC_MAX_MARKET_SIZE);
  71 |     | 
  72 | *   |         console2.log("acceptablePrice", acceptablePrice);
  73 | *   |         console2.log("===== Constructing CommitOrderParams END =====");
  74 | *   |         sizeDelta = int128(
  75 | *   |             fl.clamp(
  76 | *   |                 sizeDelta,
  77 | *   |                 -int128(
  78 | *   |                     marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE
  79 |     |                 ),
  80 |     |                 int128(
  81 | *   |                     marketId == 1 ? WETH_MAX_MARKET_SIZE : WBTC_MAX_MARKET_SIZE
  82 |     |                 )
  83 |     |             )
  84 |     |         );
  85 | *   |         console2.log("Commit size delta", sizeDelta);
  86 | *   |         console2.log(
  87 |     |             "Commit acceptable price",
  88 | *   |             sizeDelta > 0 ? acceptablePrice = type(uint256).max : 0
  89 |     |         );
  90 |     | 
  91 | *   |         return
  92 | *   |             CommitOrderParams({
  93 | *   |                 accountId: account,
  94 | *   |                 marketId: marketId,
  95 | *   |                 sizeDelta: sizeDelta,
  96 | *   |                 acceptablePrice: sizeDelta > 0
  97 | *   |                     ? acceptablePrice = type(uint256).max
  98 | *   |                     : 0,
  99 | *   |                 settlementStrategyId: settlementStrategyId,
 100 | *   |                 trackingCode: trackingCode,
 101 | *   |                 referrer: referrer
 102 |     |             });
 103 |     |         console2.log(
 104 |     |             "===== PreconditionsOrderModule:commitOrderPreconditions END ====="
 105 |     |         );
 106 |     |     }
 107 |     | 
 108 | *   |     function settleOrderPreconditions()
 109 |     |         internal
 110 |     |         returns (SettleOrderParams memory)
 111 |     |     {
 112 | *   |         for (uint256 i = 0; i < USERS.length; i++) {
 113 | *   |             address settelUser = USERS[i];
 114 | *   |             uint128 account = userToAccountIds[settelUser];
 115 |     | 
 116 | *   |             (bool success, bytes memory returnData) = perps.call(
 117 | *   |                 abi.encodeWithSelector(
 118 |     |                     asyncOrderModuleImpl.getOrder.selector,
 119 |     |                     account
 120 |     |                 )
 121 |     |             );
 122 | *   |             assert(success);
 123 |     | 
 124 | *   |             AsyncOrder.Data memory order = abi.decode(
 125 | *   |                 returnData,
 126 |     |                 (AsyncOrder.Data)
 127 |     |             );
 128 | *   |             if (order.commitmentTime != 0) {
 129 |     |                 return
 130 | *   |                     SettleOrderParams({
 131 |     |                         settleUser: settelUser,
 132 |     |                         accountId: account
 133 |     |                     });
 134 |     |             }
 135 |     |         }
 136 |     | 
 137 | *   |         require(false, "No valid order found");
 138 |     |     }
 139 |     | 
 140 | *   |     function cancelOrderPreconditions(
 141 |     |         uint8 cancelUser
 142 |     |     ) internal view returns (CancelOrderParams memory) {
 143 | *   |         address user = USERS[cancelUser % (USERS.length - 1)];
 144 | *   |         uint128 account = userToAccountIds[user];
 145 | *   |         uint128 marketId = cancelUser % 2 == 0 ? 1 : 2;
 146 |     | 
 147 | *   |         return
 148 | *   |             CancelOrderParams({
 149 | *   |                 cancelUser: USERS[cancelUser % (USERS.length - 1)],
 150 |     |                 accountId: account
 151 |     |             });
 152 |     |     }
 153 |     | }
 154 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/helper/preconditions/PreconditionsPerpsAccountModule.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | 
  6 |     | abstract contract PreconditionsPerpsAccountModule is PreconditionsBase {
  7 |     |     struct ModifyCollateralParams {
  8 |     |         uint128 accountId;
  9 |     |         uint128 marketId;
 10 |     |         address collateralAddress;
 11 |     |         uint128 collateralId;
 12 |     |         int256 amountDelta;
 13 |     |     }
 14 |     | 
 15 |     |     struct PayDebtParams {
 16 |     |         uint128 accountId;
 17 |     |         uint128 marketId;
 18 |     |         uint128 amount;
 19 |     |     }
 20 |     | 
 21 | *   |     function modifyCollateralPreconditions(
 22 |     |         int256 amountDelta,
 23 |     |         uint256 collateralTokenIndex
 24 |     |     ) internal returns (ModifyCollateralParams memory) {
 25 | *   |         address collateralToken = _getRandomCollateralToken(collateralTokenIndex);
 26 | *   |         uint128 account = userToAccountIds[currentActor];
 27 |     | 
 28 | *   |         uint128 marketId = collateralTokenIndex % 2 == 0 ? 1 : 2;
 29 |     | 
 30 | *   |         uint128 collateralId;
 31 | *   |         if (collateralToken == address(sUSDTokenMock)) collateralId = 0;
 32 | *   |         else if (collateralToken == address(wethTokenMock)) collateralId = 1;
 33 | *   |         else if (collateralToken == address(wbtcTokenMock)) collateralId = 2;
 34 |     | 
 35 | *   |         return
 36 | *   |             ModifyCollateralParams({
 37 |     |                 accountId: account,
 38 |     |                 marketId: marketId,
 39 |     |                 collateralAddress: collateralToken,
 40 |     |                 collateralId: collateralId,
 41 | *r  |                 amountDelta: fl.clamp(amountDelta, -int128(MAX_ALLOWABLE), int128(MAX_ALLOWABLE))
 42 |     |             });
 43 |     |     }
 44 |     | 
 45 | *   |     function payDebtPreconditions(uint128 amount) internal view returns (PayDebtParams memory) {
 46 | *   |         uint128 account = userToAccountIds[currentActor];
 47 | *   |         uint128 marketId = amount % 2 == 0 ? 1 : 2;
 48 |     | 
 49 | *   |         return PayDebtParams({accountId: account, marketId: marketId, amount: amount});
 50 |     |     }
 51 |     | }
 52 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockERC20.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  4 |     | 
  5 | *   | contract MockERC20 is ERC20 {
  6 |     |     uint8 private _decimals;
  7 |     | 
  8 |     |     constructor(string memory name, string memory symbol, uint8 dec) ERC20(name, symbol) {
  9 |     |         _decimals = dec;
 10 |     |     }
 11 |     | 
 12 |     |     function decimals() public view virtual override(ERC20) returns (uint8) {
 13 |     |         return _decimals;
 14 |     |     }
 15 |     | 
 16 | *   |     function mint(address account, uint256 amount) external {
 17 | *   |         _mint(account, amount);
 18 |     |     }
 19 |     | 
 20 | *   |     function burn(address account, uint256 amount) external {
 21 | *   |         _burn(account, amount);
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockLensModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {AsyncOrder} from "../../storage/AsyncOrder.sol";
   5 |     | import {PerpsMarketConfiguration} from "../../storage/PerpsMarketConfiguration.sol";
   6 |     | import {SettlementStrategy} from "../../storage/SettlementStrategy.sol";
   7 |     | import {console2} from "lib/forge-std/src/Test.sol";
   8 |     | import {PerpsAccount} from "../../storage/PerpsAccount.sol";
   9 |     | import {GlobalPerpsMarket} from "../../storage/GlobalPerpsMarket.sol";
  10 |     | 
  11 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  12 |     | import {SafeCastI256, SafeCastU256, SafeCastU128} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  13 |     | 
  14 | *   | contract MockLensModule {
  15 |     |     using AsyncOrder for AsyncOrder.Data;
  16 |     |     using PerpsAccount for PerpsAccount.Data;
  17 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  18 |     |     using SetUtil for SetUtil.UintSet;
  19 |     |     using SafeCastI256 for int256;
  20 |     |     using SafeCastU128 for uint128;
  21 |     |     using SafeCastU256 for uint256;
  22 | *   |     function getOpenPositionMarketIds(
  23 |     |         uint128 accountId
  24 | *   |     ) external returns (uint128[] memory) {
  25 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
  26 | *   |         uint256 length = account.openPositionMarketIds.length();
  27 | *   |         uint128[] memory marketIds = new uint128[](length);
  28 |     | 
  29 | *   |         for (uint256 i = 1; i <= length; i++) {
  30 |     |             //1 based index
  31 | *   |             marketIds[i - 1] = account.openPositionMarketIds.valueAt(i).to128();
  32 |     |         }
  33 |     | 
  34 |     |         return marketIds;
  35 |     |     }
  36 |     | 
  37 |     |     function getCollateralTypes(
  38 |     |         uint128 accountId
  39 |     |     ) external returns (uint128[] memory) {
  40 |     |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
  41 |     |         uint256 length = account.activeCollateralTypes.length();
  42 |     |         uint128[] memory collateralTypes = new uint128[](length);
  43 |     | 
  44 |     |         for (uint256 i = 1; i <= length; i++) {
  45 |     |             //1 based index
  46 | *   |             collateralTypes[i - 1] = account
  47 |     |                 .activeCollateralTypes
  48 |     |                 .valueAt(i)
  49 |     |                 .to128();
  50 |     |         }
  51 |     | 
  52 |     |         return collateralTypes;
  53 |     |     }
  54 | *   |     function getGlobalCollateralTypes()
  55 |     |         external
  56 |     |         view
  57 | *   |         returns (uint128[] memory)
  58 |     |     {
  59 | *   |         GlobalPerpsMarket.Data storage globalMarketData = GlobalPerpsMarket
  60 |     |             .load();
  61 | *   |         SetUtil.UintSet storage activeCollateralTypes = globalMarketData
  62 |     |             .activeCollateralTypes;
  63 | *   |         uint256 activeCollateralLength = activeCollateralTypes.length();
  64 | *   |         uint128[] memory globalCollateralTypes = new uint128[](
  65 | *   |             activeCollateralLength
  66 |     |         );
  67 |     | 
  68 | *   |         for (uint256 i = 1; i <= activeCollateralLength; i++) {
  69 | *   |             globalCollateralTypes[i - 1] = uint128(
  70 | *   |                 activeCollateralTypes.valueAt(i)
  71 |     |             );
  72 |     |         }
  73 |     | 
  74 | *   |         return globalCollateralTypes;
  75 |     |     }
  76 |     | 
  77 | *   |     function isOrderExpired(uint128 accountId) external view returns (bool) {
  78 | *   |         AsyncOrder.Data storage order = AsyncOrder.load(accountId);
  79 | *   |         console2.log(
  80 |     |             "MockLens::isOrderExpired::order.request.marketId",
  81 | *   |             order.request.marketId
  82 |     |         );
  83 | *   |         console2.log(
  84 |     |             "MockLens::isOrderExpired::order.request.sizeDelta",
  85 | *   |             order.request.sizeDelta
  86 |     |         );
  87 | *   |         if (order.request.sizeDelta != 0) {
  88 | *   |             SettlementStrategy.Data storage strategy = PerpsMarketConfiguration
  89 | *   |                 .load(order.request.marketId)
  90 | *   |                 .settlementStrategies[order.request.settlementStrategyId];
  91 |     | 
  92 | *   |             return AsyncOrder.expired(order, strategy);
  93 |     |         }
  94 |     | 
  95 | *   |         return false;
  96 |     |     }
  97 |     | 
  98 | *   |     function getOrder(
  99 |     |         uint128 accountId
 100 | *   |     ) external view returns (AsyncOrder.Data memory) {
 101 | *   |         return AsyncOrder.load(accountId);
 102 |     |     }
 103 |     | 
 104 | *   |     function getSettlementRewardCost(
 105 |     |         uint128 marketId,
 106 |     |         uint128 settlementStrategyId
 107 |     |     ) external view returns (uint256) {
 108 |     |         SettlementStrategy.Data storage strategy = PerpsMarketConfiguration
 109 |     |             .loadValidSettlementStrategy(marketId, settlementStrategyId);
 110 |     |         return AsyncOrder.settlementRewardCost(strategy);
 111 |     |     }
 112 |     | 
 113 | *   |     function calculateFillPrice(
 114 |     |         int256 skew,
 115 |     |         uint256 skewScale,
 116 |     |         int128 sizeDelta,
 117 |     |         uint256 price
 118 |     |     ) external pure returns (uint256) {
 119 |     |         return AsyncOrder.calculateFillPrice(skew, skewScale, sizeDelta, price);
 120 |     |     }
 121 |     | 
 122 |     |     // function calculateOrderFee(
 123 |     |     //     int128 sizeDelta,
 124 |     |     //     uint256 fillPrice,
 125 |     |     //     int256 marketSkew,
 126 |     |     //     AsyncOrder.OrderFee storage orderFeeData //marketConfig.orderFees
 127 |     |     // ) external view returns (uint256) {
 128 |     |     //     return AsyncOrder.calculateOrderFee(sizeDelta, fillPrice, marketSkew, orderFeeData);
 129 |     |     // }
 130 |     | }
 131 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {Account, AccountRBAC} from "@synthetixio/main/contracts/storage/Account.sol";
  5 |     | 
  6 |     | // solhint-disable-next-line no-empty-blocks
  7 |     | contract MockModule {
  8 |     |     function createAccount(uint128 id, address owner) external {
  9 |     |         Account.create(id, owner);
 10 |     |     }
 11 |     | 
 12 |     |     function grantPermission(uint128 accountId, bytes32 permission, address user) external {
 13 |     |         Account.Data storage account = Account.load(accountId);
 14 |     |         AccountRBAC.grantPermission(account.rbac, permission, user);
 15 |     |     }
 16 |     | }
 17 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockOracleManager.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {Account, AccountRBAC} from "@synthetixio/main/contracts/storage/Account.sol";
  5 |     | import {INodeModule, NodeOutput} from "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
  6 |     | import {console2} from "lib/forge-std/src/Test.sol";
  7 |     | interface IMockOracleManager {
  8 |     |     function changePrice(bytes32 nodeId, int256 newPrice) external;
  9 |     | 
 10 |     |     function process(bytes32 nodeId) external returns (NodeOutput.Data memory node);
 11 |     | }
 12 |     | 
 13 |     | // solhint-disable-next-line no-empty-blocks
 14 | *   | contract MockOracleManager {
 15 |     |     mapping(bytes32 nodeId => NodeOutput.Data) nodes;
 16 | *   |     bytes32[] public activeNodes;
 17 |     | 
 18 |     |     constructor(bytes32[] memory nodeIds, int256[] memory prices) {
 19 |     |         // initialize price for the nodeIds passed in
 20 |     |         for (uint256 i; i < nodeIds.length; i++) {
 21 |     |             nodes[nodeIds[i]] = NodeOutput.Data({
 22 |     |                 price: prices[i],
 23 |     |                 timestamp: block.timestamp,
 24 |     |                 __slotAvailableForFutureUse1: 0,
 25 |     |                 __slotAvailableForFutureUse2: 0
 26 |     |             });
 27 |     |             activeNodes.push(nodeIds[i]);
 28 |     |         }
 29 |     |     }
 30 |     | 
 31 | *   |     function getActiveNodesLength() public view returns (uint256) {
 32 | *   |         return activeNodes.length;
 33 |     |     }
 34 |     | 
 35 | *   |     function changePrice(bytes32 nodeId, int256 newPrice) external {
 36 | *   |         nodes[nodeId].price = newPrice;
 37 |     |     }
 38 |     | 
 39 | *   |     function process(bytes32 nodeId) external view returns (NodeOutput.Data memory node) {
 40 | *   |         return nodes[nodeId];
 41 |     |     }
 42 |     | 
 43 | *   |     function processWithRuntime(
 44 |     |         bytes32 nodeId,
 45 |     |         bytes32[] memory runtimeKeys,
 46 |     |         bytes32[] memory runtimeValues
 47 | *   |     ) external view returns (NodeOutput.Data memory node) {
 48 | *   |         return nodes[nodeId];
 49 |     |     }
 50 |     | }
 51 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockPyth.sol
  1 |     | // SPDX-License-Identifier: Apache-2.0
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 | *   | contract MockPyth {
  5 |     |     struct Price {
  6 |     |         // Price
  7 |     |         int64 price;
  8 |     |         // Confidence interval around the price
  9 |     |         uint64 conf;
 10 |     |         // Price exponent
 11 |     |         int32 expo;
 12 |     |         // Unix timestamp describing when the price was published
 13 |     |         uint256 publishTime;
 14 |     |     }
 15 |     | 
 16 |     |     // PriceFeed represents a current aggregate price from pyth publisher feeds.
 17 |     |     struct PriceFeed {
 18 |     |         // The price ID.
 19 |     |         bytes32 id;
 20 |     |         // Latest available price
 21 |     |         Price price;
 22 |     |         // Latest available exponentially-weighted moving average price
 23 |     |         Price emaPrice;
 24 |     |     }
 25 |     | 
 26 |     |     error InsufficientFee();
 27 |     | 
 28 |     |     mapping(bytes32 => PriceFeed[]) priceFeeds;
 29 |     |     bytes32[] activeFeeds;
 30 |     |     uint256 requiredFee;
 31 |     | 
 32 | *   |     function addPriceFeed(
 33 |     |         bytes32 id,
 34 |     |         int64 startingPrice,
 35 |     |         uint64 startingConf,
 36 |     |         int32 startingExpo
 37 |     |     ) external {
 38 |     |         priceFeeds[id].push(
 39 |     |             PriceFeed({
 40 |     |                 id: id,
 41 |     |                 price: Price({
 42 |     |                     price: startingPrice,
 43 |     |                     conf: startingConf,
 44 |     |                     expo: startingExpo,
 45 |     |                     publishTime: block.timestamp
 46 |     |                 }),
 47 |     |                 emaPrice: Price({
 48 |     |                     price: startingPrice,
 49 |     |                     conf: startingConf,
 50 |     |                     expo: startingExpo,
 51 |     |                     publishTime: block.timestamp
 52 |     |                 })
 53 |     |             })
 54 |     |         );
 55 |     |         activeFeeds.push(id);
 56 |     |     }
 57 |     | 
 58 |     |     function setRequiredFee(uint256 newFee) external {
 59 |     |         requiredFee = newFee;
 60 |     |     }
 61 |     | 
 62 | *   |     function changePrice(bytes32 id, int64 newPrice) external {
 63 | *   |         priceFeeds[id][0].price.price = newPrice;
 64 | *   |         priceFeeds[id][0].price.publishTime = block.timestamp;
 65 |     |     }
 66 |     | 
 67 |     |     function parsePriceFeedUpdatesUnique(
 68 |     |         bytes[] calldata updateData,
 69 |     |         bytes32[] calldata priceIds,
 70 |     |         uint64 minPublishTime,
 71 |     |         uint64 maxPublishTime
 72 |     |     ) external payable returns (PriceFeed[] memory feeds) {
 73 |     |         if (msg.value < requiredFee) revert InsufficientFee();
 74 |     | 
 75 |     |         return priceFeeds[priceIds[0]];
 76 |     |     }
 77 |     | 
 78 |     |     function getCurrentPrice(bytes32 id) external returns (int64) {
 79 |     |         return priceFeeds[id][0].price.price;
 80 |     |     }
 81 |     | }
 82 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockRewardDistributor.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {IRewardDistributor} from "@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol";
   5 |     | import {IERC165} from "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
   6 |     | import "./MockSynthetixV3.sol";
   7 |     | import {console2} from "lib/forge-std/src/Test.sol";
   8 |     | 
   9 | *   | contract MockRewardDistributor {
  10 |     |     MockSynthetixV3 v3Mock;
  11 | *   |     uint128 public poolId;
  12 |     |     uint public collateralId;
  13 |     |     constructor(MockSynthetixV3 _v3Mock, uint128 _poolId, uint _collateralId) {
  14 |     |         v3Mock = _v3Mock;
  15 |     |         poolId = _poolId;
  16 |     |         collateralId = _collateralId;
  17 |     |     }
  18 |     | 
  19 | *   |     function getPoolId() external view returns (uint128) {
  20 |     |         return poolId;
  21 |     |     }
  22 |     | 
  23 | *   |     function getPoolCollateralTypes() external view returns (address[] memory) {
  24 | *   |         return v3Mock.getCollateralTypes();
  25 |     |     }
  26 |     | 
  27 | *   |     function distributeRewards(
  28 |     |         uint128 poolId_,
  29 |     |         address collateralType_,
  30 |     |         uint256 amount_,
  31 |     |         uint64 start_,
  32 |     |         uint32 duration_
  33 |     |     ) external {
  34 |     |         // distribute a portion of debt rewards to different vaults
  35 |     |         // TODO: commenting out temporarily to resolve issues in LiquidationModule coverage
  36 |     |         // v3Mock.updateRewardDistribution(collateralType, amount);
  37 | *   |         console2.log(
  38 |     |             "====== MockRewardDistributor::distributeRewards END ======"
  39 |     |         );
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |         Below are required for passing safeSupportsInterface when calling MarginModule::setMarginCollateralConfiguration
  44 |     |     */
  45 |     |     function name() external view returns (string memory) {
  46 |     |         return "MockRewardDistributor";
  47 |     |     }
  48 |     | 
  49 |     |     function payout(
  50 |     |         uint128 accountId,
  51 |     |         uint128 poolId,
  52 |     |         address collateralType,
  53 |     |         address sender,
  54 |     |         uint256 amount
  55 |     |     ) external returns (bool) {
  56 |     |         // check if user is actually deposited into the vault and has shares
  57 |     |         require(v3Mock.getShares(sender, collateralType));
  58 |     | 
  59 |     |         // calculate how much a user is owed based on their share of the vault
  60 |     |         // each user's deposit in a vault is 1 share for simplification
  61 |     |         (, , , uint256 rewardAmount, uint256 totalShares) = v3Mock.vaults(
  62 |     |             collateralType
  63 |     |         );
  64 |     |         uint256 percentOfVault = (1 * 1e18) / (totalShares * 1e18);
  65 |     |         uint256 amountOfRewards = percentOfVault * rewardAmount;
  66 |     | 
  67 |     |         if (amount <= amountOfRewards) {
  68 |     |             MockERC20(collateralType).transfer(sender, amount);
  69 |     |             return true;
  70 |     |         }
  71 |     | 
  72 |     |         return false;
  73 |     |     }
  74 |     | 
  75 |     |     function onPositionUpdated(
  76 |     |         uint128 accountId,
  77 |     |         uint128 poolId,
  78 |     |         address collateralType,
  79 |     |         uint256 newShares
  80 |     |     ) external {}
  81 |     | 
  82 |     |     /// @notice Address to ERC-20 token distributed by this distributor, for display purposes only
  83 |     |     /// @dev Return address(0) if providing non ERC-20 rewards
  84 | *   |     function token() external view returns (address) {
  85 |     |         return
  86 | *   |             collateralId == 1
  87 | *   |                 ? v3Mock.wETH()
  88 | *   |                 : collateralId == 2
  89 | *   |                     ? v3Mock.wBTC()
  90 | *   |                     : v3Mock.huge();
  91 |     |     }
  92 |     | 
  93 | *   |     function supportsInterface(
  94 |     |         bytes4 interfaceId
  95 |     |     ) public view virtual returns (bool) {
  96 |     |         return
  97 |     |             interfaceId == type(IRewardDistributor).interfaceId ||
  98 |     |             interfaceId == this.supportsInterface.selector;
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 | *   | contract MockRouter {
  5 |     |     event AddedFunctionAndImplementation(bytes4 selector, address implementation);
  6 |     | 
  7 |     |     error UnknownSelector(bytes4 sel);
  8 |     | 
  9 |     |     // selector => implementation address
 10 |     |     mapping(bytes4 => address) implementations;
 11 |     | 
 12 |     |     function addFunctionAndImplementation(bytes4 selector, address implementation) external {
 13 |     |         implementations[selector] = implementation;
 14 |     |         emit AddedFunctionAndImplementation(selector, implementation);
 15 |     |         if (implementation == address(0)) {
 16 |     |             revert();
 17 |     |         }
 18 |     |     }
 19 |     | 
 20 |     |     fallback() external payable {
 21 |     |         // Lookup table: Function selector => implementation contract
 22 | *   |         bytes4 selector = msg.sig;
 23 | *   |         address implementation = implementations[selector];
 24 |     | 
 25 | *   |         if (implementation == address(0)) {
 26 |     |             revert UnknownSelector(selector);
 27 |     |         }
 28 |     | 
 29 |     |         // Delegatecall to the implementation contract
 30 |     |         assembly {
 31 | *   |             calldatacopy(0, 0, calldatasize())
 32 |     | 
 33 | *   |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 34 | *   |             returndatacopy(0, 0, returndatasize())
 35 |     | 
 36 | *   |             switch result
 37 | *   |             case 0 {
 38 | *   |                 revert(0, returndatasize())
 39 |     |             }
 40 |     |             default {
 41 | *   |                 return(0, returndatasize())
 42 |     |             }
 43 |     |         }
 44 |     |     }
 45 |     | }
 46 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockSpotMarket.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | import "./MockSynthetixV3.sol";
   5 |     | import "./MockOracleManager.sol";
   6 |     | import {SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   7 |     | 
   8 | *   | contract MockSpotMarket {
   9 |     |     using SafeCastI256 for int256;
  10 |     | 
  11 |     |     enum TransactionType {
  12 |     |         NULL, // reserved for 0 (default value)
  13 |     |         BUY,
  14 |     |         SELL,
  15 |     |         ASYNC_BUY,
  16 |     |         ASYNC_SELL,
  17 |     |         WRAP,
  18 |     |         UNWRAP
  19 |     |     }
  20 |     | 
  21 |     |     enum PriceTolerance {
  22 |     |         DEFAULT,
  23 |     |         STRICT
  24 |     |     }
  25 |     | 
  26 |     |     MockSynthetixV3 v3Mock;
  27 |     |     MockOracleManager mockOracleManager;
  28 |     |     address wethTokenMock;
  29 |     |     address wbtcTokenMock;
  30 |     |     address hugeTokenMock;
  31 |     | 
  32 |     |     bytes32 WETH_ORACLE_NODE_ID;
  33 |     |     bytes32 WBTC_ORACLE_NODE_ID;
  34 |     |     bytes32 HUGE_ORACLE_NODE_ID;
  35 |     |     uint WETH_MARKET_SKEW_SCALE;
  36 |     |     uint WBTC_MARKET_SKEW_SCALE;
  37 |     |     uint HUGE_MARKET_SKEW_SCALE;
  38 |     | 
  39 |     |     constructor(
  40 |     |         MockSynthetixV3 _v3Mock,
  41 |     |         MockOracleManager _mockOracleManager,
  42 |     |         address _weth,
  43 |     |         uint _wethMarketSkewScale,
  44 |     |         address _wbtc,
  45 |     |         uint _wbtcMarketSkewScale,
  46 |     |         address _huge,
  47 |     |         uint _hugeMarketSkewScale,
  48 |     |         bytes32 _wethOracleNodeId,
  49 |     |         bytes32 _wbtcOracleNodeId,
  50 |     |         bytes32 _hugeOracleNodeId
  51 |     |     ) {
  52 |     |         v3Mock = _v3Mock;
  53 |     |         mockOracleManager = _mockOracleManager;
  54 |     |         wethTokenMock = _weth;
  55 |     |         WETH_MARKET_SKEW_SCALE = _wethMarketSkewScale;
  56 |     | 
  57 |     |         wbtcTokenMock = _wbtc;
  58 |     |         WBTC_MARKET_SKEW_SCALE = _wbtcMarketSkewScale;
  59 |     | 
  60 |     |         hugeTokenMock = _huge;
  61 |     |         HUGE_MARKET_SKEW_SCALE = _hugeMarketSkewScale;
  62 |     | 
  63 |     |         WETH_ORACLE_NODE_ID = _wethOracleNodeId;
  64 |     |         WBTC_ORACLE_NODE_ID = _wbtcOracleNodeId;
  65 |     |         HUGE_ORACLE_NODE_ID = _hugeOracleNodeId;
  66 |     |     }
  67 |     | 
  68 |     |     mapping(uint128 marketId => address synthAddress) public synth;
  69 |     | 
  70 |     |     function setSynthForMarketId(
  71 |     |         uint128[] memory marketIds,
  72 |     |         address[] memory synthAddresses
  73 |     |     ) public {
  74 |     |         require(
  75 |     |             marketIds.length == synthAddresses.length,
  76 |     |             "Input arrays must have the same length"
  77 |     |         );
  78 |     |         for (uint i = 0; i < marketIds.length; i++) {
  79 |     |             synth[marketIds[i]] = synthAddresses[i];
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 | *   |     function getSynth(
  84 |     |         uint128 marketId
  85 | *   |     ) public view returns (address synthAddress) {
  86 | *   |         return synth[marketId];
  87 |     |     }
  88 |     | 
  89 | *   |     function getMarketSkewScale(
  90 |     |         uint128 synthMarketId
  91 | *   |     ) external view returns (uint128 skewScale) {
  92 | *   |         if (getSynth(synthMarketId) == address(wethTokenMock)) {
  93 | *   |             return uint128(WETH_MARKET_SKEW_SCALE);
  94 |     |         }
  95 | *   |         if (getSynth(synthMarketId) == address(wbtcTokenMock)) {
  96 | *   |             return uint128(WBTC_MARKET_SKEW_SCALE);
  97 |     |         }
  98 | *   |         if (getSynth(synthMarketId) == address(hugeTokenMock)) {
  99 |     |             return uint128(HUGE_MARKET_SKEW_SCALE);
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 | *   |     function indexPrice(
 104 |     |         uint128 marketId,
 105 |     |         uint128 transactionType,
 106 |     |         PriceTolerance priceTolerance
 107 | *   |     ) public returns (uint256) {
 108 | *   |         bytes32 nodeid;
 109 |     | 
 110 | *   |         require(marketId <= 3, "Only 3 markets was implemented");
 111 |     | 
 112 | *   |         TransactionType txnType = loadValidTransactionType(transactionType);
 113 |     | 
 114 | *   |         if (marketId == 1) {
 115 | *   |             nodeid = WETH_ORACLE_NODE_ID;
 116 | *   |         } else if (marketId == 2) {
 117 | *   |             nodeid = WBTC_ORACLE_NODE_ID;
 118 | *   |         } else if (marketId == 3) {
 119 |     |             nodeid = HUGE_ORACLE_NODE_ID;
 120 |     |         }
 121 |     | 
 122 | *   |         return mockOracleManager.process(nodeid).price.toUint();
 123 |     |     }
 124 |     | 
 125 | *   |     function loadValidTransactionType(
 126 |     |         uint128 txnType
 127 | *   |     ) internal pure returns (TransactionType) {
 128 |     |         // solhint-disable-next-line numcast/safe-cast
 129 | *   |         uint128 txnTypeMax = uint128(TransactionType.UNWRAP);
 130 | *   |         if (txnType > txnTypeMax) {
 131 |     |             revert("Invalid transaction type");
 132 |     |         }
 133 | *   |         return TransactionType(txnType);
 134 |     |     }
 135 |     | }
 136 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockSynthetixV3.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {INodeModule, NodeOutput} from "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
   5 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   6 |     | import {MockERC20} from "./MockERC20.sol";
   7 |     | import {MockOracleManager} from "./MockOracleManager.sol";
   8 |     | import {MathUtil} from "../../utils/MathUtil.sol";
   9 |     | import {console2} from "lib/forge-std/src/Test.sol";
  10 |     | 
  11 |     | struct Vault {
  12 |     |     address collateralToken;
  13 |     |     bytes32 nodeId; // the nodeId used in oracleManager to return the price for a give collateral type
  14 |     |     uint256 collateralAmount; // the amount of a given collateral held in SynthetixV3
  15 |     |     uint256 rewardAmount; // reward amount accumulated for a debt distribution during a liquidation event
  16 |     |     uint256 totalShares; // the total amount of shares that exist in the vault
  17 |     | }
  18 |     | struct Cache {
  19 |     |     uint256 sUSDBalance;
  20 |     |     uint256 wETHBalance;
  21 |     |     uint256 wBTCBalance;
  22 |     |     uint256 hugeBalance;
  23 |     |     bytes32 sUSDNodeId;
  24 |     |     bytes32 wETHNodeId;
  25 |     |     bytes32 wBTCNodeId;
  26 |     |     bytes32 hugeNodeId;
  27 |     |     NodeOutput.Data sUSDNode;
  28 |     |     NodeOutput.Data wETHNode;
  29 |     |     NodeOutput.Data wBTCNode;
  30 |     |     NodeOutput.Data hugeNode;
  31 |     |     uint256 valueSUSD;
  32 |     |     uint256 valueWETH;
  33 |     |     uint256 valuewBTC;
  34 |     |     uint256 valuehuge;
  35 |     | }
  36 | *   | contract MockSynthetixV3 {
  37 |     |     address oracleManager;
  38 |     |     address public sUSD;
  39 | *   |     address public wETH;
  40 | *   |     address public wBTC;
  41 |     |     address public huge;
  42 |     |     uint256 public withdrawableUSD;
  43 | *   |     uint256 public creditCapacity;
  44 |     | 
  45 |     |     mapping(address collateralToken => Vault) public vaults;
  46 |     |     mapping(address user => mapping(address collateralToken => bool deposited))
  47 |     |         public shares; // mock implementation of vault shares where each user gets 1 share of the vault they're depositing into, independent of deposit size for simplicity, since each user gets one share, just need to know if they're deposited into a vault
  48 |     | 
  49 |     |     event DepositMarketUsd(uint128 marketId, address msgSender, uint256 amount);
  50 |     |     event DepositMarketUsdAfter(
  51 |     |         uint128 marketId,
  52 |     |         address msgSender,
  53 |     |         uint256 amount
  54 |     |     );
  55 |     | 
  56 | *   |     uint256 constant FEE_PERCENT = 0.01e18;
  57 |     | 
  58 |     |     /**
  59 |     |         Getters
  60 |     |     */
  61 | *   |     function getUsdToken() external view returns (address) {
  62 |     |         return sUSD;
  63 |     |     }
  64 |     | 
  65 |     |     function getAssociatedSystem(
  66 |     |         bytes32 id
  67 |     |     ) external returns (address, bytes32) {
  68 |     |         if (id == vaults[sUSD].nodeId) {
  69 |     |             return (vaults[sUSD].collateralToken, "");
  70 |     |         } else if (id == vaults[wETH].nodeId) {
  71 |     |             return (vaults[wETH].collateralToken, "");
  72 |     |         } else if (id == vaults[wBTC].nodeId) {
  73 |     |             return (vaults[wBTC].collateralToken, "");
  74 |     |         } else if (id == vaults[huge].nodeId) {
  75 |     |             return (vaults[huge].collateralToken, "");
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     function getOracleManager() external returns (address) {
  80 |     |         return oracleManager;
  81 |     |     }
  82 |     | 
  83 | *   |     function getWithdrawableMarketUsd(
  84 |     |         uint128 marketId
  85 | *   |     ) external view returns (uint256 withdrawableUsd) {
  86 | *   |         console2.log(
  87 |     |             "===== MockSynthetixV3::getWithdrawableMarketUsd START ====="
  88 |     |         );
  89 | *   |         console2.log("marketId", marketId);
  90 |     | 
  91 | *   |         Cache memory cache;
  92 |     | 
  93 | *   |         cache.sUSDBalance = MockERC20(sUSD).balanceOf(address(this));
  94 | *   |         console2.log("sUSDBalance", cache.sUSDBalance);
  95 |     | 
  96 | *   |         cache.wETHBalance = MockERC20(wETH).balanceOf(address(this));
  97 | *   |         console2.log("wETHBalance", cache.wETHBalance);
  98 |     | 
  99 | *   |         cache.wBTCBalance = MockERC20(wBTC).balanceOf(address(this));
 100 | *   |         console2.log("wBTCBalance", cache.wBTCBalance);
 101 |     | 
 102 | *   |         cache.hugeBalance = MockERC20(huge).balanceOf(address(this));
 103 | *   |         console2.log("hugeBalance", cache.hugeBalance);
 104 |     | 
 105 | *   |         cache.sUSDNodeId = vaults[sUSD].nodeId;
 106 | *   |         console2.log("sUSDNodeId");
 107 | *   |         console2.logBytes32(cache.sUSDNodeId);
 108 |     | 
 109 | *   |         cache.wETHNodeId = vaults[wETH].nodeId;
 110 | *   |         console2.log("wETHNodeId");
 111 | *   |         console2.logBytes32(cache.wETHNodeId);
 112 |     | 
 113 | *   |         cache.wBTCNodeId = vaults[wBTC].nodeId;
 114 | *   |         console2.log("wBTCNodeId");
 115 | *   |         console2.logBytes32(cache.wBTCNodeId);
 116 |     | 
 117 | *   |         cache.hugeNodeId = vaults[huge].nodeId;
 118 | *   |         console2.log("hugeNodeId");
 119 | *   |         console2.logBytes32(cache.hugeNodeId);
 120 |     | 
 121 | *   |         cache.sUSDNode = MockOracleManager(oracleManager).process(
 122 | *   |             cache.sUSDNodeId
 123 |     |         );
 124 | *   |         console2.log("sUSDNode.price", cache.sUSDNode.price);
 125 |     | 
 126 | *   |         cache.wETHNode = MockOracleManager(oracleManager).process(
 127 | *   |             cache.wETHNodeId
 128 |     |         );
 129 | *   |         console2.log("wETHNode.price", cache.wETHNode.price);
 130 |     | 
 131 | *   |         cache.wBTCNode = MockOracleManager(oracleManager).process(
 132 | *   |             cache.wBTCNodeId
 133 |     |         );
 134 | *   |         console2.log("wBTCNode.price", cache.wBTCNode.price);
 135 |     | 
 136 | *   |         cache.hugeNode = MockOracleManager(oracleManager).process(
 137 | *   |             cache.hugeNodeId
 138 |     |         );
 139 | *   |         console2.log("hugeNode.price", cache.hugeNode.price);
 140 |     | 
 141 | *   |         cache.valueSUSD = uint256(int256(cache.sUSDBalance));
 142 | *   |         console2.log("valueSUSD", cache.valueSUSD);
 143 |     | 
 144 | *   |         cache.valueWETH = uint256(
 145 | *   |             (int256(cache.wETHBalance) * cache.wETHNode.price) / 1e18
 146 |     |         );
 147 | *   |         console2.log("valueWETH", cache.valueWETH);
 148 |     | 
 149 | *   |         cache.valuewBTC = uint256(
 150 | *   |             (int256(cache.wBTCBalance) * cache.wBTCNode.price) / 1e18
 151 |     |         );
 152 | *   |         console2.log("valuewBTC", cache.valuewBTC);
 153 |     | 
 154 | *   |         cache.valuehuge = uint256(
 155 | *   |             (int256(cache.hugeBalance) * cache.hugeNode.price) / 1e18
 156 |     |         );
 157 | *   |         console2.log("valuehuge", cache.valuehuge);
 158 |     | 
 159 | *   |         withdrawableUsd = MathUtil.min(
 160 | *   |             creditCapacity +
 161 | *   |                 (cache.valueSUSD +
 162 | *   |                     cache.valueWETH +
 163 | *   |                     cache.valuewBTC +
 164 | *   |                     cache.valuehuge),
 165 |     |             type(uint128).max
 166 |     |         );
 167 | *   |         console2.log("withdrawableUsd", withdrawableUsd);
 168 |     | 
 169 | *   |         console2.log(
 170 |     |             "===== MockSynthetixV3::getWithdrawableMarketUsd END ====="
 171 |     |         );
 172 |     |     }
 173 |     | 
 174 |     |     event Debug(string s);
 175 |     |     event DebugValue(int256 val);
 176 | *   |     function getVaultCollateral(
 177 |     |         uint128 poolId,
 178 |     |         address collateralType
 179 | *   |     ) public returns (uint256 amount, uint256 value) {
 180 | *   |         amount = vaults[collateralType].collateralAmount;
 181 |     | 
 182 |     |         // poolId is irrelevant because assuming only one pool exists so just query using the collateralType id here
 183 | *   |         bytes32 nodeId = vaults[collateralType].nodeId;
 184 |     |         // NodeOutput.Data memory node = MockOracleManager(oracleManager).process(nodeId);
 185 |     |         // emit DebugValue(node.price);
 186 |     |         // value = uint256(int256(amount) * node.price);
 187 |     | 
 188 |     |         // TODO: temporary fix to work around StateChangeWhileStatic error
 189 |     |         // assumes price of 1
 190 | *   |         value = amount * 1;
 191 |     |         // emit Debug("getVaultCollateral");
 192 |     |     }
 193 |     | 
 194 |     |     /// @notice assumes that there's only one pool in the system
 195 |     |     /// @dev added to simplify fetching collaterals for MockRewardDistributor
 196 |     |     function getCollateralTypes() external view returns (address[] memory) {
 197 |     |         address[] memory collateralTypes = new address[](4);
 198 |     |         collateralTypes[0] = sUSD;
 199 |     |         collateralTypes[1] = wETH;
 200 |     |         collateralTypes[2] = wBTC;
 201 |     |         collateralTypes[3] = huge;
 202 |     |         return collateralTypes;
 203 |     |     }
 204 |     | 
 205 | *   |     function getShares(
 206 |     |         address user,
 207 |     |         address collateral
 208 |     |     ) external view returns (bool) {
 209 |     |         return shares[user][collateral];
 210 |     |     }
 211 |     | 
 212 |     |     /** 
 213 |     |         Admin
 214 |     |     */
 215 |     |     function setUSDToken(address _usdToken, bytes32 _nodeId) external {
 216 |     |         sUSD = _usdToken;
 217 |     |         vaults[_usdToken].nodeId = _nodeId;
 218 |     |     }
 219 |     | 
 220 |     |     function setWethToken(address _wethToken, bytes32 _nodeId) external {
 221 |     |         wETH = _wethToken;
 222 |     |         vaults[_wethToken].nodeId = _nodeId;
 223 |     |     }
 224 |     | 
 225 |     |     function setWbtcToken(address _wbtcToken, bytes32 _nodeId) external {
 226 |     |         wBTC = _wbtcToken;
 227 |     |         vaults[_wbtcToken].nodeId = _nodeId;
 228 |     |     }
 229 |     | 
 230 | *   |     function setHugeToken(address _hugeToken, bytes32 _nodeId) external {
 231 |     |         huge = _hugeToken;
 232 |     |         vaults[_hugeToken].nodeId = _nodeId;
 233 |     |     }
 234 |     | 
 235 |     |     function setOracleManager(address _oracleManager) external {
 236 |     |         oracleManager = _oracleManager;
 237 |     |     }
 238 |     | 
 239 |     |     function registerMarket(address market) external returns (uint128) {
 240 |     |         return 1;
 241 |     |     }
 242 |     | 
 243 |     |     function setCollateralPrice(
 244 |     |         address collateralType,
 245 |     |         uint256 newPrice
 246 |     |     ) external {
 247 |     |         bytes32 nodeId = vaults[collateralType].nodeId;
 248 |     | 
 249 |     |         // this needs to use the MockOracleManager to set the price for a given collateral type
 250 |     |         MockOracleManager(oracleManager).changePrice(nodeId, int256(newPrice));
 251 |     |     }
 252 |     | 
 253 |     |     /// @notice only used by MockRewardDistributor to simulate distributing reward shares
 254 |     |     function updateRewardDistribution(
 255 |     |         address collateralToken,
 256 |     |         uint256 amount
 257 |     |     ) external {
 258 |     |         vaults[collateralToken].rewardAmount += amount;
 259 |     |     }
 260 |     | 
 261 | *   |     function updateCreditCapacity(uint256 amount, bool increase) external {
 262 | *   |         if (increase) {
 263 |     |             creditCapacity += amount;
 264 |     |         } else {
 265 | *   |             creditCapacity -= amount;
 266 |     |         }
 267 |     |     }
 268 |     | 
 269 |     |     /**
 270 |     |         User Actions
 271 |     |     */
 272 | *   |     function mintUSDToSynthetix(uint256 toMint) external {
 273 | *   |         MockERC20(sUSD).mint(address(this), toMint);
 274 |     |     }
 275 |     | 
 276 | *   |     function burnUSDFromSynthetix(uint256 toBurn) external {
 277 | *   |         MockERC20(sUSD).burn(address(this), toBurn);
 278 |     |     }
 279 |     | 
 280 | *   |     function depositMarketUsd(
 281 |     |         uint128 marketId,
 282 |     |         address msgSender,
 283 |     |         uint256 amount
 284 | *   |     ) external returns (uint256) {
 285 | *   |         MockERC20(sUSD).burn(msgSender, amount);
 286 | *   |         MockERC20(sUSD).mint(address(1), (amount * FEE_PERCENT) / 1e18);
 287 |     | 
 288 |     |         // accounting for user shares for handling rewards that get distributed in a liquidation event
 289 | *   |         vaults[sUSD].totalShares += 1;
 290 | *   |         shares[msgSender][sUSD] = true;
 291 | *   |         creditCapacity += (amount - (amount * FEE_PERCENT) / 1e18);
 292 |     | 
 293 | *   |         return (amount * FEE_PERCENT) / 1e18;
 294 |     |     }
 295 |     | 
 296 | *   |     function withdrawMarketUsd(
 297 |     |         uint128 marketId,
 298 |     |         address target,
 299 |     |         uint256 amount
 300 | *   |     ) external returns (uint256) {
 301 | *   |         MockERC20(sUSD).mint(target, amount);
 302 | *   |         MockERC20(sUSD).mint(address(1), (amount * FEE_PERCENT) / 1e18);
 303 |     | 
 304 |     |         // accounting for user shares for handling rewards that get distributed in a liquidation event
 305 |     |         // if the user has shares in the vault, then they should be decremented
 306 | *   |         if (shares[msg.sender][sUSD]) {
 307 |     |             vaults[sUSD].totalShares -= 1;
 308 |     |             shares[msg.sender][sUSD] = false;
 309 |     |         }
 310 |     | 
 311 | *   |         creditCapacity -= (amount + (amount * FEE_PERCENT) / 1e18);
 312 |     | 
 313 |     |         return (amount * FEE_PERCENT) / 1e18;
 314 |     |     }
 315 |     | 
 316 |     |     /// @notice allows a market to deposit collateral
 317 |     |     /// @dev assumes collateral types with 18 decimals
 318 | *   |     function depositMarketCollateral(
 319 |     |         uint128 marketId,
 320 |     |         address collateralType,
 321 |     |         uint256 tokenAmount
 322 |     |     ) external {
 323 |     |         // NOTE: no fees accounted for in this deposit function, unlike in depositMarketUsd
 324 |     |         // account for token being deposited into a vault
 325 | *   |         vaults[collateralType].collateralAmount += tokenAmount;
 326 |     | 
 327 |     |         // accounting for user shares for handling rewards that get distributed in a liquidation event
 328 | *   |         vaults[collateralType].totalShares += 1;
 329 | *   |         shares[msg.sender][collateralType] = true;
 330 |     | 
 331 |     |         // transfer collateral token
 332 | *   |         MockERC20(collateralType).transferFrom(
 333 |     |             msg.sender,
 334 | *   |             address(this),
 335 |     |             tokenAmount
 336 |     |         );
 337 |     |     }
 338 |     | 
 339 |     |     /// @notice allows a market to withdraw collateral that it has previously deposited.
 340 |     |     /// @dev marketId is irrelevant because this just mocks total accounting into and out of system
 341 | *   |     function withdrawMarketCollateral(
 342 |     |         uint128 marketId,
 343 |     |         address collateralType,
 344 |     |         uint256 tokenAmount
 345 |     |     ) external {
 346 |     |         // account for token being removed from a vault
 347 | *   |         vaults[collateralType].collateralAmount -= tokenAmount;
 348 |     | 
 349 |     |         // accounting for user shares for handling rewards that get distributed in a liquidation event
 350 |     |         // vaults[collateralType].totalShares -= 1;
 351 |     |         // shares[msg.sender][collateralType] = false;
 352 |     | 
 353 | *   |         MockERC20(collateralType).transfer(
 354 | *   |             ERC2771Context._msgSender(),
 355 |     |             tokenAmount
 356 |     |         );
 357 | *   |         emit Debug("withdraw");
 358 |     |     }
 359 |     | }
 360 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/mocks/MockVaultModule.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {MockSynthetixV3} from "./MockSynthetixV3.sol";
  5 |     | import {PerpsMarketFactoryModule} from "../../modules/PerpsMarketFactoryModule.sol";
  6 |     | import {console2} from "lib/forge-std/src/Test.sol";
  7 |     | 
  8 | *   | contract MockVaultModule {
  9 |     |     MockSynthetixV3 internal v3Mock;
 10 |     |     PerpsMarketFactoryModule internal perpMarketFactoryModuleImpl;
 11 |     |     address internal perps;
 12 |     | 
 13 |     |     constructor(MockSynthetixV3 _v3Mock, address _perps) {
 14 |     |         v3Mock = _v3Mock;
 15 |     |         perps = _perps;
 16 |     |     }
 17 |     | 
 18 |     |     function setPerpMarketFactoryModuleImpl(
 19 |     |         PerpsMarketFactoryModule _perpMarketFactoryModuleImpl
 20 |     |     ) external {
 21 |     |         perpMarketFactoryModuleImpl = _perpMarketFactoryModuleImpl;
 22 |     |     }
 23 |     | 
 24 | *   |     function delegateCollateral(
 25 |     |         uint128 accountId,
 26 |     |         uint128 poolId,
 27 |     |         address collateralType,
 28 |     |         uint256 newCollateralAmountD18,
 29 |     |         uint256 leverage,
 30 |     |         uint128 marketId
 31 | *   |     ) external {
 32 | *   |         uint256 currentCreditCapacity = v3Mock.creditCapacity();
 33 | *   |         newCollateralAmountD18 = newCollateralAmountD18 % 10_000_000 ether;
 34 |     | 
 35 | *   |         bool increase;
 36 |     |         // simplifying collateral delegation system from vault by increasing if adding more than current credit capacity and decreasing if less
 37 | *   |         if (newCollateralAmountD18 > currentCreditCapacity) {
 38 |     |             increase = true;
 39 |     |             v3Mock.updateCreditCapacity(newCollateralAmountD18, increase);
 40 | *   |         } else {
 41 |     |             // if market is below minimumCredit, LPs are blocked from withdrawals
 42 | *   |             (bool success, bytes memory returnData) = perps.call(
 43 | *   |                 abi.encodeWithSelector(perpMarketFactoryModuleImpl.minimumCredit.selector, marketId)
 44 |     |             );
 45 | *   |             assert(success);
 46 | *   |             uint128 minimumMarketCreditCapacity = abi.decode(returnData, (uint128));
 47 | *   |             console2.log(
 48 |     |                 "delegateCollateral::minimumMarketCreditCapacity",
 49 | *   |                 minimumMarketCreditCapacity
 50 |     |             );
 51 | *   |             require(currentCreditCapacity > minimumMarketCreditCapacity, "isCapacityLocked");
 52 |     | 
 53 | *   |             increase = false;
 54 | *   |             v3Mock.updateCreditCapacity(newCollateralAmountD18, increase);
 55 |     |         }
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./Properties_ORD.sol";
  5 |     | import "./Properties_LIQ.sol";
  6 |     | import "./Properties_MGN.sol";
  7 |     | 
  8 |     | abstract contract Properties is Properties_ORD, Properties_MGN, Properties_LIQ {}
  9 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/PropertiesBase.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
  5 |     | 
  6 |     | import "./PropertiesDescriptions.sol";
  7 |     | import "../helper/BeforeAfter.sol";
  8 |     | 
  9 |     | abstract contract PropertiesBase is FuzzBase, BeforeAfter, PropertiesDescriptions {}
 10 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/PropertiesDescriptions.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | contract PropertiesDescriptions {
   4 |     |     string constant MGN_01 =
   5 |     |         "MGN-01: Position is never liquidatable after a successful margin withdraw";
   6 |     |     // no flagged in perps
   7 |     |     // string constant MGN_02 =
   8 |     |     //     "MGN-02: A modify collateral call will always revert for an account with a flagged position";
   9 |     |     string constant MGN_03 =
  10 |     |         "MGN-03: A modify collateral call will always revert for an account that has a pending order";
  11 |     |     string constant MGN_04 =
  12 |     |         "MGN-04: If an account's collateral is 0, then the account's debt must also be 0";
  13 |     |     string constant MGN_05 =
  14 |     |         "MGN-05: depositedCollaterals array should be adjusted by amount of collateral modified";
  15 |     |     string constant MGN_06 =
  16 |     |         "MGN-06: If sUSD collateral modified, minimumCredit should be updated by that amount";
  17 |     |     string constant MGN_07 =
  18 |     |         "MGN-07: There should be no reportedDebt if all collateral has been withdrawn and skew=0";
  19 |     |     string constant MGN_08 =
  20 |     |         "MGN-08: Sum of collateral token values should be the totalCollateralValueUsd stored in the market";
  21 |     |     //no withaw all function
  22 |     |     // string constant MGN_09 =
  23 |     |     //     "MGN-09: After call to withdrawAllCollateral actor account margin debt should be 0";
  24 |     |     // string constant MGN_10 =
  25 |     |     //     "MGN-10: All accountMargin.collaterals should be 0 after call to withdrawAllCollateral()";
  26 |     |     // string constant MGN_11 =
  27 |     |     //     "MGN-11: Market collateral should decrease by amount of collateral user had deposited before withdrawing all collateral";
  28 |     |     string constant MGN_12 =
  29 |     |         "MGN-12: User cannot withdraw more non-susd collateral than they deposited";
  30 |     |     string constant MGN_13 =
  31 |     |         "MGN-13: activeCollateralTypesIt should never happen that a user has an amount of collateral deposited with a token > 18 decimals precision and withdrawing lead to precision loss.";
  32 |     | 
  33 |     |     string constant LIQ_01 = "LIQ-01: isPositionLiquidatable never reverts";
  34 |     |     string constant LIQ_02 =
  35 |     |         "LIQ-02: If a position is flagged for liquidation before any function call, the position after is always either flagged for liquidation, or no longer exists";
  36 |     |     string constant LIQ_03 =
  37 |     |         "LIQ-03: remainingLiquidatableSizeCapacity is strictly decreasing immediately after a successful liquidation";
  38 |     |     string constant LIQ_04 =
  39 |     |         "LIQ-04: If a user gets successfully flagged, their collateral will always be 0";
  40 |     |     string constant LIQ_05 =
  41 |     |         "LIQ-05: The sUSD balance of a user that successfully flags a position is strictly increasing";
  42 |     |     string constant LIQ_06 =
  43 |     |         "LIQ-06: The sUSD balance of a user that successfully flags a position increases less or equal to maxKeeperFee";
  44 |     |     string constant LIQ_07 =
  45 |     |         "LIQ-07:  User should not be able to gain more in keeper fees than collateral lost in liquidatePosition";
  46 |     |     string constant LIQ_08 =
  47 |     |         "LIQ-08: A user can be liquidated if minimum credit is not met";
  48 |     |     string constant LIQ_09 =
  49 |     |         "LIQ-09: All account margin collateral should be removed after full liquidation";
  50 |     |     string constant LIQ_10 =
  51 |     |         "LIQ-10: Flagged positions should be liquidated even if they have a health factor > 1";
  52 |     |     string constant LIQ_11 =
  53 |     |         "LIQ-11: Market deposited collateral should decrease after full liquidation by the account collaterla that was liquidated";
  54 |     |     string constant LIQ_12 =
  55 |     |         "LIQ-12: If a position has position.size == 0, flagger should be set to address(0)";
  56 |     |     string constant LIQ_13 =
  57 |     |         "LIQ-13: After user position flagged, user should have 0 collateral value";
  58 |     |     string constant LIQ_14 =
  59 |     |         "LIQ-14: After user is flagged, market collateral should decreases by user collateral amount";
  60 |     |     string constant LIQ_15 =
  61 |     |         "LIQ-15: User should not be able to gain more in keeper fees than collateral lost in liquidateMarginOnly";
  62 |     | 
  63 |     |     string constant ORD_01 =
  64 |     |         "ORD-01: If an account has an order commited that is unexpired, a subsequent commit order call will always revert";
  65 |     |     string constant ORD_02 =
  66 |     |         "ORD-02: The sizeDelta of an order is always 0 after a successful settle order call";
  67 |     |     string constant ORD_03 =
  68 |     |         "ORD-03: An order immediately after a successful settle order call, is never liquidatable";
  69 |     |     string constant ORD_04 =
  70 |     |         "ORD-04: If a user successfully settles an order, their sUSD balance is strictly increasing";
  71 |     |     string constant ORD_05 =
  72 |     |         "ORD-05: The sUSD balance of a user that successfully cancels an order for another user is strictly increasing";
  73 |     |     string constant ORD_06_WETH =
  74 |     |         "ORD-06_WETH: The minimum credit requirement must be met after increase order settlement";
  75 |     |     string constant ORD_06_WBTC =
  76 |     |         "ORD-06_WBTC: The minimum credit requirement must be met after increase order settlement";
  77 |     |     string constant ORD_07 =
  78 |     |         "ORD-07: Utilization is between 0% and 100% before and after order settlement";
  79 |     |     string constant ORD_08_WETH =
  80 |     |         "ORD_08_WETH: non-SUSD collateral should stay the same after profitably settling order";
  81 |     |     string constant ORD_08_WBTC =
  82 |     |         "ORD_08_WBTC: non-SUSD collateral should stay the same after profitably settling order";
  83 |     |     string constant ORD_09 =
  84 |     |         "ORD-09: Should always give premium when increasing skew and discount when decreasing skew";
  85 |     |     string constant ORD_10 =
  86 |     |         "ORD-10: market.currentUtilizationAccruedComputed decreases";
  87 |     |     string constant ORD_11 =
  88 |     |         "ORD-11: market.reportedDebt != positions.sum(p.collateralUsd + p.pricePnL + p.pendingFunding - p.pendingUtilization - p.debtUsd)";
  89 |     |     string constant ORD_12 =
  90 |     |         "ORD-12: An account should not be liquidatable by margin only after order settlement";
  91 |     |     string constant ORD_13 =
  92 |     |         "ORD-13: An account should not be liquidatable by margin only after order cancelled";
  93 |     |     string constant ORD_14 =
  94 |     |         "ORD-14: Market size should always be the sum of individual position sizes";
  95 |     |     string constant ORD_15 =
  96 |     |         "ORD-15: Position should no be liquidatable after committing an order";
  97 |     |     string constant ORD_16 =
  98 |     |         "ORD-16: Position should no be liquidatable after cancelling an order";
  99 |     |     string constant ORD_17 =
 100 |     |         "ORD-17: Position should no be liquidatable after cancelling a stale order";
 101 |     |     string constant ORD_18 =
 102 |     |         "ORD-18:  Open positions should always be added / removed from the openPositionMarketIds array.";
 103 |     |     string constant ORD_19 =
 104 |     |         "ORD-19:  All tokens in the activeCollateralTypes array from individual accounts should be included in the global activeCollateralTypes array..";
 105 |     | }
 106 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties_LIQ.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PropertiesBase.sol";
   5 |     | import {console2} from "lib/forge-std/src/Test.sol";
   6 |     | 
   7 |     | abstract contract Properties_LIQ is PropertiesBase {
   8 | *   |     function invariant_LIQ_01(uint128 account) internal {
   9 | *   |         fl.log("ACCOUNT LIQ_01:", account);
  10 | *   |         fl.t(states[0].actorStates[account].isPositionLiquidatablePassing, LIQ_01);
  11 | *   |         fl.t(states[1].actorStates[account].isPositionLiquidatablePassing, LIQ_01);
  12 |     |     }
  13 |     | 
  14 |     |     //LIQ_02 N/A no flaggedBy
  15 |     | 
  16 |     |     function invariant_LIQ_03() internal {
  17 |     |         console2.log(
  18 |     |             "WETH Liquidation Capacity (Before):",
  19 |     |             states[0].wethMarket.liquidationCapacity
  20 |     |         );
  21 |     |         console2.log(
  22 |     |             "WETH Liquidation Capacity (After):",
  23 |     |             states[1].wethMarket.liquidationCapacity
  24 |     |         );
  25 |     | 
  26 |     |         console2.log(
  27 |     |             "WBTC Liquidation Capacity (Before):",
  28 |     |             states[0].wbtcMarket.liquidationCapacity
  29 |     |         );
  30 |     |         console2.log(
  31 |     |             "WBTC Liquidation Capacity (After):",
  32 |     |             states[1].wbtcMarket.liquidationCapacity
  33 |     |         );
  34 |     |         bool wethCapacityChanged = states[1].wethMarket.liquidationCapacity !=
  35 |     |             states[0].wethMarket.liquidationCapacity;
  36 |     |         bool wbtcCapacityChanged = states[1].wbtcMarket.liquidationCapacity !=
  37 |     |             states[0].wbtcMarket.liquidationCapacity;
  38 |     | 
  39 |     |         console2.log("WBTC Capacity Changed:", wbtcCapacityChanged);
  40 |     |         console2.log("WETH Capacity Changed:", wethCapacityChanged);
  41 |     | 
  42 |     |         // Check if neither changed and was not zero
  43 |     |         if (!wethCapacityChanged && !wbtcCapacityChanged) {
  44 |     |             fl.t(
  45 |     |                 states[0].wethMarket.liquidationCapacity == 0 &&
  46 |     |                     states[0].wbtcMarket.liquidationCapacity == 0,
  47 |     |                 "LIQ_03: At least one market should have zero initial capacity if unchanged"
  48 |     |             );
  49 |     |         }
  50 |     | 
  51 |     |         // Check WETH market
  52 |     |         if (wethCapacityChanged) {
  53 |     |             if (states[0].wethMarket.liquidationCapacity != 0) {
  54 |     |                 fl.lt(
  55 |     |                     states[1].wethMarket.liquidationCapacity,
  56 |     |                     states[0].wethMarket.liquidationCapacity,
  57 |     |                     "LIQ_03: WETH capacity should decrease"
  58 |     |                 );
  59 |     |             } else {
  60 |     |                 fl.eq(
  61 |     |                     states[1].wethMarket.liquidationCapacity,
  62 |     |                     states[0].wethMarket.liquidationCapacity,
  63 |     |                     "LIQ_03: WETH capacity should remain zero"
  64 |     |                 );
  65 |     |             }
  66 |     |         }
  67 |     | 
  68 |     |         // Check WBTC market
  69 |     |         if (wbtcCapacityChanged) {
  70 |     |             if (states[0].wbtcMarket.liquidationCapacity != 0) {
  71 |     |                 fl.lt(
  72 |     |                     states[1].wbtcMarket.liquidationCapacity,
  73 |     |                     states[0].wbtcMarket.liquidationCapacity,
  74 |     |                     "LIQ_03: WBTC capacity should decrease"
  75 |     |                 );
  76 |     |             } else {
  77 |     |                 fl.eq(
  78 |     |                     states[1].wbtcMarket.liquidationCapacity,
  79 |     |                     states[0].wbtcMarket.liquidationCapacity,
  80 |     |                     "LIQ_03: WBTC capacity should remain zero"
  81 |     |                 );
  82 |     |             }
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     //LIQ_04 N/A no flaggedBy
  87 |     |     //LIQ_05 N/A no flaggedBy
  88 |     |     //LIQ_06 N/A no flaggedBy
  89 |     |     //LIQ_07 N/A no flaggedBy
  90 |     | 
  91 |     |     function invariant_LIQ_08() internal {
  92 |     |         fl.t(states[0].delegatedCollateralValueUsd >= states[0].minimumCredit, LIQ_08);
  93 |     |     }
  94 |     | 
  95 |     |     function invariant_LIQ_09(uint128 account) internal {
  96 |     |         if (
  97 |     |             states[1].actorStates[account].wethMarket.positionSize == 0 &&
  98 |     |             states[1].actorStates[account].wbtcMarket.positionSize == 0
  99 |     |         ) {
 100 |     |             fl.t(states[1].actorStates[account].availableMargin == 0, LIQ_09);
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     //LIQ_10 N/A no flaggedBy
 105 |     | 
 106 |     |     function invariant_LIQ_11(uint128 account) internal {
 107 |     |         if (
 108 |     |             states[1].actorStates[account].wethMarket.positionSize == 0 &&
 109 |     |             states[1].actorStates[account].wbtcMarket.positionSize == 0
 110 |     |         ) {
 111 |     |             fl.log("Margin before:", states[0].actorStates[account].availableMargin);
 112 |     |             fl.log("Margin after:", states[1].actorStates[account].availableMargin);
 113 |     |             // if position was fully liquidated, market collateral should be decreased by user's margin amount
 114 |     |             fl.eq(
 115 |     |                 states[0].totalCollateralValueUsd - states[1].totalCollateralValueUsd,
 116 |     |                 int256(states[0].actorStates[account].totalCollateralValue),
 117 |     |                 // int256(MathUtil.abs(states[0].actorStates[account].availableMargin)),
 118 |     |                 LIQ_11
 119 |     |             );
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     //LIQ_12 N/A no flaggedBy
 124 |     |     //LIQ_13 N/A no flaggedBy
 125 |     |     //LIQ_14 N/A no flaggedBy
 126 |     | 
 127 |     |     function invariant_LIQ_15(uint128 account) internal {
 128 |     |         fl.gte(
 129 |     |             states[0].actorStates[account].totalCollateralValue -
 130 |     |                 states[1].actorStates[account].totalCollateralValue,
 131 |     |             states[0].actorStates[account].marginKeeperFee, //TODO: DG review is it maxLiquidationReward from perpsAccountModuleImpl.getRequiredMargins?
 132 |     |             LIQ_15
 133 |     |         );
 134 |     |     }
 135 |     | }
 136 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties_MGN.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PropertiesBase.sol";
   5 |     | 
   6 |     | abstract contract Properties_MGN is PropertiesBase {
   7 |     |     function invariant_MGN_01(uint128 accountId) internal {
   8 |     |         fl.t(!states[1].actorStates[accountId].isPositionLiquidatable, MGN_01);
   9 |     |     }
  10 |     | 
  11 |     |     //MGN_02 FlaggedBy is N/A
  12 |     | 
  13 | *   |     function invariant_MGN_03(uint128 accountId) internal {
  14 | *   |         fl.t(
  15 | *   |             states[0].actorStates[accountId].sizeDelta == 0 ||
  16 |     |                 states[0].actorStates[accountId].isOrderExpired,
  17 | *   |             MGN_03
  18 |     |         );
  19 |     |     }
  20 |     | 
  21 | *   |     function invariant_MGN_04(uint128 accountId) internal {
  22 |     |         //here is a total collateral value of speecific account
  23 | *   |         if (states[1].actorStates[accountId].totalCollateralValue == 0) {
  24 |     |             fl.eq(states[1].actorStates[accountId].debt, 0, MGN_04);
  25 |     |         }
  26 |     |     }
  27 |     | 
  28 | *   |     function invariant_MGN_05(int256 amountDelta, address collateral) internal {
  29 | *   |         if (amountDelta != 0 && collateral == address(wethTokenMock)) {
  30 | *   |             fl.eq(
  31 | *   |                 int256(states[1].depositedWethCollateral),
  32 | *   |                 int256(states[0].depositedWethCollateral) + amountDelta,
  33 |     |                 MGN_05
  34 |     |             );
  35 |     |         }
  36 |     |     }
  37 |     | 
  38 |     |     // "./perps-market/contracts/modules/PerpsMarketFactoryModule.sol::minimumCredit"
  39 | *   |     function invariant_MGN_06(int256 amountDelta, address collateral) internal {
  40 | *   |         if (amountDelta != 0 && collateral == address(sUSDTokenMock)) {
  41 | *   |             fl.eq(
  42 | *   |                 int256(states[1].minimumCredit),
  43 | *   |                 int256(states[0].minimumCredit) + amountDelta,
  44 | *   |                 MGN_06
  45 |     |             );
  46 |     |         }
  47 |     |     }
  48 | *   |     function invariant_MGN_13(int256 amountDelta, address collateral) internal {
  49 | *   |         if (amountDelta != 0 && collateral == address(wbtcTokenMock)) {
  50 | *   |             fl.eq(
  51 | *   |                 int256(states[1].depositedWbtcCollateral),
  52 | *   |                 int256(states[0].depositedWbtcCollateral) + amountDelta,
  53 | *   |                 MGN_05 //TODO: split btc and eth desc
  54 |     |             );
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     //N/A for perps
  59 |     |     // function invariant_MGN_07() internal {
  60 |     |     //     // TODO: DG review
  61 |     |     //     //Q1
  62 |     |     //     //totalCollateralValueUsd is a total for all markets
  63 |     |     //     // skew is a value that was taken from PerpsMarket::Data::skew
  64 |     |     //     // so skew is different for every market
  65 |     |     //     //Q2 or is it skew for SuperMarket
  66 |     |     //     //Q3 this skew value in logs is always zero, something with config
  67 |     | 
  68 |     |     //     if (states[1].totalCollateralValueUsd == 0 && states[1].skew == 0)
  69 |     |     //         fl.eq(states[1].reportedDebt, 0, MGN_07);
  70 |     |     // }
  71 |     | 
  72 |     |     function invariant_MGN_08() internal {
  73 |     |         console2.log(
  74 |     |             "states[1].totalCollateralValueUsd",
  75 |     |             states[1].totalCollateralValueUsd
  76 |     |         );
  77 |     |         console2.log(
  78 |     |             "states[1].totalCollateralValueUsdGhost",
  79 |     |             states[1].totalCollateralValueUsdGhost
  80 |     |         );
  81 |     | 
  82 |     |         fl.eq(
  83 |     |             states[1].totalCollateralValueUsd,
  84 |     |             states[1].totalCollateralValueUsdGhost,
  85 |     |             MGN_08
  86 |     |         );
  87 |     |     }
  88 |     | 
  89 |     |     //MGN_09 is N/A now WithdrawAll function
  90 |     |     //MGN_10 is N/A now WithdrawAll function
  91 |     |     //MGN_11 is N/A now WithdrawAll function
  92 |     | 
  93 |     |     function invariant_MGN_12(uint128 accountId, uint collateralId) internal {
  94 |     |         // market collateral can only decrease by up to user's deposited weth amount value on withdrawal
  95 |     |         if (collateralId == 0) {
  96 |     |             fl.lte(
  97 |     |                 states[0].depositedSusdCollateral -
  98 |     |                     states[1].depositedSusdCollateral,
  99 |     |                 states[0].actorStates[accountId].collateralAmountSUSD,
 100 |     |                 MGN_12
 101 |     |             );
 102 |     |         }
 103 |     |         if (collateralId == 1) {
 104 |     |             fl.lte(
 105 |     |                 states[0].depositedWethCollateral -
 106 |     |                     states[1].depositedWethCollateral,
 107 |     |                 states[0].actorStates[accountId].collateralAmountWETH,
 108 |     |                 MGN_12
 109 |     |             );
 110 |     |         }
 111 |     |         if (collateralId == 2) {
 112 | *   |             fl.lte(
 113 |     |                 states[0].depositedWbtcCollateral -
 114 |     |                     states[1].depositedWbtcCollateral,
 115 |     |                 states[0].actorStates[accountId].collateralAmountWBTC,
 116 |     |                 MGN_12
 117 |     |             );
 118 |     |         }
 119 |     |     }
 120 |     | 
 121 |     |     function invariant_MGN_13(uint128 accountId, uint collateralId) internal {
 122 |     |         if (collateralId == 3) {
 123 |     |             fl.eq(
 124 |     |                 states[1].actorStates[accountId].collateralAmountHUGE %
 125 |     |                     (10 ** (hugePrecisionTokenMock.decimals() - 18)),
 126 |     |                 0,
 127 |     |                 MGN_13
 128 |     |             );
 129 |     |         }
 130 |     |     }
 131 |     | }
 132 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/properties/Properties_ORD.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PropertiesBase.sol";
   5 |     | import {MathUtil} from "../../utils/MathUtil.sol";
   6 |     | import {console2} from "lib/forge-std/src/Test.sol";
   7 |     | 
   8 |     | abstract contract Properties_ORD is PropertiesBase {
   9 | *   |     function invariant_ORD_01(uint128 account) internal {
  10 | *   |         fl.t(
  11 | *   |             states[0].actorStates[account].sizeDelta == 0 ||
  12 |     |                 states[0].actorStates[account].isOrderExpired,
  13 | *   |             ORD_01
  14 |     |         );
  15 |     |     }
  16 |     | 
  17 | *   |     function invariant_ORD_02(uint128 account) internal {
  18 | *   |         fl.eq(states[1].actorStates[account].sizeDelta, 0, ORD_02);
  19 |     |     }
  20 |     | 
  21 |     |     function invariant_ORD_03(uint128 account) internal {
  22 |     |         fl.t(!states[1].actorStates[account].isPositionLiquidatable, ORD_03);
  23 |     |     }
  24 |     | 
  25 | *   |     function invariant_ORD_04(uint128 account) internal {
  26 | *   |         fl.gt(
  27 | *   |             states[1].actorStates[account].sUSDBalance,
  28 | *   |             states[0].actorStates[account].sUSDBalance,
  29 | *   |             ORD_04
  30 |     |         );
  31 |     |     }
  32 |     | 
  33 |     |     function invariant_ORD_05(uint128 account) internal {
  34 |     |         fl.gt(
  35 |     |             states[1].actorStates[account].sUSDBalance,
  36 |     |             states[0].actorStates[account].sUSDBalance,
  37 |     |             ORD_05
  38 |     |         );
  39 |     |     }
  40 |     | 
  41 |     |     function invariant_ORD_06(uint128 account, uint128 marketId) internal {
  42 |     |         if (marketId == 1) {
  43 |     |             bool positionDecreasing = MathUtil.sameSide(
  44 |     |                 states[0].actorStates[account].wethMarket.positionSize,
  45 |     |                 states[1].actorStates[account].wethMarket.positionSize
  46 |     |             ) &&
  47 |     |                 MathUtil.abs(
  48 |     |                     states[1].actorStates[account].wethMarket.positionSize
  49 |     |                 ) < //wethMarket.positionSize
  50 |     |                 MathUtil.abs(
  51 |     |                     states[0].actorStates[account].wethMarket.positionSize
  52 |     |                 );
  53 |     |             if (!positionDecreasing) {
  54 |     |                 // TODO: DG review same Q abt min credit. Is it general value or per market.
  55 |     |                 fl.t(
  56 |     |                     states[1].minimumCredit <=
  57 |     |                         states[1].delegatedCollateralValueUsd,
  58 |     |                     ORD_06_WETH
  59 |     |                 );
  60 |     |             }
  61 |     |         } else if (marketId == 2) {
  62 |     |             bool positionDecreasing = MathUtil.sameSide(
  63 |     |                 states[0].actorStates[account].wbtcMarket.positionSize,
  64 |     |                 states[1].actorStates[account].wbtcMarket.positionSize
  65 |     |             ) &&
  66 |     |                 MathUtil.abs(
  67 |     |                     states[1].actorStates[account].wbtcMarket.positionSize
  68 |     |                 ) < //wethMarket.positionSize
  69 |     |                 MathUtil.abs(
  70 |     |                     states[0].actorStates[account].wbtcMarket.positionSize
  71 |     |                 );
  72 |     |             if (!positionDecreasing) {
  73 |     |                 fl.t(
  74 |     |                     states[1].minimumCredit <= states[1].delegatedCollateral,
  75 |     |                     ORD_06_WBTC
  76 |     |                 );
  77 |     |             }
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     function invariant_ORD_07() internal {
  82 |     |         uint256 utilizationBefore = states[0].utilizationRate;
  83 |     |         uint256 utilizationAfter = states[1].utilizationRate;
  84 |     |         fl.log("Utilization before:", utilizationBefore);
  85 |     |         fl.log("Utilization after:", utilizationAfter);
  86 |     |         fl.t(utilizationBefore >= 0 && utilizationBefore <= 1e18, ORD_07);
  87 |     |         fl.t(utilizationAfter >= 0 && utilizationAfter <= 1e18, ORD_07);
  88 |     |     }
  89 |     | 
  90 | *   |     function invariant_ORD_08(uint128 account) internal {
  91 |     |         // TODO: introduce markets
  92 | *   |         if (
  93 | *   |             states[1].actorStates[account].collateralAmountSUSD >=
  94 | *   |             states[0].actorStates[account].collateralAmountSUSD
  95 |     |         ) {
  96 | *   |             fl.eq(
  97 | *   |                 states[0].actorStates[account].collateralAmountWETH,
  98 | *   |                 states[1].actorStates[account].collateralAmountWETH,
  99 | *   |                 ORD_08_WETH
 100 |     |             );
 101 | *   |             fl.eq(
 102 | *   |                 states[0].actorStates[account].collateralAmountWBTC,
 103 | *   |                 states[1].actorStates[account].collateralAmountWBTC,
 104 | *   |                 ORD_08_WBTC
 105 |     |             );
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     event DebugSkeww(int256 a, string s);
 110 |     |     event DebugUint(uint256 a, string s);
 111 |     | 
 112 | *   |     function invariant_ORD_09(uint128 account, uint128 marketId) internal {
 113 |     |         // Upscale price to account for -8 exponent.
 114 |     |         //TODO: introduce markets
 115 | *   |         bool isLong = states[0].actorStates[account].sizeDelta > 0;
 116 |     |         // Trader gets better price than Pyth price if skew is decreased.
 117 |     | 
 118 | *   |         if (marketId == 1) {
 119 | *   |             uint256 oraclePrice = uint256(
 120 | *   |                 pythWrapper.getBenchmarkPrice(WETH_PYTH_PRICE_FEED_ID, 0)
 121 |     |             );
 122 | *   |             console2.log("weth pyth oracle price", oraclePrice);
 123 | *   |             console2.log("after skew");
 124 | *   |             console2.logInt(states[1].wethMarket.skew);
 125 | *   |             console2.log("after size", states[1].wethMarket.marketSize);
 126 | *   |             console2.log("before skew");
 127 | *   |             console2.logInt(states[0].wethMarket.skew);
 128 | *   |             console2.log("before size", states[0].wethMarket.marketSize);
 129 | *   |             if (
 130 | *   |                 MathUtil.abs(states[1].wethMarket.skew) <
 131 | *   |                 MathUtil.abs(states[0].wethMarket.skew)
 132 |     |             ) {
 133 | *   |                 if (isLong) {
 134 | *   |                     fl.lte(
 135 | *   |                         states[0].actorStates[account].fillPriceWETH,
 136 | *   |                         oraclePrice,
 137 | *   |                         ORD_09
 138 |     |                     );
 139 |     |                 } else {
 140 | *   |                     fl.gte(
 141 | *   |                         states[0].actorStates[account].fillPriceWETH,
 142 | *   |                         oraclePrice,
 143 | *   |                         ORD_09
 144 |     |                     );
 145 |     |                 }
 146 |     |             }
 147 | *   |         } else if (marketId == 2) {
 148 | *   |             uint256 oraclePrice = uint256(
 149 | *   |                 pythWrapper.getBenchmarkPrice(WBTC_PYTH_PRICE_FEED_ID, 0)
 150 |     |             );
 151 | *   |             console2.log("wbtc pyth oracle price", oraclePrice);
 152 | *   |             console2.log("after skew");
 153 | *   |             console2.logInt(states[1].wbtcMarket.skew);
 154 | *   |             console2.log("before skew");
 155 | *   |             console2.logInt(states[0].wbtcMarket.skew);
 156 | *   |             if (
 157 | *   |                 MathUtil.abs(states[1].wbtcMarket.skew) <
 158 | *   |                 MathUtil.abs(states[0].wbtcMarket.skew)
 159 |     |             ) {
 160 | *   |                 if (isLong) {
 161 |     |                     fl.lte(
 162 |     |                         states[0].actorStates[account].fillPriceWBTC,
 163 |     |                         oraclePrice,
 164 |     |                         ORD_09
 165 |     |                     );
 166 |     |                 } else {
 167 | *   |                     fl.gte(
 168 | *   |                         states[0].actorStates[account].fillPriceWBTC,
 169 | *   |                         oraclePrice,
 170 | *   |                         ORD_09
 171 |     |                     );
 172 |     |                 }
 173 |     |             }
 174 |     |         }
 175 |     |     }
 176 |     | 
 177 |     |     function invariant_ORD_10() internal {
 178 |     |         // utilization rate is always between 0 and 100%
 179 |     |         fl.lte(states[1].utilizationRate, 1e18, ORD_10);
 180 |     |         fl.gte(states[1].utilizationRate, 0, ORD_10);
 181 |     |     }
 182 |     | 
 183 |     |     function invariant_ORD_11() internal {
 184 |     |         console2.log("reported debt", states[1].reportedDebt);
 185 |     |         console2.log("reportedDebtGhost", states[1].reportedDebtGhost);
 186 |     | 
 187 |     |         if (
 188 |     |             MathUtil.abs(states[1].reportedDebt - states[1].reportedDebtGhost) >
 189 |     |             1000
 190 |     |         ) {
 191 |     |             fl.eq(states[1].reportedDebt, states[1].reportedDebtGhost, ORD_11);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 | *   |     function invariant_ORD_12(uint128 account) internal {
 196 | *   |         fl.t(!states[1].actorStates[account].isMarginLiquidatable, ORD_12);
 197 |     |     }
 198 |     | 
 199 |     |     function invariant_ORD_13(uint128 account) internal {
 200 |     |         fl.t(!states[1].actorStates[account].isMarginLiquidatable, ORD_13);
 201 |     |     }
 202 |     | 
 203 |     |     function invariant_ORD_14() internal {
 204 |     |         fl.eq(
 205 |     |             states[1].wbtcMarket.marketSize + states[1].wethMarket.marketSize,
 206 |     |             states[1].marketSizeGhost,
 207 |     |             ORD_14
 208 |     |         );
 209 |     |     }
 210 |     | 
 211 | *   |     function invariant_ORD_15(uint128 account) internal {
 212 | *   |         fl.t(!states[1].actorStates[account].isPositionLiquidatable, ORD_15);
 213 |     |     }
 214 |     | 
 215 |     |     function invariant_ORD_16(uint128 account) internal {
 216 |     |         fl.t(!states[1].actorStates[account].isPositionLiquidatable, ORD_16);
 217 |     |     }
 218 |     | 
 219 |     |     //ORD_17 N/A no stale orders here
 220 |     | 
 221 |     | 
 222 |     | 
 223 |     |     function invariant_ORD_18(uint128 account, uint128 marketId) internal {
 224 |     |         if (states[1].actorStates[account].openPositionMarketIds.length != 0) {
 225 |     |             bool containsMarketId = false;
 226 |     |             for (
 227 |     |                 uint i = 0;
 228 |     |                 i < states[1].actorStates[account].openPositionMarketIds.length;
 229 |     |                 i++
 230 |     |             ) {
 231 |     |                 if (
 232 |     |                     states[1].actorStates[account].openPositionMarketIds[i] ==
 233 |     |                     marketId
 234 |     |                 ) {
 235 |     |                     containsMarketId = true;
 236 |     |                     break;
 237 |     |                 }
 238 |     |             }
 239 |     |             fl.t(containsMarketId, ORD_18);
 240 |     |         }
 241 |     |     }
 242 |     | 
 243 | *   |     function invariant_ORD_19(uint128 account) internal {
 244 | *   |         uint128[] memory accountCollateralTypes = states[1]
 245 |     |             .actorStates[account]
 246 |     |             .activeCollateralTypes;
 247 | *   |         uint128[] memory globalCollateralTypes = states[1]
 248 |     |             .globalCollateralTypes;
 249 |     | 
 250 | *   |         if (accountCollateralTypes.length != 0) {
 251 | *   |             for (uint i = 0; i < accountCollateralTypes.length; i++) {
 252 | *   |                 uint128 collateralType = accountCollateralTypes[i];
 253 | *   |                 bool found = false;
 254 |     | 
 255 | *   |                 for (uint j = 0; j < globalCollateralTypes.length; j++) {
 256 | *   |                     if (collateralType == globalCollateralTypes[j]) {
 257 | *   |                         found = true;
 258 | *   |                         break;
 259 |     |                     }
 260 |     |                 }
 261 |     | 
 262 | *   |                 fl.t(found, ORD_19);
 263 |     |             }
 264 |     |         }
 265 |     |     }
 266 |     | }
 267 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/util/CheckCaller.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | import {console2} from "lib/forge-std/src/Test.sol";
  3 |     | 
  4 |     | contract CheckCaller {
  5 |     |     function checkCaller() public returns (address) {
  6 |     |         console2.log("CheckCaller::msg.sender", msg.sender);
  7 |     |         console2.log("CheckCaller::tx.origin", tx.origin);
  8 |     | 
  9 |     |         return msg.sender;
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/util/FunctionCalls.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   5 |     | import "../helper/FuzzStorageVariables.sol";
   6 |     | import {AsyncOrder} from "../../storage/AsyncOrder.sol";
   7 |     | 
   8 |     | contract FunctionCalls is FuzzBase, FuzzStorageVariables {
   9 |     |     event ModifyCollateralCall(uint128 accountId, uint128 collateralId, int256 amountDelta);
  10 |     |     event PayDebtCall(uint128 accountId, uint128 amount);
  11 |     |     event SettleOrderCall(address settleUser, uint128 accountId);
  12 |     |     event CancelOrderCall(address settleUser, uint128 accountId);
  13 |     |     event CommitOrderCall(
  14 |     |         uint128 accountId,
  15 |     |         uint128 marketId,
  16 |     |         int128 sizeDelta,
  17 |     |         uint256 acceptablePrice,
  18 |     |         uint128 settlementStrategyId,
  19 |     |         bytes32 trackingCode,
  20 |     |         address referrer
  21 |     |     );
  22 |     |     event LiquidatePositionCall(uint128 accountId);
  23 |     |     event LiquidateMarginOnlyCall(uint128 accountId);
  24 |     |     event LiquidateFlaggedAccountsCall(uint[] flaggedAccounts);
  25 |     |     event LiquidateFlaggedCall(uint maxNumberOfAccounts);
  26 |     | 
  27 | *   |     function _modifyCollateralCall(
  28 |     |         uint128 accountId,
  29 |     |         uint128 collateralId,
  30 |     |         int256 amountDelta
  31 | *   |     ) internal returns (bool success, bytes memory returnData) {
  32 | *   |         emit ModifyCollateralCall(accountId, collateralId, amountDelta);
  33 |     | 
  34 | *   |         vm.prank(currentActor);
  35 | *   |         (success, returnData) = perps.call(
  36 | *   |             abi.encodeWithSelector(
  37 |     |                 perpsAccountModuleImpl.modifyCollateral.selector,
  38 |     |                 accountId,
  39 |     |                 collateralId,
  40 |     |                 amountDelta
  41 |     |             )
  42 |     |         );
  43 |     |     }
  44 |     | 
  45 | *   |     function _payDebtCall(
  46 |     |         uint128 accountId,
  47 |     |         uint128 amount
  48 | *   |     ) internal returns (bool success, bytes memory returnData) {
  49 | *   |         emit PayDebtCall(accountId, amount);
  50 |     | 
  51 | *   |         vm.prank(currentActor);
  52 | *   |         (success, returnData) = perps.call(
  53 | *   |             abi.encodeWithSelector(perpsAccountModuleImpl.payDebt.selector, accountId, amount)
  54 |     |         );
  55 |     |     }
  56 |     | 
  57 | *   |     function _commitOrderCall(
  58 |     |         uint128 accountId,
  59 |     |         uint128 marketId,
  60 |     |         int128 sizeDelta,
  61 |     |         uint256 acceptablePrice,
  62 |     |         uint128 settlementStrategyId,
  63 |     |         bytes32 trackingCode,
  64 |     |         address referrer
  65 | *   |     ) internal returns (bool success, bytes memory returnData) {
  66 | *   |         emit CommitOrderCall(
  67 | *   |             accountId,
  68 | *   |             marketId,
  69 | *   |             sizeDelta,
  70 | *   |             acceptablePrice,
  71 | *   |             settlementStrategyId,
  72 | *   |             trackingCode,
  73 | *   |             referrer
  74 |     |         );
  75 |     | 
  76 | *   |         AsyncOrder.OrderCommitmentRequest memory commitment = AsyncOrder.OrderCommitmentRequest({
  77 |     |             marketId: marketId,
  78 |     |             accountId: accountId,
  79 |     |             sizeDelta: sizeDelta,
  80 |     |             settlementStrategyId: settlementStrategyId,
  81 |     |             acceptablePrice: acceptablePrice,
  82 |     |             trackingCode: trackingCode,
  83 |     |             referrer: referrer
  84 |     |         });
  85 |     | 
  86 | *   |         vm.prank(currentActor);
  87 | *   |         (success, returnData) = perps.call(
  88 | *   |             abi.encodeWithSelector(asyncOrderModuleImpl.commitOrder.selector, commitment)
  89 |     |         );
  90 |     |     }
  91 | *   |     function _settleOrderCall(
  92 |     |         address settleUser,
  93 |     |         uint128 accountId
  94 | *   |     ) internal returns (bool success, bytes memory returnData) {
  95 | *   |         emit SettleOrderCall(settleUser, accountId);
  96 |     | 
  97 | *   |         vm.prank(currentActor);
  98 | *   |         (success, returnData) = perps.call(
  99 | *   |             abi.encodeWithSelector(
 100 | *   |                 asyncOrderSettlementPythModuleImpl.settleOrder.selector,
 101 |     |                 accountId
 102 |     |             )
 103 |     |         );
 104 |     |     }
 105 |     | 
 106 | *   |     function _cancelOrderCall(
 107 |     |         address settleUser,
 108 |     |         uint128 accountId
 109 | *   |     ) internal returns (bool success, bytes memory returnData) {
 110 | *   |         emit CancelOrderCall(settleUser, accountId);
 111 |     | 
 112 | *   |         vm.prank(currentActor);
 113 | *   |         (success, returnData) = perps.call(
 114 | *   |             abi.encodeWithSelector(asyncOrderCancelModuleImpl.cancelOrder.selector, accountId)
 115 |     |         );
 116 |     |     }
 117 |     | 
 118 |     |     function _liquidatePositionCall(
 119 |     |         uint128 accountId
 120 |     |     ) internal returns (bool success, bytes memory returnData) {
 121 |     |         emit LiquidatePositionCall(accountId);
 122 |     | 
 123 |     |         vm.prank(currentActor);
 124 |     |         (success, returnData) = perps.call(
 125 |     |             abi.encodeWithSelector(liquidationModuleImpl.liquidate.selector, accountId)
 126 |     |         );
 127 |     |     }
 128 |     | 
 129 | *   |     function _liquidateMarginOnlyCall(
 130 |     |         uint128 accountId
 131 | *   |     ) internal returns (bool success, bytes memory returnData) {
 132 | *   |         emit LiquidateMarginOnlyCall(accountId);
 133 |     | 
 134 | *   |         vm.prank(currentActor);
 135 | *   |         (success, returnData) = perps.call(
 136 | *   |             abi.encodeWithSelector(liquidationModuleImpl.liquidateMarginOnly.selector, accountId)
 137 |     |         );
 138 |     |     }
 139 |     | 
 140 | *   |     function _liquidateFlaggedCall(
 141 |     |         uint256 maxNumberOfAccounts
 142 |     |     ) internal returns (bool success, bytes memory returnData) {
 143 |     |         emit LiquidateFlaggedCall(maxNumberOfAccounts);
 144 |     | 
 145 |     |         vm.prank(currentActor);
 146 | *   |         (success, returnData) = perps.call(
 147 | *   |             abi.encodeWithSelector(
 148 |     |                 liquidationModuleImpl.liquidateFlagged.selector,
 149 |     |                 maxNumberOfAccounts
 150 |     |             )
 151 |     |         );
 152 |     |     }
 153 |     | 
 154 |     |     function _liquidateFlaggedAccountsCall(
 155 |     |         uint[] memory flaggedAccounts
 156 |     |     ) internal returns (bool success, bytes memory returnData) {
 157 |     |         emit LiquidateFlaggedAccountsCall(flaggedAccounts);
 158 |     | 
 159 |     |         vm.prank(currentActor);
 160 |     |         (success, returnData) = perps.call(
 161 |     |             abi.encodeWithSelector(
 162 |     |                 liquidationModuleImpl.liquidateFlaggedAccounts.selector,
 163 |     |                 flaggedAccounts
 164 |     |             )
 165 |     |         );
 166 |     |     }
 167 |     | }
 168 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/fuzzing/util/FuzzConstants.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | import {SettlementStrategy} from "../../storage/SettlementStrategy.sol";
   4 |     | 
   5 |     | abstract contract FuzzConstants {
   6 |     |     bool internal constant DEBUG = false;
   7 |     | 
   8 |     |     address internal constant USER1 = address(0x10000);
   9 |     |     address internal constant USER2 = address(0x20000);
  10 |     |     address internal constant USER3 = address(0x30000);
  11 |     |     address[] internal USERS = [USER1, USER2, USER3];
  12 |     |     uint128[] internal ACCOUNTS = [1, 2, 3];
  13 |     | 
  14 |     |     uint256 internal constant INITIAL_BALANCE = 500_000 ether; // 1 Billion USD worth of ETH at $2000/ETH
  15 |     |     uint256 internal constant INITIAL_TOKEN_BALANCE = 5_000_000_000; // 5 Billion tokens, to be multiplied by decimals in setup
  16 |     | 
  17 |     |     int256 internal constant INT_MAX_ETH_CHANGE_BP = 2000; // 20% is the max change for 1 transaction
  18 |     |     uint256 internal constant UINT_MAX_ETH_CHANGE_BP = 2000; // 20% is the max change for 1 transaction
  19 |     | 
  20 |     |     bytes32 internal constant SUSD_ORACLE_NODE_ID = "1";
  21 |     |     bytes32 internal constant WETH_ORACLE_NODE_ID = "2";
  22 |     |     bytes32 internal constant WBTC_ORACLE_NODE_ID = "3";
  23 |     |     bytes32 internal constant HUGE_ORACLE_NODE_ID = "3";
  24 |     | 
  25 |     |     bytes32 internal constant KEEPER_NODE_ID = "5";
  26 |     | 
  27 |     |     bytes32 internal constant WETH_PYTH_PRICE_FEED_ID = "2";
  28 |     |     bytes32 internal constant WBTC_PYTH_PRICE_FEED_ID = "3";
  29 |     |     bytes32 internal constant HUGE_PYTH_PRICE_FEED_ID = "3";
  30 |     | 
  31 |     |     int64 internal constant WETH_STARTING_PRICE = 3_000 * 1e8;
  32 |     |     uint64 internal constant WETH_STARTING_CONF = 1;
  33 |     |     int32 internal constant WETH_STARTING_EXPO = -8;
  34 |     | 
  35 |     |     int64 internal constant WBTC_STARTING_PRICE = 10_000 * 1e8;
  36 |     |     uint64 internal constant WBTC_STARTING_CONF = 1;
  37 |     |     int32 internal constant WBTC_STARTING_EXPO = -8;
  38 |     | 
  39 |     |     int64 internal constant HUGE_STARTING_PRICE = 1_111 * 1e8;
  40 |     |     uint64 internal constant HUGE_STARTING_CONF = 1;
  41 |     |     int32 internal constant HUGE_STARTING_EXPO = -8;
  42 |     | 
  43 |     |     uint128 internal constant REWARD_DISTRIBUTOR_WETH_POOL_ID = 1;
  44 |     |     uint128 internal constant REWARD_DISTRIBUTOR_WBTC_POOL_ID = 2;
  45 |     |     uint128 internal constant REWARD_DISTRIBUTOR_HUGE_POOL_ID = 3;
  46 |     | 
  47 |     |     bytes32 internal constant KEEPER_SETTLEMENT_COST = 0;
  48 |     |     bytes32 internal constant KEEPER_FLAG_COST = 0;
  49 |     |     bytes32 internal constant KEEPER_LIQUIDATE_COST = 0;
  50 |     | 
  51 |     |     uint internal constant STRICT_PRICE_TOLERANCE = 60;
  52 |     | 
  53 |     |     uint internal constant POOL_ID_1 = 1;
  54 |     |     uint internal constant POOL_ID_2 = 2;
  55 |     | 
  56 |     |     //markets/perps-market/test/integration/Account/Margins.test.ts
  57 |     |     //synthetix/perps-v3-fuzzing-fresh/markets/spot-market/test/AtomicOrderModule.buy.test.ts
  58 |     |     uint128 internal constant WETH_MARKET_SKEW_SCALE = 100e18;
  59 |     |     uint128 internal constant WBTC_MARKET_SKEW_SCALE = 10000e18;
  60 |     |     uint128 internal constant HUGE_MARKET_SKEW_SCALE = 10000e18;
  61 |     | 
  62 |     |     // Settlement strategy WETH
  63 |     |     SettlementStrategy.Type internal constant WETH_SETTLEMENT_STRATEGY_TYPE =
  64 |     |         SettlementStrategy.Type.PYTH;
  65 |     |     uint256 internal constant WETH_SETTLEMENT_DELAY = 5;
  66 |     |     uint256 internal constant WETH_SETTLEMENT_WINDOW_DURATION = 120;
  67 |     |     bytes32 internal constant WETH_FEED_ID = "2";
  68 |     |     uint256 internal constant WETH_SETTLEMENT_REWARD = 5e18;
  69 |     |     bool internal constant WETH_DISABLED = false;
  70 |     |     uint256 internal constant WETH_COMMITMENT_PRICE_DELAY = 2;
  71 |     | 
  72 |     |     // Settlement strategy WBTC
  73 |     |     SettlementStrategy.Type internal constant WBTC_SETTLEMENT_STRATEGY_TYPE =
  74 |     |         SettlementStrategy.Type.PYTH;
  75 |     |     uint256 internal constant WBTC_SETTLEMENT_DELAY = 5;
  76 |     |     uint256 internal constant WBTC_SETTLEMENT_WINDOW_DURATION = 120;
  77 |     |     bytes32 internal constant WBTC_FEED_ID = "3";
  78 |     |     uint256 internal constant WBTC_SETTLEMENT_REWARD = 5e18;
  79 |     |     bool internal constant WBTC_DISABLED = false;
  80 |     |     uint256 internal constant WBTC_COMMITMENT_PRICE_DELAY = 2;
  81 |     | 
  82 |     |     // Settlement strategy HUGE
  83 |     |     SettlementStrategy.Type internal constant HUGE_SETTLEMENT_STRATEGY_TYPE =
  84 |     |         SettlementStrategy.Type.PYTH;
  85 |     |     uint256 internal constant HUGE_SETTLEMENT_DELAY = 5;
  86 |     |     uint256 internal constant HUGE_SETTLEMENT_WINDOW_DURATION = 120;
  87 |     |     bytes32 internal constant HUGE_FEED_ID = "3";
  88 |     |     uint256 internal constant HUGE_SETTLEMENT_REWARD = 5e18;
  89 |     |     bool internal constant HUGE_DISABLED = false;
  90 |     |     uint256 internal constant HUGE_COMMITMENT_PRICE_DELAY = 2;
  91 |     | 
  92 |     |     // SNX USD Collateral Configuration
  93 |     |     uint256 internal constant SNX_USD_COLLATERAL_ID = 0;
  94 |     |     uint256 internal constant SNX_USD_MAX_COLLATERAL_AMOUNT = type(uint256).max;
  95 |     |     uint256 internal constant SNX_USD_UPPER_LIMIT_DISCOUNT = 0;
  96 |     |     uint256 internal constant SNX_USD_LOWER_LIMIT_DISCOUNT = 0;
  97 |     |     uint256 internal constant SNX_USD_DISCOUNT_SCALAR = 0;
  98 |     | 
  99 |     |     // WETH Collateral Configuration
 100 |     |     uint256 internal constant WETH_COLLATERAL_ID = 1;
 101 |     |     uint256 internal constant WETH_MAX_COLLATERAL_AMOUNT = type(uint256).max;
 102 |     |     uint256 internal constant WETH_UPPER_LIMIT_DISCOUNT = 0;
 103 |     |     uint256 internal constant WETH_LOWER_LIMIT_DISCOUNT = 0;
 104 |     |     uint256 internal constant WETH_DISCOUNT_SCALAR = 0;
 105 |     | 
 106 |     |     // WBTC Collateral Configuration
 107 |     |     uint256 internal constant WBTC_COLLATERAL_ID = 2;
 108 |     |     uint256 internal constant WBTC_MAX_COLLATERAL_AMOUNT = type(uint256).max;
 109 |     |     uint256 internal constant WBTC_UPPER_LIMIT_DISCOUNT = 0;
 110 |     |     uint256 internal constant WBTC_LOWER_LIMIT_DISCOUNT = 0;
 111 |     |     uint256 internal constant WBTC_DISCOUNT_SCALAR = 0;
 112 |     | 
 113 |     |     // HUGE Collateral Configuration
 114 |     |     uint256 internal constant HUGE_COLLATERAL_ID = 3;
 115 |     |     uint256 internal constant HUGE_MAX_COLLATERAL_AMOUNT = type(uint256).max;
 116 |     |     uint256 internal constant HUGE_UPPER_LIMIT_DISCOUNT = 0;
 117 |     |     uint256 internal constant HUGE_LOWER_LIMIT_DISCOUNT = 0;
 118 |     |     uint256 internal constant HUGE_DISCOUNT_SCALAR = 0;
 119 |     | 
 120 |     |     // Max Positions and Collaterals Per Account Configuration
 121 |     |     uint128 internal constant MAX_POSITIONS_PER_ACCOUNT = 100000;
 122 |     |     uint128 internal constant MAX_COLLATERALS_PER_ACCOUNT = 100000;
 123 |     |     uint128 internal constant HUGE_COLLATERALS_PER_ACCOUNT = 100000;
 124 |     | 
 125 |     |     // WETH Funding Parameters
 126 |     |     uint128 internal constant WETH_SKEW_SCALE = 1_000_000e18;
 127 |     |     uint256 internal constant WETH_MAX_FUNDING_VELOCITY = 0;
 128 |     | 
 129 |     |     // WBTC Funding Parameters
 130 |     |     uint128 internal constant WBTC_SKEW_SCALE = 1_000_000e18;
 131 |     |     uint256 internal constant WBTC_MAX_FUNDING_VELOCITY = 0;
 132 |     | 
 133 |     |     // HUGE Funding Parameters
 134 |     |     uint128 internal constant HUGE_SKEW_SCALE = 1_000_000e18;
 135 |     |     uint256 internal constant HUGE_MAX_FUNDING_VELOCITY = 0;
 136 |     | 
 137 |     |     // Max Market Sizes
 138 | *   |     uint128 internal constant WETH_MAX_MARKET_SIZE = 27_000 * 1e18; //10_000_000;
 139 | *   |     uint128 internal constant WBTC_MAX_MARKET_SIZE = 27_000 * 1e18; //10_000_000;
 140 |     |     uint128 internal constant HUGE_MAX_MARKET_SIZE = 27_000 * 1e18; //10_000_000;
 141 |     | 
 142 |     |     // Max Market Values
 143 |     |     uint256 internal constant WETH_MAX_MARKET_VALUE = 0;
 144 |     |     uint256 internal constant WBTC_MAX_MARKET_VALUE = 0;
 145 |     |     uint256 internal constant HUGE_MAX_MARKET_VALUE = 0;
 146 |     | 
 147 |     |     // Order Fee Ratios
 148 |     |     uint256 internal constant WETH_MAKER_FEE_RATIO = 0.003e18;
 149 |     |     uint256 internal constant WETH_TAKER_FEE_RATIO = 0.006e18;
 150 |     |     uint256 internal constant WBTC_MAKER_FEE_RATIO = 0.003e18;
 151 |     |     uint256 internal constant WBTC_TAKER_FEE_RATIO = 0.006e18;
 152 |     |     uint256 internal constant HUGE_MAKER_FEE_RATIO = 0.003e18;
 153 |     |     uint256 internal constant HUGE_TAKER_FEE_RATIO = 0.006e18;
 154 |     | 
 155 |     |     // WETH Liquidation Parameters
 156 |     |     uint256 internal constant WETH_INITIAL_MARGIN_FRACTION = 2e18;
 157 |     |     uint256 internal constant WETH_MINIMUM_INITIAL_MARGIN_RATIO = 0.01e18;
 158 |     |     uint256 internal constant WETH_MAINTENANCE_MARGIN_SCALAR = 0.5e18;
 159 |     |     uint256 internal constant WETH_LIQUIDATION_REWARD_RATIO = 0.05e18;
 160 |     |     uint256 internal constant WETH_MINIMUM_POSITION_MARGIN = 1000e18;
 161 |     | 
 162 |     |     // WBTC Liquidation Parameters
 163 |     |     uint256 internal constant WBTC_INITIAL_MARGIN_FRACTION = 2e18;
 164 |     |     uint256 internal constant WBTC_MINIMUM_INITIAL_MARGIN_RATIO = 0.01e18;
 165 |     |     uint256 internal constant WBTC_MAINTENANCE_MARGIN_SCALAR = 0.5e18;
 166 |     |     uint256 internal constant WBTC_LIQUIDATION_REWARD_RATIO = 0.05e18;
 167 |     |     uint256 internal constant WBTC_MINIMUM_POSITION_MARGIN = 1000e18;
 168 |     | 
 169 |     |     // WBTC Liquidation Parameters
 170 |     |     uint256 internal constant HUGE_INITIAL_MARGIN_FRACTION = 2e18;
 171 |     |     uint256 internal constant HUGE_MINIMUM_INITIAL_MARGIN_RATIO = 0.01e18;
 172 |     |     uint256 internal constant HUGE_MAINTENANCE_MARGIN_SCALAR = 0.5e18;
 173 |     |     uint256 internal constant HUGE_LIQUIDATION_REWARD_RATIO = 0.05e18;
 174 |     |     uint256 internal constant HUGE_MINIMUM_POSITION_MARGIN = 1000e18;
 175 |     | 
 176 |     |     // WETH Max Liquidation Parameters
 177 |     |     uint256
 178 |     |         internal constant WETH_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER =
 179 |     |         0.00001e18;
 180 |     |     uint256 internal constant WETH_MAX_SECONDS_IN_LIQUIDATION_WINDOW = 60;
 181 |     |     uint256 internal constant WETH_MAX_LIQUIDATION_PD = 0;
 182 |     |     address internal constant WETH_ENDORSED_LIQUIDATOR = address(0);
 183 |     | 
 184 |     |     // WBTC Max Liquidation Parameters
 185 |     |     uint256
 186 |     |         internal constant WBTC_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER =
 187 |     |         0.00001e18;
 188 |     |     uint256 internal constant WBTC_MAX_SECONDS_IN_LIQUIDATION_WINDOW = 60;
 189 |     |     uint256 internal constant WBTC_MAX_LIQUIDATION_PD = 0;
 190 |     |     address internal constant WBTC_ENDORSED_LIQUIDATOR = address(0);
 191 |     | 
 192 |     |     // HUGE Max Liquidation Parameters
 193 |     |     uint256
 194 |     |         internal constant HUGE_MAX_LIQUIDATION_LIMIT_ACCUMULATION_MULTIPLIER =
 195 |     |         0.00001e18;
 196 |     |     uint256 internal constant HUGE_MAX_SECONDS_IN_LIQUIDATION_WINDOW = 60;
 197 |     |     uint256 internal constant HUGE_MAX_LIQUIDATION_PD = 0;
 198 |     |     address internal constant HUGE_ENDORSED_LIQUIDATOR = address(0);
 199 |     | 
 200 |     |     //Pyth settings
 201 |     | 
 202 |     |     int256 internal constant INT_MAX_SYNTHETIX_USD_CHANGE_BP = 2000; // 20% is the max change for 1 transaction
 203 | *   |     int256 internal constant INT_ONE_HUNDRED_BP = 10000;
 204 |     |     int64 internal constant INT_ONE_HUNDRED_BP_64 = 10000;
 205 |     | 
 206 | *   |     uint256 internal constant UINT_MAX_SYNTHETIX_USD_CHANGE_BP = 2000; // 20% is the max change for 1 transaction
 207 | *   |     uint256 internal constant UINT_ONE_HUNDRED_BP = 10000;
 208 |     | 
 209 | *   |     int256 internal constant INT_MAX_CHANGE_BP = 2000; // 20% is the max change for 1 transaction
 210 |     |     uint256 internal constant UINT_MAX_CHANGE_BP = 2000; //  2000; // 20% is the max change for 1 transaction
 211 |     | 
 212 | *   |     uint128 internal constant MAX_ALLOWABLE = 10_000_000 * 1e18;
 213 | *   |     int256 internal constant PRICE_DIVERGENCE_BPS_256 = 100;
 214 |     |     int64 internal constant PRICE_DIVERGENCE_BPS_64 = 100;
 215 |     | }
 216 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAccountEvents.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Account events used on several places in the system.
  6 |     |  */
  7 |     | interface IAccountEvents {
  8 |     |     /**
  9 |     |      * @notice Gets fired anytime an account is charged with fees, paying settlement rewards.
 10 |     |      * @param accountId Id of the account being deducted.
 11 |     |      * @param amount Amount of synth market deducted from the account.
 12 |     |      * @param accountDebt current debt of the account after charged amount.
 13 |     |      */
 14 |     |     event AccountCharged(uint128 accountId, int256 amount, uint256 accountDebt);
 15 |     | }
 16 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAsyncOrderCancelModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
  4 |     | import {Position} from "../storage/Position.sol";
  5 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
  6 |     | import {MarketUpdate} from "../storage/MarketUpdate.sol";
  7 |     | 
  8 |     | interface IAsyncOrderCancelModule {
  9 |     |     /**
 10 |     |      * @notice Gets fired when an order is cancelled.
 11 |     |      * @param marketId Id of the market used for the trade.
 12 |     |      * @param accountId Id of the account used for the trade.
 13 |     |      * @param desiredPrice Price at which the order was cancelled.
 14 |     |      * @param fillPrice Price at which the order was cancelled.
 15 |     |      * @param sizeDelta Size delta from order.
 16 |     |      * @param settlementReward Amount of fees collected by the settler.
 17 |     |      * @param trackingCode Optional code for integrator tracking purposes.
 18 |     |      * @param settler address of the settler of the order.
 19 |     |      */
 20 |     |     event OrderCancelled(
 21 |     |         uint128 indexed marketId,
 22 |     |         uint128 indexed accountId,
 23 |     |         uint256 desiredPrice,
 24 |     |         uint256 fillPrice,
 25 |     |         int128 sizeDelta,
 26 |     |         uint256 settlementReward,
 27 |     |         bytes32 indexed trackingCode,
 28 |     |         address settler
 29 |     |     );
 30 |     | 
 31 |     |     // only used due to stack too deep during settlement
 32 |     |     struct CancelOrderRuntime {
 33 |     |         uint128 marketId;
 34 |     |         uint128 accountId;
 35 |     |         int128 sizeDelta;
 36 |     |         uint256 settlementReward;
 37 |     |         uint256 fillPrice;
 38 |     |         uint256 acceptablePrice;
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Cancels an order when price exceeds the acceptable price. Uses the onchain benchmark price at commitment time.
 43 |     |      * @param accountId Id of the account used for the trade.
 44 |     |      */
 45 |     |     function cancelOrder(uint128 accountId) external;
 46 |     | }
 47 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAsyncOrderModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {AsyncOrder} from "../storage/AsyncOrder.sol";
   5 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Module for committing and settling async orders.
   9 |     |  */
  10 |     | interface IAsyncOrderModule {
  11 |     |     /**
  12 |     |      * @notice Gets fired when a new order is committed.
  13 |     |      * @param marketId Id of the market used for the trade.
  14 |     |      * @param accountId Id of the account used for the trade.
  15 |     |      * @param orderType Should send 0 (at time of writing) that correlates to the transaction type enum defined in SettlementStrategy.Type.
  16 |     |      * @param sizeDelta requested change in size of the order sent by the user.
  17 |     |      * @param acceptablePrice maximum or minimum, depending on the sizeDelta direction, accepted price to settle the order, set by the user.
  18 |     |      * @param commitmentTime Time at which the order was committed.
  19 |     |      * @param settlementTime start time of the settlement window.
  20 |     |      * @param expirationTime Time at which the order expired.
  21 |     |      * @param trackingCode Optional code for integrator tracking purposes.
  22 |     |      * @param sender address of the sender of the order. Authorized to commit by account owner.
  23 |     |      */
  24 |     |     event OrderCommitted(
  25 |     |         uint128 indexed marketId,
  26 |     |         uint128 indexed accountId,
  27 |     |         SettlementStrategy.Type orderType,
  28 |     |         int128 sizeDelta,
  29 |     |         uint256 acceptablePrice,
  30 |     |         uint256 commitmentTime,
  31 |     |         uint256 expectedPriceTime,
  32 |     |         uint256 settlementTime,
  33 |     |         uint256 expirationTime,
  34 |     |         bytes32 indexed trackingCode,
  35 |     |         address sender
  36 |     |     );
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Gets fired when a new order is committed while a previous one was expired.
  40 |     |      * @param marketId Id of the market used for the trade.
  41 |     |      * @param accountId Id of the account used for the trade.
  42 |     |      * @param sizeDelta requested change in size of the order sent by the user.
  43 |     |      * @param acceptablePrice maximum or minimum, depending on the sizeDelta direction, accepted price to settle the order, set by the user.
  44 |     |      * @param commitmentTime Time at which the order was committed.
  45 |     |      * @param trackingCode Optional code for integrator tracking purposes.
  46 |     |      */
  47 |     |     event PreviousOrderExpired(
  48 |     |         uint128 indexed marketId,
  49 |     |         uint128 indexed accountId,
  50 |     |         int128 sizeDelta,
  51 |     |         uint256 acceptablePrice,
  52 |     |         uint256 commitmentTime,
  53 |     |         bytes32 indexed trackingCode
  54 |     |     );
  55 |     | 
  56 |     |     /**
  57 |     |      * @notice Commit an async order via this function
  58 |     |      * @param commitment Order commitment data (see AsyncOrder.OrderCommitmentRequest struct).
  59 |     |      * @return retOrder order details (see AsyncOrder.Data struct).
  60 |     |      * @return fees order fees (protocol + settler)
  61 |     |      */
  62 |     |     function commitOrder(
  63 |     |         AsyncOrder.OrderCommitmentRequest memory commitment
  64 |     |     ) external returns (AsyncOrder.Data memory retOrder, uint256 fees);
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Get async order claim details
  68 |     |      * @param accountId id of the account.
  69 |     |      * @return order async order claim details (see AsyncOrder.Data struct).
  70 |     |      */
  71 |     |     function getOrder(uint128 accountId) external view returns (AsyncOrder.Data memory order);
  72 |     | 
  73 |     |     /**
  74 |     |      * @notice Simulates what the order fee would be for the given market with the specified size.
  75 |     |      * @dev    Note that this does not include the settlement reward fee, which is based on the strategy type used
  76 |     |      * @param marketId id of the market.
  77 |     |      * @param sizeDelta size of position.
  78 |     |      * @return orderFees incurred fees.
  79 |     |      * @return fillPrice price at which the order would be filled.
  80 |     |      */
  81 |     |     function computeOrderFees(
  82 |     |         uint128 marketId,
  83 |     |         int128 sizeDelta
  84 |     |     ) external view returns (uint256 orderFees, uint256 fillPrice);
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Simulates what the order fee would be for the given market with the specified size.
  88 |     |      * @dev    Note that this does not include the settlement reward fee, which is based on the strategy type used
  89 |     |      * @param marketId id of the market.
  90 |     |      * @param sizeDelta size of position.
  91 |     |      * @param price price of the market.
  92 |     |      * @return orderFees incurred fees.
  93 |     |      * @return fillPrice price at which the order would be filled.
  94 |     |      */
  95 |     |     function computeOrderFeesWithPrice(
  96 |     |         uint128 marketId,
  97 |     |         int128 sizeDelta,
  98 |     |         uint256 price
  99 |     |     ) external view returns (uint256 orderFees, uint256 fillPrice);
 100 |     | 
 101 |     |     /**
 102 |     |      * @notice Gets the settlement cost including keeper rewards and keeper costs.
 103 |     |      * @param marketId Id of the market.
 104 |     |      * @param settlementStrategyId Order size.
 105 |     |      * @return settlement cost.
 106 |     |      */
 107 |     |     function getSettlementRewardCost(
 108 |     |         uint128 marketId,
 109 |     |         uint128 settlementStrategyId
 110 |     |     ) external view returns (uint256);
 111 |     | 
 112 |     |     /**
 113 |     |      * @notice For a given market, account id, and a position size, returns the required total account margin for this order to succeed
 114 |     |      * @dev    Useful for integrators to determine if an order will succeed or fail
 115 |     |      * @param marketId id of the market.
 116 |     |      * @param accountId id of the trader account.
 117 |     |      * @param sizeDelta size of position.
 118 |     |      * @return requiredMargin margin required for the order to succeed.
 119 |     |      */
 120 |     |     function requiredMarginForOrder(
 121 |     |         uint128 marketId,
 122 |     |         uint128 accountId,
 123 |     |         int128 sizeDelta
 124 |     |     ) external view returns (uint256 requiredMargin);
 125 |     | 
 126 |     |     /**
 127 |     |      * @notice For a given market, account id, and a position size, and expected price returns the required total account margin for this order to succeed
 128 |     |      * @dev    Useful for integrators to determine if an order will succeed or fail faking different price scenarios
 129 |     |      * @param marketId id of the market.
 130 |     |      * @param accountId id of the trader account.
 131 |     |      * @param sizeDelta size of position.
 132 |     |      * @param price price of the market.
 133 |     |      * @return requiredMargin margin required for the order to succeed.
 134 |     |      */
 135 |     |     function requiredMarginForOrderWithPrice(
 136 |     |         uint128 marketId,
 137 |     |         uint128 accountId,
 138 |     |         int128 sizeDelta,
 139 |     |         uint256 price
 140 |     |     ) external view returns (uint256 requiredMargin);
 141 |     | }
 142 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IAsyncOrderSettlementPythModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {Position} from "../storage/Position.sol";
  5 |     | import {MarketUpdate} from "../storage/MarketUpdate.sol";
  6 |     | 
  7 |     | interface IAsyncOrderSettlementPythModule {
  8 |     |     /**
  9 |     |      * @notice Gets fired when a new order is settled.
 10 |     |      * @param marketId Id of the market used for the trade.
 11 |     |      * @param accountId Id of the account used for the trade.
 12 |     |      * @param fillPrice Price at which the order was settled.
 13 |     |      * @param pnl Pnl of the previous closed position.
 14 |     |      * @param accruedFunding Accrued funding of the previous closed position.
 15 |     |      * @param sizeDelta Size delta from order.
 16 |     |      * @param newSize New size of the position after settlement.
 17 |     |      * @param totalFees Amount of fees collected by the protocol.
 18 |     |      * @param referralFees Amount of fees collected by the referrer.
 19 |     |      * @param collectedFees Amount of fees collected by fee collector.
 20 |     |      * @param settlementReward reward to sender for settling order.
 21 |     |      * @param trackingCode Optional code for integrator tracking purposes.
 22 |     |      * @param settler address of the settler of the order.
 23 |     |      */
 24 |     |     event OrderSettled(
 25 |     |         uint128 indexed marketId,
 26 |     |         uint128 indexed accountId,
 27 |     |         uint256 fillPrice,
 28 |     |         int256 pnl,
 29 |     |         int256 accruedFunding,
 30 |     |         int128 sizeDelta,
 31 |     |         int128 newSize,
 32 |     |         uint256 totalFees,
 33 |     |         uint256 referralFees,
 34 |     |         uint256 collectedFees,
 35 |     |         uint256 settlementReward,
 36 |     |         bytes32 indexed trackingCode,
 37 |     |         address settler
 38 |     |     );
 39 |     | 
 40 |     |     /**
 41 |     |      * @notice Gets fired after order settles and includes the interest charged to the account.
 42 |     |      * @param accountId Id of the account used for the trade.
 43 |     |      * @param interest interest charges
 44 |     |      */
 45 |     |     event InterestCharged(uint128 indexed accountId, uint256 interest);
 46 |     | 
 47 |     |     // only used due to stack too deep during settlement
 48 |     |     struct SettleOrderRuntime {
 49 |     |         uint128 marketId;
 50 |     |         uint128 accountId;
 51 |     |         int128 sizeDelta;
 52 |     |         int256 pnl;
 53 |     |         uint256 chargedInterest;
 54 |     |         int256 accruedFunding;
 55 |     |         uint256 settlementReward;
 56 |     |         uint256 fillPrice;
 57 |     |         uint256 totalFees;
 58 |     |         uint256 referralFees;
 59 |     |         uint256 feeCollectorFees;
 60 |     |         Position.Data newPosition;
 61 |     |         MarketUpdate.Data updateData;
 62 |     |         uint256 synthDeductionIterator;
 63 |     |         uint128[] deductedSynthIds;
 64 |     |         uint256[] deductedAmount;
 65 |     |         int256 chargedAmount;
 66 |     |         uint256 newAccountDebt;
 67 |     |     }
 68 |     | 
 69 |     |     /**
 70 |     |      * @notice Settles an offchain order using the offchain retrieved data from pyth.
 71 |     |      * @param accountId The account id to settle the order
 72 |     |      */
 73 |     |     function settleOrder(uint128 accountId) external;
 74 |     | }
 75 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/ICollateralConfigurationModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Collateral configuration module.
   6 |     |  */
   7 |     | interface ICollateralConfigurationModule {
   8 |     |     /**
   9 |     |      * @notice Gets fired when max collateral amount for synth for all the markets is set by owner.
  10 |     |      * @param collateralId Synth market id to use as collateral, 0 for snxUSD.
  11 |     |      * @param maxCollateralAmount max amount that was set for the synth
  12 |     |      * @param upperLimitDiscount upper limit discount that was set for the synth
  13 |     |      * @param lowerLimitDiscount lower limit discount that was set for the synth
  14 |     |      * @param discountScalar discount scalar that was set for the synth
  15 |     |      */
  16 |     |     event CollateralConfigurationSet(
  17 |     |         uint128 indexed collateralId,
  18 |     |         uint256 maxCollateralAmount,
  19 |     |         uint256 upperLimitDiscount,
  20 |     |         uint256 lowerLimitDiscount,
  21 |     |         uint256 discountScalar
  22 |     |     );
  23 |     | 
  24 |     |     /**
  25 |     |      * @notice Gets fired when the collateral liquidation reward ratio is updated.
  26 |     |      * @param collateralLiquidateRewardRatioD18 new collateral liquidation reward ratio.
  27 |     |      */
  28 |     |     event CollateralLiquidateRewardRatioSet(uint128 collateralLiquidateRewardRatioD18);
  29 |     | 
  30 |     |     /**
  31 |     |      * @notice Gets fired when a new reward distributor is registered.
  32 |     |      * @param distributor the new distributor address.
  33 |     |      */
  34 |     |     event RewardDistributorRegistered(address distributor);
  35 |     | 
  36 |     |     /**
  37 |     |      * @notice Sets the max collateral amount for a specific synth market.
  38 |     |      * @param collateralId Synth market id to use as collateral, 0 for snxUSD.
  39 |     |      * @param maxCollateralAmount Max collateral amount to set for the synth market id.
  40 |     |      * @param upperLimitDiscount Collateral value is discounted and capped at this value.  In % units.
  41 |     |      * @param lowerLimitDiscount Collateral value is discounted and at minimum, this value.  In % units.
  42 |     |      * @param discountScalar This value is used to scale the impactOnSkew of the collateral.
  43 |     |      */
  44 |     |     function setCollateralConfiguration(
  45 |     |         uint128 collateralId,
  46 |     |         uint256 maxCollateralAmount,
  47 |     |         uint256 upperLimitDiscount,
  48 |     |         uint256 lowerLimitDiscount,
  49 |     |         uint256 discountScalar
  50 |     |     ) external;
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Gets the max collateral amount for a specific synth market.
  54 |     |      * @param collateralId Synth market id, 0 for snxUSD.
  55 |     |      * @return maxCollateralAmount max collateral amount of the specified synth market id
  56 |     |      */
  57 |     |     function getCollateralConfiguration(
  58 |     |         uint128 collateralId
  59 |     |     ) external view returns (uint256 maxCollateralAmount);
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice Gets the full configuration for collateral.  The above function exists for backwards compatibility; encourage all integrators to use this function
  63 |     |      * @param collateralId Synth market id, 0 for snxUSD.
  64 |     |      * @return maxCollateralAmount max collateral amount of the specified synth market id
  65 |     |      * @return upperLimitDiscount upper bound for max discount on a collateral
  66 |     |      * @return lowerLimitDiscount lower bound for min discount on a collateral
  67 |     |      * @return discountScalar scaling value on the impactOnSkew of the collateral (via spot market)
  68 |     |      */
  69 |     |     function getCollateralConfigurationFull(
  70 |     |         uint128 collateralId
  71 |     |     )
  72 |     |         external
  73 |     |         view
  74 |     |         returns (
  75 |     |             uint256 maxCollateralAmount,
  76 |     |             uint256 upperLimitDiscount,
  77 |     |             uint256 lowerLimitDiscount,
  78 |     |             uint256 discountScalar
  79 |     |         );
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Sets the collateral liquidation reward ratio.
  83 |     |      * @param collateralLiquidateRewardRatioD18 the new collateral liquidation reward ratio.
  84 |     |      */
  85 |     |     function setCollateralLiquidateRewardRatio(uint128 collateralLiquidateRewardRatioD18) external;
  86 |     | 
  87 |     |     /**
  88 |     |      * @notice Gets the collateral liquidation reward ratio.
  89 |     |      */
  90 |     |     function getCollateralLiquidateRewardRatio()
  91 |     |         external
  92 |     |         view
  93 |     |         returns (uint128 collateralLiquidateRewardRatioD18);
  94 |     | 
  95 |     |     /**
  96 |     |      * @notice Registers a new reward distributor.
  97 |     |      * @param token the collateral token address.
  98 |     |      * @param distributor the previous distributor address if there was one. Set it to address(0) if first distributor, or need to create a new clone.
  99 |     |      * @param collateralId the collateral id.
 100 |     |      * @param poolDelegatedCollateralTypes the pool delegated collateral types.
 101 |     |      */
 102 |     |     function registerDistributor(
 103 |     |         address token,
 104 |     |         address distributor,
 105 |     |         uint128 collateralId,
 106 |     |         address[] calldata poolDelegatedCollateralTypes
 107 |     |     ) external;
 108 |     | 
 109 |     |     /**
 110 |     |      * @notice Checks if a distributor is registered.
 111 |     |      * @param distributor the distributor address.
 112 |     |      * @return isRegistered true if the distributor is registered.
 113 |     |      */
 114 |     |     function isRegistered(address distributor) external view returns (bool);
 115 |     | 
 116 |     |     /**
 117 |     |      * @notice Gets the registered distributor for a collateral id.
 118 |     |      * @param collateralId the collateral id.
 119 |     |      * @return distributor the distributor address.
 120 |     |      * @return poolDelegatedCollateralTypes the pool delegated collateral types.
 121 |     |      */
 122 |     |     function getRegisteredDistributor(
 123 |     |         uint128 collateralId
 124 |     |     ) external view returns (address distributor, address[] memory poolDelegatedCollateralTypes);
 125 |     | }
 126 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IDistributorErrors.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Distributor errors used on several places in the system.
  6 |     |  */
  7 |     | interface IDistributorErrors {
  8 |     |     /**
  9 |     |      * @notice Thrown when attempting to use a wrong distributor
 10 |     |      */
 11 |     |     error InvalidDistributor(uint128 id, address distributor);
 12 |     | 
 13 |     |     /**
 14 |     |      * @notice Thrown when attempting to use a wrong contract as distributor
 15 |     |      */
 16 |     |     error InvalidDistributorContract(address distributor);
 17 |     | }
 18 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IGlobalPerpsMarketModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Module for global Perps Market settings.
   6 |     |  */
   7 |     | interface IGlobalPerpsMarketModule {
   8 |     |     /**
   9 |     |      * @notice Gets fired when the interest rate is updated.
  10 |     |      * @param superMarketId global super market id
  11 |     |      * @param interestRate new computed interest rate
  12 |     |      */
  13 |     |     event InterestRateUpdated(uint128 indexed superMarketId, uint128 interestRate);
  14 |     | 
  15 |     |     /**
  16 |     |      * @notice Gets fired when keeper reward guard is set or updated.
  17 |     |      * @param minKeeperRewardUsd Minimum keeper reward expressed as USD value.
  18 |     |      * @param minKeeperProfitRatioD18 Minimum keeper profit ratio used together with minKeeperRewardUsd to calculate the minimum.
  19 |     |      * @param maxKeeperRewardUsd Maximum keeper reward expressed as USD value.
  20 |     |      * @param maxKeeperScalingRatioD18 Scaling used to calculate the Maximum keeper reward together with maxKeeperRewardUsd.
  21 |     |      */
  22 |     |     event KeeperRewardGuardsSet(
  23 |     |         uint256 minKeeperRewardUsd,
  24 |     |         uint256 minKeeperProfitRatioD18,
  25 |     |         uint256 maxKeeperRewardUsd,
  26 |     |         uint256 maxKeeperScalingRatioD18
  27 |     |     );
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice emitted when custom fee collector is set
  31 |     |      * @param feeCollector the address of the fee collector to set.
  32 |     |      */
  33 |     |     event FeeCollectorSet(address feeCollector);
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Emitted when the share percentage for a referrer address has been updated.
  37 |     |      * @param referrer The address of the referrer
  38 |     |      * @param shareRatioD18 The new share ratio for the referrer
  39 |     |      */
  40 |     |     event ReferrerShareUpdated(address referrer, uint256 shareRatioD18);
  41 |     | 
  42 |     |     /**
  43 |     |      * @notice Emitted when interest rate parameters are set
  44 |     |      * @param lowUtilizationInterestRateGradient interest rate gradient applied to utilization prior to hitting the gradient breakpoint
  45 |     |      * @param interestRateGradientBreakpoint breakpoint at which the interest rate gradient changes from low to high
  46 |     |      * @param highUtilizationInterestRateGradient interest rate gradient applied to utilization after hitting the gradient breakpoint
  47 |     |      */
  48 |     |     event InterestRateParametersSet(
  49 |     |         uint256 lowUtilizationInterestRateGradient,
  50 |     |         uint256 interestRateGradientBreakpoint,
  51 |     |         uint256 highUtilizationInterestRateGradient
  52 |     |     );
  53 |     | 
  54 |     |     /**
  55 |     |      * @notice Gets fired when the max number of Positions and Collaterals per Account are set by owner.
  56 |     |      * @param maxPositionsPerAccount The max number of concurrent Positions per Account
  57 |     |      * @param maxCollateralsPerAccount The max number of concurrent Collaterals per Account
  58 |     |      */
  59 |     |     event PerAccountCapsSet(uint128 maxPositionsPerAccount, uint128 maxCollateralsPerAccount);
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice Gets fired when feed id for keeper cost node id is updated.
  63 |     |      * @param keeperCostNodeId oracle node id
  64 |     |      */
  65 |     |     event KeeperCostNodeIdUpdated(bytes32 keeperCostNodeId);
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Thrown when the fee collector does not implement the IFeeCollector interface
  69 |     |      */
  70 |     |     error InvalidFeeCollectorInterface(address invalidFeeCollector);
  71 |     | 
  72 |     |     /**
  73 |     |      * @notice Thrown when a referrer share gets set to larger than 100%
  74 |     |      */
  75 |     |     error InvalidReferrerShareRatio(uint256 shareRatioD18);
  76 |     | 
  77 |     |     /**
  78 |     |      * @notice Thrown when gradient breakpoint is lower than low gradient or higher than high gradient
  79 |     |      */
  80 |     |     error InvalidInterestRateParameters(
  81 |     |         uint128 lowUtilizationInterestRateGradient,
  82 |     |         uint128 highUtilizationInterestRateGradient
  83 |     |     );
  84 |     | 
  85 |     |     /**
  86 |     |      * @notice Gets the list of supported collaterals.
  87 |     |      * @return supportedCollaterals list of supported collateral ids. By supported collateral we mean a collateral which max is greater than zero
  88 |     |      */
  89 |     |     function getSupportedCollaterals()
  90 |     |         external
  91 |     |         view
  92 |     |         returns (uint256[] memory supportedCollaterals);
  93 |     | 
  94 |     |     /**
  95 |     |      * @notice Sets the keeper reward guard (min and max).
  96 |     |      * @param minKeeperRewardUsd Minimum keeper reward expressed as USD value.
  97 |     |      * @param minKeeperProfitRatioD18 Minimum keeper profit ratio used together with minKeeperRewardUsd to calculate the minimum.
  98 |     |      * @param maxKeeperRewardUsd Maximum keeper reward expressed as USD value.
  99 |     |      * @param maxKeeperScalingRatioD18 Scaling used to calculate the Maximum keeper reward together with maxKeeperRewardUsd.
 100 |     |      */
 101 |     |     function setKeeperRewardGuards(
 102 |     |         uint256 minKeeperRewardUsd,
 103 |     |         uint256 minKeeperProfitRatioD18,
 104 |     |         uint256 maxKeeperRewardUsd,
 105 |     |         uint256 maxKeeperScalingRatioD18
 106 |     |     ) external;
 107 |     | 
 108 |     |     /**
 109 |     |      * @notice Gets the keeper reward guard (min and max).
 110 |     |      * @return minKeeperRewardUsd Minimum keeper reward expressed as USD value.
 111 |     |      * @return minKeeperProfitRatioD18 Minimum keeper profit ratio used together with minKeeperRewardUsd to calculate the minimum.
 112 |     |      * @return maxKeeperRewardUsd Maximum keeper reward expressed as USD value.
 113 |     |      * @return maxKeeperScalingRatioD18 Scaling used to calculate the Maximum keeper reward together with maxKeeperRewardUsd.
 114 |     |      */
 115 |     |     function getKeeperRewardGuards()
 116 |     |         external
 117 |     |         view
 118 |     |         returns (
 119 |     |             uint256 minKeeperRewardUsd,
 120 |     |             uint256 minKeeperProfitRatioD18,
 121 |     |             uint256 maxKeeperRewardUsd,
 122 |     |             uint256 maxKeeperScalingRatioD18
 123 |     |         );
 124 |     | 
 125 |     |     /**
 126 |     |      * @notice Gets the total collateral value of all deposited collateral from all traders.
 127 |     |      * @return totalCollateralValue value of all collateral
 128 |     |      */
 129 |     |     function totalGlobalCollateralValue() external view returns (uint256 totalCollateralValue);
 130 |     | 
 131 |     |     /**
 132 |     |      * @notice Gets the total collateral value of all deposited collateral from all traders.
 133 |     |      * @param collateralId the id of the collateral (0 for snxUSD)
 134 |     |      * @return collateralValue value of all collateral for collateral id
 135 |     |      */
 136 |     |     function globalCollateralValue(
 137 |     |         uint128 collateralId
 138 |     |     ) external view returns (uint256 collateralValue);
 139 |     | 
 140 |     |     /**
 141 |     |      * @notice Sets the fee collector contract.
 142 |     |      * @dev must conform to the IFeeCollector interface
 143 |     |      * @param feeCollector address of the fee collector contract
 144 |     |      */
 145 |     |     function setFeeCollector(address feeCollector) external;
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice Gets the configured feeCollector contract
 149 |     |      * @return feeCollector address of the fee collector contract
 150 |     |      */
 151 |     |     function getFeeCollector() external view returns (address feeCollector);
 152 |     | 
 153 |     |     /**
 154 |     |      * @notice Set or update the max number of Positions and Collaterals per Account
 155 |     |      * @param maxPositionsPerAccount The max number of concurrent Positions per Account
 156 |     |      * @param maxCollateralsPerAccount The max number of concurrent Collaterals per Account
 157 |     |      */
 158 |     |     function setPerAccountCaps(
 159 |     |         uint128 maxPositionsPerAccount,
 160 |     |         uint128 maxCollateralsPerAccount
 161 |     |     ) external;
 162 |     | 
 163 |     |     /**
 164 |     |      * @notice get the max number of Positions and Collaterals per Account
 165 |     |      * @param maxPositionsPerAccount The max number of concurrent Positions per Account
 166 |     |      * @param maxCollateralsPerAccount The max number of concurrent Collaterals per Account
 167 |     |      */
 168 |     |     function getPerAccountCaps()
 169 |     |         external
 170 |     |         returns (uint128 maxPositionsPerAccount, uint128 maxCollateralsPerAccount);
 171 |     | 
 172 |     |     /**
 173 |     |      * @notice Update the referral share percentage for a referrer
 174 |     |      * @param referrer The address of the referrer
 175 |     |      * @param shareRatioD18 The new share percentage for the referrer
 176 |     |      */
 177 |     |     function updateReferrerShare(address referrer, uint256 shareRatioD18) external;
 178 |     | 
 179 |     |     /**
 180 |     |      * @notice get the referral share percentage for the specified referrer
 181 |     |      * @param referrer The address of the referrer
 182 |     |      * @return shareRatioD18 The configured share percentage for the referrer
 183 |     |      */
 184 |     |     function getReferrerShare(address referrer) external view returns (uint256 shareRatioD18);
 185 |     | 
 186 |     |     /**
 187 |     |      * @notice Set node id for keeper cost
 188 |     |      * @param keeperCostNodeId the node id
 189 |     |      */
 190 |     |     function updateKeeperCostNodeId(bytes32 keeperCostNodeId) external;
 191 |     | 
 192 |     |     /**
 193 |     |      * @notice Get the node id for keeper cost
 194 |     |      * @return keeperCostNodeId the node id
 195 |     |      */
 196 |     |     function getKeeperCostNodeId() external view returns (bytes32 keeperCostNodeId);
 197 |     | 
 198 |     |     /**
 199 |     |      * @notice get all existing market ids
 200 |     |      * @return marketIds an array of existing market ids
 201 |     |      */
 202 |     |     function getMarkets() external view returns (uint256[] memory marketIds);
 203 |     | 
 204 |     |     /**
 205 |     |      * @notice Sets the interest rate parameters
 206 |     |      * @param lowUtilizationInterestRateGradient interest rate gradient applied to utilization prior to hitting the gradient breakpoint
 207 |     |      * @param interestRateGradientBreakpoint breakpoint at which the interest rate gradient changes from low to high
 208 |     |      * @param highUtilizationInterestRateGradient interest rate gradient applied to utilization after hitting the gradient breakpoint
 209 |     |      */
 210 |     |     function setInterestRateParameters(
 211 |     |         uint128 lowUtilizationInterestRateGradient,
 212 |     |         uint128 interestRateGradientBreakpoint,
 213 |     |         uint128 highUtilizationInterestRateGradient
 214 |     |     ) external;
 215 |     | 
 216 |     |     /**
 217 |     |      * @notice Gets the interest rate parameters
 218 |     |      * @return lowUtilizationInterestRateGradient
 219 |     |      * @return interestRateGradientBreakpoint
 220 |     |      * @return highUtilizationInterestRateGradient
 221 |     |      */
 222 |     |     function getInterestRateParameters()
 223 |     |         external
 224 |     |         view
 225 |     |         returns (
 226 |     |             uint128 lowUtilizationInterestRateGradient,
 227 |     |             uint128 interestRateGradientBreakpoint,
 228 |     |             uint128 highUtilizationInterestRateGradient
 229 |     |         );
 230 |     | 
 231 |     |     /**
 232 |     |      * @notice Update the market interest rate based on current utilization of the super market against backing collateral
 233 |     |      * @dev this is a convenience method to manually update interest rate if too much time has passed
 234 |     |      *      since last update.
 235 |     |      * @dev interest rate gets automatically updated when a trade is made or when a position is liquidated
 236 |     |      * @dev InterestRateUpdated event is emitted
 237 |     |      */
 238 |     |     function updateInterestRate() external;
 239 |     | }
 240 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/ILiquidationModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Liquidation module
   6 |     |  */
   7 |     | interface ILiquidationModule {
   8 |     |     /**
   9 |     |      * @notice Thrown when attempting to liquidate an account not elegible for liquidation
  10 |     |      */
  11 |     |     error NotEligibleForLiquidation(uint128 accountId);
  12 |     | 
  13 |     |     /**
  14 |     |      * @notice Thrown when attempting to liquidate an account's margin when not elegible for liquidation
  15 |     |      */
  16 |     |     error NotEligibleForMarginLiquidation(uint128 accountId);
  17 |     | 
  18 |     |     /**
  19 |     |      * @notice Thrown when attempting to liquidate an account's margin when it has open positions (should use normal liquidate)
  20 |     |      */
  21 |     |     error AccountHasOpenPositions(uint128 accountId);
  22 |     | 
  23 |     |     /**
  24 |     |      * @notice Gets fired when an account position is liquidated .
  25 |     |      * @param marketId Id of the position's market.
  26 |     |      * @param accountId Id of the account liquidated.
  27 |     |      * @param amountLiquidated amount liquidated.
  28 |     |      * @param currentPositionSize position size after liquidation.
  29 |     |      */
  30 |     |     event PositionLiquidated(
  31 |     |         uint128 indexed accountId,
  32 |     |         uint128 indexed marketId,
  33 |     |         uint256 amountLiquidated,
  34 |     |         int128 currentPositionSize
  35 |     |     );
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Gets fired when an account is flagged for liquidation.
  39 |     |      * @param accountId Id of the account flagged.
  40 |     |      * @param availableMargin available margin after flagging.
  41 |     |      * @param requiredMaintenanceMargin required maintenance margin which caused the flagging.
  42 |     |      * @param liquidationReward reward for fully liquidating account paid when liquidation occurs.
  43 |     |      * @param flagReward reward to keeper for flagging the account
  44 |     |      */
  45 |     |     event AccountFlaggedForLiquidation(
  46 |     |         uint128 indexed accountId,
  47 |     |         int256 availableMargin,
  48 |     |         uint256 requiredMaintenanceMargin,
  49 |     |         uint256 liquidationReward,
  50 |     |         uint256 flagReward
  51 |     |     );
  52 |     | 
  53 |     |     /**
  54 |     |      * @notice Gets fired when an account is liquidated.
  55 |     |      * @dev this event is fired once per liquidation tx after the each position that can be liquidated at the time was liquidated.
  56 |     |      * @param accountId Id of the account liquidated.
  57 |     |      * @param reward total reward sent to liquidator.
  58 |     |      * @param fullLiquidation flag indicating if it was a partial or full liquidation.
  59 |     |      */
  60 |     |     event AccountLiquidationAttempt(
  61 |     |         uint128 indexed accountId,
  62 |     |         uint256 reward,
  63 |     |         bool fullLiquidation
  64 |     |     );
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Gets fired when an account margin is liquidated due to not paying down debt.
  68 |     |      * @param accountId Id of the account liquidated.
  69 |     |      * @param seizedMarginValue margin seized due to liquidation.
  70 |     |      * @param liquidationReward reward for liquidating margin account
  71 |     |      */
  72 |     |     event AccountMarginLiquidation(
  73 |     |         uint128 indexed accountId,
  74 |     |         uint256 seizedMarginValue,
  75 |     |         uint256 liquidationReward
  76 |     |     );
  77 |     | 
  78 |     |     /**
  79 |     |      * @notice Liquidates an account.
  80 |     |      * @dev according to the current situation and account size it can be a partial or full liquidation.
  81 |     |      * @param accountId Id of the account to liquidate.
  82 |     |      * @return liquidationReward total reward sent to liquidator.
  83 |     |      */
  84 |     |     function liquidate(uint128 accountId) external returns (uint256 liquidationReward);
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Liquidates an account's margin when no other positions exist.
  88 |     |      * @dev if available margin is negative and no positions exist, then account margin can be liquidated by calling this function
  89 |     |      * @param accountId Id of the account to liquidate.
  90 |     |      * @return liquidationReward total reward sent to liquidator.
  91 |     |      */
  92 |     |     function liquidateMarginOnly(uint128 accountId) external returns (uint256 liquidationReward);
  93 |     | 
  94 |     |     /**
  95 |     |      * @notice Liquidates up to maxNumberOfAccounts flagged accounts.
  96 |     |      * @param maxNumberOfAccounts max number of accounts to liquidate.
  97 |     |      * @return liquidationReward total reward sent to liquidator.
  98 |     |      */
  99 |     |     function liquidateFlagged(
 100 |     |         uint256 maxNumberOfAccounts
 101 |     |     ) external returns (uint256 liquidationReward);
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice Liquidates the listed flagged accounts.
 105 |     |      * @dev if any of the accounts is not flagged for liquidation it will be skipped.
 106 |     |      * @param accountIds list of account ids to liquidate.
 107 |     |      * @return liquidationReward total reward sent to liquidator.
 108 |     |      */
 109 |     |     function liquidateFlaggedAccounts(
 110 |     |         uint128[] calldata accountIds
 111 |     |     ) external returns (uint256 liquidationReward);
 112 |     | 
 113 |     |     /**
 114 |     |      * @notice Returns the list of flagged accounts.
 115 |     |      * @return accountIds list of flagged accounts.
 116 |     |      */
 117 |     |     function flaggedAccounts() external view returns (uint256[] memory accountIds);
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Returns if an account is eligible for liquidation.
 121 |     |      * @return isEligible
 122 |     |      */
 123 |     |     function canLiquidate(uint128 accountId) external view returns (bool isEligible);
 124 |     | 
 125 |     |     /**
 126 |     |      * @notice Returns if an account's margin is eligible for liquidation.
 127 |     |      * @return isEligible
 128 |     |      */
 129 |     |     function canLiquidateMarginOnly(uint128 accountId) external view returns (bool isEligible);
 130 |     | 
 131 |     |     /**
 132 |     |      * @notice Current liquidation capacity for the market
 133 |     |      * @return capacity market can liquidate up to this #
 134 |     |      * @return maxLiquidationInWindow max amount allowed to liquidate based on the current market configuration
 135 |     |      * @return latestLiquidationTimestamp timestamp of the last liquidation of the market
 136 |     |      */
 137 |     |     function liquidationCapacity(
 138 |     |         uint128 marketId
 139 |     |     )
 140 |     |         external
 141 |     |         view
 142 |     |         returns (
 143 |     |             uint256 capacity,
 144 |     |             uint256 maxLiquidationInWindow,
 145 |     |             uint256 latestLiquidationTimestamp
 146 |     |         );
 147 |     | }
 148 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IMarketConfigurationModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title Module for updating configuration in relation to async order modules.
   8 |     |  */
   9 |     | interface IMarketConfigurationModule {
  10 |     |     /**
  11 |     |      * @notice Gets fired when new settlement strategy is added.
  12 |     |      * @param marketId adds settlement strategy to this specific market.
  13 |     |      * @param strategy the strategy configuration.
  14 |     |      * @param strategyId the newly created settlement strategy id.
  15 |     |      */
  16 |     |     event SettlementStrategyAdded(
  17 |     |         uint128 indexed marketId,
  18 |     |         SettlementStrategy.Data strategy,
  19 |     |         uint256 indexed strategyId
  20 |     |     );
  21 |     | 
  22 |     |     /**
  23 |     |      * @notice Gets fired when new settlement strategy is updated.
  24 |     |      * @param marketId adds settlement strategy to this specific market.
  25 |     |      * @param strategyId the newly created settlement strategy id.
  26 |     |      * @param strategy the strategy configuration.
  27 |     |      */
  28 |     |     event SettlementStrategySet(
  29 |     |         uint128 indexed marketId,
  30 |     |         uint256 indexed strategyId,
  31 |     |         SettlementStrategy.Data strategy
  32 |     |     );
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Gets fired when feed id for perps market is updated.
  36 |     |      * @param marketId id of perps market
  37 |     |      * @param feedId oracle node id
  38 |     |      * @param strictStalenessTolerance strict price tolerance in seconds (used for liquidations primarily)
  39 |     |      */
  40 |     |     event MarketPriceDataUpdated(
  41 |     |         uint128 indexed marketId,
  42 |     |         bytes32 feedId,
  43 |     |         uint256 strictStalenessTolerance
  44 |     |     );
  45 |     | 
  46 |     |     /**
  47 |     |      * @notice Gets fired when order fees are updated.
  48 |     |      * @param marketId udpates fees to this specific market.
  49 |     |      * @param makerFeeRatio the maker fee ratio.
  50 |     |      * @param takerFeeRatio the taker fee ratio.
  51 |     |      */
  52 |     |     event OrderFeesSet(uint128 indexed marketId, uint256 makerFeeRatio, uint256 takerFeeRatio);
  53 |     | 
  54 |     |     /**
  55 |     |      * @notice Gets fired when funding parameters are updated.
  56 |     |      * @param marketId udpates funding parameters to this specific market.
  57 |     |      * @param skewScale the skew scale.
  58 |     |      * @param maxFundingVelocity the max funding velocity.
  59 |     |      */
  60 |     |     event FundingParametersSet(
  61 |     |         uint128 indexed marketId,
  62 |     |         uint256 skewScale,
  63 |     |         uint256 maxFundingVelocity
  64 |     |     );
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Gets fired when parameters for max liquidation are set
  68 |     |      * @param marketId updates funding parameters to this specific market.
  69 |     |      * @param maxLiquidationLimitAccumulationMultiplier the max liquidation limit accumulation multiplier.
  70 |     |      * @param maxSecondsInLiquidationWindow the max seconds in liquidation window (used together with the acc multiplier to get max liquidation per window).
  71 |     |      */
  72 |     |     event MaxLiquidationParametersSet(
  73 |     |         uint128 indexed marketId,
  74 |     |         uint256 maxLiquidationLimitAccumulationMultiplier,
  75 |     |         uint256 maxSecondsInLiquidationWindow,
  76 |     |         uint256 maxLiquidationPd,
  77 |     |         address endorsedLiquidator
  78 |     |     );
  79 |     | 
  80 |     |     /**
  81 |     |      * @notice Gets fired when liquidation parameters are updated.
  82 |     |      * @param marketId udpates funding parameters to this specific market.
  83 |     |      * @param initialMarginRatioD18 the initial margin ratio (as decimal with 18 digits precision).
  84 |     |      * @param maintenanceMarginRatioD18 the maintenance margin ratio (as decimal with 18 digits precision).
  85 |     |      * @param flagRewardRatioD18 the flag reward ratio (as decimal with 18 digits precision).
  86 |     |      * @param minimumPositionMargin the minimum position margin.
  87 |     |      */
  88 |     |     event LiquidationParametersSet(
  89 |     |         uint128 indexed marketId,
  90 |     |         uint256 initialMarginRatioD18,
  91 |     |         uint256 maintenanceMarginRatioD18,
  92 |     |         uint256 minimumInitialMarginRatioD18,
  93 |     |         uint256 flagRewardRatioD18,
  94 |     |         uint256 minimumPositionMargin
  95 |     |     );
  96 |     | 
  97 |     |     /**
  98 |     |      * @notice Gets fired when max market value is updated.
  99 |     |      * @param marketId udpates funding parameters to this specific market.
 100 |     |      * @param maxMarketSize the max market size in units.
 101 |     |      */
 102 |     |     event MaxMarketSizeSet(uint128 indexed marketId, uint256 maxMarketSize);
 103 |     | 
 104 |     |     /**
 105 |     |      * @notice Gets fired when max market value is updated.
 106 |     |      * @param marketId udpates funding parameters to this specific market.
 107 |     |      * @param maxMarketValue the max market value in USD.
 108 |     |      */
 109 |     |     event MaxMarketValueSet(uint128 indexed marketId, uint256 maxMarketValue);
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice Gets fired when locked oi ratio is updated.
 113 |     |      * @param marketId udpates funding parameters to this specific market.
 114 |     |      * @param lockedOiRatioD18 the locked OI ratio skew scale (as decimal with 18 digits precision).
 115 |     |      */
 116 |     |     event LockedOiRatioSet(uint128 indexed marketId, uint256 lockedOiRatioD18);
 117 |     | 
 118 |     |     /**
 119 |     |      * @notice Thrown when attempting to set settlement strategy with window duration as 0
 120 |     |      */
 121 |     |     error InvalidSettlementWindowDuration(uint256 duration);
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Add a new settlement strategy with this function.
 125 |     |      * @param marketId id of the market to add the settlement strategy.
 126 |     |      * @param strategy strategy details (see SettlementStrategy.Data struct).
 127 |     |      * @return strategyId id of the new settlement strategy.
 128 |     |      */
 129 |     |     function addSettlementStrategy(
 130 |     |         uint128 marketId,
 131 |     |         SettlementStrategy.Data memory strategy
 132 |     |     ) external returns (uint256 strategyId);
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice updates a settlement strategy for a market with this function.
 136 |     |      * @param marketId id of the market.
 137 |     |      * @param strategyId the specific strategy id.
 138 |     |      * @param strategy strategy details (see SettlementStrategy.Data struct).
 139 |     |      */
 140 |     |     function setSettlementStrategy(
 141 |     |         uint128 marketId,
 142 |     |         uint256 strategyId,
 143 |     |         SettlementStrategy.Data memory strategy
 144 |     |     ) external;
 145 |     | 
 146 |     |     /**
 147 |     |      * @notice Set order fees for a market with this function.
 148 |     |      * @param marketId id of the market to set order fees.
 149 |     |      * @param makerFeeRatio the maker fee ratio.
 150 |     |      * @param takerFeeRatio the taker fee ratio.
 151 |     |      */
 152 |     |     function setOrderFees(uint128 marketId, uint256 makerFeeRatio, uint256 takerFeeRatio) external;
 153 |     | 
 154 |     |     /**
 155 |     |      * @notice Set node id for perps market
 156 |     |      * @param perpsMarketId id of the market to set price feed.
 157 |     |      * @param feedId the node feed id
 158 |     |      * @param strictStalenessTolerance strict price tolerance in seconds (used for liquidations primarily)
 159 |     |      */
 160 |     |     function updatePriceData(
 161 |     |         uint128 perpsMarketId,
 162 |     |         bytes32 feedId,
 163 |     |         uint256 strictStalenessTolerance
 164 |     |     ) external;
 165 |     | 
 166 |     |     /**
 167 |     |      * @notice Set funding parameters for a market with this function.
 168 |     |      * @param marketId id of the market to set funding parameters.
 169 |     |      * @param skewScale the skew scale.
 170 |     |      * @param maxFundingVelocity the max funding velocity.
 171 |     |      */
 172 |     |     function setFundingParameters(
 173 |     |         uint128 marketId,
 174 |     |         uint256 skewScale,
 175 |     |         uint256 maxFundingVelocity
 176 |     |     ) external;
 177 |     | 
 178 |     |     /**
 179 |     |      * @notice Set liquidation parameters for a market with this function.
 180 |     |      * @param marketId id of the market to set liquidation parameters.
 181 |     |      * @param maxLiquidationLimitAccumulationMultiplier the max liquidation limit accumulation multiplier.
 182 |     |      * @param maxSecondsInLiquidationWindow the max seconds in liquidation window (used together with the acc multiplier to get max liquidation per window).
 183 |     |      * @param maxLiquidationPd max allowed pd when calculating max liquidation amount
 184 |     |      * @param endorsedLiquidator address of the endorsed liquidator who can fully liquidate accounts without any restriction
 185 |     |      */
 186 |     |     function setMaxLiquidationParameters(
 187 |     |         uint128 marketId,
 188 |     |         uint256 maxLiquidationLimitAccumulationMultiplier,
 189 |     |         uint256 maxSecondsInLiquidationWindow,
 190 |     |         uint256 maxLiquidationPd,
 191 |     |         address endorsedLiquidator
 192 |     |     ) external;
 193 |     | 
 194 |     |     /**
 195 |     |      * @notice Set liquidation parameters for a market with this function.
 196 |     |      * @param marketId id of the market to set liquidation parameters.
 197 |     |      * @param initialMarginRatioD18 the initial margin ratio (as decimal with 18 digits precision).
 198 |     |      * @param minimumInitialMarginRatioD18 the minimum initial margin ratio (as decimal with 18 digits precision).
 199 |     |      * @param maintenanceMarginScalarD18 the maintenance margin scalar relative to the initial margin ratio (as decimal with 18 digits precision).
 200 |     |      * @param flagRewardRatioD18 the flag reward ratio (as decimal with 18 digits precision).
 201 |     |      * @param minimumPositionMargin the minimum position margin.
 202 |     |      */
 203 |     |     function setLiquidationParameters(
 204 |     |         uint128 marketId,
 205 |     |         uint256 initialMarginRatioD18,
 206 |     |         uint256 minimumInitialMarginRatioD18,
 207 |     |         uint256 maintenanceMarginScalarD18,
 208 |     |         uint256 flagRewardRatioD18,
 209 |     |         uint256 minimumPositionMargin
 210 |     |     ) external;
 211 |     | 
 212 |     |     /**
 213 |     |      * @notice Set the max size of an specific market with this function.
 214 |     |      * @dev This controls the maximum open interest a market can have on either side (Long | Short). So the total Open Interest (with zero skew) for a market can be up to max market size * 2.
 215 |     |      * @param marketId id of the market to set the max market value.
 216 |     |      * @param maxMarketSize the max market size in market asset units.
 217 |     |      */
 218 |     |     function setMaxMarketSize(uint128 marketId, uint256 maxMarketSize) external;
 219 |     | 
 220 |     |     /**
 221 |     |      * @notice Set the max value in USD of an specific market with this function.
 222 |     |      * @param marketId id of the market to set the max market value.
 223 |     |      * @param maxMarketValue the max market size in market USD value.
 224 |     |      */
 225 |     |     function setMaxMarketValue(uint128 marketId, uint256 maxMarketValue) external;
 226 |     | 
 227 |     |     /**
 228 |     |      * @notice Set the locked OI Ratio for a market with this function.
 229 |     |      * @param marketId id of the market to set locked OI ratio.
 230 |     |      * @param lockedOiRatioD18 the locked OI ratio skew scale (as decimal with 18 digits precision).
 231 |     |      */
 232 |     |     function setLockedOiRatio(uint128 marketId, uint256 lockedOiRatioD18) external;
 233 |     | 
 234 |     |     /**
 235 |     |      * @notice Enable or disable a settlement strategy for a market with this function.
 236 |     |      * @param marketId id of the market.
 237 |     |      * @param strategyId the specific strategy.
 238 |     |      * @param enabled whether the strategy is enabled or disabled.
 239 |     |      */
 240 |     |     function setSettlementStrategyEnabled(
 241 |     |         uint128 marketId,
 242 |     |         uint256 strategyId,
 243 |     |         bool enabled
 244 |     |     ) external;
 245 |     | 
 246 |     |     /**
 247 |     |      * @notice Gets the settlement strategy details.
 248 |     |      * @param marketId id of the market.
 249 |     |      * @param strategyId id of the settlement strategy.
 250 |     |      * @return settlementStrategy strategy details (see SettlementStrategy.Data struct).
 251 |     |      */
 252 |     |     function getSettlementStrategy(
 253 |     |         uint128 marketId,
 254 |     |         uint256 strategyId
 255 |     |     ) external view returns (SettlementStrategy.Data memory settlementStrategy);
 256 |     | 
 257 |     |     /**
 258 |     |      * @notice Gets liquidation parameters details of a market.
 259 |     |      * @param marketId id of the market.
 260 |     |      * @return maxLiquidationLimitAccumulationMultiplier the max liquidation limit accumulation multiplier.
 261 |     |      * @return maxSecondsInLiquidationWindow the max seconds in liquidation window (used together with the acc multiplier to get max liquidation per window).
 262 |     |      * @return maxLiquidationPd max allowed pd when calculating max liquidation amount
 263 |     |      * @return endorsedLiquidator address of the endorsed liquidator who can fully liquidate accounts without any restriction
 264 |     |      */
 265 |     |     function getMaxLiquidationParameters(
 266 |     |         uint128 marketId
 267 |     |     )
 268 |     |         external
 269 |     |         view
 270 |     |         returns (
 271 |     |             uint256 maxLiquidationLimitAccumulationMultiplier,
 272 |     |             uint256 maxSecondsInLiquidationWindow,
 273 |     |             uint256 maxLiquidationPd,
 274 |     |             address endorsedLiquidator
 275 |     |         );
 276 |     | 
 277 |     |     /**
 278 |     |      * @notice Gets liquidation parameters details of a market.
 279 |     |      * @param marketId id of the market.
 280 |     |      * @return initialMarginRatioD18 the initial margin ratio (as decimal with 18 digits precision).
 281 |     |      * @return minimumInitialMarginRatioD18 the minimum initial margin ratio (as decimal with 18 digits precision).
 282 |     |      * @return maintenanceMarginScalarD18 the maintenance margin scalar relative to the initial margin ratio (as decimal with 18 digits precision).
 283 |     |      * @return flagRewardRatioD18 the flag reward ratio (as decimal with 18 digits precision).
 284 |     |      * @return minimumPositionMargin the minimum position margin.
 285 |     |      */
 286 |     |     function getLiquidationParameters(
 287 |     |         uint128 marketId
 288 |     |     )
 289 |     |         external
 290 |     |         view
 291 |     |         returns (
 292 |     |             uint256 initialMarginRatioD18,
 293 |     |             uint256 minimumInitialMarginRatioD18,
 294 |     |             uint256 maintenanceMarginScalarD18,
 295 |     |             uint256 flagRewardRatioD18,
 296 |     |             uint256 minimumPositionMargin
 297 |     |         );
 298 |     | 
 299 |     |     /**
 300 |     |      * @notice Gets funding parameters of a market.
 301 |     |      * @param marketId id of the market.
 302 |     |      * @return skewScale the skew scale.
 303 |     |      * @return maxFundingVelocity the max funding velocity.
 304 |     |      */
 305 |     |     function getFundingParameters(
 306 |     |         uint128 marketId
 307 |     |     ) external view returns (uint256 skewScale, uint256 maxFundingVelocity);
 308 |     | 
 309 |     |     /**
 310 |     |      * @notice Gets the max size of an specific market.
 311 |     |      * @param marketId id of the market.
 312 |     |      * @return maxMarketSize the max market size in market asset units.
 313 |     |      */
 314 |     |     function getMaxMarketSize(uint128 marketId) external view returns (uint256 maxMarketSize);
 315 |     | 
 316 |     |     /**
 317 |     |      * @notice Gets the max size (in value) of an specific market.
 318 |     |      * @param marketId id of the market.
 319 |     |      * @return maxMarketValue the max market size in market USD value.
 320 |     |      */
 321 |     |     function getMaxMarketValue(uint128 marketId) external view returns (uint256 maxMarketValue);
 322 |     | 
 323 |     |     /**
 324 |     |      * @notice Gets the order fees of a market.
 325 |     |      * @param marketId id of the market.
 326 |     |      * @return makerFeeRatio the maker fee ratio.
 327 |     |      * @return takerFeeRatio the taker fee ratio.
 328 |     |      */
 329 |     |     function getOrderFees(
 330 |     |         uint128 marketId
 331 |     |     ) external view returns (uint256 makerFeeRatio, uint256 takerFeeRatio);
 332 |     | 
 333 |     |     /**
 334 |     |      * @notice Gets the locked OI ratio of a market.
 335 |     |      * @param marketId id of the market.
 336 |     |      * @return lockedOiRatioD18 the locked OI ratio skew scale (as decimal with 18 digits precision).
 337 |     |      */
 338 |     |     function getLockedOiRatio(uint128 marketId) external view returns (uint256 lockedOiRatioD18);
 339 |     | 
 340 |     |     /**
 341 |     |      * @notice Set node id for perps market
 342 |     |      * @param perpsMarketId id of the market to set price feed.
 343 |     |      * @return feedId the node feed id to get price
 344 |     |      * @param strictStalenessTolerance configured strict price tolerance in seconds
 345 |     |      */
 346 |     |     function getPriceData(
 347 |     |         uint128 perpsMarketId
 348 |     |     ) external view returns (bytes32 feedId, uint256 strictStalenessTolerance);
 349 |     | }
 350 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IMarketEvents.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Market events used on several places in the system.
  8 |     |  */
  9 |     | interface IMarketEvents {
 10 |     |     /**
 11 |     |      * @notice Gets thrown when settle order is called with invalid settlement strategy.
 12 |     |      */
 13 |     |     error SettlementStrategyNotFound(SettlementStrategy.Type strategyType);
 14 |     | 
 15 |     |     /**
 16 |     |      * @notice Gets fired when the size of a market is updated by new orders or liquidations.
 17 |     |      * @param marketId Id of the market used for the trade.
 18 |     |      * @param price Price at the time of this event.
 19 |     |      * @param skew Market skew at the time of the trade. Positive values mean more longs.
 20 |     |      * @param size Size of the entire market after settlement.
 21 |     |      * @param sizeDelta Change in market size during this update.
 22 |     |      * @param currentFundingRate The current funding rate of this market (0.001 = 0.1% per day)
 23 |     |      * @param currentFundingVelocity The current rate of change of the funding rate (0.001 = +0.1% per day)
 24 |     |      * @param interestRate Current supermarket interest rate based on updated market OI.
 25 |     |      */
 26 |     |     event MarketUpdated(
 27 |     |         uint128 marketId,
 28 |     |         uint256 price,
 29 |     |         int256 skew,
 30 |     |         uint256 size,
 31 |     |         int256 sizeDelta,
 32 |     |         int256 currentFundingRate,
 33 |     |         int256 currentFundingVelocity,
 34 |     |         uint128 interestRate
 35 |     |     );
 36 |     | }
 37 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IPerpsAccountModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Account module
   6 |     |  */
   7 |     | interface IPerpsAccountModule {
   8 |     |     /**
   9 |     |      * @notice Gets fired when an account colateral is modified.
  10 |     |      * @param accountId Id of the account.
  11 |     |      * @param collateralId Id of the synth market used as collateral. Synth market id, 0 for snxUSD.
  12 |     |      * @param amountDelta requested change in amount of collateral delegated to the account.
  13 |     |      * @param sender address of the sender of the size modification. Authorized by account owner.
  14 |     |      */
  15 |     |     event CollateralModified(
  16 |     |         uint128 indexed accountId,
  17 |     |         uint128 indexed collateralId,
  18 |     |         int256 amountDelta,
  19 |     |         address indexed sender
  20 |     |     );
  21 |     | 
  22 |     |     event DebtPaid(uint128 indexed accountId, uint256 amount, address indexed sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @notice Gets thrown when the amount delta is zero.
  26 |     |      */
  27 |     |     error InvalidAmountDelta(int256 amountDelta);
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Modify the collateral delegated to the account.
  31 |     |      * @param accountId Id of the account.
  32 |     |      * @param collateralId Id of the synth market used as collateral. Synth market id, 0 for snxUSD.
  33 |     |      * @param amountDelta requested change in amount of collateral delegated to the account.
  34 |     |      */
  35 |     |     function modifyCollateral(uint128 accountId, uint128 collateralId, int256 amountDelta) external;
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Gets the account's collateral value for a specific collateral.
  39 |     |      * @param accountId Id of the account.
  40 |     |      * @param collateralId Id of the synth market used as collateral. Synth market id, 0 for snxUSD.
  41 |     |      * @return collateralValue collateral value of the account.
  42 |     |      */
  43 |     |     function getCollateralAmount(
  44 |     |         uint128 accountId,
  45 |     |         uint128 collateralId
  46 |     |     ) external view returns (uint256);
  47 |     | 
  48 |     |     /**
  49 |     |      * @notice Gets the account's collaterals ids
  50 |     |      * @param accountId Id of the account.
  51 |     |      */
  52 |     |     function getAccountCollateralIds(uint128 accountId) external view returns (uint256[] memory);
  53 |     | 
  54 |     |     /**
  55 |     |      * @notice Gets all markets that a given account id has a position in
  56 |     |      * @param accountId Id of the account.
  57 |     |      */
  58 |     |     function getAccountOpenPositions(uint128 accountId) external view returns (uint256[] memory);
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice Gets the account's total collateral value without the discount applied.
  62 |     |      * @param accountId Id of the account.
  63 |     |      * @return collateralValue total collateral value of the account without discount. USD denominated.
  64 |     |      */
  65 |     |     function totalCollateralValue(uint128 accountId) external view returns (uint256);
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Gets the account's total open interest value.
  69 |     |      * @param accountId Id of the account.
  70 |     |      * @return openInterestValue total open interest value of the account.
  71 |     |      */
  72 |     |     function totalAccountOpenInterest(uint128 accountId) external view returns (uint256);
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Gets the details of an open position.
  76 |     |      * @param accountId Id of the account.
  77 |     |      * @param marketId Id of the position market.
  78 |     |      * @return totalPnl pnl of the entire position including funding.
  79 |     |      * @return accruedFunding accrued funding of the position.
  80 |     |      * @return positionSize size of the position.
  81 |     |      * @return owedInterest interest owed due to open position.
  82 |     |      */
  83 |     |     function getOpenPosition(
  84 |     |         uint128 accountId,
  85 |     |         uint128 marketId
  86 |     |     )
  87 |     |         external
  88 |     |         view
  89 |     |         returns (int256 totalPnl, int256 accruedFunding, int128 positionSize, uint256 owedInterest);
  90 |     | 
  91 |     |     /**
  92 |     |      * @notice Gets an account open position data for a given account id and market id
  93 |     |      * @notice this function doesn't have any price staleness requirement
  94 |     |      * @param accountId Id of the account.
  95 |     |      * @param marketId Id of the position market.
  96 |     |      */
  97 |     |     function getOpenPositionSize(
  98 |     |         uint128 accountId,
  99 |     |         uint128 marketId
 100 |     |     ) external view returns (int128 positionSize);
 101 |     | 
 102 |     |     /**
 103 |     |      * @notice Gets the available margin of an account. It can be negative due to pnl.
 104 |     |      * @param accountId Id of the account.
 105 |     |      * @return availableMargin available margin of the position.
 106 |     |      */
 107 |     |     function getAvailableMargin(uint128 accountId) external view returns (int256 availableMargin);
 108 |     | 
 109 |     |     /**
 110 |     |      * @notice Gets the exact withdrawable amount a trader has available from this account while holding the account's current positions.
 111 |     |      * @param accountId Id of the account.
 112 |     |      * @return withdrawableMargin available margin to withdraw.
 113 |     |      */
 114 |     |     function getWithdrawableMargin(
 115 |     |         uint128 accountId
 116 |     |     ) external view returns (int256 withdrawableMargin);
 117 |     | 
 118 |     |     /**
 119 |     |      * @notice Gets the initial/maintenance margins across all positions that an account has open.
 120 |     |      * @dev Note that requiredInitialMargin and requiredMaintenanceMargin includes the liquidation rewards, in case you want the value without it you need to substract maxLiquidationReward.
 121 |     |      * @param accountId Id of the account.
 122 |     |      * @return requiredInitialMargin initial margin req (used when withdrawing collateral).
 123 |     |      * @return requiredMaintenanceMargin maintenance margin req (used to determine liquidation threshold).
 124 |     |      * @return maxLiquidationReward max liquidation reward the keeper would receive if account was fully liquidated. Note here that the accumulated rewards are checked against the global max/min configured liquidation rewards.
 125 |     |      */
 126 |     |     function getRequiredMargins(
 127 |     |         uint128 accountId
 128 |     |     )
 129 |     |         external
 130 |     |         view
 131 |     |         returns (
 132 |     |             uint256 requiredInitialMargin,
 133 |     |             uint256 requiredMaintenanceMargin,
 134 |     |             uint256 maxLiquidationReward
 135 |     |         );
 136 |     | 
 137 |     |     /**
 138 |     |      * @notice Allows anyone to pay an account's debt
 139 |     |      * @param accountId Id of the account.
 140 |     |      * @param amount debt amount to pay off
 141 |     |      */
 142 |     |     function payDebt(uint128 accountId, uint256 amount) external;
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Returns account's debt
 146 |     |      * @param accountId Id of the account.
 147 |     |      * @return accountDebt specified account id's debt
 148 |     |      */
 149 |     |     function debt(uint128 accountId) external view returns (uint256 accountDebt);
 150 |     | }
 151 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IPerpsMarketFactoryModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {IMarket} from "@synthetixio/main/contracts/interfaces/external/IMarket.sol";
  5 |     | import {ISynthetixSystem} from "./external/ISynthetixSystem.sol";
  6 |     | import {ISpotMarketSystem} from "./external/ISpotMarketSystem.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title Perps Market Factory module
 10 |     |  */
 11 |     | interface IPerpsMarketFactoryModule is IMarket {
 12 |     |     /**
 13 |     |      * @notice Gets fired when the factory is initialized.
 14 |     |      * @param globalPerpsMarketId the new global perps market id.
 15 |     |      */
 16 |     |     event FactoryInitialized(uint128 globalPerpsMarketId);
 17 |     | 
 18 |     |     /**
 19 |     |      * @notice Gets fired when a market is created.
 20 |     |      * @param perpsMarketId the newly created perps market id.
 21 |     |      * @param marketName the newly created perps market name.
 22 |     |      * @param marketSymbol the newly created perps market symbol.
 23 |     |      */
 24 |     |     event MarketCreated(uint128 indexed perpsMarketId, string marketName, string marketSymbol);
 25 |     | 
 26 |     |     /**
 27 |     |      * @notice Initializes the factory.
 28 |     |      * @dev this function should be called only once.
 29 |     |      * @return globalPerpsMarketId Id of the global perps market id.
 30 |     |      */
 31 |     |     function initializeFactory(
 32 |     |         ISynthetixSystem synthetix,
 33 |     |         ISpotMarketSystem spotMarket
 34 |     |     ) external returns (uint128);
 35 |     | 
 36 |     |     /**
 37 |     |      * @notice Sets the perps market name.
 38 |     |      * @param marketName the new perps market name.
 39 |     |      */
 40 |     |     function setPerpsMarketName(string memory marketName) external;
 41 |     | 
 42 |     |     /**
 43 |     |      * @notice Creates a new market.
 44 |     |      * @param requestedMarketId id of the market to create.
 45 |     |      * @param marketName name of the market to create.
 46 |     |      * @param marketSymbol symbol of the market to create.
 47 |     |      * @return perpsMarketId Id of the created perps market.
 48 |     |      */
 49 |     |     function createMarket(
 50 |     |         uint128 requestedMarketId,
 51 |     |         string memory marketName,
 52 |     |         string memory marketSymbol
 53 |     |     ) external returns (uint128);
 54 |     | 
 55 |     |     /**
 56 |     |      * @notice Returns the current market interest rate
 57 |     |      * @return rate
 58 |     |      */
 59 |     |     function interestRate() external view returns (uint128 rate);
 60 |     | 
 61 |     |     /**
 62 |     |      * @notice Returns the super market utilization rate
 63 |     |      * @dev The rate is the minimumCredit / delegatedCollateral available.
 64 |     |      * @dev Locked credit is the sum of all markets open interest * configured lockedOiRatio
 65 |     |      * @dev delegatedCollateral is the avaialble collateral value for markets to withdraw, delegated by LPs
 66 |     |      * @return rate
 67 |     |      * @return delegatedCollateral
 68 |     |      * @return lockedCredit credit locked based on OI & lockedOiRatio
 69 |     |      */
 70 |     |     function utilizationRate()
 71 |     |         external
 72 |     |         view
 73 |     |         returns (uint256 rate, uint256 delegatedCollateral, uint256 lockedCredit);
 74 |     | }
 75 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/IPerpsMarketModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Perps market module
   6 |     |  */
   7 |     | interface IPerpsMarketModule {
   8 |     |     /**
   9 |     |      * @notice Market Summary structured data.
  10 |     |      */
  11 |     |     struct MarketSummary {
  12 |     |         // @dev Skew of the market in units of native asse
  13 |     |         int256 skew;
  14 |     |         // @dev Size of the market in units of native asset
  15 |     |         uint256 size;
  16 |     |         // @dev Max open interest of the market in units of native asset
  17 |     |         uint256 maxOpenInterest;
  18 |     |         // @dev Current funding rate of the market
  19 |     |         int256 currentFundingRate;
  20 |     |         // @dev Current funding velocity of the market
  21 |     |         int256 currentFundingVelocity;
  22 |     |         // @dev Index price of the market
  23 |     |         uint256 indexPrice;
  24 |     |     }
  25 |     | 
  26 |     |     /**
  27 |     |      * @notice Gets a market metadata.
  28 |     |      * @param marketId Id of the market.
  29 |     |      * @return name Name of the market.
  30 |     |      * @return symbol Symbol of the market.
  31 |     |      */
  32 |     |     function metadata(
  33 |     |         uint128 marketId
  34 |     |     ) external view returns (string memory name, string memory symbol);
  35 |     | 
  36 |     |     /**
  37 |     |      * @notice Gets a market's skew.
  38 |     |      * @param marketId Id of the market.
  39 |     |      * @return skew Skew of the market.
  40 |     |      */
  41 |     |     function skew(uint128 marketId) external view returns (int256);
  42 |     | 
  43 |     |     /**
  44 |     |      * @notice Gets a market's size.
  45 |     |      * @param marketId Id of the market.
  46 |     |      * @return size Size of the market.
  47 |     |      */
  48 |     |     function size(uint128 marketId) external view returns (uint256);
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Gets a market's max open interest.
  52 |     |      * @param marketId Id of the market.
  53 |     |      * @return maxOpenInterest Max open interest of the market.
  54 |     |      */
  55 |     |     function maxOpenInterest(uint128 marketId) external view returns (uint256);
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice Gets a market's current funding rate.
  59 |     |      * @param marketId Id of the market.
  60 |     |      * @return currentFundingRate Current funding rate of the market.
  61 |     |      */
  62 |     |     function currentFundingRate(uint128 marketId) external view returns (int256);
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Gets a market's current funding velocity.
  66 |     |      * @param marketId Id of the market.
  67 |     |      * @return currentFundingVelocity Current funding velocity of the market.
  68 |     |      */
  69 |     |     function currentFundingVelocity(uint128 marketId) external view returns (int256);
  70 |     | 
  71 |     |     /**
  72 |     |      * @notice Gets a market's index price.
  73 |     |      * @param marketId Id of the market.
  74 |     |      * @return indexPrice Index price of the market.
  75 |     |      */
  76 |     |     function indexPrice(uint128 marketId) external view returns (uint256);
  77 |     | 
  78 |     |     /**
  79 |     |      * @notice Gets a market's fill price for a specific order size and index price.
  80 |     |      * @param marketId Id of the market.
  81 |     |      * @param orderSize Order size.
  82 |     |      * @param price Index price.
  83 |     |      * @return price Fill price.
  84 |     |      */
  85 |     |     function fillPrice(
  86 |     |         uint128 marketId,
  87 |     |         int128 orderSize,
  88 |     |         uint256 price
  89 |     |     ) external view returns (uint256);
  90 |     | 
  91 |     |     /**
  92 |     |      * @notice Given a marketId return a market's summary details in one call.
  93 |     |      * @param marketId Id of the market.
  94 |     |      * @return summary Market summary (see MarketSummary).
  95 |     |      */
  96 |     |     function getMarketSummary(
  97 |     |         uint128 marketId
  98 |     |     ) external view returns (MarketSummary memory summary);
  99 |     | }
 100 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/IFeeCollector.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
  5 |     | 
  6 |     | interface IFeeCollector is IERC165 {
  7 |     |     /**
  8 |     |      * @notice  .This function is called by the spot market proxy to get the fee amount to be collected.
  9 |     |      * @dev     .The quoted fee amount is then transferred directly to the fee collector.
 10 |     |      * @param   marketId  .synth market id value
 11 |     |      * @param   feeAmount  .max fee amount that can be collected
 12 |     |      * @param   transactor  .the trader the fee was collected from
 13 |     |      * @return  feeAmountToCollect  .quoted fee amount
 14 |     |      */
 15 |     |     function quoteFees(
 16 |     |         uint128 marketId,
 17 |     |         uint256 feeAmount,
 18 |     |         address transactor
 19 |     |     ) external returns (uint256 feeAmountToCollect);
 20 |     | }
 21 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/IPythERC7412Wrapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | interface IPythERC7412Wrapper {
  5 |     |     error OracleDataRequired(address oracleContract, bytes oracleQuery);
  6 |     | 
  7 |     |     function getBenchmarkPrice(
  8 |     |         bytes32 priceId,
  9 |     |         uint64 requestedTime
 10 |     |     ) external view returns (int256);
 11 |     | }
 12 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/ISpotMarketSystem.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {IAtomicOrderModule} from "@synthetixio/spot-market/contracts/interfaces/IAtomicOrderModule.sol";
  5 |     | import {ISpotMarketFactoryModule} from "@synthetixio/spot-market/contracts/interfaces/ISpotMarketFactoryModule.sol";
  6 |     | import {IMarketConfigurationModule} from "@synthetixio/spot-market/contracts/interfaces/IMarketConfigurationModule.sol";
  7 |     | 
  8 |     | // solhint-disable-next-line no-empty-blocks
  9 |     | interface ISpotMarketSystem is
 10 |     |     IAtomicOrderModule,
 11 |     |     ISpotMarketFactoryModule,
 12 |     |     IMarketConfigurationModule
 13 |     | {}
 14 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/interfaces/external/ISynthetixSystem.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {IAssociatedSystemsModule} from "@synthetixio/core-modules/contracts/interfaces/IAssociatedSystemsModule.sol";
  5 |     | import {IMarketManagerModule} from "@synthetixio/main/contracts/interfaces/IMarketManagerModule.sol";
  6 |     | import {IMarketCollateralModule} from "@synthetixio/main/contracts/interfaces/IMarketCollateralModule.sol";
  7 |     | import {IUtilsModule} from "@synthetixio/main/contracts/interfaces/IUtilsModule.sol";
  8 |     | import {ICollateralConfigurationModule} from "@synthetixio/main/contracts/interfaces/ICollateralConfigurationModule.sol";
  9 |     | import {IVaultModule} from "@synthetixio/main/contracts/interfaces/IVaultModule.sol";
 10 |     | 
 11 |     | // solhint-disable-next-line no-empty-blocks
 12 |     | interface ISynthetixSystem is
 13 |     |     IAssociatedSystemsModule,
 14 |     |     IMarketCollateralModule,
 15 |     |     IMarketManagerModule,
 16 |     |     IUtilsModule,
 17 |     |     ICollateralConfigurationModule,
 18 |     |     IVaultModule
 19 |     | {}
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/mocks/MockGasPriceNode.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import "@synthetixio/oracle-manager/contracts/interfaces/external/IExternalNode.sol";
  5 |     | 
  6 |     | contract MockGasPriceNode is IExternalNode {
  7 |     |     NodeOutput.Data private output;
  8 |     | 
  9 |     |     uint256 public constant KIND_SETTLEMENT = 0;
 10 |     |     uint256 public constant KIND_FLAG = 1;
 11 |     |     uint256 public constant KIND_LIQUIDATE = 2;
 12 |     | 
 13 |     |     uint256 public settlementCost;
 14 |     |     uint256 public flagCost;
 15 |     |     uint256 public liquidateCost;
 16 |     | 
 17 |     |     constructor() {}
 18 |     | 
 19 |     |     function setCosts(uint256 _settlementCost, uint256 _flagCost, uint256 _liquidateCost) external {
 20 |     |         settlementCost = _settlementCost;
 21 |     |         flagCost = _flagCost;
 22 |     |         liquidateCost = _liquidateCost;
 23 |     |     }
 24 |     | 
 25 |     |     // solhint-disable numcast/safe-cast
 26 |     |     function process(
 27 |     |         NodeOutput.Data[] memory,
 28 |     |         bytes memory,
 29 |     |         bytes32[] memory runtimeKeys,
 30 |     |         bytes32[] memory runtimeValues
 31 |     |     ) external view override returns (NodeOutput.Data memory) {
 32 |     |         NodeOutput.Data memory theOutput = output;
 33 |     |         uint256 executionKind;
 34 |     |         uint256 numberOfUpdatedFeeds;
 35 |     |         for (uint256 i = 0; i < runtimeKeys.length; i++) {
 36 |     |             if (runtimeKeys[i] == "executionKind") {
 37 |     |                 executionKind = uint256(runtimeValues[i]);
 38 |     |                 continue;
 39 |     |             }
 40 |     |             if (runtimeKeys[i] == "numberOfUpdatedFeeds") {
 41 |     |                 numberOfUpdatedFeeds = uint256(runtimeValues[i]);
 42 |     |                 continue;
 43 |     |             }
 44 |     |         }
 45 |     | 
 46 |     |         if (executionKind == KIND_SETTLEMENT) {
 47 |     |             theOutput.price = int256(settlementCost);
 48 |     |         } else if (executionKind == KIND_FLAG) {
 49 |     |             theOutput.price = int256(flagCost * numberOfUpdatedFeeds);
 50 |     |         } else if (executionKind == KIND_LIQUIDATE) {
 51 |     |             theOutput.price = int256(liquidateCost);
 52 |     |         } else {
 53 |     |             revert("Invalid execution kind");
 54 |     |         }
 55 |     | 
 56 |     |         return theOutput;
 57 |     |     }
 58 |     | 
 59 |     |     function isValid(
 60 |     |         NodeDefinition.Data memory nodeDefinition
 61 |     |     ) external pure override returns (bool) {
 62 |     |         return nodeDefinition.nodeType == NodeDefinition.NodeType.EXTERNAL;
 63 |     |     }
 64 |     | 
 65 |     |     function supportsInterface(bytes4) public view virtual override(IERC165) returns (bool) {
 66 |     |         return true;
 67 |     |     }
 68 |     | }
 69 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/mocks/MockPythERC7412Wrapper.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | import {console2} from "lib/forge-std/src/Test.sol";
  4 |     | import {MockOracleManager} from "../fuzzing/mocks/MockOracleManager.sol";
  5 |     | 
  6 | *   | contract MockPythERC7412Wrapper {
  7 |     |     MockOracleManager mockOracleManager;
  8 |     | 
  9 |     |     bool public alwaysRevert;
 10 |     |     int256 public price;
 11 |     |     mapping(bytes32 => int256) feedToPrice;
 12 |     | 
 13 |     |     error OracleDataRequired(bytes32 priceId, uint64 requestedTime);
 14 |     | 
 15 |     |     constructor(address _oracleManager) {
 16 |     |         mockOracleManager = MockOracleManager(_oracleManager);
 17 |     |     }
 18 |     | 
 19 | *   |     function setBenchmarkPrice(bytes32 priceId, int256 _price) external {
 20 | *   |         feedToPrice[priceId] = _price;
 21 | *   |         mockOracleManager.changePrice(priceId, _price);
 22 | *   |         alwaysRevert = false;
 23 |     |     }
 24 |     | 
 25 | *   |     function setAlwaysRevertFlag(bool _alwaysRevert) external {
 26 |     |         alwaysRevert = _alwaysRevert;
 27 |     |     }
 28 |     | 
 29 | *   |     function getBenchmarkPrice(
 30 |     |         bytes32 priceId,
 31 |     |         uint64 requestedTime
 32 | *   |     ) external view returns (int256) {
 33 | *   |         if (alwaysRevert) {
 34 |     |             revert OracleDataRequired(priceId, requestedTime);
 35 |     |         }
 36 |     | 
 37 | *   |         return feedToPrice[priceId];
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/AsyncOrderCancelModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {FeatureFlag} from "@synthetixio/core-modules/contracts/storage/FeatureFlag.sol";
   5 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   6 |     | import {IAsyncOrderCancelModule} from "../interfaces/IAsyncOrderCancelModule.sol";
   7 |     | import {PerpsAccount} from "../storage/PerpsAccount.sol";
   8 |     | import {Flags} from "../utils/Flags.sol";
   9 |     | import {AsyncOrder} from "../storage/AsyncOrder.sol";
  10 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
  11 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
  12 |     | import {PerpsMarketFactory} from "../storage/PerpsMarketFactory.sol";
  13 |     | import {IMarketEvents} from "../interfaces/IMarketEvents.sol";
  14 |     | import {IAccountEvents} from "../interfaces/IAccountEvents.sol";
  15 |     | import {IPythERC7412Wrapper} from "../interfaces/external/IPythERC7412Wrapper.sol";
  16 |     | import {SafeCastU256, SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  17 |     | 
  18 |     | /**
  19 |     |  * @title Module for cancelling async orders.
  20 |     |  * @dev See IAsyncOrderCancelModule.
  21 |     |  */
  22 | *   | contract AsyncOrderCancelModule is IAsyncOrderCancelModule, IMarketEvents, IAccountEvents {
  23 |     |     using SafeCastI256 for int256;
  24 |     |     using SafeCastU256 for uint256;
  25 |     |     using PerpsAccount for PerpsAccount.Data;
  26 |     |     using AsyncOrder for AsyncOrder.Data;
  27 |     |     using PerpsMarketFactory for PerpsMarketFactory.Data;
  28 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  29 |     | 
  30 |     |     /**
  31 |     |      * @inheritdoc IAsyncOrderCancelModule
  32 |     |      */
  33 | *   |     function cancelOrder(uint128 accountId) external {
  34 | *   |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
  35 |     | 
  36 | *   |         (
  37 | *   |             AsyncOrder.Data storage asyncOrder,
  38 | *   |             SettlementStrategy.Data storage settlementStrategy
  39 | *   |         ) = AsyncOrder.loadValid(accountId);
  40 |     | 
  41 | *   |         int256 offchainPrice = IPythERC7412Wrapper(settlementStrategy.priceVerificationContract)
  42 |     |             .getBenchmarkPrice(
  43 | *   |                 settlementStrategy.feedId,
  44 | *   |                 (asyncOrder.commitmentTime + settlementStrategy.commitmentPriceDelay).to64()
  45 |     |             );
  46 |     | 
  47 | *   |         _cancelOrder(offchainPrice.toUint(), asyncOrder, settlementStrategy);
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev used for canceling an order.
  52 |     |      */
  53 | *   |     function _cancelOrder(
  54 |     |         uint256 price,
  55 |     |         AsyncOrder.Data storage asyncOrder,
  56 |     |         SettlementStrategy.Data storage settlementStrategy
  57 |     |     ) private {
  58 |     |         CancelOrderRuntime memory runtime;
  59 |     |         // Get the current data before resetting the order
  60 | *   |         runtime.accountId = asyncOrder.request.accountId;
  61 | *   |         runtime.marketId = asyncOrder.request.marketId;
  62 | *   |         runtime.acceptablePrice = asyncOrder.request.acceptablePrice;
  63 | *   |         runtime.settlementReward = settlementStrategy.settlementReward;
  64 | *   |         runtime.sizeDelta = asyncOrder.request.sizeDelta;
  65 |     | 
  66 |     |         // check if account is flagged
  67 | *   |         GlobalPerpsMarket.load().checkLiquidation(runtime.accountId);
  68 |     | 
  69 | *   |         runtime.fillPrice = asyncOrder.validateCancellation(settlementStrategy, price);
  70 |     | 
  71 |     |         if (runtime.settlementReward > 0) {
  72 |     |             // charge account the settlement reward
  73 |     |             uint256 accountDebt = PerpsAccount.load(runtime.accountId).charge(
  74 |     |                 -runtime.settlementReward.toInt()
  75 |     |             );
  76 |     | 
  77 |     |             emit AccountCharged(runtime.accountId, runtime.settlementReward.toInt(), accountDebt);
  78 |     | 
  79 |     |             // pay keeper
  80 |     |             PerpsMarketFactory.load().withdrawMarketUsd(
  81 |     |                 ERC2771Context._msgSender(),
  82 |     |                 runtime.settlementReward
  83 |     |             );
  84 |     |         }
  85 |     | 
  86 |     |         // trader can now commit a new order
  87 |     |         asyncOrder.reset();
  88 |     | 
  89 |     |         // emit event
  90 |     |         emit OrderCancelled(
  91 |     |             runtime.marketId,
  92 |     |             runtime.accountId,
  93 |     |             runtime.acceptablePrice,
  94 |     |             runtime.fillPrice,
  95 |     |             runtime.sizeDelta,
  96 |     |             runtime.settlementReward,
  97 |     |             asyncOrder.request.trackingCode,
  98 |     |             ERC2771Context._msgSender()
  99 |     |         );
 100 |     |     }
 101 |     | }
 102 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/AsyncOrderModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   5 |     | import {FeatureFlag} from "@synthetixio/core-modules/contracts/storage/FeatureFlag.sol";
   6 |     | import {Account} from "@synthetixio/main/contracts/storage/Account.sol";
   7 |     | import {AccountRBAC} from "@synthetixio/main/contracts/storage/AccountRBAC.sol";
   8 |     | import {IAsyncOrderModule} from "../interfaces/IAsyncOrderModule.sol";
   9 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
  10 |     | import {PerpsAccount} from "../storage/PerpsAccount.sol";
  11 |     | import {AsyncOrder} from "../storage/AsyncOrder.sol";
  12 |     | import {Position} from "../storage/Position.sol";
  13 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
  14 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
  15 |     | import {PerpsMarketConfiguration} from "../storage/PerpsMarketConfiguration.sol";
  16 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
  17 |     | import {Flags} from "../utils/Flags.sol";
  18 |     | 
  19 |     | /**
  20 |     |  * @title Module for committing async orders.
  21 |     |  * @dev See IAsyncOrderModule.
  22 |     |  */
  23 | *   | contract AsyncOrderModule is IAsyncOrderModule {
  24 |     |     using AsyncOrder for AsyncOrder.Data;
  25 |     |     using PerpsAccount for PerpsAccount.Data;
  26 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  27 |     | 
  28 |     |     /**
  29 |     |      * @inheritdoc IAsyncOrderModule
  30 |     |      */
  31 | *   |     function commitOrder(
  32 |     |         AsyncOrder.OrderCommitmentRequest memory commitment
  33 | *   |     ) external override returns (AsyncOrder.Data memory retOrder, uint256 fees) {
  34 | *   |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
  35 | *   |         PerpsMarket.loadValid(commitment.marketId);
  36 |     | 
  37 |     |         // Check if commitment.accountId is valid
  38 | *   |         Account.exists(commitment.accountId);
  39 |     | 
  40 |     |         // Check ERC2771Context._msgSender() can commit order for commitment.accountId
  41 | *   |         Account.loadAccountAndValidatePermission(
  42 | *   |             commitment.accountId,
  43 | *   |             AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION
  44 |     |         );
  45 |     | 
  46 | *   |         GlobalPerpsMarket.load().checkLiquidation(commitment.accountId);
  47 |     | 
  48 | *   |         SettlementStrategy.Data storage strategy = PerpsMarketConfiguration
  49 | *   |             .loadValidSettlementStrategy(commitment.marketId, commitment.settlementStrategyId);
  50 |     | 
  51 | *   |         AsyncOrder.Data storage order = AsyncOrder.load(commitment.accountId);
  52 |     | 
  53 |     |         // if order (previous) sizeDelta is not zero and didn't revert while checking, it means the previous order expired
  54 | *   |         if (order.request.sizeDelta != 0) {
  55 |     |             // @notice not including the expiration time since it requires the previous settlement strategy to be loaded and enabled, otherwise loading it will revert and will prevent new orders to be committed
  56 | *   |             emit PreviousOrderExpired(
  57 | *   |                 order.request.marketId,
  58 | *   |                 order.request.accountId,
  59 | *   |                 order.request.sizeDelta,
  60 | *   |                 order.request.acceptablePrice,
  61 | *   |                 order.commitmentTime,
  62 | *   |                 order.request.trackingCode
  63 |     |             );
  64 |     |         }
  65 |     | 
  66 | *   |         order.updateValid(commitment);
  67 |     | 
  68 | *   |         (, uint256 feesAccrued, , ) = order.validateRequest(
  69 | *   |             strategy,
  70 | *   |             PerpsPrice.getCurrentPrice(commitment.marketId, PerpsPrice.Tolerance.DEFAULT)
  71 |     |         );
  72 |     | 
  73 | *   |         emit OrderCommitted(
  74 | *   |             commitment.marketId,
  75 | *   |             commitment.accountId,
  76 | *   |             strategy.strategyType,
  77 | *   |             commitment.sizeDelta,
  78 | *   |             commitment.acceptablePrice,
  79 | *   |             order.commitmentTime,
  80 | *   |             order.commitmentTime + strategy.commitmentPriceDelay,
  81 | *   |             order.commitmentTime + strategy.settlementDelay,
  82 | *   |             order.commitmentTime + strategy.settlementDelay + strategy.settlementWindowDuration,
  83 | *   |             commitment.trackingCode,
  84 | *   |             ERC2771Context._msgSender()
  85 |     |         );
  86 |     | 
  87 | *   |         return (order, feesAccrued);
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @inheritdoc IAsyncOrderModule
  92 |     |      */
  93 |     |     // solc-ignore-next-line func-mutability
  94 |     |     function getOrder(
  95 |     |         uint128 accountId
  96 |     |     ) external view override returns (AsyncOrder.Data memory order) {
  97 |     |         order = AsyncOrder.load(accountId);
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @inheritdoc IAsyncOrderModule
 102 |     |      */
 103 |     |     function computeOrderFees(
 104 |     |         uint128 marketId,
 105 |     |         int128 sizeDelta
 106 |     |     ) external view override returns (uint256 orderFees, uint256 fillPrice) {
 107 |     |         (orderFees, fillPrice) = _computeOrderFees(
 108 |     |             marketId,
 109 |     |             sizeDelta,
 110 |     |             PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)
 111 |     |         );
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @inheritdoc IAsyncOrderModule
 116 |     |      */
 117 | *   |     function computeOrderFeesWithPrice(
 118 |     |         uint128 marketId,
 119 |     |         int128 sizeDelta,
 120 |     |         uint256 price
 121 | *   |     ) external view override returns (uint256 orderFees, uint256 fillPrice) {
 122 | *   |         (orderFees, fillPrice) = _computeOrderFees(marketId, sizeDelta, price);
 123 |     |     }
 124 |     | 
 125 |     |     /**
 126 |     |      * @inheritdoc IAsyncOrderModule
 127 |     |      */
 128 | *   |     function getSettlementRewardCost(
 129 |     |         uint128 marketId,
 130 |     |         uint128 settlementStrategyId
 131 |     |     ) external view override returns (uint256) {
 132 | *   |         return
 133 | *   |             AsyncOrder.settlementRewardCost(
 134 |     |                 PerpsMarketConfiguration.loadValidSettlementStrategy(marketId, settlementStrategyId)
 135 |     |             );
 136 |     |     }
 137 |     | 
 138 |     |     function requiredMarginForOrder(
 139 |     |         uint128 accountId,
 140 |     |         uint128 marketId,
 141 |     |         int128 sizeDelta
 142 |     |     ) external view override returns (uint256 requiredMargin) {
 143 |     |         return
 144 |     |             _requiredMarginForOrder(
 145 |     |                 accountId,
 146 |     |                 marketId,
 147 |     |                 sizeDelta,
 148 |     |                 PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)
 149 |     |             );
 150 |     |     }
 151 |     | 
 152 | *   |     function requiredMarginForOrderWithPrice(
 153 |     |         uint128 accountId,
 154 |     |         uint128 marketId,
 155 |     |         int128 sizeDelta,
 156 |     |         uint256 price
 157 |     |     ) external view override returns (uint256 requiredMargin) {
 158 |     |         return _requiredMarginForOrder(accountId, marketId, sizeDelta, price);
 159 |     |     }
 160 |     | 
 161 |     |     function _requiredMarginForOrder(
 162 |     |         uint128 accountId,
 163 |     |         uint128 marketId,
 164 |     |         int128 sizeDelta,
 165 |     |         uint256 orderPrice
 166 |     |     ) internal view returns (uint256 requiredMargin) {
 167 |     |         PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(
 168 |     |             marketId
 169 |     |         );
 170 |     | 
 171 |     |         Position.Data storage oldPosition = PerpsMarket.accountPosition(marketId, accountId);
 172 |     |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
 173 |     |         (uint256 currentInitialMargin, , ) = account.getAccountRequiredMargins(
 174 |     |             PerpsPrice.Tolerance.DEFAULT
 175 |     |         );
 176 |     |         (uint256 orderFees, uint256 fillPrice) = _computeOrderFees(marketId, sizeDelta, orderPrice);
 177 |     | 
 178 |     |         return
 179 |     |             AsyncOrder.getRequiredMarginWithNewPosition(
 180 |     |                 account,
 181 |     |                 marketConfig,
 182 |     |                 marketId,
 183 |     |                 oldPosition.size,
 184 |     |                 oldPosition.size + sizeDelta,
 185 |     |                 fillPrice,
 186 |     |                 currentInitialMargin
 187 |     |             ) + orderFees;
 188 |     |     }
 189 |     | 
 190 | *   |     function _computeOrderFees(
 191 |     |         uint128 marketId,
 192 |     |         int128 sizeDelta,
 193 |     |         uint256 orderPrice
 194 | *   |     ) private view returns (uint256 orderFees, uint256 fillPrice) {
 195 | *   |         int256 skew = PerpsMarket.load(marketId).skew;
 196 | *   |         PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(
 197 | *   |             marketId
 198 |     |         );
 199 | *   |         fillPrice = AsyncOrder.calculateFillPrice(
 200 | *   |             skew,
 201 | *   |             marketConfig.skewScale,
 202 | *   |             sizeDelta,
 203 | *   |             orderPrice
 204 |     |         );
 205 |     | 
 206 | *   |         orderFees = AsyncOrder.calculateOrderFee(
 207 | *   |             sizeDelta,
 208 |     |             fillPrice,
 209 | *   |             skew,
 210 | *   |             marketConfig.orderFees
 211 |     |         );
 212 |     |     }
 213 |     | }
 214 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/AsyncOrderSettlementPythModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   5 |     | import {FeatureFlag} from "@synthetixio/core-modules/contracts/storage/FeatureFlag.sol";
   6 |     | import {IAsyncOrderSettlementPythModule} from "../interfaces/IAsyncOrderSettlementPythModule.sol";
   7 |     | import {PerpsAccount, SNX_USD_MARKET_ID} from "../storage/PerpsAccount.sol";
   8 |     | import {MathUtil} from "../utils/MathUtil.sol";
   9 |     | import {Flags} from "../utils/Flags.sol";
  10 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
  11 |     | import {AsyncOrder} from "../storage/AsyncOrder.sol";
  12 |     | import {Position} from "../storage/Position.sol";
  13 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
  14 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
  15 |     | import {PerpsMarketFactory} from "../storage/PerpsMarketFactory.sol";
  16 |     | import {GlobalPerpsMarketConfiguration} from "../storage/GlobalPerpsMarketConfiguration.sol";
  17 |     | import {IMarketEvents} from "../interfaces/IMarketEvents.sol";
  18 |     | import {IAccountEvents} from "../interfaces/IAccountEvents.sol";
  19 |     | import {KeeperCosts} from "../storage/KeeperCosts.sol";
  20 |     | import {IPythERC7412Wrapper} from "../interfaces/external/IPythERC7412Wrapper.sol";
  21 |     | import {SafeCastU256, SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  22 |     | 
  23 |     | /**
  24 |     |  * @title Module for settling async orders using pyth as price feed.
  25 |     |  * @dev See IAsyncOrderSettlementPythModule.
  26 |     |  */
  27 | *   | contract AsyncOrderSettlementPythModule is
  28 |     |     IAsyncOrderSettlementPythModule,
  29 |     |     IMarketEvents,
  30 |     |     IAccountEvents
  31 |     | {
  32 |     |     using SafeCastI256 for int256;
  33 |     |     using SafeCastU256 for uint256;
  34 |     |     using PerpsAccount for PerpsAccount.Data;
  35 |     |     using PerpsMarket for PerpsMarket.Data;
  36 |     |     using AsyncOrder for AsyncOrder.Data;
  37 |     |     using PerpsMarketFactory for PerpsMarketFactory.Data;
  38 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  39 |     |     using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;
  40 |     |     using Position for Position.Data;
  41 |     |     using KeeperCosts for KeeperCosts.Data;
  42 |     | 
  43 |     |     /**
  44 |     |      * @inheritdoc IAsyncOrderSettlementPythModule
  45 |     |      */
  46 | *   |     function settleOrder(uint128 accountId) external {
  47 | *   |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
  48 |     | 
  49 | *   |         (
  50 | *   |             AsyncOrder.Data storage asyncOrder,
  51 | *   |             SettlementStrategy.Data storage settlementStrategy
  52 | *   |         ) = AsyncOrder.loadValid(accountId);
  53 |     | 
  54 | *   |         int256 offchainPrice = IPythERC7412Wrapper(settlementStrategy.priceVerificationContract)
  55 |     |             .getBenchmarkPrice(
  56 | *   |                 settlementStrategy.feedId,
  57 | *   |                 (asyncOrder.commitmentTime + settlementStrategy.commitmentPriceDelay).to64()
  58 |     |             );
  59 |     | 
  60 | *   |         _settleOrder(offchainPrice.toUint(), asyncOrder, settlementStrategy);
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev used for settleing an order.
  65 |     |      */
  66 | *   |     function _settleOrder(
  67 |     |         uint256 price,
  68 |     |         AsyncOrder.Data storage asyncOrder,
  69 |     |         SettlementStrategy.Data storage settlementStrategy
  70 | *   |     ) private {
  71 | *   |         SettleOrderRuntime memory runtime;
  72 | *   |         runtime.accountId = asyncOrder.request.accountId;
  73 | *   |         runtime.marketId = asyncOrder.request.marketId;
  74 |     |         // check if account is flagged
  75 | *   |         GlobalPerpsMarket.load().checkLiquidation(runtime.accountId);
  76 |     | 
  77 | *   |         Position.Data storage oldPosition;
  78 | *   |         (runtime.newPosition, runtime.totalFees, runtime.fillPrice, oldPosition) = asyncOrder
  79 | *   |             .validateRequest(settlementStrategy, price);
  80 | *   |         asyncOrder.validateAcceptablePrice(runtime.fillPrice);
  81 |     | 
  82 | *   |         runtime.sizeDelta = asyncOrder.request.sizeDelta;
  83 |     | 
  84 | *   |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
  85 | *   |         PerpsAccount.Data storage perpsAccount = PerpsAccount.load(runtime.accountId);
  86 |     | 
  87 |     |         // use fill price to calculate realized pnl
  88 | *   |         (runtime.pnl, , runtime.chargedInterest, runtime.accruedFunding, , ) = oldPosition.getPnl(
  89 | *   |             runtime.fillPrice
  90 |     |         );
  91 |     | 
  92 | *   |         runtime.chargedAmount = runtime.pnl - runtime.totalFees.toInt();
  93 | *   |         perpsAccount.charge(runtime.chargedAmount);
  94 | *   |         emit AccountCharged(runtime.accountId, runtime.chargedAmount, perpsAccount.debt);
  95 |     | 
  96 |     |         // after pnl is realized, update position
  97 | *   |         runtime.updateData = PerpsMarket.loadValid(runtime.marketId).updatePositionData(
  98 | *   |             runtime.accountId,
  99 | *   |             runtime.newPosition
 100 |     |         );
 101 | *   |         perpsAccount.updateOpenPositions(runtime.marketId, runtime.newPosition.size);
 102 |     | 
 103 | *   |         emit MarketUpdated(
 104 | *   |             runtime.updateData.marketId,
 105 | *   |             price,
 106 | *   |             runtime.updateData.skew,
 107 | *   |             runtime.updateData.size,
 108 | *   |             runtime.sizeDelta,
 109 | *   |             runtime.updateData.currentFundingRate,
 110 | *   |             runtime.updateData.currentFundingVelocity,
 111 | *   |             runtime.updateData.interestRate
 112 |     |         );
 113 |     | 
 114 | *   |         runtime.settlementReward = AsyncOrder.settlementRewardCost(settlementStrategy);
 115 |     | 
 116 | *   |         if (runtime.settlementReward > 0) {
 117 |     |             // pay keeper
 118 | *   |             factory.withdrawMarketUsd(ERC2771Context._msgSender(), runtime.settlementReward);
 119 |     |         }
 120 |     | 
 121 | *   |         (runtime.referralFees, runtime.feeCollectorFees) = GlobalPerpsMarketConfiguration
 122 |     |             .load()
 123 |     |             .collectFees(
 124 | *   |                 runtime.totalFees - runtime.settlementReward, // totalFees includes settlement reward so we remove it
 125 | *   |                 asyncOrder.request.referrer,
 126 | *   |                 factory
 127 |     |             );
 128 |     | 
 129 |     |         // trader can now commit a new order
 130 | *   |         asyncOrder.reset();
 131 |     | 
 132 |     |         // Note: new event for this due to stack too deep adding it to OrderSettled event
 133 | *   |         emit InterestCharged(runtime.accountId, runtime.chargedInterest);
 134 |     | 
 135 |     |         // emit event
 136 | *   |         emit OrderSettled(
 137 | *   |             runtime.marketId,
 138 | *   |             runtime.accountId,
 139 | *   |             runtime.fillPrice,
 140 | *   |             runtime.pnl,
 141 | *   |             runtime.accruedFunding,
 142 | *   |             runtime.sizeDelta,
 143 | *   |             runtime.newPosition.size,
 144 | *   |             runtime.totalFees,
 145 | *   |             runtime.referralFees,
 146 | *   |             runtime.feeCollectorFees,
 147 | *   |             runtime.settlementReward,
 148 | *   |             asyncOrder.request.trackingCode,
 149 | *   |             ERC2771Context._msgSender()
 150 |     |         );
 151 |     |     }
 152 |     | }
 153 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/CollateralConfigurationModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ICollateralConfigurationModule} from "../interfaces/ICollateralConfigurationModule.sol";
   5 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   6 |     | import {GlobalPerpsMarketConfiguration} from "../storage/GlobalPerpsMarketConfiguration.sol";
   7 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
   8 |     | import {LiquidationAssetManager} from "../storage/LiquidationAssetManager.sol";
   9 |     | import {OwnableStorage} from "@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol";
  10 |     | import {AddressError} from "@synthetixio/core-contracts/contracts/errors/AddressError.sol";
  11 |     | import {PerpsCollateralConfiguration} from "../storage/PerpsCollateralConfiguration.sol";
  12 |     | import {RewardsDistributor} from "@synthetixio/rewards-distributor/src/RewardsDistributor.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title Module for collateral configuration setters/getters.
  16 |     |  * @dev See ICollateralConfigurationModule.
  17 |     |  */
  18 |     | contract CollateralConfigurationModule is ICollateralConfigurationModule {
  19 |     |     using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;
  20 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  21 |     |     using SetUtil for SetUtil.UintSet;
  22 |     |     using LiquidationAssetManager for LiquidationAssetManager.Data;
  23 |     |     using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;
  24 |     | 
  25 |     |     /**
  26 |     |      * @inheritdoc ICollateralConfigurationModule
  27 |     |      */
  28 |     |     function setCollateralConfiguration(
  29 |     |         uint128 collateralId,
  30 |     |         uint256 maxCollateralAmount,
  31 |     |         uint256 upperLimitDiscount,
  32 |     |         uint256 lowerLimitDiscount,
  33 |     |         uint256 discountScalar
  34 |     |     ) external override {
  35 |     |         OwnableStorage.onlyOwner();
  36 |     |         PerpsCollateralConfiguration.Data storage collateralConfig = PerpsCollateralConfiguration
  37 |     |             .load(collateralId);
  38 |     | 
  39 |     |         collateralConfig.setMax(collateralId, maxCollateralAmount);
  40 |     |         collateralConfig.setDiscounts(upperLimitDiscount, lowerLimitDiscount, discountScalar);
  41 |     | 
  42 |     |         GlobalPerpsMarketConfiguration.load().updateSupportedCollaterals(
  43 |     |             collateralId,
  44 |     |             maxCollateralAmount
  45 |     |         );
  46 |     | 
  47 |     |         emit CollateralConfigurationSet(
  48 |     |             collateralId,
  49 |     |             maxCollateralAmount,
  50 |     |             upperLimitDiscount,
  51 |     |             lowerLimitDiscount,
  52 |     |             discountScalar
  53 |     |         );
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @inheritdoc ICollateralConfigurationModule
  58 |     |      */
  59 |     |     function getCollateralConfiguration(
  60 |     |         uint128 collateralId
  61 |     |     ) external view override returns (uint256 maxCollateralAmount) {
  62 |     |         return PerpsCollateralConfiguration.load(collateralId).maxAmount;
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @inheritdoc ICollateralConfigurationModule
  67 |     |      */
  68 |     |     function getCollateralConfigurationFull(
  69 |     |         uint128 collateralId
  70 |     |     )
  71 |     |         external
  72 |     |         view
  73 |     |         override
  74 |     |         returns (
  75 |     |             uint256 maxCollateralAmount,
  76 |     |             uint256 upperLimitDiscount,
  77 |     |             uint256 lowerLimitDiscount,
  78 |     |             uint256 discountScalar
  79 |     |         )
  80 |     |     {
  81 |     |         return PerpsCollateralConfiguration.load(collateralId).getConfig();
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @inheritdoc ICollateralConfigurationModule
  86 |     |      */
  87 |     |     function setCollateralLiquidateRewardRatio(
  88 |     |         uint128 collateralLiquidateRewardRatioD18
  89 |     |     ) external override {
  90 |     |         OwnableStorage.onlyOwner();
  91 |     |         GlobalPerpsMarketConfiguration
  92 |     |             .load()
  93 |     |             .collateralLiquidateRewardRatioD18 = collateralLiquidateRewardRatioD18;
  94 |     | 
  95 |     |         emit CollateralLiquidateRewardRatioSet(collateralLiquidateRewardRatioD18);
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @inheritdoc ICollateralConfigurationModule
 100 |     |      */
 101 |     |     function getCollateralLiquidateRewardRatio()
 102 |     |         external
 103 |     |         view
 104 |     |         override
 105 |     |         returns (uint128 collateralLiquidateRewardRatioD18)
 106 |     |     {
 107 |     |         return GlobalPerpsMarketConfiguration.load().collateralLiquidateRewardRatioD18;
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @inheritdoc ICollateralConfigurationModule
 112 |     |      */
 113 |     |     function registerDistributor(
 114 |     |         address token,
 115 |     |         address distributor,
 116 |     |         uint128 collateralId,
 117 |     |         address[] calldata poolDelegatedCollateralTypes
 118 |     |     ) external override {
 119 |     |         OwnableStorage.onlyOwner();
 120 |     |         // A reward token to distribute must exist.
 121 |     |         if (token == address(0)) {
 122 |     |             revert AddressError.ZeroAddress();
 123 |     |         }
 124 |     | 
 125 |     |         // Using loadValid here to ensure we are tying the distributor to a valid collateral.
 126 |     |         LiquidationAssetManager.Data storage lam = PerpsCollateralConfiguration
 127 |     |             .loadValid(collateralId)
 128 |     |             .lam;
 129 |     | 
 130 |     |         lam.id = collateralId;
 131 |     | 
 132 |     |         // validate and set poolDelegatedCollateralTypes
 133 |     |         lam.setValidPoolDelegatedCollateralTypes(poolDelegatedCollateralTypes);
 134 |     | 
 135 |     |         // reuse current or clone distributor
 136 |     |         lam.setValidDistributor(distributor, token);
 137 |     | 
 138 |     |         emit RewardDistributorRegistered(distributor);
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @inheritdoc ICollateralConfigurationModule
 143 |     |      */
 144 |     |     function isRegistered(address distributor) external view override returns (bool) {
 145 |     |         return distributor != address(0) && RewardsDistributor(distributor).poolId() != 0;
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @inheritdoc ICollateralConfigurationModule
 150 |     |      */
 151 |     |     function getRegisteredDistributor(
 152 |     |         uint128 collateralId
 153 |     |     )
 154 |     |         external
 155 |     |         view
 156 |     |         override
 157 |     |         returns (address distributor, address[] memory poolDelegatedCollateralTypes)
 158 |     |     {
 159 |     |         LiquidationAssetManager.Data storage lam = PerpsCollateralConfiguration.loadValidLam(
 160 |     |             collateralId
 161 |     |         );
 162 |     |         distributor = lam.distributor;
 163 |     |         poolDelegatedCollateralTypes = lam.poolDelegatedCollateralTypes;
 164 |     |     }
 165 |     | }
 166 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/CoreModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {CoreModule as BaseCoreModule} from "@synthetixio/core-modules/contracts/modules/CoreModule.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Module that defines ownership and upgradability.
  8 |     |  * See core-modules/../CoreModule
  9 |     |  */
 10 |     | // solhint-disable-next-line no-empty-blocks
 11 |     | contract CoreModule is BaseCoreModule {
 12 |     | 
 13 |     | }
 14 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/FeatureFlagModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {FeatureFlagModule as BaseFeatureFlagModule} from "@synthetixio/core-modules/contracts/modules/FeatureFlagModule.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Module that allows disabling certain system features.
  8 |     |  *
  9 |     |  * Users will not be able to interact with certain functions associated to disabled features.
 10 |     |  */
 11 |     | // solhint-disable-next-line no-empty-blocks
 12 |     | contract FeatureFlagModule is BaseFeatureFlagModule {}
 13 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/GlobalPerpsMarketModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   5 |     | import {ERC165Helper} from "@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol";
   6 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   7 |     | import {IFeeCollector} from "../interfaces/external/IFeeCollector.sol";
   8 |     | import {GlobalPerpsMarketConfiguration} from "../storage/GlobalPerpsMarketConfiguration.sol";
   9 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
  10 |     | import {InterestRate} from "../storage/InterestRate.sol";
  11 |     | import {PerpsMarketFactory} from "../storage/PerpsMarketFactory.sol";
  12 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
  13 |     | import {IGlobalPerpsMarketModule} from "../interfaces/IGlobalPerpsMarketModule.sol";
  14 |     | import {OwnableStorage} from "@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol";
  15 |     | import {AddressError} from "@synthetixio/core-contracts/contracts/errors/AddressError.sol";
  16 |     | import {ParameterError} from "@synthetixio/core-contracts/contracts/errors/ParameterError.sol";
  17 |     | import {KeeperCosts} from "../storage/KeeperCosts.sol";
  18 |     | 
  19 |     | /**
  20 |     |  * @title Module for global Perps Market settings.
  21 |     |  * @dev See IGlobalPerpsMarketModule.
  22 |     |  */
  23 | *   | contract GlobalPerpsMarketModule is IGlobalPerpsMarketModule {
  24 |     |     using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;
  25 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  26 |     |     using SetUtil for SetUtil.UintSet;
  27 |     |     using KeeperCosts for KeeperCosts.Data;
  28 |     | 
  29 |     |     /**
  30 |     |      * @inheritdoc IGlobalPerpsMarketModule
  31 |     |      */
  32 | *   |     function getSupportedCollaterals()
  33 |     |         external
  34 |     |         view
  35 |     |         override
  36 | *   |         returns (uint256[] memory supportedCollaterals)
  37 | *   |     {
  38 | *   |         GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();
  39 | *   |         supportedCollaterals = store.supportedCollateralTypes.values();
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @inheritdoc IGlobalPerpsMarketModule
  44 |     |      */
  45 |     |     function setKeeperRewardGuards(
  46 |     |         uint256 minKeeperRewardUsd,
  47 |     |         uint256 minKeeperProfitRatioD18,
  48 |     |         uint256 maxKeeperRewardUsd,
  49 |     |         uint256 maxKeeperScalingRatioD18
  50 |     |     ) external override {
  51 |     |         OwnableStorage.onlyOwner();
  52 |     |         if (minKeeperRewardUsd > maxKeeperRewardUsd) {
  53 |     |             revert ParameterError.InvalidParameter("min/maxKeeperRewardUSD", "min > max");
  54 |     |         }
  55 |     | 
  56 |     |         GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();
  57 |     |         store.minKeeperRewardUsd = minKeeperRewardUsd;
  58 |     |         store.minKeeperProfitRatioD18 = minKeeperProfitRatioD18;
  59 |     |         store.maxKeeperRewardUsd = maxKeeperRewardUsd;
  60 |     |         store.maxKeeperScalingRatioD18 = maxKeeperScalingRatioD18;
  61 |     | 
  62 |     |         emit KeeperRewardGuardsSet(
  63 |     |             minKeeperRewardUsd,
  64 |     |             minKeeperProfitRatioD18,
  65 |     |             maxKeeperRewardUsd,
  66 |     |             maxKeeperScalingRatioD18
  67 |     |         );
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @inheritdoc IGlobalPerpsMarketModule
  72 |     |      */
  73 |     |     function getKeeperRewardGuards()
  74 |     |         external
  75 |     |         view
  76 |     |         override
  77 |     |         returns (
  78 |     |             uint256 minKeeperRewardUsd,
  79 |     |             uint256 minKeeperProfitRatioD18,
  80 |     |             uint256 maxKeeperRewardUsd,
  81 |     |             uint256 maxKeeperScalingRatioD18
  82 |     |         )
  83 |     |     {
  84 |     |         GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();
  85 |     |         minKeeperRewardUsd = store.minKeeperRewardUsd;
  86 |     |         minKeeperProfitRatioD18 = store.minKeeperProfitRatioD18;
  87 |     |         maxKeeperRewardUsd = store.maxKeeperRewardUsd;
  88 |     |         maxKeeperScalingRatioD18 = store.maxKeeperScalingRatioD18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @inheritdoc IGlobalPerpsMarketModule
  93 |     |      */
  94 | *   |     function totalGlobalCollateralValue()
  95 |     |         external
  96 |     |         view
  97 |     |         override
  98 | *   |         returns (uint256 totalCollateralValue)
  99 |     |     {
 100 | *   |         return GlobalPerpsMarket.load().totalCollateralValue();
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @inheritdoc IGlobalPerpsMarketModule
 105 |     |      */
 106 | *   |     function globalCollateralValue(
 107 |     |         uint128 collateralId
 108 | *   |     ) external view override returns (uint256 collateralValue) {
 109 | *   |         return GlobalPerpsMarket.load().collateralAmounts[collateralId];
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @inheritdoc IGlobalPerpsMarketModule
 114 |     |      */
 115 |     |     function setFeeCollector(address feeCollector) external override {
 116 |     |         OwnableStorage.onlyOwner();
 117 |     |         if (feeCollector != address(0)) {
 118 |     |             if (
 119 |     |                 !ERC165Helper.safeSupportsInterface(feeCollector, type(IFeeCollector).interfaceId)
 120 |     |             ) {
 121 |     |                 revert InvalidFeeCollectorInterface(feeCollector);
 122 |     |             }
 123 |     |         }
 124 |     | 
 125 |     |         GlobalPerpsMarketConfiguration.load().feeCollector = IFeeCollector(feeCollector);
 126 |     |         emit FeeCollectorSet(feeCollector);
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @inheritdoc IGlobalPerpsMarketModule
 131 |     |      */
 132 |     |     function getFeeCollector() external view override returns (address feeCollector) {
 133 |     |         return address(GlobalPerpsMarketConfiguration.load().feeCollector);
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @inheritdoc IGlobalPerpsMarketModule
 138 |     |      */
 139 |     |     function updateKeeperCostNodeId(bytes32 keeperCostNodeId) external override {
 140 |     |         OwnableStorage.onlyOwner();
 141 |     | 
 142 |     |         KeeperCosts.load().update(keeperCostNodeId);
 143 |     | 
 144 |     |         emit KeeperCostNodeIdUpdated(keeperCostNodeId);
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @inheritdoc IGlobalPerpsMarketModule
 149 |     |      */
 150 | *   |     function getKeeperCostNodeId() external view override returns (bytes32 keeperCostNodeId) {
 151 |     |         return KeeperCosts.load().keeperCostNodeId;
 152 |     |     }
 153 |     | 
 154 |     |     /**
 155 |     |      * @inheritdoc IGlobalPerpsMarketModule
 156 |     |      */
 157 |     |     function updateReferrerShare(address referrer, uint256 shareRatioD18) external override {
 158 |     |         OwnableStorage.onlyOwner();
 159 |     | 
 160 |     |         if (shareRatioD18 > DecimalMath.UNIT) {
 161 |     |             revert InvalidReferrerShareRatio(shareRatioD18);
 162 |     |         }
 163 |     | 
 164 |     |         if (referrer == address(0)) {
 165 |     |             revert AddressError.ZeroAddress();
 166 |     |         }
 167 |     | 
 168 |     |         GlobalPerpsMarketConfiguration.load().referrerShare[referrer] = shareRatioD18;
 169 |     | 
 170 |     |         emit ReferrerShareUpdated(referrer, shareRatioD18);
 171 |     |     }
 172 |     | 
 173 |     |     /**
 174 |     |      * @inheritdoc IGlobalPerpsMarketModule
 175 |     |      */
 176 |     |     function getReferrerShare(
 177 |     |         address referrer
 178 |     |     ) external view override returns (uint256 shareRatioD18) {
 179 |     |         return GlobalPerpsMarketConfiguration.load().referrerShare[referrer];
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @inheritdoc IGlobalPerpsMarketModule
 184 |     |      */
 185 |     |     function getMarkets() external view override returns (uint256[] memory marketIds) {
 186 |     |         marketIds = GlobalPerpsMarket.load().activeMarkets.values();
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @inheritdoc IGlobalPerpsMarketModule
 191 |     |      */
 192 |     |     function setPerAccountCaps(
 193 |     |         uint128 maxPositionsPerAccount,
 194 |     |         uint128 maxCollateralsPerAccount
 195 |     |     ) external override {
 196 |     |         OwnableStorage.onlyOwner();
 197 |     |         GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();
 198 |     |         store.maxPositionsPerAccount = maxPositionsPerAccount;
 199 |     |         store.maxCollateralsPerAccount = maxCollateralsPerAccount;
 200 |     | 
 201 |     |         emit PerAccountCapsSet(maxPositionsPerAccount, maxCollateralsPerAccount);
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @inheritdoc IGlobalPerpsMarketModule
 206 |     |      */
 207 |     |     function getPerAccountCaps()
 208 |     |         external
 209 |     |         view
 210 |     |         override
 211 |     |         returns (uint128 maxPositionsPerAccount, uint128 maxCollateralsPerAccount)
 212 |     |     {
 213 |     |         GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();
 214 |     |         maxPositionsPerAccount = store.maxPositionsPerAccount;
 215 |     |         maxCollateralsPerAccount = store.maxCollateralsPerAccount;
 216 |     |     }
 217 |     | 
 218 |     |     /**
 219 |     |      * @inheritdoc IGlobalPerpsMarketModule
 220 |     |      */
 221 |     |     function setInterestRateParameters(
 222 |     |         uint128 lowUtilizationInterestRateGradient,
 223 |     |         uint128 interestRateGradientBreakpoint,
 224 |     |         uint128 highUtilizationInterestRateGradient
 225 |     |     ) external override {
 226 |     |         OwnableStorage.onlyOwner();
 227 |     |         GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();
 228 |     | 
 229 |     |         if (lowUtilizationInterestRateGradient > highUtilizationInterestRateGradient) {
 230 |     |             revert InvalidInterestRateParameters(
 231 |     |                 lowUtilizationInterestRateGradient,
 232 |     |                 highUtilizationInterestRateGradient
 233 |     |             );
 234 |     |         }
 235 |     | 
 236 |     |         store.lowUtilizationInterestRateGradient = lowUtilizationInterestRateGradient;
 237 |     |         store.interestRateGradientBreakpoint = interestRateGradientBreakpoint;
 238 |     |         store.highUtilizationInterestRateGradient = highUtilizationInterestRateGradient;
 239 |     | 
 240 |     |         emit InterestRateParametersSet(
 241 |     |             lowUtilizationInterestRateGradient,
 242 |     |             interestRateGradientBreakpoint,
 243 |     |             highUtilizationInterestRateGradient
 244 |     |         );
 245 |     |     }
 246 |     | 
 247 |     |     /**
 248 |     |      * @inheritdoc IGlobalPerpsMarketModule
 249 |     |      */
 250 |     |     function getInterestRateParameters()
 251 |     |         external
 252 |     |         view
 253 |     |         override
 254 |     |         returns (
 255 |     |             uint128 lowUtilizationInterestRateGradient,
 256 |     |             uint128 interestRateGradientBreakpoint,
 257 |     |             uint128 highUtilizationInterestRateGradient
 258 |     |         )
 259 |     |     {
 260 |     |         GlobalPerpsMarketConfiguration.Data storage store = GlobalPerpsMarketConfiguration.load();
 261 |     |         lowUtilizationInterestRateGradient = store.lowUtilizationInterestRateGradient;
 262 |     |         interestRateGradientBreakpoint = store.interestRateGradientBreakpoint;
 263 |     |         highUtilizationInterestRateGradient = store.highUtilizationInterestRateGradient;
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @inheritdoc IGlobalPerpsMarketModule
 268 |     |      */
 269 |     |     function updateInterestRate() external override {
 270 |     |         (uint128 interestRate, ) = InterestRate.update(PerpsPrice.Tolerance.DEFAULT);
 271 |     | 
 272 |     |         emit InterestRateUpdated(PerpsMarketFactory.load().perpsMarketId, interestRate);
 273 |     |     }
 274 |     | }
 275 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/LiquidationModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   5 |     | import {FeatureFlag} from "@synthetixio/core-modules/contracts/storage/FeatureFlag.sol";
   6 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   7 |     | import {MathUtil} from "../utils/MathUtil.sol";
   8 |     | import {Flags} from "../utils/Flags.sol";
   9 |     | import {SafeCastU256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  10 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  11 |     | import {ILiquidationModule} from "../interfaces/ILiquidationModule.sol";
  12 |     | import {PerpsAccount} from "../storage/PerpsAccount.sol";
  13 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
  14 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
  15 |     | import {PerpsMarketFactory} from "../storage/PerpsMarketFactory.sol";
  16 |     | import {GlobalPerpsMarketConfiguration} from "../storage/GlobalPerpsMarketConfiguration.sol";
  17 |     | import {PerpsMarketConfiguration} from "../storage/PerpsMarketConfiguration.sol";
  18 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
  19 |     | import {MarketUpdate} from "../storage/MarketUpdate.sol";
  20 |     | import {IMarketEvents} from "../interfaces/IMarketEvents.sol";
  21 |     | import {KeeperCosts} from "../storage/KeeperCosts.sol";
  22 |     | 
  23 |     | /**
  24 |     |  * @title Module for liquidating accounts.
  25 |     |  * @dev See ILiquidationModule.
  26 |     |  */
  27 | *   | contract LiquidationModule is ILiquidationModule, IMarketEvents {
  28 |     |     using DecimalMath for uint256;
  29 |     |     using SafeCastU256 for uint256;
  30 |     |     using SetUtil for SetUtil.UintSet;
  31 |     |     using PerpsAccount for PerpsAccount.Data;
  32 |     |     using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;
  33 |     |     using PerpsMarketFactory for PerpsMarketFactory.Data;
  34 |     |     using PerpsMarket for PerpsMarket.Data;
  35 |     |     using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;
  36 |     |     using KeeperCosts for KeeperCosts.Data;
  37 |     | 
  38 |     |     /**
  39 |     |      * @inheritdoc ILiquidationModule
  40 |     |      */
  41 | *   |     function liquidate(uint128 accountId) external override returns (uint256 liquidationReward) {
  42 |     |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
  43 |     | 
  44 |     |         SetUtil.UintSet storage liquidatableAccounts = GlobalPerpsMarket
  45 |     |             .load()
  46 |     |             .liquidatableAccounts;
  47 |     |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
  48 | *   |         if (!liquidatableAccounts.contains(accountId)) {
  49 |     |             (
  50 |     |                 bool isEligible,
  51 |     |                 int256 availableMargin,
  52 |     |                 ,
  53 |     |                 uint256 requiredMaintenaceMargin,
  54 |     |                 uint256 expectedLiquidationReward
  55 |     |             ) = account.isEligibleForLiquidation(PerpsPrice.Tolerance.STRICT);
  56 |     | 
  57 |     |             if (isEligible) {
  58 |     |                 (uint256 flagCost, uint256 seizedMarginValue) = account.flagForLiquidation();
  59 |     | 
  60 |     |                 emit AccountFlaggedForLiquidation(
  61 |     |                     accountId,
  62 |     |                     availableMargin,
  63 |     |                     requiredMaintenaceMargin,
  64 |     |                     expectedLiquidationReward,
  65 |     |                     flagCost
  66 |     |                 );
  67 |     | 
  68 |     |                 liquidationReward = _liquidateAccount(account, flagCost, seizedMarginValue, true);
  69 |     |             } else {
  70 |     |                 revert NotEligibleForLiquidation(accountId);
  71 |     |             }
  72 |     |         } else {
  73 |     |             liquidationReward = _liquidateAccount(account, 0, 0, false);
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 | *   |     function liquidateMarginOnly(
  78 |     |         uint128 accountId
  79 | *   |     ) external override returns (uint256 liquidationReward) {
  80 | *   |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
  81 |     | 
  82 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
  83 |     | 
  84 | *   |         if (account.hasOpenPositions()) {
  85 |     |             revert AccountHasOpenPositions(accountId);
  86 |     |         }
  87 |     | 
  88 | *   |         (bool isEligible, ) = account.isEligibleForMarginLiquidation(PerpsPrice.Tolerance.STRICT);
  89 | *   |         if (isEligible) {
  90 |     |             // margin is sent to liquidation rewards distributor in getMarginLiquidationCostAndSeizeMargin
  91 | *   |             (uint256 marginLiquidateCost, uint256 seizedMarginValue) = account
  92 |     |                 .getMarginLiquidationCostAndSeizeMargin();
  93 |     |             // keeper is rewarded in _liquidateAccount
  94 | *   |             liquidationReward = _liquidateAccount(
  95 | *   |                 account,
  96 | *   |                 marginLiquidateCost,
  97 | *   |                 seizedMarginValue,
  98 | *   |                 true
  99 |     |             );
 100 |     |             // clear debt
 101 | *   |             account.updateAccountDebt(-(account.debt.toInt()));
 102 |     | 
 103 | *   |             emit AccountMarginLiquidation(accountId, seizedMarginValue, liquidationReward);
 104 |     |         } else {
 105 |     |             revert NotEligibleForMarginLiquidation(accountId);
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @inheritdoc ILiquidationModule
 111 |     |      */
 112 |     |     function liquidateFlagged(
 113 |     |         uint256 maxNumberOfAccounts
 114 |     |     ) external override returns (uint256 liquidationReward) {
 115 |     |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
 116 |     | 
 117 |     |         uint256[] memory liquidatableAccounts = GlobalPerpsMarket
 118 |     |             .load()
 119 |     |             .liquidatableAccounts
 120 |     |             .values();
 121 |     | 
 122 |     |         uint256 numberOfAccountsToLiquidate = MathUtil.min(
 123 |     |             maxNumberOfAccounts,
 124 |     |             liquidatableAccounts.length
 125 |     |         );
 126 |     | 
 127 |     |         for (uint256 i = 0; i < numberOfAccountsToLiquidate; i++) {
 128 | *   |             uint128 accountId = liquidatableAccounts[i].to128();
 129 |     |             liquidationReward += _liquidateAccount(PerpsAccount.load(accountId), 0, 0, false);
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @inheritdoc ILiquidationModule
 135 |     |      */
 136 | *   |     function liquidateFlaggedAccounts(
 137 |     |         uint128[] calldata accountIds
 138 | *   |     ) external override returns (uint256 liquidationReward) {
 139 |     |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
 140 |     | 
 141 |     |         SetUtil.UintSet storage liquidatableAccounts = GlobalPerpsMarket
 142 |     |             .load()
 143 |     |             .liquidatableAccounts;
 144 |     | 
 145 | *   |         for (uint256 i = 0; i < accountIds.length; i++) {
 146 |     |             uint128 accountId = accountIds[i];
 147 |     |             if (!liquidatableAccounts.contains(accountId)) {
 148 |     |                 continue;
 149 |     |             }
 150 |     | 
 151 |     |             liquidationReward += _liquidateAccount(PerpsAccount.load(accountId), 0, 0, false);
 152 |     |         }
 153 |     |     }
 154 |     | 
 155 |     |     /**
 156 |     |      * @inheritdoc ILiquidationModule
 157 |     |      */
 158 |     |     function flaggedAccounts() external view override returns (uint256[] memory accountIds) {
 159 |     |         return GlobalPerpsMarket.load().liquidatableAccounts.values();
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @inheritdoc ILiquidationModule
 164 |     |      */
 165 | *   |     function canLiquidate(uint128 accountId) external view override returns (bool isEligible) {
 166 | *   |         (isEligible, , , , ) = PerpsAccount.load(accountId).isEligibleForLiquidation(
 167 | *   |             PerpsPrice.Tolerance.DEFAULT
 168 |     |         );
 169 |     |     }
 170 |     | 
 171 | *   |     function canLiquidateMarginOnly(
 172 |     |         uint128 accountId
 173 | *   |     ) external view override returns (bool isEligible) {
 174 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
 175 | *   |         if (account.hasOpenPositions()) {
 176 | *   |             return false;
 177 |     |         } else {
 178 | *   |             (isEligible, ) = account.isEligibleForMarginLiquidation(PerpsPrice.Tolerance.DEFAULT);
 179 |     |         }
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @inheritdoc ILiquidationModule
 184 |     |      */
 185 | *   |     function liquidationCapacity(
 186 |     |         uint128 marketId
 187 |     |     )
 188 |     |         external
 189 |     |         view
 190 |     |         override
 191 |     |         returns (
 192 | *   |             uint256 capacity,
 193 | *   |             uint256 maxLiquidationInWindow,
 194 | *   |             uint256 latestLiquidationTimestamp
 195 |     |         )
 196 |     |     {
 197 | *   |         return
 198 | *   |             PerpsMarket.load(marketId).currentLiquidationCapacity(
 199 | *   |                 PerpsMarketConfiguration.load(marketId)
 200 |     |             );
 201 |     |     }
 202 |     | 
 203 |     |     struct LiquidateAccountRuntime {
 204 |     |         uint128 accountId;
 205 |     |         uint256 totalFlaggingRewards;
 206 |     |         uint256 totalLiquidated;
 207 |     |         bool accountFullyLiquidated;
 208 |     |         uint256 totalLiquidationCost;
 209 |     |         uint256 price;
 210 |     |         uint128 positionMarketId;
 211 |     |         uint256 loopIterator; // stack too deep to the extreme
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev liquidates an account
 216 |     |      */
 217 | *   |     function _liquidateAccount(
 218 |     |         PerpsAccount.Data storage account,
 219 |     |         uint256 costOfFlagExecution,
 220 |     |         uint256 totalCollateralValue,
 221 |     |         bool positionFlagged
 222 | *   |     ) internal returns (uint256 keeperLiquidationReward) {
 223 |     |         LiquidateAccountRuntime memory runtime;
 224 | *   |         runtime.accountId = account.id;
 225 | *   |         uint256[] memory openPositionMarketIds = account.openPositionMarketIds.values();
 226 |     | 
 227 | *   |         for (
 228 | *   |             runtime.loopIterator = 0;
 229 | *   |             runtime.loopIterator < openPositionMarketIds.length;
 230 |     |             runtime.loopIterator++
 231 |     |         ) {
 232 |     |             runtime.positionMarketId = openPositionMarketIds[runtime.loopIterator].to128();
 233 |     |             runtime.price = PerpsPrice.getCurrentPrice(
 234 |     |                 runtime.positionMarketId,
 235 |     |                 PerpsPrice.Tolerance.STRICT
 236 |     |             );
 237 |     | 
 238 |     |             (
 239 |     |                 uint256 amountLiquidated,
 240 |     |                 int128 newPositionSize,
 241 |     |                 int128 sizeDelta,
 242 |     |                 uint256 oldPositionAbsSize,
 243 |     |                 MarketUpdate.Data memory marketUpdateData
 244 |     |             ) = account.liquidatePosition(runtime.positionMarketId, runtime.price);
 245 |     | 
 246 |     |             // endorsed liquidators do not get flag rewards
 247 |     |             if (
 248 |     |                 ERC2771Context._msgSender() !=
 249 |     |                 PerpsMarketConfiguration.load(runtime.positionMarketId).endorsedLiquidator
 250 |     |             ) {
 251 |     |                 // using oldPositionAbsSize to calculate flag reward
 252 |     |                 runtime.totalFlaggingRewards += PerpsMarketConfiguration
 253 |     |                     .load(runtime.positionMarketId)
 254 |     |                     .calculateFlagReward(oldPositionAbsSize.mulDecimal(runtime.price));
 255 |     |             }
 256 |     | 
 257 |     |             if (amountLiquidated == 0) {
 258 |     |                 continue;
 259 |     |             }
 260 |     | 
 261 |     |             runtime.totalLiquidated += amountLiquidated;
 262 |     | 
 263 |     |             emit MarketUpdated(
 264 |     |                 runtime.positionMarketId,
 265 |     |                 runtime.price,
 266 |     |                 marketUpdateData.skew,
 267 |     |                 marketUpdateData.size,
 268 |     |                 sizeDelta,
 269 |     |                 marketUpdateData.currentFundingRate,
 270 |     |                 marketUpdateData.currentFundingVelocity,
 271 |     |                 marketUpdateData.interestRate
 272 |     |             );
 273 |     | 
 274 |     |             emit PositionLiquidated(
 275 |     |                 runtime.accountId,
 276 |     |                 runtime.positionMarketId,
 277 |     |                 amountLiquidated,
 278 |     |                 newPositionSize
 279 |     |             );
 280 |     |         }
 281 |     | 
 282 | *   |         if (
 283 | *   |             ERC2771Context._msgSender() !=
 284 | *   |             PerpsMarketConfiguration.load(runtime.positionMarketId).endorsedLiquidator
 285 |     |         ) {
 286 |     |             // Use max of collateral or positions flag rewards
 287 | *   |             uint256 totalCollateralLiquidateRewards = GlobalPerpsMarketConfiguration
 288 |     |                 .load()
 289 | *   |                 .calculateCollateralLiquidateReward(totalCollateralValue);
 290 |     | 
 291 | *   |             runtime.totalFlaggingRewards = totalCollateralLiquidateRewards >
 292 | *   |                 runtime.totalFlaggingRewards
 293 |     |                 ? totalCollateralLiquidateRewards
 294 | *   |                 : runtime.totalFlaggingRewards;
 295 |     |         }
 296 |     | 
 297 | *   |         runtime.totalLiquidationCost =
 298 | *   |             KeeperCosts.load().getLiquidateKeeperCosts() +
 299 | *   |             costOfFlagExecution;
 300 | *   |         if (positionFlagged || runtime.totalLiquidated > 0) {
 301 | *   |             keeperLiquidationReward = _processLiquidationRewards(
 302 | *   |                 positionFlagged ? runtime.totalFlaggingRewards : 0,
 303 | *   |                 runtime.totalLiquidationCost,
 304 | *   |                 totalCollateralValue
 305 |     |             );
 306 | *   |             runtime.accountFullyLiquidated = account.openPositionMarketIds.length() == 0;
 307 | *   |             if (
 308 | *   |                 runtime.accountFullyLiquidated &&
 309 | *   |                 GlobalPerpsMarket.load().liquidatableAccounts.contains(runtime.accountId)
 310 |     |             ) {
 311 | *   |                 GlobalPerpsMarket.load().liquidatableAccounts.remove(runtime.accountId);
 312 |     |             }
 313 |     |         }
 314 |     | 
 315 | *   |         emit AccountLiquidationAttempt(
 316 | *   |             runtime.accountId,
 317 |     |             keeperLiquidationReward,
 318 | *   |             runtime.accountFullyLiquidated
 319 |     |         );
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev process the accumulated liquidation rewards
 324 |     |      */
 325 | *   |     function _processLiquidationRewards(
 326 |     |         uint256 keeperRewards,
 327 |     |         uint256 costOfExecutionInUsd,
 328 |     |         uint256 availableMarginInUsd
 329 | *   |     ) private returns (uint256 reward) {
 330 | *   |         if ((keeperRewards + costOfExecutionInUsd) == 0) {
 331 |     |             return 0;
 332 |     |         }
 333 |     |         // pay out liquidation rewards
 334 | *   |         reward = GlobalPerpsMarketConfiguration.load().keeperReward(
 335 | *   |             keeperRewards,
 336 | *   |             costOfExecutionInUsd,
 337 | *   |             availableMarginInUsd
 338 |     |         );
 339 | *   |         if (reward > 0) {
 340 |     |             PerpsMarketFactory.load().withdrawMarketUsd(ERC2771Context._msgSender(), reward);
 341 |     |         }
 342 |     |     }
 343 |     | }
 344 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/MarketConfigurationModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {OwnableStorage} from "@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol";
   5 |     | import {IMarketConfigurationModule} from "../interfaces/IMarketConfigurationModule.sol";
   6 |     | import {SettlementStrategy} from "../storage/SettlementStrategy.sol";
   7 |     | import {PerpsMarketConfiguration} from "../storage/PerpsMarketConfiguration.sol";
   8 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title Module for updating configuration in relation to async order modules.
  12 |     |  * @dev See IMarketConfigurationModule.
  13 |     |  */
  14 |     | contract MarketConfigurationModule is IMarketConfigurationModule {
  15 |     |     using PerpsPrice for PerpsPrice.Data;
  16 |     |     using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;
  17 |     | 
  18 |     |     /**
  19 |     |      * @inheritdoc IMarketConfigurationModule
  20 |     |      */
  21 |     |     function addSettlementStrategy(
  22 |     |         uint128 marketId,
  23 |     |         SettlementStrategy.Data memory strategy
  24 |     |     ) external override returns (uint256 strategyId) {
  25 |     |         OwnableStorage.onlyOwner();
  26 |     | 
  27 |     |         if (strategy.settlementWindowDuration == 0) {
  28 |     |             revert InvalidSettlementWindowDuration(strategy.settlementWindowDuration);
  29 |     |         }
  30 |     | 
  31 |     |         strategy.settlementDelay = strategy.settlementDelay == 0 ? 1 : strategy.settlementDelay;
  32 |     | 
  33 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
  34 |     |         strategyId = config.settlementStrategies.length;
  35 |     | 
  36 |     |         config.settlementStrategies.push(strategy);
  37 |     |         emit SettlementStrategyAdded(marketId, strategy, strategyId);
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @inheritdoc IMarketConfigurationModule
  42 |     |      */
  43 |     |     function setSettlementStrategy(
  44 |     |         uint128 marketId,
  45 |     |         uint256 strategyId,
  46 |     |         SettlementStrategy.Data memory strategy
  47 |     |     ) external override {
  48 |     |         OwnableStorage.onlyOwner();
  49 |     | 
  50 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
  51 |     |         config.validateStrategyExists(strategyId);
  52 |     | 
  53 |     |         if (strategy.settlementWindowDuration == 0) {
  54 |     |             revert InvalidSettlementWindowDuration(strategy.settlementWindowDuration);
  55 |     |         }
  56 |     | 
  57 |     |         strategy.settlementDelay = strategy.settlementDelay == 0 ? 1 : strategy.settlementDelay;
  58 |     |         config.settlementStrategies[strategyId] = strategy;
  59 |     | 
  60 |     |         emit SettlementStrategySet(marketId, strategyId, strategy);
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @inheritdoc IMarketConfigurationModule
  65 |     |      */
  66 |     |     function setSettlementStrategyEnabled(
  67 |     |         uint128 marketId,
  68 |     |         uint256 strategyId,
  69 |     |         bool enabled
  70 |     |     ) external override {
  71 |     |         OwnableStorage.onlyOwner();
  72 |     | 
  73 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
  74 |     |         config.validateStrategyExists(strategyId);
  75 |     | 
  76 |     |         SettlementStrategy.Data storage strategy = config.settlementStrategies[strategyId];
  77 |     |         strategy.disabled = !enabled;
  78 |     | 
  79 |     |         emit SettlementStrategySet(marketId, strategyId, strategy);
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @inheritdoc IMarketConfigurationModule
  84 |     |      */
  85 |     |     function setOrderFees(
  86 |     |         uint128 marketId,
  87 |     |         uint256 makerFeeRatio,
  88 |     |         uint256 takerFeeRatio
  89 |     |     ) external override {
  90 |     |         OwnableStorage.onlyOwner();
  91 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
  92 |     |         config.orderFees.makerFee = makerFeeRatio;
  93 |     |         config.orderFees.takerFee = takerFeeRatio;
  94 |     |         emit OrderFeesSet(marketId, makerFeeRatio, takerFeeRatio);
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @inheritdoc IMarketConfigurationModule
  99 |     |      */
 100 |     |     function updatePriceData(
 101 |     |         uint128 perpsMarketId,
 102 |     |         bytes32 feedId,
 103 |     |         uint256 strictStalenessTolerance
 104 |     |     ) external override {
 105 |     |         OwnableStorage.onlyOwner();
 106 |     | 
 107 |     |         PerpsPrice.load(perpsMarketId).update(feedId, strictStalenessTolerance);
 108 |     | 
 109 |     |         emit MarketPriceDataUpdated(perpsMarketId, feedId, strictStalenessTolerance);
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @inheritdoc IMarketConfigurationModule
 114 |     |      */
 115 |     |     function getPriceData(
 116 |     |         uint128 perpsMarketId
 117 |     |     ) external view returns (bytes32 feedId, uint256 strictStalenessTolerance) {
 118 |     |         PerpsPrice.Data storage priceData = PerpsPrice.load(perpsMarketId);
 119 |     |         feedId = priceData.feedId;
 120 |     |         strictStalenessTolerance = priceData.strictStalenessTolerance;
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @inheritdoc IMarketConfigurationModule
 125 |     |      */
 126 |     |     function setMaxMarketSize(uint128 marketId, uint256 maxMarketSize) external override {
 127 |     |         OwnableStorage.onlyOwner();
 128 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 129 |     |         config.maxMarketSize = maxMarketSize;
 130 |     |         emit MaxMarketSizeSet(marketId, maxMarketSize);
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @inheritdoc IMarketConfigurationModule
 135 |     |      */
 136 |     |     function setMaxMarketValue(uint128 marketId, uint256 maxMarketValue) external override {
 137 |     |         OwnableStorage.onlyOwner();
 138 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 139 |     |         config.maxMarketValue = maxMarketValue;
 140 |     |         emit MaxMarketValueSet(marketId, maxMarketValue);
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @inheritdoc IMarketConfigurationModule
 145 |     |      */
 146 |     |     function setFundingParameters(
 147 |     |         uint128 marketId,
 148 |     |         uint256 skewScale,
 149 |     |         uint256 maxFundingVelocity
 150 |     |     ) external override {
 151 |     |         OwnableStorage.onlyOwner();
 152 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 153 |     | 
 154 |     |         config.maxFundingVelocity = maxFundingVelocity;
 155 |     |         config.skewScale = skewScale;
 156 |     |         emit FundingParametersSet(marketId, skewScale, maxFundingVelocity);
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @inheritdoc IMarketConfigurationModule
 161 |     |      */
 162 |     |     function setMaxLiquidationParameters(
 163 |     |         uint128 marketId,
 164 |     |         uint256 maxLiquidationLimitAccumulationMultiplier,
 165 |     |         uint256 maxSecondsInLiquidationWindow,
 166 |     |         uint256 maxLiquidationPd,
 167 |     |         address endorsedLiquidator
 168 |     |     ) external override {
 169 |     |         OwnableStorage.onlyOwner();
 170 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 171 |     | 
 172 |     |         config
 173 |     |             .maxLiquidationLimitAccumulationMultiplier = maxLiquidationLimitAccumulationMultiplier;
 174 |     |         config.maxLiquidationPd = maxLiquidationPd;
 175 |     |         config.endorsedLiquidator = endorsedLiquidator;
 176 |     |         config.maxSecondsInLiquidationWindow = maxSecondsInLiquidationWindow;
 177 |     | 
 178 |     |         emit MaxLiquidationParametersSet(
 179 |     |             marketId,
 180 |     |             maxLiquidationLimitAccumulationMultiplier,
 181 |     |             maxSecondsInLiquidationWindow,
 182 |     |             maxLiquidationPd,
 183 |     |             endorsedLiquidator
 184 |     |         );
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @inheritdoc IMarketConfigurationModule
 189 |     |      */
 190 |     |     function setLiquidationParameters(
 191 |     |         uint128 marketId,
 192 |     |         uint256 initialMarginRatioD18,
 193 |     |         uint256 minimumInitialMarginRatioD18,
 194 |     |         uint256 maintenanceMarginScalarD18,
 195 |     |         uint256 flagRewardRatioD18,
 196 |     |         uint256 minimumPositionMargin
 197 |     |     ) external override {
 198 |     |         OwnableStorage.onlyOwner();
 199 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 200 |     | 
 201 |     |         config.initialMarginRatioD18 = initialMarginRatioD18;
 202 |     |         config.maintenanceMarginScalarD18 = maintenanceMarginScalarD18;
 203 |     |         config.minimumInitialMarginRatioD18 = minimumInitialMarginRatioD18;
 204 |     |         config.flagRewardRatioD18 = flagRewardRatioD18;
 205 |     |         config.minimumPositionMargin = minimumPositionMargin;
 206 |     | 
 207 |     |         emit LiquidationParametersSet(
 208 |     |             marketId,
 209 |     |             initialMarginRatioD18,
 210 |     |             maintenanceMarginScalarD18,
 211 |     |             minimumInitialMarginRatioD18,
 212 |     |             flagRewardRatioD18,
 213 |     |             minimumPositionMargin
 214 |     |         );
 215 |     |     }
 216 |     | 
 217 |     |     /**
 218 |     |      * @inheritdoc IMarketConfigurationModule
 219 |     |      */
 220 |     |     function setLockedOiRatio(uint128 marketId, uint256 lockedOiRatioD18) external override {
 221 |     |         OwnableStorage.onlyOwner();
 222 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 223 |     |         config.lockedOiRatioD18 = lockedOiRatioD18;
 224 |     |         emit LockedOiRatioSet(marketId, lockedOiRatioD18);
 225 |     |     }
 226 |     | 
 227 |     |     /**
 228 |     |      * @inheritdoc IMarketConfigurationModule
 229 |     |      */
 230 |     |     function getSettlementStrategy(
 231 |     |         uint128 marketId,
 232 |     |         uint256 strategyId
 233 |     |     ) external view override returns (SettlementStrategy.Data memory settlementStrategy) {
 234 |     |         return PerpsMarketConfiguration.load(marketId).settlementStrategies[strategyId];
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @inheritdoc IMarketConfigurationModule
 239 |     |      */
 240 |     |     function getMaxLiquidationParameters(
 241 |     |         uint128 marketId
 242 |     |     )
 243 |     |         external
 244 |     |         view
 245 |     |         override
 246 |     |         returns (
 247 |     |             uint256 maxLiquidationLimitAccumulationMultiplier,
 248 |     |             uint256 maxSecondsInLiquidationWindow,
 249 |     |             uint256 maxLiquidationPd,
 250 |     |             address endorsedLiquidator
 251 |     |         )
 252 |     |     {
 253 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 254 |     | 
 255 |     |         maxLiquidationLimitAccumulationMultiplier = config
 256 |     |             .maxLiquidationLimitAccumulationMultiplier;
 257 |     |         maxSecondsInLiquidationWindow = config.maxSecondsInLiquidationWindow;
 258 |     |         maxLiquidationPd = config.maxLiquidationPd;
 259 |     |         endorsedLiquidator = config.endorsedLiquidator;
 260 |     |     }
 261 |     | 
 262 |     |     /**
 263 |     |      * @inheritdoc IMarketConfigurationModule
 264 |     |      */
 265 |     |     function getLiquidationParameters(
 266 |     |         uint128 marketId
 267 |     |     )
 268 |     |         external
 269 |     |         view
 270 |     |         override
 271 |     |         returns (
 272 |     |             uint256 initialMarginRatioD18,
 273 |     |             uint256 minimumInitialMarginRatioD18,
 274 |     |             uint256 maintenanceMarginScalarD18,
 275 |     |             uint256 flagRewardRatioD18,
 276 |     |             uint256 minimumPositionMargin
 277 |     |         )
 278 |     |     {
 279 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 280 |     | 
 281 |     |         initialMarginRatioD18 = config.initialMarginRatioD18;
 282 |     |         minimumInitialMarginRatioD18 = config.minimumInitialMarginRatioD18;
 283 |     |         maintenanceMarginScalarD18 = config.maintenanceMarginScalarD18;
 284 |     |         flagRewardRatioD18 = config.flagRewardRatioD18;
 285 |     |         minimumPositionMargin = config.minimumPositionMargin;
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * @inheritdoc IMarketConfigurationModule
 290 |     |      */
 291 |     |     function getFundingParameters(
 292 |     |         uint128 marketId
 293 |     |     ) external view override returns (uint256 skewScale, uint256 maxFundingVelocity) {
 294 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 295 |     | 
 296 |     |         skewScale = config.skewScale;
 297 |     |         maxFundingVelocity = config.maxFundingVelocity;
 298 |     |     }
 299 |     | 
 300 |     |     /**
 301 |     |      * @inheritdoc IMarketConfigurationModule
 302 |     |      */
 303 |     |     function getMaxMarketSize(
 304 |     |         uint128 marketId
 305 |     |     ) external view override returns (uint256 maxMarketSize) {
 306 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 307 |     | 
 308 |     |         maxMarketSize = config.maxMarketSize;
 309 |     |     }
 310 |     | 
 311 |     |     /**
 312 |     |      * @inheritdoc IMarketConfigurationModule
 313 |     |      */
 314 |     |     function getMaxMarketValue(
 315 |     |         uint128 marketId
 316 |     |     ) external view override returns (uint256 maxMarketValue) {
 317 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 318 |     | 
 319 |     |         maxMarketValue = config.maxMarketValue;
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @inheritdoc IMarketConfigurationModule
 324 |     |      */
 325 |     |     function getOrderFees(
 326 |     |         uint128 marketId
 327 |     |     ) external view override returns (uint256 makerFee, uint256 takerFee) {
 328 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 329 |     | 
 330 |     |         makerFee = config.orderFees.makerFee;
 331 |     |         takerFee = config.orderFees.takerFee;
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @inheritdoc IMarketConfigurationModule
 336 |     |      */
 337 |     |     function getLockedOiRatio(uint128 marketId) external view override returns (uint256) {
 338 |     |         PerpsMarketConfiguration.Data storage config = PerpsMarketConfiguration.load(marketId);
 339 |     | 
 340 |     |         return config.lockedOiRatioD18;
 341 |     |     }
 342 |     | }
 343 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/PerpsAccountModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   5 |     | import {FeatureFlag} from "@synthetixio/core-modules/contracts/storage/FeatureFlag.sol";
   6 |     | import {Account} from "@synthetixio/main/contracts/storage/Account.sol";
   7 |     | import {AccountRBAC} from "@synthetixio/main/contracts/storage/AccountRBAC.sol";
   8 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   9 |     | import {ITokenModule} from "@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol";
  10 |     | import {PerpsMarketFactory} from "../storage/PerpsMarketFactory.sol";
  11 |     | import {IPerpsAccountModule} from "../interfaces/IPerpsAccountModule.sol";
  12 |     | import {PerpsAccount, SNX_USD_MARKET_ID} from "../storage/PerpsAccount.sol";
  13 |     | import {Position} from "../storage/Position.sol";
  14 |     | import {AsyncOrder} from "../storage/AsyncOrder.sol";
  15 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
  16 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
  17 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
  18 |     | import {MathUtil} from "../utils/MathUtil.sol";
  19 |     | import {Flags} from "../utils/Flags.sol";
  20 |     | import {SafeCastU256, SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  21 |     | import {PerpsCollateralConfiguration} from "../storage/PerpsCollateralConfiguration.sol";
  22 |     | 
  23 |     | import {console2} from "../../lib/forge-std/src/Test.sol";
  24 |     | 
  25 |     | /**
  26 |     |  * @title Module to manage accounts
  27 |     |  * @dev See IPerpsAccountModule.
  28 |     |  */
  29 | *   | contract PerpsAccountModule is IPerpsAccountModule {
  30 |     |     using SetUtil for SetUtil.UintSet;
  31 |     |     using PerpsAccount for PerpsAccount.Data;
  32 |     |     using Position for Position.Data;
  33 |     |     using SafeCastU256 for uint256;
  34 |     |     using SafeCastI256 for int256;
  35 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  36 |     |     using PerpsMarketFactory for PerpsMarketFactory.Data;
  37 |     | 
  38 |     |     /**
  39 |     |      * @inheritdoc IPerpsAccountModule
  40 |     |      */
  41 | *   |     function modifyCollateral(
  42 |     |         uint128 accountId,
  43 |     |         uint128 collateralId,
  44 |     |         int256 amountDelta
  45 | *   |     ) external override {
  46 | *   |         console2.log("===== PerpsAccountModule::modifyCollateral START =====");
  47 |     | 
  48 | *   |         console2.log("Before ensureAccessToFeature");
  49 | *   |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
  50 | *   |         console2.log("After ensureAccessToFeature");
  51 |     | 
  52 | *   |         PerpsCollateralConfiguration.validDistributorExists(collateralId);
  53 |     | 
  54 | *   |         Account.exists(accountId);
  55 | *   |         Account.loadAccountAndValidatePermission(
  56 | *   |             accountId,
  57 | *   |             AccountRBAC._PERPS_MODIFY_COLLATERAL_PERMISSION
  58 |     |         );
  59 |     | 
  60 | *   |         if (amountDelta == 0) revert InvalidAmountDelta(amountDelta);
  61 |     | 
  62 | *   |         console2.log("Before perpsMarketFactory");
  63 | *   |         PerpsMarketFactory.Data storage perpsMarketFactory = PerpsMarketFactory.load();
  64 | *   |         console2.log("After perpsMarketFactory");
  65 |     | 
  66 | *   |         console2.log("Before globalPerpsMarket");
  67 |     | 
  68 | *   |         GlobalPerpsMarket.Data storage globalPerpsMarket = GlobalPerpsMarket.load();
  69 | *   |         console2.log("After globalPerpsMarket");
  70 |     | 
  71 | *   |         globalPerpsMarket.validateCollateralAmount(collateralId, amountDelta);
  72 | *   |         globalPerpsMarket.checkLiquidation(accountId);
  73 |     | 
  74 | *   |         PerpsAccount.Data storage account = PerpsAccount.create(accountId);
  75 | *   |         uint128 perpsMarketId = perpsMarketFactory.perpsMarketId;
  76 |     | 
  77 | *   |         PerpsAccount.validateMaxCollaterals(accountId, collateralId);
  78 |     | 
  79 | *   |         AsyncOrder.checkPendingOrder(account.id);
  80 |     | 
  81 | *   |         if (amountDelta > 0) {
  82 | *   |             _depositMargin(perpsMarketFactory, perpsMarketId, collateralId, amountDelta.toUint());
  83 | *   |         } else {
  84 | *   |             uint256 amountAbs = MathUtil.abs(amountDelta);
  85 |     |             // removing collateral
  86 | *   |             account.validateWithdrawableAmount(
  87 | *   |                 collateralId,
  88 |     |                 amountAbs,
  89 | *   |                 perpsMarketFactory.spotMarket
  90 |     |             );
  91 | *   |             _withdrawMargin(perpsMarketFactory, perpsMarketId, collateralId, amountAbs);
  92 |     |         }
  93 |     | 
  94 |     |         // accounting
  95 | *   |         account.updateCollateralAmount(collateralId, amountDelta);
  96 |     | 
  97 | *   |         emit CollateralModified(accountId, collateralId, amountDelta, ERC2771Context._msgSender());
  98 | *   |         console2.log("===== PerpsAccountModule::modifyCollateral END =====");
  99 |     |     }
 100 |     | 
 101 | *   |     function debt(uint128 accountId) external view override returns (uint256 accountDebt) {
 102 | *   |         Account.exists(accountId);
 103 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
 104 |     | 
 105 | *   |         accountDebt = account.debt;
 106 |     |     }
 107 |     | 
 108 |     |     // 1. call depositMarketUsd and deposit amount directly to core system
 109 |     |     // 2. look up account and reduce debt by amount
 110 |     |     // 3b. quoteUnwrap() -> inchQuote -> returnAmount
 111 | *   |     function payDebt(uint128 accountId, uint256 amount) external override {
 112 | *   |         Account.exists(accountId);
 113 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
 114 |     | 
 115 | *   |         account.payDebt(amount);
 116 |     | 
 117 | *   |         emit DebtPaid(accountId, amount, ERC2771Context._msgSender());
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @inheritdoc IPerpsAccountModule
 122 |     |      */
 123 | *   |     function totalCollateralValue(uint128 accountId) external view override returns (uint256) {
 124 |     |         return
 125 | *   |             PerpsAccount.load(accountId).getTotalCollateralValue(
 126 | *   |                 PerpsPrice.Tolerance.DEFAULT,
 127 | *   |                 false
 128 |     |             );
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @inheritdoc IPerpsAccountModule
 133 |     |      */
 134 |     |     function totalAccountOpenInterest(uint128 accountId) external view override returns (uint256) {
 135 |     |         return PerpsAccount.load(accountId).getTotalNotionalOpenInterest();
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @inheritdoc IPerpsAccountModule
 140 |     |      */
 141 | *   |     function getOpenPosition(
 142 |     |         uint128 accountId,
 143 |     |         uint128 marketId
 144 |     |     )
 145 |     |         external
 146 |     |         view
 147 |     |         override
 148 | *   |         returns (int256 totalPnl, int256 accruedFunding, int128 positionSize, uint256 owedInterest)
 149 |     |     {
 150 | *   |         PerpsMarket.Data storage perpsMarket = PerpsMarket.loadValid(marketId);
 151 |     | 
 152 | *   |         Position.Data storage position = perpsMarket.positions[accountId];
 153 |     | 
 154 | *   |         (, totalPnl, , owedInterest, accruedFunding, , ) = position.getPositionData(
 155 | *   |             PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)
 156 |     |         );
 157 | *   |         return (totalPnl, accruedFunding, position.size, owedInterest);
 158 |     |     }
 159 |     | 
 160 |     |     /**
 161 |     |      * @inheritdoc IPerpsAccountModule
 162 |     |      */
 163 |     |     function getOpenPositionSize(
 164 |     |         uint128 accountId,
 165 |     |         uint128 marketId
 166 |     |     ) external view override returns (int128 positionSize) {
 167 |     |         PerpsMarket.Data storage perpsMarket = PerpsMarket.loadValid(marketId);
 168 |     | 
 169 |     |         positionSize = perpsMarket.positions[accountId].size;
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @inheritdoc IPerpsAccountModule
 174 |     |      */
 175 | *   |     function getAvailableMargin(
 176 |     |         uint128 accountId
 177 | *   |     ) external view override returns (int256 availableMargin) {
 178 | *   |         availableMargin = PerpsAccount.load(accountId).getAvailableMargin(
 179 | *   |             PerpsPrice.Tolerance.DEFAULT
 180 |     |         );
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @inheritdoc IPerpsAccountModule
 185 |     |      */
 186 | *   |     function getWithdrawableMargin(
 187 |     |         uint128 accountId
 188 |     |     ) external view override returns (int256 withdrawableMargin) {
 189 |     |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
 190 | *   |         withdrawableMargin = account.getWithdrawableMargin(PerpsPrice.Tolerance.DEFAULT);
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @inheritdoc IPerpsAccountModule
 195 |     |      */
 196 | *   |     function getRequiredMargins(
 197 |     |         uint128 accountId
 198 |     |     )
 199 |     |         external
 200 |     |         view
 201 |     |         override
 202 |     |         returns (
 203 | *   |             uint256 requiredInitialMargin,
 204 | *   |             uint256 requiredMaintenanceMargin,
 205 | *   |             uint256 maxLiquidationReward
 206 |     |         )
 207 | *   |     {
 208 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
 209 | *   |         if (account.openPositionMarketIds.length() == 0) {
 210 | *   |             return (0, 0, 0);
 211 |     |         }
 212 |     | 
 213 | *   |         (requiredInitialMargin, requiredMaintenanceMargin, maxLiquidationReward) = account
 214 | *   |             .getAccountRequiredMargins(PerpsPrice.Tolerance.DEFAULT);
 215 |     | 
 216 |     |         // Include liquidation rewards to required initial margin and required maintenance margin
 217 | *   |         requiredInitialMargin += maxLiquidationReward;
 218 | *   |         requiredMaintenanceMargin += maxLiquidationReward;
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @inheritdoc IPerpsAccountModule
 223 |     |      */
 224 | *   |     function getCollateralAmount(
 225 |     |         uint128 accountId,
 226 |     |         uint128 collateralId
 227 | *   |     ) external view override returns (uint256) {
 228 | *   |         return PerpsAccount.load(accountId).collateralAmounts[collateralId];
 229 |     |     }
 230 |     | 
 231 |     |     /**
 232 |     |      * @inheritdoc IPerpsAccountModule
 233 |     |      */
 234 | *   |     function getAccountCollateralIds(
 235 |     |         uint128 accountId
 236 | *   |     ) external view override returns (uint256[] memory) {
 237 | *   |         return PerpsAccount.load(accountId).activeCollateralTypes.values();
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @inheritdoc IPerpsAccountModule
 242 |     |      */
 243 | *   |     function getAccountOpenPositions(
 244 |     |         uint128 accountId
 245 |     |     ) external view override returns (uint256[] memory) {
 246 |     |         return PerpsAccount.load(accountId).openPositionMarketIds.values();
 247 |     |     }
 248 |     | 
 249 | *   |     function _depositMargin(
 250 |     |         PerpsMarketFactory.Data storage perpsMarketFactory,
 251 |     |         uint128 perpsMarketId,
 252 |     |         uint128 collateralId,
 253 |     |         uint256 amount
 254 |     |     ) internal {
 255 | *   |         if (collateralId == SNX_USD_MARKET_ID) {
 256 |     |             // depositing into the USD market
 257 | *   |             perpsMarketFactory.synthetix.depositMarketUsd(
 258 | *   |                 perpsMarketId,
 259 | *   |                 ERC2771Context._msgSender(),
 260 | *   |                 amount
 261 |     |             );
 262 |     |         } else {
 263 | *   |             ITokenModule synth = ITokenModule(perpsMarketFactory.spotMarket.getSynth(collateralId));
 264 | *   |             synth.transferFrom(ERC2771Context._msgSender(), address(this), amount);
 265 |     |             // depositing into a synth market
 266 | *   |             perpsMarketFactory.depositMarketCollateral(synth, amount);
 267 |     |         }
 268 |     |     }
 269 |     | 
 270 | *   |     function _withdrawMargin(
 271 |     |         PerpsMarketFactory.Data storage perpsMarketFactory,
 272 |     |         uint128 perpsMarketId,
 273 |     |         uint128 collateralId,
 274 |     |         uint256 amount
 275 |     |     ) internal {
 276 | *   |         if (collateralId == SNX_USD_MARKET_ID) {
 277 |     |             // withdrawing from the USD market
 278 |     |             perpsMarketFactory.synthetix.withdrawMarketUsd(
 279 |     |                 perpsMarketId,
 280 |     |                 ERC2771Context._msgSender(),
 281 |     |                 amount
 282 |     |             );
 283 | *   |         } else {
 284 | *   |             ITokenModule synth = ITokenModule(perpsMarketFactory.spotMarket.getSynth(collateralId));
 285 |     |             // withdrawing from a synth market
 286 | *   |             perpsMarketFactory.synthetix.withdrawMarketCollateral(
 287 | *   |                 perpsMarketId,
 288 |     |                 address(synth),
 289 | *   |                 amount
 290 |     |             );
 291 | *   |             synth.transfer(ERC2771Context._msgSender(), amount);
 292 |     |         }
 293 |     |     }
 294 |     | }
 295 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/PerpsMarketFactoryModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {OwnableStorage} from "@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol";
   5 |     | import {FeatureFlag} from "@synthetixio/core-modules/contracts/storage/FeatureFlag.sol";
   6 |     | import {IERC165} from "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
   7 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   8 |     | import {PerpsMarketFactory} from "../storage/PerpsMarketFactory.sol";
   9 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
  10 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
  11 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
  12 |     | import {Flags} from "../utils/Flags.sol";
  13 |     | import {MathUtil} from "../utils/MathUtil.sol";
  14 |     | import {InterestRate} from "../storage/InterestRate.sol";
  15 |     | import {IPerpsMarketFactoryModule} from "../interfaces/IPerpsMarketFactoryModule.sol";
  16 |     | import {ISpotMarketSystem} from "../interfaces/external/ISpotMarketSystem.sol";
  17 |     | import {ISynthetixSystem} from "../interfaces/external/ISynthetixSystem.sol";
  18 |     | import {ParameterError} from "@synthetixio/core-contracts/contracts/errors/ParameterError.sol";
  19 |     | import {PerpsMarketConfiguration} from "../storage/PerpsMarketConfiguration.sol";
  20 |     | import {IMarket} from "@synthetixio/main/contracts/interfaces/external/IMarket.sol";
  21 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  22 |     | import {SafeCastU256, SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  23 |     | 
  24 |     | /**
  25 |     |  * @title Module for registering perpetual futures markets. The factory tracks all markets in the system and consolidates implementation.
  26 |     |  * @dev See IPerpsMarketFactoryModule.
  27 |     |  */
  28 | *   | contract PerpsMarketFactoryModule is IPerpsMarketFactoryModule {
  29 |     |     using PerpsMarketFactory for PerpsMarketFactory.Data;
  30 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  31 |     |     using DecimalMath for uint256;
  32 |     |     using SafeCastU256 for uint256;
  33 |     |     using SafeCastI256 for int256;
  34 |     |     using SetUtil for SetUtil.UintSet;
  35 |     |     using PerpsMarket for PerpsMarket.Data;
  36 |     | 
  37 |     |     bytes32 private constant _ACCOUNT_TOKEN_SYSTEM = "accountNft";
  38 |     | 
  39 |     |     /**
  40 |     |      * @inheritdoc IPerpsMarketFactoryModule
  41 |     |      */
  42 |     |     function initializeFactory(
  43 |     |         ISynthetixSystem synthetix,
  44 |     |         ISpotMarketSystem spotMarket
  45 |     |     ) external override returns (uint128) {
  46 |     |         OwnableStorage.onlyOwner();
  47 |     | 
  48 |     |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
  49 |     | 
  50 |     |         uint128 perpsMarketId;
  51 |     |         if (factory.perpsMarketId == 0) {
  52 |     |             perpsMarketId = factory.initialize(synthetix, spotMarket);
  53 |     |         } else {
  54 |     |             perpsMarketId = factory.perpsMarketId;
  55 |     |         }
  56 |     | 
  57 |     |         emit FactoryInitialized(perpsMarketId);
  58 |     | 
  59 |     |         return perpsMarketId;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @inheritdoc IPerpsMarketFactoryModule
  64 |     |      */
  65 | *   |     function setPerpsMarketName(string memory marketName) external override {
  66 |     |         OwnableStorage.onlyOwner();
  67 | *   |         PerpsMarketFactory.load().name = marketName;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @inheritdoc IPerpsMarketFactoryModule
  72 |     |      */
  73 |     |     function createMarket(
  74 |     |         uint128 requestedMarketId,
  75 |     |         string memory marketName,
  76 |     |         string memory marketSymbol
  77 |     |     ) external override returns (uint128) {
  78 |     |         FeatureFlag.ensureAccessToFeature(Flags.PERPS_SYSTEM);
  79 |     |         FeatureFlag.ensureAccessToFeature(Flags.CREATE_MARKET);
  80 |     | 
  81 |     |         OwnableStorage.onlyOwner();
  82 |     |         PerpsMarketFactory.load().onlyIfInitialized();
  83 |     | 
  84 |     |         if (requestedMarketId == 0) {
  85 |     |             revert ParameterError.InvalidParameter("requestedMarketId", "cannot be 0");
  86 |     |         }
  87 |     | 
  88 |     |         PerpsMarket.createValid(requestedMarketId, marketName, marketSymbol);
  89 |     |         GlobalPerpsMarket.load().addMarket(requestedMarketId);
  90 |     | 
  91 |     |         emit MarketCreated(requestedMarketId, marketName, marketSymbol);
  92 |     | 
  93 |     |         return requestedMarketId;
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @inheritdoc IMarket
  98 |     |      */
  99 |     |     // solc-ignore-next-line func-mutability
 100 |     |     function name(uint128 perpsMarketId) external view override returns (string memory) {
 101 |     |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
 102 |     | 
 103 |     |         if (factory.perpsMarketId == perpsMarketId) {
 104 |     |             return string.concat(factory.name, " Perps Market");
 105 |     |         }
 106 |     | 
 107 |     |         return "";
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @inheritdoc IMarket
 112 |     |      */
 113 |     |     function reportedDebt(uint128 perpsMarketId) external view override returns (uint256) {
 114 |     |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
 115 |     | 
 116 |     |         if (factory.perpsMarketId == perpsMarketId) {
 117 |     |             // debt is the total debt of all markets
 118 |     |             // can be computed as total collateral value - sum_each_market( debt )
 119 |     |             GlobalPerpsMarket.Data storage globalMarket = GlobalPerpsMarket.load();
 120 |     |             uint256 collateralValue = globalMarket.totalCollateralValue();
 121 |     |             int256 totalMarketDebt;
 122 |     | 
 123 |     |             SetUtil.UintSet storage activeMarkets = globalMarket.activeMarkets;
 124 |     |             uint256 activeMarketsLength = activeMarkets.length();
 125 |     |             for (uint256 i = 1; i <= activeMarketsLength; i++) {
 126 | *   |                 uint128 marketId = activeMarkets.valueAt(i).to128();
 127 |     |                 totalMarketDebt += PerpsMarket.load(marketId).marketDebt(
 128 |     |                     PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)
 129 |     |                 );
 130 |     |             }
 131 |     | 
 132 |     |             int256 totalDebt = collateralValue.toInt() +
 133 |     |                 totalMarketDebt -
 134 |     |                 globalMarket.totalAccountsDebt.toInt();
 135 |     |             return MathUtil.max(0, totalDebt).toUint();
 136 |     |         }
 137 |     | 
 138 |     |         return 0;
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @inheritdoc IMarket
 143 |     |      */
 144 | *   |     function minimumCredit(uint128 perpsMarketId) external view override returns (uint256) {
 145 | *   |         if (PerpsMarketFactory.load().perpsMarketId == perpsMarketId) {
 146 | *   |             return GlobalPerpsMarket.load().minimumCredit(PerpsPrice.Tolerance.DEFAULT);
 147 |     |         }
 148 |     | 
 149 | *   |         return 0;
 150 |     |     }
 151 |     | 
 152 |     |     /**
 153 |     |      * @inheritdoc IPerpsMarketFactoryModule
 154 |     |      */
 155 |     |     function interestRate() external view override returns (uint128) {
 156 |     |         return InterestRate.load().interestRate;
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @inheritdoc IPerpsMarketFactoryModule
 161 |     |      */
 162 | *   |     function utilizationRate()
 163 |     |         external
 164 |     |         view
 165 |     |         override
 166 | *   |         returns (uint256 rate, uint256 delegatedCollateral, uint256 lockedCredit)
 167 |     |     {
 168 | *   |         return GlobalPerpsMarket.load().utilizationRate(PerpsPrice.Tolerance.ONE_MONTH);
 169 |     |     }
 170 |     | 
 171 |     |     /**
 172 |     |      * @dev See {IERC165-supportsInterface}.
 173 |     |      */
 174 | *   |     function supportsInterface(
 175 |     |         bytes4 interfaceId
 176 |     |     ) public view virtual override(IERC165) returns (bool) {
 177 | *   |         return
 178 | *   |             interfaceId == type(IMarket).interfaceId ||
 179 |     |             interfaceId == this.supportsInterface.selector;
 180 |     |     }
 181 |     | }
 182 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/modules/PerpsMarketModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
   5 |     | import {PerpsMarketConfiguration} from "../storage/PerpsMarketConfiguration.sol";
   6 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
   7 |     | import {AsyncOrder} from "../storage/AsyncOrder.sol";
   8 |     | import {IPerpsMarketModule} from "../interfaces/IPerpsMarketModule.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title Module for getting perps market information.
  12 |     |  * @dev See IPerpsMarketModule.
  13 |     |  */
  14 | *   | contract PerpsMarketModule is IPerpsMarketModule {
  15 |     |     using PerpsMarket for PerpsMarket.Data;
  16 |     | 
  17 |     |     /**
  18 |     |      * @inheritdoc IPerpsMarketModule
  19 |     |      */
  20 |     |     function metadata(
  21 |     |         uint128 marketId
  22 |     |     ) external view override returns (string memory name, string memory symbol) {
  23 |     |         PerpsMarket.Data storage market = PerpsMarket.load(marketId);
  24 |     |         return (market.name, market.symbol);
  25 |     |     }
  26 |     | 
  27 |     |     /**
  28 |     |      * @inheritdoc IPerpsMarketModule
  29 |     |      */
  30 | *   |     function skew(uint128 marketId) external view override returns (int256) {
  31 | *   |         return PerpsMarket.load(marketId).skew;
  32 |     |     }
  33 |     | 
  34 |     |     /**
  35 |     |      * @inheritdoc IPerpsMarketModule
  36 |     |      */
  37 | *   |     function size(uint128 marketId) external view override returns (uint256) {
  38 | *   |         return PerpsMarket.load(marketId).size;
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @inheritdoc IPerpsMarketModule
  43 |     |      */
  44 | *   |     function maxOpenInterest(uint128 marketId) external view override returns (uint256) {
  45 | *   |         return PerpsMarketConfiguration.load(marketId).maxMarketSize;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @inheritdoc IPerpsMarketModule
  50 |     |      */
  51 |     |     function currentFundingRate(uint128 marketId) external view override returns (int256) {
  52 |     |         return PerpsMarket.load(marketId).currentFundingRate();
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @inheritdoc IPerpsMarketModule
  57 |     |      */
  58 |     |     function currentFundingVelocity(uint128 marketId) external view override returns (int256) {
  59 |     |         return PerpsMarket.load(marketId).currentFundingVelocity();
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @inheritdoc IPerpsMarketModule
  64 |     |      */
  65 |     |     function indexPrice(uint128 marketId) external view override returns (uint256) {
  66 |     |         return PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT);
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @inheritdoc IPerpsMarketModule
  71 |     |      */
  72 |     |     function fillPrice(
  73 |     |         uint128 marketId,
  74 |     |         int128 orderSize,
  75 |     |         uint256 price
  76 |     |     ) external view override returns (uint256) {
  77 |     |         return
  78 |     |             AsyncOrder.calculateFillPrice(
  79 |     |                 PerpsMarket.load(marketId).skew,
  80 |     |                 PerpsMarketConfiguration.load(marketId).skewScale,
  81 |     |                 orderSize,
  82 |     |                 price
  83 |     |             );
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @inheritdoc IPerpsMarketModule
  88 |     |      */
  89 |     |     function getMarketSummary(
  90 |     |         uint128 marketId
  91 |     |     ) external view override returns (MarketSummary memory summary) {
  92 |     |         PerpsMarket.Data storage market = PerpsMarket.load(marketId);
  93 |     |         return
  94 |     |             MarketSummary({
  95 |     |                 skew: market.skew,
  96 |     |                 size: market.size,
  97 |     |                 maxOpenInterest: this.maxOpenInterest(marketId),
  98 |     |                 currentFundingRate: market.currentFundingRate(),
  99 |     |                 currentFundingVelocity: market.currentFundingVelocity(),
 100 |     |                 indexPrice: this.indexPrice(marketId)
 101 |     |             });
 102 |     |     }
 103 |     | }
 104 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/AsyncOrder.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   5 |     | import {SafeCastI256, SafeCastU256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   6 |     | import {SettlementStrategy} from "./SettlementStrategy.sol";
   7 |     | import {Position} from "./Position.sol";
   8 |     | import {PerpsMarketConfiguration} from "./PerpsMarketConfiguration.sol";
   9 |     | import {PerpsMarket} from "./PerpsMarket.sol";
  10 |     | import {PerpsPrice} from "./PerpsPrice.sol";
  11 |     | import {PerpsAccount} from "./PerpsAccount.sol";
  12 |     | import {MathUtil} from "../utils/MathUtil.sol";
  13 |     | import {OrderFee} from "./OrderFee.sol";
  14 |     | import {KeeperCosts} from "./KeeperCosts.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @title Async order top level data storage
  18 |     |  */
  19 |     | library AsyncOrder {
  20 |     |     using DecimalMath for int256;
  21 |     |     using DecimalMath for int128;
  22 |     |     using DecimalMath for uint256;
  23 |     |     using SafeCastI256 for int256;
  24 |     |     using SafeCastU256 for uint256;
  25 |     |     using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;
  26 |     |     using PerpsMarket for PerpsMarket.Data;
  27 |     |     using PerpsAccount for PerpsAccount.Data;
  28 |     |     using KeeperCosts for KeeperCosts.Data;
  29 |     | 
  30 |     |     /**
  31 |     |      * @notice Thrown when settlement window is not open yet.
  32 |     |      */
  33 |     |     error SettlementWindowNotOpen(uint256 timestamp, uint256 settlementTime);
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Thrown when attempting to settle an expired order.
  37 |     |      */
  38 |     |     error SettlementWindowExpired(
  39 |     |         uint256 timestamp,
  40 |     |         uint256 settlementTime,
  41 |     |         uint256 settlementExpiration
  42 |     |     );
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Thrown when order does not exist.
  46 |     |      * @dev Order does not exist if the order sizeDelta is 0.
  47 |     |      */
  48 |     |     error OrderNotValid();
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Thrown when fill price exceeds the acceptable price set at submission.
  52 |     |      */
  53 |     |     error AcceptablePriceExceeded(uint256 fillPrice, uint256 acceptablePrice);
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Gets thrown when attempting to cancel an order and price does not exceeds acceptable price.
  57 |     |      */
  58 |     |     error AcceptablePriceNotExceeded(uint256 fillPrice, uint256 acceptablePrice);
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice Gets thrown when pending orders exist and attempts to modify collateral.
  62 |     |      */
  63 |     |     error PendingOrderExists();
  64 |     | 
  65 |     |     /**
  66 |     |      * @notice Thrown when commiting an order with sizeDelta is zero.
  67 |     |      * @dev Size delta 0 is used to flag a non-valid order since it's a non-update order.
  68 |     |      */
  69 |     |     error ZeroSizeOrder();
  70 |     | 
  71 |     |     /**
  72 |     |      * @notice Thrown when there's not enough margin to cover the order and settlement costs associated.
  73 |     |      */
  74 |     |     error InsufficientMargin(int256 availableMargin, uint256 minMargin);
  75 |     | 
  76 |     |     struct Data {
  77 |     |         /**
  78 |     |          * @dev Time at which the order was committed.
  79 |     |          */
  80 |     |         uint256 commitmentTime;
  81 |     |         /**
  82 |     |          * @dev Order request details.
  83 |     |          */
  84 |     |         OrderCommitmentRequest request;
  85 |     |     }
  86 |     | 
  87 |     |     struct OrderCommitmentRequest {
  88 |     |         /**
  89 |     |          * @dev Order market id.
  90 |     |          */
  91 |     |         uint128 marketId;
  92 |     |         /**
  93 |     |          * @dev Order account id.
  94 |     |          */
  95 |     |         uint128 accountId;
  96 |     |         /**
  97 |     |          * @dev Order size delta (of asset units expressed in decimal 18 digits). It can be positive or negative.
  98 |     |          */
  99 |     |         int128 sizeDelta;
 100 |     |         /**
 101 |     |          * @dev Settlement strategy used for the order.
 102 |     |          */
 103 |     |         uint128 settlementStrategyId;
 104 |     |         /**
 105 |     |          * @dev Acceptable price set at submission.
 106 |     |          */
 107 |     |         uint256 acceptablePrice;
 108 |     |         /**
 109 |     |          * @dev An optional code provided by frontends to assist with tracking the source of volume and fees.
 110 |     |          */
 111 |     |         bytes32 trackingCode;
 112 |     |         /**
 113 |     |          * @dev Referrer address to send the referrer fees to.
 114 |     |          */
 115 |     |         address referrer;
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @notice Updates the order with the commitment request data and settlement time.
 120 |     |      */
 121 | *   |     function load(uint128 accountId) internal pure returns (Data storage order) {
 122 | *   |         bytes32 s = keccak256(abi.encode("io.synthetix.perps-market.AsyncOrder", accountId));
 123 |     | 
 124 |     |         assembly {
 125 |     |             order.slot := s
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Reverts if order was not committed by checking the sizeDelta.
 131 |     |      * @dev Reverts if order is not in the settlement window.
 132 |     |      */
 133 | *   |     function loadValid(
 134 |     |         uint128 accountId
 135 | *   |     ) internal view returns (Data storage order, SettlementStrategy.Data storage strategy) {
 136 | *   |         order = load(accountId);
 137 | *   |         if (order.request.sizeDelta == 0) {
 138 | *   |             revert OrderNotValid();
 139 |     |         }
 140 |     | 
 141 | *   |         strategy = PerpsMarketConfiguration.loadValidSettlementStrategy(
 142 | *   |             order.request.marketId,
 143 | *   |             order.request.settlementStrategyId
 144 |     |         );
 145 | *   |         checkWithinSettlementWindow(order, strategy);
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Updates the order with the new commitment request data and settlement time.
 150 |     |      * @dev Reverts if there's a pending order.
 151 |     |      * @dev Reverts if accont cannot open a new position (due to max allowed reached).
 152 |     |      */
 153 | *   |     function updateValid(Data storage self, OrderCommitmentRequest memory newRequest) internal {
 154 | *   |         checkPendingOrder(newRequest.accountId);
 155 |     | 
 156 | *   |         PerpsAccount.validateMaxPositions(newRequest.accountId, newRequest.marketId);
 157 |     | 
 158 |     |         // Replace previous (or empty) order with the commitment request
 159 | *   |         self.commitmentTime = block.timestamp;
 160 | *   |         self.request = newRequest;
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Reverts if there is a pending order.
 165 |     |      * @dev A pending order is one that has a sizeDelta and isn't expired yet.
 166 |     |      */
 167 | *   |     function checkPendingOrder(uint128 accountId) internal view returns (Data storage order) {
 168 | *   |         order = load(accountId);
 169 |     | 
 170 | *   |         if (order.request.sizeDelta != 0) {
 171 | *   |             SettlementStrategy.Data storage strategy = PerpsMarketConfiguration
 172 | *   |                 .load(order.request.marketId)
 173 | *   |                 .settlementStrategies[order.request.settlementStrategyId];
 174 |     | 
 175 | *   |             if (!expired(order, strategy)) {
 176 | *   |                 revert PendingOrderExists();
 177 |     |             }
 178 |     |         }
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @notice Resets the order.
 183 |     |      * @dev This function is called after the order is settled.
 184 |     |      * @dev Just setting the sizeDelta to 0 is enough, since is the value checked to identify an active order at settlement time.
 185 |     |      * @dev The rest of the fields will be updated on the next commitment. Not doing it here is more gas efficient.
 186 |     |      */
 187 | *   |     function reset(Data storage self) internal {
 188 | *   |         self.request.sizeDelta = 0;
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @notice Checks if the order window settlement is opened and expired.
 193 |     |      * @dev Reverts if block.timestamp is < settlementTime (not <=, so even if the settlementDelay is set to zero, it will require at least 1 second waiting time)
 194 |     |      * @dev Reverts if block.timestamp is > settlementTime + settlementWindowDuration
 195 |     |      */
 196 | *   |     function checkWithinSettlementWindow(
 197 |     |         Data storage self,
 198 |     |         SettlementStrategy.Data storage settlementStrategy
 199 |     |     ) internal view {
 200 | *   |         uint256 settlementTime = self.commitmentTime + settlementStrategy.settlementDelay;
 201 | *   |         uint256 settlementExpiration = settlementTime + settlementStrategy.settlementWindowDuration;
 202 |     | 
 203 | *   |         if (block.timestamp < settlementTime) {
 204 |     |             revert SettlementWindowNotOpen(block.timestamp, settlementTime);
 205 |     |         }
 206 |     | 
 207 | *   |         if (block.timestamp > settlementExpiration) {
 208 | *   |             revert SettlementWindowExpired(block.timestamp, settlementTime, settlementExpiration);
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @notice Returns if order is expired or not
 214 |     |      */
 215 | *   |     function expired(
 216 |     |         Data storage self,
 217 |     |         SettlementStrategy.Data storage settlementStrategy
 218 | *   |     ) internal view returns (bool) {
 219 | *   |         uint256 settlementExpiration = self.commitmentTime +
 220 | *   |             settlementStrategy.settlementDelay +
 221 | *   |             settlementStrategy.settlementWindowDuration;
 222 | *   |         return block.timestamp > settlementExpiration;
 223 |     |     }
 224 |     | 
 225 |     |     /**
 226 |     |      * @dev Struct used internally in validateOrder() to prevent stack too deep error.
 227 |     |      */
 228 |     |     struct SimulateDataRuntime {
 229 |     |         bool isEligible;
 230 |     |         int128 sizeDelta;
 231 |     |         uint128 accountId;
 232 |     |         uint128 marketId;
 233 |     |         uint256 fillPrice;
 234 |     |         uint256 orderFees;
 235 |     |         uint256 availableMargin;
 236 |     |         uint256 currentLiquidationMargin;
 237 |     |         uint256 accumulatedLiquidationRewards;
 238 |     |         uint256 currentLiquidationReward;
 239 |     |         int128 newPositionSize;
 240 |     |         uint256 newNotionalValue;
 241 |     |         int256 currentAvailableMargin;
 242 |     |         uint256 requiredInitialMargin;
 243 |     |         uint256 initialRequiredMargin;
 244 |     |         uint256 totalRequiredMargin;
 245 |     |         Position.Data newPosition;
 246 |     |         bytes32 trackingCode;
 247 |     |     }
 248 |     | 
 249 |     |     /**
 250 |     |      * @notice Checks if the order request can be settled.
 251 |     |      * @dev it recomputes market funding rate, calculates fill price and fees for the order
 252 |     |      * @dev and with that data it checks that:
 253 |     |      * @dev - the account is eligible for liquidation
 254 |     |      * @dev - the fill price is within the acceptable price range
 255 |     |      * @dev - the position size doesn't exceed market configured limits
 256 |     |      * @dev - the account has enough margin to cover for the fees
 257 |     |      * @dev - the account has enough margin to not be liquidable immediately after the order is settled
 258 |     |      * @dev if the order can be executed, it returns (newPosition, orderFees, fillPrice, oldPosition)
 259 |     |      */
 260 | *   |     function validateRequest(
 261 |     |         Data storage order,
 262 |     |         SettlementStrategy.Data storage strategy,
 263 |     |         uint256 orderPrice
 264 |     |     ) internal returns (Position.Data memory, uint256, uint256, Position.Data storage oldPosition) {
 265 | *   |         SimulateDataRuntime memory runtime;
 266 | *   |         runtime.sizeDelta = order.request.sizeDelta;
 267 | *   |         runtime.accountId = order.request.accountId;
 268 | *   |         runtime.marketId = order.request.marketId;
 269 |     | 
 270 | *   |         if (runtime.sizeDelta == 0) {
 271 |     |             revert ZeroSizeOrder();
 272 |     |         }
 273 |     | 
 274 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(runtime.accountId);
 275 |     | 
 276 | *   |         (
 277 |     |             runtime.isEligible,
 278 | *   |             runtime.currentAvailableMargin,
 279 | *   |             runtime.requiredInitialMargin,
 280 |     |             ,
 281 | *   |             runtime.currentLiquidationReward
 282 | *   |         ) = account.isEligibleForLiquidation(PerpsPrice.Tolerance.DEFAULT);
 283 |     | 
 284 | *   |         if (runtime.isEligible) {
 285 | *   |             revert PerpsAccount.AccountLiquidatable(runtime.accountId);
 286 |     |         }
 287 |     | 
 288 | *   |         PerpsMarket.Data storage perpsMarketData = PerpsMarket.load(runtime.marketId);
 289 | *   |         perpsMarketData.recomputeFunding(orderPrice);
 290 |     | 
 291 | *   |         PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(
 292 | *   |             runtime.marketId
 293 |     |         );
 294 |     | 
 295 | *   |         runtime.fillPrice = calculateFillPrice(
 296 | *   |             perpsMarketData.skew,
 297 | *   |             marketConfig.skewScale,
 298 | *   |             runtime.sizeDelta,
 299 | *   |             orderPrice
 300 |     |         );
 301 |     | 
 302 | *   |         runtime.orderFees =
 303 | *   |             calculateOrderFee(
 304 | *   |                 runtime.sizeDelta,
 305 | *   |                 runtime.fillPrice,
 306 | *   |                 perpsMarketData.skew,
 307 | *   |                 marketConfig.orderFees
 308 |     |             ) +
 309 | *   |             settlementRewardCost(strategy);
 310 |     | 
 311 | *   |         oldPosition = PerpsMarket.accountPosition(runtime.marketId, runtime.accountId);
 312 | *   |         runtime.newPositionSize = oldPosition.size + runtime.sizeDelta;
 313 |     | 
 314 |     |         // only account for negative pnl
 315 | *   |         runtime.currentAvailableMargin += MathUtil.min(
 316 | *   |             calculateStartingPnl(runtime.fillPrice, orderPrice, runtime.newPositionSize),
 317 | *   |             0
 318 |     |         );
 319 |     | 
 320 | *   |         if (runtime.currentAvailableMargin < runtime.orderFees.toInt()) {
 321 | *   |             revert InsufficientMargin(runtime.currentAvailableMargin, runtime.orderFees);
 322 |     |         }
 323 |     | 
 324 | *   |         PerpsMarket.validatePositionSize(
 325 | *   |             perpsMarketData,
 326 | *   |             marketConfig.maxMarketSize,
 327 | *   |             marketConfig.maxMarketValue,
 328 | *   |             orderPrice,
 329 | *   |             oldPosition.size,
 330 | *   |             runtime.newPositionSize
 331 |     |         );
 332 |     | 
 333 | *   |         runtime.totalRequiredMargin =
 334 | *   |             getRequiredMarginWithNewPosition(
 335 | *   |                 account,
 336 | *   |                 marketConfig,
 337 | *   |                 runtime.marketId,
 338 | *   |                 oldPosition.size,
 339 | *   |                 runtime.newPositionSize,
 340 | *   |                 runtime.fillPrice,
 341 | *   |                 runtime.requiredInitialMargin
 342 |     |             ) +
 343 | *   |             runtime.orderFees;
 344 |     | 
 345 | *   |         if (runtime.currentAvailableMargin < runtime.totalRequiredMargin.toInt()) {
 346 | *   |             revert InsufficientMargin(runtime.currentAvailableMargin, runtime.totalRequiredMargin);
 347 |     |         }
 348 |     | 
 349 | *   |         runtime.newPosition = Position.Data({
 350 | *   |             marketId: runtime.marketId,
 351 | *   |             latestInteractionPrice: runtime.fillPrice.to128(),
 352 | *   |             latestInteractionFunding: perpsMarketData.lastFundingValue.to128(),
 353 | *   |             latestInterestAccrued: 0,
 354 | *   |             size: runtime.newPositionSize
 355 |     |         });
 356 | *   |         return (runtime.newPosition, runtime.orderFees, runtime.fillPrice, oldPosition);
 357 |     |     }
 358 |     | 
 359 |     |     /**
 360 |     |      * @notice Checks if the order request can be cancelled.
 361 |     |      * @notice This function doesn't check for liquidation or available margin since the fees to be paid are small and we did that check at commitment less than the settlement window time.
 362 |     |      * @notice it won't check if the order exists since it was already checked when loading the order (loadValid)
 363 |     |      * @dev it calculates fill price the order
 364 |     |      * @dev and with that data it checks that:
 365 |     |      * @dev - settlement window is open
 366 |     |      * @dev - the fill price is outside the acceptable price range
 367 |     |      * @dev if the order can be cancelled, it returns the fillPrice
 368 |     |      */
 369 | *   |     function validateCancellation(
 370 |     |         Data storage order,
 371 |     |         SettlementStrategy.Data storage strategy,
 372 |     |         uint256 orderPrice
 373 | *   |     ) internal view returns (uint256 fillPrice) {
 374 | *   |         checkWithinSettlementWindow(order, strategy);
 375 |     | 
 376 | *   |         PerpsMarket.Data storage perpsMarketData = PerpsMarket.load(order.request.marketId);
 377 |     | 
 378 | *   |         PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(
 379 | *   |             order.request.marketId
 380 |     |         );
 381 |     | 
 382 | *   |         fillPrice = calculateFillPrice(
 383 | *   |             perpsMarketData.skew,
 384 | *   |             marketConfig.skewScale,
 385 | *   |             order.request.sizeDelta,
 386 | *   |             orderPrice
 387 |     |         );
 388 |     | 
 389 |     |         // check if fill price exceeded acceptable price
 390 | *   |         if (!acceptablePriceExceeded(order, fillPrice)) {
 391 | *   |             revert AcceptablePriceNotExceeded(fillPrice, order.request.acceptablePrice);
 392 |     |         }
 393 |     |     }
 394 |     | 
 395 |     |     /**
 396 |     |      * @notice Calculates the settlement rewards.
 397 |     |      */
 398 | *   |     function settlementRewardCost(
 399 |     |         SettlementStrategy.Data storage strategy
 400 | *   |     ) internal view returns (uint256) {
 401 | *   |         return KeeperCosts.load().getSettlementKeeperCosts() + strategy.settlementReward;
 402 |     |     }
 403 |     | 
 404 |     |     /**
 405 |     |      * @notice Calculates the order fees.
 406 |     |      */
 407 | *   |     function calculateOrderFee(
 408 |     |         int128 sizeDelta,
 409 |     |         uint256 fillPrice,
 410 |     |         int256 marketSkew,
 411 |     |         OrderFee.Data storage orderFeeData
 412 | *   |     ) internal view returns (uint256) {
 413 | *   |         int256 notionalDiff = sizeDelta.mulDecimal(fillPrice.toInt());
 414 |     | 
 415 |     |         // does this trade keep the skew on one side?
 416 | *   |         if (MathUtil.sameSide(marketSkew + sizeDelta, marketSkew)) {
 417 |     |             // use a flat maker/taker fee for the entire size depending on whether the skew is increased or reduced.
 418 |     |             //
 419 |     |             // if the order is submitted on the same side as the skew (increasing it) - the taker fee is charged.
 420 |     |             // otherwise if the order is opposite to the skew, the maker fee is charged.
 421 |     | 
 422 | *   |             uint256 staticRate = MathUtil.sameSide(notionalDiff, marketSkew)
 423 | *   |                 ? orderFeeData.takerFee
 424 | *   |                 : orderFeeData.makerFee;
 425 | *   |             return MathUtil.abs(notionalDiff.mulDecimal(staticRate.toInt()));
 426 |     |         }
 427 |     | 
 428 |     |         // this trade flips the skew.
 429 |     |         //
 430 |     |         // the proportion of size that moves in the direction after the flip should not be considered
 431 |     |         // as a maker (reducing skew) as it's now taking (increasing skew) in the opposite direction. hence,
 432 |     |         // a different fee is applied on the proportion increasing the skew.
 433 |     | 
 434 |     |         // The proportions are computed as follows:
 435 |     |         // makerSize = abs(marketSkew) => since we are reversing the skew, the maker size is the current skew
 436 |     |         // takerSize = abs(marketSkew + sizeDelta) => since we are reversing the skew, the taker size is the new skew
 437 |     |         //
 438 |     |         // we then multiply the sizes by the fill price to get the notional value of each side, and that times the fee rate for each side
 439 |     | 
 440 | *   |         uint256 makerFee = MathUtil.abs(marketSkew).mulDecimal(fillPrice).mulDecimal(
 441 | *   |             orderFeeData.makerFee
 442 |     |         );
 443 |     | 
 444 | *   |         uint256 takerFee = MathUtil.abs(marketSkew + sizeDelta).mulDecimal(fillPrice).mulDecimal(
 445 | *   |             orderFeeData.takerFee
 446 |     |         );
 447 |     | 
 448 | *   |         return takerFee + makerFee;
 449 |     |     }
 450 |     | 
 451 |     |     /**
 452 |     |      * @notice Calculates the fill price for an order.
 453 |     |      */
 454 | *   |     function calculateFillPrice(
 455 |     |         int256 skew,
 456 |     |         uint256 skewScale,
 457 |     |         int128 size,
 458 |     |         uint256 price
 459 | *   |     ) internal pure returns (uint256) {
 460 |     |         // How is the p/d-adjusted price calculated using an example:
 461 |     |         //
 462 |     |         // price      = $1200 USD (oracle)
 463 |     |         // size       = 100
 464 |     |         // skew       = 0
 465 |     |         // skew_scale = 1,000,000 (1M)
 466 |     |         //
 467 |     |         // Then,
 468 |     |         //
 469 |     |         // pd_before = 0 / 1,000,000
 470 |     |         //           = 0
 471 |     |         // pd_after  = (0 + 100) / 1,000,000
 472 |     |         //           = 100 / 1,000,000
 473 |     |         //           = 0.0001
 474 |     |         //
 475 |     |         // price_before = 1200 * (1 + pd_before)
 476 |     |         //              = 1200 * (1 + 0)
 477 |     |         //              = 1200
 478 |     |         // price_after  = 1200 * (1 + pd_after)
 479 |     |         //              = 1200 * (1 + 0.0001)
 480 |     |         //              = 1200 * (1.0001)
 481 |     |         //              = 1200.12
 482 |     |         // Finally,
 483 |     |         //
 484 |     |         // fill_price = (price_before + price_after) / 2
 485 |     |         //            = (1200 + 1200.12) / 2
 486 |     |         //            = 1200.06
 487 | *   |         if (skewScale == 0) {
 488 |     |             return price;
 489 |     |         }
 490 |     |         // calculate pd (premium/discount) before and after trade
 491 | *   |         int256 pdBefore = skew.divDecimal(skewScale.toInt());
 492 | *   |         int256 newSkew = skew + size;
 493 | *   |         int256 pdAfter = newSkew.divDecimal(skewScale.toInt());
 494 |     | 
 495 |     |         // calculate price before and after trade with pd applied
 496 | *   |         int256 priceBefore = price.toInt() + (price.toInt().mulDecimal(pdBefore));
 497 | *   |         int256 priceAfter = price.toInt() + (price.toInt().mulDecimal(pdAfter));
 498 |     | 
 499 |     |         // the fill price is the average of those prices
 500 | *   |         return (priceBefore + priceAfter).toUint().divDecimal(DecimalMath.UNIT * 2);
 501 |     |     }
 502 |     | 
 503 |     |     struct RequiredMarginWithNewPositionRuntime {
 504 |     |         uint256 newRequiredMargin;
 505 |     |         uint256 oldRequiredMargin;
 506 |     |         uint256 requiredMarginForNewPosition;
 507 |     |         uint256 accumulatedLiquidationRewards;
 508 |     |         uint256 maxNumberOfWindows;
 509 |     |         uint256 numberOfWindows;
 510 |     |         uint256 requiredRewardMargin;
 511 |     |     }
 512 |     | 
 513 |     |     /**
 514 |     |      * @notice Initial pnl of a position after it's opened due to p/d fill price delta.
 515 |     |      */
 516 | *   |     function calculateStartingPnl(
 517 |     |         uint256 fillPrice,
 518 |     |         uint256 marketPrice,
 519 |     |         int128 size
 520 | *   |     ) internal pure returns (int256) {
 521 | *   |         return size.mulDecimal(marketPrice.toInt() - fillPrice.toInt());
 522 |     |     }
 523 |     | 
 524 |     |     /**
 525 |     |      * @notice After the required margins are calculated with the old position, this function replaces the
 526 |     |      * old position initial margin with the new position initial margin requirements and returns them.
 527 |     |      * @dev SIP-359: If the position is being reduced, required margin is 0.
 528 |     |      */
 529 | *   |     function getRequiredMarginWithNewPosition(
 530 |     |         PerpsAccount.Data storage account,
 531 |     |         PerpsMarketConfiguration.Data storage marketConfig,
 532 |     |         uint128 marketId,
 533 |     |         int128 oldPositionSize,
 534 |     |         int128 newPositionSize,
 535 |     |         uint256 fillPrice,
 536 |     |         uint256 currentTotalInitialMargin
 537 | *   |     ) internal view returns (uint256) {
 538 | *   |         RequiredMarginWithNewPositionRuntime memory runtime;
 539 |     | 
 540 | *   |         if (MathUtil.isSameSideReducing(oldPositionSize, newPositionSize)) {
 541 | *   |             return 0;
 542 |     |         }
 543 |     | 
 544 |     |         // get initial margin requirement for the new position
 545 | *   |         (, , runtime.newRequiredMargin, ) = marketConfig.calculateRequiredMargins(
 546 | *   |             newPositionSize,
 547 | *   |             fillPrice
 548 |     |         );
 549 |     | 
 550 |     |         // get initial margin of old position
 551 | *   |         (, , runtime.oldRequiredMargin, ) = marketConfig.calculateRequiredMargins(
 552 | *   |             oldPositionSize,
 553 | *   |             PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)
 554 |     |         );
 555 |     | 
 556 |     |         // remove the old initial margin and add the new initial margin requirement
 557 |     |         // this gets us our total required margin for new position
 558 | *   |         runtime.requiredMarginForNewPosition =
 559 | *   |             currentTotalInitialMargin +
 560 | *   |             runtime.newRequiredMargin -
 561 |     |             runtime.oldRequiredMargin;
 562 |     | 
 563 | *   |         (runtime.accumulatedLiquidationRewards, runtime.maxNumberOfWindows) = account
 564 | *   |             .getKeeperRewardsAndCosts(marketId);
 565 | *   |         runtime.accumulatedLiquidationRewards += marketConfig.calculateFlagReward(
 566 | *   |             MathUtil.abs(newPositionSize).mulDecimal(fillPrice)
 567 |     |         );
 568 | *   |         runtime.numberOfWindows = marketConfig.numberOfLiquidationWindows(
 569 | *   |             MathUtil.abs(newPositionSize)
 570 |     |         );
 571 | *   |         runtime.maxNumberOfWindows = MathUtil.max(
 572 |     |             runtime.numberOfWindows,
 573 | *   |             runtime.maxNumberOfWindows
 574 |     |         );
 575 |     | 
 576 | *   |         runtime.requiredRewardMargin = account.getPossibleLiquidationReward(
 577 | *   |             runtime.accumulatedLiquidationRewards,
 578 |     |             runtime.maxNumberOfWindows
 579 |     |         );
 580 |     | 
 581 |     |         // this is the required margin for the new position (minus any order fees)
 582 | *   |         return runtime.requiredMarginForNewPosition + runtime.requiredRewardMargin;
 583 |     |     }
 584 |     | 
 585 | *   |     function validateAcceptablePrice(Data storage order, uint256 fillPrice) internal view {
 586 | *   |         if (acceptablePriceExceeded(order, fillPrice)) {
 587 | *   |             revert AcceptablePriceExceeded(fillPrice, order.request.acceptablePrice);
 588 |     |         }
 589 |     |     }
 590 |     | 
 591 |     |     /**
 592 |     |      * @notice Checks if the fill price exceeds the acceptable price set at submission.
 593 |     |      */
 594 | *   |     function acceptablePriceExceeded(
 595 |     |         Data storage order,
 596 |     |         uint256 fillPrice
 597 | *   |     ) internal view returns (bool exceeded) {
 598 |     |         return
 599 | *   |             (order.request.sizeDelta > 0 && fillPrice > order.request.acceptablePrice) ||
 600 | *   |             (order.request.sizeDelta < 0 && fillPrice < order.request.acceptablePrice);
 601 |     |     }
 602 |     | }
 603 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/GlobalPerpsMarket.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ISpotMarketSystem} from "../interfaces/external/ISpotMarketSystem.sol";
   5 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   7 |     | import {MathUtil} from "../utils/MathUtil.sol";
   8 |     | import {GlobalPerpsMarketConfiguration} from "./GlobalPerpsMarketConfiguration.sol";
   9 |     | import {SafeCastU256, SafeCastI256, SafeCastU128} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  10 |     | import {PerpsAccount, SNX_USD_MARKET_ID} from "./PerpsAccount.sol";
  11 |     | import {PerpsMarket} from "./PerpsMarket.sol";
  12 |     | import {PerpsPrice} from "./PerpsPrice.sol";
  13 |     | import {PerpsMarketFactory} from "./PerpsMarketFactory.sol";
  14 |     | import {PerpsCollateralConfiguration} from "./PerpsCollateralConfiguration.sol";
  15 |     | import {console2} from "lib/forge-std/src/Test.sol";
  16 |     | /**
  17 |     |  * @title This library contains all global perps market data
  18 |     |  */
  19 |     | library GlobalPerpsMarket {
  20 |     |     using SafeCastI256 for int256;
  21 |     |     using SafeCastU256 for uint256;
  22 |     |     using SafeCastU128 for uint128;
  23 |     |     using DecimalMath for uint256;
  24 |     |     using SetUtil for SetUtil.UintSet;
  25 |     |     using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;
  26 |     | 
  27 |     |     bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET =
  28 | *   |         keccak256(abi.encode("io.synthetix.perps-market.GlobalPerpsMarket"));
  29 |     | 
  30 |     |     /**
  31 |     |      * @notice Thrown when attempting to deposit more than enabled collateral.
  32 |     |      */
  33 |     |     error MaxCollateralExceeded(
  34 |     |         uint128 collateralId,
  35 |     |         uint256 maxAmount,
  36 |     |         uint256 collateralAmount,
  37 |     |         uint256 depositAmount
  38 |     |     );
  39 |     | 
  40 |     |     /**
  41 |     |      * @notice Thrown when attempting to use a synth that is not enabled as collateral.
  42 |     |      */
  43 |     |     error SynthNotEnabledForCollateral(uint128 collateralId);
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Thrown when attempting to withdraw more collateral than is available.
  47 |     |      */
  48 |     |     error InsufficientCollateral(
  49 |     |         uint128 collateralId,
  50 |     |         uint256 collateralAmount,
  51 |     |         uint256 withdrawAmount
  52 |     |     );
  53 |     | 
  54 |     |     struct Data {
  55 |     |         /**
  56 |     |          * @dev Set of liquidatable account ids.
  57 |     |          */
  58 |     |         SetUtil.UintSet liquidatableAccounts;
  59 |     |         /**
  60 |     |          * @dev Collateral amounts running total, by collateral synth market id.
  61 |     |          */
  62 |     |         mapping(uint128 => uint256) collateralAmounts;
  63 |     |         SetUtil.UintSet activeCollateralTypes;
  64 |     |         SetUtil.UintSet activeMarkets;
  65 |     |         /**
  66 |     |          * @dev Total debt that hasn't been paid across all accounts.
  67 |     |          */
  68 |     |         uint256 totalAccountsDebt;
  69 |     |     }
  70 |     | 
  71 | *   |     function load() internal pure returns (Data storage marketData) {
  72 | *   |         bytes32 s = _SLOT_GLOBAL_PERPS_MARKET;
  73 |     |         assembly {
  74 |     |             marketData.slot := s
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 | *   |     function utilizationRate(
  79 |     |         Data storage self,
  80 |     |         PerpsPrice.Tolerance minCreditPriceTolerance
  81 | *   |     ) internal view returns (uint128 rate, uint256 delegatedCollateralValue, uint256 lockedCredit) {
  82 | *   |         console2.log("===== GlobalPerpsMarket::utilizationRate START =====");
  83 |     | 
  84 | *   |         uint256 withdrawableUsd = PerpsMarketFactory.totalWithdrawableUsd();
  85 | *   |         console2.log("withdrawableUsd", withdrawableUsd);
  86 |     | 
  87 | *   |         int256 delegatedCollateralValueInt = withdrawableUsd.toInt() -
  88 | *   |             totalCollateralValue(self).toInt();
  89 | *   |         console2.log("delegatedCollateralValueInt", delegatedCollateralValueInt);
  90 |     | 
  91 | *   |         lockedCredit = minimumCredit(self, minCreditPriceTolerance);
  92 | *   |         console2.log("lockedCredit", lockedCredit);
  93 |     | 
  94 | *   |         if (delegatedCollateralValueInt <= 0) {
  95 | *   |             console2.log("delegatedCollateralValueInt <= 0, returning UNIT_UINT128");
  96 | *   |             console2.log("rate", DecimalMath.UNIT_UINT128);
  97 |     | 
  98 | *   |             console2.log("lockedCredit", lockedCredit);
  99 | *   |             console2.log("===== utilizationRate END =====");
 100 | *   |             return (DecimalMath.UNIT_UINT128, 0, lockedCredit);
 101 |     |         }
 102 |     | 
 103 | *   |         delegatedCollateralValue = delegatedCollateralValueInt.toUint();
 104 | *   |         console2.log("delegatedCollateralValue", delegatedCollateralValue);
 105 |     | 
 106 | *   |         rate = lockedCredit.divDecimal(delegatedCollateralValue).to128();
 107 | *   |         console2.log("rate", rate);
 108 |     | 
 109 | *   |         console2.log("===== GlobalPerpsMarket::utilizationRate END =====");
 110 |     |     }
 111 |     | 
 112 | *   |     function minimumCredit(
 113 |     |         Data storage self,
 114 |     |         PerpsPrice.Tolerance priceTolerance
 115 | *   |     ) internal view returns (uint256 accumulatedMinimumCredit) {
 116 | *   |         console2.log("===== GlobalPerpsMarket::minimumCredit START =====");
 117 |     | 
 118 | *   |         uint256 activeMarketsLength = self.activeMarkets.length();
 119 | *   |         console2.log("activeMarketsLength", activeMarketsLength);
 120 |     | 
 121 | *   |         accumulatedMinimumCredit = 0;
 122 | *   |         console2.log("Initial accumulatedMinimumCredit", accumulatedMinimumCredit);
 123 |     | 
 124 | *   |         for (uint256 i = 1; i <= activeMarketsLength; i++) {
 125 | *   |             uint128 marketId = self.activeMarkets.valueAt(i).to128();
 126 | *   |             console2.log("Loop iteration", i);
 127 | *   |             console2.log("marketId", marketId);
 128 |     | 
 129 | *   |             uint256 requiredCreditForMarket = PerpsMarket.requiredCredit(marketId, priceTolerance);
 130 | *   |             console2.log("requiredCreditForMarket", requiredCreditForMarket);
 131 |     | 
 132 | *   |             accumulatedMinimumCredit += requiredCreditForMarket;
 133 | *   |             console2.log("Updated accumulatedMinimumCredit", accumulatedMinimumCredit);
 134 |     |         }
 135 |     | 
 136 | *   |         uint256 sUSDCollateralValue = self.collateralAmounts[SNX_USD_MARKET_ID];
 137 | *   |         console2.log("sUSDCollateralValue", sUSDCollateralValue);
 138 |     | 
 139 | *   |         accumulatedMinimumCredit += sUSDCollateralValue;
 140 | *   |         console2.log("Final accumulatedMinimumCredit", accumulatedMinimumCredit);
 141 |     | 
 142 | *   |         console2.log("===== GlobalPerpsMarket::minimumCredit END =====");
 143 |     |     }
 144 |     | 
 145 | *   |     function totalCollateralValue(Data storage self) internal view returns (uint256 total) {
 146 | *   |         ISpotMarketSystem spotMarket = PerpsMarketFactory.load().spotMarket;
 147 | *   |         SetUtil.UintSet storage activeCollateralTypes = self.activeCollateralTypes;
 148 | *   |         uint256 activeCollateralLength = activeCollateralTypes.length();
 149 | *   |         for (uint256 i = 1; i <= activeCollateralLength; i++) {
 150 | *   |             uint128 collateralId = activeCollateralTypes.valueAt(i).to128();
 151 |     | 
 152 | *   |             if (collateralId == SNX_USD_MARKET_ID) {
 153 | *   |                 total += self.collateralAmounts[collateralId];
 154 | *   |             } else {
 155 | *   |                 (uint256 collateralValue, ) = PerpsCollateralConfiguration
 156 |     |                     .load(collateralId)
 157 |     |                     .valueInUsd(
 158 | *   |                         self.collateralAmounts[collateralId],
 159 | *   |                         spotMarket,
 160 |     |                         PerpsPrice.Tolerance.DEFAULT,
 161 |     |                         false
 162 |     |                     );
 163 | *   |                 total += collateralValue;
 164 |     |             }
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 | *   |     function updateCollateralAmount(
 169 |     |         Data storage self,
 170 |     |         uint128 collateralId,
 171 |     |         int256 amountDelta
 172 | *   |     ) internal returns (uint256 collateralAmount) {
 173 | *   |         collateralAmount = (self.collateralAmounts[collateralId].toInt() + amountDelta).toUint();
 174 | *   |         self.collateralAmounts[collateralId] = collateralAmount;
 175 |     | 
 176 | *   |         bool isActiveCollateral = self.activeCollateralTypes.contains(collateralId);
 177 | *   |         if (collateralAmount > 0 && !isActiveCollateral) {
 178 | *   |             self.activeCollateralTypes.add(collateralId.to256());
 179 | *   |         } else if (collateralAmount == 0 && isActiveCollateral) {
 180 | *   |             self.activeCollateralTypes.remove(collateralId.to256());
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 | *   |     function updateDebt(Data storage self, int256 debtDelta) internal {
 185 | *   |         int256 newTotalAccountsDebt = self.totalAccountsDebt.toInt() + debtDelta;
 186 | *   |         self.totalAccountsDebt = newTotalAccountsDebt < 0 ? 0 : newTotalAccountsDebt.toUint();
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @notice Check if the account is set as liquidatable.
 191 |     |      */
 192 | *   |     function checkLiquidation(Data storage self, uint128 accountId) internal view {
 193 | *   |         if (self.liquidatableAccounts.contains(accountId)) {
 194 |     |             revert PerpsAccount.AccountLiquidatable(accountId);
 195 |     |         }
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |      * @notice Check the collateral is enabled and amount acceptable and adjusts accounting.
 200 |     |      * @dev called when the account is modifying collateral.
 201 |     |      * @dev 1. checks to ensure max cap isn't hit
 202 |     |      * @dev 2. adjusts accounting for collateral amounts
 203 |     |      */
 204 | *   |     function validateCollateralAmount(
 205 |     |         Data storage self,
 206 |     |         uint128 collateralId,
 207 |     |         int256 synthAmount
 208 | *   |     ) internal view {
 209 | *   |         uint256 collateralAmount = self.collateralAmounts[collateralId];
 210 | *   |         if (synthAmount > 0) {
 211 | *   |             uint256 maxAmount = PerpsCollateralConfiguration.load(collateralId).maxAmount;
 212 | *   |             if (maxAmount == 0) {
 213 |     |                 revert SynthNotEnabledForCollateral(collateralId);
 214 |     |             }
 215 | *   |             uint256 newCollateralAmount = collateralAmount + synthAmount.toUint();
 216 | *   |             if (newCollateralAmount > maxAmount) {
 217 |     |                 revert MaxCollateralExceeded(
 218 |     |                     collateralId,
 219 |     |                     maxAmount,
 220 |     |                     collateralAmount,
 221 |     |                     synthAmount.toUint()
 222 |     |                 );
 223 |     |             }
 224 | *   |         } else {
 225 | *   |             uint256 synthAmountAbs = MathUtil.abs(synthAmount);
 226 | *   |             if (collateralAmount < synthAmountAbs) {
 227 | *   |                 revert InsufficientCollateral(collateralId, collateralAmount, synthAmountAbs);
 228 |     |             }
 229 |     |         }
 230 |     |     }
 231 |     | 
 232 |     |     function addMarket(Data storage self, uint128 marketId) internal {
 233 |     |         self.activeMarkets.add(marketId.to256());
 234 |     |     }
 235 |     | }
 236 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/GlobalPerpsMarketConfiguration.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   5 |     | import {SafeCastU128} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   6 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   7 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   8 |     | import {MathUtil} from "../utils/MathUtil.sol";
   9 |     | import {IFeeCollector} from "../interfaces/external/IFeeCollector.sol";
  10 |     | import {PerpsMarketFactory} from "./PerpsMarketFactory.sol";
  11 |     | import {PerpsCollateralConfiguration} from "./PerpsCollateralConfiguration.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title This library contains all global perps market configuration data
  15 |     |  */
  16 |     | library GlobalPerpsMarketConfiguration {
  17 |     |     using DecimalMath for uint256;
  18 |     |     using PerpsMarketFactory for PerpsMarketFactory.Data;
  19 |     |     using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;
  20 |     |     using SetUtil for SetUtil.UintSet;
  21 |     |     using SafeCastU128 for uint128;
  22 |     | 
  23 |     |     bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION =
  24 | *   |         keccak256(abi.encode("io.synthetix.perps-market.GlobalPerpsMarketConfiguration"));
  25 |     | 
  26 |     |     struct Data {
  27 |     |         /**
  28 |     |          * @dev fee collector contract
  29 |     |          * @dev portion or all of the order fees are sent to fee collector contract based on quote.
  30 |     |          */
  31 |     |         IFeeCollector feeCollector;
  32 |     |         /**
  33 |     |          * @dev Percentage share of fees for each referrer address
  34 |     |          */
  35 |     |         mapping(address => uint256) referrerShare;
  36 |     |         /**
  37 |     |          * @dev previously maxCollateralAmounts[collateralId] was used in storage slot
  38 |     |          */
  39 |     |         // solhint-disable-next-line var-name-mixedcase
  40 |     |         mapping(uint128 => uint256) __unused_1;
  41 |     |         /**
  42 |     |          * @dev previously synth deduction priority
  43 |     |          */
  44 |     |         // solhint-disable-next-line var-name-mixedcase
  45 |     |         uint128[] __unused_2;
  46 |     |         /**
  47 |     |          * @dev minimum configured keeper reward for the sender who liquidates the account
  48 |     |          */
  49 |     |         uint256 minKeeperRewardUsd;
  50 |     |         /**
  51 |     |          * @dev maximum configured keeper reward for the sender who liquidates the account
  52 |     |          */
  53 |     |         uint256 maxKeeperRewardUsd;
  54 |     |         /**
  55 |     |          * @dev maximum configured number of concurrent positions per account.
  56 |     |          * @notice If set to zero it means no new positions can be opened, but existing positions can be increased or decreased.
  57 |     |          * @notice If set to a larger number (larger than number of markets created) it means is unlimited.
  58 |     |          */
  59 |     |         uint128 maxPositionsPerAccount;
  60 |     |         /**
  61 |     |          * @dev maximum configured number of concurrent collaterals per account.
  62 |     |          * @notice If set to zero it means no new collaterals can be added accounts, but existing collaterals can be increased or decreased.
  63 |     |          * @notice If set to a larger number (larger than number of collaterals enabled) it means is unlimited.
  64 |     |          */
  65 |     |         uint128 maxCollateralsPerAccount;
  66 |     |         /**
  67 |     |          * @dev used together with minKeeperRewardUsd to get the minumum keeper reward for the sender who settles, or liquidates the account
  68 |     |          */
  69 |     |         uint256 minKeeperProfitRatioD18;
  70 |     |         /**
  71 |     |          * @dev used together with maxKeeperRewardUsd to get the maximum keeper reward for the sender who settles, or liquidates the account
  72 |     |          */
  73 |     |         uint256 maxKeeperScalingRatioD18;
  74 |     |         /**
  75 |     |          * @dev set of supported collateral types. By supported we mean collateral types that have a maxCollateralAmount > 0
  76 |     |          */
  77 |     |         SetUtil.UintSet supportedCollateralTypes;
  78 |     |         /**
  79 |     |          * @dev interest rate gradient applied to utilization prior to hitting the gradient breakpoint
  80 |     |          */
  81 |     |         uint128 lowUtilizationInterestRateGradient;
  82 |     |         /**
  83 |     |          * @dev breakpoint at which the interest rate gradient changes from low to high
  84 |     |          */
  85 |     |         uint128 interestRateGradientBreakpoint;
  86 |     |         /**
  87 |     |          * @dev interest rate gradient applied to utilization after hitting the gradient breakpoint
  88 |     |          */
  89 |     |         uint128 highUtilizationInterestRateGradient;
  90 |     |         /**
  91 |     |          * @dev ratio of the collateral liquidation reward. 1e18 is 100%.
  92 |     |          */
  93 |     |         uint128 collateralLiquidateRewardRatioD18;
  94 |     |         /**
  95 |     |          * @dev reward distributor implementation. This is used as a base to be cloned to distribute rewards to the liquidator.
  96 |     |          */
  97 |     |         address rewardDistributorImplementation;
  98 |     |     }
  99 |     | 
 100 | *   |     function load() internal pure returns (Data storage globalMarketConfig) {
 101 | *   |         bytes32 s = _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION;
 102 |     |         assembly {
 103 |     |             globalMarketConfig.slot := s
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 | *   |     function loadInterestRateParameters() internal view returns (uint128, uint128, uint128) {
 108 | *   |         Data storage self = load();
 109 |     |         return (
 110 | *   |             self.lowUtilizationInterestRateGradient,
 111 | *   |             self.interestRateGradientBreakpoint,
 112 | *   |             self.highUtilizationInterestRateGradient
 113 |     |         );
 114 |     |     }
 115 |     | 
 116 | *   |     function minimumKeeperRewardCap(
 117 |     |         Data storage self,
 118 |     |         uint256 costOfExecutionInUsd
 119 | *   |     ) internal view returns (uint256) {
 120 |     |         return
 121 | *   |             MathUtil.max(
 122 | *   |                 costOfExecutionInUsd + self.minKeeperRewardUsd,
 123 | *   |                 costOfExecutionInUsd.mulDecimal(self.minKeeperProfitRatioD18 + DecimalMath.UNIT)
 124 |     |             );
 125 |     |     }
 126 |     | 
 127 | *   |     function maximumKeeperRewardCap(
 128 |     |         Data storage self,
 129 |     |         uint256 availableMarginInUsd
 130 | *   |     ) internal view returns (uint256) {
 131 |     |         // Note: if availableMarginInUsd is zero, it means the account was flagged, so the maximumKeeperRewardCap will just be maxKeeperRewardUsd
 132 | *   |         if (availableMarginInUsd == 0) {
 133 | *   |             return self.maxKeeperRewardUsd;
 134 |     |         }
 135 |     | 
 136 |     |         return
 137 | *   |             MathUtil.min(
 138 | *   |                 availableMarginInUsd.mulDecimal(self.maxKeeperScalingRatioD18),
 139 | *   |                 self.maxKeeperRewardUsd
 140 |     |             );
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev returns the keeper reward based on total keeper rewards from all markets compared against min/max
 145 |     |      */
 146 | *   |     function keeperReward(
 147 |     |         Data storage self,
 148 |     |         uint256 keeperRewards,
 149 |     |         uint256 costOfExecutionInUsd,
 150 |     |         uint256 availableMarginInUsd
 151 | *   |     ) internal view returns (uint256) {
 152 | *   |         uint256 minCap = minimumKeeperRewardCap(self, costOfExecutionInUsd);
 153 | *   |         uint256 maxCap = maximumKeeperRewardCap(self, availableMarginInUsd);
 154 | *   |         return MathUtil.min(MathUtil.max(minCap, keeperRewards + costOfExecutionInUsd), maxCap);
 155 |     |     }
 156 |     | 
 157 | *   |     function collectFees(
 158 |     |         Data storage self,
 159 |     |         uint256 orderFees,
 160 |     |         address referrer,
 161 |     |         PerpsMarketFactory.Data storage factory
 162 | *   |     ) internal returns (uint256 referralFees, uint256 feeCollectorFees) {
 163 | *   |         referralFees = _collectReferrerFees(self, orderFees, referrer, factory);
 164 | *   |         uint256 remainingFees = orderFees - referralFees;
 165 |     | 
 166 | *   |         if (remainingFees == 0 || self.feeCollector == IFeeCollector(address(0))) {
 167 | *   |             return (referralFees, 0);
 168 |     |         }
 169 |     | 
 170 |     |         uint256 feeCollectorQuote = self.feeCollector.quoteFees(
 171 |     |             factory.perpsMarketId,
 172 |     |             remainingFees,
 173 |     |             ERC2771Context._msgSender()
 174 |     |         );
 175 |     | 
 176 |     |         if (feeCollectorQuote == 0) {
 177 |     |             return (referralFees, 0);
 178 |     |         }
 179 |     | 
 180 |     |         if (feeCollectorQuote > remainingFees) {
 181 |     |             feeCollectorQuote = remainingFees;
 182 |     |         }
 183 |     | 
 184 |     |         factory.withdrawMarketUsd(address(self.feeCollector), feeCollectorQuote);
 185 |     | 
 186 |     |         return (referralFees, feeCollectorQuote);
 187 |     |     }
 188 |     | 
 189 | *   |     function calculateCollateralLiquidateReward(
 190 |     |         Data storage self,
 191 |     |         uint256 notionalValue
 192 | *   |     ) internal view returns (uint256) {
 193 | *   |         return notionalValue.mulDecimal(self.collateralLiquidateRewardRatioD18);
 194 |     |     }
 195 |     | 
 196 |     |     function updateSupportedCollaterals(
 197 |     |         Data storage self,
 198 |     |         uint128 collateralId,
 199 |     |         uint256 maxCollateralAmount
 200 |     |     ) internal {
 201 |     |         bool isSupportedCollateral = self.supportedCollateralTypes.contains(collateralId);
 202 |     |         if (maxCollateralAmount > 0 && !isSupportedCollateral) {
 203 |     |             self.supportedCollateralTypes.add(collateralId.to256());
 204 |     |         } else if (maxCollateralAmount == 0 && isSupportedCollateral) {
 205 |     |             self.supportedCollateralTypes.remove(collateralId.to256());
 206 |     |         }
 207 |     |     }
 208 |     | 
 209 | *   |     function _collectReferrerFees(
 210 |     |         Data storage self,
 211 |     |         uint256 fees,
 212 |     |         address referrer,
 213 |     |         PerpsMarketFactory.Data storage factory
 214 | *   |     ) private returns (uint256 referralFeesSent) {
 215 | *   |         if (fees == 0 || referrer == address(0)) {
 216 | *   |             return 0;
 217 |     |         }
 218 |     | 
 219 |     |         uint256 referrerShareRatio = self.referrerShare[referrer];
 220 |     |         if (referrerShareRatio > 0) {
 221 |     |             referralFeesSent = fees.mulDecimal(referrerShareRatio);
 222 |     |             factory.withdrawMarketUsd(referrer, referralFeesSent);
 223 |     |         }
 224 |     |     }
 225 |     | }
 226 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/InterestRate.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {SafeCastU256, SafeCastU128, SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   5 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | import {GlobalPerpsMarket} from "./GlobalPerpsMarket.sol";
   7 |     | import {Position} from "./Position.sol";
   8 |     | import {PerpsPrice} from "./PerpsPrice.sol";
   9 |     | import {GlobalPerpsMarketConfiguration} from "../storage/GlobalPerpsMarketConfiguration.sol";
  10 |     | 
  11 |     | library InterestRate {
  12 |     |     using DecimalMath for uint256;
  13 |     |     using DecimalMath for uint128;
  14 |     |     using SafeCastU128 for uint128;
  15 |     |     using SafeCastU256 for uint256;
  16 |     |     using SafeCastI256 for int256;
  17 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  18 |     |     using Position for Position.Data;
  19 |     |     // 4 year average which includes leap
  20 | *   |     uint256 private constant AVERAGE_SECONDS_PER_YEAR = 31557600;
  21 |     | 
  22 |     |     bytes32 private constant _SLOT_INTEREST_RATE =
  23 | *   |         keccak256(abi.encode("io.synthetix.perps-market.InterestRate"));
  24 |     | 
  25 |     |     struct Data {
  26 |     |         uint256 interestAccrued; // per $1 of OI
  27 |     |         uint128 interestRate;
  28 |     |         uint256 lastTimestamp;
  29 |     |     }
  30 |     | 
  31 | *   |     function load() internal pure returns (Data storage interestRate) {
  32 | *   |         bytes32 s = _SLOT_INTEREST_RATE;
  33 |     |         assembly {
  34 |     |             interestRate.slot := s
  35 |     |         }
  36 |     |     }
  37 |     | 
  38 | *   |     function update(
  39 |     |         PerpsPrice.Tolerance priceTolerance
  40 | *   |     ) internal returns (uint128 newInterestRate, uint256 currentInterestAccrued) {
  41 | *   |         Data storage self = load();
  42 |     | 
  43 | *   |         (
  44 | *   |             uint128 lowUtilizationInterestRateGradient,
  45 | *   |             uint128 interestRateGradientBreakpoint,
  46 | *   |             uint128 highUtilizationInterestRateGradient
  47 | *   |         ) = GlobalPerpsMarketConfiguration.loadInterestRateParameters();
  48 |     | 
  49 |     |         // if no interest parameters are set, interest rate is 0 and the interest accrued stays the same
  50 | *   |         if (
  51 | *   |             lowUtilizationInterestRateGradient == 0 &&
  52 | *   |             interestRateGradientBreakpoint == 0 &&
  53 | *   |             highUtilizationInterestRateGradient == 0
  54 |     |         ) {
  55 | *   |             self.interestRate = 0;
  56 | *   |             return (0, self.interestAccrued);
  57 |     |         }
  58 |     | 
  59 |     |         (uint128 currentUtilizationRate, , ) = GlobalPerpsMarket.load().utilizationRate(
  60 |     |             priceTolerance
  61 |     |         );
  62 |     | 
  63 |     |         self.interestAccrued = calculateNextInterest(self);
  64 |     | 
  65 |     |         self.interestRate = currentInterestRate(
  66 |     |             currentUtilizationRate,
  67 |     |             lowUtilizationInterestRateGradient,
  68 |     |             interestRateGradientBreakpoint,
  69 |     |             highUtilizationInterestRateGradient
  70 |     |         );
  71 |     |         self.lastTimestamp = block.timestamp;
  72 |     | 
  73 |     |         return (self.interestRate, self.interestAccrued);
  74 |     |     }
  75 |     | 
  76 | *   |     function proportionalElapsed(Data storage self) internal view returns (uint128) {
  77 |     |         // even though timestamps here are not D18, divDecimal multiplies by 1e18 to preserve decimals into D18
  78 | *   |         return (block.timestamp - self.lastTimestamp).divDecimal(AVERAGE_SECONDS_PER_YEAR).to128();
  79 |     |     }
  80 |     | 
  81 | *   |     function calculateNextInterest(Data storage self) internal view returns (uint256) {
  82 | *   |         return self.interestAccrued + unrecordedInterest(self);
  83 |     |     }
  84 |     | 
  85 | *   |     function unrecordedInterest(Data storage self) internal view returns (uint256) {
  86 | *   |         return self.interestRate.mulDecimalUint128(proportionalElapsed(self)).to256();
  87 |     |     }
  88 |     | 
  89 |     |     function currentInterestRate(
  90 |     |         uint128 currentUtilizationRate,
  91 |     |         uint128 lowUtilizationInterestRateGradient,
  92 |     |         uint128 interestRateGradientBreakpoint,
  93 |     |         uint128 highUtilizationInterestRateGradient
  94 |     |     ) internal pure returns (uint128 rate) {
  95 |     |         // if utilization rate is below breakpoint, multiply low utilization * # of percentage points of utilizationRate
  96 |     |         // otherwise multiply low utilization until breakpoint, then use high utilization gradient for the rest
  97 |     |         if (currentUtilizationRate < interestRateGradientBreakpoint) {
  98 |     |             rate =
  99 |     |                 lowUtilizationInterestRateGradient.mulDecimalUint128(currentUtilizationRate) *
 100 |     |                 100;
 101 |     |         } else {
 102 |     |             uint128 highUtilizationRate = currentUtilizationRate - interestRateGradientBreakpoint;
 103 |     |             uint128 highUtilizationRateInterest = highUtilizationInterestRateGradient
 104 |     |                 .mulDecimalUint128(highUtilizationRate) * 100;
 105 |     |             uint128 lowUtilizationRateInterest = lowUtilizationInterestRateGradient
 106 |     |                 .mulDecimalUint128(interestRateGradientBreakpoint) * 100;
 107 |     |             rate = highUtilizationRateInterest + lowUtilizationRateInterest;
 108 |     |         }
 109 |     |     }
 110 |     | }
 111 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/KeeperCosts.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  5 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  6 |     | import {INodeModule} from "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
  7 |     | import {PerpsMarketFactory} from "./PerpsMarketFactory.sol";
  8 |     | import {PerpsAccount} from "./PerpsAccount.sol";
  9 |     | import {PerpsMarketConfiguration} from "./PerpsMarketConfiguration.sol";
 10 |     | 
 11 |     | uint128 constant SNX_USD_MARKET_ID = 0;
 12 |     | 
 13 |     | /**
 14 |     |  * @title Keeper txn execution costs for rewards calculation based on gas price
 15 |     |  */
 16 |     | library KeeperCosts {
 17 |     |     using SafeCastI256 for int256;
 18 |     |     using SetUtil for SetUtil.UintSet;
 19 |     |     using PerpsAccount for PerpsAccount.Data;
 20 |     |     using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;
 21 |     | 
 22 | *   |     uint256 private constant KIND_SETTLEMENT = 0;
 23 | *   |     uint256 private constant KIND_FLAG = 1;
 24 | *   |     uint256 private constant KIND_LIQUIDATE = 2;
 25 |     | 
 26 |     |     struct Data {
 27 |     |         bytes32 keeperCostNodeId;
 28 |     |     }
 29 |     | 
 30 | *   |     function load() internal pure returns (Data storage price) {
 31 | *   |         bytes32 s = keccak256(abi.encode("io.synthetix.perps-market.KeeperCosts"));
 32 |     |         assembly {
 33 |     |             price.slot := s
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function update(Data storage self, bytes32 keeperCostNodeId) internal {
 38 |     |         self.keeperCostNodeId = keeperCostNodeId;
 39 |     |     }
 40 |     | 
 41 | *   |     function getSettlementKeeperCosts(Data storage self) internal view returns (uint256 sUSDCost) {
 42 | *   |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
 43 |     | 
 44 | *   |         sUSDCost = _processWithRuntime(self.keeperCostNodeId, factory, 0, KIND_SETTLEMENT);
 45 |     |     }
 46 |     | 
 47 | *   |     function getFlagKeeperCosts(
 48 |     |         Data storage self,
 49 |     |         uint128 accountId
 50 | *   |     ) internal view returns (uint256 sUSDCost) {
 51 | *   |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
 52 |     | 
 53 | *   |         PerpsAccount.Data storage account = PerpsAccount.load(accountId);
 54 | *   |         uint256 numberOfCollateralFeeds = account.activeCollateralTypes.contains(SNX_USD_MARKET_ID)
 55 | *   |             ? account.activeCollateralTypes.length() - 1
 56 | *   |             : account.activeCollateralTypes.length();
 57 | *   |         uint256 numberOfUpdatedFeeds = numberOfCollateralFeeds +
 58 | *   |             account.openPositionMarketIds.length();
 59 |     | 
 60 | *   |         sUSDCost = _processWithRuntime(
 61 | *   |             self.keeperCostNodeId,
 62 | *   |             factory,
 63 | *   |             numberOfUpdatedFeeds,
 64 |     |             KIND_FLAG
 65 |     |         );
 66 |     |     }
 67 |     | 
 68 | *   |     function getLiquidateKeeperCosts(Data storage self) internal view returns (uint256 sUSDCost) {
 69 | *   |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
 70 |     | 
 71 | *   |         sUSDCost = _processWithRuntime(self.keeperCostNodeId, factory, 0, KIND_LIQUIDATE);
 72 |     |     }
 73 |     | 
 74 | *   |     function _processWithRuntime(
 75 |     |         bytes32 keeperCostNodeId,
 76 |     |         PerpsMarketFactory.Data storage factory,
 77 |     |         uint256 numberOfUpdatedFeeds,
 78 |     |         uint256 executionKind
 79 | *   |     ) private view returns (uint256 sUSDCost) {
 80 | *   |         bytes32[] memory runtimeKeys = new bytes32[](4);
 81 | *   |         bytes32[] memory runtimeValues = new bytes32[](4);
 82 | *   |         runtimeKeys[0] = bytes32("numberOfUpdatedFeeds");
 83 | *   |         runtimeKeys[1] = bytes32("executionKind");
 84 | *   |         runtimeValues[0] = bytes32(numberOfUpdatedFeeds);
 85 | *   |         runtimeValues[1] = bytes32(executionKind);
 86 |     | 
 87 | *   |         sUSDCost = INodeModule(factory.oracle)
 88 | *   |             .processWithRuntime(keeperCostNodeId, runtimeKeys, runtimeValues)
 89 |     |             .price
 90 |     |             .toUint();
 91 |     |     }
 92 |     | }
 93 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/Liquidation.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Liquidation data used for determining max liquidation amounts
  6 |     |  */
  7 |     | library Liquidation {
  8 |     |     struct Data {
  9 |     |         /**
 10 |     |          * @dev Accumulated amount for this corresponding timestamp
 11 |     |          */
 12 |     |         uint128 amount;
 13 |     |         /**
 14 |     |          * @dev timestamp of the accumulated liqudation amount
 15 |     |          */
 16 |     |         uint256 timestamp;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/LiquidationAssetManager.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ERC165Helper} from "@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol";
   5 |     | import {ITokenModule} from "@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol";
   6 |     | import {RewardsDistributor} from "@synthetixio/rewards-distributor/src/RewardsDistributor.sol";
   7 |     | import {IRewardDistributor} from "@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol";
   8 |     | import {ISynthetixSystem} from "../interfaces/external/ISynthetixSystem.sol";
   9 |     | import {GlobalPerpsMarketConfiguration} from "./GlobalPerpsMarketConfiguration.sol";
  10 |     | import {PerpsMarketFactory} from "./PerpsMarketFactory.sol";
  11 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
  12 |     | import {AddressUtil} from "@synthetixio/core-contracts/contracts/utils/AddressUtil.sol";
  13 |     | import {AddressError} from "@synthetixio/core-contracts/contracts/errors/AddressError.sol";
  14 |     | import {ParameterError} from "@synthetixio/core-contracts/contracts/errors/ParameterError.sol";
  15 |     | import {IDistributorErrors} from "../interfaces/IDistributorErrors.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title LiquidationAssetManager send liquidity to the reward distributor according to each collateral type
  19 |     |  */
  20 |     | library LiquidationAssetManager {
  21 |     |     using DecimalMath for uint256;
  22 |     | 
  23 |     |     struct Data {
  24 |     |         /**
  25 |     |          * @dev Collateral Id (same as synth id)
  26 |     |          */
  27 |     |         uint128 id;
  28 |     |         /**
  29 |     |          * @dev Distributor address used for reward distribution. If address is 0x0, a new distributor will be created.
  30 |     |          */
  31 |     |         address distributor;
  32 |     |         /**
  33 |     |          * @dev Addresses of collateral types delegated to the pool. Used to distribute rewards.
  34 |     |          * @dev Needs to be manually maintained in synch with pool configuration to distribute proportionally to all LPs.
  35 |     |          */
  36 |     |         address[] poolDelegatedCollateralTypes;
  37 |     |     }
  38 |     | 
  39 |     |     function setValidPoolDelegatedCollateralTypes(
  40 |     |         Data storage self,
  41 |     |         address[] calldata poolDelegatedCollateralTypes
  42 |     |     ) internal {
  43 |     |         self.poolDelegatedCollateralTypes = poolDelegatedCollateralTypes;
  44 |     | 
  45 |     |         // Collaterals in a V3 pool can be delegated to a specific market. `collateralTypes` are the pool collateral
  46 |     |         // addresses delegated to this market. They're tracked here so downstream operations post creation can infer
  47 |     |         // pct of `token` to distribute amongst delegated collaterals. For example, during liquidation we calc to total
  48 |     |         // dollar value of delegated collateral and distribute the reward token proportionally to each collateral.
  49 |     |         //
  50 |     |         // There must be at least one pool collateral type available otherwise this reward distribute cannot distribute.
  51 |     |         uint256 collateralTypesLength = self.poolDelegatedCollateralTypes.length;
  52 |     |         if (collateralTypesLength == 0) {
  53 |     |             revert ParameterError.InvalidParameter("collateralTypes", "must not be empty");
  54 |     |         }
  55 |     |         for (uint256 i = 0; i < collateralTypesLength; ) {
  56 |     |             if (self.poolDelegatedCollateralTypes[i] == address(0)) {
  57 |     |                 revert AddressError.ZeroAddress();
  58 |     |             }
  59 |     |             unchecked {
  60 |     |                 ++i;
  61 |     |             }
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     function setValidDistributor(
  66 |     |         Data storage self,
  67 |     |         address distributor,
  68 |     |         address tokenAddress
  69 |     |     ) internal {
  70 |     |         if (distributor == address(0)) {
  71 |     |             revert AddressError.ZeroAddress();
  72 |     |         }
  73 |     | 
  74 |     |         if (
  75 |     |             !ERC165Helper.safeSupportsInterface(distributor, type(IRewardDistributor).interfaceId)
  76 |     |         ) {
  77 |     |             revert IDistributorErrors.InvalidDistributorContract(distributor);
  78 |     |         }
  79 |     | 
  80 |     |         if (RewardsDistributor(distributor).token() != tokenAddress) {
  81 |     |             revert IDistributorErrors.InvalidDistributor(self.id, tokenAddress);
  82 |     |         }
  83 |     | 
  84 |     |         self.distributor = distributor;
  85 |     |     }
  86 |     | 
  87 | *   |     function distributeCollateral(
  88 |     |         Data storage self,
  89 |     |         address tokenAddress,
  90 |     |         uint256 amount
  91 | *   |     ) internal {
  92 | *   |         RewardsDistributor distributor = RewardsDistributor(self.distributor);
  93 |     | 
  94 | *   |         if (distributor.token() != tokenAddress) {
  95 |     |             revert IDistributorErrors.InvalidDistributor(self.id, tokenAddress);
  96 |     |         }
  97 |     | 
  98 | *   |         uint256 poolCollateralTypesLength = self.poolDelegatedCollateralTypes.length;
  99 | *   |         ISynthetixSystem synthetix = PerpsMarketFactory.load().synthetix;
 100 |     | 
 101 |     |         // Transfer collateral to the distributor
 102 | *   |         ITokenModule(tokenAddress).transfer(self.distributor, amount);
 103 |     | 
 104 |     |         // Calculate the USD value of each collateral delegated to pool.
 105 | *   |         uint128 poolId = distributor.poolId();
 106 | *   |         uint256[] memory collateralValuesUsd = new uint256[](poolCollateralTypesLength);
 107 | *   |         uint256 totalCollateralValueUsd;
 108 | *   |         for (uint256 i = 0; i < poolCollateralTypesLength; ) {
 109 | *   |             (, uint256 collateralValueUsd) = synthetix.getVaultCollateral(
 110 | *   |                 poolId,
 111 | *   |                 self.poolDelegatedCollateralTypes[i]
 112 |     |             );
 113 | *   |             totalCollateralValueUsd += collateralValueUsd;
 114 | *   |             collateralValuesUsd[i] = collateralValueUsd;
 115 |     | 
 116 |     |             unchecked {
 117 | *   |                 ++i;
 118 |     |             }
 119 |     |         }
 120 |     | 
 121 |     |         // Infer the ratio of size to distribute, proportional to value of each delegated collateral.
 122 | *   |         uint256 remainingAmountToDistribute = amount;
 123 | *   |         for (uint256 j = 0; j < poolCollateralTypesLength; ) {
 124 |     |             // Ensure total amounts fully distributed, the last collateral receives the remainder.
 125 | *   |             if (j == poolCollateralTypesLength - 1) {
 126 | *   |                 distributor.distributeRewards(
 127 | *   |                     poolId,
 128 | *   |                     self.poolDelegatedCollateralTypes[j],
 129 | *   |                     remainingAmountToDistribute,
 130 | *   |                     uint64(block.timestamp), // solhint-disable-line numcast/safe-cast
 131 |     |                     0
 132 |     |                 );
 133 |     |             } else {
 134 |     |                 uint256 amountToDistribute = amount.mulDecimal(
 135 |     |                     collateralValuesUsd[j].divDecimal(totalCollateralValueUsd)
 136 |     |                 );
 137 |     |                 remainingAmountToDistribute -= amountToDistribute;
 138 |     |                 distributor.distributeRewards(
 139 |     |                     poolId,
 140 |     |                     self.poolDelegatedCollateralTypes[j],
 141 |     |                     amountToDistribute,
 142 |     |                     uint64(block.timestamp), // solhint-disable-line numcast/safe-cast
 143 |     |                     0
 144 |     |                 );
 145 |     |             }
 146 |     | 
 147 |     |             unchecked {
 148 | *   |                 ++j;
 149 |     |             }
 150 |     |         }
 151 |     |     }
 152 |     | }
 153 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/MarketUpdate.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title MarketUpdateData
  6 |     |  */
  7 |     | library MarketUpdate {
  8 |     |     // this data struct returns the data required to emit a MarketUpdated event
  9 |     |     struct Data {
 10 |     |         uint128 marketId;
 11 |     |         uint128 interestRate;
 12 |     |         int256 skew;
 13 |     |         uint256 size;
 14 |     |         int256 currentFundingRate;
 15 |     |         int256 currentFundingVelocity;
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/OrderFee.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Orders Fee data
  6 |     |  */
  7 |     | library OrderFee {
  8 |     |     struct Data {
  9 |     |         /**
 10 |     |          * @dev Maker fee. Applied when order (or partial order) is reducing skew.
 11 |     |          */
 12 |     |         uint256 makerFee;
 13 |     |         /**
 14 |     |          * @dev Taker fee. Applied when order (or partial order) is increasing skew.
 15 |     |          */
 16 |     |         uint256 takerFee;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsAccount.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   5 |     | import {Price} from "@synthetixio/spot-market/contracts/storage/Price.sol";
   6 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   7 |     | import {SafeCastI256, SafeCastU256, SafeCastU128} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   8 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   9 |     | import {ISpotMarketSystem} from "../interfaces/external/ISpotMarketSystem.sol";
  10 |     | import {Position} from "./Position.sol";
  11 |     | import {PerpsMarket} from "./PerpsMarket.sol";
  12 |     | import {MathUtil} from "../utils/MathUtil.sol";
  13 |     | import {PerpsPrice} from "./PerpsPrice.sol";
  14 |     | import {MarketUpdate} from "./MarketUpdate.sol";
  15 |     | import {PerpsMarketFactory} from "./PerpsMarketFactory.sol";
  16 |     | import {GlobalPerpsMarket} from "./GlobalPerpsMarket.sol";
  17 |     | import {GlobalPerpsMarketConfiguration} from "./GlobalPerpsMarketConfiguration.sol";
  18 |     | import {PerpsMarketConfiguration} from "./PerpsMarketConfiguration.sol";
  19 |     | import {KeeperCosts} from "../storage/KeeperCosts.sol";
  20 |     | import {AsyncOrder} from "../storage/AsyncOrder.sol";
  21 |     | import {PerpsCollateralConfiguration} from "./PerpsCollateralConfiguration.sol";
  22 |     | 
  23 | *   | uint128 constant SNX_USD_MARKET_ID = 0;
  24 |     | 
  25 |     | /**
  26 |     |  * @title Data for a single perps market
  27 |     |  */
  28 |     | library PerpsAccount {
  29 |     |     using SetUtil for SetUtil.UintSet;
  30 |     |     using SafeCastI256 for int256;
  31 |     |     using SafeCastU128 for uint128;
  32 |     |     using SafeCastU256 for uint256;
  33 |     |     using Position for Position.Data;
  34 |     |     using PerpsPrice for PerpsPrice.Data;
  35 |     |     using PerpsMarket for PerpsMarket.Data;
  36 |     |     using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;
  37 |     |     using PerpsMarketFactory for PerpsMarketFactory.Data;
  38 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  39 |     |     using GlobalPerpsMarketConfiguration for GlobalPerpsMarketConfiguration.Data;
  40 |     |     using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;
  41 |     |     using DecimalMath for int256;
  42 |     |     using DecimalMath for uint256;
  43 |     |     using KeeperCosts for KeeperCosts.Data;
  44 |     |     using AsyncOrder for AsyncOrder.Data;
  45 |     | 
  46 |     |     struct Data {
  47 |     |         // @dev synth marketId => amount
  48 |     |         mapping(uint128 => uint256) collateralAmounts;
  49 |     |         // @dev account Id
  50 |     |         uint128 id;
  51 |     |         // @dev set of active collateral types. By active we mean collateral types that have a non-zero amount
  52 |     |         SetUtil.UintSet activeCollateralTypes;
  53 |     |         // @dev set of open position market ids
  54 |     |         SetUtil.UintSet openPositionMarketIds;
  55 |     |         // @dev account's debt accrued from previous positions
  56 |     |         // @dev please use updateAccountDebt() to update this value which will update global debt also
  57 |     |         uint256 debt;
  58 |     |     }
  59 |     | 
  60 |     |     error InsufficientCollateralAvailableForWithdraw(
  61 |     |         int256 withdrawableMarginUsd,
  62 |     |         uint256 requestedMarginUsd
  63 |     |     );
  64 |     | 
  65 |     |     error InsufficientSynthCollateral(
  66 |     |         uint128 collateralId,
  67 |     |         uint256 collateralAmount,
  68 |     |         uint256 withdrawAmount
  69 |     |     );
  70 |     | 
  71 |     |     error InsufficientAccountMargin(uint256 leftover);
  72 |     | 
  73 |     |     error AccountLiquidatable(uint128 accountId);
  74 |     | 
  75 |     |     error AccountMarginLiquidatable(uint128 accountId);
  76 |     | 
  77 |     |     error MaxPositionsPerAccountReached(uint128 maxPositionsPerAccount);
  78 |     | 
  79 |     |     error MaxCollateralsPerAccountReached(uint128 maxCollateralsPerAccount);
  80 |     | 
  81 |     |     error NonexistentDebt(uint128 accountId);
  82 |     | 
  83 | *   |     function load(uint128 id) internal pure returns (Data storage account) {
  84 | *   |         bytes32 s = keccak256(abi.encode("io.synthetix.perps-market.Account", id));
  85 |     | 
  86 |     |         assembly {
  87 |     |             account.slot := s
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |         @notice allows us to update the account id in case it needs to be
  93 |     |      */
  94 | *   |     function create(uint128 id) internal returns (Data storage account) {
  95 | *   |         account = load(id);
  96 | *   |         if (account.id == 0) {
  97 | *   |             account.id = id;
  98 |     |         }
  99 |     |     }
 100 |     | 
 101 | *   |     function validateMaxPositions(uint128 accountId, uint128 marketId) internal view {
 102 | *   |         if (PerpsMarket.accountPosition(marketId, accountId).size == 0) {
 103 | *   |             uint128 maxPositionsPerAccount = GlobalPerpsMarketConfiguration
 104 |     |                 .load()
 105 |     |                 .maxPositionsPerAccount;
 106 | *   |             if (maxPositionsPerAccount <= load(accountId).openPositionMarketIds.length()) {
 107 |     |                 revert MaxPositionsPerAccountReached(maxPositionsPerAccount);
 108 |     |             }
 109 |     |         }
 110 |     |     }
 111 |     | 
 112 | *   |     function validateMaxCollaterals(uint128 accountId, uint128 collateralId) internal view {
 113 | *   |         Data storage account = load(accountId);
 114 |     | 
 115 | *   |         if (account.collateralAmounts[collateralId] == 0) {
 116 | *   |             uint128 maxCollateralsPerAccount = GlobalPerpsMarketConfiguration
 117 |     |                 .load()
 118 |     |                 .maxCollateralsPerAccount;
 119 | *   |             if (maxCollateralsPerAccount <= account.activeCollateralTypes.length()) {
 120 |     |                 revert MaxCollateralsPerAccountReached(maxCollateralsPerAccount);
 121 |     |             }
 122 |     |         }
 123 |     |     }
 124 |     | 
 125 |     |     /**
 126 |     |      * @notice This function charges the account the specified amount
 127 |     |      * @dev This is the only function that changes account debt.
 128 |     |      * @dev Excess credit is added to account's snxUSD amount.
 129 |     |      * @dev if the amount is positive, it is credit, if negative, it is debt.
 130 |     |      */
 131 | *   |     function charge(Data storage self, int256 amount) internal returns (uint256 debt) {
 132 | *   |         uint256 newDebt;
 133 | *   |         if (amount > 0) {
 134 | *   |             int256 leftoverDebt = self.debt.toInt() - amount;
 135 | *   |             if (leftoverDebt > 0) {
 136 |     |                 newDebt = leftoverDebt.toUint();
 137 |     |             } else {
 138 | *   |                 newDebt = 0;
 139 | *   |                 updateCollateralAmount(self, SNX_USD_MARKET_ID, -leftoverDebt);
 140 |     |             }
 141 | *   |         } else {
 142 | *   |             int256 creditAvailable = self.collateralAmounts[SNX_USD_MARKET_ID].toInt();
 143 | *   |             int256 leftoverCredit = creditAvailable + amount;
 144 |     | 
 145 | *   |             if (leftoverCredit > 0) {
 146 | *   |                 updateCollateralAmount(self, SNX_USD_MARKET_ID, amount);
 147 |     |             } else {
 148 | *   |                 updateCollateralAmount(self, SNX_USD_MARKET_ID, -creditAvailable);
 149 | *   |                 newDebt = (self.debt.toInt() - leftoverCredit).toUint();
 150 |     |             }
 151 |     |         }
 152 |     | 
 153 | *   |         return updateAccountDebt(self, newDebt.toInt() - self.debt.toInt());
 154 |     |     }
 155 |     | 
 156 | *   |     function updateAccountDebt(Data storage self, int256 amount) internal returns (uint256 debt) {
 157 | *   |         self.debt = (self.debt.toInt() + amount).toUint();
 158 | *   |         GlobalPerpsMarket.load().updateDebt(amount);
 159 |     | 
 160 | *   |         return self.debt;
 161 |     |     }
 162 |     | 
 163 | *   |     function isEligibleForMarginLiquidation(
 164 |     |         Data storage self,
 165 |     |         PerpsPrice.Tolerance stalenessTolerance
 166 | *   |     ) internal view returns (bool isEligible, int256 availableMargin) {
 167 | *   |         availableMargin = getAvailableMargin(self, stalenessTolerance);
 168 | *   |         isEligible = availableMargin < 0;
 169 |     |     }
 170 |     | 
 171 | *   |     function isEligibleForLiquidation(
 172 |     |         Data storage self,
 173 |     |         PerpsPrice.Tolerance stalenessTolerance
 174 |     |     )
 175 |     |         internal
 176 |     |         view
 177 |     |         returns (
 178 | *   |             bool isEligible,
 179 | *   |             int256 availableMargin,
 180 | *   |             uint256 requiredInitialMargin,
 181 | *   |             uint256 requiredMaintenanceMargin,
 182 | *   |             uint256 liquidationReward
 183 |     |         )
 184 |     |     {
 185 | *   |         availableMargin = getAvailableMargin(self, stalenessTolerance);
 186 |     | 
 187 | *   |         (
 188 |     |             requiredInitialMargin,
 189 |     |             requiredMaintenanceMargin,
 190 |     |             liquidationReward
 191 | *   |         ) = getAccountRequiredMargins(self, stalenessTolerance);
 192 | *   |         isEligible = (requiredMaintenanceMargin + liquidationReward).toInt() > availableMargin;
 193 |     |     }
 194 |     | 
 195 |     |     function flagForLiquidation(
 196 |     |         Data storage self
 197 |     |     ) internal returns (uint256 flagKeeperCost, uint256 seizedMarginValue) {
 198 |     |         SetUtil.UintSet storage liquidatableAccounts = GlobalPerpsMarket
 199 |     |             .load()
 200 |     |             .liquidatableAccounts;
 201 |     | 
 202 |     |         if (!liquidatableAccounts.contains(self.id)) {
 203 | *   |             flagKeeperCost = KeeperCosts.load().getFlagKeeperCosts(self.id);
 204 |     |             liquidatableAccounts.add(self.id);
 205 |     |             seizedMarginValue = transferAllCollateral(self);
 206 |     |             AsyncOrder.load(self.id).reset();
 207 |     | 
 208 |     |             updateAccountDebt(self, -self.debt.toInt());
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 | *   |     function getMarginLiquidationCostAndSeizeMargin(
 213 |     |         Data storage self
 214 | *   |     ) internal returns (uint256 marginLiquidateCost, uint256 seizedMarginValue) {
 215 |     |         // notice: using getFlagKeeperCosts here since the logic is the same, but with no positions.
 216 | *   |         marginLiquidateCost = KeeperCosts.load().getFlagKeeperCosts(self.id);
 217 |     | 
 218 | *   |         seizedMarginValue = transferAllCollateral(self);
 219 |     |     }
 220 |     | 
 221 | *   |     function updateOpenPositions(
 222 |     |         Data storage self,
 223 |     |         uint256 positionMarketId,
 224 |     |         int256 size
 225 |     |     ) internal {
 226 | *   |         if (size == 0 && self.openPositionMarketIds.contains(positionMarketId)) {
 227 | *   |             self.openPositionMarketIds.remove(positionMarketId);
 228 | *   |         } else if (!self.openPositionMarketIds.contains(positionMarketId)) {
 229 | *   |             self.openPositionMarketIds.add(positionMarketId);
 230 |     |         }
 231 |     |     }
 232 |     | 
 233 | *   |     function updateCollateralAmount(
 234 |     |         Data storage self,
 235 |     |         uint128 collateralId,
 236 |     |         int256 amountDelta
 237 | *   |     ) internal returns (uint256 collateralAmount) {
 238 | *   |         collateralAmount = (self.collateralAmounts[collateralId].toInt() + amountDelta).toUint();
 239 | *   |         self.collateralAmounts[collateralId] = collateralAmount;
 240 |     | 
 241 | *   |         bool isActiveCollateral = self.activeCollateralTypes.contains(collateralId);
 242 | *   |         if (collateralAmount > 0 && !isActiveCollateral) {
 243 | *   |             self.activeCollateralTypes.add(collateralId);
 244 | *   |         } else if (collateralAmount == 0 && isActiveCollateral) {
 245 | *   |             self.activeCollateralTypes.remove(collateralId);
 246 |     |         }
 247 |     | 
 248 |     |         // always update global values when account collateral is changed
 249 | *   |         GlobalPerpsMarket.load().updateCollateralAmount(collateralId, amountDelta);
 250 |     |     }
 251 |     | 
 252 | *   |     function payDebt(Data storage self, uint256 amount) internal {
 253 | *   |         if (self.debt == 0) {
 254 | *   |             revert NonexistentDebt(self.id);
 255 |     |         }
 256 |     | 
 257 | *   |         PerpsMarketFactory.Data storage perpsMarketFactory = PerpsMarketFactory.load();
 258 | *   |         perpsMarketFactory.synthetix.depositMarketUsd(
 259 | *   |             perpsMarketFactory.perpsMarketId,
 260 | *   |             ERC2771Context._msgSender(),
 261 | *   |             amount
 262 |     |         );
 263 |     | 
 264 | *   |         if (self.debt < amount) {
 265 |     |             self.debt = 0;
 266 | *   |             updateCollateralAmount(self, SNX_USD_MARKET_ID, (amount - self.debt).toInt());
 267 |     |         } else {
 268 | *   |             self.debt -= amount;
 269 |     |         }
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @notice This function validates you have enough margin to withdraw without being liquidated.
 274 |     |      * @dev    This is done by checking your collateral value against your initial maintenance value.
 275 |     |      * @dev    It also checks the synth collateral for this account is enough to cover the withdrawal amount.
 276 |     |      * @dev    All price checks are not checking strict staleness tolerance.
 277 |     |      */
 278 | *   |     function validateWithdrawableAmount(
 279 |     |         Data storage self,
 280 |     |         uint128 collateralId,
 281 |     |         uint256 amountToWithdraw,
 282 |     |         ISpotMarketSystem spotMarket
 283 |     |     ) internal view {
 284 | *   |         uint256 collateralAmount = self.collateralAmounts[collateralId];
 285 | *   |         if (collateralAmount < amountToWithdraw) {
 286 |     |             revert InsufficientSynthCollateral(collateralId, collateralAmount, amountToWithdraw);
 287 |     |         }
 288 |     | 
 289 | *   |         int256 withdrawableMarginUsd = getWithdrawableMargin(self, PerpsPrice.Tolerance.STRICT);
 290 |     |         // Note: this can only happen if account is liquidatable
 291 | *   |         if (withdrawableMarginUsd < 0) {
 292 |     |             revert AccountLiquidatable(self.id);
 293 |     |         }
 294 |     | 
 295 | *   |         uint256 amountToWithdrawUsd;
 296 | *   |         if (collateralId == SNX_USD_MARKET_ID) {
 297 |     |             amountToWithdrawUsd = amountToWithdraw;
 298 |     |         } else {
 299 | *   |             (amountToWithdrawUsd, ) = PerpsCollateralConfiguration.load(collateralId).valueInUsd(
 300 | *   |                 amountToWithdraw,
 301 | *   |                 spotMarket,
 302 | *   |                 PerpsPrice.Tolerance.STRICT,
 303 | *   |                 false
 304 |     |             );
 305 |     |         }
 306 |     | 
 307 | *   |         if (amountToWithdrawUsd.toInt() > withdrawableMarginUsd) {
 308 |     |             revert InsufficientCollateralAvailableForWithdraw(
 309 |     |                 withdrawableMarginUsd,
 310 |     |                 amountToWithdrawUsd
 311 |     |             );
 312 |     |         }
 313 |     |     }
 314 |     | 
 315 |     |     /**
 316 |     |      * @notice Withdrawable amount depends on if the account has active positions or not
 317 |     |      * @dev    If the account has no active positions and no debt, the withdrawable margin is the total collateral value
 318 |     |      * @dev    If the account has no active positions but has debt, the withdrawable margin is the available margin (which is debt reduced)
 319 |     |      * @dev    If the account has active positions, the withdrawable margin is the available margin - required margin - potential liquidation reward
 320 |     |      */
 321 | *   |     function getWithdrawableMargin(
 322 |     |         Data storage self,
 323 |     |         PerpsPrice.Tolerance stalenessTolerance
 324 | *   |     ) internal view returns (int256 withdrawableMargin) {
 325 | *   |         bool hasActivePositions = hasOpenPositions(self);
 326 |     | 
 327 |     |         // not allowed to withdraw until debt is paid off fully.
 328 | *   |         if (self.debt > 0) return 0;
 329 |     | 
 330 | *   |         if (hasActivePositions) {
 331 |     |             (
 332 |     |                 uint256 requiredInitialMargin,
 333 |     |                 ,
 334 |     |                 uint256 liquidationReward
 335 |     |             ) = getAccountRequiredMargins(self, stalenessTolerance);
 336 |     |             uint256 requiredMargin = requiredInitialMargin + liquidationReward;
 337 |     |             withdrawableMargin =
 338 |     |                 getAvailableMargin(self, stalenessTolerance) -
 339 |     |                 requiredMargin.toInt();
 340 |     |         } else {
 341 | *   |             withdrawableMargin = getTotalCollateralValue(self, stalenessTolerance, false).toInt();
 342 |     |         }
 343 |     |     }
 344 |     | 
 345 | *   |     function getTotalCollateralValue(
 346 |     |         Data storage self,
 347 |     |         PerpsPrice.Tolerance stalenessTolerance,
 348 |     |         bool useDiscountedValue
 349 | *   |     ) internal view returns (uint256) {
 350 | *   |         uint256 totalCollateralValue;
 351 | *   |         ISpotMarketSystem spotMarket = PerpsMarketFactory.load().spotMarket;
 352 | *   |         for (uint256 i = 1; i <= self.activeCollateralTypes.length(); i++) {
 353 | *   |             uint128 collateralId = self.activeCollateralTypes.valueAt(i).to128();
 354 | *   |             uint256 amount = self.collateralAmounts[collateralId];
 355 |     | 
 356 |     |             uint256 amountToAdd;
 357 | *   |             if (collateralId == SNX_USD_MARKET_ID) {
 358 | *   |                 amountToAdd = amount;
 359 |     |             } else {
 360 | *   |                 (amountToAdd, ) = PerpsCollateralConfiguration.load(collateralId).valueInUsd(
 361 | *   |                     amount,
 362 | *   |                     spotMarket,
 363 | *   |                     stalenessTolerance,
 364 | *   |                     useDiscountedValue
 365 |     |                 );
 366 |     |             }
 367 | *   |             totalCollateralValue += amountToAdd;
 368 |     |         }
 369 | *   |         return totalCollateralValue;
 370 |     |     }
 371 |     | 
 372 | *   |     function getAccountPnl(
 373 |     |         Data storage self,
 374 |     |         PerpsPrice.Tolerance stalenessTolerance
 375 | *   |     ) internal view returns (int256 totalPnl) {
 376 | *   |         for (uint256 i = 1; i <= self.openPositionMarketIds.length(); i++) {
 377 | *   |             uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();
 378 | *   |             Position.Data storage position = PerpsMarket.load(marketId).positions[self.id];
 379 | *   |             (int256 pnl, , , , , ) = position.getPnl(
 380 | *   |                 PerpsPrice.getCurrentPrice(marketId, stalenessTolerance)
 381 |     |             );
 382 | *   |             totalPnl += pnl;
 383 |     |         }
 384 |     |     }
 385 |     | 
 386 |     |     /**
 387 |     |      * @notice This function returns the available margin for an account (this is not withdrawable margin which takes into account, margin requirements for open positions)
 388 |     |      * @dev    The available margin is the total collateral value + account pnl - account debt
 389 |     |      * @dev    The total collateral value is always based on the discounted value of the collateral
 390 |     |      */
 391 | *   |     function getAvailableMargin(
 392 |     |         Data storage self,
 393 |     |         PerpsPrice.Tolerance stalenessTolerance
 394 | *   |     ) internal view returns (int256) {
 395 | *   |         int256 totalCollateralValue = getTotalCollateralValue(self, stalenessTolerance, true)
 396 |     |             .toInt();
 397 | *   |         int256 accountPnl = getAccountPnl(self, stalenessTolerance);
 398 |     | 
 399 | *   |         return totalCollateralValue + accountPnl - self.debt.toInt();
 400 |     |     }
 401 |     | 
 402 | *   |     function getTotalNotionalOpenInterest(
 403 |     |         Data storage self
 404 |     |     ) internal view returns (uint256 totalAccountOpenInterest) {
 405 | *   |         for (uint256 i = 1; i <= self.openPositionMarketIds.length(); i++) {
 406 | *   |             uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();
 407 |     | 
 408 |     |             Position.Data storage position = PerpsMarket.load(marketId).positions[self.id];
 409 |     |             uint256 openInterest = position.getNotionalValue(
 410 |     |                 PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)
 411 |     |             );
 412 |     |             totalAccountOpenInterest += openInterest;
 413 |     |         }
 414 |     |     }
 415 |     | 
 416 |     |     /**
 417 |     |      * @notice  This function returns the required margins for an account
 418 |     |      * @dev The initial required margin is used to determine withdrawal amount and when opening positions
 419 |     |      * @dev The maintenance margin is used to determine when to liquidate a position
 420 |     |      */
 421 | *   |     function getAccountRequiredMargins(
 422 |     |         Data storage self,
 423 |     |         PerpsPrice.Tolerance stalenessTolerance
 424 |     |     )
 425 |     |         internal
 426 |     |         view
 427 |     |         returns (
 428 | *   |             uint256 initialMargin,
 429 | *   |             uint256 maintenanceMargin,
 430 | *   |             uint256 possibleLiquidationReward
 431 |     |         )
 432 |     |     {
 433 | *   |         uint256 openPositionMarketIdsLength = self.openPositionMarketIds.length();
 434 | *   |         if (openPositionMarketIdsLength == 0) {
 435 | *   |             return (0, 0, 0);
 436 |     |         }
 437 |     | 
 438 |     |         // use separate accounting for liquidation rewards so we can compare against global min/max liquidation reward values
 439 | *   |         for (uint256 i = 1; i <= openPositionMarketIdsLength; i++) {
 440 | *   |             uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();
 441 | *   |             Position.Data storage position = PerpsMarket.load(marketId).positions[self.id];
 442 | *   |             PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(
 443 | *   |                 marketId
 444 |     |             );
 445 | *   |             (, , uint256 positionInitialMargin, uint256 positionMaintenanceMargin) = marketConfig
 446 |     |                 .calculateRequiredMargins(
 447 | *   |                     position.size,
 448 | *   |                     PerpsPrice.getCurrentPrice(marketId, stalenessTolerance)
 449 |     |                 );
 450 |     | 
 451 | *   |             maintenanceMargin += positionMaintenanceMargin;
 452 | *   |             initialMargin += positionInitialMargin;
 453 |     |         }
 454 |     | 
 455 | *   |         (
 456 | *   |             uint256 accumulatedLiquidationRewards,
 457 | *   |             uint256 maxNumberOfWindows
 458 | *   |         ) = getKeeperRewardsAndCosts(self, 0);
 459 | *   |         possibleLiquidationReward = getPossibleLiquidationReward(
 460 | *   |             self,
 461 | *   |             accumulatedLiquidationRewards,
 462 | *   |             maxNumberOfWindows
 463 |     |         );
 464 |     | 
 465 | *   |         return (initialMargin, maintenanceMargin, possibleLiquidationReward);
 466 |     |     }
 467 |     | 
 468 | *   |     function getKeeperRewardsAndCosts(
 469 |     |         Data storage self,
 470 |     |         uint128 skipMarketId
 471 | *   |     ) internal view returns (uint256 accumulatedLiquidationRewards, uint256 maxNumberOfWindows) {
 472 |     |         // use separate accounting for liquidation rewards so we can compare against global min/max liquidation reward values
 473 | *   |         for (uint256 i = 1; i <= self.openPositionMarketIds.length(); i++) {
 474 | *   |             uint128 marketId = self.openPositionMarketIds.valueAt(i).to128();
 475 | *   |             if (marketId == skipMarketId) continue;
 476 | *   |             Position.Data storage position = PerpsMarket.load(marketId).positions[self.id];
 477 | *   |             PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(
 478 | *   |                 marketId
 479 |     |             );
 480 |     | 
 481 | *   |             uint256 numberOfWindows = marketConfig.numberOfLiquidationWindows(
 482 | *   |                 MathUtil.abs(position.size)
 483 |     |             );
 484 |     | 
 485 | *   |             uint256 flagReward = marketConfig.calculateFlagReward(
 486 | *   |                 MathUtil.abs(position.size).mulDecimal(
 487 | *   |                     PerpsPrice.getCurrentPrice(marketId, PerpsPrice.Tolerance.DEFAULT)
 488 |     |                 )
 489 |     |             );
 490 | *   |             accumulatedLiquidationRewards += flagReward;
 491 |     | 
 492 | *   |             maxNumberOfWindows = MathUtil.max(numberOfWindows, maxNumberOfWindows);
 493 |     |         }
 494 |     |     }
 495 |     | 
 496 | *   |     function getPossibleLiquidationReward(
 497 |     |         Data storage self,
 498 |     |         uint256 accumulatedLiquidationRewards,
 499 |     |         uint256 numOfWindows
 500 | *   |     ) internal view returns (uint256 possibleLiquidationReward) {
 501 | *   |         GlobalPerpsMarketConfiguration.Data storage globalConfig = GlobalPerpsMarketConfiguration
 502 |     |             .load();
 503 | *   |         KeeperCosts.Data storage keeperCosts = KeeperCosts.load();
 504 | *   |         uint256 costOfFlagging = keeperCosts.getFlagKeeperCosts(self.id);
 505 | *   |         uint256 costOfLiquidation = keeperCosts.getLiquidateKeeperCosts();
 506 | *   |         uint256 liquidateAndFlagCost = globalConfig.keeperReward(
 507 | *   |             accumulatedLiquidationRewards,
 508 | *   |             costOfFlagging,
 509 | *   |             getTotalCollateralValue(self, PerpsPrice.Tolerance.DEFAULT, false)
 510 |     |         );
 511 | *   |         uint256 liquidateWindowsCosts = numOfWindows == 0
 512 |     |             ? 0
 513 | *   |             : globalConfig.keeperReward(0, costOfLiquidation, 0) * (numOfWindows - 1);
 514 |     | 
 515 | *   |         possibleLiquidationReward = liquidateAndFlagCost + liquidateWindowsCosts;
 516 |     |     }
 517 |     | 
 518 | *   |     function transferAllCollateral(
 519 |     |         Data storage self
 520 | *   |     ) internal returns (uint256 seizedCollateralValue) {
 521 | *   |         uint256[] memory activeCollateralTypes = self.activeCollateralTypes.values();
 522 |     | 
 523 | *   |         for (uint256 i = 0; i < activeCollateralTypes.length; i++) {
 524 | *   |             uint128 collateralId = activeCollateralTypes[i].to128();
 525 | *   |             if (collateralId == SNX_USD_MARKET_ID) {
 526 |     |                 seizedCollateralValue += self.collateralAmounts[collateralId];
 527 |     |             } else {
 528 |     |                 // transfer to liquidation asset manager
 529 | *   |                 seizedCollateralValue += PerpsMarketFactory.load().transferLiquidatedSynth(
 530 | *   |                     collateralId,
 531 | *   |                     self.collateralAmounts[collateralId]
 532 |     |                 );
 533 |     |             }
 534 |     | 
 535 | *   |             updateCollateralAmount(
 536 | *   |                 self,
 537 | *   |                 collateralId,
 538 | *   |                 -(self.collateralAmounts[collateralId].toInt())
 539 |     |             );
 540 |     |         }
 541 |     |     }
 542 |     | 
 543 |     |     function liquidatePosition(
 544 |     |         Data storage self,
 545 |     |         uint128 marketId,
 546 |     |         uint256 price
 547 |     |     )
 548 |     |         internal
 549 |     |         returns (
 550 |     |             uint128 amountToLiquidate,
 551 |     |             int128 newPositionSize,
 552 |     |             int128 sizeDelta,
 553 |     |             uint128 oldPositionAbsSize,
 554 |     |             MarketUpdate.Data memory marketUpdateData
 555 |     |         )
 556 |     |     {
 557 |     |         PerpsMarket.Data storage perpsMarket = PerpsMarket.load(marketId);
 558 |     |         Position.Data storage position = perpsMarket.positions[self.id];
 559 |     | 
 560 |     |         perpsMarket.recomputeFunding(price);
 561 |     | 
 562 |     |         int128 oldPositionSize = position.size;
 563 |     |         oldPositionAbsSize = MathUtil.abs128(oldPositionSize);
 564 |     |         amountToLiquidate = perpsMarket.maxLiquidatableAmount(oldPositionAbsSize);
 565 |     | 
 566 |     |         if (amountToLiquidate == 0) {
 567 |     |             return (0, oldPositionSize, 0, oldPositionAbsSize, marketUpdateData);
 568 |     |         }
 569 |     | 
 570 |     |         int128 amtToLiquidationInt = amountToLiquidate.toInt();
 571 |     |         // reduce position size
 572 |     |         newPositionSize = oldPositionSize > 0
 573 |     |             ? oldPositionSize - amtToLiquidationInt
 574 |     |             : oldPositionSize + amtToLiquidationInt;
 575 |     | 
 576 |     |         // create new position in case of partial liquidation
 577 |     |         Position.Data memory newPosition;
 578 |     |         if (newPositionSize != 0) {
 579 |     |             newPosition = Position.Data({
 580 |     |                 marketId: marketId,
 581 |     |                 latestInteractionPrice: price.to128(),
 582 |     |                 latestInteractionFunding: perpsMarket.lastFundingValue.to128(),
 583 |     |                 latestInterestAccrued: 0,
 584 |     |                 size: newPositionSize
 585 |     |             });
 586 |     |         }
 587 |     | 
 588 |     |         // update position markets
 589 |     |         updateOpenPositions(self, marketId, newPositionSize);
 590 |     | 
 591 |     |         // update market data
 592 |     |         marketUpdateData = perpsMarket.updatePositionData(self.id, newPosition);
 593 |     |         sizeDelta = newPositionSize - oldPositionSize;
 594 |     | 
 595 |     |         return (
 596 |     |             amountToLiquidate,
 597 |     |             newPositionSize,
 598 |     |             sizeDelta,
 599 |     |             oldPositionAbsSize,
 600 |     |             marketUpdateData
 601 |     |         );
 602 |     |     }
 603 |     | 
 604 | *   |     function hasOpenPositions(Data storage self) internal view returns (bool) {
 605 | *   |         return self.openPositionMarketIds.length() > 0;
 606 |     |     }
 607 |     | }
 608 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsCollateralConfiguration.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   5 |     | import {MathUtil} from "../utils/MathUtil.sol";
   6 |     | import {PerpsPrice} from "./PerpsPrice.sol";
   7 |     | import {Price} from "@synthetixio/spot-market/contracts/storage/Price.sol";
   8 |     | import {ISpotMarketSystem} from "../interfaces/external/ISpotMarketSystem.sol";
   9 |     | import {LiquidationAssetManager} from "./LiquidationAssetManager.sol";
  10 |     | import {SNX_USD_MARKET_ID} from "./PerpsAccount.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @title Configuration of all multi collateral assets used for trader margin
  14 |     |  */
  15 |     | library PerpsCollateralConfiguration {
  16 |     |     using DecimalMath for uint256;
  17 |     | 
  18 |     |     /**
  19 |     |      * @notice Thrown when attempting to access a not registered id
  20 |     |      */
  21 |     |     error InvalidId(uint128 id);
  22 |     | 
  23 |     |     struct Data {
  24 |     |         /**
  25 |     |          * @dev Collateral Id
  26 |     |          */
  27 |     |         uint128 id;
  28 |     |         /**
  29 |     |          * @dev Max amount of collateral that can be used for margin
  30 |     |          */
  31 |     |         uint256 maxAmount;
  32 |     |         /**
  33 |     |          * @dev Collateral value is discounted and capped at this value.  In % units.
  34 |     |          */
  35 |     |         uint256 upperLimitDiscount;
  36 |     |         /**
  37 |     |          * @dev Collateral value is discounted and at minimum, this value.  In % units.
  38 |     |          */
  39 |     |         uint256 lowerLimitDiscount;
  40 |     |         /**
  41 |     |          * @dev This value is used to scale the impactOnSkew of the collateral.
  42 |     |          */
  43 |     |         uint256 discountScalar;
  44 |     |         /**
  45 |     |          * @dev Liquidation Asset Manager data. (see LiquidationAssetManager.Data struct).
  46 |     |          */
  47 |     |         LiquidationAssetManager.Data lam;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev Load the collateral configuration data using collateral/synth id
  52 |     |      */
  53 | *   |     function load(uint128 collateralId) internal pure returns (Data storage collateralConfig) {
  54 | *   |         bytes32 s = keccak256(
  55 | *   |             abi.encode("io.synthetix.perps-market.CollateralConfiguration", collateralId)
  56 |     |         );
  57 |     |         assembly {
  58 |     |             collateralConfig.slot := s
  59 |     |         }
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Load a valid collateral configuration data using collateral/synth id
  64 |     |      */
  65 |     |     function loadValid(uint128 collateralId) internal view returns (Data storage collateralConfig) {
  66 |     |         collateralConfig = load(collateralId);
  67 |     |         if (collateralConfig.id == 0) {
  68 |     |             revert InvalidId(collateralId);
  69 |     |         }
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Load a valid  collateral LiquidationAssetManager configuration data using collateral/synth id
  74 |     |      */
  75 | *   |     function loadValidLam(
  76 |     |         uint128 collateralId
  77 | *   |     ) internal view returns (LiquidationAssetManager.Data storage collateralLAMConfig) {
  78 | *   |         collateralLAMConfig = load(collateralId).lam;
  79 | *   |         if (collateralLAMConfig.id == 0) {
  80 |     |             revert InvalidId(collateralId);
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 | *   |     function validDistributorExists(uint128 collateralId) internal view returns (bool) {
  85 | *   |         return
  86 | *   |             (collateralId == SNX_USD_MARKET_ID) ||
  87 | *   |             (loadValidLam(collateralId).distributor != address(0));
  88 |     |     }
  89 |     | 
  90 |     |     function setMax(Data storage self, uint128 collateralId, uint256 maxAmount) internal {
  91 |     |         if (self.id == 0) self.id = collateralId;
  92 |     |         self.maxAmount = maxAmount;
  93 |     |     }
  94 |     | 
  95 |     |     function setDiscounts(
  96 |     |         Data storage self,
  97 |     |         uint256 upperLimitDiscount,
  98 |     |         uint256 lowerLimitDiscount,
  99 |     |         uint256 discountScalar
 100 |     |     ) internal {
 101 |     |         self.upperLimitDiscount = upperLimitDiscount;
 102 |     |         self.lowerLimitDiscount = lowerLimitDiscount;
 103 |     |         self.discountScalar = discountScalar;
 104 |     |     }
 105 |     | 
 106 |     |     function getConfig(
 107 |     |         Data storage self
 108 |     |     )
 109 |     |         internal
 110 |     |         view
 111 |     |         returns (
 112 |     |             uint256 maxAmount,
 113 |     |             uint256 upperLimitDiscount,
 114 |     |             uint256 lowerLimitDiscount,
 115 |     |             uint256 discountScalar
 116 |     |         )
 117 |     |     {
 118 |     |         maxAmount = self.maxAmount;
 119 |     |         upperLimitDiscount = self.upperLimitDiscount;
 120 |     |         lowerLimitDiscount = self.lowerLimitDiscount;
 121 |     |         discountScalar = self.discountScalar;
 122 |     |     }
 123 |     | 
 124 |     |     function isSupported(Data storage self) internal view returns (bool) {
 125 |     |         return self.maxAmount != 0;
 126 |     |     }
 127 |     | 
 128 | *   |     function valueInUsd(
 129 |     |         Data storage self,
 130 |     |         uint256 amount,
 131 |     |         ISpotMarketSystem spotMarket,
 132 |     |         PerpsPrice.Tolerance stalenessTolerance,
 133 |     |         bool useDiscount
 134 | *   |     ) internal view returns (uint256 collateralValueInUsd, uint256 discount) {
 135 | *   |         uint256 skewScale = spotMarket.getMarketSkewScale(self.id);
 136 |     |         // only discount collateral if skew scale is set on spot market and useDiscount is set to true
 137 | *   |         if (useDiscount && skewScale != 0) {
 138 | *   |             uint256 impactOnSkew = amount.divDecimal(skewScale).mulDecimal(self.discountScalar);
 139 | *   |             discount = (
 140 | *   |                 MathUtil.max(
 141 | *   |                     MathUtil.min(impactOnSkew, self.lowerLimitDiscount),
 142 | *   |                     self.upperLimitDiscount
 143 |     |                 )
 144 |     |             );
 145 |     |         }
 146 |     |         // first get value of collateral in usd
 147 | *   |         uint128 sellTxnType = 2;
 148 | *   |         uint256 collateralPrice = spotMarket.indexPrice(
 149 | *   |             self.id,
 150 |     |             sellTxnType,
 151 | *   |             Price.Tolerance(uint256(stalenessTolerance)) // solhint-disable-line numcast/safe-cast
 152 |     |         );
 153 | *   |         uint256 valueWithoutDiscount = amount.mulDecimal(collateralPrice);
 154 |     | 
 155 |     |         // if discount is 0, this just gets multiplied by 1
 156 | *   |         collateralValueInUsd = valueWithoutDiscount.mulDecimal(DecimalMath.UNIT - discount);
 157 |     |     }
 158 |     | }
 159 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsMarket.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ERC2771Context} from "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
   5 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | import {SafeCastU256, SafeCastI256, SafeCastU128} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   7 |     | import {Position} from "./Position.sol";
   8 |     | import {AsyncOrder} from "./AsyncOrder.sol";
   9 |     | import {PerpsMarketConfiguration} from "./PerpsMarketConfiguration.sol";
  10 |     | import {MarketUpdate} from "./MarketUpdate.sol";
  11 |     | import {MathUtil} from "../utils/MathUtil.sol";
  12 |     | import {PerpsPrice} from "./PerpsPrice.sol";
  13 |     | import {Liquidation} from "./Liquidation.sol";
  14 |     | import {KeeperCosts} from "./KeeperCosts.sol";
  15 |     | import {InterestRate} from "./InterestRate.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title Data for a single perps market
  19 |     |  */
  20 |     | library PerpsMarket {
  21 |     |     using DecimalMath for int256;
  22 |     |     using DecimalMath for uint256;
  23 |     |     using SafeCastI256 for int256;
  24 |     |     using SafeCastU256 for uint256;
  25 |     |     using SafeCastU128 for uint128;
  26 |     |     using Position for Position.Data;
  27 |     |     using PerpsMarketConfiguration for PerpsMarketConfiguration.Data;
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Thrown when attempting to create a market that already exists or invalid id was passed in
  31 |     |      */
  32 |     |     error InvalidMarket(uint128 marketId);
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Thrown when attempting to load a market without a configured price feed
  36 |     |      */
  37 |     |     error PriceFeedNotSet(uint128 marketId);
  38 |     | 
  39 |     |     /**
  40 |     |      * @notice Thrown when attempting to load a market without a configured keeper costs
  41 |     |      */
  42 |     |     error KeeperCostsNotSet();
  43 |     | 
  44 |     |     struct Data {
  45 |     |         string name;
  46 |     |         string symbol;
  47 |     |         uint128 id;
  48 |     |         int256 skew;
  49 |     |         uint256 size;
  50 |     |         int256 lastFundingRate;
  51 |     |         int256 lastFundingValue;
  52 |     |         uint256 lastFundingTime;
  53 |     |         // solhint-disable-next-line var-name-mixedcase
  54 |     |         uint128 __unused_1;
  55 |     |         // solhint-disable-next-line var-name-mixedcase
  56 |     |         uint128 __unused_2;
  57 |     |         // debt calculation
  58 |     |         // accumulates total notional size of the market including accrued funding until the last time any position changed
  59 |     |         int256 debtCorrectionAccumulator;
  60 |     |         // accountId => asyncOrder
  61 |     |         mapping(uint256 => AsyncOrder.Data) asyncOrders;
  62 |     |         // accountId => position
  63 |     |         mapping(uint256 => Position.Data) positions;
  64 |     |         // liquidation amounts
  65 |     |         Liquidation.Data[] liquidationData;
  66 |     |     }
  67 |     | 
  68 | *   |     function load(uint128 marketId) internal pure returns (Data storage market) {
  69 | *   |         bytes32 s = keccak256(abi.encode("io.synthetix.perps-market.PerpsMarket", marketId));
  70 |     | 
  71 |     |         assembly {
  72 |     |             market.slot := s
  73 |     |         }
  74 |     |     }
  75 |     | 
  76 |     |     function createValid(
  77 |     |         uint128 id,
  78 |     |         string memory name,
  79 |     |         string memory symbol
  80 |     |     ) internal returns (Data storage market) {
  81 |     |         if (id == 0 || load(id).id == id) {
  82 |     |             revert InvalidMarket(id);
  83 |     |         }
  84 |     | 
  85 |     |         market = load(id);
  86 |     | 
  87 |     |         market.id = id;
  88 |     |         market.name = name;
  89 |     |         market.symbol = symbol;
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Reverts if the market does not exist with appropriate error. Otherwise, returns the market.
  94 |     |      */
  95 | *   |     function loadValid(uint128 marketId) internal view returns (Data storage market) {
  96 | *   |         market = load(marketId);
  97 | *   |         if (market.id == 0) {
  98 |     |             revert InvalidMarket(marketId);
  99 |     |         }
 100 |     | 
 101 | *   |         if (PerpsPrice.load(marketId).feedId == "") {
 102 |     |             revert PriceFeedNotSet(marketId);
 103 |     |         }
 104 |     | 
 105 | *   |         if (KeeperCosts.load().keeperCostNodeId == "") {
 106 |     |             revert KeeperCostsNotSet();
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Returns the max amount of liquidation that can occur based on the market configuration
 112 |     |      * @notice Based on the configured liquidation window, a trader can only be liquidated for a certain
 113 |     |      *   amount within that window.  If the amount requested is greater than the amount allowed, the
 114 |     |      *   smaller amount is returned.  The function also updates its accounting to ensure the results on
 115 |     |      *   subsequent liquidations work appropriately.
 116 |     |      */
 117 |     |     function maxLiquidatableAmount(
 118 |     |         Data storage self,
 119 |     |         uint128 requestedLiquidationAmount
 120 |     |     ) internal returns (uint128 liquidatableAmount) {
 121 |     |         PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(self.id);
 122 |     | 
 123 |     |         // if endorsedLiquidator is configured and is the sender, allow full liquidation
 124 |     |         if (ERC2771Context._msgSender() == marketConfig.endorsedLiquidator) {
 125 |     |             _updateLiquidationData(self, requestedLiquidationAmount);
 126 |     |             return requestedLiquidationAmount;
 127 |     |         }
 128 |     | 
 129 |     |         (
 130 |     |             uint256 liquidationCapacity,
 131 |     |             uint256 maxLiquidationInWindow,
 132 |     |             uint256 latestLiquidationTimestamp
 133 |     |         ) = currentLiquidationCapacity(self, marketConfig);
 134 |     | 
 135 |     |         // this would only occur if there was a misconfiguration (like skew scale not being set)
 136 |     |         // or the max liquidation window not being set etc.
 137 |     |         // in this case, return the entire requested liquidation amount
 138 |     |         if (maxLiquidationInWindow == 0) {
 139 |     |             return requestedLiquidationAmount;
 140 |     |         }
 141 |     | 
 142 |     |         uint256 maxLiquidationPd = marketConfig.maxLiquidationPd;
 143 |     |         // if liquidation capacity exists, update accordingly
 144 |     |         if (liquidationCapacity != 0) {
 145 |     |             liquidatableAmount = MathUtil.min128(
 146 |     |                 liquidationCapacity.to128(),
 147 |     |                 requestedLiquidationAmount
 148 |     |             );
 149 |     |         } else if (
 150 |     |             maxLiquidationPd != 0 &&
 151 |     |             // only allow this if the last update was not in the current block
 152 |     |             latestLiquidationTimestamp != block.timestamp
 153 |     |         ) {
 154 |     |             /**
 155 |     |                 if capacity is at 0, but the market is under configured liquidation p/d,
 156 |     |                 another block of liquidation becomes allowable.
 157 |     |              */
 158 | *   |             uint256 currentPd = MathUtil.abs(self.skew).divDecimal(marketConfig.skewScale);
 159 |     |             if (currentPd < maxLiquidationPd) {
 160 |     |                 liquidatableAmount = MathUtil.min128(
 161 |     |                     maxLiquidationInWindow.to128(),
 162 |     |                     requestedLiquidationAmount
 163 |     |                 );
 164 |     |             }
 165 |     |         }
 166 |     | 
 167 |     |         if (liquidatableAmount > 0) {
 168 |     |             _updateLiquidationData(self, liquidatableAmount);
 169 |     |         }
 170 |     |     }
 171 |     | 
 172 |     |     function _updateLiquidationData(Data storage self, uint128 liquidationAmount) private {
 173 |     |         uint256 liquidationDataLength = self.liquidationData.length;
 174 |     |         uint256 currentTimestamp = liquidationDataLength == 0
 175 |     |             ? 0
 176 |     |             : self.liquidationData[liquidationDataLength - 1].timestamp;
 177 |     | 
 178 |     |         if (currentTimestamp == block.timestamp) {
 179 |     |             self.liquidationData[liquidationDataLength - 1].amount += liquidationAmount;
 180 |     |         } else {
 181 |     |             self.liquidationData.push(
 182 |     |                 Liquidation.Data({amount: liquidationAmount, timestamp: block.timestamp})
 183 |     |             );
 184 |     |         }
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Returns the current liquidation capacity for the market
 189 |     |      * @notice This function sums up the liquidation amounts in the current liquidation window
 190 |     |      * and returns the capacity left.
 191 |     |      */
 192 | *   |     function currentLiquidationCapacity(
 193 |     |         Data storage self,
 194 |     |         PerpsMarketConfiguration.Data storage marketConfig
 195 |     |     )
 196 |     |         internal
 197 |     |         view
 198 |     |         returns (
 199 | *   |             uint256 capacity,
 200 | *   |             uint256 maxLiquidationInWindow,
 201 | *   |             uint256 latestLiquidationTimestamp
 202 |     |         )
 203 |     |     {
 204 | *   |         maxLiquidationInWindow = marketConfig.maxLiquidationAmountInWindow();
 205 | *   |         uint256 accumulatedLiquidationAmounts;
 206 | *   |         uint256 liquidationDataLength = self.liquidationData.length;
 207 | *   |         if (liquidationDataLength == 0) return (maxLiquidationInWindow, maxLiquidationInWindow, 0);
 208 |     | 
 209 |     |         uint256 currentIndex = liquidationDataLength - 1;
 210 |     |         latestLiquidationTimestamp = self.liquidationData[currentIndex].timestamp;
 211 |     |         uint256 windowStartTimestamp = block.timestamp - marketConfig.maxSecondsInLiquidationWindow;
 212 |     | 
 213 |     |         while (self.liquidationData[currentIndex].timestamp > windowStartTimestamp) {
 214 |     |             accumulatedLiquidationAmounts += self.liquidationData[currentIndex].amount;
 215 |     | 
 216 |     |             if (currentIndex == 0) break;
 217 |     |             currentIndex--;
 218 |     |         }
 219 |     |         int256 availableLiquidationCapacity = maxLiquidationInWindow.toInt() -
 220 |     |             accumulatedLiquidationAmounts.toInt();
 221 |     |         // solhint-disable-next-line numcast/safe-cast
 222 |     |         capacity = MathUtil.max(availableLiquidationCapacity, int256(0)).toUint();
 223 |     |     }
 224 |     | 
 225 |     |     struct PositionDataRuntime {
 226 |     |         uint256 currentPrice;
 227 |     |         int256 sizeDelta;
 228 |     |         int256 fundingDelta;
 229 |     |         int256 notionalDelta;
 230 |     |     }
 231 |     | 
 232 |     |     /**
 233 |     |      * @dev Use this function to update both market/position size/skew.
 234 |     |      * @dev Size and skew should not be updated directly.
 235 |     |      * @dev The return value is used to emit a MarketUpdated event.
 236 |     |      */
 237 | *   |     function updatePositionData(
 238 |     |         Data storage self,
 239 |     |         uint128 accountId,
 240 |     |         Position.Data memory newPosition
 241 | *   |     ) internal returns (MarketUpdate.Data memory) {
 242 | *   |         PositionDataRuntime memory runtime;
 243 | *   |         Position.Data storage oldPosition = self.positions[accountId];
 244 |     | 
 245 | *   |         self.size =
 246 | *   |             (self.size + MathUtil.abs128(newPosition.size)) -
 247 | *   |             MathUtil.abs128(oldPosition.size);
 248 | *   |         self.skew += newPosition.size - oldPosition.size;
 249 |     | 
 250 | *   |         runtime.currentPrice = newPosition.latestInteractionPrice;
 251 | *   |         (, int256 pricePnl, , int256 fundingPnl, , ) = oldPosition.getPnl(runtime.currentPrice);
 252 |     | 
 253 | *   |         runtime.sizeDelta = newPosition.size - oldPosition.size;
 254 | *   |         runtime.fundingDelta = calculateNextFunding(self, runtime.currentPrice).mulDecimal(
 255 |     |             runtime.sizeDelta
 256 |     |         );
 257 | *   |         runtime.notionalDelta = runtime.currentPrice.toInt().mulDecimal(runtime.sizeDelta);
 258 |     | 
 259 |     |         // update the market debt correction accumulator before losing oldPosition details
 260 |     |         // by adding the new updated notional (old - new size) plus old position pnl
 261 | *   |         self.debtCorrectionAccumulator +=
 262 | *   |             runtime.fundingDelta +
 263 |     |             runtime.notionalDelta +
 264 | *   |             pricePnl +
 265 | *   |             fundingPnl;
 266 |     | 
 267 |     |         // update position to new position
 268 |     |         // Note: once market interest rate is updated, the current accrued interest is saved
 269 |     |         // to figure out the unrealized interest for the position
 270 |     |         // when we update market size, use a 1 month price tolerance for calculating minimum credit
 271 | *   |         (uint128 interestRate, uint256 currentInterestAccrued) = InterestRate.update(
 272 | *   |             PerpsPrice.Tolerance.ONE_MONTH
 273 |     |         );
 274 |     |         oldPosition.update(newPosition, currentInterestAccrued);
 275 |     | 
 276 | *   |         return
 277 | *   |             MarketUpdate.Data(
 278 | *   |                 self.id,
 279 |     |                 interestRate,
 280 | *   |                 self.skew,
 281 | *   |                 self.size,
 282 | *   |                 self.lastFundingRate,
 283 | *   |                 currentFundingVelocity(self)
 284 |     |             );
 285 |     |     }
 286 |     | 
 287 | *   |     function recomputeFunding(
 288 |     |         Data storage self,
 289 |     |         uint256 price
 290 | *   |     ) internal returns (int256 fundingRate, int256 fundingValue) {
 291 | *   |         fundingRate = currentFundingRate(self);
 292 | *   |         fundingValue = calculateNextFunding(self, price);
 293 |     | 
 294 | *   |         self.lastFundingRate = fundingRate;
 295 | *   |         self.lastFundingValue = fundingValue;
 296 | *   |         self.lastFundingTime = block.timestamp;
 297 |     | 
 298 |     |         return (fundingRate, fundingValue);
 299 |     |     }
 300 |     | 
 301 | *   |     function calculateNextFunding(
 302 |     |         Data storage self,
 303 |     |         uint256 price
 304 | *   |     ) internal view returns (int256 nextFunding) {
 305 | *   |         nextFunding = self.lastFundingValue + unrecordedFunding(self, price);
 306 |     |     }
 307 |     | 
 308 | *   |     function unrecordedFunding(Data storage self, uint256 price) internal view returns (int256) {
 309 | *   |         int256 fundingRate = currentFundingRate(self);
 310 |     |         // note the minus sign: funding flows in the opposite direction to the skew.
 311 | *   |         int256 avgFundingRate = -(self.lastFundingRate + fundingRate).divDecimal(
 312 | *   |             (DecimalMath.UNIT * 2).toInt()
 313 |     |         );
 314 |     | 
 315 | *   |         return avgFundingRate.mulDecimal(proportionalElapsed(self)).mulDecimal(price.toInt());
 316 |     |     }
 317 |     | 
 318 | *   |     function currentFundingRate(Data storage self) internal view returns (int256) {
 319 |     |         // calculations:
 320 |     |         //  - velocity          = proportional_skew * max_funding_velocity
 321 |     |         //  - proportional_skew = skew / skew_scale
 322 |     |         //
 323 |     |         // example:
 324 |     |         //  - prev_funding_rate     = 0
 325 |     |         //  - prev_velocity         = 0.0025
 326 |     |         //  - time_delta            = 29,000s
 327 |     |         //  - max_funding_velocity  = 0.025 (2.5%)
 328 |     |         //  - skew                  = 300
 329 |     |         //  - skew_scale            = 10,000
 330 |     |         //
 331 |     |         // note: prev_velocity just refs to the velocity _before_ modifying the market skew.
 332 |     |         //
 333 |     |         // funding_rate = prev_funding_rate + prev_velocity * (time_delta / seconds_in_day)
 334 |     |         // funding_rate = 0 + 0.0025 * (29,000 / 86,400)
 335 |     |         //              = 0 + 0.0025 * 0.33564815
 336 |     |         //              = 0.00083912
 337 |     |         return
 338 | *   |             self.lastFundingRate +
 339 | *   |             (currentFundingVelocity(self).mulDecimal(proportionalElapsed(self)));
 340 |     |     }
 341 |     | 
 342 | *   |     function currentFundingVelocity(Data storage self) internal view returns (int256) {
 343 | *   |         PerpsMarketConfiguration.Data storage marketConfig = PerpsMarketConfiguration.load(self.id);
 344 | *   |         int256 maxFundingVelocity = marketConfig.maxFundingVelocity.toInt();
 345 | *   |         int256 skewScale = marketConfig.skewScale.toInt();
 346 |     |         // Avoid a panic due to div by zero. Return 0 immediately.
 347 | *   |         if (skewScale == 0) {
 348 | *   |             return 0;
 349 |     |         }
 350 |     |         // Ensures the proportionalSkew is between -1 and 1.
 351 | *   |         int256 pSkew = self.skew.divDecimal(skewScale);
 352 | *   |         int256 pSkewBounded = MathUtil.min(
 353 | *   |             MathUtil.max(-(DecimalMath.UNIT).toInt(), pSkew),
 354 | *   |             (DecimalMath.UNIT).toInt()
 355 |     |         );
 356 | *   |         return pSkewBounded.mulDecimal(maxFundingVelocity);
 357 |     |     }
 358 |     | 
 359 | *   |     function proportionalElapsed(Data storage self) internal view returns (int256) {
 360 |     |         // even though timestamps here are not D18, divDecimal multiplies by 1e18 to preserve decimals into D18
 361 | *   |         return (block.timestamp - self.lastFundingTime).divDecimal(1 days).toInt();
 362 |     |     }
 363 |     | 
 364 | *   |     function validatePositionSize(
 365 |     |         Data storage self,
 366 |     |         uint256 maxSize,
 367 |     |         uint256 maxValue,
 368 |     |         uint256 price,
 369 |     |         int128 oldSize,
 370 |     |         int128 newSize
 371 | *   |     ) internal view {
 372 |     |         // Allow users to reduce an order no matter the market conditions.
 373 | *   |         bool isReducingInterest = MathUtil.isSameSideReducing(oldSize, newSize);
 374 | *   |         if (!isReducingInterest) {
 375 | *   |             int256 newSkew = self.skew - oldSize + newSize;
 376 |     | 
 377 | *   |             int256 newMarketSize = self.size.toInt() -
 378 | *   |                 MathUtil.abs(oldSize).toInt() +
 379 | *   |                 MathUtil.abs(newSize).toInt();
 380 |     | 
 381 | *   |             int256 newSideSize;
 382 | *   |             if (0 < newSize) {
 383 |     |                 // long case: marketSize + skew
 384 |     |                 //            = (|longSize| + |shortSize|) + (longSize + shortSize)
 385 |     |                 //            = 2 * longSize
 386 | *   |                 newSideSize = newMarketSize + newSkew;
 387 |     |             } else {
 388 |     |                 // short case: marketSize - skew
 389 |     |                 //            = (|longSize| + |shortSize|) - (longSize + shortSize)
 390 |     |                 //            = 2 * -shortSize
 391 | *   |                 newSideSize = newMarketSize - newSkew;
 392 |     |             }
 393 |     | 
 394 |     |             // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
 395 | *   |             if (maxSize < MathUtil.abs(newSideSize / 2)) {
 396 |     |                 revert PerpsMarketConfiguration.MaxOpenInterestReached(
 397 |     |                     self.id,
 398 |     |                     maxSize,
 399 |     |                     newSideSize / 2
 400 |     |                 );
 401 |     |             }
 402 |     | 
 403 |     |             // same check but with value (size * price)
 404 |     |             // note that if maxValue param is set to 0, this validation is skipped
 405 | *   |             if (maxValue > 0 && maxValue < MathUtil.abs(newSideSize / 2).mulDecimal(price)) {
 406 |     |                 revert PerpsMarketConfiguration.MaxUSDOpenInterestReached(
 407 |     |                     self.id,
 408 |     |                     maxValue,
 409 |     |                     newSideSize / 2,
 410 |     |                     price
 411 |     |                 );
 412 |     |             }
 413 |     |         }
 414 |     |     }
 415 |     | 
 416 |     |     /**
 417 |     |      * @dev Returns the market debt incurred by all positions
 418 |     |      * @notice  Market debt is the sum of all position sizes multiplied by the price, and old positions pnl that is included in the debt correction accumulator.
 419 |     |      */
 420 |     |     function marketDebt(Data storage self, uint256 price) internal view returns (int256) {
 421 |     |         // all positions sizes multiplied by the price is equivalent to skew times price
 422 |     |         // and the debt correction accumulator is the  sum of all positions pnl
 423 |     |         int256 positionPnl = self.skew.mulDecimal(price.toInt());
 424 |     |         int256 fundingPnl = self.skew.mulDecimal(calculateNextFunding(self, price));
 425 |     | 
 426 |     |         return positionPnl + fundingPnl - self.debtCorrectionAccumulator;
 427 |     |     }
 428 |     | 
 429 | *   |     function requiredCredit(
 430 |     |         uint128 marketId,
 431 |     |         PerpsPrice.Tolerance tolerance
 432 | *   |     ) internal view returns (uint256) {
 433 |     |         return
 434 | *   |             PerpsMarket
 435 | *   |                 .load(marketId)
 436 |     |                 .size
 437 | *   |                 .mulDecimal(PerpsPrice.getCurrentPrice(marketId, tolerance))
 438 | *   |                 .mulDecimal(PerpsMarketConfiguration.load(marketId).lockedOiRatioD18);
 439 |     |     }
 440 |     | 
 441 | *   |     function accountPosition(
 442 |     |         uint128 marketId,
 443 |     |         uint128 accountId
 444 | *   |     ) internal view returns (Position.Data storage position) {
 445 | *   |         position = load(marketId).positions[accountId];
 446 |     |     }
 447 |     | }
 448 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsMarketConfiguration.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   5 |     | import {SafeCastI128} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   6 |     | import {OrderFee} from "./OrderFee.sol";
   7 |     | import {SettlementStrategy} from "./SettlementStrategy.sol";
   8 |     | import {MathUtil} from "../utils/MathUtil.sol";
   9 |     | 
  10 |     | library PerpsMarketConfiguration {
  11 |     |     using DecimalMath for int256;
  12 |     |     using DecimalMath for uint256;
  13 |     |     using SafeCastI128 for int128;
  14 |     | 
  15 |     |     error MaxOpenInterestReached(uint128 marketId, uint256 maxMarketSize, int256 newSideSize);
  16 |     | 
  17 |     |     error MaxUSDOpenInterestReached(
  18 |     |         uint128 marketId,
  19 |     |         uint256 maxMarketValue,
  20 |     |         int256 newSideSize,
  21 |     |         uint256 price
  22 |     |     );
  23 |     | 
  24 |     |     error InvalidSettlementStrategy(uint256 settlementStrategyId);
  25 |     | 
  26 |     |     struct Data {
  27 |     |         OrderFee.Data orderFees;
  28 |     |         SettlementStrategy.Data[] settlementStrategies;
  29 |     |         uint256 maxMarketSize; // oi cap in units of asset
  30 |     |         uint256 maxFundingVelocity;
  31 |     |         uint256 skewScale;
  32 |     |         /**
  33 |     |          * @dev the initial margin requirements for this market when opening a position
  34 |     |          * @dev this fraction is multiplied by the impact of the position on the skew (open position size / skewScale)
  35 |     |          */
  36 |     |         uint256 initialMarginRatioD18;
  37 |     |         /**
  38 |     |          * @dev This scalar is applied to the calculated initial margin ratio
  39 |     |          * @dev this generally will be lower than initial margin but is used to determine when to liquidate a position
  40 |     |          * @dev this fraction is multiplied by the impact of the position on the skew (position size / skewScale)
  41 |     |          */
  42 |     |         uint256 maintenanceMarginScalarD18;
  43 |     |         /**
  44 |     |          * @dev This ratio is multiplied by the market's notional size (size * currentPrice) to determine how much credit is required for the market to be sufficiently backed by the LPs
  45 |     |          */
  46 |     |         uint256 lockedOiRatioD18;
  47 |     |         /**
  48 |     |          * @dev This multiplier is applied to the max liquidation value when calculating max liquidation for a given market
  49 |     |          */
  50 |     |         uint256 maxLiquidationLimitAccumulationMultiplier;
  51 |     |         /**
  52 |     |          * @dev This configured window is the max liquidation amount that can be accumulated.
  53 |     |          * @dev If you multiply maxLiquidationPerSecond * this window in seconds, you get the max liquidation amount that can be accumulated within this window
  54 |     |          */
  55 |     |         uint256 maxSecondsInLiquidationWindow;
  56 |     |         /**
  57 |     |          * @dev This value is multiplied by the notional value of a position to determine flag reward
  58 |     |          */
  59 |     |         uint256 flagRewardRatioD18;
  60 |     |         /**
  61 |     |          * @dev minimum position value in USD, this is a constant value added to position margin requirements (initial/maintenance)
  62 |     |          */
  63 |     |         uint256 minimumPositionMargin;
  64 |     |         /**
  65 |     |          * @dev This value gets applied to the initial margin ratio to ensure there's a cap on the max leverage regardless of position size
  66 |     |          */
  67 |     |         uint256 minimumInitialMarginRatioD18;
  68 |     |         /**
  69 |     |          * @dev Threshold for allowing further liquidations when max liquidation amount is reached
  70 |     |          */
  71 |     |         uint256 maxLiquidationPd;
  72 |     |         /**
  73 |     |          * @dev if the msg.sender is this endorsed liquidator during an account liquidation, the max liquidation amount doesn't apply.
  74 |     |          * @dev this address is allowed to fully liquidate any account eligible for liquidation.
  75 |     |          */
  76 |     |         address endorsedLiquidator;
  77 |     |         /**
  78 |     |          * @dev OI cap in USD denominated.
  79 |     |          * @dev If set to zero then there is no cap with value, just units
  80 |     |          */
  81 |     |         uint256 maxMarketValue;
  82 |     |     }
  83 |     | 
  84 | *   |     function load(uint128 marketId) internal pure returns (Data storage store) {
  85 | *   |         bytes32 s = keccak256(
  86 | *   |             abi.encode("io.synthetix.perps-market.PerpsMarketConfiguration", marketId)
  87 |     |         );
  88 |     |         assembly {
  89 |     |             store.slot := s
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 | *   |     function maxLiquidationAmountInWindow(Data storage self) internal view returns (uint256) {
  94 | *   |         OrderFee.Data storage orderFeeData = self.orderFees;
  95 |     |         return
  96 | *   |             (orderFeeData.makerFee + orderFeeData.takerFee).mulDecimal(self.skewScale).mulDecimal(
  97 | *   |                 self.maxLiquidationLimitAccumulationMultiplier
  98 | *   |             ) * self.maxSecondsInLiquidationWindow;
  99 |     |     }
 100 |     | 
 101 | *   |     function numberOfLiquidationWindows(
 102 |     |         Data storage self,
 103 |     |         uint256 positionSize
 104 | *   |     ) internal view returns (uint256) {
 105 | *   |         return MathUtil.ceilDivide(positionSize, maxLiquidationAmountInWindow(self));
 106 |     |     }
 107 |     | 
 108 | *   |     function calculateFlagReward(
 109 |     |         Data storage self,
 110 |     |         uint256 notionalValue
 111 | *   |     ) internal view returns (uint256) {
 112 | *   |         return notionalValue.mulDecimal(self.flagRewardRatioD18);
 113 |     |     }
 114 |     | 
 115 | *   |     function calculateRequiredMargins(
 116 |     |         Data storage self,
 117 |     |         int128 size,
 118 |     |         uint256 price
 119 |     |     )
 120 |     |         internal
 121 |     |         view
 122 |     |         returns (
 123 | *   |             uint256 initialMarginRatio,
 124 | *   |             uint256 maintenanceMarginRatio,
 125 | *   |             uint256 initialMargin,
 126 | *   |             uint256 maintenanceMargin
 127 |     |         )
 128 | *   |     {
 129 | *   |         if (size == 0) {
 130 | *   |             return (0, 0, 0, 0);
 131 |     |         }
 132 | *   |         uint256 sizeAbs = MathUtil.abs(size.to256());
 133 | *   |         uint256 impactOnSkew = self.skewScale == 0 ? 0 : sizeAbs.divDecimal(self.skewScale);
 134 |     | 
 135 | *   |         initialMarginRatio =
 136 | *   |             impactOnSkew.mulDecimal(self.initialMarginRatioD18) +
 137 | *   |             self.minimumInitialMarginRatioD18;
 138 | *   |         maintenanceMarginRatio = initialMarginRatio.mulDecimal(self.maintenanceMarginScalarD18);
 139 |     | 
 140 | *   |         uint256 notional = sizeAbs.mulDecimal(price);
 141 |     | 
 142 | *   |         initialMargin = notional.mulDecimal(initialMarginRatio) + self.minimumPositionMargin;
 143 | *   |         maintenanceMargin =
 144 | *   |             notional.mulDecimal(maintenanceMarginRatio) +
 145 | *   |             self.minimumPositionMargin;
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice given a strategy id, returns the entire settlement strategy struct
 150 |     |      */
 151 | *   |     function loadValidSettlementStrategy(
 152 |     |         uint128 marketId,
 153 |     |         uint256 settlementStrategyId
 154 | *   |     ) internal view returns (SettlementStrategy.Data storage strategy) {
 155 | *   |         Data storage self = load(marketId);
 156 | *   |         validateStrategyExists(self, settlementStrategyId);
 157 |     | 
 158 | *   |         strategy = self.settlementStrategies[settlementStrategyId];
 159 | *   |         if (strategy.disabled) {
 160 |     |             revert InvalidSettlementStrategy(settlementStrategyId);
 161 |     |         }
 162 |     |     }
 163 |     | 
 164 | *   |     function validateStrategyExists(
 165 |     |         Data storage config,
 166 |     |         uint256 settlementStrategyId
 167 |     |     ) internal view {
 168 | *   |         if (settlementStrategyId >= config.settlementStrategies.length) {
 169 |     |             revert InvalidSettlementStrategy(settlementStrategyId);
 170 |     |         }
 171 |     |     }
 172 |     | }
 173 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsMarketFactory.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ITokenModule} from "@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol";
   5 |     | import {INodeModule} from "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
   6 |     | import {ISynthetixSystem} from "../interfaces/external/ISynthetixSystem.sol";
   7 |     | import {ISpotMarketSystem} from "../interfaces/external/ISpotMarketSystem.sol";
   8 |     | import {GlobalPerpsMarket} from "../storage/GlobalPerpsMarket.sol";
   9 |     | import {PerpsMarket} from "../storage/PerpsMarket.sol";
  10 |     | import {PerpsPrice} from "../storage/PerpsPrice.sol";
  11 |     | import {PerpsCollateralConfiguration} from "../storage/PerpsCollateralConfiguration.sol";
  12 |     | import {LiquidationAssetManager} from "../storage/LiquidationAssetManager.sol";
  13 |     | import {SafeCastI256, SafeCastU256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  14 |     | import {SetUtil} from "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @title Main factory library that registers perps markets.  Also houses global configuration for all perps markets.
  18 |     |  */
  19 |     | library PerpsMarketFactory {
  20 |     |     using SafeCastI256 for int256;
  21 |     |     using SafeCastU256 for uint256;
  22 |     |     using SetUtil for SetUtil.UintSet;
  23 |     |     using GlobalPerpsMarket for GlobalPerpsMarket.Data;
  24 |     |     using PerpsMarket for PerpsMarket.Data;
  25 |     |     using LiquidationAssetManager for LiquidationAssetManager.Data;
  26 |     |     using PerpsCollateralConfiguration for PerpsCollateralConfiguration.Data;
  27 |     | 
  28 |     |     bytes32 private constant _SLOT_PERPS_MARKET_FACTORY =
  29 | *   |         keccak256(abi.encode("io.synthetix.perps-market.PerpsMarketFactory"));
  30 |     | 
  31 |     |     error PerpsMarketNotInitialized();
  32 |     |     error PerpsMarketAlreadyInitialized();
  33 |     | 
  34 |     |     struct Data {
  35 |     |         /**
  36 |     |          * @dev oracle manager address used for price feeds
  37 |     |          */
  38 |     |         INodeModule oracle;
  39 |     |         ITokenModule usdToken;
  40 |     |         /**
  41 |     |          * @dev Synthetix core v3 proxy address
  42 |     |          */
  43 |     |         ISynthetixSystem synthetix;
  44 |     |         ISpotMarketSystem spotMarket;
  45 |     |         uint128 perpsMarketId;
  46 |     |         string name;
  47 |     |         /**
  48 |     |          * @dev all liquidated account's assets are sent to this address
  49 |     |          */
  50 |     |         address liquidationAssetManager;
  51 |     |     }
  52 |     | 
  53 |     |     function onlyIfInitialized(Data storage self) internal view {
  54 |     |         if (self.perpsMarketId == 0) {
  55 |     |             revert PerpsMarketNotInitialized();
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     function onlyIfNotInitialized(Data storage self) internal view {
  60 |     |         if (self.perpsMarketId != 0) {
  61 |     |             revert PerpsMarketAlreadyInitialized();
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 | *   |     function load() internal pure returns (Data storage perpsMarketFactory) {
  66 | *   |         bytes32 s = _SLOT_PERPS_MARKET_FACTORY;
  67 |     |         assembly {
  68 |     |             perpsMarketFactory.slot := s
  69 |     |         }
  70 |     |     }
  71 |     | 
  72 |     |     function initialize(
  73 |     |         Data storage self,
  74 |     |         ISynthetixSystem synthetix,
  75 |     |         ISpotMarketSystem spotMarket
  76 |     |     ) internal returns (uint128 perpsMarketId) {
  77 |     |         onlyIfNotInitialized(self); // redundant check, but kept here in case this internal is called somewhere else
  78 |     | 
  79 |     |         (address usdTokenAddress, ) = synthetix.getAssociatedSystem("USDToken");
  80 |     |         perpsMarketId = synthetix.registerMarket(address(this));
  81 |     | 
  82 |     |         self.spotMarket = spotMarket;
  83 |     |         self.synthetix = synthetix;
  84 |     |         self.usdToken = ITokenModule(usdTokenAddress);
  85 |     |         self.oracle = synthetix.getOracleManager();
  86 |     |         self.perpsMarketId = perpsMarketId;
  87 |     |     }
  88 |     | 
  89 | *   |     function totalWithdrawableUsd() internal view returns (uint256) {
  90 | *   |         Data storage self = load();
  91 | *   |         return self.synthetix.getWithdrawableMarketUsd(self.perpsMarketId);
  92 |     |     }
  93 |     | 
  94 | *   |     function depositMarketCollateral(
  95 |     |         Data storage self,
  96 |     |         ITokenModule collateral,
  97 |     |         uint256 amount
  98 |     |     ) internal {
  99 | *   |         collateral.approve(address(self.synthetix), amount);
 100 | *   |         self.synthetix.depositMarketCollateral(self.perpsMarketId, address(collateral), amount);
 101 |     |     }
 102 |     | 
 103 |     |     function depositMarketUsd(Data storage self, uint256 amount) internal {
 104 |     |         self.usdToken.approve(address(this), amount);
 105 |     |         self.synthetix.depositMarketUsd(self.perpsMarketId, address(this), amount);
 106 |     |     }
 107 |     | 
 108 | *   |     function withdrawMarketUsd(Data storage self, address to, uint256 amount) internal {
 109 | *   |         self.synthetix.withdrawMarketUsd(self.perpsMarketId, to, amount);
 110 |     |     }
 111 |     | 
 112 | *   |     function transferLiquidatedSynth(
 113 |     |         Data storage self,
 114 |     |         uint128 collateralId,
 115 |     |         uint256 amount
 116 | *   |     ) internal returns (uint256 synthValue) {
 117 | *   |         address synth = self.spotMarket.getSynth(collateralId);
 118 | *   |         self.synthetix.withdrawMarketCollateral(self.perpsMarketId, synth, amount);
 119 |     | 
 120 | *   |         (synthValue, ) = PerpsCollateralConfiguration.load(collateralId).valueInUsd(
 121 | *   |             amount,
 122 | *   |             self.spotMarket,
 123 |     |             PerpsPrice.Tolerance.DEFAULT,
 124 |     |             false
 125 |     |         );
 126 |     | 
 127 | *   |         PerpsCollateralConfiguration.loadValidLam(collateralId).distributeCollateral(synth, amount);
 128 |     |     }
 129 |     | }
 130 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/PerpsPrice.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {INodeModule} from "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
  5 |     | import {NodeOutput} from "@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol";
  6 |     | import {SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  7 |     | import {PerpsMarketFactory} from "./PerpsMarketFactory.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title Price storage for a specific synth market.
 11 |     |  */
 12 |     | library PerpsPrice {
 13 |     |     using SafeCastI256 for int256;
 14 |     | 
 15 |     |     enum Tolerance {
 16 |     |         DEFAULT,
 17 |     |         STRICT,
 18 |     |         ONE_MONTH
 19 |     |     }
 20 |     | 
 21 | *   |     uint256 private constant ONE_MONTH = 2592000;
 22 |     | 
 23 |     |     struct Data {
 24 |     |         /**
 25 |     |          * @dev the price feed id for the market.  this node is processed using the oracle manager which returns the price.
 26 |     |          * @dev the staleness tolerance is provided as a runtime argument to this feed for processing.
 27 |     |          */
 28 |     |         bytes32 feedId;
 29 |     |         /**
 30 |     |          * @dev strict tolerance in seconds, mainly utilized for liquidations.
 31 |     |          */
 32 |     |         uint256 strictStalenessTolerance;
 33 |     |     }
 34 |     | 
 35 | *   |     function load(uint128 marketId) internal pure returns (Data storage price) {
 36 | *   |         bytes32 s = keccak256(abi.encode("io.synthetix.perps-market.Price", marketId));
 37 |     |         assembly {
 38 |     |             price.slot := s
 39 |     |         }
 40 |     |     }
 41 |     | 
 42 | *   |     function getCurrentPrice(
 43 |     |         uint128 marketId,
 44 |     |         Tolerance priceTolerance
 45 | *   |     ) internal view returns (uint256 price) {
 46 | *   |         Data storage self = load(marketId);
 47 | *   |         PerpsMarketFactory.Data storage factory = PerpsMarketFactory.load();
 48 | *   |         NodeOutput.Data memory output;
 49 | *   |         if (priceTolerance == Tolerance.DEFAULT) {
 50 | *   |             output = INodeModule(factory.oracle).process(self.feedId);
 51 | *   |         } else {
 52 | *   |             bytes32[] memory runtimeKeys = new bytes32[](1);
 53 | *   |             bytes32[] memory runtimeValues = new bytes32[](1);
 54 | *   |             runtimeKeys[0] = bytes32("stalenessTolerance");
 55 | *   |             runtimeValues[0] = toleranceBytes(self, priceTolerance);
 56 | *   |             output = INodeModule(factory.oracle).processWithRuntime(
 57 | *   |                 self.feedId,
 58 | *   |                 runtimeKeys,
 59 | *   |                 runtimeValues
 60 |     |             );
 61 |     |         }
 62 |     | 
 63 | *   |         return output.price.toUint();
 64 |     |     }
 65 |     | 
 66 |     |     function update(Data storage self, bytes32 feedId, uint256 strictStalenessTolerance) internal {
 67 |     |         self.feedId = feedId;
 68 |     |         self.strictStalenessTolerance = strictStalenessTolerance;
 69 |     |     }
 70 |     | 
 71 | *   |     function toleranceBytes(
 72 |     |         Data storage self,
 73 |     |         Tolerance tolerance
 74 | *   |     ) internal view returns (bytes32) {
 75 | *   |         if (tolerance == Tolerance.STRICT) {
 76 |     |             return bytes32(self.strictStalenessTolerance);
 77 | *   |         } else if (tolerance == Tolerance.ONE_MONTH) {
 78 | *   |             return bytes32(ONE_MONTH);
 79 |     |         } else {
 80 |     |             return bytes32(0);
 81 |     |         }
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/Position.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {SafeCastU256, SafeCastU128} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   5 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | import {PerpsMarket} from "./PerpsMarket.sol";
   7 |     | import {PerpsMarketConfiguration} from "./PerpsMarketConfiguration.sol";
   8 |     | import {InterestRate} from "./InterestRate.sol";
   9 |     | import {MathUtil} from "../utils/MathUtil.sol";
  10 |     | 
  11 |     | library Position {
  12 |     |     using SafeCastU256 for uint256;
  13 |     |     using SafeCastU128 for uint128;
  14 |     |     using DecimalMath for uint256;
  15 |     |     using DecimalMath for int128;
  16 |     |     using PerpsMarket for PerpsMarket.Data;
  17 |     |     using InterestRate for InterestRate.Data;
  18 |     | 
  19 |     |     struct Data {
  20 |     |         uint128 marketId;
  21 |     |         int128 size;
  22 |     |         uint128 latestInteractionPrice;
  23 |     |         int128 latestInteractionFunding;
  24 |     |         uint256 latestInterestAccrued;
  25 |     |     }
  26 |     | 
  27 |     |     function update(
  28 |     |         Data storage self,
  29 |     |         Data memory newPosition,
  30 |     |         uint256 latestInterestAccrued
  31 |     |     ) internal {
  32 | *   |         self.size = newPosition.size;
  33 | *   |         self.marketId = newPosition.marketId;
  34 | *   |         self.latestInteractionPrice = newPosition.latestInteractionPrice;
  35 | *   |         self.latestInteractionFunding = newPosition.latestInteractionFunding;
  36 | *   |         self.latestInterestAccrued = latestInterestAccrued;
  37 |     |     }
  38 |     | 
  39 | *   |     function getPositionData(
  40 |     |         Data storage self,
  41 |     |         uint256 price
  42 |     |     )
  43 |     |         internal
  44 |     |         view
  45 |     |         returns (
  46 | *   |             uint256 notionalValue,
  47 | *   |             int256 totalPnl,
  48 | *   |             int256 pricePnl,
  49 | *   |             uint256 chargedInterest,
  50 | *   |             int256 accruedFunding,
  51 | *   |             int256 netFundingPerUnit,
  52 | *   |             int256 nextFunding
  53 |     |         )
  54 |     |     {
  55 | *   |         (
  56 |     |             totalPnl,
  57 |     |             pricePnl,
  58 |     |             chargedInterest,
  59 |     |             accruedFunding,
  60 |     |             netFundingPerUnit,
  61 |     |             nextFunding
  62 | *   |         ) = getPnl(self, price);
  63 | *   |         notionalValue = getNotionalValue(self, price);
  64 |     |     }
  65 |     | 
  66 | *   |     function getPnl(
  67 |     |         Data storage self,
  68 |     |         uint256 price
  69 |     |     )
  70 |     |         internal
  71 |     |         view
  72 |     |         returns (
  73 | *   |             int256 totalPnl,
  74 | *   |             int256 pricePnl,
  75 | *   |             uint256 chargedInterest,
  76 | *   |             int256 accruedFunding,
  77 | *   |             int256 netFundingPerUnit,
  78 | *   |             int256 nextFunding
  79 |     |         )
  80 | *   |     {
  81 | *   |         nextFunding = PerpsMarket.load(self.marketId).calculateNextFunding(price);
  82 | *   |         netFundingPerUnit = nextFunding - self.latestInteractionFunding;
  83 | *   |         accruedFunding = self.size.mulDecimal(netFundingPerUnit);
  84 |     | 
  85 | *   |         int256 priceShift = price.toInt() - self.latestInteractionPrice.toInt();
  86 | *   |         pricePnl = self.size.mulDecimal(priceShift);
  87 |     | 
  88 | *   |         chargedInterest = interestAccrued(self, price);
  89 |     | 
  90 | *   |         totalPnl = pricePnl + accruedFunding - chargedInterest.toInt();
  91 |     |     }
  92 |     | 
  93 | *   |     function interestAccrued(
  94 |     |         Data storage self,
  95 |     |         uint256 price
  96 | *   |     ) internal view returns (uint256 chargedInterest) {
  97 | *   |         uint256 nextInterestAccrued = InterestRate.load().calculateNextInterest();
  98 | *   |         uint256 netInterestPerDollar = nextInterestAccrued - self.latestInterestAccrued;
  99 |     | 
 100 |     |         // The interest is charged pro-rata on this position's contribution to the locked OI requirement
 101 | *   |         chargedInterest = getLockedNotionalValue(self, price).mulDecimal(netInterestPerDollar);
 102 |     |     }
 103 |     | 
 104 | *   |     function getLockedNotionalValue(
 105 |     |         Data storage self,
 106 |     |         uint256 price
 107 | *   |     ) internal view returns (uint256) {
 108 |     |         return
 109 | *   |             getNotionalValue(self, price).mulDecimal(
 110 | *   |                 PerpsMarketConfiguration.load(self.marketId).lockedOiRatioD18
 111 |     |             );
 112 |     |     }
 113 |     | 
 114 | *   |     function getNotionalValue(Data storage self, uint256 price) internal view returns (uint256) {
 115 | *   |         return MathUtil.abs(self.size).mulDecimal(price);
 116 |     |     }
 117 |     | }
 118 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/storage/SettlementStrategy.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
  5 |     | import {SafeCastI256, SafeCastU256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  6 |     | import {MathUtil} from "../utils/MathUtil.sol";
  7 |     | 
  8 |     | library SettlementStrategy {
  9 |     |     using DecimalMath for uint256;
 10 |     |     using SafeCastI256 for int256;
 11 |     |     using SafeCastU256 for uint256;
 12 |     | 
 13 |     |     struct Data {
 14 |     |         /**
 15 |     |          * @dev see Type for more details
 16 |     |          */
 17 |     |         Type strategyType;
 18 |     |         /**
 19 |     |          * @dev the delay added to commitment time after which committed orders can be settled.
 20 |     |          * @dev this ensures settlements aren't on the same block as commitment.
 21 |     |          */
 22 |     |         uint256 settlementDelay;
 23 |     |         /**
 24 |     |          * @dev the duration of the settlement window, after which committed orders can be cancelled.
 25 |     |          */
 26 |     |         uint256 settlementWindowDuration;
 27 |     |         /**
 28 |     |          * @dev the address of the contract that returns the benchmark price at a given timestamp
 29 |     |          * @dev generally this contract orchestrates the erc7412 logic to force push an offchain price for a given timestamp.
 30 |     |          */
 31 |     |         address priceVerificationContract; // For Chainlink and Pyth settlement strategies
 32 |     |         /**
 33 |     |          * @dev configurable feed id for chainlink and pyth
 34 |     |          */
 35 |     |         bytes32 feedId;
 36 |     |         /**
 37 |     |          * @dev the amount of reward paid to the keeper for settling the order.
 38 |     |          */
 39 |     |         uint256 settlementReward;
 40 |     |         /**
 41 |     |          * @dev whether the strategy is disabled or not.
 42 |     |          */
 43 |     |         bool disabled;
 44 |     |         /**
 45 |     |          * @dev the delay added to commitment time for determining valid price. Defines the expected price timestamp.
 46 |     |          * @dev this ensures price aren't on the same block as commitment in case of blockchain drift in timestamp or bad actors timestamp manipulation.
 47 |     |          */
 48 |     |         uint256 commitmentPriceDelay;
 49 |     |     }
 50 |     | 
 51 |     |     enum Type {
 52 |     |         PYTH
 53 |     |     }
 54 |     | }
 55 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/utils/Flags.sol
 1 |     | //SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.8.11 <0.9.0;
 3 |     | 
 4 |     | library Flags {
 5 |     |     bytes32 public constant PERPS_SYSTEM = "perpsSystem";
 6 |     |     bytes32 public constant CREATE_MARKET = "createMarket";
 7 |     | }
 8 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/contracts/utils/MathUtil.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {SafeCastI256, SafeCastI128, SafeCastU256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  5 |     | 
  6 |     | library MathUtil {
  7 |     |     using SafeCastI256 for int256;
  8 |     |     using SafeCastI128 for int128;
  9 |     |     using SafeCastU256 for uint256;
 10 |     | 
 11 | *   |     function abs(int256 x) internal pure returns (uint256) {
 12 | *   |         return x >= 0 ? x.toUint() : (-x).toUint();
 13 |     |     }
 14 |     | 
 15 | *   |     function abs128(int128 x) internal pure returns (uint128) {
 16 | *   |         return x >= 0 ? x.toUint() : (-x).toUint();
 17 |     |     }
 18 |     | 
 19 | *   |     function max(int256 x, int256 y) internal pure returns (int256) {
 20 | *   |         return x < y ? y : x;
 21 |     |     }
 22 |     | 
 23 | *   |     function max(uint256 x, uint256 y) internal pure returns (uint256) {
 24 | *   |         return x < y ? y : x;
 25 |     |     }
 26 |     | 
 27 | *   |     function min(int256 x, int256 y) internal pure returns (int256) {
 28 | *   |         return x < y ? x : y;
 29 |     |     }
 30 |     | 
 31 |     |     function min128(int128 x, int128 y) internal pure returns (int128) {
 32 |     |         return x < y ? x : y;
 33 |     |     }
 34 |     | 
 35 | *   |     function min(uint256 x, uint256 y) internal pure returns (uint256) {
 36 | *   |         return x < y ? x : y;
 37 |     |     }
 38 |     | 
 39 |     |     function min128(uint128 x, uint128 y) internal pure returns (uint128) {
 40 |     |         return x < y ? x : y;
 41 |     |     }
 42 |     | 
 43 | *   |     function sameSide(int256 a, int256 b) internal pure returns (bool) {
 44 | *   |         return (a == 0) || (b == 0) || (a > 0) == (b > 0);
 45 |     |     }
 46 |     | 
 47 | *   |     function isSameSideReducing(int128 a, int128 b) internal pure returns (bool) {
 48 | *   |         return sameSide(a, b) && abs(b) < abs(a);
 49 |     |     }
 50 |     | 
 51 | *   |     function ceilDivide(uint256 a, uint256 b) internal pure returns (uint256) {
 52 | *   |         if (b == 0) return 0;
 53 | *   |         return a / b + (a % b == 0 ? 0 : 1);
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
  9 | *   |     address internal constant VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
 10 |     |     // console.sol and console2.sol work by executing a staticcall to this address.
 11 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 12 |     |     // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
 13 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 14 |     |     // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.
 15 |     |     address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256("foundry default caller"))));
 16 |     |     // Address of the test contract, deployed by the DEFAULT_SENDER.
 17 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 18 |     |     // Deterministic deployment address of the Multicall3 contract.
 19 |     |     address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
 20 |     |     // The order of the secp256k1 curve.
 21 |     |     uint256 internal constant SECP256K1_ORDER =
 22 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 23 |     | 
 24 |     |     uint256 internal constant UINT256_MAX =
 25 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 26 |     | 
 27 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 28 |     |     StdStorage internal stdstore;
 29 |     | }
 30 |     | 
 31 |     | abstract contract TestBase is CommonBase {}
 32 |     | 
 33 |     | abstract contract ScriptBase is CommonBase {
 34 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 35 |     | }
 36 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | pragma experimental ABIEncoderV2;
   4 |     | 
   5 |     | import {Vm} from "./Vm.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions {
   8 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
   9 |     | 
  10 |     |     event log(string);
  11 |     |     event logs(bytes);
  12 |     | 
  13 |     |     event log_address(address);
  14 |     |     event log_bytes32(bytes32);
  15 |     |     event log_int(int256);
  16 |     |     event log_uint(uint256);
  17 |     |     event log_bytes(bytes);
  18 |     |     event log_string(string);
  19 |     | 
  20 |     |     event log_named_address(string key, address val);
  21 |     |     event log_named_bytes32(string key, bytes32 val);
  22 |     |     event log_named_decimal_int(string key, int256 val, uint256 decimals);
  23 |     |     event log_named_decimal_uint(string key, uint256 val, uint256 decimals);
  24 |     |     event log_named_int(string key, int256 val);
  25 |     |     event log_named_uint(string key, uint256 val);
  26 |     |     event log_named_bytes(string key, bytes val);
  27 |     |     event log_named_string(string key, string val);
  28 |     | 
  29 |     |     event log_array(uint256[] val);
  30 |     |     event log_array(int256[] val);
  31 |     |     event log_array(address[] val);
  32 |     |     event log_named_array(string key, uint256[] val);
  33 |     |     event log_named_array(string key, int256[] val);
  34 |     |     event log_named_array(string key, address[] val);
  35 |     | 
  36 |     |     bool private _failed;
  37 |     | 
  38 | *   |     function failed() public view returns (bool) {
  39 | *   |         if (_failed) {
  40 |     |             return _failed;
  41 |     |         } else {
  42 | *   |             return vm.load(address(vm), bytes32("failed")) != bytes32(0);
  43 |     |         }
  44 |     |     }
  45 |     | 
  46 |     |     function fail() internal virtual {
  47 |     |         vm.store(address(vm), bytes32("failed"), bytes32(uint256(1)));
  48 |     |         _failed = true;
  49 |     |     }
  50 |     | 
  51 |     |     function assertTrue(bool data) internal pure virtual {
  52 |     |         vm.assertTrue(data);
  53 |     |     }
  54 |     | 
  55 |     |     function assertTrue(bool data, string memory err) internal pure virtual {
  56 |     |         vm.assertTrue(data, err);
  57 |     |     }
  58 |     | 
  59 |     |     function assertFalse(bool data) internal pure virtual {
  60 |     |         vm.assertFalse(data);
  61 |     |     }
  62 |     | 
  63 |     |     function assertFalse(bool data, string memory err) internal pure virtual {
  64 |     |         vm.assertFalse(data, err);
  65 |     |     }
  66 |     | 
  67 |     |     function assertEq(bool left, bool right) internal pure virtual {
  68 |     |         vm.assertEq(left, right);
  69 |     |     }
  70 |     | 
  71 |     |     function assertEq(bool left, bool right, string memory err) internal pure virtual {
  72 |     |         vm.assertEq(left, right, err);
  73 |     |     }
  74 |     | 
  75 |     |     function assertEq(uint256 left, uint256 right) internal pure virtual {
  76 |     |         vm.assertEq(left, right);
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {
  80 |     |         vm.assertEq(left, right, err);
  81 |     |     }
  82 |     | 
  83 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
  84 |     |         vm.assertEqDecimal(left, right, decimals);
  85 |     |     }
  86 |     | 
  87 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
  88 |     |         vm.assertEqDecimal(left, right, decimals, err);
  89 |     |     }
  90 |     | 
  91 |     |     function assertEq(int256 left, int256 right) internal pure virtual {
  92 |     |         vm.assertEq(left, right);
  93 |     |     }
  94 |     | 
  95 |     |     function assertEq(int256 left, int256 right, string memory err) internal pure virtual {
  96 |     |         vm.assertEq(left, right, err);
  97 |     |     }
  98 |     | 
  99 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 100 |     |         vm.assertEqDecimal(left, right, decimals);
 101 |     |     }
 102 |     | 
 103 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 104 |     |         vm.assertEqDecimal(left, right, decimals, err);
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address left, address right) internal pure virtual {
 108 |     |         vm.assertEq(left, right);
 109 |     |     }
 110 |     | 
 111 |     |     function assertEq(address left, address right, string memory err) internal pure virtual {
 112 |     |         vm.assertEq(left, right, err);
 113 |     |     }
 114 |     | 
 115 |     |     function assertEq(bytes32 left, bytes32 right) internal pure virtual {
 116 |     |         vm.assertEq(left, right);
 117 |     |     }
 118 |     | 
 119 |     |     function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 120 |     |         vm.assertEq(left, right, err);
 121 |     |     }
 122 |     | 
 123 |     |     function assertEq32(bytes32 left, bytes32 right) internal pure virtual {
 124 |     |         assertEq(left, right);
 125 |     |     }
 126 |     | 
 127 |     |     function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 128 |     |         assertEq(left, right, err);
 129 |     |     }
 130 |     | 
 131 |     |     function assertEq(string memory left, string memory right) internal pure virtual {
 132 |     |         vm.assertEq(left, right);
 133 |     |     }
 134 |     | 
 135 |     |     function assertEq(string memory left, string memory right, string memory err) internal pure virtual {
 136 |     |         vm.assertEq(left, right, err);
 137 |     |     }
 138 |     | 
 139 |     |     function assertEq(bytes memory left, bytes memory right) internal pure virtual {
 140 |     |         vm.assertEq(left, right);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 144 |     |         vm.assertEq(left, right, err);
 145 |     |     }
 146 |     | 
 147 |     |     function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {
 148 |     |         vm.assertEq(left, right);
 149 |     |     }
 150 |     | 
 151 |     |     function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 152 |     |         vm.assertEq(left, right, err);
 153 |     |     }
 154 |     | 
 155 |     |     function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 156 |     |         vm.assertEq(left, right);
 157 |     |     }
 158 |     | 
 159 |     |     function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 160 |     |         vm.assertEq(left, right, err);
 161 |     |     }
 162 |     | 
 163 |     |     function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {
 164 |     |         vm.assertEq(left, right);
 165 |     |     }
 166 |     | 
 167 |     |     function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 168 |     |         vm.assertEq(left, right, err);
 169 |     |     }
 170 |     | 
 171 |     |     function assertEq(address[] memory left, address[] memory right) internal pure virtual {
 172 |     |         vm.assertEq(left, right);
 173 |     |     }
 174 |     | 
 175 |     |     function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 176 |     |         vm.assertEq(left, right, err);
 177 |     |     }
 178 |     | 
 179 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 180 |     |         vm.assertEq(left, right);
 181 |     |     }
 182 |     | 
 183 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 184 |     |         vm.assertEq(left, right, err);
 185 |     |     }
 186 |     | 
 187 |     |     function assertEq(string[] memory left, string[] memory right) internal pure virtual {
 188 |     |         vm.assertEq(left, right);
 189 |     |     }
 190 |     | 
 191 |     |     function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 192 |     |         vm.assertEq(left, right, err);
 193 |     |     }
 194 |     | 
 195 |     |     function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 196 |     |         vm.assertEq(left, right);
 197 |     |     }
 198 |     | 
 199 |     |     function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 200 |     |         vm.assertEq(left, right, err);
 201 |     |     }
 202 |     | 
 203 |     |     // Legacy helper
 204 |     |     function assertEqUint(uint256 left, uint256 right) internal pure virtual {
 205 |     |         assertEq(left, right);
 206 |     |     }
 207 |     | 
 208 |     |     function assertNotEq(bool left, bool right) internal pure virtual {
 209 |     |         vm.assertNotEq(left, right);
 210 |     |     }
 211 |     | 
 212 |     |     function assertNotEq(bool left, bool right, string memory err) internal pure virtual {
 213 |     |         vm.assertNotEq(left, right, err);
 214 |     |     }
 215 |     | 
 216 |     |     function assertNotEq(uint256 left, uint256 right) internal pure virtual {
 217 |     |         vm.assertNotEq(left, right);
 218 |     |     }
 219 |     | 
 220 |     |     function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {
 221 |     |         vm.assertNotEq(left, right, err);
 222 |     |     }
 223 |     | 
 224 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 225 |     |         vm.assertNotEqDecimal(left, right, decimals);
 226 |     |     }
 227 |     | 
 228 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)
 229 |     |         internal
 230 |     |         pure
 231 |     |         virtual
 232 |     |     {
 233 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 234 |     |     }
 235 |     | 
 236 |     |     function assertNotEq(int256 left, int256 right) internal pure virtual {
 237 |     |         vm.assertNotEq(left, right);
 238 |     |     }
 239 |     | 
 240 |     |     function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {
 241 |     |         vm.assertNotEq(left, right, err);
 242 |     |     }
 243 |     | 
 244 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 245 |     |         vm.assertNotEqDecimal(left, right, decimals);
 246 |     |     }
 247 |     | 
 248 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 249 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 250 |     |     }
 251 |     | 
 252 |     |     function assertNotEq(address left, address right) internal pure virtual {
 253 |     |         vm.assertNotEq(left, right);
 254 |     |     }
 255 |     | 
 256 |     |     function assertNotEq(address left, address right, string memory err) internal pure virtual {
 257 |     |         vm.assertNotEq(left, right, err);
 258 |     |     }
 259 |     | 
 260 |     |     function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {
 261 |     |         vm.assertNotEq(left, right);
 262 |     |     }
 263 |     | 
 264 |     |     function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 265 |     |         vm.assertNotEq(left, right, err);
 266 |     |     }
 267 |     | 
 268 |     |     function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {
 269 |     |         assertNotEq(left, right);
 270 |     |     }
 271 |     | 
 272 |     |     function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 273 |     |         assertNotEq(left, right, err);
 274 |     |     }
 275 |     | 
 276 |     |     function assertNotEq(string memory left, string memory right) internal pure virtual {
 277 |     |         vm.assertNotEq(left, right);
 278 |     |     }
 279 |     | 
 280 |     |     function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {
 281 |     |         vm.assertNotEq(left, right, err);
 282 |     |     }
 283 |     | 
 284 |     |     function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {
 285 |     |         vm.assertNotEq(left, right);
 286 |     |     }
 287 |     | 
 288 |     |     function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 289 |     |         vm.assertNotEq(left, right, err);
 290 |     |     }
 291 |     | 
 292 |     |     function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {
 293 |     |         vm.assertNotEq(left, right);
 294 |     |     }
 295 |     | 
 296 |     |     function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 297 |     |         vm.assertNotEq(left, right, err);
 298 |     |     }
 299 |     | 
 300 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 301 |     |         vm.assertNotEq(left, right);
 302 |     |     }
 303 |     | 
 304 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 305 |     |         vm.assertNotEq(left, right, err);
 306 |     |     }
 307 |     | 
 308 |     |     function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {
 309 |     |         vm.assertNotEq(left, right);
 310 |     |     }
 311 |     | 
 312 |     |     function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 313 |     |         vm.assertNotEq(left, right, err);
 314 |     |     }
 315 |     | 
 316 |     |     function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {
 317 |     |         vm.assertNotEq(left, right);
 318 |     |     }
 319 |     | 
 320 |     |     function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 321 |     |         vm.assertNotEq(left, right, err);
 322 |     |     }
 323 |     | 
 324 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 325 |     |         vm.assertNotEq(left, right);
 326 |     |     }
 327 |     | 
 328 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 329 |     |         vm.assertNotEq(left, right, err);
 330 |     |     }
 331 |     | 
 332 |     |     function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {
 333 |     |         vm.assertNotEq(left, right);
 334 |     |     }
 335 |     | 
 336 |     |     function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 337 |     |         vm.assertNotEq(left, right, err);
 338 |     |     }
 339 |     | 
 340 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 341 |     |         vm.assertNotEq(left, right);
 342 |     |     }
 343 |     | 
 344 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 345 |     |         vm.assertNotEq(left, right, err);
 346 |     |     }
 347 |     | 
 348 |     |     function assertLt(uint256 left, uint256 right) internal pure virtual {
 349 |     |         vm.assertLt(left, right);
 350 |     |     }
 351 |     | 
 352 |     |     function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {
 353 |     |         vm.assertLt(left, right, err);
 354 |     |     }
 355 |     | 
 356 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 357 |     |         vm.assertLtDecimal(left, right, decimals);
 358 |     |     }
 359 |     | 
 360 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 361 |     |         vm.assertLtDecimal(left, right, decimals, err);
 362 |     |     }
 363 |     | 
 364 |     |     function assertLt(int256 left, int256 right) internal pure virtual {
 365 |     |         vm.assertLt(left, right);
 366 |     |     }
 367 |     | 
 368 |     |     function assertLt(int256 left, int256 right, string memory err) internal pure virtual {
 369 |     |         vm.assertLt(left, right, err);
 370 |     |     }
 371 |     | 
 372 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 373 |     |         vm.assertLtDecimal(left, right, decimals);
 374 |     |     }
 375 |     | 
 376 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 377 |     |         vm.assertLtDecimal(left, right, decimals, err);
 378 |     |     }
 379 |     | 
 380 |     |     function assertGt(uint256 left, uint256 right) internal pure virtual {
 381 |     |         vm.assertGt(left, right);
 382 |     |     }
 383 |     | 
 384 |     |     function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {
 385 |     |         vm.assertGt(left, right, err);
 386 |     |     }
 387 |     | 
 388 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 389 |     |         vm.assertGtDecimal(left, right, decimals);
 390 |     |     }
 391 |     | 
 392 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 393 |     |         vm.assertGtDecimal(left, right, decimals, err);
 394 |     |     }
 395 |     | 
 396 |     |     function assertGt(int256 left, int256 right) internal pure virtual {
 397 |     |         vm.assertGt(left, right);
 398 |     |     }
 399 |     | 
 400 |     |     function assertGt(int256 left, int256 right, string memory err) internal pure virtual {
 401 |     |         vm.assertGt(left, right, err);
 402 |     |     }
 403 |     | 
 404 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 405 |     |         vm.assertGtDecimal(left, right, decimals);
 406 |     |     }
 407 |     | 
 408 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 409 |     |         vm.assertGtDecimal(left, right, decimals, err);
 410 |     |     }
 411 |     | 
 412 |     |     function assertLe(uint256 left, uint256 right) internal pure virtual {
 413 |     |         vm.assertLe(left, right);
 414 |     |     }
 415 |     | 
 416 |     |     function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {
 417 |     |         vm.assertLe(left, right, err);
 418 |     |     }
 419 |     | 
 420 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 421 |     |         vm.assertLeDecimal(left, right, decimals);
 422 |     |     }
 423 |     | 
 424 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 425 |     |         vm.assertLeDecimal(left, right, decimals, err);
 426 |     |     }
 427 |     | 
 428 |     |     function assertLe(int256 left, int256 right) internal pure virtual {
 429 |     |         vm.assertLe(left, right);
 430 |     |     }
 431 |     | 
 432 |     |     function assertLe(int256 left, int256 right, string memory err) internal pure virtual {
 433 |     |         vm.assertLe(left, right, err);
 434 |     |     }
 435 |     | 
 436 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 437 |     |         vm.assertLeDecimal(left, right, decimals);
 438 |     |     }
 439 |     | 
 440 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 441 |     |         vm.assertLeDecimal(left, right, decimals, err);
 442 |     |     }
 443 |     | 
 444 |     |     function assertGe(uint256 left, uint256 right) internal pure virtual {
 445 |     |         vm.assertGe(left, right);
 446 |     |     }
 447 |     | 
 448 |     |     function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {
 449 |     |         vm.assertGe(left, right, err);
 450 |     |     }
 451 |     | 
 452 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 453 |     |         vm.assertGeDecimal(left, right, decimals);
 454 |     |     }
 455 |     | 
 456 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 457 |     |         vm.assertGeDecimal(left, right, decimals, err);
 458 |     |     }
 459 |     | 
 460 |     |     function assertGe(int256 left, int256 right) internal pure virtual {
 461 |     |         vm.assertGe(left, right);
 462 |     |     }
 463 |     | 
 464 |     |     function assertGe(int256 left, int256 right, string memory err) internal pure virtual {
 465 |     |         vm.assertGe(left, right, err);
 466 |     |     }
 467 |     | 
 468 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 469 |     |         vm.assertGeDecimal(left, right, decimals);
 470 |     |     }
 471 |     | 
 472 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 473 |     |         vm.assertGeDecimal(left, right, decimals, err);
 474 |     |     }
 475 |     | 
 476 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {
 477 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 478 |     |     }
 479 |     | 
 480 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)
 481 |     |         internal
 482 |     |         pure
 483 |     |         virtual
 484 |     |     {
 485 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 486 |     |     }
 487 |     | 
 488 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)
 489 |     |         internal
 490 |     |         pure
 491 |     |         virtual
 492 |     |     {
 493 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 494 |     |     }
 495 |     | 
 496 |     |     function assertApproxEqAbsDecimal(
 497 |     |         uint256 left,
 498 |     |         uint256 right,
 499 |     |         uint256 maxDelta,
 500 |     |         uint256 decimals,
 501 |     |         string memory err
 502 |     |     ) internal pure virtual {
 503 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 504 |     |     }
 505 |     | 
 506 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {
 507 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 508 |     |     }
 509 |     | 
 510 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {
 511 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 512 |     |     }
 513 |     | 
 514 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)
 515 |     |         internal
 516 |     |         pure
 517 |     |         virtual
 518 |     |     {
 519 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 520 |     |     }
 521 |     | 
 522 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)
 523 |     |         internal
 524 |     |         pure
 525 |     |         virtual
 526 |     |     {
 527 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 528 |     |     }
 529 |     | 
 530 |     |     function assertApproxEqRel(
 531 |     |         uint256 left,
 532 |     |         uint256 right,
 533 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 534 |     |     ) internal pure virtual {
 535 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 536 |     |     }
 537 |     | 
 538 |     |     function assertApproxEqRel(
 539 |     |         uint256 left,
 540 |     |         uint256 right,
 541 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 542 |     |         string memory err
 543 |     |     ) internal pure virtual {
 544 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 545 |     |     }
 546 |     | 
 547 |     |     function assertApproxEqRelDecimal(
 548 |     |         uint256 left,
 549 |     |         uint256 right,
 550 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 551 |     |         uint256 decimals
 552 |     |     ) internal pure virtual {
 553 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 554 |     |     }
 555 |     | 
 556 |     |     function assertApproxEqRelDecimal(
 557 |     |         uint256 left,
 558 |     |         uint256 right,
 559 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 560 |     |         uint256 decimals,
 561 |     |         string memory err
 562 |     |     ) internal pure virtual {
 563 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 564 |     |     }
 565 |     | 
 566 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {
 567 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 568 |     |     }
 569 |     | 
 570 |     |     function assertApproxEqRel(
 571 |     |         int256 left,
 572 |     |         int256 right,
 573 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 574 |     |         string memory err
 575 |     |     ) internal pure virtual {
 576 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 577 |     |     }
 578 |     | 
 579 |     |     function assertApproxEqRelDecimal(
 580 |     |         int256 left,
 581 |     |         int256 right,
 582 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 583 |     |         uint256 decimals
 584 |     |     ) internal pure virtual {
 585 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 586 |     |     }
 587 |     | 
 588 |     |     function assertApproxEqRelDecimal(
 589 |     |         int256 left,
 590 |     |         int256 right,
 591 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 592 |     |         uint256 decimals,
 593 |     |         string memory err
 594 |     |     ) internal pure virtual {
 595 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 596 |     |     }
 597 |     | 
 598 |     |     // Inherited from DSTest, not used but kept for backwards-compatibility
 599 |     |     function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {
 600 |     |         return keccak256(left) == keccak256(right);
 601 |     |     }
 602 |     | 
 603 |     |     function assertEq0(bytes memory left, bytes memory right) internal pure virtual {
 604 |     |         assertEq(left, right);
 605 |     |     }
 606 |     | 
 607 |     |     function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 608 |     |         assertEq(left, right, err);
 609 |     |     }
 610 |     | 
 611 |     |     function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {
 612 |     |         assertNotEq(left, right);
 613 |     |     }
 614 |     | 
 615 |     |     function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 616 |     |         assertNotEq(left, right, err);
 617 |     |     }
 618 |     | 
 619 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {
 620 |     |         assertEqCall(target, callDataA, target, callDataB, true);
 621 |     |     }
 622 |     | 
 623 |     |     function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)
 624 |     |         internal
 625 |     |         virtual
 626 |     |     {
 627 |     |         assertEqCall(targetA, callDataA, targetB, callDataB, true);
 628 |     |     }
 629 |     | 
 630 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)
 631 |     |         internal
 632 |     |         virtual
 633 |     |     {
 634 |     |         assertEqCall(target, callDataA, target, callDataB, strictRevertData);
 635 |     |     }
 636 |     | 
 637 |     |     function assertEqCall(
 638 |     |         address targetA,
 639 |     |         bytes memory callDataA,
 640 |     |         address targetB,
 641 |     |         bytes memory callDataB,
 642 |     |         bool strictRevertData
 643 |     |     ) internal virtual {
 644 |     |         (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);
 645 |     |         (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);
 646 |     | 
 647 |     |         if (successA && successB) {
 648 |     |             assertEq(returnDataA, returnDataB, "Call return data does not match");
 649 |     |         }
 650 |     | 
 651 |     |         if (!successA && !successB && strictRevertData) {
 652 |     |             assertEq(returnDataA, returnDataB, "Call revert data does not match");
 653 |     |         }
 654 |     | 
 655 |     |         if (!successA && successB) {
 656 |     |             emit log("Error: Calls were not equal");
 657 |     |             emit log_named_bytes("  Left call revert data", returnDataA);
 658 |     |             emit log_named_bytes(" Right call return data", returnDataB);
 659 |     |             revert("assertion failed");
 660 |     |         }
 661 |     | 
 662 |     |         if (successA && !successB) {
 663 |     |             emit log("Error: Calls were not equal");
 664 |     |             emit log_named_bytes("  Left call return data", returnDataA);
 665 |     |             emit log_named_bytes(" Right call revert data", returnDataB);
 666 |     |             revert("assertion failed");
 667 |     |         }
 668 |     |     }
 669 |     | }
 670 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
   8 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
   9 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  10 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  11 |     |  * alias used in this contract, which can be found as the first argument to the
  12 |     |  * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.
  13 |     |  *
  14 |     |  * There are two main ways to use this contract:
  15 |     |  *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or
  16 |     |  *      `setChain(string memory chainAlias, Chain memory chain)`
  17 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  18 |     |  *
  19 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  20 |     |  * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  21 |     |  * `defaultRpcUrls`.
  22 |     |  *
  23 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  24 |     |  *
  25 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  26 |     |  * we want to retrieve the RPC URL for `mainnet`:
  27 |     |  *   - If you have specified data with `setChain`, it will return that.
  28 |     |  *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it
  29 |     |  *     is valid (e.g. a URL is specified, or an environment variable is given and exists).
  30 |     |  *   - If neither of the above conditions is met, the default data is returned.
  31 |     |  *
  32 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.
  33 |     |  */
  34 |     | abstract contract StdChains {
  35 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  36 |     | 
  37 |     |     bool private stdChainsInitialized;
  38 |     | 
  39 |     |     struct ChainData {
  40 |     |         string name;
  41 |     |         uint256 chainId;
  42 |     |         string rpcUrl;
  43 |     |     }
  44 |     | 
  45 |     |     struct Chain {
  46 |     |         // The chain name.
  47 |     |         string name;
  48 |     |         // The chain's Chain ID.
  49 |     |         uint256 chainId;
  50 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  51 |     |         string chainAlias;
  52 |     |         // A default RPC endpoint for this chain.
  53 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  54 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  55 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  56 |     |         string rpcUrl;
  57 |     |     }
  58 |     | 
  59 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  60 |     |     mapping(string => Chain) private chains;
  61 |     |     // Maps from the chain's alias to it's default RPC URL.
  62 |     |     mapping(string => string) private defaultRpcUrls;
  63 |     |     // Maps from a chain ID to it's alias.
  64 |     |     mapping(uint256 => string) private idToAlias;
  65 |     | 
  66 |     |     bool private fallbackToDefaultRpcUrls = true;
  67 |     | 
  68 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  69 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  70 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  71 |     | 
  72 |     |         initializeStdChains();
  73 |     |         chain = chains[chainAlias];
  74 |     |         require(
  75 |     |             chain.chainId != 0,
  76 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  77 |     |         );
  78 |     | 
  79 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  80 |     |     }
  81 |     | 
  82 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  83 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  84 |     |         initializeStdChains();
  85 |     |         string memory chainAlias = idToAlias[chainId];
  86 |     | 
  87 |     |         chain = chains[chainAlias];
  88 |     | 
  89 |     |         require(
  90 |     |             chain.chainId != 0,
  91 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  92 |     |         );
  93 |     | 
  94 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  95 |     |     }
  96 |     | 
  97 |     |     // set chain info, with priority to argument's rpcUrl field.
  98 |     |     function setChain(string memory chainAlias, ChainData memory chain) internal virtual {
  99 |     |         require(
 100 |     |             bytes(chainAlias).length != 0,
 101 |     |             "StdChains setChain(string,ChainData): Chain alias cannot be the empty string."
 102 |     |         );
 103 |     | 
 104 |     |         require(chain.chainId != 0, "StdChains setChain(string,ChainData): Chain ID cannot be 0.");
 105 |     | 
 106 |     |         initializeStdChains();
 107 |     |         string memory foundAlias = idToAlias[chain.chainId];
 108 |     | 
 109 |     |         require(
 110 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 111 |     |             string(
 112 |     |                 abi.encodePacked(
 113 |     |                     "StdChains setChain(string,ChainData): Chain ID ",
 114 |     |                     vm.toString(chain.chainId),
 115 |     |                     " already used by \"",
 116 |     |                     foundAlias,
 117 |     |                     "\"."
 118 |     |                 )
 119 |     |             )
 120 |     |         );
 121 |     | 
 122 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 123 |     |         delete idToAlias[oldChainId];
 124 |     | 
 125 |     |         chains[chainAlias] =
 126 |     |             Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});
 127 |     |         idToAlias[chain.chainId] = chainAlias;
 128 |     |     }
 129 |     | 
 130 |     |     // set chain info, with priority to argument's rpcUrl field.
 131 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
 132 |     |         setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));
 133 |     |     }
 134 |     | 
 135 |     |     function _toUpper(string memory str) private pure returns (string memory) {
 136 |     |         bytes memory strb = bytes(str);
 137 |     |         bytes memory copy = new bytes(strb.length);
 138 |     |         for (uint256 i = 0; i < strb.length; i++) {
 139 |     |             bytes1 b = strb[i];
 140 |     |             if (b >= 0x61 && b <= 0x7A) {
 141 |     |                 copy[i] = bytes1(uint8(b) - 32);
 142 |     |             } else {
 143 |     |                 copy[i] = b;
 144 |     |             }
 145 |     |         }
 146 |     |         return string(copy);
 147 |     |     }
 148 |     | 
 149 |     |     // lookup rpcUrl, in descending order of priority:
 150 |     |     // current -> config (foundry.toml) -> environment variable -> default
 151 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 152 |     |         private
 153 |     |         view
 154 |     |         returns (Chain memory)
 155 |     |     {
 156 |     |         if (bytes(chain.rpcUrl).length == 0) {
 157 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 158 |     |                 chain.rpcUrl = configRpcUrl;
 159 |     |             } catch (bytes memory err) {
 160 |     |                 string memory envName = string(abi.encodePacked(_toUpper(chainAlias), "_RPC_URL"));
 161 |     |                 if (fallbackToDefaultRpcUrls) {
 162 |     |                     chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);
 163 |     |                 } else {
 164 |     |                     chain.rpcUrl = vm.envString(envName);
 165 |     |                 }
 166 |     |                 // Distinguish 'not found' from 'cannot read'
 167 |     |                 // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions
 168 |     |                 bytes memory oldNotFoundError =
 169 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 170 |     |                 bytes memory newNotFoundError = abi.encodeWithSignature(
 171 |     |                     "CheatcodeError(string)", string(abi.encodePacked("invalid rpc url: ", chainAlias))
 172 |     |                 );
 173 |     |                 bytes32 errHash = keccak256(err);
 174 |     |                 if (
 175 |     |                     (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))
 176 |     |                         || bytes(chain.rpcUrl).length == 0
 177 |     |                 ) {
 178 |     |                     /// @solidity memory-safe-assembly
 179 |     |                     assembly {
 180 |     |                         revert(add(32, err), mload(err))
 181 |     |                     }
 182 |     |                 }
 183 |     |             }
 184 |     |         }
 185 |     |         return chain;
 186 |     |     }
 187 |     | 
 188 |     |     function setFallbackToDefaultRpcUrls(bool useDefault) internal {
 189 |     |         fallbackToDefaultRpcUrls = useDefault;
 190 |     |     }
 191 |     | 
 192 |     |     function initializeStdChains() private {
 193 |     |         if (stdChainsInitialized) return;
 194 |     | 
 195 |     |         stdChainsInitialized = true;
 196 |     | 
 197 |     |         // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`
 198 |     |         setChainWithDefaultRpcUrl("anvil", ChainData("Anvil", 31337, "http://127.0.0.1:8545"));
 199 |     |         setChainWithDefaultRpcUrl(
 200 |     |             "mainnet", ChainData("Mainnet", 1, "https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP")
 201 |     |         );
 202 |     |         setChainWithDefaultRpcUrl(
 203 |     |             "sepolia", ChainData("Sepolia", 11155111, "https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 204 |     |         );
 205 |     |         setChainWithDefaultRpcUrl("holesky", ChainData("Holesky", 17000, "https://rpc.holesky.ethpandaops.io"));
 206 |     |         setChainWithDefaultRpcUrl("optimism", ChainData("Optimism", 10, "https://mainnet.optimism.io"));
 207 |     |         setChainWithDefaultRpcUrl(
 208 |     |             "optimism_sepolia", ChainData("Optimism Sepolia", 11155420, "https://sepolia.optimism.io")
 209 |     |         );
 210 |     |         setChainWithDefaultRpcUrl("arbitrum_one", ChainData("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 211 |     |         setChainWithDefaultRpcUrl(
 212 |     |             "arbitrum_one_sepolia", ChainData("Arbitrum One Sepolia", 421614, "https://sepolia-rollup.arbitrum.io/rpc")
 213 |     |         );
 214 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", ChainData("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 215 |     |         setChainWithDefaultRpcUrl("polygon", ChainData("Polygon", 137, "https://polygon-rpc.com"));
 216 |     |         setChainWithDefaultRpcUrl(
 217 |     |             "polygon_amoy", ChainData("Polygon Amoy", 80002, "https://rpc-amoy.polygon.technology")
 218 |     |         );
 219 |     |         setChainWithDefaultRpcUrl("avalanche", ChainData("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 220 |     |         setChainWithDefaultRpcUrl(
 221 |     |             "avalanche_fuji", ChainData("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 222 |     |         );
 223 |     |         setChainWithDefaultRpcUrl(
 224 |     |             "bnb_smart_chain", ChainData("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org")
 225 |     |         );
 226 |     |         setChainWithDefaultRpcUrl(
 227 |     |             "bnb_smart_chain_testnet",
 228 |     |             ChainData("BNB Smart Chain Testnet", 97, "https://rpc.ankr.com/bsc_testnet_chapel")
 229 |     |         );
 230 |     |         setChainWithDefaultRpcUrl("gnosis_chain", ChainData("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 231 |     |         setChainWithDefaultRpcUrl("moonbeam", ChainData("Moonbeam", 1284, "https://rpc.api.moonbeam.network"));
 232 |     |         setChainWithDefaultRpcUrl(
 233 |     |             "moonriver", ChainData("Moonriver", 1285, "https://rpc.api.moonriver.moonbeam.network")
 234 |     |         );
 235 |     |         setChainWithDefaultRpcUrl("moonbase", ChainData("Moonbase", 1287, "https://rpc.testnet.moonbeam.network"));
 236 |     |         setChainWithDefaultRpcUrl("base_sepolia", ChainData("Base Sepolia", 84532, "https://sepolia.base.org"));
 237 |     |         setChainWithDefaultRpcUrl("base", ChainData("Base", 8453, "https://mainnet.base.org"));
 238 |     |         setChainWithDefaultRpcUrl("blast_sepolia", ChainData("Blast Sepolia", 168587773, "https://sepolia.blast.io"));
 239 |     |         setChainWithDefaultRpcUrl("blast", ChainData("Blast", 81457, "https://rpc.blast.io"));
 240 |     |         setChainWithDefaultRpcUrl("fantom_opera", ChainData("Fantom Opera", 250, "https://rpc.ankr.com/fantom/"));
 241 |     |         setChainWithDefaultRpcUrl(
 242 |     |             "fantom_opera_testnet", ChainData("Fantom Opera Testnet", 4002, "https://rpc.ankr.com/fantom_testnet/")
 243 |     |         );
 244 |     |         setChainWithDefaultRpcUrl("fraxtal", ChainData("Fraxtal", 252, "https://rpc.frax.com"));
 245 |     |         setChainWithDefaultRpcUrl("fraxtal_testnet", ChainData("Fraxtal Testnet", 2522, "https://rpc.testnet.frax.com"));
 246 |     |         setChainWithDefaultRpcUrl(
 247 |     |             "berachain_bartio_testnet", ChainData("Berachain bArtio Testnet", 80084, "https://bartio.rpc.berachain.com")
 248 |     |         );
 249 |     |     }
 250 |     | 
 251 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 252 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {
 253 |     |         string memory rpcUrl = chain.rpcUrl;
 254 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 255 |     |         chain.rpcUrl = "";
 256 |     |         setChain(chainAlias, chain);
 257 |     |         chain.rpcUrl = rpcUrl; // restore argument
 258 |     |     }
 259 |     | }
 260 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {console2} from "./console2.sol";
   8 |     | import {Vm} from "./Vm.sol";
   9 |     | 
  10 |     | abstract contract StdCheatsSafe {
  11 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  12 |     | 
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     bool private gasMeteringOff;
  17 |     | 
  18 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  19 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  20 |     |     // and then converted to the one that is used by the user for better UX.
  21 |     | 
  22 |     |     struct RawTx1559 {
  23 |     |         string[] arguments;
  24 |     |         address contractAddress;
  25 |     |         string contractName;
  26 |     |         // json value name = function
  27 |     |         string functionSig;
  28 |     |         bytes32 hash;
  29 |     |         // json value name = tx
  30 |     |         RawTx1559Detail txDetail;
  31 |     |         // json value name = type
  32 |     |         string opcode;
  33 |     |     }
  34 |     | 
  35 |     |     struct RawTx1559Detail {
  36 |     |         AccessList[] accessList;
  37 |     |         bytes data;
  38 |     |         address from;
  39 |     |         bytes gas;
  40 |     |         bytes nonce;
  41 |     |         address to;
  42 |     |         bytes txType;
  43 |     |         bytes value;
  44 |     |     }
  45 |     | 
  46 |     |     struct Tx1559 {
  47 |     |         string[] arguments;
  48 |     |         address contractAddress;
  49 |     |         string contractName;
  50 |     |         string functionSig;
  51 |     |         bytes32 hash;
  52 |     |         Tx1559Detail txDetail;
  53 |     |         string opcode;
  54 |     |     }
  55 |     | 
  56 |     |     struct Tx1559Detail {
  57 |     |         AccessList[] accessList;
  58 |     |         bytes data;
  59 |     |         address from;
  60 |     |         uint256 gas;
  61 |     |         uint256 nonce;
  62 |     |         address to;
  63 |     |         uint256 txType;
  64 |     |         uint256 value;
  65 |     |     }
  66 |     | 
  67 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  68 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  69 |     |     // and then converted to the one that is used by the user for better UX.
  70 |     | 
  71 |     |     struct TxLegacy {
  72 |     |         string[] arguments;
  73 |     |         address contractAddress;
  74 |     |         string contractName;
  75 |     |         string functionSig;
  76 |     |         string hash;
  77 |     |         string opcode;
  78 |     |         TxDetailLegacy transaction;
  79 |     |     }
  80 |     | 
  81 |     |     struct TxDetailLegacy {
  82 |     |         AccessList[] accessList;
  83 |     |         uint256 chainId;
  84 |     |         bytes data;
  85 |     |         address from;
  86 |     |         uint256 gas;
  87 |     |         uint256 gasPrice;
  88 |     |         bytes32 hash;
  89 |     |         uint256 nonce;
  90 |     |         bytes1 opcode;
  91 |     |         bytes32 r;
  92 |     |         bytes32 s;
  93 |     |         uint256 txType;
  94 |     |         address to;
  95 |     |         uint8 v;
  96 |     |         uint256 value;
  97 |     |     }
  98 |     | 
  99 |     |     struct AccessList {
 100 |     |         address accessAddress;
 101 |     |         bytes32[] storageKeys;
 102 |     |     }
 103 |     | 
 104 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 105 |     |     // The Raw structs is what is parsed from the JSON
 106 |     |     // and then converted to the one that is used by the user for better UX.
 107 |     | 
 108 |     |     struct RawReceipt {
 109 |     |         bytes32 blockHash;
 110 |     |         bytes blockNumber;
 111 |     |         address contractAddress;
 112 |     |         bytes cumulativeGasUsed;
 113 |     |         bytes effectiveGasPrice;
 114 |     |         address from;
 115 |     |         bytes gasUsed;
 116 |     |         RawReceiptLog[] logs;
 117 |     |         bytes logsBloom;
 118 |     |         bytes status;
 119 |     |         address to;
 120 |     |         bytes32 transactionHash;
 121 |     |         bytes transactionIndex;
 122 |     |     }
 123 |     | 
 124 |     |     struct Receipt {
 125 |     |         bytes32 blockHash;
 126 |     |         uint256 blockNumber;
 127 |     |         address contractAddress;
 128 |     |         uint256 cumulativeGasUsed;
 129 |     |         uint256 effectiveGasPrice;
 130 |     |         address from;
 131 |     |         uint256 gasUsed;
 132 |     |         ReceiptLog[] logs;
 133 |     |         bytes logsBloom;
 134 |     |         uint256 status;
 135 |     |         address to;
 136 |     |         bytes32 transactionHash;
 137 |     |         uint256 transactionIndex;
 138 |     |     }
 139 |     | 
 140 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 141 |     |     // transactions conform to EIP1559.
 142 |     | 
 143 |     |     struct EIP1559ScriptArtifact {
 144 |     |         string[] libraries;
 145 |     |         string path;
 146 |     |         string[] pending;
 147 |     |         Receipt[] receipts;
 148 |     |         uint256 timestamp;
 149 |     |         Tx1559[] transactions;
 150 |     |         TxReturn[] txReturns;
 151 |     |     }
 152 |     | 
 153 |     |     struct RawEIP1559ScriptArtifact {
 154 |     |         string[] libraries;
 155 |     |         string path;
 156 |     |         string[] pending;
 157 |     |         RawReceipt[] receipts;
 158 |     |         TxReturn[] txReturns;
 159 |     |         uint256 timestamp;
 160 |     |         RawTx1559[] transactions;
 161 |     |     }
 162 |     | 
 163 |     |     struct RawReceiptLog {
 164 |     |         // json value = address
 165 |     |         address logAddress;
 166 |     |         bytes32 blockHash;
 167 |     |         bytes blockNumber;
 168 |     |         bytes data;
 169 |     |         bytes logIndex;
 170 |     |         bool removed;
 171 |     |         bytes32[] topics;
 172 |     |         bytes32 transactionHash;
 173 |     |         bytes transactionIndex;
 174 |     |         bytes transactionLogIndex;
 175 |     |     }
 176 |     | 
 177 |     |     struct ReceiptLog {
 178 |     |         // json value = address
 179 |     |         address logAddress;
 180 |     |         bytes32 blockHash;
 181 |     |         uint256 blockNumber;
 182 |     |         bytes data;
 183 |     |         uint256 logIndex;
 184 |     |         bytes32[] topics;
 185 |     |         uint256 transactionIndex;
 186 |     |         uint256 transactionLogIndex;
 187 |     |         bool removed;
 188 |     |     }
 189 |     | 
 190 |     |     struct TxReturn {
 191 |     |         string internalType;
 192 |     |         string value;
 193 |     |     }
 194 |     | 
 195 |     |     struct Account {
 196 |     |         address addr;
 197 |     |         uint256 key;
 198 |     |     }
 199 |     | 
 200 |     |     enum AddressType {
 201 |     |         Payable,
 202 |     |         NonPayable,
 203 |     |         ZeroAddress,
 204 |     |         Precompile,
 205 |     |         ForgeAddress
 206 |     |     }
 207 |     | 
 208 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 209 |     |     function assumeNotBlacklisted(address token, address addr) internal view virtual {
 210 |     |         // Nothing to check if `token` is not a contract.
 211 |     |         uint256 tokenCodeSize;
 212 |     |         assembly {
 213 |     |             tokenCodeSize := extcodesize(token)
 214 |     |         }
 215 |     |         require(tokenCodeSize > 0, "StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.");
 216 |     | 
 217 |     |         bool success;
 218 |     |         bytes memory returnData;
 219 |     | 
 220 |     |         // 4-byte selector for `isBlacklisted(address)`, used by USDC.
 221 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));
 222 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 223 |     | 
 224 |     |         // 4-byte selector for `isBlackListed(address)`, used by USDT.
 225 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));
 226 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 227 |     |     }
 228 |     | 
 229 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 230 |     |     // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for
 231 |     |     // backwards compatibility, since this name was used in the original PR which has already has
 232 |     |     // a release. This function can be removed in a future release once we want a breaking change.
 233 |     |     function assumeNoBlacklisted(address token, address addr) internal view virtual {
 234 |     |         assumeNotBlacklisted(token, addr);
 235 |     |     }
 236 |     | 
 237 |     |     function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {
 238 |     |         if (addressType == AddressType.Payable) {
 239 |     |             assumeNotPayable(addr);
 240 |     |         } else if (addressType == AddressType.NonPayable) {
 241 |     |             assumePayable(addr);
 242 |     |         } else if (addressType == AddressType.ZeroAddress) {
 243 |     |             assumeNotZeroAddress(addr);
 244 |     |         } else if (addressType == AddressType.Precompile) {
 245 |     |             assumeNotPrecompile(addr);
 246 |     |         } else if (addressType == AddressType.ForgeAddress) {
 247 |     |             assumeNotForgeAddress(addr);
 248 |     |         }
 249 |     |     }
 250 |     | 
 251 |     |     function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {
 252 |     |         assumeAddressIsNot(addr, addressType1);
 253 |     |         assumeAddressIsNot(addr, addressType2);
 254 |     |     }
 255 |     | 
 256 |     |     function assumeAddressIsNot(
 257 |     |         address addr,
 258 |     |         AddressType addressType1,
 259 |     |         AddressType addressType2,
 260 |     |         AddressType addressType3
 261 |     |     ) internal virtual {
 262 |     |         assumeAddressIsNot(addr, addressType1);
 263 |     |         assumeAddressIsNot(addr, addressType2);
 264 |     |         assumeAddressIsNot(addr, addressType3);
 265 |     |     }
 266 |     | 
 267 |     |     function assumeAddressIsNot(
 268 |     |         address addr,
 269 |     |         AddressType addressType1,
 270 |     |         AddressType addressType2,
 271 |     |         AddressType addressType3,
 272 |     |         AddressType addressType4
 273 |     |     ) internal virtual {
 274 |     |         assumeAddressIsNot(addr, addressType1);
 275 |     |         assumeAddressIsNot(addr, addressType2);
 276 |     |         assumeAddressIsNot(addr, addressType3);
 277 |     |         assumeAddressIsNot(addr, addressType4);
 278 |     |     }
 279 |     | 
 280 |     |     // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to
 281 |     |     // `addr` and checking the `success` return value.
 282 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 283 |     |     // implemented by `addr`, which should be taken into account when this function is used.
 284 |     |     function _isPayable(address addr) private returns (bool) {
 285 |     |         require(
 286 |     |             addr.balance < UINT256_MAX,
 287 |     |             "StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds"
 288 |     |         );
 289 |     |         uint256 origBalanceTest = address(this).balance;
 290 |     |         uint256 origBalanceAddr = address(addr).balance;
 291 |     | 
 292 |     |         vm.deal(address(this), 1);
 293 |     |         (bool success,) = payable(addr).call{value: 1}("");
 294 |     | 
 295 |     |         // reset balances
 296 |     |         vm.deal(address(this), origBalanceTest);
 297 |     |         vm.deal(addr, origBalanceAddr);
 298 |     | 
 299 |     |         return success;
 300 |     |     }
 301 |     | 
 302 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 303 |     |     // implemented by `addr`, which should be taken into account when this function is used. See the
 304 |     |     // `_isPayable` method for more information.
 305 |     |     function assumePayable(address addr) internal virtual {
 306 |     |         vm.assume(_isPayable(addr));
 307 |     |     }
 308 |     | 
 309 |     |     function assumeNotPayable(address addr) internal virtual {
 310 |     |         vm.assume(!_isPayable(addr));
 311 |     |     }
 312 |     | 
 313 |     |     function assumeNotZeroAddress(address addr) internal pure virtual {
 314 |     |         vm.assume(addr != address(0));
 315 |     |     }
 316 |     | 
 317 |     |     function assumeNotPrecompile(address addr) internal pure virtual {
 318 |     |         assumeNotPrecompile(addr, _pureChainId());
 319 |     |     }
 320 |     | 
 321 |     |     function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {
 322 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 323 |     |         // address), but the same rationale for excluding them applies so we include those too.
 324 |     | 
 325 |     |         // These should be present on all EVM-compatible chains.
 326 |     |         vm.assume(addr < address(0x1) || addr > address(0x9));
 327 |     | 
 328 |     |         // forgefmt: disable-start
 329 |     |         if (chainId == 10 || chainId == 420) {
 330 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 331 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 332 |     |         } else if (chainId == 42161 || chainId == 421613) {
 333 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 334 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 335 |     |         } else if (chainId == 43114 || chainId == 43113) {
 336 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 337 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 338 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 339 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 340 |     |         }
 341 |     |         // forgefmt: disable-end
 342 |     |     }
 343 |     | 
 344 |     |     function assumeNotForgeAddress(address addr) internal pure virtual {
 345 |     |         // vm, console, and Create2Deployer addresses
 346 |     |         vm.assume(
 347 |     |             addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67
 348 |     |                 && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C
 349 |     |         );
 350 |     |     }
 351 |     | 
 352 |     |     function readEIP1559ScriptArtifact(string memory path)
 353 |     |         internal
 354 |     |         view
 355 |     |         virtual
 356 |     |         returns (EIP1559ScriptArtifact memory)
 357 |     |     {
 358 |     |         string memory data = vm.readFile(path);
 359 |     |         bytes memory parsedData = vm.parseJson(data);
 360 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 361 |     |         EIP1559ScriptArtifact memory artifact;
 362 |     |         artifact.libraries = rawArtifact.libraries;
 363 |     |         artifact.path = rawArtifact.path;
 364 |     |         artifact.timestamp = rawArtifact.timestamp;
 365 |     |         artifact.pending = rawArtifact.pending;
 366 |     |         artifact.txReturns = rawArtifact.txReturns;
 367 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 368 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 369 |     |         return artifact;
 370 |     |     }
 371 |     | 
 372 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 373 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 374 |     |         for (uint256 i; i < rawTxs.length; i++) {
 375 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 376 |     |         }
 377 |     |         return txs;
 378 |     |     }
 379 |     | 
 380 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 381 |     |         Tx1559 memory transaction;
 382 |     |         transaction.arguments = rawTx.arguments;
 383 |     |         transaction.contractName = rawTx.contractName;
 384 |     |         transaction.functionSig = rawTx.functionSig;
 385 |     |         transaction.hash = rawTx.hash;
 386 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 387 |     |         transaction.opcode = rawTx.opcode;
 388 |     |         return transaction;
 389 |     |     }
 390 |     | 
 391 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 392 |     |         internal
 393 |     |         pure
 394 |     |         virtual
 395 |     |         returns (Tx1559Detail memory)
 396 |     |     {
 397 |     |         Tx1559Detail memory txDetail;
 398 |     |         txDetail.data = rawDetail.data;
 399 |     |         txDetail.from = rawDetail.from;
 400 |     |         txDetail.to = rawDetail.to;
 401 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 402 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 403 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 404 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 405 |     |         txDetail.accessList = rawDetail.accessList;
 406 |     |         return txDetail;
 407 |     |     }
 408 |     | 
 409 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 410 |     |         string memory deployData = vm.readFile(path);
 411 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 412 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 413 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 414 |     |     }
 415 |     | 
 416 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 417 |     |         string memory deployData = vm.readFile(path);
 418 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 419 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 420 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 421 |     |         return rawToConvertedEIPTx1559(rawTx);
 422 |     |     }
 423 |     | 
 424 |     |     // Analogous to readTransactions, but for receipts.
 425 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 426 |     |         string memory deployData = vm.readFile(path);
 427 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 428 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 429 |     |         return rawToConvertedReceipts(rawReceipts);
 430 |     |     }
 431 |     | 
 432 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 433 |     |         string memory deployData = vm.readFile(path);
 434 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 435 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 436 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 437 |     |         return rawToConvertedReceipt(rawReceipt);
 438 |     |     }
 439 |     | 
 440 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 441 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 442 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 443 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 444 |     |         }
 445 |     |         return receipts;
 446 |     |     }
 447 |     | 
 448 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 449 |     |         Receipt memory receipt;
 450 |     |         receipt.blockHash = rawReceipt.blockHash;
 451 |     |         receipt.to = rawReceipt.to;
 452 |     |         receipt.from = rawReceipt.from;
 453 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 454 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 455 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 456 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 457 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 458 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 459 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 460 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 461 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 462 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 463 |     |         return receipt;
 464 |     |     }
 465 |     | 
 466 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 467 |     |         internal
 468 |     |         pure
 469 |     |         virtual
 470 |     |         returns (ReceiptLog[] memory)
 471 |     |     {
 472 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 473 |     |         for (uint256 i; i < rawLogs.length; i++) {
 474 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 475 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 476 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 477 |     |             logs[i].data = rawLogs[i].data;
 478 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 479 |     |             logs[i].topics = rawLogs[i].topics;
 480 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 481 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 482 |     |             logs[i].removed = rawLogs[i].removed;
 483 |     |         }
 484 |     |         return logs;
 485 |     |     }
 486 |     | 
 487 |     |     // Deploy a contract by fetching the contract bytecode from
 488 |     |     // the artifacts directory
 489 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 490 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 491 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 492 |     |         /// @solidity memory-safe-assembly
 493 |     |         assembly {
 494 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 495 |     |         }
 496 |     | 
 497 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 498 |     |     }
 499 |     | 
 500 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 501 |     |         bytes memory bytecode = vm.getCode(what);
 502 |     |         /// @solidity memory-safe-assembly
 503 |     |         assembly {
 504 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 505 |     |         }
 506 |     | 
 507 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 508 |     |     }
 509 |     | 
 510 |     |     /// @dev deploy contract with value on construction
 511 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 512 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 513 |     |         /// @solidity memory-safe-assembly
 514 |     |         assembly {
 515 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 516 |     |         }
 517 |     | 
 518 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 519 |     |     }
 520 |     | 
 521 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 522 |     |         bytes memory bytecode = vm.getCode(what);
 523 |     |         /// @solidity memory-safe-assembly
 524 |     |         assembly {
 525 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 526 |     |         }
 527 |     | 
 528 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 529 |     |     }
 530 |     | 
 531 |     |     // creates a labeled address and the corresponding private key
 532 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 533 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 534 |     |         addr = vm.addr(privateKey);
 535 |     |         vm.label(addr, name);
 536 |     |     }
 537 |     | 
 538 |     |     // creates a labeled address
 539 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 540 |     |         (addr,) = makeAddrAndKey(name);
 541 |     |     }
 542 |     | 
 543 |     |     // Destroys an account immediately, sending the balance to beneficiary.
 544 |     |     // Destroying means: balance will be zero, code will be empty, and nonce will be 0
 545 |     |     // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce
 546 |     |     // only after tx ends, this will run immediately.
 547 |     |     function destroyAccount(address who, address beneficiary) internal virtual {
 548 |     |         uint256 currBalance = who.balance;
 549 |     |         vm.etch(who, abi.encode());
 550 |     |         vm.deal(who, 0);
 551 |     |         vm.resetNonce(who);
 552 |     | 
 553 |     |         uint256 beneficiaryBalance = beneficiary.balance;
 554 |     |         vm.deal(beneficiary, currBalance + beneficiaryBalance);
 555 |     |     }
 556 |     | 
 557 |     |     // creates a struct containing both a labeled address and the corresponding private key
 558 |     |     function makeAccount(string memory name) internal virtual returns (Account memory account) {
 559 |     |         (account.addr, account.key) = makeAddrAndKey(name);
 560 |     |     }
 561 |     | 
 562 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 563 |     |         internal
 564 |     |         virtual
 565 |     |         returns (address who, uint256 privateKey)
 566 |     |     {
 567 |     |         privateKey = vm.deriveKey(mnemonic, index);
 568 |     |         who = vm.rememberKey(privateKey);
 569 |     |     }
 570 |     | 
 571 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 572 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 573 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 574 |     |     }
 575 |     | 
 576 |     |     function isFork() internal view virtual returns (bool status) {
 577 |     |         try vm.activeFork() {
 578 |     |             status = true;
 579 |     |         } catch (bytes memory) {}
 580 |     |     }
 581 |     | 
 582 |     |     modifier skipWhenForking() {
 583 |     |         if (!isFork()) {
 584 |     |             _;
 585 |     |         }
 586 |     |     }
 587 |     | 
 588 |     |     modifier skipWhenNotForking() {
 589 |     |         if (isFork()) {
 590 |     |             _;
 591 |     |         }
 592 |     |     }
 593 |     | 
 594 |     |     modifier noGasMetering() {
 595 |     |         vm.pauseGasMetering();
 596 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 597 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 598 |     |         // it back on until we exit the top level function that used the modifier
 599 |     |         //
 600 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 601 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 602 |     |         // so we only turn metering back on at the end of the funcA
 603 |     |         bool gasStartedOff = gasMeteringOff;
 604 |     |         gasMeteringOff = true;
 605 |     | 
 606 |     |         _;
 607 |     | 
 608 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 609 |     |         if (!gasStartedOff) {
 610 |     |             gasMeteringOff = false;
 611 |     |             vm.resumeGasMetering();
 612 |     |         }
 613 |     |     }
 614 |     | 
 615 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 616 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 617 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 618 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 619 |     |     function _viewChainId() private view returns (uint256 chainId) {
 620 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 621 |     |         assembly {
 622 |     |             chainId := chainid()
 623 |     |         }
 624 |     | 
 625 |     |         address(this); // Silence warnings in older Solc versions.
 626 |     |     }
 627 |     | 
 628 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 629 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 630 |     |         function() internal pure returns (uint256) pureChainId;
 631 |     |         assembly {
 632 |     |             pureChainId := fnIn
 633 |     |         }
 634 |     |         chainId = pureChainId();
 635 |     |     }
 636 |     | }
 637 |     | 
 638 |     | // Wrappers around cheatcodes to avoid footguns
 639 |     | abstract contract StdCheats is StdCheatsSafe {
 640 |     |     using stdStorage for StdStorage;
 641 |     | 
 642 |     |     StdStorage private stdstore;
 643 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 644 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
 645 |     | 
 646 |     |     // Skip forward or rewind time by the specified number of seconds
 647 |     |     function skip(uint256 time) internal virtual {
 648 |     |         vm.warp(block.timestamp + time);
 649 |     |     }
 650 |     | 
 651 |     |     function rewind(uint256 time) internal virtual {
 652 |     |         vm.warp(block.timestamp - time);
 653 |     |     }
 654 |     | 
 655 |     |     // Setup a prank from an address that has some ether
 656 |     |     function hoax(address msgSender) internal virtual {
 657 |     |         vm.deal(msgSender, 1 << 128);
 658 |     |         vm.prank(msgSender);
 659 |     |     }
 660 |     | 
 661 |     |     function hoax(address msgSender, uint256 give) internal virtual {
 662 |     |         vm.deal(msgSender, give);
 663 |     |         vm.prank(msgSender);
 664 |     |     }
 665 |     | 
 666 |     |     function hoax(address msgSender, address origin) internal virtual {
 667 |     |         vm.deal(msgSender, 1 << 128);
 668 |     |         vm.prank(msgSender, origin);
 669 |     |     }
 670 |     | 
 671 |     |     function hoax(address msgSender, address origin, uint256 give) internal virtual {
 672 |     |         vm.deal(msgSender, give);
 673 |     |         vm.prank(msgSender, origin);
 674 |     |     }
 675 |     | 
 676 |     |     // Start perpetual prank from an address that has some ether
 677 |     |     function startHoax(address msgSender) internal virtual {
 678 |     |         vm.deal(msgSender, 1 << 128);
 679 |     |         vm.startPrank(msgSender);
 680 |     |     }
 681 |     | 
 682 |     |     function startHoax(address msgSender, uint256 give) internal virtual {
 683 |     |         vm.deal(msgSender, give);
 684 |     |         vm.startPrank(msgSender);
 685 |     |     }
 686 |     | 
 687 |     |     // Start perpetual prank from an address that has some ether
 688 |     |     // tx.origin is set to the origin parameter
 689 |     |     function startHoax(address msgSender, address origin) internal virtual {
 690 |     |         vm.deal(msgSender, 1 << 128);
 691 |     |         vm.startPrank(msgSender, origin);
 692 |     |     }
 693 |     | 
 694 |     |     function startHoax(address msgSender, address origin, uint256 give) internal virtual {
 695 |     |         vm.deal(msgSender, give);
 696 |     |         vm.startPrank(msgSender, origin);
 697 |     |     }
 698 |     | 
 699 |     |     function changePrank(address msgSender) internal virtual {
 700 |     |         console2_log_StdCheats("changePrank is deprecated. Please use vm.startPrank instead.");
 701 |     |         vm.stopPrank();
 702 |     |         vm.startPrank(msgSender);
 703 |     |     }
 704 |     | 
 705 |     |     function changePrank(address msgSender, address txOrigin) internal virtual {
 706 |     |         vm.stopPrank();
 707 |     |         vm.startPrank(msgSender, txOrigin);
 708 |     |     }
 709 |     | 
 710 |     |     // The same as Vm's `deal`
 711 |     |     // Use the alternative signature for ERC20 tokens
 712 |     |     function deal(address to, uint256 give) internal virtual {
 713 |     |         vm.deal(to, give);
 714 |     |     }
 715 |     | 
 716 |     |     // Set the balance of an account for any ERC20 token
 717 |     |     // Use the alternative signature to update `totalSupply`
 718 |     |     function deal(address token, address to, uint256 give) internal virtual {
 719 |     |         deal(token, to, give, false);
 720 |     |     }
 721 |     | 
 722 |     |     // Set the balance of an account for any ERC1155 token
 723 |     |     // Use the alternative signature to update `totalSupply`
 724 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {
 725 |     |         dealERC1155(token, to, id, give, false);
 726 |     |     }
 727 |     | 
 728 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 729 |     |         // get current balance
 730 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 731 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 732 |     | 
 733 |     |         // update balance
 734 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 735 |     | 
 736 |     |         // update total supply
 737 |     |         if (adjust) {
 738 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));
 739 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 740 |     |             if (give < prevBal) {
 741 |     |                 totSup -= (prevBal - give);
 742 |     |             } else {
 743 |     |                 totSup += (give - prevBal);
 744 |     |             }
 745 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 746 |     |         }
 747 |     |     }
 748 |     | 
 749 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {
 750 |     |         // get current balance
 751 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));
 752 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 753 |     | 
 754 |     |         // update balance
 755 |     |         stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);
 756 |     | 
 757 |     |         // update total supply
 758 |     |         if (adjust) {
 759 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));
 760 |     |             require(
 761 |     |                 totSupData.length != 0,
 762 |     |                 "StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply."
 763 |     |             );
 764 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 765 |     |             if (give < prevBal) {
 766 |     |                 totSup -= (prevBal - give);
 767 |     |             } else {
 768 |     |                 totSup += (give - prevBal);
 769 |     |             }
 770 |     |             stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);
 771 |     |         }
 772 |     |     }
 773 |     | 
 774 |     |     function dealERC721(address token, address to, uint256 id) internal virtual {
 775 |     |         // check if token id is already minted and the actual owner.
 776 |     |         (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));
 777 |     |         require(successMinted, "StdCheats deal(address,address,uint,bool): id not minted.");
 778 |     | 
 779 |     |         // get owner current balance
 780 |     |         (, bytes memory fromBalData) =
 781 |     |             token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));
 782 |     |         uint256 fromPrevBal = abi.decode(fromBalData, (uint256));
 783 |     | 
 784 |     |         // get new user current balance
 785 |     |         (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 786 |     |         uint256 toPrevBal = abi.decode(toBalData, (uint256));
 787 |     | 
 788 |     |         // update balances
 789 |     |         stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);
 790 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);
 791 |     | 
 792 |     |         // update owner
 793 |     |         stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);
 794 |     |     }
 795 |     | 
 796 |     |     function deployCodeTo(string memory what, address where) internal virtual {
 797 |     |         deployCodeTo(what, "", 0, where);
 798 |     |     }
 799 |     | 
 800 |     |     function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {
 801 |     |         deployCodeTo(what, args, 0, where);
 802 |     |     }
 803 |     | 
 804 |     |     function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {
 805 |     |         bytes memory creationCode = vm.getCode(what);
 806 |     |         vm.etch(where, abi.encodePacked(creationCode, args));
 807 |     |         (bool success, bytes memory runtimeBytecode) = where.call{value: value}("");
 808 |     |         require(success, "StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.");
 809 |     |         vm.etch(where, runtimeBytecode);
 810 |     |     }
 811 |     | 
 812 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 813 |     |     function console2_log_StdCheats(string memory p0) private view {
 814 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string)", p0));
 815 |     |         status;
 816 |     |     }
 817 |     | }
 818 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdInvariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | abstract contract StdInvariant {
   7 |     |     struct FuzzSelector {
   8 |     |         address addr;
   9 |     |         bytes4[] selectors;
  10 |     |     }
  11 |     | 
  12 |     |     struct FuzzArtifactSelector {
  13 |     |         string artifact;
  14 |     |         bytes4[] selectors;
  15 |     |     }
  16 |     | 
  17 |     |     struct FuzzInterface {
  18 |     |         address addr;
  19 |     |         string[] artifacts;
  20 |     |     }
  21 |     | 
  22 |     |     address[] private _excludedContracts;
  23 |     |     address[] private _excludedSenders;
  24 |     |     address[] private _targetedContracts;
  25 |     |     address[] private _targetedSenders;
  26 |     | 
  27 |     |     string[] private _excludedArtifacts;
  28 |     |     string[] private _targetedArtifacts;
  29 |     | 
  30 |     |     FuzzArtifactSelector[] private _targetedArtifactSelectors;
  31 |     | 
  32 |     |     FuzzSelector[] private _excludedSelectors;
  33 |     |     FuzzSelector[] private _targetedSelectors;
  34 |     | 
  35 |     |     FuzzInterface[] private _targetedInterfaces;
  36 |     | 
  37 |     |     // Functions for users:
  38 |     |     // These are intended to be called in tests.
  39 |     | 
  40 |     |     function excludeContract(address newExcludedContract_) internal {
  41 |     |         _excludedContracts.push(newExcludedContract_);
  42 |     |     }
  43 |     | 
  44 |     |     function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {
  45 |     |         _excludedSelectors.push(newExcludedSelector_);
  46 |     |     }
  47 |     | 
  48 |     |     function excludeSender(address newExcludedSender_) internal {
  49 |     |         _excludedSenders.push(newExcludedSender_);
  50 |     |     }
  51 |     | 
  52 |     |     function excludeArtifact(string memory newExcludedArtifact_) internal {
  53 |     |         _excludedArtifacts.push(newExcludedArtifact_);
  54 |     |     }
  55 |     | 
  56 |     |     function targetArtifact(string memory newTargetedArtifact_) internal {
  57 |     |         _targetedArtifacts.push(newTargetedArtifact_);
  58 |     |     }
  59 |     | 
  60 |     |     function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {
  61 |     |         _targetedArtifactSelectors.push(newTargetedArtifactSelector_);
  62 |     |     }
  63 |     | 
  64 |     |     function targetContract(address newTargetedContract_) internal {
  65 |     |         _targetedContracts.push(newTargetedContract_);
  66 |     |     }
  67 |     | 
  68 |     |     function targetSelector(FuzzSelector memory newTargetedSelector_) internal {
  69 |     |         _targetedSelectors.push(newTargetedSelector_);
  70 |     |     }
  71 |     | 
  72 |     |     function targetSender(address newTargetedSender_) internal {
  73 |     |         _targetedSenders.push(newTargetedSender_);
  74 |     |     }
  75 |     | 
  76 |     |     function targetInterface(FuzzInterface memory newTargetedInterface_) internal {
  77 |     |         _targetedInterfaces.push(newTargetedInterface_);
  78 |     |     }
  79 |     | 
  80 |     |     // Functions for forge:
  81 |     |     // These are called by forge to run invariant tests and don't need to be called in tests.
  82 |     | 
  83 | *   |     function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {
  84 | *   |         excludedArtifacts_ = _excludedArtifacts;
  85 |     |     }
  86 |     | 
  87 | *   |     function excludeContracts() public view returns (address[] memory excludedContracts_) {
  88 | *   |         excludedContracts_ = _excludedContracts;
  89 |     |     }
  90 |     | 
  91 | *   |     function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {
  92 | *   |         excludedSelectors_ = _excludedSelectors;
  93 |     |     }
  94 |     | 
  95 | *   |     function excludeSenders() public view returns (address[] memory excludedSenders_) {
  96 | *   |         excludedSenders_ = _excludedSenders;
  97 |     |     }
  98 |     | 
  99 | *   |     function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {
 100 | *   |         targetedArtifacts_ = _targetedArtifacts;
 101 |     |     }
 102 |     | 
 103 | *   |     function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {
 104 | *   |         targetedArtifactSelectors_ = _targetedArtifactSelectors;
 105 |     |     }
 106 |     | 
 107 | *   |     function targetContracts() public view returns (address[] memory targetedContracts_) {
 108 | *   |         targetedContracts_ = _targetedContracts;
 109 |     |     }
 110 |     | 
 111 | *   |     function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {
 112 | *   |         targetedSelectors_ = _targetedSelectors;
 113 |     |     }
 114 |     | 
 115 | *   |     function targetSenders() public view returns (address[] memory targetedSenders_) {
 116 | *   |         targetedSenders_ = _targetedSenders;
 117 |     |     }
 118 |     | 
 119 | *   |     function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {
 120 | *   |         targetedInterfaces_ = _targetedInterfaces;
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("<some_path>");
  13 |     | // json.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdJson {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  29 |     |         return vm.parseJson(json, key);
  30 |     |     }
  31 |     | 
  32 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  33 |     |         return vm.parseJsonUint(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  37 |     |         return vm.parseJsonUintArray(json, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  41 |     |         return vm.parseJsonInt(json, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  45 |     |         return vm.parseJsonIntArray(json, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  49 |     |         return vm.parseJsonBytes32(json, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  53 |     |         return vm.parseJsonBytes32Array(json, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  57 |     |         return vm.parseJsonString(json, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  61 |     |         return vm.parseJsonStringArray(json, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  65 |     |         return vm.parseJsonAddress(json, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  69 |     |         return vm.parseJsonAddressArray(json, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  73 |     |         return vm.parseJsonBool(json, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  77 |     |         return vm.parseJsonBoolArray(json, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  81 |     |         return vm.parseJsonBytes(json, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  85 |     |         return vm.parseJsonBytesArray(json, key);
  86 |     |     }
  87 |     | 
  88 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
  89 |     |         return vm.serializeJson(jsonKey, rootObject);
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  93 |     |         return vm.serializeBool(jsonKey, key, value);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
  97 |     |         internal
  98 |     |         returns (string memory)
  99 |     |     {
 100 |     |         return vm.serializeBool(jsonKey, key, value);
 101 |     |     }
 102 |     | 
 103 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 104 |     |         return vm.serializeUint(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 108 |     |         internal
 109 |     |         returns (string memory)
 110 |     |     {
 111 |     |         return vm.serializeUint(jsonKey, key, value);
 112 |     |     }
 113 |     | 
 114 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 115 |     |         return vm.serializeInt(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 119 |     |         internal
 120 |     |         returns (string memory)
 121 |     |     {
 122 |     |         return vm.serializeInt(jsonKey, key, value);
 123 |     |     }
 124 |     | 
 125 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 126 |     |         return vm.serializeAddress(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 130 |     |         internal
 131 |     |         returns (string memory)
 132 |     |     {
 133 |     |         return vm.serializeAddress(jsonKey, key, value);
 134 |     |     }
 135 |     | 
 136 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 137 |     |         return vm.serializeBytes32(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 141 |     |         internal
 142 |     |         returns (string memory)
 143 |     |     {
 144 |     |         return vm.serializeBytes32(jsonKey, key, value);
 145 |     |     }
 146 |     | 
 147 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 148 |     |         return vm.serializeBytes(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 152 |     |         internal
 153 |     |         returns (string memory)
 154 |     |     {
 155 |     |         return vm.serializeBytes(jsonKey, key, value);
 156 |     |     }
 157 |     | 
 158 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 159 |     |         internal
 160 |     |         returns (string memory)
 161 |     |     {
 162 |     |         return vm.serializeString(jsonKey, key, value);
 163 |     |     }
 164 |     | 
 165 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 166 |     |         internal
 167 |     |         returns (string memory)
 168 |     |     {
 169 |     |         return vm.serializeString(jsonKey, key, value);
 170 |     |     }
 171 |     | 
 172 |     |     function write(string memory jsonKey, string memory path) internal {
 173 |     |         vm.writeJson(jsonKey, path);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 177 |     |         vm.writeJson(jsonKey, path, valueKey);
 178 |     |     }
 179 |     | }
 180 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct FindData {
   7 |     |     uint256 slot;
   8 |     |     uint256 offsetLeft;
   9 |     |     uint256 offsetRight;
  10 |     |     bool found;
  11 |     | }
  12 |     | 
  13 |     | struct StdStorage {
  14 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;
  15 |     |     bytes32[] _keys;
  16 |     |     bytes4 _sig;
  17 |     |     uint256 _depth;
  18 |     |     address _target;
  19 |     |     bytes32 _set;
  20 |     |     bool _enable_packed_slots;
  21 |     |     bytes _calldata;
  22 |     | }
  23 |     | 
  24 |     | library stdStorageSafe {
  25 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  26 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  27 |     | 
  28 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  29 |     |     uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
  30 |     | 
  31 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  32 |     |         return bytes4(keccak256(bytes(sigStr)));
  33 |     |     }
  34 |     | 
  35 |     |     function getCallParams(StdStorage storage self) internal view returns (bytes memory) {
  36 |     |         if (self._calldata.length == 0) {
  37 |     |             return flatten(self._keys);
  38 |     |         } else {
  39 |     |             return self._calldata;
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     // Calls target contract with configured parameters
  44 |     |     function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {
  45 |     |         bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));
  46 |     |         (bool success, bytes memory rdat) = self._target.staticcall(cald);
  47 |     |         bytes32 result = bytesToBytes32(rdat, 32 * self._depth);
  48 |     | 
  49 |     |         return (success, result);
  50 |     |     }
  51 |     | 
  52 |     |     // Tries mutating slot value to determine if the targeted value is stored in it.
  53 |     |     // If current value is 0, then we are setting slot value to type(uint256).max
  54 |     |     // Otherwise, we set it to 0. That way, return value should always be affected.
  55 |     |     function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {
  56 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  57 |     |         (bool success, bytes32 prevReturnValue) = callTarget(self);
  58 |     | 
  59 |     |         bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);
  60 |     |         vm.store(self._target, slot, testVal);
  61 |     | 
  62 |     |         (, bytes32 newReturnValue) = callTarget(self);
  63 |     | 
  64 |     |         vm.store(self._target, slot, prevSlotValue);
  65 |     | 
  66 |     |         return (success && (prevReturnValue != newReturnValue));
  67 |     |     }
  68 |     | 
  69 |     |     // Tries setting one of the bits in slot to 1 until return value changes.
  70 |     |     // Index of resulted bit is an offset packed slot has from left/right side
  71 |     |     function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {
  72 |     |         for (uint256 offset = 0; offset < 256; offset++) {
  73 |     |             uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);
  74 |     |             vm.store(self._target, slot, bytes32(valueToPut));
  75 |     | 
  76 |     |             (bool success, bytes32 data) = callTarget(self);
  77 |     | 
  78 |     |             if (success && (uint256(data) > 0)) {
  79 |     |                 return (true, offset);
  80 |     |             }
  81 |     |         }
  82 |     |         return (false, 0);
  83 |     |     }
  84 |     | 
  85 |     |     function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {
  86 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  87 |     | 
  88 |     |         (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);
  89 |     |         (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);
  90 |     | 
  91 |     |         // `findOffset` may mutate slot value, so we are setting it to initial value
  92 |     |         vm.store(self._target, slot, prevSlotValue);
  93 |     |         return (foundLeft && foundRight, offsetLeft, offsetRight);
  94 |     |     }
  95 |     | 
  96 |     |     function find(StdStorage storage self) internal returns (FindData storage) {
  97 |     |         return find(self, true);
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
 101 |     |     // slot complexity:
 102 |     |     //  if flat, will be bytes32(uint256(uint));
 103 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
 104 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
 105 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
 106 |     |     function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {
 107 |     |         address who = self._target;
 108 |     |         bytes4 fsig = self._sig;
 109 |     |         uint256 field_depth = self._depth;
 110 |     |         bytes memory params = getCallParams(self);
 111 |     | 
 112 |     |         // calldata to test against
 113 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 114 |     |             if (_clear) {
 115 |     |                 clear(self);
 116 |     |             }
 117 |     |             return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 118 |     |         }
 119 |     |         vm.record();
 120 |     |         (, bytes32 callResult) = callTarget(self);
 121 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
 122 |     | 
 123 |     |         if (reads.length == 0) {
 124 |     |             revert("stdStorage find(StdStorage): No storage use detected for target.");
 125 |     |         } else {
 126 |     |             for (uint256 i = 0; i < reads.length; i++) {
 127 |     |                 bytes32 prev = vm.load(who, reads[i]);
 128 |     |                 if (prev == bytes32(0)) {
 129 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
 130 |     |                 }
 131 |     | 
 132 |     |                 if (!checkSlotMutatesCall(self, reads[i])) {
 133 |     |                     continue;
 134 |     |                 }
 135 |     | 
 136 |     |                 (uint256 offsetLeft, uint256 offsetRight) = (0, 0);
 137 |     | 
 138 |     |                 if (self._enable_packed_slots) {
 139 |     |                     bool found;
 140 |     |                     (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);
 141 |     |                     if (!found) {
 142 |     |                         continue;
 143 |     |                     }
 144 |     |                 }
 145 |     | 
 146 |     |                 // Check that value between found offsets is equal to the current call result
 147 |     |                 uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;
 148 |     | 
 149 |     |                 if (uint256(callResult) != curVal) {
 150 |     |                     continue;
 151 |     |                 }
 152 |     | 
 153 |     |                 emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));
 154 |     |                 self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =
 155 |     |                     FindData(uint256(reads[i]), offsetLeft, offsetRight, true);
 156 |     |                 break;
 157 |     |             }
 158 |     |         }
 159 |     | 
 160 |     |         require(
 161 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,
 162 |     |             "stdStorage find(StdStorage): Slot(s) not found."
 163 |     |         );
 164 |     | 
 165 |     |         if (_clear) {
 166 |     |             clear(self);
 167 |     |         }
 168 |     |         return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 169 |     |     }
 170 |     | 
 171 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 172 |     |         self._target = _target;
 173 |     |         return self;
 174 |     |     }
 175 |     | 
 176 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 177 |     |         self._sig = _sig;
 178 |     |         return self;
 179 |     |     }
 180 |     | 
 181 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 182 |     |         self._sig = sigs(_sig);
 183 |     |         return self;
 184 |     |     }
 185 |     | 
 186 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 187 |     |         self._calldata = _calldata;
 188 |     |         return self;
 189 |     |     }
 190 |     | 
 191 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 192 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 193 |     |         return self;
 194 |     |     }
 195 |     | 
 196 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 197 |     |         self._keys.push(bytes32(amt));
 198 |     |         return self;
 199 |     |     }
 200 |     | 
 201 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 202 |     |         self._keys.push(key);
 203 |     |         return self;
 204 |     |     }
 205 |     | 
 206 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 207 |     |         self._enable_packed_slots = true;
 208 |     |         return self;
 209 |     |     }
 210 |     | 
 211 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 212 |     |         self._depth = _depth;
 213 |     |         return self;
 214 |     |     }
 215 |     | 
 216 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 217 |     |         FindData storage data = find(self, false);
 218 |     |         uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);
 219 |     |         uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;
 220 |     |         clear(self);
 221 |     |         return abi.encode(value);
 222 |     |     }
 223 |     | 
 224 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 225 |     |         return abi.decode(read(self), (bytes32));
 226 |     |     }
 227 |     | 
 228 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 229 |     |         int256 v = read_int(self);
 230 |     |         if (v == 0) return false;
 231 |     |         if (v == 1) return true;
 232 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 233 |     |     }
 234 |     | 
 235 |     |     function read_address(StdStorage storage self) internal returns (address) {
 236 |     |         return abi.decode(read(self), (address));
 237 |     |     }
 238 |     | 
 239 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 240 |     |         return abi.decode(read(self), (uint256));
 241 |     |     }
 242 |     | 
 243 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 244 |     |         return abi.decode(read(self), (int256));
 245 |     |     }
 246 |     | 
 247 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 248 |     |         address who = self._target;
 249 |     |         uint256 field_depth = self._depth;
 250 |     |         vm.startMappingRecording();
 251 |     |         uint256 child = find(self, true).slot - field_depth;
 252 |     |         (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 253 |     |         if (!found) {
 254 |     |             revert(
 255 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 256 |     |             );
 257 |     |         }
 258 |     |         return (uint256(parent_slot), key);
 259 |     |     }
 260 |     | 
 261 |     |     function root(StdStorage storage self) internal returns (uint256) {
 262 |     |         address who = self._target;
 263 |     |         uint256 field_depth = self._depth;
 264 |     |         vm.startMappingRecording();
 265 |     |         uint256 child = find(self, true).slot - field_depth;
 266 |     |         bool found;
 267 |     |         bytes32 root_slot;
 268 |     |         bytes32 parent_slot;
 269 |     |         (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 270 |     |         if (!found) {
 271 |     |             revert(
 272 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 273 |     |             );
 274 |     |         }
 275 |     |         while (found) {
 276 |     |             root_slot = parent_slot;
 277 |     |             (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));
 278 |     |         }
 279 |     |         return uint256(root_slot);
 280 |     |     }
 281 |     | 
 282 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 283 |     |         bytes32 out;
 284 |     | 
 285 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 286 |     |         for (uint256 i = 0; i < max; i++) {
 287 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 288 |     |         }
 289 |     |         return out;
 290 |     |     }
 291 |     | 
 292 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 293 |     |         bytes memory result = new bytes(b.length * 32);
 294 |     |         for (uint256 i = 0; i < b.length; i++) {
 295 |     |             bytes32 k = b[i];
 296 |     |             /// @solidity memory-safe-assembly
 297 |     |             assembly {
 298 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 299 |     |             }
 300 |     |         }
 301 |     | 
 302 |     |         return result;
 303 |     |     }
 304 |     | 
 305 |     |     function clear(StdStorage storage self) internal {
 306 |     |         delete self._target;
 307 |     |         delete self._sig;
 308 |     |         delete self._keys;
 309 |     |         delete self._depth;
 310 |     |         delete self._enable_packed_slots;
 311 |     |         delete self._calldata;
 312 |     |     }
 313 |     | 
 314 |     |     // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`
 315 |     |     // (slotValue & mask) >> offsetRight will be the value of the given packed variable
 316 |     |     function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {
 317 |     |         // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;
 318 |     |         // using assembly because (1 << 256) causes overflow
 319 |     |         assembly {
 320 |     |             mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))
 321 |     |         }
 322 |     |     }
 323 |     | 
 324 |     |     // Returns slot value with updated packed variable.
 325 |     |     function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)
 326 |     |         internal
 327 |     |         pure
 328 |     |         returns (bytes32 newValue)
 329 |     |     {
 330 |     |         return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));
 331 |     |     }
 332 |     | }
 333 |     | 
 334 |     | library stdStorage {
 335 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 336 |     | 
 337 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 338 |     |         return stdStorageSafe.sigs(sigStr);
 339 |     |     }
 340 |     | 
 341 |     |     function find(StdStorage storage self) internal returns (uint256) {
 342 |     |         return find(self, true);
 343 |     |     }
 344 |     | 
 345 |     |     function find(StdStorage storage self, bool _clear) internal returns (uint256) {
 346 |     |         return stdStorageSafe.find(self, _clear).slot;
 347 |     |     }
 348 |     | 
 349 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 350 |     |         return stdStorageSafe.target(self, _target);
 351 |     |     }
 352 |     | 
 353 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 354 |     |         return stdStorageSafe.sig(self, _sig);
 355 |     |     }
 356 |     | 
 357 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 358 |     |         return stdStorageSafe.sig(self, _sig);
 359 |     |     }
 360 |     | 
 361 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 362 |     |         return stdStorageSafe.with_key(self, who);
 363 |     |     }
 364 |     | 
 365 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 366 |     |         return stdStorageSafe.with_key(self, amt);
 367 |     |     }
 368 |     | 
 369 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 370 |     |         return stdStorageSafe.with_key(self, key);
 371 |     |     }
 372 |     | 
 373 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 374 |     |         return stdStorageSafe.with_calldata(self, _calldata);
 375 |     |     }
 376 |     | 
 377 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 378 |     |         return stdStorageSafe.enable_packed_slots(self);
 379 |     |     }
 380 |     | 
 381 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 382 |     |         return stdStorageSafe.depth(self, _depth);
 383 |     |     }
 384 |     | 
 385 |     |     function clear(StdStorage storage self) internal {
 386 |     |         stdStorageSafe.clear(self);
 387 |     |     }
 388 |     | 
 389 |     |     function checked_write(StdStorage storage self, address who) internal {
 390 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 391 |     |     }
 392 |     | 
 393 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 394 |     |         checked_write(self, bytes32(amt));
 395 |     |     }
 396 |     | 
 397 |     |     function checked_write_int(StdStorage storage self, int256 val) internal {
 398 |     |         checked_write(self, bytes32(uint256(val)));
 399 |     |     }
 400 |     | 
 401 |     |     function checked_write(StdStorage storage self, bool write) internal {
 402 |     |         bytes32 t;
 403 |     |         /// @solidity memory-safe-assembly
 404 |     |         assembly {
 405 |     |             t := write
 406 |     |         }
 407 |     |         checked_write(self, t);
 408 |     |     }
 409 |     | 
 410 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 411 |     |         address who = self._target;
 412 |     |         bytes4 fsig = self._sig;
 413 |     |         uint256 field_depth = self._depth;
 414 |     |         bytes memory params = stdStorageSafe.getCallParams(self);
 415 |     | 
 416 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 417 |     |             find(self, false);
 418 |     |         }
 419 |     |         FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 420 |     |         if ((data.offsetLeft + data.offsetRight) > 0) {
 421 |     |             uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));
 422 |     |             require(
 423 |     |                 uint256(set) < maxVal,
 424 |     |                 string(
 425 |     |                     abi.encodePacked(
 426 |     |                         "stdStorage find(StdStorage): Packed slot. We can't fit value greater than ",
 427 |     |                         vm.toString(maxVal)
 428 |     |                     )
 429 |     |                 )
 430 |     |             );
 431 |     |         }
 432 |     |         bytes32 curVal = vm.load(who, bytes32(data.slot));
 433 |     |         bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);
 434 |     | 
 435 |     |         vm.store(who, bytes32(data.slot), valToSet);
 436 |     | 
 437 |     |         (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);
 438 |     | 
 439 |     |         if (!success || callResult != set) {
 440 |     |             vm.store(who, bytes32(data.slot), curVal);
 441 |     |             revert("stdStorage find(StdStorage): Failed to write value.");
 442 |     |         }
 443 |     |         clear(self);
 444 |     |     }
 445 |     | 
 446 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 447 |     |         return stdStorageSafe.read_bytes32(self);
 448 |     |     }
 449 |     | 
 450 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 451 |     |         return stdStorageSafe.read_bool(self);
 452 |     |     }
 453 |     | 
 454 |     |     function read_address(StdStorage storage self) internal returns (address) {
 455 |     |         return stdStorageSafe.read_address(self);
 456 |     |     }
 457 |     | 
 458 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 459 |     |         return stdStorageSafe.read_uint(self);
 460 |     |     }
 461 |     | 
 462 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 463 |     |         return stdStorageSafe.read_int(self);
 464 |     |     }
 465 |     | 
 466 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 467 |     |         return stdStorageSafe.parent(self);
 468 |     |     }
 469 |     | 
 470 |     |     function root(StdStorage storage self) internal returns (uint256) {
 471 |     |         return stdStorageSafe.root(self);
 472 |     |     }
 473 |     | }
 474 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdStyle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.22 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | library StdStyle {
   7 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   8 |     | 
   9 |     |     string constant RED = "\u001b[91m";
  10 |     |     string constant GREEN = "\u001b[92m";
  11 |     |     string constant YELLOW = "\u001b[93m";
  12 |     |     string constant BLUE = "\u001b[94m";
  13 |     |     string constant MAGENTA = "\u001b[95m";
  14 |     |     string constant CYAN = "\u001b[96m";
  15 |     |     string constant BOLD = "\u001b[1m";
  16 |     |     string constant DIM = "\u001b[2m";
  17 |     |     string constant ITALIC = "\u001b[3m";
  18 |     |     string constant UNDERLINE = "\u001b[4m";
  19 |     |     string constant INVERSE = "\u001b[7m";
  20 |     |     string constant RESET = "\u001b[0m";
  21 |     | 
  22 |     |     function styleConcat(string memory style, string memory self) private pure returns (string memory) {
  23 |     |         return string(abi.encodePacked(style, self, RESET));
  24 |     |     }
  25 |     | 
  26 |     |     function red(string memory self) internal pure returns (string memory) {
  27 |     |         return styleConcat(RED, self);
  28 |     |     }
  29 |     | 
  30 |     |     function red(uint256 self) internal pure returns (string memory) {
  31 |     |         return red(vm.toString(self));
  32 |     |     }
  33 |     | 
  34 |     |     function red(int256 self) internal pure returns (string memory) {
  35 |     |         return red(vm.toString(self));
  36 |     |     }
  37 |     | 
  38 |     |     function red(address self) internal pure returns (string memory) {
  39 |     |         return red(vm.toString(self));
  40 |     |     }
  41 |     | 
  42 |     |     function red(bool self) internal pure returns (string memory) {
  43 |     |         return red(vm.toString(self));
  44 |     |     }
  45 |     | 
  46 |     |     function redBytes(bytes memory self) internal pure returns (string memory) {
  47 |     |         return red(vm.toString(self));
  48 |     |     }
  49 |     | 
  50 |     |     function redBytes32(bytes32 self) internal pure returns (string memory) {
  51 |     |         return red(vm.toString(self));
  52 |     |     }
  53 |     | 
  54 |     |     function green(string memory self) internal pure returns (string memory) {
  55 |     |         return styleConcat(GREEN, self);
  56 |     |     }
  57 |     | 
  58 |     |     function green(uint256 self) internal pure returns (string memory) {
  59 |     |         return green(vm.toString(self));
  60 |     |     }
  61 |     | 
  62 |     |     function green(int256 self) internal pure returns (string memory) {
  63 |     |         return green(vm.toString(self));
  64 |     |     }
  65 |     | 
  66 |     |     function green(address self) internal pure returns (string memory) {
  67 |     |         return green(vm.toString(self));
  68 |     |     }
  69 |     | 
  70 |     |     function green(bool self) internal pure returns (string memory) {
  71 |     |         return green(vm.toString(self));
  72 |     |     }
  73 |     | 
  74 |     |     function greenBytes(bytes memory self) internal pure returns (string memory) {
  75 |     |         return green(vm.toString(self));
  76 |     |     }
  77 |     | 
  78 |     |     function greenBytes32(bytes32 self) internal pure returns (string memory) {
  79 |     |         return green(vm.toString(self));
  80 |     |     }
  81 |     | 
  82 |     |     function yellow(string memory self) internal pure returns (string memory) {
  83 |     |         return styleConcat(YELLOW, self);
  84 |     |     }
  85 |     | 
  86 |     |     function yellow(uint256 self) internal pure returns (string memory) {
  87 |     |         return yellow(vm.toString(self));
  88 |     |     }
  89 |     | 
  90 |     |     function yellow(int256 self) internal pure returns (string memory) {
  91 |     |         return yellow(vm.toString(self));
  92 |     |     }
  93 |     | 
  94 |     |     function yellow(address self) internal pure returns (string memory) {
  95 |     |         return yellow(vm.toString(self));
  96 |     |     }
  97 |     | 
  98 |     |     function yellow(bool self) internal pure returns (string memory) {
  99 |     |         return yellow(vm.toString(self));
 100 |     |     }
 101 |     | 
 102 |     |     function yellowBytes(bytes memory self) internal pure returns (string memory) {
 103 |     |         return yellow(vm.toString(self));
 104 |     |     }
 105 |     | 
 106 |     |     function yellowBytes32(bytes32 self) internal pure returns (string memory) {
 107 |     |         return yellow(vm.toString(self));
 108 |     |     }
 109 |     | 
 110 |     |     function blue(string memory self) internal pure returns (string memory) {
 111 |     |         return styleConcat(BLUE, self);
 112 |     |     }
 113 |     | 
 114 |     |     function blue(uint256 self) internal pure returns (string memory) {
 115 |     |         return blue(vm.toString(self));
 116 |     |     }
 117 |     | 
 118 |     |     function blue(int256 self) internal pure returns (string memory) {
 119 |     |         return blue(vm.toString(self));
 120 |     |     }
 121 |     | 
 122 |     |     function blue(address self) internal pure returns (string memory) {
 123 |     |         return blue(vm.toString(self));
 124 |     |     }
 125 |     | 
 126 |     |     function blue(bool self) internal pure returns (string memory) {
 127 |     |         return blue(vm.toString(self));
 128 |     |     }
 129 |     | 
 130 |     |     function blueBytes(bytes memory self) internal pure returns (string memory) {
 131 |     |         return blue(vm.toString(self));
 132 |     |     }
 133 |     | 
 134 |     |     function blueBytes32(bytes32 self) internal pure returns (string memory) {
 135 |     |         return blue(vm.toString(self));
 136 |     |     }
 137 |     | 
 138 |     |     function magenta(string memory self) internal pure returns (string memory) {
 139 |     |         return styleConcat(MAGENTA, self);
 140 |     |     }
 141 |     | 
 142 |     |     function magenta(uint256 self) internal pure returns (string memory) {
 143 |     |         return magenta(vm.toString(self));
 144 |     |     }
 145 |     | 
 146 |     |     function magenta(int256 self) internal pure returns (string memory) {
 147 |     |         return magenta(vm.toString(self));
 148 |     |     }
 149 |     | 
 150 |     |     function magenta(address self) internal pure returns (string memory) {
 151 |     |         return magenta(vm.toString(self));
 152 |     |     }
 153 |     | 
 154 |     |     function magenta(bool self) internal pure returns (string memory) {
 155 |     |         return magenta(vm.toString(self));
 156 |     |     }
 157 |     | 
 158 |     |     function magentaBytes(bytes memory self) internal pure returns (string memory) {
 159 |     |         return magenta(vm.toString(self));
 160 |     |     }
 161 |     | 
 162 |     |     function magentaBytes32(bytes32 self) internal pure returns (string memory) {
 163 |     |         return magenta(vm.toString(self));
 164 |     |     }
 165 |     | 
 166 |     |     function cyan(string memory self) internal pure returns (string memory) {
 167 |     |         return styleConcat(CYAN, self);
 168 |     |     }
 169 |     | 
 170 |     |     function cyan(uint256 self) internal pure returns (string memory) {
 171 |     |         return cyan(vm.toString(self));
 172 |     |     }
 173 |     | 
 174 |     |     function cyan(int256 self) internal pure returns (string memory) {
 175 |     |         return cyan(vm.toString(self));
 176 |     |     }
 177 |     | 
 178 |     |     function cyan(address self) internal pure returns (string memory) {
 179 |     |         return cyan(vm.toString(self));
 180 |     |     }
 181 |     | 
 182 |     |     function cyan(bool self) internal pure returns (string memory) {
 183 |     |         return cyan(vm.toString(self));
 184 |     |     }
 185 |     | 
 186 |     |     function cyanBytes(bytes memory self) internal pure returns (string memory) {
 187 |     |         return cyan(vm.toString(self));
 188 |     |     }
 189 |     | 
 190 |     |     function cyanBytes32(bytes32 self) internal pure returns (string memory) {
 191 |     |         return cyan(vm.toString(self));
 192 |     |     }
 193 |     | 
 194 |     |     function bold(string memory self) internal pure returns (string memory) {
 195 |     |         return styleConcat(BOLD, self);
 196 |     |     }
 197 |     | 
 198 |     |     function bold(uint256 self) internal pure returns (string memory) {
 199 |     |         return bold(vm.toString(self));
 200 |     |     }
 201 |     | 
 202 |     |     function bold(int256 self) internal pure returns (string memory) {
 203 |     |         return bold(vm.toString(self));
 204 |     |     }
 205 |     | 
 206 |     |     function bold(address self) internal pure returns (string memory) {
 207 |     |         return bold(vm.toString(self));
 208 |     |     }
 209 |     | 
 210 |     |     function bold(bool self) internal pure returns (string memory) {
 211 |     |         return bold(vm.toString(self));
 212 |     |     }
 213 |     | 
 214 |     |     function boldBytes(bytes memory self) internal pure returns (string memory) {
 215 |     |         return bold(vm.toString(self));
 216 |     |     }
 217 |     | 
 218 |     |     function boldBytes32(bytes32 self) internal pure returns (string memory) {
 219 |     |         return bold(vm.toString(self));
 220 |     |     }
 221 |     | 
 222 |     |     function dim(string memory self) internal pure returns (string memory) {
 223 |     |         return styleConcat(DIM, self);
 224 |     |     }
 225 |     | 
 226 |     |     function dim(uint256 self) internal pure returns (string memory) {
 227 |     |         return dim(vm.toString(self));
 228 |     |     }
 229 |     | 
 230 |     |     function dim(int256 self) internal pure returns (string memory) {
 231 |     |         return dim(vm.toString(self));
 232 |     |     }
 233 |     | 
 234 |     |     function dim(address self) internal pure returns (string memory) {
 235 |     |         return dim(vm.toString(self));
 236 |     |     }
 237 |     | 
 238 |     |     function dim(bool self) internal pure returns (string memory) {
 239 |     |         return dim(vm.toString(self));
 240 |     |     }
 241 |     | 
 242 |     |     function dimBytes(bytes memory self) internal pure returns (string memory) {
 243 |     |         return dim(vm.toString(self));
 244 |     |     }
 245 |     | 
 246 |     |     function dimBytes32(bytes32 self) internal pure returns (string memory) {
 247 |     |         return dim(vm.toString(self));
 248 |     |     }
 249 |     | 
 250 |     |     function italic(string memory self) internal pure returns (string memory) {
 251 |     |         return styleConcat(ITALIC, self);
 252 |     |     }
 253 |     | 
 254 |     |     function italic(uint256 self) internal pure returns (string memory) {
 255 |     |         return italic(vm.toString(self));
 256 |     |     }
 257 |     | 
 258 |     |     function italic(int256 self) internal pure returns (string memory) {
 259 |     |         return italic(vm.toString(self));
 260 |     |     }
 261 |     | 
 262 |     |     function italic(address self) internal pure returns (string memory) {
 263 |     |         return italic(vm.toString(self));
 264 |     |     }
 265 |     | 
 266 |     |     function italic(bool self) internal pure returns (string memory) {
 267 |     |         return italic(vm.toString(self));
 268 |     |     }
 269 |     | 
 270 |     |     function italicBytes(bytes memory self) internal pure returns (string memory) {
 271 |     |         return italic(vm.toString(self));
 272 |     |     }
 273 |     | 
 274 |     |     function italicBytes32(bytes32 self) internal pure returns (string memory) {
 275 |     |         return italic(vm.toString(self));
 276 |     |     }
 277 |     | 
 278 |     |     function underline(string memory self) internal pure returns (string memory) {
 279 |     |         return styleConcat(UNDERLINE, self);
 280 |     |     }
 281 |     | 
 282 |     |     function underline(uint256 self) internal pure returns (string memory) {
 283 |     |         return underline(vm.toString(self));
 284 |     |     }
 285 |     | 
 286 |     |     function underline(int256 self) internal pure returns (string memory) {
 287 |     |         return underline(vm.toString(self));
 288 |     |     }
 289 |     | 
 290 |     |     function underline(address self) internal pure returns (string memory) {
 291 |     |         return underline(vm.toString(self));
 292 |     |     }
 293 |     | 
 294 |     |     function underline(bool self) internal pure returns (string memory) {
 295 |     |         return underline(vm.toString(self));
 296 |     |     }
 297 |     | 
 298 |     |     function underlineBytes(bytes memory self) internal pure returns (string memory) {
 299 |     |         return underline(vm.toString(self));
 300 |     |     }
 301 |     | 
 302 |     |     function underlineBytes32(bytes32 self) internal pure returns (string memory) {
 303 |     |         return underline(vm.toString(self));
 304 |     |     }
 305 |     | 
 306 |     |     function inverse(string memory self) internal pure returns (string memory) {
 307 |     |         return styleConcat(INVERSE, self);
 308 |     |     }
 309 |     | 
 310 |     |     function inverse(uint256 self) internal pure returns (string memory) {
 311 |     |         return inverse(vm.toString(self));
 312 |     |     }
 313 |     | 
 314 |     |     function inverse(int256 self) internal pure returns (string memory) {
 315 |     |         return inverse(vm.toString(self));
 316 |     |     }
 317 |     | 
 318 |     |     function inverse(address self) internal pure returns (string memory) {
 319 |     |         return inverse(vm.toString(self));
 320 |     |     }
 321 |     | 
 322 |     |     function inverse(bool self) internal pure returns (string memory) {
 323 |     |         return inverse(vm.toString(self));
 324 |     |     }
 325 |     | 
 326 |     |     function inverseBytes(bytes memory self) internal pure returns (string memory) {
 327 |     |         return inverse(vm.toString(self));
 328 |     |     }
 329 |     | 
 330 |     |     function inverseBytes32(bytes32 self) internal pure returns (string memory) {
 331 |     |         return inverse(vm.toString(self));
 332 |     |     }
 333 |     | }
 334 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdToml.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing TOML files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdToml for string;
  12 |     | // string memory toml = vm.readFile("<some_path>");
  13 |     | // toml.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdToml for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdToml {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {
  29 |     |         return vm.parseToml(toml, key);
  30 |     |     }
  31 |     | 
  32 |     |     function readUint(string memory toml, string memory key) internal pure returns (uint256) {
  33 |     |         return vm.parseTomlUint(toml, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {
  37 |     |         return vm.parseTomlUintArray(toml, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readInt(string memory toml, string memory key) internal pure returns (int256) {
  41 |     |         return vm.parseTomlInt(toml, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {
  45 |     |         return vm.parseTomlIntArray(toml, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {
  49 |     |         return vm.parseTomlBytes32(toml, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {
  53 |     |         return vm.parseTomlBytes32Array(toml, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readString(string memory toml, string memory key) internal pure returns (string memory) {
  57 |     |         return vm.parseTomlString(toml, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {
  61 |     |         return vm.parseTomlStringArray(toml, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readAddress(string memory toml, string memory key) internal pure returns (address) {
  65 |     |         return vm.parseTomlAddress(toml, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {
  69 |     |         return vm.parseTomlAddressArray(toml, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readBool(string memory toml, string memory key) internal pure returns (bool) {
  73 |     |         return vm.parseTomlBool(toml, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {
  77 |     |         return vm.parseTomlBoolArray(toml, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {
  81 |     |         return vm.parseTomlBytes(toml, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {
  85 |     |         return vm.parseTomlBytesArray(toml, key);
  86 |     |     }
  87 |     | 
  88 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
  89 |     |         return vm.serializeJson(jsonKey, rootObject);
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  93 |     |         return vm.serializeBool(jsonKey, key, value);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
  97 |     |         internal
  98 |     |         returns (string memory)
  99 |     |     {
 100 |     |         return vm.serializeBool(jsonKey, key, value);
 101 |     |     }
 102 |     | 
 103 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 104 |     |         return vm.serializeUint(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 108 |     |         internal
 109 |     |         returns (string memory)
 110 |     |     {
 111 |     |         return vm.serializeUint(jsonKey, key, value);
 112 |     |     }
 113 |     | 
 114 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 115 |     |         return vm.serializeInt(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 119 |     |         internal
 120 |     |         returns (string memory)
 121 |     |     {
 122 |     |         return vm.serializeInt(jsonKey, key, value);
 123 |     |     }
 124 |     | 
 125 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 126 |     |         return vm.serializeAddress(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 130 |     |         internal
 131 |     |         returns (string memory)
 132 |     |     {
 133 |     |         return vm.serializeAddress(jsonKey, key, value);
 134 |     |     }
 135 |     | 
 136 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 137 |     |         return vm.serializeBytes32(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 141 |     |         internal
 142 |     |         returns (string memory)
 143 |     |     {
 144 |     |         return vm.serializeBytes32(jsonKey, key, value);
 145 |     |     }
 146 |     | 
 147 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 148 |     |         return vm.serializeBytes(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 152 |     |         internal
 153 |     |         returns (string memory)
 154 |     |     {
 155 |     |         return vm.serializeBytes(jsonKey, key, value);
 156 |     |     }
 157 |     | 
 158 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 159 |     |         internal
 160 |     |         returns (string memory)
 161 |     |     {
 162 |     |         return vm.serializeString(jsonKey, key, value);
 163 |     |     }
 164 |     | 
 165 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 166 |     |         internal
 167 |     |         returns (string memory)
 168 |     |     {
 169 |     |         return vm.serializeString(jsonKey, key, value);
 170 |     |     }
 171 |     | 
 172 |     |     function write(string memory jsonKey, string memory path) internal {
 173 |     |         vm.writeToml(jsonKey, path);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 177 |     |         vm.writeToml(jsonKey, path, valueKey);
 178 |     |     }
 179 |     | }
 180 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
   7 |     | import {MockERC20} from "./mocks/MockERC20.sol";
   8 |     | import {MockERC721} from "./mocks/MockERC721.sol";
   9 |     | import {VmSafe} from "./Vm.sol";
  10 |     | 
  11 |     | abstract contract StdUtils {
  12 |     |     /*//////////////////////////////////////////////////////////////////////////
  13 |     |                                      CONSTANTS
  14 |     |     //////////////////////////////////////////////////////////////////////////*/
  15 |     | 
  16 |     |     IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
  17 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  18 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  19 |     |     uint256 private constant INT256_MIN_ABS =
  20 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  21 |     |     uint256 private constant SECP256K1_ORDER =
  22 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
  23 |     |     uint256 private constant UINT256_MAX =
  24 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  25 |     | 
  26 |     |     // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
  27 |     |     address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
  28 |     | 
  29 |     |     /*//////////////////////////////////////////////////////////////////////////
  30 |     |                                  INTERNAL FUNCTIONS
  31 |     |     //////////////////////////////////////////////////////////////////////////*/
  32 |     | 
  33 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  34 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  35 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  36 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  37 |     |         if (x >= min && x <= max) return x;
  38 |     | 
  39 |     |         uint256 size = max - min + 1;
  40 |     | 
  41 |     |         // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  42 |     |         // This helps ensure coverage of the min/max values.
  43 |     |         if (x <= 3 && size > x) return min + x;
  44 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  45 |     | 
  46 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  47 |     |         if (x > max) {
  48 |     |             uint256 diff = x - max;
  49 |     |             uint256 rem = diff % size;
  50 |     |             if (rem == 0) return max;
  51 |     |             result = min + rem - 1;
  52 |     |         } else if (x < min) {
  53 |     |             uint256 diff = min - x;
  54 |     |             uint256 rem = diff % size;
  55 |     |             if (rem == 0) return min;
  56 |     |             result = max - rem + 1;
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  61 |     |         result = _bound(x, min, max);
  62 |     |         console2_log_StdUtils("Bound result", result);
  63 |     |     }
  64 |     | 
  65 |     |     function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  66 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  67 |     | 
  68 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  69 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  70 |     |         // uint256:     0     ~ (2**256 - 1)
  71 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  72 |     |         //
  73 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  74 |     |         // So, use `~uint256(x) + 1` instead.
  75 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  76 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  77 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  78 |     | 
  79 |     |         uint256 y = _bound(_x, _min, _max);
  80 |     | 
  81 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  82 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  83 |     |     }
  84 |     | 
  85 |     |     function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  86 |     |         result = _bound(x, min, max);
  87 |     |         console2_log_StdUtils("Bound result", vm.toString(result));
  88 |     |     }
  89 |     | 
  90 |     |     function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {
  91 |     |         result = _bound(privateKey, 1, SECP256K1_ORDER - 1);
  92 |     |     }
  93 |     | 
  94 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
  95 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
  96 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
  97 |     |     }
  98 |     | 
  99 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
 100 |     |     /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
 101 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
 102 |     |         console2_log_StdUtils("computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.");
 103 |     |         return vm.computeCreateAddress(deployer, nonce);
 104 |     |     }
 105 |     | 
 106 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
 107 |     |         internal
 108 |     |         pure
 109 |     |         virtual
 110 |     |         returns (address)
 111 |     |     {
 112 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 113 |     |         return vm.computeCreate2Address(salt, initcodeHash, deployer);
 114 |     |     }
 115 |     | 
 116 |     |     /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer
 117 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
 118 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 119 |     |         return vm.computeCreate2Address(salt, initCodeHash);
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev returns an initialized mock ERC20 contract
 123 |     |     function deployMockERC20(string memory name, string memory symbol, uint8 decimals)
 124 |     |         internal
 125 |     |         returns (MockERC20 mock)
 126 |     |     {
 127 |     |         mock = new MockERC20();
 128 |     |         mock.initialize(name, symbol, decimals);
 129 |     |     }
 130 |     | 
 131 |     |     /// @dev returns an initialized mock ERC721 contract
 132 |     |     function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {
 133 |     |         mock = new MockERC721();
 134 |     |         mock.initialize(name, symbol);
 135 |     |     }
 136 |     | 
 137 |     |     /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments
 138 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 139 |     |     function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {
 140 |     |         return hashInitCode(creationCode, "");
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2
 144 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 145 |     |     /// @param args the ABI-encoded arguments to the constructor of C
 146 |     |     function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {
 147 |     |         return keccak256(abi.encodePacked(creationCode, args));
 148 |     |     }
 149 |     | 
 150 |     |     // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.
 151 |     |     function getTokenBalances(address token, address[] memory addresses)
 152 |     |         internal
 153 |     |         virtual
 154 |     |         returns (uint256[] memory balances)
 155 |     |     {
 156 |     |         uint256 tokenCodeSize;
 157 |     |         assembly {
 158 |     |             tokenCodeSize := extcodesize(token)
 159 |     |         }
 160 |     |         require(tokenCodeSize > 0, "StdUtils getTokenBalances(address,address[]): Token address is not a contract.");
 161 |     | 
 162 |     |         // ABI encode the aggregate call to Multicall3.
 163 |     |         uint256 length = addresses.length;
 164 |     |         IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);
 165 |     |         for (uint256 i = 0; i < length; ++i) {
 166 |     |             // 0x70a08231 = bytes4("balanceOf(address)"))
 167 |     |             calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});
 168 |     |         }
 169 |     | 
 170 |     |         // Make the aggregate call.
 171 |     |         (, bytes[] memory returnData) = multicall.aggregate(calls);
 172 |     | 
 173 |     |         // ABI decode the return data and return the balances.
 174 |     |         balances = new uint256[](length);
 175 |     |         for (uint256 i = 0; i < length; ++i) {
 176 |     |             balances[i] = abi.decode(returnData[i], (uint256));
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     /*//////////////////////////////////////////////////////////////////////////
 181 |     |                                  PRIVATE FUNCTIONS
 182 |     |     //////////////////////////////////////////////////////////////////////////*/
 183 |     | 
 184 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 185 |     |         return address(uint160(uint256(bytesValue)));
 186 |     |     }
 187 |     | 
 188 |     |     // This section is used to prevent the compilation of console, which shortens the compilation time when console is
 189 |     |     // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid
 190 |     |     // any breaking changes to function signatures.
 191 |     |     function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)
 192 |     |         internal
 193 |     |         pure
 194 |     |         returns (function(bytes memory) internal pure fnOut)
 195 |     |     {
 196 |     |         assembly {
 197 |     |             fnOut := fnIn
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 |     |     function _sendLogPayload(bytes memory payload) internal pure {
 202 |     |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
 203 |     |     }
 204 |     | 
 205 |     |     function _sendLogPayloadView(bytes memory payload) private view {
 206 |     |         uint256 payloadLength = payload.length;
 207 |     |         address consoleAddress = CONSOLE2_ADDRESS;
 208 |     |         /// @solidity memory-safe-assembly
 209 |     |         assembly {
 210 |     |             let payloadStart := add(payload, 32)
 211 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     function console2_log_StdUtils(string memory p0) private pure {
 216 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
 217 |     |     }
 218 |     | 
 219 |     |     function console2_log_StdUtils(string memory p0, uint256 p1) private pure {
 220 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 221 |     |     }
 222 |     | 
 223 |     |     function console2_log_StdUtils(string memory p0, string memory p1) private pure {
 224 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
 225 |     |     }
 226 |     | }
 227 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | // 💬 ABOUT
  7 |     | // Forge Std's default Test.
  8 |     | 
  9 |     | // 🧩 MODULES
 10 |     | import {console} from "./console.sol";
 11 |     | import {console2} from "./console2.sol";
 12 |     | import {safeconsole} from "./safeconsole.sol";
 13 |     | import {StdAssertions} from "./StdAssertions.sol";
 14 |     | import {StdChains} from "./StdChains.sol";
 15 |     | import {StdCheats} from "./StdCheats.sol";
 16 |     | import {stdError} from "./StdError.sol";
 17 |     | import {StdInvariant} from "./StdInvariant.sol";
 18 |     | import {stdJson} from "./StdJson.sol";
 19 |     | import {stdMath} from "./StdMath.sol";
 20 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 21 |     | import {StdStyle} from "./StdStyle.sol";
 22 |     | import {stdToml} from "./StdToml.sol";
 23 |     | import {StdUtils} from "./StdUtils.sol";
 24 |     | import {Vm} from "./Vm.sol";
 25 |     | 
 26 |     | // 📦 BOILERPLATE
 27 |     | import {TestBase} from "./Base.sol";
 28 |     | 
 29 |     | // ⭐️ TEST
 30 |     | abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {
 31 |     |     // Note: IS_TEST() must return true.
 32 | *   |     bool public IS_TEST = true;
 33 |     | }
 34 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/Vm.sol
    1 |     | // Automatically @generated by scripts/vm.py. Do not modify manually.
    2 |     | 
    3 |     | // SPDX-License-Identifier: MIT OR Apache-2.0
    4 |     | pragma solidity >=0.6.2 <0.9.0;
    5 |     | pragma experimental ABIEncoderV2;
    6 |     | 
    7 |     | /// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may
    8 |     | /// result in Script simulations differing from on-chain execution. It is recommended to only use
    9 |     | /// these cheats in scripts.
   10 |     | interface VmSafe {
   11 |     |     /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.
   12 |     |     enum CallerMode {
   13 |     |         // No caller modification is currently active.
   14 |     |         None,
   15 |     |         // A one time broadcast triggered by a `vm.broadcast()` call is currently active.
   16 |     |         Broadcast,
   17 |     |         // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.
   18 |     |         RecurrentBroadcast,
   19 |     |         // A one time prank triggered by a `vm.prank()` call is currently active.
   20 |     |         Prank,
   21 |     |         // A recurrent prank triggered by a `vm.startPrank()` call is currently active.
   22 |     |         RecurrentPrank
   23 |     |     }
   24 |     | 
   25 |     |     /// The kind of account access that occurred.
   26 |     |     enum AccountAccessKind {
   27 |     |         // The account was called.
   28 |     |         Call,
   29 |     |         // The account was called via delegatecall.
   30 |     |         DelegateCall,
   31 |     |         // The account was called via callcode.
   32 |     |         CallCode,
   33 |     |         // The account was called via staticcall.
   34 |     |         StaticCall,
   35 |     |         // The account was created.
   36 |     |         Create,
   37 |     |         // The account was selfdestructed.
   38 |     |         SelfDestruct,
   39 |     |         // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).
   40 |     |         Resume,
   41 |     |         // The account's balance was read.
   42 |     |         Balance,
   43 |     |         // The account's codesize was read.
   44 |     |         Extcodesize,
   45 |     |         // The account's codehash was read.
   46 |     |         Extcodehash,
   47 |     |         // The account's code was copied.
   48 |     |         Extcodecopy
   49 |     |     }
   50 |     | 
   51 |     |     /// Forge execution contexts.
   52 |     |     enum ForgeContext {
   53 |     |         // Test group execution context (test, coverage or snapshot).
   54 |     |         TestGroup,
   55 |     |         // `forge test` execution context.
   56 |     |         Test,
   57 |     |         // `forge coverage` execution context.
   58 |     |         Coverage,
   59 |     |         // `forge snapshot` execution context.
   60 |     |         Snapshot,
   61 |     |         // Script group execution context (dry run, broadcast or resume).
   62 |     |         ScriptGroup,
   63 |     |         // `forge script` execution context.
   64 |     |         ScriptDryRun,
   65 |     |         // `forge script --broadcast` execution context.
   66 |     |         ScriptBroadcast,
   67 |     |         // `forge script --resume` execution context.
   68 |     |         ScriptResume,
   69 |     |         // Unknown `forge` execution context.
   70 |     |         Unknown
   71 |     |     }
   72 |     | 
   73 |     |     /// An Ethereum log. Returned by `getRecordedLogs`.
   74 |     |     struct Log {
   75 |     |         // The topics of the log, including the signature, if any.
   76 |     |         bytes32[] topics;
   77 |     |         // The raw data of the log.
   78 |     |         bytes data;
   79 |     |         // The address of the log's emitter.
   80 |     |         address emitter;
   81 |     |     }
   82 |     | 
   83 |     |     /// An RPC URL and its alias. Returned by `rpcUrlStructs`.
   84 |     |     struct Rpc {
   85 |     |         // The alias of the RPC URL.
   86 |     |         string key;
   87 |     |         // The RPC URL.
   88 |     |         string url;
   89 |     |     }
   90 |     | 
   91 |     |     /// An RPC log object. Returned by `eth_getLogs`.
   92 |     |     struct EthGetLogs {
   93 |     |         // The address of the log's emitter.
   94 |     |         address emitter;
   95 |     |         // The topics of the log, including the signature, if any.
   96 |     |         bytes32[] topics;
   97 |     |         // The raw data of the log.
   98 |     |         bytes data;
   99 |     |         // The block hash.
  100 |     |         bytes32 blockHash;
  101 |     |         // The block number.
  102 |     |         uint64 blockNumber;
  103 |     |         // The transaction hash.
  104 |     |         bytes32 transactionHash;
  105 |     |         // The transaction index in the block.
  106 |     |         uint64 transactionIndex;
  107 |     |         // The log index.
  108 |     |         uint256 logIndex;
  109 |     |         // Whether the log was removed.
  110 |     |         bool removed;
  111 |     |     }
  112 |     | 
  113 |     |     /// A single entry in a directory listing. Returned by `readDir`.
  114 |     |     struct DirEntry {
  115 |     |         // The error message, if any.
  116 |     |         string errorMessage;
  117 |     |         // The path of the entry.
  118 |     |         string path;
  119 |     |         // The depth of the entry.
  120 |     |         uint64 depth;
  121 |     |         // Whether the entry is a directory.
  122 |     |         bool isDir;
  123 |     |         // Whether the entry is a symlink.
  124 |     |         bool isSymlink;
  125 |     |     }
  126 |     | 
  127 |     |     /// Metadata information about a file.
  128 |     |     /// This structure is returned from the `fsMetadata` function and represents known
  129 |     |     /// metadata about a file such as its permissions, size, modification
  130 |     |     /// times, etc.
  131 |     |     struct FsMetadata {
  132 |     |         // True if this metadata is for a directory.
  133 |     |         bool isDir;
  134 |     |         // True if this metadata is for a symlink.
  135 |     |         bool isSymlink;
  136 |     |         // The size of the file, in bytes, this metadata is for.
  137 |     |         uint256 length;
  138 |     |         // True if this metadata is for a readonly (unwritable) file.
  139 |     |         bool readOnly;
  140 |     |         // The last modification time listed in this metadata.
  141 |     |         uint256 modified;
  142 |     |         // The last access time of this metadata.
  143 |     |         uint256 accessed;
  144 |     |         // The creation time listed in this metadata.
  145 |     |         uint256 created;
  146 |     |     }
  147 |     | 
  148 |     |     /// A wallet with a public and private key.
  149 |     |     struct Wallet {
  150 |     |         // The wallet's address.
  151 |     |         address addr;
  152 |     |         // The wallet's public key `X`.
  153 |     |         uint256 publicKeyX;
  154 |     |         // The wallet's public key `Y`.
  155 |     |         uint256 publicKeyY;
  156 |     |         // The wallet's private key.
  157 |     |         uint256 privateKey;
  158 |     |     }
  159 |     | 
  160 |     |     /// The result of a `tryFfi` call.
  161 |     |     struct FfiResult {
  162 |     |         // The exit code of the call.
  163 |     |         int32 exitCode;
  164 |     |         // The optionally hex-decoded `stdout` data.
  165 |     |         bytes stdout;
  166 |     |         // The `stderr` data.
  167 |     |         bytes stderr;
  168 |     |     }
  169 |     | 
  170 |     |     /// Information on the chain and fork.
  171 |     |     struct ChainInfo {
  172 |     |         // The fork identifier. Set to zero if no fork is active.
  173 |     |         uint256 forkId;
  174 |     |         // The chain ID of the current fork.
  175 |     |         uint256 chainId;
  176 |     |     }
  177 |     | 
  178 |     |     /// The result of a `stopAndReturnStateDiff` call.
  179 |     |     struct AccountAccess {
  180 |     |         // The chain and fork the access occurred.
  181 |     |         ChainInfo chainInfo;
  182 |     |         // The kind of account access that determines what the account is.
  183 |     |         // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.
  184 |     |         // If kind is Create, then the account is the newly created account.
  185 |     |         // If kind is SelfDestruct, then the account is the selfdestruct recipient.
  186 |     |         // If kind is a Resume, then account represents a account context that has resumed.
  187 |     |         AccountAccessKind kind;
  188 |     |         // The account that was accessed.
  189 |     |         // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.
  190 |     |         address account;
  191 |     |         // What accessed the account.
  192 |     |         address accessor;
  193 |     |         // If the account was initialized or empty prior to the access.
  194 |     |         // An account is considered initialized if it has code, a
  195 |     |         // non-zero nonce, or a non-zero balance.
  196 |     |         bool initialized;
  197 |     |         // The previous balance of the accessed account.
  198 |     |         uint256 oldBalance;
  199 |     |         // The potential new balance of the accessed account.
  200 |     |         // That is, all balance changes are recorded here, even if reverts occurred.
  201 |     |         uint256 newBalance;
  202 |     |         // Code of the account deployed by CREATE.
  203 |     |         bytes deployedCode;
  204 |     |         // Value passed along with the account access
  205 |     |         uint256 value;
  206 |     |         // Input data provided to the CREATE or CALL
  207 |     |         bytes data;
  208 |     |         // If this access reverted in either the current or parent context.
  209 |     |         bool reverted;
  210 |     |         // An ordered list of storage accesses made during an account access operation.
  211 |     |         StorageAccess[] storageAccesses;
  212 |     |         // Call depth traversed during the recording of state differences
  213 |     |         uint64 depth;
  214 |     |     }
  215 |     | 
  216 |     |     /// The storage accessed during an `AccountAccess`.
  217 |     |     struct StorageAccess {
  218 |     |         // The account whose storage was accessed.
  219 |     |         address account;
  220 |     |         // The slot that was accessed.
  221 |     |         bytes32 slot;
  222 |     |         // If the access was a write.
  223 |     |         bool isWrite;
  224 |     |         // The previous value of the slot.
  225 |     |         bytes32 previousValue;
  226 |     |         // The new value of the slot.
  227 |     |         bytes32 newValue;
  228 |     |         // If the access was reverted.
  229 |     |         bool reverted;
  230 |     |     }
  231 |     | 
  232 |     |     /// Gas used. Returned by `lastCallGas`.
  233 |     |     struct Gas {
  234 |     |         // The gas limit of the call.
  235 |     |         uint64 gasLimit;
  236 |     |         // The total gas used.
  237 |     |         uint64 gasTotalUsed;
  238 |     |         // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>
  239 |     |         uint64 gasMemoryUsed;
  240 |     |         // The amount of gas refunded.
  241 |     |         int64 gasRefunded;
  242 |     |         // The amount of gas remaining.
  243 |     |         uint64 gasRemaining;
  244 |     |     }
  245 |     | 
  246 |     |     // ======== Environment ========
  247 |     | 
  248 |     |     /// Gets the environment variable `name` and parses it as `address`.
  249 |     |     /// Reverts if the variable was not found or could not be parsed.
  250 |     |     function envAddress(string calldata name) external view returns (address value);
  251 |     | 
  252 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  253 |     |     /// Reverts if the variable was not found or could not be parsed.
  254 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  255 |     | 
  256 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  257 |     |     /// Reverts if the variable was not found or could not be parsed.
  258 |     |     function envBool(string calldata name) external view returns (bool value);
  259 |     | 
  260 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  261 |     |     /// Reverts if the variable was not found or could not be parsed.
  262 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  263 |     | 
  264 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  265 |     |     /// Reverts if the variable was not found or could not be parsed.
  266 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  267 |     | 
  268 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  269 |     |     /// Reverts if the variable was not found or could not be parsed.
  270 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  271 |     | 
  272 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  273 |     |     /// Reverts if the variable was not found or could not be parsed.
  274 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  275 |     | 
  276 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  277 |     |     /// Reverts if the variable was not found or could not be parsed.
  278 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  279 |     | 
  280 |     |     /// Gets the environment variable `name` and returns true if it exists, else returns false.
  281 |     |     function envExists(string calldata name) external view returns (bool result);
  282 |     | 
  283 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  284 |     |     /// Reverts if the variable was not found or could not be parsed.
  285 |     |     function envInt(string calldata name) external view returns (int256 value);
  286 |     | 
  287 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  288 |     |     /// Reverts if the variable was not found or could not be parsed.
  289 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  290 |     | 
  291 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  292 |     |     /// Reverts if the variable could not be parsed.
  293 |     |     /// Returns `defaultValue` if the variable was not found.
  294 |     |     function envOr(string calldata name, bool defaultValue) external view returns (bool value);
  295 |     | 
  296 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  297 |     |     /// Reverts if the variable could not be parsed.
  298 |     |     /// Returns `defaultValue` if the variable was not found.
  299 |     |     function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);
  300 |     | 
  301 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  302 |     |     /// Reverts if the variable could not be parsed.
  303 |     |     /// Returns `defaultValue` if the variable was not found.
  304 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  305 |     |         external
  306 |     |         view
  307 |     |         returns (address[] memory value);
  308 |     | 
  309 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  310 |     |     /// Reverts if the variable could not be parsed.
  311 |     |     /// Returns `defaultValue` if the variable was not found.
  312 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  313 |     |         external
  314 |     |         view
  315 |     |         returns (bytes32[] memory value);
  316 |     | 
  317 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  318 |     |     /// Reverts if the variable could not be parsed.
  319 |     |     /// Returns `defaultValue` if the variable was not found.
  320 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  321 |     |         external
  322 |     |         view
  323 |     |         returns (string[] memory value);
  324 |     | 
  325 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  326 |     |     /// Reverts if the variable could not be parsed.
  327 |     |     /// Returns `defaultValue` if the variable was not found.
  328 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  329 |     |         external
  330 |     |         view
  331 |     |         returns (bytes[] memory value);
  332 |     | 
  333 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  334 |     |     /// Reverts if the variable could not be parsed.
  335 |     |     /// Returns `defaultValue` if the variable was not found.
  336 |     |     function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);
  337 |     | 
  338 |     |     /// Gets the environment variable `name` and parses it as `address`.
  339 |     |     /// Reverts if the variable could not be parsed.
  340 |     |     /// Returns `defaultValue` if the variable was not found.
  341 |     |     function envOr(string calldata name, address defaultValue) external view returns (address value);
  342 |     | 
  343 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  344 |     |     /// Reverts if the variable could not be parsed.
  345 |     |     /// Returns `defaultValue` if the variable was not found.
  346 |     |     function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);
  347 |     | 
  348 |     |     /// Gets the environment variable `name` and parses it as `string`.
  349 |     |     /// Reverts if the variable could not be parsed.
  350 |     |     /// Returns `defaultValue` if the variable was not found.
  351 |     |     function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);
  352 |     | 
  353 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  354 |     |     /// Reverts if the variable could not be parsed.
  355 |     |     /// Returns `defaultValue` if the variable was not found.
  356 |     |     function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);
  357 |     | 
  358 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  359 |     |     /// Reverts if the variable could not be parsed.
  360 |     |     /// Returns `defaultValue` if the variable was not found.
  361 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  362 |     |         external
  363 |     |         view
  364 |     |         returns (bool[] memory value);
  365 |     | 
  366 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  367 |     |     /// Reverts if the variable could not be parsed.
  368 |     |     /// Returns `defaultValue` if the variable was not found.
  369 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  370 |     |         external
  371 |     |         view
  372 |     |         returns (uint256[] memory value);
  373 |     | 
  374 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  375 |     |     /// Reverts if the variable could not be parsed.
  376 |     |     /// Returns `defaultValue` if the variable was not found.
  377 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  378 |     |         external
  379 |     |         view
  380 |     |         returns (int256[] memory value);
  381 |     | 
  382 |     |     /// Gets the environment variable `name` and parses it as `string`.
  383 |     |     /// Reverts if the variable was not found or could not be parsed.
  384 |     |     function envString(string calldata name) external view returns (string memory value);
  385 |     | 
  386 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  387 |     |     /// Reverts if the variable was not found or could not be parsed.
  388 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  389 |     | 
  390 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  391 |     |     /// Reverts if the variable was not found or could not be parsed.
  392 |     |     function envUint(string calldata name) external view returns (uint256 value);
  393 |     | 
  394 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  395 |     |     /// Reverts if the variable was not found or could not be parsed.
  396 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  397 |     | 
  398 |     |     /// Returns true if `forge` command was executed in given context.
  399 |     |     function isContext(ForgeContext context) external view returns (bool result);
  400 |     | 
  401 |     |     /// Sets environment variables.
  402 |     |     function setEnv(string calldata name, string calldata value) external;
  403 |     | 
  404 |     |     // ======== EVM ========
  405 |     | 
  406 |     |     /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.
  407 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  408 |     | 
  409 |     |     /// Gets the address for a given private key.
  410 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  411 |     | 
  412 |     |     /// Gets all the logs according to specified filter.
  413 |     |     function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)
  414 |     |         external
  415 |     |         returns (EthGetLogs[] memory logs);
  416 |     | 
  417 |     |     /// Gets the current `block.blobbasefee`.
  418 |     |     /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,
  419 |     |     /// and as a result will get optimized out by the compiler.
  420 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  421 |     |     function getBlobBaseFee() external view returns (uint256 blobBaseFee);
  422 |     | 
  423 |     |     /// Gets the current `block.number`.
  424 |     |     /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,
  425 |     |     /// and as a result will get optimized out by the compiler.
  426 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  427 |     |     function getBlockNumber() external view returns (uint256 height);
  428 |     | 
  429 |     |     /// Gets the current `block.timestamp`.
  430 |     |     /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,
  431 |     |     /// and as a result will get optimized out by the compiler.
  432 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  433 |     |     function getBlockTimestamp() external view returns (uint256 timestamp);
  434 |     | 
  435 |     |     /// Gets the map key and parent of a mapping at a given slot, for a given address.
  436 |     |     function getMappingKeyAndParentOf(address target, bytes32 elementSlot)
  437 |     |         external
  438 |     |         returns (bool found, bytes32 key, bytes32 parent);
  439 |     | 
  440 |     |     /// Gets the number of elements in the mapping at the given slot, for a given address.
  441 |     |     function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
  442 |     | 
  443 |     |     /// Gets the elements at index idx of the mapping at the given slot, for a given address. The
  444 |     |     /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).
  445 |     |     function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
  446 |     | 
  447 |     |     /// Gets the nonce of an account.
  448 |     |     function getNonce(address account) external view returns (uint64 nonce);
  449 |     | 
  450 |     |     /// Gets all the recorded logs.
  451 |     |     function getRecordedLogs() external returns (Log[] memory logs);
  452 |     | 
  453 |     |     /// Gets the gas used in the last call.
  454 |     |     function lastCallGas() external view returns (Gas memory gas);
  455 |     | 
  456 |     |     /// Loads a storage slot from an address.
  457 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  458 |     | 
  459 |     |     /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
  460 |     |     function pauseGasMetering() external;
  461 |     | 
  462 |     |     /// Records all storage reads and writes.
  463 |     |     function record() external;
  464 |     | 
  465 |     |     /// Record all the transaction logs.
  466 |     |     function recordLogs() external;
  467 |     | 
  468 |     |     /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
  469 |     |     function resumeGasMetering() external;
  470 |     | 
  471 |     |     /// Performs an Ethereum JSON-RPC request to the current fork URL.
  472 |     |     function rpc(string calldata method, string calldata params) external returns (bytes memory data);
  473 |     | 
  474 |     |     /// Signs `digest` with `privateKey` using the secp256r1 curve.
  475 |     |     function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
  476 |     | 
  477 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  478 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  479 |     | 
  480 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  481 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  482 |     |     /// if exactly one signer is provided to the script, that signer is used.
  483 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  484 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  485 |     |     function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  486 |     | 
  487 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  488 |     |     /// Raises error if none of the signers passed into the script have provided address.
  489 |     |     function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  490 |     | 
  491 |     |     /// Starts recording all map SSTOREs for later retrieval.
  492 |     |     function startMappingRecording() external;
  493 |     | 
  494 |     |     /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,
  495 |     |     /// along with the context of the calls
  496 |     |     function startStateDiffRecording() external;
  497 |     | 
  498 |     |     /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
  499 |     |     function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
  500 |     | 
  501 |     |     /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.
  502 |     |     function stopMappingRecording() external;
  503 |     | 
  504 |     |     // ======== Filesystem ========
  505 |     | 
  506 |     |     /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
  507 |     |     /// `path` is relative to the project root.
  508 |     |     function closeFile(string calldata path) external;
  509 |     | 
  510 |     |     /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.
  511 |     |     /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.
  512 |     |     /// Both `from` and `to` are relative to the project root.
  513 |     |     function copyFile(string calldata from, string calldata to) external returns (uint64 copied);
  514 |     | 
  515 |     |     /// Creates a new, empty directory at the provided path.
  516 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  517 |     |     /// - User lacks permissions to modify `path`.
  518 |     |     /// - A parent of the given path doesn't exist and `recursive` is false.
  519 |     |     /// - `path` already exists and `recursive` is false.
  520 |     |     /// `path` is relative to the project root.
  521 |     |     function createDir(string calldata path, bool recursive) external;
  522 |     | 
  523 |     |     /// Returns true if the given path points to an existing entity, else returns false.
  524 |     |     function exists(string calldata path) external returns (bool result);
  525 |     | 
  526 |     |     /// Performs a foreign function call via the terminal.
  527 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  528 |     | 
  529 |     |     /// Given a path, query the file system to get information about a file, directory, etc.
  530 |     |     function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);
  531 |     | 
  532 |     |     /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  533 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  534 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  535 |     | 
  536 |     |     /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  537 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  538 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
  539 |     | 
  540 |     |     /// Returns true if the path exists on disk and is pointing at a directory, else returns false.
  541 |     |     function isDir(string calldata path) external returns (bool result);
  542 |     | 
  543 |     |     /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.
  544 |     |     function isFile(string calldata path) external returns (bool result);
  545 |     | 
  546 |     |     /// Get the path of the current project root.
  547 |     |     function projectRoot() external view returns (string memory path);
  548 |     | 
  549 |     |     /// Prompts the user for a string value in the terminal.
  550 |     |     function prompt(string calldata promptText) external returns (string memory input);
  551 |     | 
  552 |     |     /// Prompts the user for an address in the terminal.
  553 |     |     function promptAddress(string calldata promptText) external returns (address);
  554 |     | 
  555 |     |     /// Prompts the user for a hidden string value in the terminal.
  556 |     |     function promptSecret(string calldata promptText) external returns (string memory input);
  557 |     | 
  558 |     |     /// Prompts the user for hidden uint256 in the terminal (usually pk).
  559 |     |     function promptSecretUint(string calldata promptText) external returns (uint256);
  560 |     | 
  561 |     |     /// Prompts the user for uint256 in the terminal.
  562 |     |     function promptUint(string calldata promptText) external returns (uint256);
  563 |     | 
  564 |     |     /// Reads the directory at the given path recursively, up to `maxDepth`.
  565 |     |     /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.
  566 |     |     /// Follows symbolic links if `followLinks` is true.
  567 |     |     function readDir(string calldata path) external view returns (DirEntry[] memory entries);
  568 |     | 
  569 |     |     /// See `readDir(string)`.
  570 |     |     function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
  571 |     | 
  572 |     |     /// See `readDir(string)`.
  573 |     |     function readDir(string calldata path, uint64 maxDepth, bool followLinks)
  574 |     |         external
  575 |     |         view
  576 |     |         returns (DirEntry[] memory entries);
  577 |     | 
  578 |     |     /// Reads the entire content of file to string. `path` is relative to the project root.
  579 |     |     function readFile(string calldata path) external view returns (string memory data);
  580 |     | 
  581 |     |     /// Reads the entire content of file as binary. `path` is relative to the project root.
  582 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
  583 |     | 
  584 |     |     /// Reads next line of file to string.
  585 |     |     function readLine(string calldata path) external view returns (string memory line);
  586 |     | 
  587 |     |     /// Reads a symbolic link, returning the path that the link points to.
  588 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  589 |     |     /// - `path` is not a symbolic link.
  590 |     |     /// - `path` does not exist.
  591 |     |     function readLink(string calldata linkPath) external view returns (string memory targetPath);
  592 |     | 
  593 |     |     /// Removes a directory at the provided path.
  594 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  595 |     |     /// - `path` doesn't exist.
  596 |     |     /// - `path` isn't a directory.
  597 |     |     /// - User lacks permissions to modify `path`.
  598 |     |     /// - The directory is not empty and `recursive` is false.
  599 |     |     /// `path` is relative to the project root.
  600 |     |     function removeDir(string calldata path, bool recursive) external;
  601 |     | 
  602 |     |     /// Removes a file from the filesystem.
  603 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  604 |     |     /// - `path` points to a directory.
  605 |     |     /// - The file doesn't exist.
  606 |     |     /// - The user lacks permissions to remove the file.
  607 |     |     /// `path` is relative to the project root.
  608 |     |     function removeFile(string calldata path) external;
  609 |     | 
  610 |     |     /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
  611 |     |     function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);
  612 |     | 
  613 |     |     /// Returns the time since unix epoch in milliseconds.
  614 |     |     function unixTime() external returns (uint256 milliseconds);
  615 |     | 
  616 |     |     /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
  617 |     |     /// `path` is relative to the project root.
  618 |     |     function writeFile(string calldata path, string calldata data) external;
  619 |     | 
  620 |     |     /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
  621 |     |     /// `path` is relative to the project root.
  622 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
  623 |     | 
  624 |     |     /// Writes line to file, creating a file if it does not exist.
  625 |     |     /// `path` is relative to the project root.
  626 |     |     function writeLine(string calldata path, string calldata data) external;
  627 |     | 
  628 |     |     // ======== JSON ========
  629 |     | 
  630 |     |     /// Checks if `key` exists in a JSON object
  631 |     |     /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
  632 |     |     function keyExists(string calldata json, string calldata key) external view returns (bool);
  633 |     | 
  634 |     |     /// Checks if `key` exists in a JSON object.
  635 |     |     function keyExistsJson(string calldata json, string calldata key) external view returns (bool);
  636 |     | 
  637 |     |     /// Parses a string of JSON data at `key` and coerces it to `address`.
  638 |     |     function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);
  639 |     | 
  640 |     |     /// Parses a string of JSON data at `key` and coerces it to `address[]`.
  641 |     |     function parseJsonAddressArray(string calldata json, string calldata key)
  642 |     |         external
  643 |     |         pure
  644 |     |         returns (address[] memory);
  645 |     | 
  646 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool`.
  647 |     |     function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);
  648 |     | 
  649 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool[]`.
  650 |     |     function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);
  651 |     | 
  652 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes`.
  653 |     |     function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);
  654 |     | 
  655 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32`.
  656 |     |     function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);
  657 |     | 
  658 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
  659 |     |     function parseJsonBytes32Array(string calldata json, string calldata key)
  660 |     |         external
  661 |     |         pure
  662 |     |         returns (bytes32[] memory);
  663 |     | 
  664 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.
  665 |     |     function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);
  666 |     | 
  667 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256`.
  668 |     |     function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);
  669 |     | 
  670 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256[]`.
  671 |     |     function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);
  672 |     | 
  673 |     |     /// Returns an array of all the keys in a JSON object.
  674 |     |     function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);
  675 |     | 
  676 |     |     /// Parses a string of JSON data at `key` and coerces it to `string`.
  677 |     |     function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);
  678 |     | 
  679 |     |     /// Parses a string of JSON data at `key` and coerces it to `string[]`.
  680 |     |     function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);
  681 |     | 
  682 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256`.
  683 |     |     function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);
  684 |     | 
  685 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.
  686 |     |     function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);
  687 |     | 
  688 |     |     /// ABI-encodes a JSON object.
  689 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
  690 |     | 
  691 |     |     /// ABI-encodes a JSON object at `key`.
  692 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
  693 |     | 
  694 |     |     /// See `serializeJson`.
  695 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
  696 |     |         external
  697 |     |         returns (string memory json);
  698 |     | 
  699 |     |     /// See `serializeJson`.
  700 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
  701 |     |         external
  702 |     |         returns (string memory json);
  703 |     | 
  704 |     |     /// See `serializeJson`.
  705 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
  706 |     |         external
  707 |     |         returns (string memory json);
  708 |     | 
  709 |     |     /// See `serializeJson`.
  710 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
  711 |     |         external
  712 |     |         returns (string memory json);
  713 |     | 
  714 |     |     /// See `serializeJson`.
  715 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
  716 |     |         external
  717 |     |         returns (string memory json);
  718 |     | 
  719 |     |     /// See `serializeJson`.
  720 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
  721 |     |         external
  722 |     |         returns (string memory json);
  723 |     | 
  724 |     |     /// See `serializeJson`.
  725 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
  726 |     |         external
  727 |     |         returns (string memory json);
  728 |     | 
  729 |     |     /// See `serializeJson`.
  730 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
  731 |     |         external
  732 |     |         returns (string memory json);
  733 |     | 
  734 |     |     /// See `serializeJson`.
  735 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
  736 |     |         external
  737 |     |         returns (string memory json);
  738 |     | 
  739 |     |     /// See `serializeJson`.
  740 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
  741 |     |         external
  742 |     |         returns (string memory json);
  743 |     | 
  744 |     |     /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.
  745 |     |     /// Returns the stringified version of the specific JSON file up to that moment.
  746 |     |     function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);
  747 |     | 
  748 |     |     /// See `serializeJson`.
  749 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
  750 |     |         external
  751 |     |         returns (string memory json);
  752 |     | 
  753 |     |     /// See `serializeJson`.
  754 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
  755 |     |         external
  756 |     |         returns (string memory json);
  757 |     | 
  758 |     |     /// See `serializeJson`.
  759 |     |     function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)
  760 |     |         external
  761 |     |         returns (string memory json);
  762 |     | 
  763 |     |     /// See `serializeJson`.
  764 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
  765 |     |         external
  766 |     |         returns (string memory json);
  767 |     | 
  768 |     |     /// See `serializeJson`.
  769 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
  770 |     |         external
  771 |     |         returns (string memory json);
  772 |     | 
  773 |     |     /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.
  774 |     |     function writeJson(string calldata json, string calldata path) external;
  775 |     | 
  776 |     |     /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>
  777 |     |     /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
  778 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
  779 |     | 
  780 |     |     // ======== Scripting ========
  781 |     | 
  782 |     |     /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.
  783 |     |     /// Broadcasting address is determined by checking the following in order:
  784 |     |     /// 1. If `--sender` argument was provided, that address is used.
  785 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
  786 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
  787 |     |     function broadcast() external;
  788 |     | 
  789 |     |     /// Has the next call (at this call depth only) create a transaction with the address provided
  790 |     |     /// as the sender that can later be signed and sent onchain.
  791 |     |     function broadcast(address signer) external;
  792 |     | 
  793 |     |     /// Has the next call (at this call depth only) create a transaction with the private key
  794 |     |     /// provided as the sender that can later be signed and sent onchain.
  795 |     |     function broadcast(uint256 privateKey) external;
  796 |     | 
  797 |     |     /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.
  798 |     |     /// Broadcasting address is determined by checking the following in order:
  799 |     |     /// 1. If `--sender` argument was provided, that address is used.
  800 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
  801 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
  802 |     |     function startBroadcast() external;
  803 |     | 
  804 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the address
  805 |     |     /// provided that can later be signed and sent onchain.
  806 |     |     function startBroadcast(address signer) external;
  807 |     | 
  808 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the private key
  809 |     |     /// provided that can later be signed and sent onchain.
  810 |     |     function startBroadcast(uint256 privateKey) external;
  811 |     | 
  812 |     |     /// Stops collecting onchain transactions.
  813 |     |     function stopBroadcast() external;
  814 |     | 
  815 |     |     // ======== String ========
  816 |     | 
  817 |     |     /// Returns the index of the first occurrence of a `key` in an `input` string.
  818 |     |     /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.
  819 |     |     /// Returns 0 in case of an empty `key`.
  820 |     |     function indexOf(string calldata input, string calldata key) external pure returns (uint256);
  821 |     | 
  822 |     |     /// Parses the given `string` into an `address`.
  823 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
  824 |     | 
  825 |     |     /// Parses the given `string` into a `bool`.
  826 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
  827 |     | 
  828 |     |     /// Parses the given `string` into `bytes`.
  829 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
  830 |     | 
  831 |     |     /// Parses the given `string` into a `bytes32`.
  832 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
  833 |     | 
  834 |     |     /// Parses the given `string` into a `int256`.
  835 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
  836 |     | 
  837 |     |     /// Parses the given `string` into a `uint256`.
  838 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
  839 |     | 
  840 |     |     /// Replaces occurrences of `from` in the given `string` with `to`.
  841 |     |     function replace(string calldata input, string calldata from, string calldata to)
  842 |     |         external
  843 |     |         pure
  844 |     |         returns (string memory output);
  845 |     | 
  846 |     |     /// Splits the given `string` into an array of strings divided by the `delimiter`.
  847 |     |     function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);
  848 |     | 
  849 |     |     /// Converts the given `string` value to Lowercase.
  850 |     |     function toLowercase(string calldata input) external pure returns (string memory output);
  851 |     | 
  852 |     |     /// Converts the given value to a `string`.
  853 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
  854 |     | 
  855 |     |     /// Converts the given value to a `string`.
  856 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
  857 |     | 
  858 |     |     /// Converts the given value to a `string`.
  859 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
  860 |     | 
  861 |     |     /// Converts the given value to a `string`.
  862 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
  863 |     | 
  864 |     |     /// Converts the given value to a `string`.
  865 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
  866 |     | 
  867 |     |     /// Converts the given value to a `string`.
  868 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
  869 |     | 
  870 |     |     /// Converts the given `string` value to Uppercase.
  871 |     |     function toUppercase(string calldata input) external pure returns (string memory output);
  872 |     | 
  873 |     |     /// Trims leading and trailing whitespace from the given `string` value.
  874 |     |     function trim(string calldata input) external pure returns (string memory output);
  875 |     | 
  876 |     |     // ======== Testing ========
  877 |     | 
  878 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  879 |     |     /// Formats values with decimals in failure message.
  880 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;
  881 |     | 
  882 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  883 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  884 |     |     function assertApproxEqAbsDecimal(
  885 |     |         uint256 left,
  886 |     |         uint256 right,
  887 |     |         uint256 maxDelta,
  888 |     |         uint256 decimals,
  889 |     |         string calldata error
  890 |     |     ) external pure;
  891 |     | 
  892 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  893 |     |     /// Formats values with decimals in failure message.
  894 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;
  895 |     | 
  896 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  897 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  898 |     |     function assertApproxEqAbsDecimal(
  899 |     |         int256 left,
  900 |     |         int256 right,
  901 |     |         uint256 maxDelta,
  902 |     |         uint256 decimals,
  903 |     |         string calldata error
  904 |     |     ) external pure;
  905 |     | 
  906 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  907 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;
  908 |     | 
  909 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  910 |     |     /// Includes error message into revert string on failure.
  911 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;
  912 |     | 
  913 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  914 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;
  915 |     | 
  916 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  917 |     |     /// Includes error message into revert string on failure.
  918 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;
  919 |     | 
  920 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  921 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  922 |     |     /// Formats values with decimals in failure message.
  923 |     |     function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)
  924 |     |         external
  925 |     |         pure;
  926 |     | 
  927 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  928 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  929 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  930 |     |     function assertApproxEqRelDecimal(
  931 |     |         uint256 left,
  932 |     |         uint256 right,
  933 |     |         uint256 maxPercentDelta,
  934 |     |         uint256 decimals,
  935 |     |         string calldata error
  936 |     |     ) external pure;
  937 |     | 
  938 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  939 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  940 |     |     /// Formats values with decimals in failure message.
  941 |     |     function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)
  942 |     |         external
  943 |     |         pure;
  944 |     | 
  945 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  946 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  947 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  948 |     |     function assertApproxEqRelDecimal(
  949 |     |         int256 left,
  950 |     |         int256 right,
  951 |     |         uint256 maxPercentDelta,
  952 |     |         uint256 decimals,
  953 |     |         string calldata error
  954 |     |     ) external pure;
  955 |     | 
  956 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  957 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  958 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;
  959 |     | 
  960 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  961 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  962 |     |     /// Includes error message into revert string on failure.
  963 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)
  964 |     |         external
  965 |     |         pure;
  966 |     | 
  967 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  968 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  969 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;
  970 |     | 
  971 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  972 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  973 |     |     /// Includes error message into revert string on failure.
  974 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)
  975 |     |         external
  976 |     |         pure;
  977 |     | 
  978 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
  979 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
  980 |     | 
  981 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
  982 |     |     /// Includes error message into revert string on failure.
  983 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
  984 |     | 
  985 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
  986 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
  987 |     | 
  988 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
  989 |     |     /// Includes error message into revert string on failure.
  990 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
  991 |     | 
  992 |     |     /// Asserts that two `bool` values are equal.
  993 |     |     function assertEq(bool left, bool right) external pure;
  994 |     | 
  995 |     |     /// Asserts that two `bool` values are equal and includes error message into revert string on failure.
  996 |     |     function assertEq(bool left, bool right, string calldata error) external pure;
  997 |     | 
  998 |     |     /// Asserts that two `string` values are equal.
  999 |     |     function assertEq(string calldata left, string calldata right) external pure;
 1000 |     | 
 1001 |     |     /// Asserts that two `string` values are equal and includes error message into revert string on failure.
 1002 |     |     function assertEq(string calldata left, string calldata right, string calldata error) external pure;
 1003 |     | 
 1004 |     |     /// Asserts that two `bytes` values are equal.
 1005 |     |     function assertEq(bytes calldata left, bytes calldata right) external pure;
 1006 |     | 
 1007 |     |     /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.
 1008 |     |     function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1009 |     | 
 1010 |     |     /// Asserts that two arrays of `bool` values are equal.
 1011 |     |     function assertEq(bool[] calldata left, bool[] calldata right) external pure;
 1012 |     | 
 1013 |     |     /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
 1014 |     |     function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1015 |     | 
 1016 |     |     /// Asserts that two arrays of `uint256 values are equal.
 1017 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1018 |     | 
 1019 |     |     /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
 1020 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1021 |     | 
 1022 |     |     /// Asserts that two arrays of `int256` values are equal.
 1023 |     |     function assertEq(int256[] calldata left, int256[] calldata right) external pure;
 1024 |     | 
 1025 |     |     /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
 1026 |     |     function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1027 |     | 
 1028 |     |     /// Asserts that two `uint256` values are equal.
 1029 |     |     function assertEq(uint256 left, uint256 right) external pure;
 1030 |     | 
 1031 |     |     /// Asserts that two arrays of `address` values are equal.
 1032 |     |     function assertEq(address[] calldata left, address[] calldata right) external pure;
 1033 |     | 
 1034 |     |     /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
 1035 |     |     function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1036 |     | 
 1037 |     |     /// Asserts that two arrays of `bytes32` values are equal.
 1038 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1039 |     | 
 1040 |     |     /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
 1041 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1042 |     | 
 1043 |     |     /// Asserts that two arrays of `string` values are equal.
 1044 |     |     function assertEq(string[] calldata left, string[] calldata right) external pure;
 1045 |     | 
 1046 |     |     /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
 1047 |     |     function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1048 |     | 
 1049 |     |     /// Asserts that two arrays of `bytes` values are equal.
 1050 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1051 |     | 
 1052 |     |     /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
 1053 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1054 |     | 
 1055 |     |     /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.
 1056 |     |     function assertEq(uint256 left, uint256 right, string calldata error) external pure;
 1057 |     | 
 1058 |     |     /// Asserts that two `int256` values are equal.
 1059 |     |     function assertEq(int256 left, int256 right) external pure;
 1060 |     | 
 1061 |     |     /// Asserts that two `int256` values are equal and includes error message into revert string on failure.
 1062 |     |     function assertEq(int256 left, int256 right, string calldata error) external pure;
 1063 |     | 
 1064 |     |     /// Asserts that two `address` values are equal.
 1065 |     |     function assertEq(address left, address right) external pure;
 1066 |     | 
 1067 |     |     /// Asserts that two `address` values are equal and includes error message into revert string on failure.
 1068 |     |     function assertEq(address left, address right, string calldata error) external pure;
 1069 |     | 
 1070 |     |     /// Asserts that two `bytes32` values are equal.
 1071 |     |     function assertEq(bytes32 left, bytes32 right) external pure;
 1072 |     | 
 1073 |     |     /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
 1074 |     |     function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1075 |     | 
 1076 |     |     /// Asserts that the given condition is false.
 1077 |     |     function assertFalse(bool condition) external pure;
 1078 |     | 
 1079 |     |     /// Asserts that the given condition is false and includes error message into revert string on failure.
 1080 |     |     function assertFalse(bool condition, string calldata error) external pure;
 1081 |     | 
 1082 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1083 |     |     /// Formats values with decimals in failure message.
 1084 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1085 |     | 
 1086 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1087 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1088 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1089 |     | 
 1090 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1091 |     |     /// Formats values with decimals in failure message.
 1092 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1093 |     | 
 1094 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1095 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1096 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1097 |     | 
 1098 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1099 |     |     function assertGe(uint256 left, uint256 right) external pure;
 1100 |     | 
 1101 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1102 |     |     /// Includes error message into revert string on failure.
 1103 |     |     function assertGe(uint256 left, uint256 right, string calldata error) external pure;
 1104 |     | 
 1105 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1106 |     |     function assertGe(int256 left, int256 right) external pure;
 1107 |     | 
 1108 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1109 |     |     /// Includes error message into revert string on failure.
 1110 |     |     function assertGe(int256 left, int256 right, string calldata error) external pure;
 1111 |     | 
 1112 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1113 |     |     /// Formats values with decimals in failure message.
 1114 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1115 |     | 
 1116 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1117 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1118 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1119 |     | 
 1120 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1121 |     |     /// Formats values with decimals in failure message.
 1122 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1123 |     | 
 1124 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1125 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1126 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1127 |     | 
 1128 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1129 |     |     function assertGt(uint256 left, uint256 right) external pure;
 1130 |     | 
 1131 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1132 |     |     /// Includes error message into revert string on failure.
 1133 |     |     function assertGt(uint256 left, uint256 right, string calldata error) external pure;
 1134 |     | 
 1135 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1136 |     |     function assertGt(int256 left, int256 right) external pure;
 1137 |     | 
 1138 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1139 |     |     /// Includes error message into revert string on failure.
 1140 |     |     function assertGt(int256 left, int256 right, string calldata error) external pure;
 1141 |     | 
 1142 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1143 |     |     /// Formats values with decimals in failure message.
 1144 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1145 |     | 
 1146 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1147 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1148 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1149 |     | 
 1150 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1151 |     |     /// Formats values with decimals in failure message.
 1152 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1153 |     | 
 1154 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1155 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1156 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1157 |     | 
 1158 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1159 |     |     function assertLe(uint256 left, uint256 right) external pure;
 1160 |     | 
 1161 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1162 |     |     /// Includes error message into revert string on failure.
 1163 |     |     function assertLe(uint256 left, uint256 right, string calldata error) external pure;
 1164 |     | 
 1165 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1166 |     |     function assertLe(int256 left, int256 right) external pure;
 1167 |     | 
 1168 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1169 |     |     /// Includes error message into revert string on failure.
 1170 |     |     function assertLe(int256 left, int256 right, string calldata error) external pure;
 1171 |     | 
 1172 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1173 |     |     /// Formats values with decimals in failure message.
 1174 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1175 |     | 
 1176 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1177 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1178 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1179 |     | 
 1180 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1181 |     |     /// Formats values with decimals in failure message.
 1182 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1183 |     | 
 1184 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1185 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1186 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1187 |     | 
 1188 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1189 |     |     function assertLt(uint256 left, uint256 right) external pure;
 1190 |     | 
 1191 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1192 |     |     /// Includes error message into revert string on failure.
 1193 |     |     function assertLt(uint256 left, uint256 right, string calldata error) external pure;
 1194 |     | 
 1195 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1196 |     |     function assertLt(int256 left, int256 right) external pure;
 1197 |     | 
 1198 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1199 |     |     /// Includes error message into revert string on failure.
 1200 |     |     function assertLt(int256 left, int256 right, string calldata error) external pure;
 1201 |     | 
 1202 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1203 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1204 |     | 
 1205 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1206 |     |     /// Includes error message into revert string on failure.
 1207 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1208 |     | 
 1209 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1210 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1211 |     | 
 1212 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1213 |     |     /// Includes error message into revert string on failure.
 1214 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1215 |     | 
 1216 |     |     /// Asserts that two `bool` values are not equal.
 1217 |     |     function assertNotEq(bool left, bool right) external pure;
 1218 |     | 
 1219 |     |     /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.
 1220 |     |     function assertNotEq(bool left, bool right, string calldata error) external pure;
 1221 |     | 
 1222 |     |     /// Asserts that two `string` values are not equal.
 1223 |     |     function assertNotEq(string calldata left, string calldata right) external pure;
 1224 |     | 
 1225 |     |     /// Asserts that two `string` values are not equal and includes error message into revert string on failure.
 1226 |     |     function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;
 1227 |     | 
 1228 |     |     /// Asserts that two `bytes` values are not equal.
 1229 |     |     function assertNotEq(bytes calldata left, bytes calldata right) external pure;
 1230 |     | 
 1231 |     |     /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
 1232 |     |     function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1233 |     | 
 1234 |     |     /// Asserts that two arrays of `bool` values are not equal.
 1235 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;
 1236 |     | 
 1237 |     |     /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
 1238 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1239 |     | 
 1240 |     |     /// Asserts that two arrays of `uint256` values are not equal.
 1241 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1242 |     | 
 1243 |     |     /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
 1244 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1245 |     | 
 1246 |     |     /// Asserts that two arrays of `int256` values are not equal.
 1247 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;
 1248 |     | 
 1249 |     |     /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
 1250 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1251 |     | 
 1252 |     |     /// Asserts that two `uint256` values are not equal.
 1253 |     |     function assertNotEq(uint256 left, uint256 right) external pure;
 1254 |     | 
 1255 |     |     /// Asserts that two arrays of `address` values are not equal.
 1256 |     |     function assertNotEq(address[] calldata left, address[] calldata right) external pure;
 1257 |     | 
 1258 |     |     /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
 1259 |     |     function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1260 |     | 
 1261 |     |     /// Asserts that two arrays of `bytes32` values are not equal.
 1262 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1263 |     | 
 1264 |     |     /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
 1265 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1266 |     | 
 1267 |     |     /// Asserts that two arrays of `string` values are not equal.
 1268 |     |     function assertNotEq(string[] calldata left, string[] calldata right) external pure;
 1269 |     | 
 1270 |     |     /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
 1271 |     |     function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1272 |     | 
 1273 |     |     /// Asserts that two arrays of `bytes` values are not equal.
 1274 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1275 |     | 
 1276 |     |     /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
 1277 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1278 |     | 
 1279 |     |     /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
 1280 |     |     function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;
 1281 |     | 
 1282 |     |     /// Asserts that two `int256` values are not equal.
 1283 |     |     function assertNotEq(int256 left, int256 right) external pure;
 1284 |     | 
 1285 |     |     /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.
 1286 |     |     function assertNotEq(int256 left, int256 right, string calldata error) external pure;
 1287 |     | 
 1288 |     |     /// Asserts that two `address` values are not equal.
 1289 |     |     function assertNotEq(address left, address right) external pure;
 1290 |     | 
 1291 |     |     /// Asserts that two `address` values are not equal and includes error message into revert string on failure.
 1292 |     |     function assertNotEq(address left, address right, string calldata error) external pure;
 1293 |     | 
 1294 |     |     /// Asserts that two `bytes32` values are not equal.
 1295 |     |     function assertNotEq(bytes32 left, bytes32 right) external pure;
 1296 |     | 
 1297 |     |     /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
 1298 |     |     function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1299 |     | 
 1300 |     |     /// Asserts that the given condition is true.
 1301 |     |     function assertTrue(bool condition) external pure;
 1302 |     | 
 1303 |     |     /// Asserts that the given condition is true and includes error message into revert string on failure.
 1304 |     |     function assertTrue(bool condition, string calldata error) external pure;
 1305 |     | 
 1306 |     |     /// If the condition is false, discard this run's fuzz inputs and generate new ones.
 1307 |     |     function assume(bool condition) external pure;
 1308 |     | 
 1309 |     |     /// Writes a breakpoint to jump to in the debugger.
 1310 |     |     function breakpoint(string calldata char) external;
 1311 |     | 
 1312 |     |     /// Writes a conditional breakpoint to jump to in the debugger.
 1313 |     |     function breakpoint(string calldata char, bool value) external;
 1314 |     | 
 1315 |     |     /// Returns the RPC url for the given alias.
 1316 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 1317 |     | 
 1318 |     |     /// Returns all rpc urls and their aliases as structs.
 1319 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 1320 |     | 
 1321 |     |     /// Returns all rpc urls and their aliases `[alias, url][]`.
 1322 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 1323 |     | 
 1324 |     |     /// Suspends execution of the main thread for `duration` milliseconds.
 1325 |     |     function sleep(uint256 duration) external;
 1326 |     | 
 1327 |     |     // ======== Toml ========
 1328 |     | 
 1329 |     |     /// Checks if `key` exists in a TOML table.
 1330 |     |     function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);
 1331 |     | 
 1332 |     |     /// Parses a string of TOML data at `key` and coerces it to `address`.
 1333 |     |     function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);
 1334 |     | 
 1335 |     |     /// Parses a string of TOML data at `key` and coerces it to `address[]`.
 1336 |     |     function parseTomlAddressArray(string calldata toml, string calldata key)
 1337 |     |         external
 1338 |     |         pure
 1339 |     |         returns (address[] memory);
 1340 |     | 
 1341 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool`.
 1342 |     |     function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);
 1343 |     | 
 1344 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool[]`.
 1345 |     |     function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);
 1346 |     | 
 1347 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes`.
 1348 |     |     function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);
 1349 |     | 
 1350 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32`.
 1351 |     |     function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);
 1352 |     | 
 1353 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
 1354 |     |     function parseTomlBytes32Array(string calldata toml, string calldata key)
 1355 |     |         external
 1356 |     |         pure
 1357 |     |         returns (bytes32[] memory);
 1358 |     | 
 1359 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.
 1360 |     |     function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);
 1361 |     | 
 1362 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256`.
 1363 |     |     function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);
 1364 |     | 
 1365 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256[]`.
 1366 |     |     function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);
 1367 |     | 
 1368 |     |     /// Returns an array of all the keys in a TOML table.
 1369 |     |     function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);
 1370 |     | 
 1371 |     |     /// Parses a string of TOML data at `key` and coerces it to `string`.
 1372 |     |     function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);
 1373 |     | 
 1374 |     |     /// Parses a string of TOML data at `key` and coerces it to `string[]`.
 1375 |     |     function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);
 1376 |     | 
 1377 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256`.
 1378 |     |     function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);
 1379 |     | 
 1380 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.
 1381 |     |     function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);
 1382 |     | 
 1383 |     |     /// ABI-encodes a TOML table.
 1384 |     |     function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);
 1385 |     | 
 1386 |     |     /// ABI-encodes a TOML table at `key`.
 1387 |     |     function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);
 1388 |     | 
 1389 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
 1390 |     |     function writeToml(string calldata json, string calldata path) external;
 1391 |     | 
 1392 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>
 1393 |     |     /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
 1394 |     |     function writeToml(string calldata json, string calldata path, string calldata valueKey) external;
 1395 |     | 
 1396 |     |     // ======== Utilities ========
 1397 |     | 
 1398 |     |     /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
 1399 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)
 1400 |     |         external
 1401 |     |         pure
 1402 |     |         returns (address);
 1403 |     | 
 1404 |     |     /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
 1405 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
 1406 |     | 
 1407 |     |     /// Compute the address a contract will be deployed at for a given deployer address and nonce.
 1408 |     |     function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
 1409 |     | 
 1410 |     |     /// Derives a private key from the name, labels the account with that name, and returns the wallet.
 1411 |     |     function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);
 1412 |     | 
 1413 |     |     /// Generates a wallet from the private key and returns the wallet.
 1414 |     |     function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
 1415 |     | 
 1416 |     |     /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.
 1417 |     |     function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);
 1418 |     | 
 1419 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
 1420 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
 1421 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
 1422 |     | 
 1423 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
 1424 |     |     /// at `{derivationPath}{index}`.
 1425 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
 1426 |     |         external
 1427 |     |         pure
 1428 |     |         returns (uint256 privateKey);
 1429 |     | 
 1430 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
 1431 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
 1432 |     |     function deriveKey(string calldata mnemonic, uint32 index, string calldata language)
 1433 |     |         external
 1434 |     |         pure
 1435 |     |         returns (uint256 privateKey);
 1436 |     | 
 1437 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
 1438 |     |     /// at `{derivationPath}{index}`.
 1439 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)
 1440 |     |         external
 1441 |     |         pure
 1442 |     |         returns (uint256 privateKey);
 1443 |     | 
 1444 |     |     /// Returns ENS namehash for provided string.
 1445 |     |     function ensNamehash(string calldata name) external pure returns (bytes32);
 1446 |     | 
 1447 |     |     /// Gets the label for the specified address.
 1448 |     |     function getLabel(address account) external view returns (string memory currentLabel);
 1449 |     | 
 1450 |     |     /// Get a `Wallet`'s nonce.
 1451 |     |     function getNonce(Wallet calldata wallet) external returns (uint64 nonce);
 1452 |     | 
 1453 |     |     /// Labels an address in call traces.
 1454 |     |     function label(address account, string calldata newLabel) external;
 1455 |     | 
 1456 |     |     /// Returns a random `address`.
 1457 |     |     function randomAddress() external returns (address);
 1458 |     | 
 1459 |     |     /// Returns a random uint256 value.
 1460 |     |     function randomUint() external returns (uint256);
 1461 |     | 
 1462 |     |     /// Returns random uin256 value between the provided range (=min..=max).
 1463 |     |     function randomUint(uint256 min, uint256 max) external returns (uint256);
 1464 |     | 
 1465 |     |     /// Adds a private key to the local forge wallet and returns the address.
 1466 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
 1467 |     | 
 1468 |     |     /// Signs data with a `Wallet`.
 1469 |     |     function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
 1470 |     | 
 1471 |     |     /// Encodes a `bytes` value to a base64url string.
 1472 |     |     function toBase64URL(bytes calldata data) external pure returns (string memory);
 1473 |     | 
 1474 |     |     /// Encodes a `string` value to a base64url string.
 1475 |     |     function toBase64URL(string calldata data) external pure returns (string memory);
 1476 |     | 
 1477 |     |     /// Encodes a `bytes` value to a base64 string.
 1478 |     |     function toBase64(bytes calldata data) external pure returns (string memory);
 1479 |     | 
 1480 |     |     /// Encodes a `string` value to a base64 string.
 1481 |     |     function toBase64(string calldata data) external pure returns (string memory);
 1482 |     | }
 1483 |     | 
 1484 |     | /// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used
 1485 |     | /// in tests, but it is not recommended to use these cheats in scripts.
 1486 |     | interface Vm is VmSafe {
 1487 |     |     // ======== EVM ========
 1488 |     | 
 1489 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 1490 |     |     function activeFork() external view returns (uint256 forkId);
 1491 |     | 
 1492 |     |     /// In forking mode, explicitly grant the given address cheatcode access.
 1493 |     |     function allowCheatcodes(address account) external;
 1494 |     | 
 1495 |     |     /// Sets `block.blobbasefee`
 1496 |     |     function blobBaseFee(uint256 newBlobBaseFee) external;
 1497 |     | 
 1498 |     |     /// Sets the blobhashes in the transaction.
 1499 |     |     /// Not available on EVM versions before Cancun.
 1500 |     |     /// If used on unsupported EVM versions it will revert.
 1501 |     |     function blobhashes(bytes32[] calldata hashes) external;
 1502 |     | 
 1503 |     |     /// Sets `block.chainid`.
 1504 |     |     function chainId(uint256 newChainId) external;
 1505 |     | 
 1506 |     |     /// Clears all mocked calls.
 1507 |     |     function clearMockedCalls() external;
 1508 |     | 
 1509 |     |     /// Sets `block.coinbase`.
 1510 |     |     function coinbase(address newCoinbase) external;
 1511 |     | 
 1512 |     |     /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
 1513 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1514 |     | 
 1515 |     |     /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.
 1516 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1517 |     | 
 1518 |     |     /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,
 1519 |     |     /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
 1520 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1521 |     | 
 1522 |     |     /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
 1523 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1524 |     | 
 1525 |     |     /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
 1526 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1527 |     | 
 1528 |     |     /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,
 1529 |     |     /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.
 1530 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1531 |     | 
 1532 |     |     /// Sets an address' balance.
 1533 |     |     function deal(address account, uint256 newBalance) external;
 1534 |     | 
 1535 |     |     /// Removes the snapshot with the given ID created by `snapshot`.
 1536 |     |     /// Takes the snapshot ID to delete.
 1537 |     |     /// Returns `true` if the snapshot was successfully deleted.
 1538 |     |     /// Returns `false` if the snapshot does not exist.
 1539 |     |     function deleteSnapshot(uint256 snapshotId) external returns (bool success);
 1540 |     | 
 1541 |     |     /// Removes _all_ snapshots previously created by `snapshot`.
 1542 |     |     function deleteSnapshots() external;
 1543 |     | 
 1544 |     |     /// Sets `block.difficulty`.
 1545 |     |     /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.
 1546 |     |     /// Reverts if used on unsupported EVM versions.
 1547 |     |     function difficulty(uint256 newDifficulty) external;
 1548 |     | 
 1549 |     |     /// Dump a genesis JSON file's `allocs` to disk.
 1550 |     |     function dumpState(string calldata pathToStateJson) external;
 1551 |     | 
 1552 |     |     /// Sets an address' code.
 1553 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 1554 |     | 
 1555 |     |     /// Sets `block.basefee`.
 1556 |     |     function fee(uint256 newBasefee) external;
 1557 |     | 
 1558 |     |     /// Gets the blockhashes from the current transaction.
 1559 |     |     /// Not available on EVM versions before Cancun.
 1560 |     |     /// If used on unsupported EVM versions it will revert.
 1561 |     |     function getBlobhashes() external view returns (bytes32[] memory hashes);
 1562 |     | 
 1563 |     |     /// Returns true if the account is marked as persistent.
 1564 |     |     function isPersistent(address account) external view returns (bool persistent);
 1565 |     | 
 1566 |     |     /// Load a genesis JSON file's `allocs` into the in-memory revm state.
 1567 |     |     function loadAllocs(string calldata pathToAllocsJson) external;
 1568 |     | 
 1569 |     |     /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 1570 |     |     /// Meaning, changes made to the state of this account will be kept when switching forks.
 1571 |     |     function makePersistent(address account) external;
 1572 |     | 
 1573 |     |     /// See `makePersistent(address)`.
 1574 |     |     function makePersistent(address account0, address account1) external;
 1575 |     | 
 1576 |     |     /// See `makePersistent(address)`.
 1577 |     |     function makePersistent(address account0, address account1, address account2) external;
 1578 |     | 
 1579 |     |     /// See `makePersistent(address)`.
 1580 |     |     function makePersistent(address[] calldata accounts) external;
 1581 |     | 
 1582 |     |     /// Reverts a call to an address with specified revert data.
 1583 |     |     function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;
 1584 |     | 
 1585 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 1586 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)
 1587 |     |         external;
 1588 |     | 
 1589 |     |     /// Mocks a call to an address, returning specified data.
 1590 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 1591 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 1592 |     |     /// function will be mocked.
 1593 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 1594 |     | 
 1595 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 1596 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 1597 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 1598 |     | 
 1599 |     |     /// Sets the *next* call's `msg.sender` to be the input address.
 1600 |     |     function prank(address msgSender) external;
 1601 |     | 
 1602 |     |     /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 1603 |     |     function prank(address msgSender, address txOrigin) external;
 1604 |     | 
 1605 |     |     /// Sets `block.prevrandao`.
 1606 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 1607 |     |     /// If used on unsupported EVM versions it will revert.
 1608 |     |     function prevrandao(bytes32 newPrevrandao) external;
 1609 |     | 
 1610 |     |     /// Sets `block.prevrandao`.
 1611 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 1612 |     |     /// If used on unsupported EVM versions it will revert.
 1613 |     |     function prevrandao(uint256 newPrevrandao) external;
 1614 |     | 
 1615 |     |     /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
 1616 |     |     function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);
 1617 |     | 
 1618 |     |     /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
 1619 |     |     function resetNonce(address account) external;
 1620 |     | 
 1621 |     |     /// Revert the state of the EVM to a previous snapshot
 1622 |     |     /// Takes the snapshot ID to revert to.
 1623 |     |     /// Returns `true` if the snapshot was successfully reverted.
 1624 |     |     /// Returns `false` if the snapshot does not exist.
 1625 |     |     /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
 1626 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 1627 |     | 
 1628 |     |     /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots
 1629 |     |     /// Takes the snapshot ID to revert to.
 1630 |     |     /// Returns `true` if the snapshot was successfully reverted and deleted.
 1631 |     |     /// Returns `false` if the snapshot does not exist.
 1632 |     |     function revertToAndDelete(uint256 snapshotId) external returns (bool success);
 1633 |     | 
 1634 |     |     /// Revokes persistent status from the address, previously added via `makePersistent`.
 1635 |     |     function revokePersistent(address account) external;
 1636 |     | 
 1637 |     |     /// See `revokePersistent(address)`.
 1638 |     |     function revokePersistent(address[] calldata accounts) external;
 1639 |     | 
 1640 |     |     /// Sets `block.height`.
 1641 |     |     function roll(uint256 newHeight) external;
 1642 |     | 
 1643 |     |     /// Updates the currently active fork to given block number
 1644 |     |     /// This is similar to `roll` but for the currently active fork.
 1645 |     |     function rollFork(uint256 blockNumber) external;
 1646 |     | 
 1647 |     |     /// Updates the currently active fork to given transaction. This will `rollFork` with the number
 1648 |     |     /// of the block the transaction was mined in and replays all transaction mined before it in the block.
 1649 |     |     function rollFork(bytes32 txHash) external;
 1650 |     | 
 1651 |     |     /// Updates the given fork to given block number.
 1652 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 1653 |     | 
 1654 |     |     /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
 1655 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 1656 |     | 
 1657 |     |     /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 1658 |     |     function selectFork(uint256 forkId) external;
 1659 |     | 
 1660 |     |     /// Sets the nonce of an account. Must be higher than the current nonce of the account.
 1661 |     |     function setNonce(address account, uint64 newNonce) external;
 1662 |     | 
 1663 |     |     /// Sets the nonce of an account to an arbitrary value.
 1664 |     |     function setNonceUnsafe(address account, uint64 newNonce) external;
 1665 |     | 
 1666 |     |     /// Snapshot the current state of the evm.
 1667 |     |     /// Returns the ID of the snapshot that was created.
 1668 |     |     /// To revert a snapshot use `revertTo`.
 1669 |     |     function snapshot() external returns (uint256 snapshotId);
 1670 |     | 
 1671 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
 1672 |     |     function startPrank(address msgSender) external;
 1673 |     | 
 1674 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 1675 |     |     function startPrank(address msgSender, address txOrigin) external;
 1676 |     | 
 1677 |     |     /// Resets subsequent calls' `msg.sender` to be `address(this)`.
 1678 |     |     function stopPrank() external;
 1679 |     | 
 1680 |     |     /// Stores a value to an address' storage slot.
 1681 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 1682 |     | 
 1683 |     |     /// Fetches the given transaction from the active fork and executes it on the current state.
 1684 |     |     function transact(bytes32 txHash) external;
 1685 |     | 
 1686 |     |     /// Fetches the given transaction from the given fork and executes it on the current state.
 1687 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 1688 |     | 
 1689 |     |     /// Sets `tx.gasprice`.
 1690 |     |     function txGasPrice(uint256 newGasPrice) external;
 1691 |     | 
 1692 |     |     /// Sets `block.timestamp`.
 1693 |     |     function warp(uint256 newTimestamp) external;
 1694 |     | 
 1695 |     |     // ======== Testing ========
 1696 |     | 
 1697 |     |     /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 1698 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;
 1699 |     | 
 1700 |     |     /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 1701 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)
 1702 |     |         external;
 1703 |     | 
 1704 |     |     /// Expects a call to an address with the specified calldata.
 1705 |     |     /// Calldata can either be a strict or a partial match.
 1706 |     |     function expectCall(address callee, bytes calldata data) external;
 1707 |     | 
 1708 |     |     /// Expects given number of calls to an address with the specified calldata.
 1709 |     |     function expectCall(address callee, bytes calldata data, uint64 count) external;
 1710 |     | 
 1711 |     |     /// Expects a call to an address with the specified `msg.value` and calldata.
 1712 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 1713 |     | 
 1714 |     |     /// Expects given number of calls to an address with the specified `msg.value` and calldata.
 1715 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;
 1716 |     | 
 1717 |     |     /// Expect a call to an address with the specified `msg.value`, gas, and calldata.
 1718 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;
 1719 |     | 
 1720 |     |     /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
 1721 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;
 1722 |     | 
 1723 |     |     /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 1724 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 1725 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 1726 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 1727 |     | 
 1728 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 1729 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 1730 |     |         external;
 1731 |     | 
 1732 |     |     /// Prepare an expected log with all topic and data checks enabled.
 1733 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 1734 |     |     /// logs were emitted in the expected order with the expected topics and data.
 1735 |     |     function expectEmit() external;
 1736 |     | 
 1737 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 1738 |     |     function expectEmit(address emitter) external;
 1739 |     | 
 1740 |     |     /// Expects an error on next call with any revert data.
 1741 |     |     function expectRevert() external;
 1742 |     | 
 1743 |     |     /// Expects an error on next call that starts with the revert data.
 1744 |     |     function expectRevert(bytes4 revertData) external;
 1745 |     | 
 1746 |     |     /// Expects an error on next call that exactly matches the revert data.
 1747 |     |     function expectRevert(bytes calldata revertData) external;
 1748 |     | 
 1749 |     |     /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other
 1750 |     |     /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
 1751 |     |     function expectSafeMemory(uint64 min, uint64 max) external;
 1752 |     | 
 1753 |     |     /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.
 1754 |     |     /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges
 1755 |     |     /// to the set.
 1756 |     |     function expectSafeMemoryCall(uint64 min, uint64 max) external;
 1757 |     | 
 1758 |     |     /// Marks a test as skipped. Must be called at the top of the test.
 1759 |     |     function skip(bool skipTest) external;
 1760 |     | 
 1761 |     |     /// Stops all safe memory expectation in the current subcontext.
 1762 |     |     function stopExpectSafeMemory() external;
 1763 |     | }
 1764 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 | *   |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     |     function _castLogPayloadViewToPure(
    8 |     |         function(bytes memory) internal view fnIn
    9 |     |     ) internal pure returns (function(bytes memory) internal pure fnOut) {
   10 |     |         assembly {
   11 |     |             fnOut := fnIn
   12 |     |         }
   13 |     |     }
   14 |     | 
   15 | *   |     function _sendLogPayload(bytes memory payload) internal pure {
   16 | *   |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
   17 |     |     }
   18 |     | 
   19 | *   |     function _sendLogPayloadView(bytes memory payload) private view {
   20 | *   |         uint256 payloadLength = payload.length;
   21 |     |         address consoleAddress = CONSOLE_ADDRESS;
   22 |     |         /// @solidity memory-safe-assembly
   23 | *   |         assembly {
   24 | *   |             let payloadStart := add(payload, 32)
   25 | *   |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   26 |     |         }
   27 |     |     }
   28 |     | 
   29 |     |     function log() internal pure {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   31 |     |     }
   32 |     | 
   33 | *   |     function logInt(int p0) internal pure {
   34 | *   |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logUint(uint p0) internal pure {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logString(string memory p0) internal pure {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBool(bool p0) internal pure {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logAddress(address p0) internal pure {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes(bytes memory p0) internal pure {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes1(bytes1 p0) internal pure {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes2(bytes2 p0) internal pure {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes3(bytes3 p0) internal pure {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes4(bytes4 p0) internal pure {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes5(bytes5 p0) internal pure {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes6(bytes6 p0) internal pure {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes7(bytes7 p0) internal pure {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes8(bytes8 p0) internal pure {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes9(bytes9 p0) internal pure {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes10(bytes10 p0) internal pure {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes11(bytes11 p0) internal pure {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes12(bytes12 p0) internal pure {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes13(bytes13 p0) internal pure {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes14(bytes14 p0) internal pure {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes15(bytes15 p0) internal pure {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes16(bytes16 p0) internal pure {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes17(bytes17 p0) internal pure {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes18(bytes18 p0) internal pure {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes19(bytes19 p0) internal pure {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes20(bytes20 p0) internal pure {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes21(bytes21 p0) internal pure {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes22(bytes22 p0) internal pure {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes23(bytes23 p0) internal pure {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes24(bytes24 p0) internal pure {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes25(bytes25 p0) internal pure {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes26(bytes26 p0) internal pure {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes27(bytes27 p0) internal pure {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes28(bytes28 p0) internal pure {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes29(bytes29 p0) internal pure {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function logBytes30(bytes30 p0) internal pure {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function logBytes31(bytes31 p0) internal pure {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  179 |     |     }
  180 |     | 
  181 | *   |     function logBytes32(bytes32 p0) internal pure {
  182 | *   |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(uint p0) internal pure {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(int p0) internal pure {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
  191 |     |     }
  192 |     | 
  193 | *   |     function log(string memory p0) internal pure {
  194 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  195 |     |     }
  196 |     | 
  197 |     |     function log(bool p0) internal pure {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  199 |     |     }
  200 |     | 
  201 |     |     function log(address p0) internal pure {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  203 |     |     }
  204 |     | 
  205 |     |     function log(uint p0, uint p1) internal pure {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(uint p0, string memory p1) internal pure {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(uint p0, bool p1) internal pure {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(uint p0, address p1) internal pure {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  219 |     |     }
  220 |     | 
  221 | *   |     function log(string memory p0, uint p1) internal pure {
  222 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  223 |     |     }
  224 |     | 
  225 | *   |     function log(string memory p0, int p1) internal pure {
  226 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,int)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(string memory p0, string memory p1) internal pure {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(string memory p0, bool p1) internal pure {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  235 |     |     }
  236 |     | 
  237 | *   |     function log(string memory p0, address p1) internal pure {
  238 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(bool p0, uint p1) internal pure {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(bool p0, string memory p1) internal pure {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(bool p0, bool p1) internal pure {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(bool p0, address p1) internal pure {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  255 |     |     }
  256 |     | 
  257 |     |     function log(address p0, uint p1) internal pure {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  259 |     |     }
  260 |     | 
  261 |     |     function log(address p0, string memory p1) internal pure {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  263 |     |     }
  264 |     | 
  265 |     |     function log(address p0, bool p1) internal pure {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  267 |     |     }
  268 |     | 
  269 |     |     function log(address p0, address p1) internal pure {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, uint p1, uint p2) internal pure {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, uint p1, string memory p2) internal pure {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, uint p1, bool p2) internal pure {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, uint p1, address p2) internal pure {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, string memory p1, uint p2) internal pure {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, string memory p1, string memory p2) internal pure {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, string memory p1, bool p2) internal pure {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, string memory p1, address p2) internal pure {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, bool p1, uint p2) internal pure {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, bool p1, string memory p2) internal pure {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, bool p1, bool p2) internal pure {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(uint p0, bool p1, address p2) internal pure {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(uint p0, address p1, uint p2) internal pure {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(uint p0, address p1, string memory p2) internal pure {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(uint p0, address p1, bool p2) internal pure {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(uint p0, address p1, address p2) internal pure {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, uint p1, uint p2) internal pure {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, uint p1, string memory p2) internal pure {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, uint p1, bool p2) internal pure {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, uint p1, address p2) internal pure {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, string memory p1, uint p2) internal pure {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, bool p1, uint p2) internal pure {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(string memory p0, address p1, uint p2) internal pure {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(string memory p0, address p1, address p2) internal pure {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, uint p1, uint p2) internal pure {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, uint p1, string memory p2) internal pure {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, uint p1, bool p2) internal pure {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, uint p1, address p2) internal pure {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, string memory p1, uint p2) internal pure {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, bool p1, uint p2) internal pure {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(bool p0, bool p1, address p2) internal pure {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(bool p0, address p1, uint p2) internal pure {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(bool p0, address p1, bool p2) internal pure {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(bool p0, address p1, address p2) internal pure {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, uint p1, uint p2) internal pure {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, uint p1, string memory p2) internal pure {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, uint p1, bool p2) internal pure {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, uint p1, address p2) internal pure {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, string memory p1, uint p2) internal pure {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, string memory p1, address p2) internal pure {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, bool p1, uint p2) internal pure {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, bool p1, bool p2) internal pure {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(address p0, bool p1, address p2) internal pure {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  511 |     |     }
  512 |     | 
  513 |     |     function log(address p0, address p1, uint p2) internal pure {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  515 |     |     }
  516 |     | 
  517 |     |     function log(address p0, address p1, string memory p2) internal pure {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  519 |     |     }
  520 |     | 
  521 |     |     function log(address p0, address p1, bool p2) internal pure {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  523 |     |     }
  524 |     | 
  525 |     |     function log(address p0, address p1, address p2) internal pure {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal pure {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal pure {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal pure {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, uint p2, address p3) internal pure {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal pure {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal pure {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal pure {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal pure {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal pure {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal pure {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal pure {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, uint p1, bool p2, address p3) internal pure {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, uint p1, address p2, uint p3) internal pure {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal pure {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, uint p1, address p2, bool p3) internal pure {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, uint p1, address p2, address p3) internal pure {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal pure {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal pure {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal pure {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal pure {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal pure {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal pure {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal pure {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal pure {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal pure {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal pure {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal pure {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal pure {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal pure {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal pure {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal pure {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, string memory p1, address p2, address p3) internal pure {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal pure {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal pure {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal pure {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, uint p2, address p3) internal pure {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal pure {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal pure {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal pure {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal pure {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal pure {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal pure {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal pure {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, bool p1, bool p2, address p3) internal pure {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, bool p1, address p2, uint p3) internal pure {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal pure {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, bool p1, address p2, bool p3) internal pure {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, bool p1, address p2, address p3) internal pure {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, uint p2, uint p3) internal pure {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal pure {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, uint p2, bool p3) internal pure {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, uint p2, address p3) internal pure {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal pure {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal pure {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal pure {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, string memory p2, address p3) internal pure {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, bool p2, uint p3) internal pure {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal pure {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, bool p2, bool p3) internal pure {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(uint p0, address p1, bool p2, address p3) internal pure {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(uint p0, address p1, address p2, uint p3) internal pure {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(uint p0, address p1, address p2, string memory p3) internal pure {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(uint p0, address p1, address p2, bool p3) internal pure {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(uint p0, address p1, address p2, address p3) internal pure {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal pure {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal pure {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal pure {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal pure {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal pure {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal pure {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal pure {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal pure {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal pure {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal pure {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal pure {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal pure {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal pure {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal pure {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal pure {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, uint p1, address p2, address p3) internal pure {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal pure {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal pure {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal pure {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal pure {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal pure {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal pure {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal pure {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal pure {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal pure {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal pure {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal pure {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal pure {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal pure {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal pure {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal pure {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal pure {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal pure {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, uint p2, address p3) internal pure {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal pure {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal pure {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(string memory p0, address p1, address p2, uint p3) internal pure {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal pure {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal pure {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal pure {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, uint p2, address p3) internal pure {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal pure {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal pure {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal pure {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal pure {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal pure {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal pure {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal pure {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, uint p1, bool p2, address p3) internal pure {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, uint p1, address p2, uint p3) internal pure {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal pure {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, uint p1, address p2, bool p3) internal pure {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, uint p1, address p2, address p3) internal pure {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal pure {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal pure {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal pure {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal pure {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal pure {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal pure {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal pure {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal pure {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal pure {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal pure {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, uint p2, address p3) internal pure {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal pure {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal pure {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, bool p1, address p2, uint p3) internal pure {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, uint p2, uint p3) internal pure {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal pure {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, uint p2, bool p3) internal pure {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, uint p2, address p3) internal pure {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal pure {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, bool p2, uint p3) internal pure {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(bool p0, address p1, address p2, uint p3) internal pure {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, uint p2, uint p3) internal pure {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal pure {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, uint p2, bool p3) internal pure {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, uint p2, address p3) internal pure {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal pure {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal pure {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal pure {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, string memory p2, address p3) internal pure {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, bool p2, uint p3) internal pure {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal pure {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, bool p2, bool p3) internal pure {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, uint p1, bool p2, address p3) internal pure {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, uint p1, address p2, uint p3) internal pure {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, uint p1, address p2, string memory p3) internal pure {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, uint p1, address p2, bool p3) internal pure {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, uint p1, address p2, address p3) internal pure {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal pure {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal pure {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal pure {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, uint p2, address p3) internal pure {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal pure {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal pure {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, string memory p1, address p2, uint p3) internal pure {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, uint p2, uint p3) internal pure {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal pure {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, uint p2, bool p3) internal pure {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, uint p2, address p3) internal pure {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal pure {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, bool p2, uint p3) internal pure {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, bool p1, address p2, uint p3) internal pure {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, uint p2, uint p3) internal pure {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, uint p2, string memory p3) internal pure {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, uint p2, bool p3) internal pure {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, uint p2, address p3) internal pure {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, string memory p2, uint p3) internal pure {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, bool p2, uint p3) internal pure {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1535 |     |     }
 1536 |     | 
 1537 |     |     function log(address p0, address p1, address p2, uint p3) internal pure {
 1538 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1539 |     |     }
 1540 |     | 
 1541 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1542 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1543 |     |     }
 1544 |     | 
 1545 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1546 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1547 |     |     }
 1548 |     | 
 1549 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1550 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1551 |     |     }
 1552 |     | }
 1553 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/console2.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.4.22 <0.9.0;
 3 |     | 
 4 |     | import {console as console2} from "./console.sol";
 5 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2;
  3 |     | 
  4 |     | interface IERC165 {
  5 |     |     /// @notice Query if a contract implements an interface
  6 |     |     /// @param interfaceID The interface identifier, as specified in ERC-165
  7 |     |     /// @dev Interface identification is specified in ERC-165. This function
  8 |     |     /// uses less than 30,000 gas.
  9 |     |     /// @return `true` if the contract implements `interfaceID` and
 10 |     |     /// `interfaceID` is not 0xffffffff, `false` otherwise
 11 |     |     function supportsInterface(bytes4 interfaceID) external view returns (bool);
 12 |     | }
 13 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2;
  3 |     | 
  4 |     | /// @dev Interface of the ERC20 standard as defined in the EIP.
  5 |     | /// @dev This includes the optional name, symbol, and decimals metadata.
  6 |     | interface IERC20 {
  7 |     |     /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
  8 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  9 |     | 
 10 |     |     /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`
 11 |     |     /// is the new allowance.
 12 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 13 |     | 
 14 |     |     /// @notice Returns the amount of tokens in existence.
 15 |     |     function totalSupply() external view returns (uint256);
 16 |     | 
 17 |     |     /// @notice Returns the amount of tokens owned by `account`.
 18 |     |     function balanceOf(address account) external view returns (uint256);
 19 |     | 
 20 |     |     /// @notice Moves `amount` tokens from the caller's account to `to`.
 21 |     |     function transfer(address to, uint256 amount) external returns (bool);
 22 |     | 
 23 |     |     /// @notice Returns the remaining number of tokens that `spender` is allowed
 24 |     |     /// to spend on behalf of `owner`
 25 |     |     function allowance(address owner, address spender) external view returns (uint256);
 26 |     | 
 27 |     |     /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.
 28 |     |     /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 29 |     |     function approve(address spender, uint256 amount) external returns (bool);
 30 |     | 
 31 |     |     /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.
 32 |     |     /// `amount` is then deducted from the caller's allowance.
 33 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 34 |     | 
 35 |     |     /// @notice Returns the name of the token.
 36 |     |     function name() external view returns (string memory);
 37 |     | 
 38 |     |     /// @notice Returns the symbol of the token.
 39 |     |     function symbol() external view returns (string memory);
 40 |     | 
 41 |     |     /// @notice Returns the decimals places of the token.
 42 |     |     function decimals() external view returns (uint8);
 43 |     | }
 44 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2;
   3 |     | 
   4 |     | import "./IERC165.sol";
   5 |     | 
   6 |     | /// @title ERC-721 Non-Fungible Token Standard
   7 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
   8 |     | /// Note: the ERC-165 identifier for this interface is 0x80ac58cd.
   9 |     | interface IERC721 is IERC165 {
  10 |     |     /// @dev This emits when ownership of any NFT changes by any mechanism.
  11 |     |     /// This event emits when NFTs are created (`from` == 0) and destroyed
  12 |     |     /// (`to` == 0). Exception: during contract creation, any number of NFTs
  13 |     |     /// may be created and assigned without emitting Transfer. At the time of
  14 |     |     /// any transfer, the approved address for that NFT (if any) is reset to none.
  15 |     |     event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
  16 |     | 
  17 |     |     /// @dev This emits when the approved address for an NFT is changed or
  18 |     |     /// reaffirmed. The zero address indicates there is no approved address.
  19 |     |     /// When a Transfer event emits, this also indicates that the approved
  20 |     |     /// address for that NFT (if any) is reset to none.
  21 |     |     event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
  22 |     | 
  23 |     |     /// @dev This emits when an operator is enabled or disabled for an owner.
  24 |     |     /// The operator can manage all NFTs of the owner.
  25 |     |     event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
  26 |     | 
  27 |     |     /// @notice Count all NFTs assigned to an owner
  28 |     |     /// @dev NFTs assigned to the zero address are considered invalid, and this
  29 |     |     /// function throws for queries about the zero address.
  30 |     |     /// @param _owner An address for whom to query the balance
  31 |     |     /// @return The number of NFTs owned by `_owner`, possibly zero
  32 |     |     function balanceOf(address _owner) external view returns (uint256);
  33 |     | 
  34 |     |     /// @notice Find the owner of an NFT
  35 |     |     /// @dev NFTs assigned to zero address are considered invalid, and queries
  36 |     |     /// about them do throw.
  37 |     |     /// @param _tokenId The identifier for an NFT
  38 |     |     /// @return The address of the owner of the NFT
  39 |     |     function ownerOf(uint256 _tokenId) external view returns (address);
  40 |     | 
  41 |     |     /// @notice Transfers the ownership of an NFT from one address to another address
  42 |     |     /// @dev Throws unless `msg.sender` is the current owner, an authorized
  43 |     |     /// operator, or the approved address for this NFT. Throws if `_from` is
  44 |     |     /// not the current owner. Throws if `_to` is the zero address. Throws if
  45 |     |     /// `_tokenId` is not a valid NFT. When transfer is complete, this function
  46 |     |     /// checks if `_to` is a smart contract (code size > 0). If so, it calls
  47 |     |     /// `onERC721Received` on `_to` and throws if the return value is not
  48 |     |     /// `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
  49 |     |     /// @param _from The current owner of the NFT
  50 |     |     /// @param _to The new owner
  51 |     |     /// @param _tokenId The NFT to transfer
  52 |     |     /// @param data Additional data with no specified format, sent in call to `_to`
  53 |     |     function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;
  54 |     | 
  55 |     |     /// @notice Transfers the ownership of an NFT from one address to another address
  56 |     |     /// @dev This works identically to the other function with an extra data parameter,
  57 |     |     /// except this function just sets data to "".
  58 |     |     /// @param _from The current owner of the NFT
  59 |     |     /// @param _to The new owner
  60 |     |     /// @param _tokenId The NFT to transfer
  61 |     |     function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
  62 |     | 
  63 |     |     /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
  64 |     |     /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
  65 |     |     /// THEY MAY BE PERMANENTLY LOST
  66 |     |     /// @dev Throws unless `msg.sender` is the current owner, an authorized
  67 |     |     /// operator, or the approved address for this NFT. Throws if `_from` is
  68 |     |     /// not the current owner. Throws if `_to` is the zero address. Throws if
  69 |     |     /// `_tokenId` is not a valid NFT.
  70 |     |     /// @param _from The current owner of the NFT
  71 |     |     /// @param _to The new owner
  72 |     |     /// @param _tokenId The NFT to transfer
  73 |     |     function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
  74 |     | 
  75 |     |     /// @notice Change or reaffirm the approved address for an NFT
  76 |     |     /// @dev The zero address indicates there is no approved address.
  77 |     |     /// Throws unless `msg.sender` is the current NFT owner, or an authorized
  78 |     |     /// operator of the current owner.
  79 |     |     /// @param _approved The new approved NFT controller
  80 |     |     /// @param _tokenId The NFT to approve
  81 |     |     function approve(address _approved, uint256 _tokenId) external payable;
  82 |     | 
  83 |     |     /// @notice Enable or disable approval for a third party ("operator") to manage
  84 |     |     /// all of `msg.sender`'s assets
  85 |     |     /// @dev Emits the ApprovalForAll event. The contract MUST allow
  86 |     |     /// multiple operators per owner.
  87 |     |     /// @param _operator Address to add to the set of authorized operators
  88 |     |     /// @param _approved True if the operator is approved, false to revoke approval
  89 |     |     function setApprovalForAll(address _operator, bool _approved) external;
  90 |     | 
  91 |     |     /// @notice Get the approved address for a single NFT
  92 |     |     /// @dev Throws if `_tokenId` is not a valid NFT.
  93 |     |     /// @param _tokenId The NFT to find the approved address for
  94 |     |     /// @return The approved address for this NFT, or the zero address if there is none
  95 |     |     function getApproved(uint256 _tokenId) external view returns (address);
  96 |     | 
  97 |     |     /// @notice Query if an address is an authorized operator for another address
  98 |     |     /// @param _owner The address that owns the NFTs
  99 |     |     /// @param _operator The address that acts on behalf of the owner
 100 |     |     /// @return True if `_operator` is an approved operator for `_owner`, false otherwise
 101 |     |     function isApprovedForAll(address _owner, address _operator) external view returns (bool);
 102 |     | }
 103 |     | 
 104 |     | /// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.
 105 |     | interface IERC721TokenReceiver {
 106 |     |     /// @notice Handle the receipt of an NFT
 107 |     |     /// @dev The ERC721 smart contract calls this function on the recipient
 108 |     |     /// after a `transfer`. This function MAY throw to revert and reject the
 109 |     |     /// transfer. Return of other than the magic value MUST result in the
 110 |     |     /// transaction being reverted.
 111 |     |     /// Note: the contract address is always the message sender.
 112 |     |     /// @param _operator The address which called `safeTransferFrom` function
 113 |     |     /// @param _from The address which previously owned the token
 114 |     |     /// @param _tokenId The NFT identifier which is being transferred
 115 |     |     /// @param _data Additional data with no specified format
 116 |     |     /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
 117 |     |     ///  unless throwing
 118 |     |     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)
 119 |     |         external
 120 |     |         returns (bytes4);
 121 |     | }
 122 |     | 
 123 |     | /// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 124 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
 125 |     | /// Note: the ERC-165 identifier for this interface is 0x5b5e139f.
 126 |     | interface IERC721Metadata is IERC721 {
 127 |     |     /// @notice A descriptive name for a collection of NFTs in this contract
 128 |     |     function name() external view returns (string memory _name);
 129 |     | 
 130 |     |     /// @notice An abbreviated name for NFTs in this contract
 131 |     |     function symbol() external view returns (string memory _symbol);
 132 |     | 
 133 |     |     /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
 134 |     |     /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
 135 |     |     /// 3986. The URI may point to a JSON file that conforms to the "ERC721
 136 |     |     /// Metadata JSON Schema".
 137 |     |     function tokenURI(uint256 _tokenId) external view returns (string memory);
 138 |     | }
 139 |     | 
 140 |     | /// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 141 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
 142 |     | /// Note: the ERC-165 identifier for this interface is 0x780e9d63.
 143 |     | interface IERC721Enumerable is IERC721 {
 144 |     |     /// @notice Count NFTs tracked by this contract
 145 |     |     /// @return A count of valid NFTs tracked by this contract, where each one of
 146 |     |     /// them has an assigned and queryable owner not equal to the zero address
 147 |     |     function totalSupply() external view returns (uint256);
 148 |     | 
 149 |     |     /// @notice Enumerate valid NFTs
 150 |     |     /// @dev Throws if `_index` >= `totalSupply()`.
 151 |     |     /// @param _index A counter less than `totalSupply()`
 152 |     |     /// @return The token identifier for the `_index`th NFT,
 153 |     |     /// (sort order not specified)
 154 |     |     function tokenByIndex(uint256 _index) external view returns (uint256);
 155 |     | 
 156 |     |     /// @notice Enumerate NFTs assigned to an owner
 157 |     |     /// @dev Throws if `_index` >= `balanceOf(_owner)` or if
 158 |     |     /// `_owner` is the zero address, representing invalid NFTs.
 159 |     |     /// @param _owner An address where we are interested in NFTs owned by them
 160 |     |     /// @param _index A counter less than `balanceOf(_owner)`
 161 |     |     /// @return The token identifier for the `_index`th NFT assigned to `_owner`,
 162 |     |     /// (sort order not specified)
 163 |     |     function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
 164 |     | }
 165 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/interfaces/IMulticall3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | interface IMulticall3 {
  7 |     |     struct Call {
  8 |     |         address target;
  9 |     |         bytes callData;
 10 |     |     }
 11 |     | 
 12 |     |     struct Call3 {
 13 |     |         address target;
 14 |     |         bool allowFailure;
 15 |     |         bytes callData;
 16 |     |     }
 17 |     | 
 18 |     |     struct Call3Value {
 19 |     |         address target;
 20 |     |         bool allowFailure;
 21 |     |         uint256 value;
 22 |     |         bytes callData;
 23 |     |     }
 24 |     | 
 25 |     |     struct Result {
 26 |     |         bool success;
 27 |     |         bytes returnData;
 28 |     |     }
 29 |     | 
 30 |     |     function aggregate(Call[] calldata calls)
 31 |     |         external
 32 |     |         payable
 33 |     |         returns (uint256 blockNumber, bytes[] memory returnData);
 34 |     | 
 35 |     |     function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
 36 |     | 
 37 |     |     function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);
 38 |     | 
 39 |     |     function blockAndAggregate(Call[] calldata calls)
 40 |     |         external
 41 |     |         payable
 42 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 43 |     | 
 44 |     |     function getBasefee() external view returns (uint256 basefee);
 45 |     | 
 46 |     |     function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);
 47 |     | 
 48 |     |     function getBlockNumber() external view returns (uint256 blockNumber);
 49 |     | 
 50 |     |     function getChainId() external view returns (uint256 chainid);
 51 |     | 
 52 |     |     function getCurrentBlockCoinbase() external view returns (address coinbase);
 53 |     | 
 54 |     |     function getCurrentBlockDifficulty() external view returns (uint256 difficulty);
 55 |     | 
 56 |     |     function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);
 57 |     | 
 58 |     |     function getCurrentBlockTimestamp() external view returns (uint256 timestamp);
 59 |     | 
 60 |     |     function getEthBalance(address addr) external view returns (uint256 balance);
 61 |     | 
 62 |     |     function getLastBlockHash() external view returns (bytes32 blockHash);
 63 |     | 
 64 |     |     function tryAggregate(bool requireSuccess, Call[] calldata calls)
 65 |     |         external
 66 |     |         payable
 67 |     |         returns (Result[] memory returnData);
 68 |     | 
 69 |     |     function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)
 70 |     |         external
 71 |     |         payable
 72 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 73 |     | }
 74 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/mocks/MockERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {IERC20} from "../interfaces/IERC20.sol";
   5 |     | 
   6 |     | /// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.
   7 |     | /// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol
   8 |     | contract MockERC20 is IERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                             METADATA STORAGE
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     string internal _name;
  14 |     | 
  15 |     |     string internal _symbol;
  16 |     | 
  17 |     |     uint8 internal _decimals;
  18 |     | 
  19 |     |     function name() external view override returns (string memory) {
  20 |     |         return _name;
  21 |     |     }
  22 |     | 
  23 |     |     function symbol() external view override returns (string memory) {
  24 |     |         return _symbol;
  25 |     |     }
  26 |     | 
  27 |     |     function decimals() external view override returns (uint8) {
  28 |     |         return _decimals;
  29 |     |     }
  30 |     | 
  31 |     |     /*//////////////////////////////////////////////////////////////
  32 |     |                               ERC20 STORAGE
  33 |     |     //////////////////////////////////////////////////////////////*/
  34 |     | 
  35 |     |     uint256 internal _totalSupply;
  36 |     | 
  37 |     |     mapping(address => uint256) internal _balanceOf;
  38 |     | 
  39 |     |     mapping(address => mapping(address => uint256)) internal _allowance;
  40 |     | 
  41 |     |     function totalSupply() external view override returns (uint256) {
  42 |     |         return _totalSupply;
  43 |     |     }
  44 |     | 
  45 |     |     function balanceOf(address owner) external view override returns (uint256) {
  46 |     |         return _balanceOf[owner];
  47 |     |     }
  48 |     | 
  49 |     |     function allowance(address owner, address spender) external view override returns (uint256) {
  50 |     |         return _allowance[owner][spender];
  51 |     |     }
  52 |     | 
  53 |     |     /*//////////////////////////////////////////////////////////////
  54 |     |                             EIP-2612 STORAGE
  55 |     |     //////////////////////////////////////////////////////////////*/
  56 |     | 
  57 |     |     uint256 internal INITIAL_CHAIN_ID;
  58 |     | 
  59 |     |     bytes32 internal INITIAL_DOMAIN_SEPARATOR;
  60 |     | 
  61 |     |     mapping(address => uint256) public nonces;
  62 |     | 
  63 |     |     /*//////////////////////////////////////////////////////////////
  64 |     |                                INITIALIZE
  65 |     |     //////////////////////////////////////////////////////////////*/
  66 |     | 
  67 |     |     /// @dev A bool to track whether the contract has been initialized.
  68 |     |     bool private initialized;
  69 |     | 
  70 |     |     /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and
  71 |     |     /// syntaxes, we add an initialization function that can be called only once.
  72 |     |     function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {
  73 |     |         require(!initialized, "ALREADY_INITIALIZED");
  74 |     | 
  75 |     |         _name = name_;
  76 |     |         _symbol = symbol_;
  77 |     |         _decimals = decimals_;
  78 |     | 
  79 |     |         INITIAL_CHAIN_ID = _pureChainId();
  80 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  81 |     | 
  82 |     |         initialized = true;
  83 |     |     }
  84 |     | 
  85 |     |     /*//////////////////////////////////////////////////////////////
  86 |     |                                ERC20 LOGIC
  87 |     |     //////////////////////////////////////////////////////////////*/
  88 |     | 
  89 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
  90 |     |         _allowance[msg.sender][spender] = amount;
  91 |     | 
  92 |     |         emit Approval(msg.sender, spender, amount);
  93 |     | 
  94 |     |         return true;
  95 |     |     }
  96 |     | 
  97 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
  98 |     |         _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);
  99 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 100 |     | 
 101 |     |         emit Transfer(msg.sender, to, amount);
 102 |     | 
 103 |     |         return true;
 104 |     |     }
 105 |     | 
 106 |     |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 107 |     |         uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.
 108 |     | 
 109 |     |         if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);
 110 |     | 
 111 |     |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 112 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 113 |     | 
 114 |     |         emit Transfer(from, to, amount);
 115 |     | 
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /*//////////////////////////////////////////////////////////////
 120 |     |                              EIP-2612 LOGIC
 121 |     |     //////////////////////////////////////////////////////////////*/
 122 |     | 
 123 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 124 |     |         public
 125 |     |         virtual
 126 |     |     {
 127 |     |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 128 |     | 
 129 |     |         address recoveredAddress = ecrecover(
 130 |     |             keccak256(
 131 |     |                 abi.encodePacked(
 132 |     |                     "\x19\x01",
 133 |     |                     DOMAIN_SEPARATOR(),
 134 |     |                     keccak256(
 135 |     |                         abi.encode(
 136 |     |                             keccak256(
 137 |     |                                 "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 138 |     |                             ),
 139 |     |                             owner,
 140 |     |                             spender,
 141 |     |                             value,
 142 |     |                             nonces[owner]++,
 143 |     |                             deadline
 144 |     |                         )
 145 |     |                     )
 146 |     |                 )
 147 |     |             ),
 148 |     |             v,
 149 |     |             r,
 150 |     |             s
 151 |     |         );
 152 |     | 
 153 |     |         require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 154 |     | 
 155 |     |         _allowance[recoveredAddress][spender] = value;
 156 |     | 
 157 |     |         emit Approval(owner, spender, value);
 158 |     |     }
 159 |     | 
 160 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 161 |     |         return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 162 |     |     }
 163 |     | 
 164 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 165 |     |         return keccak256(
 166 |     |             abi.encode(
 167 |     |                 keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 168 |     |                 keccak256(bytes(_name)),
 169 |     |                 keccak256("1"),
 170 |     |                 _pureChainId(),
 171 |     |                 address(this)
 172 |     |             )
 173 |     |         );
 174 |     |     }
 175 |     | 
 176 |     |     /*//////////////////////////////////////////////////////////////
 177 |     |                         INTERNAL MINT/BURN LOGIC
 178 |     |     //////////////////////////////////////////////////////////////*/
 179 |     | 
 180 |     |     function _mint(address to, uint256 amount) internal virtual {
 181 |     |         _totalSupply = _add(_totalSupply, amount);
 182 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 183 |     | 
 184 |     |         emit Transfer(address(0), to, amount);
 185 |     |     }
 186 |     | 
 187 |     |     function _burn(address from, uint256 amount) internal virtual {
 188 |     |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 189 |     |         _totalSupply = _sub(_totalSupply, amount);
 190 |     | 
 191 |     |         emit Transfer(from, address(0), amount);
 192 |     |     }
 193 |     | 
 194 |     |     /*//////////////////////////////////////////////////////////////
 195 |     |                         INTERNAL SAFE MATH LOGIC
 196 |     |     //////////////////////////////////////////////////////////////*/
 197 |     | 
 198 |     |     function _add(uint256 a, uint256 b) internal pure returns (uint256) {
 199 |     |         uint256 c = a + b;
 200 |     |         require(c >= a, "ERC20: addition overflow");
 201 |     |         return c;
 202 |     |     }
 203 |     | 
 204 |     |     function _sub(uint256 a, uint256 b) internal pure returns (uint256) {
 205 |     |         require(a >= b, "ERC20: subtraction underflow");
 206 |     |         return a - b;
 207 |     |     }
 208 |     | 
 209 |     |     /*//////////////////////////////////////////////////////////////
 210 |     |                                 HELPERS
 211 |     |     //////////////////////////////////////////////////////////////*/
 212 |     | 
 213 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 214 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 215 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 216 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 217 |     |     function _viewChainId() private view returns (uint256 chainId) {
 218 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 219 |     |         assembly {
 220 |     |             chainId := chainid()
 221 |     |         }
 222 |     | 
 223 |     |         address(this); // Silence warnings in older Solc versions.
 224 |     |     }
 225 |     | 
 226 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 227 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 228 |     |         function() internal pure returns (uint256) pureChainId;
 229 |     |         assembly {
 230 |     |             pureChainId := fnIn
 231 |     |         }
 232 |     |         chainId = pureChainId();
 233 |     |     }
 234 |     | }
 235 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/mocks/MockERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {IERC721Metadata, IERC721TokenReceiver} from "../interfaces/IERC721.sol";
   5 |     | 
   6 |     | /// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.
   7 |     | /// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol
   8 |     | contract MockERC721 is IERC721Metadata {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                          METADATA STORAGE/LOGIC
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     string internal _name;
  14 |     | 
  15 |     |     string internal _symbol;
  16 |     | 
  17 |     |     function name() external view override returns (string memory) {
  18 |     |         return _name;
  19 |     |     }
  20 |     | 
  21 |     |     function symbol() external view override returns (string memory) {
  22 |     |         return _symbol;
  23 |     |     }
  24 |     | 
  25 |     |     function tokenURI(uint256 id) public view virtual override returns (string memory) {}
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                       ERC721 BALANCE/OWNER STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     mapping(uint256 => address) internal _ownerOf;
  32 |     | 
  33 |     |     mapping(address => uint256) internal _balanceOf;
  34 |     | 
  35 |     |     function ownerOf(uint256 id) public view virtual override returns (address owner) {
  36 |     |         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");
  37 |     |     }
  38 |     | 
  39 |     |     function balanceOf(address owner) public view virtual override returns (uint256) {
  40 |     |         require(owner != address(0), "ZERO_ADDRESS");
  41 |     | 
  42 |     |         return _balanceOf[owner];
  43 |     |     }
  44 |     | 
  45 |     |     /*//////////////////////////////////////////////////////////////
  46 |     |                          ERC721 APPROVAL STORAGE
  47 |     |     //////////////////////////////////////////////////////////////*/
  48 |     | 
  49 |     |     mapping(uint256 => address) internal _getApproved;
  50 |     | 
  51 |     |     mapping(address => mapping(address => bool)) internal _isApprovedForAll;
  52 |     | 
  53 |     |     function getApproved(uint256 id) public view virtual override returns (address) {
  54 |     |         return _getApproved[id];
  55 |     |     }
  56 |     | 
  57 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
  58 |     |         return _isApprovedForAll[owner][operator];
  59 |     |     }
  60 |     | 
  61 |     |     /*//////////////////////////////////////////////////////////////
  62 |     |                                INITIALIZE
  63 |     |     //////////////////////////////////////////////////////////////*/
  64 |     | 
  65 |     |     /// @dev A bool to track whether the contract has been initialized.
  66 |     |     bool private initialized;
  67 |     | 
  68 |     |     /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and
  69 |     |     /// syntaxes, we add an initialization function that can be called only once.
  70 |     |     function initialize(string memory name_, string memory symbol_) public {
  71 |     |         require(!initialized, "ALREADY_INITIALIZED");
  72 |     | 
  73 |     |         _name = name_;
  74 |     |         _symbol = symbol_;
  75 |     | 
  76 |     |         initialized = true;
  77 |     |     }
  78 |     | 
  79 |     |     /*//////////////////////////////////////////////////////////////
  80 |     |                               ERC721 LOGIC
  81 |     |     //////////////////////////////////////////////////////////////*/
  82 |     | 
  83 |     |     function approve(address spender, uint256 id) public payable virtual override {
  84 |     |         address owner = _ownerOf[id];
  85 |     | 
  86 |     |         require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");
  87 |     | 
  88 |     |         _getApproved[id] = spender;
  89 |     | 
  90 |     |         emit Approval(owner, spender, id);
  91 |     |     }
  92 |     | 
  93 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
  94 |     |         _isApprovedForAll[msg.sender][operator] = approved;
  95 |     | 
  96 |     |         emit ApprovalForAll(msg.sender, operator, approved);
  97 |     |     }
  98 |     | 
  99 |     |     function transferFrom(address from, address to, uint256 id) public payable virtual override {
 100 |     |         require(from == _ownerOf[id], "WRONG_FROM");
 101 |     | 
 102 |     |         require(to != address(0), "INVALID_RECIPIENT");
 103 |     | 
 104 |     |         require(
 105 |     |             msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],
 106 |     |             "NOT_AUTHORIZED"
 107 |     |         );
 108 |     | 
 109 |     |         // Underflow of the sender's balance is impossible because we check for
 110 |     |         // ownership above and the recipient's balance can't realistically overflow.
 111 |     |         _balanceOf[from]--;
 112 |     | 
 113 |     |         _balanceOf[to]++;
 114 |     | 
 115 |     |         _ownerOf[id] = to;
 116 |     | 
 117 |     |         delete _getApproved[id];
 118 |     | 
 119 |     |         emit Transfer(from, to, id);
 120 |     |     }
 121 |     | 
 122 |     |     function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {
 123 |     |         transferFrom(from, to, id);
 124 |     | 
 125 |     |         require(
 126 |     |             !_isContract(to)
 127 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
 128 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 129 |     |             "UNSAFE_RECIPIENT"
 130 |     |         );
 131 |     |     }
 132 |     | 
 133 |     |     function safeTransferFrom(address from, address to, uint256 id, bytes memory data)
 134 |     |         public
 135 |     |         payable
 136 |     |         virtual
 137 |     |         override
 138 |     |     {
 139 |     |         transferFrom(from, to, id);
 140 |     | 
 141 |     |         require(
 142 |     |             !_isContract(to)
 143 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
 144 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 145 |     |             "UNSAFE_RECIPIENT"
 146 |     |         );
 147 |     |     }
 148 |     | 
 149 |     |     /*//////////////////////////////////////////////////////////////
 150 |     |                               ERC165 LOGIC
 151 |     |     //////////////////////////////////////////////////////////////*/
 152 |     | 
 153 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 154 |     |         return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165
 155 |     |             || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721
 156 |     |             || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
 157 |     |     }
 158 |     | 
 159 |     |     /*//////////////////////////////////////////////////////////////
 160 |     |                         INTERNAL MINT/BURN LOGIC
 161 |     |     //////////////////////////////////////////////////////////////*/
 162 |     | 
 163 |     |     function _mint(address to, uint256 id) internal virtual {
 164 |     |         require(to != address(0), "INVALID_RECIPIENT");
 165 |     | 
 166 |     |         require(_ownerOf[id] == address(0), "ALREADY_MINTED");
 167 |     | 
 168 |     |         // Counter overflow is incredibly unrealistic.
 169 |     | 
 170 |     |         _balanceOf[to]++;
 171 |     | 
 172 |     |         _ownerOf[id] = to;
 173 |     | 
 174 |     |         emit Transfer(address(0), to, id);
 175 |     |     }
 176 |     | 
 177 |     |     function _burn(uint256 id) internal virtual {
 178 |     |         address owner = _ownerOf[id];
 179 |     | 
 180 |     |         require(owner != address(0), "NOT_MINTED");
 181 |     | 
 182 |     |         _balanceOf[owner]--;
 183 |     | 
 184 |     |         delete _ownerOf[id];
 185 |     | 
 186 |     |         delete _getApproved[id];
 187 |     | 
 188 |     |         emit Transfer(owner, address(0), id);
 189 |     |     }
 190 |     | 
 191 |     |     /*//////////////////////////////////////////////////////////////
 192 |     |                         INTERNAL SAFE MINT LOGIC
 193 |     |     //////////////////////////////////////////////////////////////*/
 194 |     | 
 195 |     |     function _safeMint(address to, uint256 id) internal virtual {
 196 |     |         _mint(to, id);
 197 |     | 
 198 |     |         require(
 199 |     |             !_isContract(to)
 200 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
 201 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 202 |     |             "UNSAFE_RECIPIENT"
 203 |     |         );
 204 |     |     }
 205 |     | 
 206 |     |     function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
 207 |     |         _mint(to, id);
 208 |     | 
 209 |     |         require(
 210 |     |             !_isContract(to)
 211 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
 212 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 213 |     |             "UNSAFE_RECIPIENT"
 214 |     |         );
 215 |     |     }
 216 |     | 
 217 |     |     /*//////////////////////////////////////////////////////////////
 218 |     |                                 HELPERS
 219 |     |     //////////////////////////////////////////////////////////////*/
 220 |     | 
 221 |     |     function _isContract(address _addr) private view returns (bool) {
 222 |     |         uint256 codeLength;
 223 |     | 
 224 |     |         // Assembly required for versions < 0.8.0 to check extcodesize.
 225 |     |         assembly {
 226 |     |             codeLength := extcodesize(_addr)
 227 |     |         }
 228 |     | 
 229 |     |         return codeLength > 0;
 230 |     |     }
 231 |     | }
 232 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/forge-std/src/safeconsole.sol
     1 |     | // SPDX-License-Identifier: MIT
     2 |     | pragma solidity >=0.6.2 <0.9.0;
     3 |     | 
     4 |     | /// @author philogy <https://github.com/philogy>
     5 |     | /// @dev Code generated automatically by script.
     6 |     | library safeconsole {
     7 |     |     uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;
     8 |     | 
     9 |     |     // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)
    10 |     |     // for the view-to-pure log trick.
    11 |     |     function _sendLogPayload(uint256 offset, uint256 size) private pure {
    12 |     |         function(uint256, uint256) internal view fnIn = _sendLogPayloadView;
    13 |     |         function(uint256, uint256) internal pure pureSendLogPayload;
    14 |     |         assembly {
    15 |     |             pureSendLogPayload := fnIn
    16 |     |         }
    17 |     |         pureSendLogPayload(offset, size);
    18 |     |     }
    19 |     | 
    20 |     |     function _sendLogPayloadView(uint256 offset, uint256 size) private view {
    21 |     |         assembly {
    22 |     |             pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))
    23 |     |         }
    24 |     |     }
    25 |     | 
    26 |     |     function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {
    27 |     |         function(uint256, uint256, uint256) internal view fnIn = _memcopyView;
    28 |     |         function(uint256, uint256, uint256) internal pure pureMemcopy;
    29 |     |         assembly {
    30 |     |             pureMemcopy := fnIn
    31 |     |         }
    32 |     |         pureMemcopy(fromOffset, toOffset, length);
    33 |     |     }
    34 |     | 
    35 |     |     function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {
    36 |     |         assembly {
    37 |     |             pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))
    38 |     |         }
    39 |     |     }
    40 |     | 
    41 |     |     function logMemory(uint256 offset, uint256 length) internal pure {
    42 |     |         if (offset >= 0x60) {
    43 |     |             // Sufficient memory before slice to prepare call header.
    44 |     |             bytes32 m0;
    45 |     |             bytes32 m1;
    46 |     |             bytes32 m2;
    47 |     |             assembly {
    48 |     |                 m0 := mload(sub(offset, 0x60))
    49 |     |                 m1 := mload(sub(offset, 0x40))
    50 |     |                 m2 := mload(sub(offset, 0x20))
    51 |     |                 // Selector of `logBytes(bytes)`.
    52 |     |                 mstore(sub(offset, 0x60), 0xe17bf956)
    53 |     |                 mstore(sub(offset, 0x40), 0x20)
    54 |     |                 mstore(sub(offset, 0x20), length)
    55 |     |             }
    56 |     |             _sendLogPayload(offset - 0x44, length + 0x44);
    57 |     |             assembly {
    58 |     |                 mstore(sub(offset, 0x60), m0)
    59 |     |                 mstore(sub(offset, 0x40), m1)
    60 |     |                 mstore(sub(offset, 0x20), m2)
    61 |     |             }
    62 |     |         } else {
    63 |     |             // Insufficient space, so copy slice forward, add header and reverse.
    64 |     |             bytes32 m0;
    65 |     |             bytes32 m1;
    66 |     |             bytes32 m2;
    67 |     |             uint256 endOffset = offset + length;
    68 |     |             assembly {
    69 |     |                 m0 := mload(add(endOffset, 0x00))
    70 |     |                 m1 := mload(add(endOffset, 0x20))
    71 |     |                 m2 := mload(add(endOffset, 0x40))
    72 |     |             }
    73 |     |             _memcopy(offset, offset + 0x60, length);
    74 |     |             assembly {
    75 |     |                 // Selector of `logBytes(bytes)`.
    76 |     |                 mstore(add(offset, 0x00), 0xe17bf956)
    77 |     |                 mstore(add(offset, 0x20), 0x20)
    78 |     |                 mstore(add(offset, 0x40), length)
    79 |     |             }
    80 |     |             _sendLogPayload(offset + 0x1c, length + 0x44);
    81 |     |             _memcopy(offset + 0x60, offset, length);
    82 |     |             assembly {
    83 |     |                 mstore(add(endOffset, 0x00), m0)
    84 |     |                 mstore(add(endOffset, 0x20), m1)
    85 |     |                 mstore(add(endOffset, 0x40), m2)
    86 |     |             }
    87 |     |         }
    88 |     |     }
    89 |     | 
    90 |     |     function log(address p0) internal pure {
    91 |     |         bytes32 m0;
    92 |     |         bytes32 m1;
    93 |     |         assembly {
    94 |     |             m0 := mload(0x00)
    95 |     |             m1 := mload(0x20)
    96 |     |             // Selector of `log(address)`.
    97 |     |             mstore(0x00, 0x2c2ecbc2)
    98 |     |             mstore(0x20, p0)
    99 |     |         }
   100 |     |         _sendLogPayload(0x1c, 0x24);
   101 |     |         assembly {
   102 |     |             mstore(0x00, m0)
   103 |     |             mstore(0x20, m1)
   104 |     |         }
   105 |     |     }
   106 |     | 
   107 |     |     function log(bool p0) internal pure {
   108 |     |         bytes32 m0;
   109 |     |         bytes32 m1;
   110 |     |         assembly {
   111 |     |             m0 := mload(0x00)
   112 |     |             m1 := mload(0x20)
   113 |     |             // Selector of `log(bool)`.
   114 |     |             mstore(0x00, 0x32458eed)
   115 |     |             mstore(0x20, p0)
   116 |     |         }
   117 |     |         _sendLogPayload(0x1c, 0x24);
   118 |     |         assembly {
   119 |     |             mstore(0x00, m0)
   120 |     |             mstore(0x20, m1)
   121 |     |         }
   122 |     |     }
   123 |     | 
   124 |     |     function log(uint256 p0) internal pure {
   125 |     |         bytes32 m0;
   126 |     |         bytes32 m1;
   127 |     |         assembly {
   128 |     |             m0 := mload(0x00)
   129 |     |             m1 := mload(0x20)
   130 |     |             // Selector of `log(uint256)`.
   131 |     |             mstore(0x00, 0xf82c50f1)
   132 |     |             mstore(0x20, p0)
   133 |     |         }
   134 |     |         _sendLogPayload(0x1c, 0x24);
   135 |     |         assembly {
   136 |     |             mstore(0x00, m0)
   137 |     |             mstore(0x20, m1)
   138 |     |         }
   139 |     |     }
   140 |     | 
   141 |     |     function log(bytes32 p0) internal pure {
   142 |     |         bytes32 m0;
   143 |     |         bytes32 m1;
   144 |     |         bytes32 m2;
   145 |     |         bytes32 m3;
   146 |     |         assembly {
   147 |     |             function writeString(pos, w) {
   148 |     |                 let length := 0
   149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   150 |     |                 mstore(pos, length)
   151 |     |                 let shift := sub(256, shl(3, length))
   152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   153 |     |             }
   154 |     |             m0 := mload(0x00)
   155 |     |             m1 := mload(0x20)
   156 |     |             m2 := mload(0x40)
   157 |     |             m3 := mload(0x60)
   158 |     |             // Selector of `log(string)`.
   159 |     |             mstore(0x00, 0x41304fac)
   160 |     |             mstore(0x20, 0x20)
   161 |     |             writeString(0x40, p0)
   162 |     |         }
   163 |     |         _sendLogPayload(0x1c, 0x64);
   164 |     |         assembly {
   165 |     |             mstore(0x00, m0)
   166 |     |             mstore(0x20, m1)
   167 |     |             mstore(0x40, m2)
   168 |     |             mstore(0x60, m3)
   169 |     |         }
   170 |     |     }
   171 |     | 
   172 |     |     function log(address p0, address p1) internal pure {
   173 |     |         bytes32 m0;
   174 |     |         bytes32 m1;
   175 |     |         bytes32 m2;
   176 |     |         assembly {
   177 |     |             m0 := mload(0x00)
   178 |     |             m1 := mload(0x20)
   179 |     |             m2 := mload(0x40)
   180 |     |             // Selector of `log(address,address)`.
   181 |     |             mstore(0x00, 0xdaf0d4aa)
   182 |     |             mstore(0x20, p0)
   183 |     |             mstore(0x40, p1)
   184 |     |         }
   185 |     |         _sendLogPayload(0x1c, 0x44);
   186 |     |         assembly {
   187 |     |             mstore(0x00, m0)
   188 |     |             mstore(0x20, m1)
   189 |     |             mstore(0x40, m2)
   190 |     |         }
   191 |     |     }
   192 |     | 
   193 |     |     function log(address p0, bool p1) internal pure {
   194 |     |         bytes32 m0;
   195 |     |         bytes32 m1;
   196 |     |         bytes32 m2;
   197 |     |         assembly {
   198 |     |             m0 := mload(0x00)
   199 |     |             m1 := mload(0x20)
   200 |     |             m2 := mload(0x40)
   201 |     |             // Selector of `log(address,bool)`.
   202 |     |             mstore(0x00, 0x75b605d3)
   203 |     |             mstore(0x20, p0)
   204 |     |             mstore(0x40, p1)
   205 |     |         }
   206 |     |         _sendLogPayload(0x1c, 0x44);
   207 |     |         assembly {
   208 |     |             mstore(0x00, m0)
   209 |     |             mstore(0x20, m1)
   210 |     |             mstore(0x40, m2)
   211 |     |         }
   212 |     |     }
   213 |     | 
   214 |     |     function log(address p0, uint256 p1) internal pure {
   215 |     |         bytes32 m0;
   216 |     |         bytes32 m1;
   217 |     |         bytes32 m2;
   218 |     |         assembly {
   219 |     |             m0 := mload(0x00)
   220 |     |             m1 := mload(0x20)
   221 |     |             m2 := mload(0x40)
   222 |     |             // Selector of `log(address,uint256)`.
   223 |     |             mstore(0x00, 0x8309e8a8)
   224 |     |             mstore(0x20, p0)
   225 |     |             mstore(0x40, p1)
   226 |     |         }
   227 |     |         _sendLogPayload(0x1c, 0x44);
   228 |     |         assembly {
   229 |     |             mstore(0x00, m0)
   230 |     |             mstore(0x20, m1)
   231 |     |             mstore(0x40, m2)
   232 |     |         }
   233 |     |     }
   234 |     | 
   235 |     |     function log(address p0, bytes32 p1) internal pure {
   236 |     |         bytes32 m0;
   237 |     |         bytes32 m1;
   238 |     |         bytes32 m2;
   239 |     |         bytes32 m3;
   240 |     |         bytes32 m4;
   241 |     |         assembly {
   242 |     |             function writeString(pos, w) {
   243 |     |                 let length := 0
   244 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   245 |     |                 mstore(pos, length)
   246 |     |                 let shift := sub(256, shl(3, length))
   247 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   248 |     |             }
   249 |     |             m0 := mload(0x00)
   250 |     |             m1 := mload(0x20)
   251 |     |             m2 := mload(0x40)
   252 |     |             m3 := mload(0x60)
   253 |     |             m4 := mload(0x80)
   254 |     |             // Selector of `log(address,string)`.
   255 |     |             mstore(0x00, 0x759f86bb)
   256 |     |             mstore(0x20, p0)
   257 |     |             mstore(0x40, 0x40)
   258 |     |             writeString(0x60, p1)
   259 |     |         }
   260 |     |         _sendLogPayload(0x1c, 0x84);
   261 |     |         assembly {
   262 |     |             mstore(0x00, m0)
   263 |     |             mstore(0x20, m1)
   264 |     |             mstore(0x40, m2)
   265 |     |             mstore(0x60, m3)
   266 |     |             mstore(0x80, m4)
   267 |     |         }
   268 |     |     }
   269 |     | 
   270 |     |     function log(bool p0, address p1) internal pure {
   271 |     |         bytes32 m0;
   272 |     |         bytes32 m1;
   273 |     |         bytes32 m2;
   274 |     |         assembly {
   275 |     |             m0 := mload(0x00)
   276 |     |             m1 := mload(0x20)
   277 |     |             m2 := mload(0x40)
   278 |     |             // Selector of `log(bool,address)`.
   279 |     |             mstore(0x00, 0x853c4849)
   280 |     |             mstore(0x20, p0)
   281 |     |             mstore(0x40, p1)
   282 |     |         }
   283 |     |         _sendLogPayload(0x1c, 0x44);
   284 |     |         assembly {
   285 |     |             mstore(0x00, m0)
   286 |     |             mstore(0x20, m1)
   287 |     |             mstore(0x40, m2)
   288 |     |         }
   289 |     |     }
   290 |     | 
   291 |     |     function log(bool p0, bool p1) internal pure {
   292 |     |         bytes32 m0;
   293 |     |         bytes32 m1;
   294 |     |         bytes32 m2;
   295 |     |         assembly {
   296 |     |             m0 := mload(0x00)
   297 |     |             m1 := mload(0x20)
   298 |     |             m2 := mload(0x40)
   299 |     |             // Selector of `log(bool,bool)`.
   300 |     |             mstore(0x00, 0x2a110e83)
   301 |     |             mstore(0x20, p0)
   302 |     |             mstore(0x40, p1)
   303 |     |         }
   304 |     |         _sendLogPayload(0x1c, 0x44);
   305 |     |         assembly {
   306 |     |             mstore(0x00, m0)
   307 |     |             mstore(0x20, m1)
   308 |     |             mstore(0x40, m2)
   309 |     |         }
   310 |     |     }
   311 |     | 
   312 |     |     function log(bool p0, uint256 p1) internal pure {
   313 |     |         bytes32 m0;
   314 |     |         bytes32 m1;
   315 |     |         bytes32 m2;
   316 |     |         assembly {
   317 |     |             m0 := mload(0x00)
   318 |     |             m1 := mload(0x20)
   319 |     |             m2 := mload(0x40)
   320 |     |             // Selector of `log(bool,uint256)`.
   321 |     |             mstore(0x00, 0x399174d3)
   322 |     |             mstore(0x20, p0)
   323 |     |             mstore(0x40, p1)
   324 |     |         }
   325 |     |         _sendLogPayload(0x1c, 0x44);
   326 |     |         assembly {
   327 |     |             mstore(0x00, m0)
   328 |     |             mstore(0x20, m1)
   329 |     |             mstore(0x40, m2)
   330 |     |         }
   331 |     |     }
   332 |     | 
   333 |     |     function log(bool p0, bytes32 p1) internal pure {
   334 |     |         bytes32 m0;
   335 |     |         bytes32 m1;
   336 |     |         bytes32 m2;
   337 |     |         bytes32 m3;
   338 |     |         bytes32 m4;
   339 |     |         assembly {
   340 |     |             function writeString(pos, w) {
   341 |     |                 let length := 0
   342 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   343 |     |                 mstore(pos, length)
   344 |     |                 let shift := sub(256, shl(3, length))
   345 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   346 |     |             }
   347 |     |             m0 := mload(0x00)
   348 |     |             m1 := mload(0x20)
   349 |     |             m2 := mload(0x40)
   350 |     |             m3 := mload(0x60)
   351 |     |             m4 := mload(0x80)
   352 |     |             // Selector of `log(bool,string)`.
   353 |     |             mstore(0x00, 0x8feac525)
   354 |     |             mstore(0x20, p0)
   355 |     |             mstore(0x40, 0x40)
   356 |     |             writeString(0x60, p1)
   357 |     |         }
   358 |     |         _sendLogPayload(0x1c, 0x84);
   359 |     |         assembly {
   360 |     |             mstore(0x00, m0)
   361 |     |             mstore(0x20, m1)
   362 |     |             mstore(0x40, m2)
   363 |     |             mstore(0x60, m3)
   364 |     |             mstore(0x80, m4)
   365 |     |         }
   366 |     |     }
   367 |     | 
   368 |     |     function log(uint256 p0, address p1) internal pure {
   369 |     |         bytes32 m0;
   370 |     |         bytes32 m1;
   371 |     |         bytes32 m2;
   372 |     |         assembly {
   373 |     |             m0 := mload(0x00)
   374 |     |             m1 := mload(0x20)
   375 |     |             m2 := mload(0x40)
   376 |     |             // Selector of `log(uint256,address)`.
   377 |     |             mstore(0x00, 0x69276c86)
   378 |     |             mstore(0x20, p0)
   379 |     |             mstore(0x40, p1)
   380 |     |         }
   381 |     |         _sendLogPayload(0x1c, 0x44);
   382 |     |         assembly {
   383 |     |             mstore(0x00, m0)
   384 |     |             mstore(0x20, m1)
   385 |     |             mstore(0x40, m2)
   386 |     |         }
   387 |     |     }
   388 |     | 
   389 |     |     function log(uint256 p0, bool p1) internal pure {
   390 |     |         bytes32 m0;
   391 |     |         bytes32 m1;
   392 |     |         bytes32 m2;
   393 |     |         assembly {
   394 |     |             m0 := mload(0x00)
   395 |     |             m1 := mload(0x20)
   396 |     |             m2 := mload(0x40)
   397 |     |             // Selector of `log(uint256,bool)`.
   398 |     |             mstore(0x00, 0x1c9d7eb3)
   399 |     |             mstore(0x20, p0)
   400 |     |             mstore(0x40, p1)
   401 |     |         }
   402 |     |         _sendLogPayload(0x1c, 0x44);
   403 |     |         assembly {
   404 |     |             mstore(0x00, m0)
   405 |     |             mstore(0x20, m1)
   406 |     |             mstore(0x40, m2)
   407 |     |         }
   408 |     |     }
   409 |     | 
   410 |     |     function log(uint256 p0, uint256 p1) internal pure {
   411 |     |         bytes32 m0;
   412 |     |         bytes32 m1;
   413 |     |         bytes32 m2;
   414 |     |         assembly {
   415 |     |             m0 := mload(0x00)
   416 |     |             m1 := mload(0x20)
   417 |     |             m2 := mload(0x40)
   418 |     |             // Selector of `log(uint256,uint256)`.
   419 |     |             mstore(0x00, 0xf666715a)
   420 |     |             mstore(0x20, p0)
   421 |     |             mstore(0x40, p1)
   422 |     |         }
   423 |     |         _sendLogPayload(0x1c, 0x44);
   424 |     |         assembly {
   425 |     |             mstore(0x00, m0)
   426 |     |             mstore(0x20, m1)
   427 |     |             mstore(0x40, m2)
   428 |     |         }
   429 |     |     }
   430 |     | 
   431 |     |     function log(uint256 p0, bytes32 p1) internal pure {
   432 |     |         bytes32 m0;
   433 |     |         bytes32 m1;
   434 |     |         bytes32 m2;
   435 |     |         bytes32 m3;
   436 |     |         bytes32 m4;
   437 |     |         assembly {
   438 |     |             function writeString(pos, w) {
   439 |     |                 let length := 0
   440 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   441 |     |                 mstore(pos, length)
   442 |     |                 let shift := sub(256, shl(3, length))
   443 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   444 |     |             }
   445 |     |             m0 := mload(0x00)
   446 |     |             m1 := mload(0x20)
   447 |     |             m2 := mload(0x40)
   448 |     |             m3 := mload(0x60)
   449 |     |             m4 := mload(0x80)
   450 |     |             // Selector of `log(uint256,string)`.
   451 |     |             mstore(0x00, 0x643fd0df)
   452 |     |             mstore(0x20, p0)
   453 |     |             mstore(0x40, 0x40)
   454 |     |             writeString(0x60, p1)
   455 |     |         }
   456 |     |         _sendLogPayload(0x1c, 0x84);
   457 |     |         assembly {
   458 |     |             mstore(0x00, m0)
   459 |     |             mstore(0x20, m1)
   460 |     |             mstore(0x40, m2)
   461 |     |             mstore(0x60, m3)
   462 |     |             mstore(0x80, m4)
   463 |     |         }
   464 |     |     }
   465 |     | 
   466 |     |     function log(bytes32 p0, address p1) internal pure {
   467 |     |         bytes32 m0;
   468 |     |         bytes32 m1;
   469 |     |         bytes32 m2;
   470 |     |         bytes32 m3;
   471 |     |         bytes32 m4;
   472 |     |         assembly {
   473 |     |             function writeString(pos, w) {
   474 |     |                 let length := 0
   475 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   476 |     |                 mstore(pos, length)
   477 |     |                 let shift := sub(256, shl(3, length))
   478 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   479 |     |             }
   480 |     |             m0 := mload(0x00)
   481 |     |             m1 := mload(0x20)
   482 |     |             m2 := mload(0x40)
   483 |     |             m3 := mload(0x60)
   484 |     |             m4 := mload(0x80)
   485 |     |             // Selector of `log(string,address)`.
   486 |     |             mstore(0x00, 0x319af333)
   487 |     |             mstore(0x20, 0x40)
   488 |     |             mstore(0x40, p1)
   489 |     |             writeString(0x60, p0)
   490 |     |         }
   491 |     |         _sendLogPayload(0x1c, 0x84);
   492 |     |         assembly {
   493 |     |             mstore(0x00, m0)
   494 |     |             mstore(0x20, m1)
   495 |     |             mstore(0x40, m2)
   496 |     |             mstore(0x60, m3)
   497 |     |             mstore(0x80, m4)
   498 |     |         }
   499 |     |     }
   500 |     | 
   501 |     |     function log(bytes32 p0, bool p1) internal pure {
   502 |     |         bytes32 m0;
   503 |     |         bytes32 m1;
   504 |     |         bytes32 m2;
   505 |     |         bytes32 m3;
   506 |     |         bytes32 m4;
   507 |     |         assembly {
   508 |     |             function writeString(pos, w) {
   509 |     |                 let length := 0
   510 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   511 |     |                 mstore(pos, length)
   512 |     |                 let shift := sub(256, shl(3, length))
   513 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   514 |     |             }
   515 |     |             m0 := mload(0x00)
   516 |     |             m1 := mload(0x20)
   517 |     |             m2 := mload(0x40)
   518 |     |             m3 := mload(0x60)
   519 |     |             m4 := mload(0x80)
   520 |     |             // Selector of `log(string,bool)`.
   521 |     |             mstore(0x00, 0xc3b55635)
   522 |     |             mstore(0x20, 0x40)
   523 |     |             mstore(0x40, p1)
   524 |     |             writeString(0x60, p0)
   525 |     |         }
   526 |     |         _sendLogPayload(0x1c, 0x84);
   527 |     |         assembly {
   528 |     |             mstore(0x00, m0)
   529 |     |             mstore(0x20, m1)
   530 |     |             mstore(0x40, m2)
   531 |     |             mstore(0x60, m3)
   532 |     |             mstore(0x80, m4)
   533 |     |         }
   534 |     |     }
   535 |     | 
   536 |     |     function log(bytes32 p0, uint256 p1) internal pure {
   537 |     |         bytes32 m0;
   538 |     |         bytes32 m1;
   539 |     |         bytes32 m2;
   540 |     |         bytes32 m3;
   541 |     |         bytes32 m4;
   542 |     |         assembly {
   543 |     |             function writeString(pos, w) {
   544 |     |                 let length := 0
   545 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   546 |     |                 mstore(pos, length)
   547 |     |                 let shift := sub(256, shl(3, length))
   548 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   549 |     |             }
   550 |     |             m0 := mload(0x00)
   551 |     |             m1 := mload(0x20)
   552 |     |             m2 := mload(0x40)
   553 |     |             m3 := mload(0x60)
   554 |     |             m4 := mload(0x80)
   555 |     |             // Selector of `log(string,uint256)`.
   556 |     |             mstore(0x00, 0xb60e72cc)
   557 |     |             mstore(0x20, 0x40)
   558 |     |             mstore(0x40, p1)
   559 |     |             writeString(0x60, p0)
   560 |     |         }
   561 |     |         _sendLogPayload(0x1c, 0x84);
   562 |     |         assembly {
   563 |     |             mstore(0x00, m0)
   564 |     |             mstore(0x20, m1)
   565 |     |             mstore(0x40, m2)
   566 |     |             mstore(0x60, m3)
   567 |     |             mstore(0x80, m4)
   568 |     |         }
   569 |     |     }
   570 |     | 
   571 |     |     function log(bytes32 p0, bytes32 p1) internal pure {
   572 |     |         bytes32 m0;
   573 |     |         bytes32 m1;
   574 |     |         bytes32 m2;
   575 |     |         bytes32 m3;
   576 |     |         bytes32 m4;
   577 |     |         bytes32 m5;
   578 |     |         bytes32 m6;
   579 |     |         assembly {
   580 |     |             function writeString(pos, w) {
   581 |     |                 let length := 0
   582 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   583 |     |                 mstore(pos, length)
   584 |     |                 let shift := sub(256, shl(3, length))
   585 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   586 |     |             }
   587 |     |             m0 := mload(0x00)
   588 |     |             m1 := mload(0x20)
   589 |     |             m2 := mload(0x40)
   590 |     |             m3 := mload(0x60)
   591 |     |             m4 := mload(0x80)
   592 |     |             m5 := mload(0xa0)
   593 |     |             m6 := mload(0xc0)
   594 |     |             // Selector of `log(string,string)`.
   595 |     |             mstore(0x00, 0x4b5c4277)
   596 |     |             mstore(0x20, 0x40)
   597 |     |             mstore(0x40, 0x80)
   598 |     |             writeString(0x60, p0)
   599 |     |             writeString(0xa0, p1)
   600 |     |         }
   601 |     |         _sendLogPayload(0x1c, 0xc4);
   602 |     |         assembly {
   603 |     |             mstore(0x00, m0)
   604 |     |             mstore(0x20, m1)
   605 |     |             mstore(0x40, m2)
   606 |     |             mstore(0x60, m3)
   607 |     |             mstore(0x80, m4)
   608 |     |             mstore(0xa0, m5)
   609 |     |             mstore(0xc0, m6)
   610 |     |         }
   611 |     |     }
   612 |     | 
   613 |     |     function log(address p0, address p1, address p2) internal pure {
   614 |     |         bytes32 m0;
   615 |     |         bytes32 m1;
   616 |     |         bytes32 m2;
   617 |     |         bytes32 m3;
   618 |     |         assembly {
   619 |     |             m0 := mload(0x00)
   620 |     |             m1 := mload(0x20)
   621 |     |             m2 := mload(0x40)
   622 |     |             m3 := mload(0x60)
   623 |     |             // Selector of `log(address,address,address)`.
   624 |     |             mstore(0x00, 0x018c84c2)
   625 |     |             mstore(0x20, p0)
   626 |     |             mstore(0x40, p1)
   627 |     |             mstore(0x60, p2)
   628 |     |         }
   629 |     |         _sendLogPayload(0x1c, 0x64);
   630 |     |         assembly {
   631 |     |             mstore(0x00, m0)
   632 |     |             mstore(0x20, m1)
   633 |     |             mstore(0x40, m2)
   634 |     |             mstore(0x60, m3)
   635 |     |         }
   636 |     |     }
   637 |     | 
   638 |     |     function log(address p0, address p1, bool p2) internal pure {
   639 |     |         bytes32 m0;
   640 |     |         bytes32 m1;
   641 |     |         bytes32 m2;
   642 |     |         bytes32 m3;
   643 |     |         assembly {
   644 |     |             m0 := mload(0x00)
   645 |     |             m1 := mload(0x20)
   646 |     |             m2 := mload(0x40)
   647 |     |             m3 := mload(0x60)
   648 |     |             // Selector of `log(address,address,bool)`.
   649 |     |             mstore(0x00, 0xf2a66286)
   650 |     |             mstore(0x20, p0)
   651 |     |             mstore(0x40, p1)
   652 |     |             mstore(0x60, p2)
   653 |     |         }
   654 |     |         _sendLogPayload(0x1c, 0x64);
   655 |     |         assembly {
   656 |     |             mstore(0x00, m0)
   657 |     |             mstore(0x20, m1)
   658 |     |             mstore(0x40, m2)
   659 |     |             mstore(0x60, m3)
   660 |     |         }
   661 |     |     }
   662 |     | 
   663 |     |     function log(address p0, address p1, uint256 p2) internal pure {
   664 |     |         bytes32 m0;
   665 |     |         bytes32 m1;
   666 |     |         bytes32 m2;
   667 |     |         bytes32 m3;
   668 |     |         assembly {
   669 |     |             m0 := mload(0x00)
   670 |     |             m1 := mload(0x20)
   671 |     |             m2 := mload(0x40)
   672 |     |             m3 := mload(0x60)
   673 |     |             // Selector of `log(address,address,uint256)`.
   674 |     |             mstore(0x00, 0x17fe6185)
   675 |     |             mstore(0x20, p0)
   676 |     |             mstore(0x40, p1)
   677 |     |             mstore(0x60, p2)
   678 |     |         }
   679 |     |         _sendLogPayload(0x1c, 0x64);
   680 |     |         assembly {
   681 |     |             mstore(0x00, m0)
   682 |     |             mstore(0x20, m1)
   683 |     |             mstore(0x40, m2)
   684 |     |             mstore(0x60, m3)
   685 |     |         }
   686 |     |     }
   687 |     | 
   688 |     |     function log(address p0, address p1, bytes32 p2) internal pure {
   689 |     |         bytes32 m0;
   690 |     |         bytes32 m1;
   691 |     |         bytes32 m2;
   692 |     |         bytes32 m3;
   693 |     |         bytes32 m4;
   694 |     |         bytes32 m5;
   695 |     |         assembly {
   696 |     |             function writeString(pos, w) {
   697 |     |                 let length := 0
   698 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   699 |     |                 mstore(pos, length)
   700 |     |                 let shift := sub(256, shl(3, length))
   701 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   702 |     |             }
   703 |     |             m0 := mload(0x00)
   704 |     |             m1 := mload(0x20)
   705 |     |             m2 := mload(0x40)
   706 |     |             m3 := mload(0x60)
   707 |     |             m4 := mload(0x80)
   708 |     |             m5 := mload(0xa0)
   709 |     |             // Selector of `log(address,address,string)`.
   710 |     |             mstore(0x00, 0x007150be)
   711 |     |             mstore(0x20, p0)
   712 |     |             mstore(0x40, p1)
   713 |     |             mstore(0x60, 0x60)
   714 |     |             writeString(0x80, p2)
   715 |     |         }
   716 |     |         _sendLogPayload(0x1c, 0xa4);
   717 |     |         assembly {
   718 |     |             mstore(0x00, m0)
   719 |     |             mstore(0x20, m1)
   720 |     |             mstore(0x40, m2)
   721 |     |             mstore(0x60, m3)
   722 |     |             mstore(0x80, m4)
   723 |     |             mstore(0xa0, m5)
   724 |     |         }
   725 |     |     }
   726 |     | 
   727 |     |     function log(address p0, bool p1, address p2) internal pure {
   728 |     |         bytes32 m0;
   729 |     |         bytes32 m1;
   730 |     |         bytes32 m2;
   731 |     |         bytes32 m3;
   732 |     |         assembly {
   733 |     |             m0 := mload(0x00)
   734 |     |             m1 := mload(0x20)
   735 |     |             m2 := mload(0x40)
   736 |     |             m3 := mload(0x60)
   737 |     |             // Selector of `log(address,bool,address)`.
   738 |     |             mstore(0x00, 0xf11699ed)
   739 |     |             mstore(0x20, p0)
   740 |     |             mstore(0x40, p1)
   741 |     |             mstore(0x60, p2)
   742 |     |         }
   743 |     |         _sendLogPayload(0x1c, 0x64);
   744 |     |         assembly {
   745 |     |             mstore(0x00, m0)
   746 |     |             mstore(0x20, m1)
   747 |     |             mstore(0x40, m2)
   748 |     |             mstore(0x60, m3)
   749 |     |         }
   750 |     |     }
   751 |     | 
   752 |     |     function log(address p0, bool p1, bool p2) internal pure {
   753 |     |         bytes32 m0;
   754 |     |         bytes32 m1;
   755 |     |         bytes32 m2;
   756 |     |         bytes32 m3;
   757 |     |         assembly {
   758 |     |             m0 := mload(0x00)
   759 |     |             m1 := mload(0x20)
   760 |     |             m2 := mload(0x40)
   761 |     |             m3 := mload(0x60)
   762 |     |             // Selector of `log(address,bool,bool)`.
   763 |     |             mstore(0x00, 0xeb830c92)
   764 |     |             mstore(0x20, p0)
   765 |     |             mstore(0x40, p1)
   766 |     |             mstore(0x60, p2)
   767 |     |         }
   768 |     |         _sendLogPayload(0x1c, 0x64);
   769 |     |         assembly {
   770 |     |             mstore(0x00, m0)
   771 |     |             mstore(0x20, m1)
   772 |     |             mstore(0x40, m2)
   773 |     |             mstore(0x60, m3)
   774 |     |         }
   775 |     |     }
   776 |     | 
   777 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
   778 |     |         bytes32 m0;
   779 |     |         bytes32 m1;
   780 |     |         bytes32 m2;
   781 |     |         bytes32 m3;
   782 |     |         assembly {
   783 |     |             m0 := mload(0x00)
   784 |     |             m1 := mload(0x20)
   785 |     |             m2 := mload(0x40)
   786 |     |             m3 := mload(0x60)
   787 |     |             // Selector of `log(address,bool,uint256)`.
   788 |     |             mstore(0x00, 0x9c4f99fb)
   789 |     |             mstore(0x20, p0)
   790 |     |             mstore(0x40, p1)
   791 |     |             mstore(0x60, p2)
   792 |     |         }
   793 |     |         _sendLogPayload(0x1c, 0x64);
   794 |     |         assembly {
   795 |     |             mstore(0x00, m0)
   796 |     |             mstore(0x20, m1)
   797 |     |             mstore(0x40, m2)
   798 |     |             mstore(0x60, m3)
   799 |     |         }
   800 |     |     }
   801 |     | 
   802 |     |     function log(address p0, bool p1, bytes32 p2) internal pure {
   803 |     |         bytes32 m0;
   804 |     |         bytes32 m1;
   805 |     |         bytes32 m2;
   806 |     |         bytes32 m3;
   807 |     |         bytes32 m4;
   808 |     |         bytes32 m5;
   809 |     |         assembly {
   810 |     |             function writeString(pos, w) {
   811 |     |                 let length := 0
   812 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   813 |     |                 mstore(pos, length)
   814 |     |                 let shift := sub(256, shl(3, length))
   815 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   816 |     |             }
   817 |     |             m0 := mload(0x00)
   818 |     |             m1 := mload(0x20)
   819 |     |             m2 := mload(0x40)
   820 |     |             m3 := mload(0x60)
   821 |     |             m4 := mload(0x80)
   822 |     |             m5 := mload(0xa0)
   823 |     |             // Selector of `log(address,bool,string)`.
   824 |     |             mstore(0x00, 0x212255cc)
   825 |     |             mstore(0x20, p0)
   826 |     |             mstore(0x40, p1)
   827 |     |             mstore(0x60, 0x60)
   828 |     |             writeString(0x80, p2)
   829 |     |         }
   830 |     |         _sendLogPayload(0x1c, 0xa4);
   831 |     |         assembly {
   832 |     |             mstore(0x00, m0)
   833 |     |             mstore(0x20, m1)
   834 |     |             mstore(0x40, m2)
   835 |     |             mstore(0x60, m3)
   836 |     |             mstore(0x80, m4)
   837 |     |             mstore(0xa0, m5)
   838 |     |         }
   839 |     |     }
   840 |     | 
   841 |     |     function log(address p0, uint256 p1, address p2) internal pure {
   842 |     |         bytes32 m0;
   843 |     |         bytes32 m1;
   844 |     |         bytes32 m2;
   845 |     |         bytes32 m3;
   846 |     |         assembly {
   847 |     |             m0 := mload(0x00)
   848 |     |             m1 := mload(0x20)
   849 |     |             m2 := mload(0x40)
   850 |     |             m3 := mload(0x60)
   851 |     |             // Selector of `log(address,uint256,address)`.
   852 |     |             mstore(0x00, 0x7bc0d848)
   853 |     |             mstore(0x20, p0)
   854 |     |             mstore(0x40, p1)
   855 |     |             mstore(0x60, p2)
   856 |     |         }
   857 |     |         _sendLogPayload(0x1c, 0x64);
   858 |     |         assembly {
   859 |     |             mstore(0x00, m0)
   860 |     |             mstore(0x20, m1)
   861 |     |             mstore(0x40, m2)
   862 |     |             mstore(0x60, m3)
   863 |     |         }
   864 |     |     }
   865 |     | 
   866 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
   867 |     |         bytes32 m0;
   868 |     |         bytes32 m1;
   869 |     |         bytes32 m2;
   870 |     |         bytes32 m3;
   871 |     |         assembly {
   872 |     |             m0 := mload(0x00)
   873 |     |             m1 := mload(0x20)
   874 |     |             m2 := mload(0x40)
   875 |     |             m3 := mload(0x60)
   876 |     |             // Selector of `log(address,uint256,bool)`.
   877 |     |             mstore(0x00, 0x678209a8)
   878 |     |             mstore(0x20, p0)
   879 |     |             mstore(0x40, p1)
   880 |     |             mstore(0x60, p2)
   881 |     |         }
   882 |     |         _sendLogPayload(0x1c, 0x64);
   883 |     |         assembly {
   884 |     |             mstore(0x00, m0)
   885 |     |             mstore(0x20, m1)
   886 |     |             mstore(0x40, m2)
   887 |     |             mstore(0x60, m3)
   888 |     |         }
   889 |     |     }
   890 |     | 
   891 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
   892 |     |         bytes32 m0;
   893 |     |         bytes32 m1;
   894 |     |         bytes32 m2;
   895 |     |         bytes32 m3;
   896 |     |         assembly {
   897 |     |             m0 := mload(0x00)
   898 |     |             m1 := mload(0x20)
   899 |     |             m2 := mload(0x40)
   900 |     |             m3 := mload(0x60)
   901 |     |             // Selector of `log(address,uint256,uint256)`.
   902 |     |             mstore(0x00, 0xb69bcaf6)
   903 |     |             mstore(0x20, p0)
   904 |     |             mstore(0x40, p1)
   905 |     |             mstore(0x60, p2)
   906 |     |         }
   907 |     |         _sendLogPayload(0x1c, 0x64);
   908 |     |         assembly {
   909 |     |             mstore(0x00, m0)
   910 |     |             mstore(0x20, m1)
   911 |     |             mstore(0x40, m2)
   912 |     |             mstore(0x60, m3)
   913 |     |         }
   914 |     |     }
   915 |     | 
   916 |     |     function log(address p0, uint256 p1, bytes32 p2) internal pure {
   917 |     |         bytes32 m0;
   918 |     |         bytes32 m1;
   919 |     |         bytes32 m2;
   920 |     |         bytes32 m3;
   921 |     |         bytes32 m4;
   922 |     |         bytes32 m5;
   923 |     |         assembly {
   924 |     |             function writeString(pos, w) {
   925 |     |                 let length := 0
   926 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   927 |     |                 mstore(pos, length)
   928 |     |                 let shift := sub(256, shl(3, length))
   929 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   930 |     |             }
   931 |     |             m0 := mload(0x00)
   932 |     |             m1 := mload(0x20)
   933 |     |             m2 := mload(0x40)
   934 |     |             m3 := mload(0x60)
   935 |     |             m4 := mload(0x80)
   936 |     |             m5 := mload(0xa0)
   937 |     |             // Selector of `log(address,uint256,string)`.
   938 |     |             mstore(0x00, 0xa1f2e8aa)
   939 |     |             mstore(0x20, p0)
   940 |     |             mstore(0x40, p1)
   941 |     |             mstore(0x60, 0x60)
   942 |     |             writeString(0x80, p2)
   943 |     |         }
   944 |     |         _sendLogPayload(0x1c, 0xa4);
   945 |     |         assembly {
   946 |     |             mstore(0x00, m0)
   947 |     |             mstore(0x20, m1)
   948 |     |             mstore(0x40, m2)
   949 |     |             mstore(0x60, m3)
   950 |     |             mstore(0x80, m4)
   951 |     |             mstore(0xa0, m5)
   952 |     |         }
   953 |     |     }
   954 |     | 
   955 |     |     function log(address p0, bytes32 p1, address p2) internal pure {
   956 |     |         bytes32 m0;
   957 |     |         bytes32 m1;
   958 |     |         bytes32 m2;
   959 |     |         bytes32 m3;
   960 |     |         bytes32 m4;
   961 |     |         bytes32 m5;
   962 |     |         assembly {
   963 |     |             function writeString(pos, w) {
   964 |     |                 let length := 0
   965 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   966 |     |                 mstore(pos, length)
   967 |     |                 let shift := sub(256, shl(3, length))
   968 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   969 |     |             }
   970 |     |             m0 := mload(0x00)
   971 |     |             m1 := mload(0x20)
   972 |     |             m2 := mload(0x40)
   973 |     |             m3 := mload(0x60)
   974 |     |             m4 := mload(0x80)
   975 |     |             m5 := mload(0xa0)
   976 |     |             // Selector of `log(address,string,address)`.
   977 |     |             mstore(0x00, 0xf08744e8)
   978 |     |             mstore(0x20, p0)
   979 |     |             mstore(0x40, 0x60)
   980 |     |             mstore(0x60, p2)
   981 |     |             writeString(0x80, p1)
   982 |     |         }
   983 |     |         _sendLogPayload(0x1c, 0xa4);
   984 |     |         assembly {
   985 |     |             mstore(0x00, m0)
   986 |     |             mstore(0x20, m1)
   987 |     |             mstore(0x40, m2)
   988 |     |             mstore(0x60, m3)
   989 |     |             mstore(0x80, m4)
   990 |     |             mstore(0xa0, m5)
   991 |     |         }
   992 |     |     }
   993 |     | 
   994 |     |     function log(address p0, bytes32 p1, bool p2) internal pure {
   995 |     |         bytes32 m0;
   996 |     |         bytes32 m1;
   997 |     |         bytes32 m2;
   998 |     |         bytes32 m3;
   999 |     |         bytes32 m4;
  1000 |     |         bytes32 m5;
  1001 |     |         assembly {
  1002 |     |             function writeString(pos, w) {
  1003 |     |                 let length := 0
  1004 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1005 |     |                 mstore(pos, length)
  1006 |     |                 let shift := sub(256, shl(3, length))
  1007 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1008 |     |             }
  1009 |     |             m0 := mload(0x00)
  1010 |     |             m1 := mload(0x20)
  1011 |     |             m2 := mload(0x40)
  1012 |     |             m3 := mload(0x60)
  1013 |     |             m4 := mload(0x80)
  1014 |     |             m5 := mload(0xa0)
  1015 |     |             // Selector of `log(address,string,bool)`.
  1016 |     |             mstore(0x00, 0xcf020fb1)
  1017 |     |             mstore(0x20, p0)
  1018 |     |             mstore(0x40, 0x60)
  1019 |     |             mstore(0x60, p2)
  1020 |     |             writeString(0x80, p1)
  1021 |     |         }
  1022 |     |         _sendLogPayload(0x1c, 0xa4);
  1023 |     |         assembly {
  1024 |     |             mstore(0x00, m0)
  1025 |     |             mstore(0x20, m1)
  1026 |     |             mstore(0x40, m2)
  1027 |     |             mstore(0x60, m3)
  1028 |     |             mstore(0x80, m4)
  1029 |     |             mstore(0xa0, m5)
  1030 |     |         }
  1031 |     |     }
  1032 |     | 
  1033 |     |     function log(address p0, bytes32 p1, uint256 p2) internal pure {
  1034 |     |         bytes32 m0;
  1035 |     |         bytes32 m1;
  1036 |     |         bytes32 m2;
  1037 |     |         bytes32 m3;
  1038 |     |         bytes32 m4;
  1039 |     |         bytes32 m5;
  1040 |     |         assembly {
  1041 |     |             function writeString(pos, w) {
  1042 |     |                 let length := 0
  1043 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1044 |     |                 mstore(pos, length)
  1045 |     |                 let shift := sub(256, shl(3, length))
  1046 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1047 |     |             }
  1048 |     |             m0 := mload(0x00)
  1049 |     |             m1 := mload(0x20)
  1050 |     |             m2 := mload(0x40)
  1051 |     |             m3 := mload(0x60)
  1052 |     |             m4 := mload(0x80)
  1053 |     |             m5 := mload(0xa0)
  1054 |     |             // Selector of `log(address,string,uint256)`.
  1055 |     |             mstore(0x00, 0x67dd6ff1)
  1056 |     |             mstore(0x20, p0)
  1057 |     |             mstore(0x40, 0x60)
  1058 |     |             mstore(0x60, p2)
  1059 |     |             writeString(0x80, p1)
  1060 |     |         }
  1061 |     |         _sendLogPayload(0x1c, 0xa4);
  1062 |     |         assembly {
  1063 |     |             mstore(0x00, m0)
  1064 |     |             mstore(0x20, m1)
  1065 |     |             mstore(0x40, m2)
  1066 |     |             mstore(0x60, m3)
  1067 |     |             mstore(0x80, m4)
  1068 |     |             mstore(0xa0, m5)
  1069 |     |         }
  1070 |     |     }
  1071 |     | 
  1072 |     |     function log(address p0, bytes32 p1, bytes32 p2) internal pure {
  1073 |     |         bytes32 m0;
  1074 |     |         bytes32 m1;
  1075 |     |         bytes32 m2;
  1076 |     |         bytes32 m3;
  1077 |     |         bytes32 m4;
  1078 |     |         bytes32 m5;
  1079 |     |         bytes32 m6;
  1080 |     |         bytes32 m7;
  1081 |     |         assembly {
  1082 |     |             function writeString(pos, w) {
  1083 |     |                 let length := 0
  1084 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1085 |     |                 mstore(pos, length)
  1086 |     |                 let shift := sub(256, shl(3, length))
  1087 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1088 |     |             }
  1089 |     |             m0 := mload(0x00)
  1090 |     |             m1 := mload(0x20)
  1091 |     |             m2 := mload(0x40)
  1092 |     |             m3 := mload(0x60)
  1093 |     |             m4 := mload(0x80)
  1094 |     |             m5 := mload(0xa0)
  1095 |     |             m6 := mload(0xc0)
  1096 |     |             m7 := mload(0xe0)
  1097 |     |             // Selector of `log(address,string,string)`.
  1098 |     |             mstore(0x00, 0xfb772265)
  1099 |     |             mstore(0x20, p0)
  1100 |     |             mstore(0x40, 0x60)
  1101 |     |             mstore(0x60, 0xa0)
  1102 |     |             writeString(0x80, p1)
  1103 |     |             writeString(0xc0, p2)
  1104 |     |         }
  1105 |     |         _sendLogPayload(0x1c, 0xe4);
  1106 |     |         assembly {
  1107 |     |             mstore(0x00, m0)
  1108 |     |             mstore(0x20, m1)
  1109 |     |             mstore(0x40, m2)
  1110 |     |             mstore(0x60, m3)
  1111 |     |             mstore(0x80, m4)
  1112 |     |             mstore(0xa0, m5)
  1113 |     |             mstore(0xc0, m6)
  1114 |     |             mstore(0xe0, m7)
  1115 |     |         }
  1116 |     |     }
  1117 |     | 
  1118 |     |     function log(bool p0, address p1, address p2) internal pure {
  1119 |     |         bytes32 m0;
  1120 |     |         bytes32 m1;
  1121 |     |         bytes32 m2;
  1122 |     |         bytes32 m3;
  1123 |     |         assembly {
  1124 |     |             m0 := mload(0x00)
  1125 |     |             m1 := mload(0x20)
  1126 |     |             m2 := mload(0x40)
  1127 |     |             m3 := mload(0x60)
  1128 |     |             // Selector of `log(bool,address,address)`.
  1129 |     |             mstore(0x00, 0xd2763667)
  1130 |     |             mstore(0x20, p0)
  1131 |     |             mstore(0x40, p1)
  1132 |     |             mstore(0x60, p2)
  1133 |     |         }
  1134 |     |         _sendLogPayload(0x1c, 0x64);
  1135 |     |         assembly {
  1136 |     |             mstore(0x00, m0)
  1137 |     |             mstore(0x20, m1)
  1138 |     |             mstore(0x40, m2)
  1139 |     |             mstore(0x60, m3)
  1140 |     |         }
  1141 |     |     }
  1142 |     | 
  1143 |     |     function log(bool p0, address p1, bool p2) internal pure {
  1144 |     |         bytes32 m0;
  1145 |     |         bytes32 m1;
  1146 |     |         bytes32 m2;
  1147 |     |         bytes32 m3;
  1148 |     |         assembly {
  1149 |     |             m0 := mload(0x00)
  1150 |     |             m1 := mload(0x20)
  1151 |     |             m2 := mload(0x40)
  1152 |     |             m3 := mload(0x60)
  1153 |     |             // Selector of `log(bool,address,bool)`.
  1154 |     |             mstore(0x00, 0x18c9c746)
  1155 |     |             mstore(0x20, p0)
  1156 |     |             mstore(0x40, p1)
  1157 |     |             mstore(0x60, p2)
  1158 |     |         }
  1159 |     |         _sendLogPayload(0x1c, 0x64);
  1160 |     |         assembly {
  1161 |     |             mstore(0x00, m0)
  1162 |     |             mstore(0x20, m1)
  1163 |     |             mstore(0x40, m2)
  1164 |     |             mstore(0x60, m3)
  1165 |     |         }
  1166 |     |     }
  1167 |     | 
  1168 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  1169 |     |         bytes32 m0;
  1170 |     |         bytes32 m1;
  1171 |     |         bytes32 m2;
  1172 |     |         bytes32 m3;
  1173 |     |         assembly {
  1174 |     |             m0 := mload(0x00)
  1175 |     |             m1 := mload(0x20)
  1176 |     |             m2 := mload(0x40)
  1177 |     |             m3 := mload(0x60)
  1178 |     |             // Selector of `log(bool,address,uint256)`.
  1179 |     |             mstore(0x00, 0x5f7b9afb)
  1180 |     |             mstore(0x20, p0)
  1181 |     |             mstore(0x40, p1)
  1182 |     |             mstore(0x60, p2)
  1183 |     |         }
  1184 |     |         _sendLogPayload(0x1c, 0x64);
  1185 |     |         assembly {
  1186 |     |             mstore(0x00, m0)
  1187 |     |             mstore(0x20, m1)
  1188 |     |             mstore(0x40, m2)
  1189 |     |             mstore(0x60, m3)
  1190 |     |         }
  1191 |     |     }
  1192 |     | 
  1193 |     |     function log(bool p0, address p1, bytes32 p2) internal pure {
  1194 |     |         bytes32 m0;
  1195 |     |         bytes32 m1;
  1196 |     |         bytes32 m2;
  1197 |     |         bytes32 m3;
  1198 |     |         bytes32 m4;
  1199 |     |         bytes32 m5;
  1200 |     |         assembly {
  1201 |     |             function writeString(pos, w) {
  1202 |     |                 let length := 0
  1203 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1204 |     |                 mstore(pos, length)
  1205 |     |                 let shift := sub(256, shl(3, length))
  1206 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1207 |     |             }
  1208 |     |             m0 := mload(0x00)
  1209 |     |             m1 := mload(0x20)
  1210 |     |             m2 := mload(0x40)
  1211 |     |             m3 := mload(0x60)
  1212 |     |             m4 := mload(0x80)
  1213 |     |             m5 := mload(0xa0)
  1214 |     |             // Selector of `log(bool,address,string)`.
  1215 |     |             mstore(0x00, 0xde9a9270)
  1216 |     |             mstore(0x20, p0)
  1217 |     |             mstore(0x40, p1)
  1218 |     |             mstore(0x60, 0x60)
  1219 |     |             writeString(0x80, p2)
  1220 |     |         }
  1221 |     |         _sendLogPayload(0x1c, 0xa4);
  1222 |     |         assembly {
  1223 |     |             mstore(0x00, m0)
  1224 |     |             mstore(0x20, m1)
  1225 |     |             mstore(0x40, m2)
  1226 |     |             mstore(0x60, m3)
  1227 |     |             mstore(0x80, m4)
  1228 |     |             mstore(0xa0, m5)
  1229 |     |         }
  1230 |     |     }
  1231 |     | 
  1232 |     |     function log(bool p0, bool p1, address p2) internal pure {
  1233 |     |         bytes32 m0;
  1234 |     |         bytes32 m1;
  1235 |     |         bytes32 m2;
  1236 |     |         bytes32 m3;
  1237 |     |         assembly {
  1238 |     |             m0 := mload(0x00)
  1239 |     |             m1 := mload(0x20)
  1240 |     |             m2 := mload(0x40)
  1241 |     |             m3 := mload(0x60)
  1242 |     |             // Selector of `log(bool,bool,address)`.
  1243 |     |             mstore(0x00, 0x1078f68d)
  1244 |     |             mstore(0x20, p0)
  1245 |     |             mstore(0x40, p1)
  1246 |     |             mstore(0x60, p2)
  1247 |     |         }
  1248 |     |         _sendLogPayload(0x1c, 0x64);
  1249 |     |         assembly {
  1250 |     |             mstore(0x00, m0)
  1251 |     |             mstore(0x20, m1)
  1252 |     |             mstore(0x40, m2)
  1253 |     |             mstore(0x60, m3)
  1254 |     |         }
  1255 |     |     }
  1256 |     | 
  1257 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  1258 |     |         bytes32 m0;
  1259 |     |         bytes32 m1;
  1260 |     |         bytes32 m2;
  1261 |     |         bytes32 m3;
  1262 |     |         assembly {
  1263 |     |             m0 := mload(0x00)
  1264 |     |             m1 := mload(0x20)
  1265 |     |             m2 := mload(0x40)
  1266 |     |             m3 := mload(0x60)
  1267 |     |             // Selector of `log(bool,bool,bool)`.
  1268 |     |             mstore(0x00, 0x50709698)
  1269 |     |             mstore(0x20, p0)
  1270 |     |             mstore(0x40, p1)
  1271 |     |             mstore(0x60, p2)
  1272 |     |         }
  1273 |     |         _sendLogPayload(0x1c, 0x64);
  1274 |     |         assembly {
  1275 |     |             mstore(0x00, m0)
  1276 |     |             mstore(0x20, m1)
  1277 |     |             mstore(0x40, m2)
  1278 |     |             mstore(0x60, m3)
  1279 |     |         }
  1280 |     |     }
  1281 |     | 
  1282 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  1283 |     |         bytes32 m0;
  1284 |     |         bytes32 m1;
  1285 |     |         bytes32 m2;
  1286 |     |         bytes32 m3;
  1287 |     |         assembly {
  1288 |     |             m0 := mload(0x00)
  1289 |     |             m1 := mload(0x20)
  1290 |     |             m2 := mload(0x40)
  1291 |     |             m3 := mload(0x60)
  1292 |     |             // Selector of `log(bool,bool,uint256)`.
  1293 |     |             mstore(0x00, 0x12f21602)
  1294 |     |             mstore(0x20, p0)
  1295 |     |             mstore(0x40, p1)
  1296 |     |             mstore(0x60, p2)
  1297 |     |         }
  1298 |     |         _sendLogPayload(0x1c, 0x64);
  1299 |     |         assembly {
  1300 |     |             mstore(0x00, m0)
  1301 |     |             mstore(0x20, m1)
  1302 |     |             mstore(0x40, m2)
  1303 |     |             mstore(0x60, m3)
  1304 |     |         }
  1305 |     |     }
  1306 |     | 
  1307 |     |     function log(bool p0, bool p1, bytes32 p2) internal pure {
  1308 |     |         bytes32 m0;
  1309 |     |         bytes32 m1;
  1310 |     |         bytes32 m2;
  1311 |     |         bytes32 m3;
  1312 |     |         bytes32 m4;
  1313 |     |         bytes32 m5;
  1314 |     |         assembly {
  1315 |     |             function writeString(pos, w) {
  1316 |     |                 let length := 0
  1317 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1318 |     |                 mstore(pos, length)
  1319 |     |                 let shift := sub(256, shl(3, length))
  1320 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1321 |     |             }
  1322 |     |             m0 := mload(0x00)
  1323 |     |             m1 := mload(0x20)
  1324 |     |             m2 := mload(0x40)
  1325 |     |             m3 := mload(0x60)
  1326 |     |             m4 := mload(0x80)
  1327 |     |             m5 := mload(0xa0)
  1328 |     |             // Selector of `log(bool,bool,string)`.
  1329 |     |             mstore(0x00, 0x2555fa46)
  1330 |     |             mstore(0x20, p0)
  1331 |     |             mstore(0x40, p1)
  1332 |     |             mstore(0x60, 0x60)
  1333 |     |             writeString(0x80, p2)
  1334 |     |         }
  1335 |     |         _sendLogPayload(0x1c, 0xa4);
  1336 |     |         assembly {
  1337 |     |             mstore(0x00, m0)
  1338 |     |             mstore(0x20, m1)
  1339 |     |             mstore(0x40, m2)
  1340 |     |             mstore(0x60, m3)
  1341 |     |             mstore(0x80, m4)
  1342 |     |             mstore(0xa0, m5)
  1343 |     |         }
  1344 |     |     }
  1345 |     | 
  1346 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  1347 |     |         bytes32 m0;
  1348 |     |         bytes32 m1;
  1349 |     |         bytes32 m2;
  1350 |     |         bytes32 m3;
  1351 |     |         assembly {
  1352 |     |             m0 := mload(0x00)
  1353 |     |             m1 := mload(0x20)
  1354 |     |             m2 := mload(0x40)
  1355 |     |             m3 := mload(0x60)
  1356 |     |             // Selector of `log(bool,uint256,address)`.
  1357 |     |             mstore(0x00, 0x088ef9d2)
  1358 |     |             mstore(0x20, p0)
  1359 |     |             mstore(0x40, p1)
  1360 |     |             mstore(0x60, p2)
  1361 |     |         }
  1362 |     |         _sendLogPayload(0x1c, 0x64);
  1363 |     |         assembly {
  1364 |     |             mstore(0x00, m0)
  1365 |     |             mstore(0x20, m1)
  1366 |     |             mstore(0x40, m2)
  1367 |     |             mstore(0x60, m3)
  1368 |     |         }
  1369 |     |     }
  1370 |     | 
  1371 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  1372 |     |         bytes32 m0;
  1373 |     |         bytes32 m1;
  1374 |     |         bytes32 m2;
  1375 |     |         bytes32 m3;
  1376 |     |         assembly {
  1377 |     |             m0 := mload(0x00)
  1378 |     |             m1 := mload(0x20)
  1379 |     |             m2 := mload(0x40)
  1380 |     |             m3 := mload(0x60)
  1381 |     |             // Selector of `log(bool,uint256,bool)`.
  1382 |     |             mstore(0x00, 0xe8defba9)
  1383 |     |             mstore(0x20, p0)
  1384 |     |             mstore(0x40, p1)
  1385 |     |             mstore(0x60, p2)
  1386 |     |         }
  1387 |     |         _sendLogPayload(0x1c, 0x64);
  1388 |     |         assembly {
  1389 |     |             mstore(0x00, m0)
  1390 |     |             mstore(0x20, m1)
  1391 |     |             mstore(0x40, m2)
  1392 |     |             mstore(0x60, m3)
  1393 |     |         }
  1394 |     |     }
  1395 |     | 
  1396 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  1397 |     |         bytes32 m0;
  1398 |     |         bytes32 m1;
  1399 |     |         bytes32 m2;
  1400 |     |         bytes32 m3;
  1401 |     |         assembly {
  1402 |     |             m0 := mload(0x00)
  1403 |     |             m1 := mload(0x20)
  1404 |     |             m2 := mload(0x40)
  1405 |     |             m3 := mload(0x60)
  1406 |     |             // Selector of `log(bool,uint256,uint256)`.
  1407 |     |             mstore(0x00, 0x37103367)
  1408 |     |             mstore(0x20, p0)
  1409 |     |             mstore(0x40, p1)
  1410 |     |             mstore(0x60, p2)
  1411 |     |         }
  1412 |     |         _sendLogPayload(0x1c, 0x64);
  1413 |     |         assembly {
  1414 |     |             mstore(0x00, m0)
  1415 |     |             mstore(0x20, m1)
  1416 |     |             mstore(0x40, m2)
  1417 |     |             mstore(0x60, m3)
  1418 |     |         }
  1419 |     |     }
  1420 |     | 
  1421 |     |     function log(bool p0, uint256 p1, bytes32 p2) internal pure {
  1422 |     |         bytes32 m0;
  1423 |     |         bytes32 m1;
  1424 |     |         bytes32 m2;
  1425 |     |         bytes32 m3;
  1426 |     |         bytes32 m4;
  1427 |     |         bytes32 m5;
  1428 |     |         assembly {
  1429 |     |             function writeString(pos, w) {
  1430 |     |                 let length := 0
  1431 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1432 |     |                 mstore(pos, length)
  1433 |     |                 let shift := sub(256, shl(3, length))
  1434 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1435 |     |             }
  1436 |     |             m0 := mload(0x00)
  1437 |     |             m1 := mload(0x20)
  1438 |     |             m2 := mload(0x40)
  1439 |     |             m3 := mload(0x60)
  1440 |     |             m4 := mload(0x80)
  1441 |     |             m5 := mload(0xa0)
  1442 |     |             // Selector of `log(bool,uint256,string)`.
  1443 |     |             mstore(0x00, 0xc3fc3970)
  1444 |     |             mstore(0x20, p0)
  1445 |     |             mstore(0x40, p1)
  1446 |     |             mstore(0x60, 0x60)
  1447 |     |             writeString(0x80, p2)
  1448 |     |         }
  1449 |     |         _sendLogPayload(0x1c, 0xa4);
  1450 |     |         assembly {
  1451 |     |             mstore(0x00, m0)
  1452 |     |             mstore(0x20, m1)
  1453 |     |             mstore(0x40, m2)
  1454 |     |             mstore(0x60, m3)
  1455 |     |             mstore(0x80, m4)
  1456 |     |             mstore(0xa0, m5)
  1457 |     |         }
  1458 |     |     }
  1459 |     | 
  1460 |     |     function log(bool p0, bytes32 p1, address p2) internal pure {
  1461 |     |         bytes32 m0;
  1462 |     |         bytes32 m1;
  1463 |     |         bytes32 m2;
  1464 |     |         bytes32 m3;
  1465 |     |         bytes32 m4;
  1466 |     |         bytes32 m5;
  1467 |     |         assembly {
  1468 |     |             function writeString(pos, w) {
  1469 |     |                 let length := 0
  1470 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1471 |     |                 mstore(pos, length)
  1472 |     |                 let shift := sub(256, shl(3, length))
  1473 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1474 |     |             }
  1475 |     |             m0 := mload(0x00)
  1476 |     |             m1 := mload(0x20)
  1477 |     |             m2 := mload(0x40)
  1478 |     |             m3 := mload(0x60)
  1479 |     |             m4 := mload(0x80)
  1480 |     |             m5 := mload(0xa0)
  1481 |     |             // Selector of `log(bool,string,address)`.
  1482 |     |             mstore(0x00, 0x9591b953)
  1483 |     |             mstore(0x20, p0)
  1484 |     |             mstore(0x40, 0x60)
  1485 |     |             mstore(0x60, p2)
  1486 |     |             writeString(0x80, p1)
  1487 |     |         }
  1488 |     |         _sendLogPayload(0x1c, 0xa4);
  1489 |     |         assembly {
  1490 |     |             mstore(0x00, m0)
  1491 |     |             mstore(0x20, m1)
  1492 |     |             mstore(0x40, m2)
  1493 |     |             mstore(0x60, m3)
  1494 |     |             mstore(0x80, m4)
  1495 |     |             mstore(0xa0, m5)
  1496 |     |         }
  1497 |     |     }
  1498 |     | 
  1499 |     |     function log(bool p0, bytes32 p1, bool p2) internal pure {
  1500 |     |         bytes32 m0;
  1501 |     |         bytes32 m1;
  1502 |     |         bytes32 m2;
  1503 |     |         bytes32 m3;
  1504 |     |         bytes32 m4;
  1505 |     |         bytes32 m5;
  1506 |     |         assembly {
  1507 |     |             function writeString(pos, w) {
  1508 |     |                 let length := 0
  1509 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1510 |     |                 mstore(pos, length)
  1511 |     |                 let shift := sub(256, shl(3, length))
  1512 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1513 |     |             }
  1514 |     |             m0 := mload(0x00)
  1515 |     |             m1 := mload(0x20)
  1516 |     |             m2 := mload(0x40)
  1517 |     |             m3 := mload(0x60)
  1518 |     |             m4 := mload(0x80)
  1519 |     |             m5 := mload(0xa0)
  1520 |     |             // Selector of `log(bool,string,bool)`.
  1521 |     |             mstore(0x00, 0xdbb4c247)
  1522 |     |             mstore(0x20, p0)
  1523 |     |             mstore(0x40, 0x60)
  1524 |     |             mstore(0x60, p2)
  1525 |     |             writeString(0x80, p1)
  1526 |     |         }
  1527 |     |         _sendLogPayload(0x1c, 0xa4);
  1528 |     |         assembly {
  1529 |     |             mstore(0x00, m0)
  1530 |     |             mstore(0x20, m1)
  1531 |     |             mstore(0x40, m2)
  1532 |     |             mstore(0x60, m3)
  1533 |     |             mstore(0x80, m4)
  1534 |     |             mstore(0xa0, m5)
  1535 |     |         }
  1536 |     |     }
  1537 |     | 
  1538 |     |     function log(bool p0, bytes32 p1, uint256 p2) internal pure {
  1539 |     |         bytes32 m0;
  1540 |     |         bytes32 m1;
  1541 |     |         bytes32 m2;
  1542 |     |         bytes32 m3;
  1543 |     |         bytes32 m4;
  1544 |     |         bytes32 m5;
  1545 |     |         assembly {
  1546 |     |             function writeString(pos, w) {
  1547 |     |                 let length := 0
  1548 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1549 |     |                 mstore(pos, length)
  1550 |     |                 let shift := sub(256, shl(3, length))
  1551 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1552 |     |             }
  1553 |     |             m0 := mload(0x00)
  1554 |     |             m1 := mload(0x20)
  1555 |     |             m2 := mload(0x40)
  1556 |     |             m3 := mload(0x60)
  1557 |     |             m4 := mload(0x80)
  1558 |     |             m5 := mload(0xa0)
  1559 |     |             // Selector of `log(bool,string,uint256)`.
  1560 |     |             mstore(0x00, 0x1093ee11)
  1561 |     |             mstore(0x20, p0)
  1562 |     |             mstore(0x40, 0x60)
  1563 |     |             mstore(0x60, p2)
  1564 |     |             writeString(0x80, p1)
  1565 |     |         }
  1566 |     |         _sendLogPayload(0x1c, 0xa4);
  1567 |     |         assembly {
  1568 |     |             mstore(0x00, m0)
  1569 |     |             mstore(0x20, m1)
  1570 |     |             mstore(0x40, m2)
  1571 |     |             mstore(0x60, m3)
  1572 |     |             mstore(0x80, m4)
  1573 |     |             mstore(0xa0, m5)
  1574 |     |         }
  1575 |     |     }
  1576 |     | 
  1577 |     |     function log(bool p0, bytes32 p1, bytes32 p2) internal pure {
  1578 |     |         bytes32 m0;
  1579 |     |         bytes32 m1;
  1580 |     |         bytes32 m2;
  1581 |     |         bytes32 m3;
  1582 |     |         bytes32 m4;
  1583 |     |         bytes32 m5;
  1584 |     |         bytes32 m6;
  1585 |     |         bytes32 m7;
  1586 |     |         assembly {
  1587 |     |             function writeString(pos, w) {
  1588 |     |                 let length := 0
  1589 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1590 |     |                 mstore(pos, length)
  1591 |     |                 let shift := sub(256, shl(3, length))
  1592 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1593 |     |             }
  1594 |     |             m0 := mload(0x00)
  1595 |     |             m1 := mload(0x20)
  1596 |     |             m2 := mload(0x40)
  1597 |     |             m3 := mload(0x60)
  1598 |     |             m4 := mload(0x80)
  1599 |     |             m5 := mload(0xa0)
  1600 |     |             m6 := mload(0xc0)
  1601 |     |             m7 := mload(0xe0)
  1602 |     |             // Selector of `log(bool,string,string)`.
  1603 |     |             mstore(0x00, 0xb076847f)
  1604 |     |             mstore(0x20, p0)
  1605 |     |             mstore(0x40, 0x60)
  1606 |     |             mstore(0x60, 0xa0)
  1607 |     |             writeString(0x80, p1)
  1608 |     |             writeString(0xc0, p2)
  1609 |     |         }
  1610 |     |         _sendLogPayload(0x1c, 0xe4);
  1611 |     |         assembly {
  1612 |     |             mstore(0x00, m0)
  1613 |     |             mstore(0x20, m1)
  1614 |     |             mstore(0x40, m2)
  1615 |     |             mstore(0x60, m3)
  1616 |     |             mstore(0x80, m4)
  1617 |     |             mstore(0xa0, m5)
  1618 |     |             mstore(0xc0, m6)
  1619 |     |             mstore(0xe0, m7)
  1620 |     |         }
  1621 |     |     }
  1622 |     | 
  1623 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  1624 |     |         bytes32 m0;
  1625 |     |         bytes32 m1;
  1626 |     |         bytes32 m2;
  1627 |     |         bytes32 m3;
  1628 |     |         assembly {
  1629 |     |             m0 := mload(0x00)
  1630 |     |             m1 := mload(0x20)
  1631 |     |             m2 := mload(0x40)
  1632 |     |             m3 := mload(0x60)
  1633 |     |             // Selector of `log(uint256,address,address)`.
  1634 |     |             mstore(0x00, 0xbcfd9be0)
  1635 |     |             mstore(0x20, p0)
  1636 |     |             mstore(0x40, p1)
  1637 |     |             mstore(0x60, p2)
  1638 |     |         }
  1639 |     |         _sendLogPayload(0x1c, 0x64);
  1640 |     |         assembly {
  1641 |     |             mstore(0x00, m0)
  1642 |     |             mstore(0x20, m1)
  1643 |     |             mstore(0x40, m2)
  1644 |     |             mstore(0x60, m3)
  1645 |     |         }
  1646 |     |     }
  1647 |     | 
  1648 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  1649 |     |         bytes32 m0;
  1650 |     |         bytes32 m1;
  1651 |     |         bytes32 m2;
  1652 |     |         bytes32 m3;
  1653 |     |         assembly {
  1654 |     |             m0 := mload(0x00)
  1655 |     |             m1 := mload(0x20)
  1656 |     |             m2 := mload(0x40)
  1657 |     |             m3 := mload(0x60)
  1658 |     |             // Selector of `log(uint256,address,bool)`.
  1659 |     |             mstore(0x00, 0x9b6ec042)
  1660 |     |             mstore(0x20, p0)
  1661 |     |             mstore(0x40, p1)
  1662 |     |             mstore(0x60, p2)
  1663 |     |         }
  1664 |     |         _sendLogPayload(0x1c, 0x64);
  1665 |     |         assembly {
  1666 |     |             mstore(0x00, m0)
  1667 |     |             mstore(0x20, m1)
  1668 |     |             mstore(0x40, m2)
  1669 |     |             mstore(0x60, m3)
  1670 |     |         }
  1671 |     |     }
  1672 |     | 
  1673 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  1674 |     |         bytes32 m0;
  1675 |     |         bytes32 m1;
  1676 |     |         bytes32 m2;
  1677 |     |         bytes32 m3;
  1678 |     |         assembly {
  1679 |     |             m0 := mload(0x00)
  1680 |     |             m1 := mload(0x20)
  1681 |     |             m2 := mload(0x40)
  1682 |     |             m3 := mload(0x60)
  1683 |     |             // Selector of `log(uint256,address,uint256)`.
  1684 |     |             mstore(0x00, 0x5a9b5ed5)
  1685 |     |             mstore(0x20, p0)
  1686 |     |             mstore(0x40, p1)
  1687 |     |             mstore(0x60, p2)
  1688 |     |         }
  1689 |     |         _sendLogPayload(0x1c, 0x64);
  1690 |     |         assembly {
  1691 |     |             mstore(0x00, m0)
  1692 |     |             mstore(0x20, m1)
  1693 |     |             mstore(0x40, m2)
  1694 |     |             mstore(0x60, m3)
  1695 |     |         }
  1696 |     |     }
  1697 |     | 
  1698 |     |     function log(uint256 p0, address p1, bytes32 p2) internal pure {
  1699 |     |         bytes32 m0;
  1700 |     |         bytes32 m1;
  1701 |     |         bytes32 m2;
  1702 |     |         bytes32 m3;
  1703 |     |         bytes32 m4;
  1704 |     |         bytes32 m5;
  1705 |     |         assembly {
  1706 |     |             function writeString(pos, w) {
  1707 |     |                 let length := 0
  1708 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1709 |     |                 mstore(pos, length)
  1710 |     |                 let shift := sub(256, shl(3, length))
  1711 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1712 |     |             }
  1713 |     |             m0 := mload(0x00)
  1714 |     |             m1 := mload(0x20)
  1715 |     |             m2 := mload(0x40)
  1716 |     |             m3 := mload(0x60)
  1717 |     |             m4 := mload(0x80)
  1718 |     |             m5 := mload(0xa0)
  1719 |     |             // Selector of `log(uint256,address,string)`.
  1720 |     |             mstore(0x00, 0x63cb41f9)
  1721 |     |             mstore(0x20, p0)
  1722 |     |             mstore(0x40, p1)
  1723 |     |             mstore(0x60, 0x60)
  1724 |     |             writeString(0x80, p2)
  1725 |     |         }
  1726 |     |         _sendLogPayload(0x1c, 0xa4);
  1727 |     |         assembly {
  1728 |     |             mstore(0x00, m0)
  1729 |     |             mstore(0x20, m1)
  1730 |     |             mstore(0x40, m2)
  1731 |     |             mstore(0x60, m3)
  1732 |     |             mstore(0x80, m4)
  1733 |     |             mstore(0xa0, m5)
  1734 |     |         }
  1735 |     |     }
  1736 |     | 
  1737 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  1738 |     |         bytes32 m0;
  1739 |     |         bytes32 m1;
  1740 |     |         bytes32 m2;
  1741 |     |         bytes32 m3;
  1742 |     |         assembly {
  1743 |     |             m0 := mload(0x00)
  1744 |     |             m1 := mload(0x20)
  1745 |     |             m2 := mload(0x40)
  1746 |     |             m3 := mload(0x60)
  1747 |     |             // Selector of `log(uint256,bool,address)`.
  1748 |     |             mstore(0x00, 0x35085f7b)
  1749 |     |             mstore(0x20, p0)
  1750 |     |             mstore(0x40, p1)
  1751 |     |             mstore(0x60, p2)
  1752 |     |         }
  1753 |     |         _sendLogPayload(0x1c, 0x64);
  1754 |     |         assembly {
  1755 |     |             mstore(0x00, m0)
  1756 |     |             mstore(0x20, m1)
  1757 |     |             mstore(0x40, m2)
  1758 |     |             mstore(0x60, m3)
  1759 |     |         }
  1760 |     |     }
  1761 |     | 
  1762 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  1763 |     |         bytes32 m0;
  1764 |     |         bytes32 m1;
  1765 |     |         bytes32 m2;
  1766 |     |         bytes32 m3;
  1767 |     |         assembly {
  1768 |     |             m0 := mload(0x00)
  1769 |     |             m1 := mload(0x20)
  1770 |     |             m2 := mload(0x40)
  1771 |     |             m3 := mload(0x60)
  1772 |     |             // Selector of `log(uint256,bool,bool)`.
  1773 |     |             mstore(0x00, 0x20718650)
  1774 |     |             mstore(0x20, p0)
  1775 |     |             mstore(0x40, p1)
  1776 |     |             mstore(0x60, p2)
  1777 |     |         }
  1778 |     |         _sendLogPayload(0x1c, 0x64);
  1779 |     |         assembly {
  1780 |     |             mstore(0x00, m0)
  1781 |     |             mstore(0x20, m1)
  1782 |     |             mstore(0x40, m2)
  1783 |     |             mstore(0x60, m3)
  1784 |     |         }
  1785 |     |     }
  1786 |     | 
  1787 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  1788 |     |         bytes32 m0;
  1789 |     |         bytes32 m1;
  1790 |     |         bytes32 m2;
  1791 |     |         bytes32 m3;
  1792 |     |         assembly {
  1793 |     |             m0 := mload(0x00)
  1794 |     |             m1 := mload(0x20)
  1795 |     |             m2 := mload(0x40)
  1796 |     |             m3 := mload(0x60)
  1797 |     |             // Selector of `log(uint256,bool,uint256)`.
  1798 |     |             mstore(0x00, 0x20098014)
  1799 |     |             mstore(0x20, p0)
  1800 |     |             mstore(0x40, p1)
  1801 |     |             mstore(0x60, p2)
  1802 |     |         }
  1803 |     |         _sendLogPayload(0x1c, 0x64);
  1804 |     |         assembly {
  1805 |     |             mstore(0x00, m0)
  1806 |     |             mstore(0x20, m1)
  1807 |     |             mstore(0x40, m2)
  1808 |     |             mstore(0x60, m3)
  1809 |     |         }
  1810 |     |     }
  1811 |     | 
  1812 |     |     function log(uint256 p0, bool p1, bytes32 p2) internal pure {
  1813 |     |         bytes32 m0;
  1814 |     |         bytes32 m1;
  1815 |     |         bytes32 m2;
  1816 |     |         bytes32 m3;
  1817 |     |         bytes32 m4;
  1818 |     |         bytes32 m5;
  1819 |     |         assembly {
  1820 |     |             function writeString(pos, w) {
  1821 |     |                 let length := 0
  1822 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1823 |     |                 mstore(pos, length)
  1824 |     |                 let shift := sub(256, shl(3, length))
  1825 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1826 |     |             }
  1827 |     |             m0 := mload(0x00)
  1828 |     |             m1 := mload(0x20)
  1829 |     |             m2 := mload(0x40)
  1830 |     |             m3 := mload(0x60)
  1831 |     |             m4 := mload(0x80)
  1832 |     |             m5 := mload(0xa0)
  1833 |     |             // Selector of `log(uint256,bool,string)`.
  1834 |     |             mstore(0x00, 0x85775021)
  1835 |     |             mstore(0x20, p0)
  1836 |     |             mstore(0x40, p1)
  1837 |     |             mstore(0x60, 0x60)
  1838 |     |             writeString(0x80, p2)
  1839 |     |         }
  1840 |     |         _sendLogPayload(0x1c, 0xa4);
  1841 |     |         assembly {
  1842 |     |             mstore(0x00, m0)
  1843 |     |             mstore(0x20, m1)
  1844 |     |             mstore(0x40, m2)
  1845 |     |             mstore(0x60, m3)
  1846 |     |             mstore(0x80, m4)
  1847 |     |             mstore(0xa0, m5)
  1848 |     |         }
  1849 |     |     }
  1850 |     | 
  1851 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  1852 |     |         bytes32 m0;
  1853 |     |         bytes32 m1;
  1854 |     |         bytes32 m2;
  1855 |     |         bytes32 m3;
  1856 |     |         assembly {
  1857 |     |             m0 := mload(0x00)
  1858 |     |             m1 := mload(0x20)
  1859 |     |             m2 := mload(0x40)
  1860 |     |             m3 := mload(0x60)
  1861 |     |             // Selector of `log(uint256,uint256,address)`.
  1862 |     |             mstore(0x00, 0x5c96b331)
  1863 |     |             mstore(0x20, p0)
  1864 |     |             mstore(0x40, p1)
  1865 |     |             mstore(0x60, p2)
  1866 |     |         }
  1867 |     |         _sendLogPayload(0x1c, 0x64);
  1868 |     |         assembly {
  1869 |     |             mstore(0x00, m0)
  1870 |     |             mstore(0x20, m1)
  1871 |     |             mstore(0x40, m2)
  1872 |     |             mstore(0x60, m3)
  1873 |     |         }
  1874 |     |     }
  1875 |     | 
  1876 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  1877 |     |         bytes32 m0;
  1878 |     |         bytes32 m1;
  1879 |     |         bytes32 m2;
  1880 |     |         bytes32 m3;
  1881 |     |         assembly {
  1882 |     |             m0 := mload(0x00)
  1883 |     |             m1 := mload(0x20)
  1884 |     |             m2 := mload(0x40)
  1885 |     |             m3 := mload(0x60)
  1886 |     |             // Selector of `log(uint256,uint256,bool)`.
  1887 |     |             mstore(0x00, 0x4766da72)
  1888 |     |             mstore(0x20, p0)
  1889 |     |             mstore(0x40, p1)
  1890 |     |             mstore(0x60, p2)
  1891 |     |         }
  1892 |     |         _sendLogPayload(0x1c, 0x64);
  1893 |     |         assembly {
  1894 |     |             mstore(0x00, m0)
  1895 |     |             mstore(0x20, m1)
  1896 |     |             mstore(0x40, m2)
  1897 |     |             mstore(0x60, m3)
  1898 |     |         }
  1899 |     |     }
  1900 |     | 
  1901 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  1902 |     |         bytes32 m0;
  1903 |     |         bytes32 m1;
  1904 |     |         bytes32 m2;
  1905 |     |         bytes32 m3;
  1906 |     |         assembly {
  1907 |     |             m0 := mload(0x00)
  1908 |     |             m1 := mload(0x20)
  1909 |     |             m2 := mload(0x40)
  1910 |     |             m3 := mload(0x60)
  1911 |     |             // Selector of `log(uint256,uint256,uint256)`.
  1912 |     |             mstore(0x00, 0xd1ed7a3c)
  1913 |     |             mstore(0x20, p0)
  1914 |     |             mstore(0x40, p1)
  1915 |     |             mstore(0x60, p2)
  1916 |     |         }
  1917 |     |         _sendLogPayload(0x1c, 0x64);
  1918 |     |         assembly {
  1919 |     |             mstore(0x00, m0)
  1920 |     |             mstore(0x20, m1)
  1921 |     |             mstore(0x40, m2)
  1922 |     |             mstore(0x60, m3)
  1923 |     |         }
  1924 |     |     }
  1925 |     | 
  1926 |     |     function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {
  1927 |     |         bytes32 m0;
  1928 |     |         bytes32 m1;
  1929 |     |         bytes32 m2;
  1930 |     |         bytes32 m3;
  1931 |     |         bytes32 m4;
  1932 |     |         bytes32 m5;
  1933 |     |         assembly {
  1934 |     |             function writeString(pos, w) {
  1935 |     |                 let length := 0
  1936 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1937 |     |                 mstore(pos, length)
  1938 |     |                 let shift := sub(256, shl(3, length))
  1939 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1940 |     |             }
  1941 |     |             m0 := mload(0x00)
  1942 |     |             m1 := mload(0x20)
  1943 |     |             m2 := mload(0x40)
  1944 |     |             m3 := mload(0x60)
  1945 |     |             m4 := mload(0x80)
  1946 |     |             m5 := mload(0xa0)
  1947 |     |             // Selector of `log(uint256,uint256,string)`.
  1948 |     |             mstore(0x00, 0x71d04af2)
  1949 |     |             mstore(0x20, p0)
  1950 |     |             mstore(0x40, p1)
  1951 |     |             mstore(0x60, 0x60)
  1952 |     |             writeString(0x80, p2)
  1953 |     |         }
  1954 |     |         _sendLogPayload(0x1c, 0xa4);
  1955 |     |         assembly {
  1956 |     |             mstore(0x00, m0)
  1957 |     |             mstore(0x20, m1)
  1958 |     |             mstore(0x40, m2)
  1959 |     |             mstore(0x60, m3)
  1960 |     |             mstore(0x80, m4)
  1961 |     |             mstore(0xa0, m5)
  1962 |     |         }
  1963 |     |     }
  1964 |     | 
  1965 |     |     function log(uint256 p0, bytes32 p1, address p2) internal pure {
  1966 |     |         bytes32 m0;
  1967 |     |         bytes32 m1;
  1968 |     |         bytes32 m2;
  1969 |     |         bytes32 m3;
  1970 |     |         bytes32 m4;
  1971 |     |         bytes32 m5;
  1972 |     |         assembly {
  1973 |     |             function writeString(pos, w) {
  1974 |     |                 let length := 0
  1975 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1976 |     |                 mstore(pos, length)
  1977 |     |                 let shift := sub(256, shl(3, length))
  1978 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1979 |     |             }
  1980 |     |             m0 := mload(0x00)
  1981 |     |             m1 := mload(0x20)
  1982 |     |             m2 := mload(0x40)
  1983 |     |             m3 := mload(0x60)
  1984 |     |             m4 := mload(0x80)
  1985 |     |             m5 := mload(0xa0)
  1986 |     |             // Selector of `log(uint256,string,address)`.
  1987 |     |             mstore(0x00, 0x7afac959)
  1988 |     |             mstore(0x20, p0)
  1989 |     |             mstore(0x40, 0x60)
  1990 |     |             mstore(0x60, p2)
  1991 |     |             writeString(0x80, p1)
  1992 |     |         }
  1993 |     |         _sendLogPayload(0x1c, 0xa4);
  1994 |     |         assembly {
  1995 |     |             mstore(0x00, m0)
  1996 |     |             mstore(0x20, m1)
  1997 |     |             mstore(0x40, m2)
  1998 |     |             mstore(0x60, m3)
  1999 |     |             mstore(0x80, m4)
  2000 |     |             mstore(0xa0, m5)
  2001 |     |         }
  2002 |     |     }
  2003 |     | 
  2004 |     |     function log(uint256 p0, bytes32 p1, bool p2) internal pure {
  2005 |     |         bytes32 m0;
  2006 |     |         bytes32 m1;
  2007 |     |         bytes32 m2;
  2008 |     |         bytes32 m3;
  2009 |     |         bytes32 m4;
  2010 |     |         bytes32 m5;
  2011 |     |         assembly {
  2012 |     |             function writeString(pos, w) {
  2013 |     |                 let length := 0
  2014 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2015 |     |                 mstore(pos, length)
  2016 |     |                 let shift := sub(256, shl(3, length))
  2017 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2018 |     |             }
  2019 |     |             m0 := mload(0x00)
  2020 |     |             m1 := mload(0x20)
  2021 |     |             m2 := mload(0x40)
  2022 |     |             m3 := mload(0x60)
  2023 |     |             m4 := mload(0x80)
  2024 |     |             m5 := mload(0xa0)
  2025 |     |             // Selector of `log(uint256,string,bool)`.
  2026 |     |             mstore(0x00, 0x4ceda75a)
  2027 |     |             mstore(0x20, p0)
  2028 |     |             mstore(0x40, 0x60)
  2029 |     |             mstore(0x60, p2)
  2030 |     |             writeString(0x80, p1)
  2031 |     |         }
  2032 |     |         _sendLogPayload(0x1c, 0xa4);
  2033 |     |         assembly {
  2034 |     |             mstore(0x00, m0)
  2035 |     |             mstore(0x20, m1)
  2036 |     |             mstore(0x40, m2)
  2037 |     |             mstore(0x60, m3)
  2038 |     |             mstore(0x80, m4)
  2039 |     |             mstore(0xa0, m5)
  2040 |     |         }
  2041 |     |     }
  2042 |     | 
  2043 |     |     function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {
  2044 |     |         bytes32 m0;
  2045 |     |         bytes32 m1;
  2046 |     |         bytes32 m2;
  2047 |     |         bytes32 m3;
  2048 |     |         bytes32 m4;
  2049 |     |         bytes32 m5;
  2050 |     |         assembly {
  2051 |     |             function writeString(pos, w) {
  2052 |     |                 let length := 0
  2053 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2054 |     |                 mstore(pos, length)
  2055 |     |                 let shift := sub(256, shl(3, length))
  2056 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2057 |     |             }
  2058 |     |             m0 := mload(0x00)
  2059 |     |             m1 := mload(0x20)
  2060 |     |             m2 := mload(0x40)
  2061 |     |             m3 := mload(0x60)
  2062 |     |             m4 := mload(0x80)
  2063 |     |             m5 := mload(0xa0)
  2064 |     |             // Selector of `log(uint256,string,uint256)`.
  2065 |     |             mstore(0x00, 0x37aa7d4c)
  2066 |     |             mstore(0x20, p0)
  2067 |     |             mstore(0x40, 0x60)
  2068 |     |             mstore(0x60, p2)
  2069 |     |             writeString(0x80, p1)
  2070 |     |         }
  2071 |     |         _sendLogPayload(0x1c, 0xa4);
  2072 |     |         assembly {
  2073 |     |             mstore(0x00, m0)
  2074 |     |             mstore(0x20, m1)
  2075 |     |             mstore(0x40, m2)
  2076 |     |             mstore(0x60, m3)
  2077 |     |             mstore(0x80, m4)
  2078 |     |             mstore(0xa0, m5)
  2079 |     |         }
  2080 |     |     }
  2081 |     | 
  2082 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {
  2083 |     |         bytes32 m0;
  2084 |     |         bytes32 m1;
  2085 |     |         bytes32 m2;
  2086 |     |         bytes32 m3;
  2087 |     |         bytes32 m4;
  2088 |     |         bytes32 m5;
  2089 |     |         bytes32 m6;
  2090 |     |         bytes32 m7;
  2091 |     |         assembly {
  2092 |     |             function writeString(pos, w) {
  2093 |     |                 let length := 0
  2094 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2095 |     |                 mstore(pos, length)
  2096 |     |                 let shift := sub(256, shl(3, length))
  2097 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2098 |     |             }
  2099 |     |             m0 := mload(0x00)
  2100 |     |             m1 := mload(0x20)
  2101 |     |             m2 := mload(0x40)
  2102 |     |             m3 := mload(0x60)
  2103 |     |             m4 := mload(0x80)
  2104 |     |             m5 := mload(0xa0)
  2105 |     |             m6 := mload(0xc0)
  2106 |     |             m7 := mload(0xe0)
  2107 |     |             // Selector of `log(uint256,string,string)`.
  2108 |     |             mstore(0x00, 0xb115611f)
  2109 |     |             mstore(0x20, p0)
  2110 |     |             mstore(0x40, 0x60)
  2111 |     |             mstore(0x60, 0xa0)
  2112 |     |             writeString(0x80, p1)
  2113 |     |             writeString(0xc0, p2)
  2114 |     |         }
  2115 |     |         _sendLogPayload(0x1c, 0xe4);
  2116 |     |         assembly {
  2117 |     |             mstore(0x00, m0)
  2118 |     |             mstore(0x20, m1)
  2119 |     |             mstore(0x40, m2)
  2120 |     |             mstore(0x60, m3)
  2121 |     |             mstore(0x80, m4)
  2122 |     |             mstore(0xa0, m5)
  2123 |     |             mstore(0xc0, m6)
  2124 |     |             mstore(0xe0, m7)
  2125 |     |         }
  2126 |     |     }
  2127 |     | 
  2128 |     |     function log(bytes32 p0, address p1, address p2) internal pure {
  2129 |     |         bytes32 m0;
  2130 |     |         bytes32 m1;
  2131 |     |         bytes32 m2;
  2132 |     |         bytes32 m3;
  2133 |     |         bytes32 m4;
  2134 |     |         bytes32 m5;
  2135 |     |         assembly {
  2136 |     |             function writeString(pos, w) {
  2137 |     |                 let length := 0
  2138 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2139 |     |                 mstore(pos, length)
  2140 |     |                 let shift := sub(256, shl(3, length))
  2141 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2142 |     |             }
  2143 |     |             m0 := mload(0x00)
  2144 |     |             m1 := mload(0x20)
  2145 |     |             m2 := mload(0x40)
  2146 |     |             m3 := mload(0x60)
  2147 |     |             m4 := mload(0x80)
  2148 |     |             m5 := mload(0xa0)
  2149 |     |             // Selector of `log(string,address,address)`.
  2150 |     |             mstore(0x00, 0xfcec75e0)
  2151 |     |             mstore(0x20, 0x60)
  2152 |     |             mstore(0x40, p1)
  2153 |     |             mstore(0x60, p2)
  2154 |     |             writeString(0x80, p0)
  2155 |     |         }
  2156 |     |         _sendLogPayload(0x1c, 0xa4);
  2157 |     |         assembly {
  2158 |     |             mstore(0x00, m0)
  2159 |     |             mstore(0x20, m1)
  2160 |     |             mstore(0x40, m2)
  2161 |     |             mstore(0x60, m3)
  2162 |     |             mstore(0x80, m4)
  2163 |     |             mstore(0xa0, m5)
  2164 |     |         }
  2165 |     |     }
  2166 |     | 
  2167 |     |     function log(bytes32 p0, address p1, bool p2) internal pure {
  2168 |     |         bytes32 m0;
  2169 |     |         bytes32 m1;
  2170 |     |         bytes32 m2;
  2171 |     |         bytes32 m3;
  2172 |     |         bytes32 m4;
  2173 |     |         bytes32 m5;
  2174 |     |         assembly {
  2175 |     |             function writeString(pos, w) {
  2176 |     |                 let length := 0
  2177 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2178 |     |                 mstore(pos, length)
  2179 |     |                 let shift := sub(256, shl(3, length))
  2180 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2181 |     |             }
  2182 |     |             m0 := mload(0x00)
  2183 |     |             m1 := mload(0x20)
  2184 |     |             m2 := mload(0x40)
  2185 |     |             m3 := mload(0x60)
  2186 |     |             m4 := mload(0x80)
  2187 |     |             m5 := mload(0xa0)
  2188 |     |             // Selector of `log(string,address,bool)`.
  2189 |     |             mstore(0x00, 0xc91d5ed4)
  2190 |     |             mstore(0x20, 0x60)
  2191 |     |             mstore(0x40, p1)
  2192 |     |             mstore(0x60, p2)
  2193 |     |             writeString(0x80, p0)
  2194 |     |         }
  2195 |     |         _sendLogPayload(0x1c, 0xa4);
  2196 |     |         assembly {
  2197 |     |             mstore(0x00, m0)
  2198 |     |             mstore(0x20, m1)
  2199 |     |             mstore(0x40, m2)
  2200 |     |             mstore(0x60, m3)
  2201 |     |             mstore(0x80, m4)
  2202 |     |             mstore(0xa0, m5)
  2203 |     |         }
  2204 |     |     }
  2205 |     | 
  2206 |     |     function log(bytes32 p0, address p1, uint256 p2) internal pure {
  2207 |     |         bytes32 m0;
  2208 |     |         bytes32 m1;
  2209 |     |         bytes32 m2;
  2210 |     |         bytes32 m3;
  2211 |     |         bytes32 m4;
  2212 |     |         bytes32 m5;
  2213 |     |         assembly {
  2214 |     |             function writeString(pos, w) {
  2215 |     |                 let length := 0
  2216 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2217 |     |                 mstore(pos, length)
  2218 |     |                 let shift := sub(256, shl(3, length))
  2219 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2220 |     |             }
  2221 |     |             m0 := mload(0x00)
  2222 |     |             m1 := mload(0x20)
  2223 |     |             m2 := mload(0x40)
  2224 |     |             m3 := mload(0x60)
  2225 |     |             m4 := mload(0x80)
  2226 |     |             m5 := mload(0xa0)
  2227 |     |             // Selector of `log(string,address,uint256)`.
  2228 |     |             mstore(0x00, 0x0d26b925)
  2229 |     |             mstore(0x20, 0x60)
  2230 |     |             mstore(0x40, p1)
  2231 |     |             mstore(0x60, p2)
  2232 |     |             writeString(0x80, p0)
  2233 |     |         }
  2234 |     |         _sendLogPayload(0x1c, 0xa4);
  2235 |     |         assembly {
  2236 |     |             mstore(0x00, m0)
  2237 |     |             mstore(0x20, m1)
  2238 |     |             mstore(0x40, m2)
  2239 |     |             mstore(0x60, m3)
  2240 |     |             mstore(0x80, m4)
  2241 |     |             mstore(0xa0, m5)
  2242 |     |         }
  2243 |     |     }
  2244 |     | 
  2245 |     |     function log(bytes32 p0, address p1, bytes32 p2) internal pure {
  2246 |     |         bytes32 m0;
  2247 |     |         bytes32 m1;
  2248 |     |         bytes32 m2;
  2249 |     |         bytes32 m3;
  2250 |     |         bytes32 m4;
  2251 |     |         bytes32 m5;
  2252 |     |         bytes32 m6;
  2253 |     |         bytes32 m7;
  2254 |     |         assembly {
  2255 |     |             function writeString(pos, w) {
  2256 |     |                 let length := 0
  2257 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2258 |     |                 mstore(pos, length)
  2259 |     |                 let shift := sub(256, shl(3, length))
  2260 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2261 |     |             }
  2262 |     |             m0 := mload(0x00)
  2263 |     |             m1 := mload(0x20)
  2264 |     |             m2 := mload(0x40)
  2265 |     |             m3 := mload(0x60)
  2266 |     |             m4 := mload(0x80)
  2267 |     |             m5 := mload(0xa0)
  2268 |     |             m6 := mload(0xc0)
  2269 |     |             m7 := mload(0xe0)
  2270 |     |             // Selector of `log(string,address,string)`.
  2271 |     |             mstore(0x00, 0xe0e9ad4f)
  2272 |     |             mstore(0x20, 0x60)
  2273 |     |             mstore(0x40, p1)
  2274 |     |             mstore(0x60, 0xa0)
  2275 |     |             writeString(0x80, p0)
  2276 |     |             writeString(0xc0, p2)
  2277 |     |         }
  2278 |     |         _sendLogPayload(0x1c, 0xe4);
  2279 |     |         assembly {
  2280 |     |             mstore(0x00, m0)
  2281 |     |             mstore(0x20, m1)
  2282 |     |             mstore(0x40, m2)
  2283 |     |             mstore(0x60, m3)
  2284 |     |             mstore(0x80, m4)
  2285 |     |             mstore(0xa0, m5)
  2286 |     |             mstore(0xc0, m6)
  2287 |     |             mstore(0xe0, m7)
  2288 |     |         }
  2289 |     |     }
  2290 |     | 
  2291 |     |     function log(bytes32 p0, bool p1, address p2) internal pure {
  2292 |     |         bytes32 m0;
  2293 |     |         bytes32 m1;
  2294 |     |         bytes32 m2;
  2295 |     |         bytes32 m3;
  2296 |     |         bytes32 m4;
  2297 |     |         bytes32 m5;
  2298 |     |         assembly {
  2299 |     |             function writeString(pos, w) {
  2300 |     |                 let length := 0
  2301 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2302 |     |                 mstore(pos, length)
  2303 |     |                 let shift := sub(256, shl(3, length))
  2304 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2305 |     |             }
  2306 |     |             m0 := mload(0x00)
  2307 |     |             m1 := mload(0x20)
  2308 |     |             m2 := mload(0x40)
  2309 |     |             m3 := mload(0x60)
  2310 |     |             m4 := mload(0x80)
  2311 |     |             m5 := mload(0xa0)
  2312 |     |             // Selector of `log(string,bool,address)`.
  2313 |     |             mstore(0x00, 0x932bbb38)
  2314 |     |             mstore(0x20, 0x60)
  2315 |     |             mstore(0x40, p1)
  2316 |     |             mstore(0x60, p2)
  2317 |     |             writeString(0x80, p0)
  2318 |     |         }
  2319 |     |         _sendLogPayload(0x1c, 0xa4);
  2320 |     |         assembly {
  2321 |     |             mstore(0x00, m0)
  2322 |     |             mstore(0x20, m1)
  2323 |     |             mstore(0x40, m2)
  2324 |     |             mstore(0x60, m3)
  2325 |     |             mstore(0x80, m4)
  2326 |     |             mstore(0xa0, m5)
  2327 |     |         }
  2328 |     |     }
  2329 |     | 
  2330 |     |     function log(bytes32 p0, bool p1, bool p2) internal pure {
  2331 |     |         bytes32 m0;
  2332 |     |         bytes32 m1;
  2333 |     |         bytes32 m2;
  2334 |     |         bytes32 m3;
  2335 |     |         bytes32 m4;
  2336 |     |         bytes32 m5;
  2337 |     |         assembly {
  2338 |     |             function writeString(pos, w) {
  2339 |     |                 let length := 0
  2340 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2341 |     |                 mstore(pos, length)
  2342 |     |                 let shift := sub(256, shl(3, length))
  2343 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2344 |     |             }
  2345 |     |             m0 := mload(0x00)
  2346 |     |             m1 := mload(0x20)
  2347 |     |             m2 := mload(0x40)
  2348 |     |             m3 := mload(0x60)
  2349 |     |             m4 := mload(0x80)
  2350 |     |             m5 := mload(0xa0)
  2351 |     |             // Selector of `log(string,bool,bool)`.
  2352 |     |             mstore(0x00, 0x850b7ad6)
  2353 |     |             mstore(0x20, 0x60)
  2354 |     |             mstore(0x40, p1)
  2355 |     |             mstore(0x60, p2)
  2356 |     |             writeString(0x80, p0)
  2357 |     |         }
  2358 |     |         _sendLogPayload(0x1c, 0xa4);
  2359 |     |         assembly {
  2360 |     |             mstore(0x00, m0)
  2361 |     |             mstore(0x20, m1)
  2362 |     |             mstore(0x40, m2)
  2363 |     |             mstore(0x60, m3)
  2364 |     |             mstore(0x80, m4)
  2365 |     |             mstore(0xa0, m5)
  2366 |     |         }
  2367 |     |     }
  2368 |     | 
  2369 |     |     function log(bytes32 p0, bool p1, uint256 p2) internal pure {
  2370 |     |         bytes32 m0;
  2371 |     |         bytes32 m1;
  2372 |     |         bytes32 m2;
  2373 |     |         bytes32 m3;
  2374 |     |         bytes32 m4;
  2375 |     |         bytes32 m5;
  2376 |     |         assembly {
  2377 |     |             function writeString(pos, w) {
  2378 |     |                 let length := 0
  2379 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2380 |     |                 mstore(pos, length)
  2381 |     |                 let shift := sub(256, shl(3, length))
  2382 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2383 |     |             }
  2384 |     |             m0 := mload(0x00)
  2385 |     |             m1 := mload(0x20)
  2386 |     |             m2 := mload(0x40)
  2387 |     |             m3 := mload(0x60)
  2388 |     |             m4 := mload(0x80)
  2389 |     |             m5 := mload(0xa0)
  2390 |     |             // Selector of `log(string,bool,uint256)`.
  2391 |     |             mstore(0x00, 0xc95958d6)
  2392 |     |             mstore(0x20, 0x60)
  2393 |     |             mstore(0x40, p1)
  2394 |     |             mstore(0x60, p2)
  2395 |     |             writeString(0x80, p0)
  2396 |     |         }
  2397 |     |         _sendLogPayload(0x1c, 0xa4);
  2398 |     |         assembly {
  2399 |     |             mstore(0x00, m0)
  2400 |     |             mstore(0x20, m1)
  2401 |     |             mstore(0x40, m2)
  2402 |     |             mstore(0x60, m3)
  2403 |     |             mstore(0x80, m4)
  2404 |     |             mstore(0xa0, m5)
  2405 |     |         }
  2406 |     |     }
  2407 |     | 
  2408 |     |     function log(bytes32 p0, bool p1, bytes32 p2) internal pure {
  2409 |     |         bytes32 m0;
  2410 |     |         bytes32 m1;
  2411 |     |         bytes32 m2;
  2412 |     |         bytes32 m3;
  2413 |     |         bytes32 m4;
  2414 |     |         bytes32 m5;
  2415 |     |         bytes32 m6;
  2416 |     |         bytes32 m7;
  2417 |     |         assembly {
  2418 |     |             function writeString(pos, w) {
  2419 |     |                 let length := 0
  2420 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2421 |     |                 mstore(pos, length)
  2422 |     |                 let shift := sub(256, shl(3, length))
  2423 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2424 |     |             }
  2425 |     |             m0 := mload(0x00)
  2426 |     |             m1 := mload(0x20)
  2427 |     |             m2 := mload(0x40)
  2428 |     |             m3 := mload(0x60)
  2429 |     |             m4 := mload(0x80)
  2430 |     |             m5 := mload(0xa0)
  2431 |     |             m6 := mload(0xc0)
  2432 |     |             m7 := mload(0xe0)
  2433 |     |             // Selector of `log(string,bool,string)`.
  2434 |     |             mstore(0x00, 0xe298f47d)
  2435 |     |             mstore(0x20, 0x60)
  2436 |     |             mstore(0x40, p1)
  2437 |     |             mstore(0x60, 0xa0)
  2438 |     |             writeString(0x80, p0)
  2439 |     |             writeString(0xc0, p2)
  2440 |     |         }
  2441 |     |         _sendLogPayload(0x1c, 0xe4);
  2442 |     |         assembly {
  2443 |     |             mstore(0x00, m0)
  2444 |     |             mstore(0x20, m1)
  2445 |     |             mstore(0x40, m2)
  2446 |     |             mstore(0x60, m3)
  2447 |     |             mstore(0x80, m4)
  2448 |     |             mstore(0xa0, m5)
  2449 |     |             mstore(0xc0, m6)
  2450 |     |             mstore(0xe0, m7)
  2451 |     |         }
  2452 |     |     }
  2453 |     | 
  2454 |     |     function log(bytes32 p0, uint256 p1, address p2) internal pure {
  2455 |     |         bytes32 m0;
  2456 |     |         bytes32 m1;
  2457 |     |         bytes32 m2;
  2458 |     |         bytes32 m3;
  2459 |     |         bytes32 m4;
  2460 |     |         bytes32 m5;
  2461 |     |         assembly {
  2462 |     |             function writeString(pos, w) {
  2463 |     |                 let length := 0
  2464 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2465 |     |                 mstore(pos, length)
  2466 |     |                 let shift := sub(256, shl(3, length))
  2467 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2468 |     |             }
  2469 |     |             m0 := mload(0x00)
  2470 |     |             m1 := mload(0x20)
  2471 |     |             m2 := mload(0x40)
  2472 |     |             m3 := mload(0x60)
  2473 |     |             m4 := mload(0x80)
  2474 |     |             m5 := mload(0xa0)
  2475 |     |             // Selector of `log(string,uint256,address)`.
  2476 |     |             mstore(0x00, 0x1c7ec448)
  2477 |     |             mstore(0x20, 0x60)
  2478 |     |             mstore(0x40, p1)
  2479 |     |             mstore(0x60, p2)
  2480 |     |             writeString(0x80, p0)
  2481 |     |         }
  2482 |     |         _sendLogPayload(0x1c, 0xa4);
  2483 |     |         assembly {
  2484 |     |             mstore(0x00, m0)
  2485 |     |             mstore(0x20, m1)
  2486 |     |             mstore(0x40, m2)
  2487 |     |             mstore(0x60, m3)
  2488 |     |             mstore(0x80, m4)
  2489 |     |             mstore(0xa0, m5)
  2490 |     |         }
  2491 |     |     }
  2492 |     | 
  2493 |     |     function log(bytes32 p0, uint256 p1, bool p2) internal pure {
  2494 |     |         bytes32 m0;
  2495 |     |         bytes32 m1;
  2496 |     |         bytes32 m2;
  2497 |     |         bytes32 m3;
  2498 |     |         bytes32 m4;
  2499 |     |         bytes32 m5;
  2500 |     |         assembly {
  2501 |     |             function writeString(pos, w) {
  2502 |     |                 let length := 0
  2503 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2504 |     |                 mstore(pos, length)
  2505 |     |                 let shift := sub(256, shl(3, length))
  2506 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2507 |     |             }
  2508 |     |             m0 := mload(0x00)
  2509 |     |             m1 := mload(0x20)
  2510 |     |             m2 := mload(0x40)
  2511 |     |             m3 := mload(0x60)
  2512 |     |             m4 := mload(0x80)
  2513 |     |             m5 := mload(0xa0)
  2514 |     |             // Selector of `log(string,uint256,bool)`.
  2515 |     |             mstore(0x00, 0xca7733b1)
  2516 |     |             mstore(0x20, 0x60)
  2517 |     |             mstore(0x40, p1)
  2518 |     |             mstore(0x60, p2)
  2519 |     |             writeString(0x80, p0)
  2520 |     |         }
  2521 |     |         _sendLogPayload(0x1c, 0xa4);
  2522 |     |         assembly {
  2523 |     |             mstore(0x00, m0)
  2524 |     |             mstore(0x20, m1)
  2525 |     |             mstore(0x40, m2)
  2526 |     |             mstore(0x60, m3)
  2527 |     |             mstore(0x80, m4)
  2528 |     |             mstore(0xa0, m5)
  2529 |     |         }
  2530 |     |     }
  2531 |     | 
  2532 |     |     function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {
  2533 |     |         bytes32 m0;
  2534 |     |         bytes32 m1;
  2535 |     |         bytes32 m2;
  2536 |     |         bytes32 m3;
  2537 |     |         bytes32 m4;
  2538 |     |         bytes32 m5;
  2539 |     |         assembly {
  2540 |     |             function writeString(pos, w) {
  2541 |     |                 let length := 0
  2542 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2543 |     |                 mstore(pos, length)
  2544 |     |                 let shift := sub(256, shl(3, length))
  2545 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2546 |     |             }
  2547 |     |             m0 := mload(0x00)
  2548 |     |             m1 := mload(0x20)
  2549 |     |             m2 := mload(0x40)
  2550 |     |             m3 := mload(0x60)
  2551 |     |             m4 := mload(0x80)
  2552 |     |             m5 := mload(0xa0)
  2553 |     |             // Selector of `log(string,uint256,uint256)`.
  2554 |     |             mstore(0x00, 0xca47c4eb)
  2555 |     |             mstore(0x20, 0x60)
  2556 |     |             mstore(0x40, p1)
  2557 |     |             mstore(0x60, p2)
  2558 |     |             writeString(0x80, p0)
  2559 |     |         }
  2560 |     |         _sendLogPayload(0x1c, 0xa4);
  2561 |     |         assembly {
  2562 |     |             mstore(0x00, m0)
  2563 |     |             mstore(0x20, m1)
  2564 |     |             mstore(0x40, m2)
  2565 |     |             mstore(0x60, m3)
  2566 |     |             mstore(0x80, m4)
  2567 |     |             mstore(0xa0, m5)
  2568 |     |         }
  2569 |     |     }
  2570 |     | 
  2571 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {
  2572 |     |         bytes32 m0;
  2573 |     |         bytes32 m1;
  2574 |     |         bytes32 m2;
  2575 |     |         bytes32 m3;
  2576 |     |         bytes32 m4;
  2577 |     |         bytes32 m5;
  2578 |     |         bytes32 m6;
  2579 |     |         bytes32 m7;
  2580 |     |         assembly {
  2581 |     |             function writeString(pos, w) {
  2582 |     |                 let length := 0
  2583 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2584 |     |                 mstore(pos, length)
  2585 |     |                 let shift := sub(256, shl(3, length))
  2586 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2587 |     |             }
  2588 |     |             m0 := mload(0x00)
  2589 |     |             m1 := mload(0x20)
  2590 |     |             m2 := mload(0x40)
  2591 |     |             m3 := mload(0x60)
  2592 |     |             m4 := mload(0x80)
  2593 |     |             m5 := mload(0xa0)
  2594 |     |             m6 := mload(0xc0)
  2595 |     |             m7 := mload(0xe0)
  2596 |     |             // Selector of `log(string,uint256,string)`.
  2597 |     |             mstore(0x00, 0x5970e089)
  2598 |     |             mstore(0x20, 0x60)
  2599 |     |             mstore(0x40, p1)
  2600 |     |             mstore(0x60, 0xa0)
  2601 |     |             writeString(0x80, p0)
  2602 |     |             writeString(0xc0, p2)
  2603 |     |         }
  2604 |     |         _sendLogPayload(0x1c, 0xe4);
  2605 |     |         assembly {
  2606 |     |             mstore(0x00, m0)
  2607 |     |             mstore(0x20, m1)
  2608 |     |             mstore(0x40, m2)
  2609 |     |             mstore(0x60, m3)
  2610 |     |             mstore(0x80, m4)
  2611 |     |             mstore(0xa0, m5)
  2612 |     |             mstore(0xc0, m6)
  2613 |     |             mstore(0xe0, m7)
  2614 |     |         }
  2615 |     |     }
  2616 |     | 
  2617 |     |     function log(bytes32 p0, bytes32 p1, address p2) internal pure {
  2618 |     |         bytes32 m0;
  2619 |     |         bytes32 m1;
  2620 |     |         bytes32 m2;
  2621 |     |         bytes32 m3;
  2622 |     |         bytes32 m4;
  2623 |     |         bytes32 m5;
  2624 |     |         bytes32 m6;
  2625 |     |         bytes32 m7;
  2626 |     |         assembly {
  2627 |     |             function writeString(pos, w) {
  2628 |     |                 let length := 0
  2629 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2630 |     |                 mstore(pos, length)
  2631 |     |                 let shift := sub(256, shl(3, length))
  2632 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2633 |     |             }
  2634 |     |             m0 := mload(0x00)
  2635 |     |             m1 := mload(0x20)
  2636 |     |             m2 := mload(0x40)
  2637 |     |             m3 := mload(0x60)
  2638 |     |             m4 := mload(0x80)
  2639 |     |             m5 := mload(0xa0)
  2640 |     |             m6 := mload(0xc0)
  2641 |     |             m7 := mload(0xe0)
  2642 |     |             // Selector of `log(string,string,address)`.
  2643 |     |             mstore(0x00, 0x95ed0195)
  2644 |     |             mstore(0x20, 0x60)
  2645 |     |             mstore(0x40, 0xa0)
  2646 |     |             mstore(0x60, p2)
  2647 |     |             writeString(0x80, p0)
  2648 |     |             writeString(0xc0, p1)
  2649 |     |         }
  2650 |     |         _sendLogPayload(0x1c, 0xe4);
  2651 |     |         assembly {
  2652 |     |             mstore(0x00, m0)
  2653 |     |             mstore(0x20, m1)
  2654 |     |             mstore(0x40, m2)
  2655 |     |             mstore(0x60, m3)
  2656 |     |             mstore(0x80, m4)
  2657 |     |             mstore(0xa0, m5)
  2658 |     |             mstore(0xc0, m6)
  2659 |     |             mstore(0xe0, m7)
  2660 |     |         }
  2661 |     |     }
  2662 |     | 
  2663 |     |     function log(bytes32 p0, bytes32 p1, bool p2) internal pure {
  2664 |     |         bytes32 m0;
  2665 |     |         bytes32 m1;
  2666 |     |         bytes32 m2;
  2667 |     |         bytes32 m3;
  2668 |     |         bytes32 m4;
  2669 |     |         bytes32 m5;
  2670 |     |         bytes32 m6;
  2671 |     |         bytes32 m7;
  2672 |     |         assembly {
  2673 |     |             function writeString(pos, w) {
  2674 |     |                 let length := 0
  2675 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2676 |     |                 mstore(pos, length)
  2677 |     |                 let shift := sub(256, shl(3, length))
  2678 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2679 |     |             }
  2680 |     |             m0 := mload(0x00)
  2681 |     |             m1 := mload(0x20)
  2682 |     |             m2 := mload(0x40)
  2683 |     |             m3 := mload(0x60)
  2684 |     |             m4 := mload(0x80)
  2685 |     |             m5 := mload(0xa0)
  2686 |     |             m6 := mload(0xc0)
  2687 |     |             m7 := mload(0xe0)
  2688 |     |             // Selector of `log(string,string,bool)`.
  2689 |     |             mstore(0x00, 0xb0e0f9b5)
  2690 |     |             mstore(0x20, 0x60)
  2691 |     |             mstore(0x40, 0xa0)
  2692 |     |             mstore(0x60, p2)
  2693 |     |             writeString(0x80, p0)
  2694 |     |             writeString(0xc0, p1)
  2695 |     |         }
  2696 |     |         _sendLogPayload(0x1c, 0xe4);
  2697 |     |         assembly {
  2698 |     |             mstore(0x00, m0)
  2699 |     |             mstore(0x20, m1)
  2700 |     |             mstore(0x40, m2)
  2701 |     |             mstore(0x60, m3)
  2702 |     |             mstore(0x80, m4)
  2703 |     |             mstore(0xa0, m5)
  2704 |     |             mstore(0xc0, m6)
  2705 |     |             mstore(0xe0, m7)
  2706 |     |         }
  2707 |     |     }
  2708 |     | 
  2709 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {
  2710 |     |         bytes32 m0;
  2711 |     |         bytes32 m1;
  2712 |     |         bytes32 m2;
  2713 |     |         bytes32 m3;
  2714 |     |         bytes32 m4;
  2715 |     |         bytes32 m5;
  2716 |     |         bytes32 m6;
  2717 |     |         bytes32 m7;
  2718 |     |         assembly {
  2719 |     |             function writeString(pos, w) {
  2720 |     |                 let length := 0
  2721 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2722 |     |                 mstore(pos, length)
  2723 |     |                 let shift := sub(256, shl(3, length))
  2724 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2725 |     |             }
  2726 |     |             m0 := mload(0x00)
  2727 |     |             m1 := mload(0x20)
  2728 |     |             m2 := mload(0x40)
  2729 |     |             m3 := mload(0x60)
  2730 |     |             m4 := mload(0x80)
  2731 |     |             m5 := mload(0xa0)
  2732 |     |             m6 := mload(0xc0)
  2733 |     |             m7 := mload(0xe0)
  2734 |     |             // Selector of `log(string,string,uint256)`.
  2735 |     |             mstore(0x00, 0x5821efa1)
  2736 |     |             mstore(0x20, 0x60)
  2737 |     |             mstore(0x40, 0xa0)
  2738 |     |             mstore(0x60, p2)
  2739 |     |             writeString(0x80, p0)
  2740 |     |             writeString(0xc0, p1)
  2741 |     |         }
  2742 |     |         _sendLogPayload(0x1c, 0xe4);
  2743 |     |         assembly {
  2744 |     |             mstore(0x00, m0)
  2745 |     |             mstore(0x20, m1)
  2746 |     |             mstore(0x40, m2)
  2747 |     |             mstore(0x60, m3)
  2748 |     |             mstore(0x80, m4)
  2749 |     |             mstore(0xa0, m5)
  2750 |     |             mstore(0xc0, m6)
  2751 |     |             mstore(0xe0, m7)
  2752 |     |         }
  2753 |     |     }
  2754 |     | 
  2755 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {
  2756 |     |         bytes32 m0;
  2757 |     |         bytes32 m1;
  2758 |     |         bytes32 m2;
  2759 |     |         bytes32 m3;
  2760 |     |         bytes32 m4;
  2761 |     |         bytes32 m5;
  2762 |     |         bytes32 m6;
  2763 |     |         bytes32 m7;
  2764 |     |         bytes32 m8;
  2765 |     |         bytes32 m9;
  2766 |     |         assembly {
  2767 |     |             function writeString(pos, w) {
  2768 |     |                 let length := 0
  2769 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2770 |     |                 mstore(pos, length)
  2771 |     |                 let shift := sub(256, shl(3, length))
  2772 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2773 |     |             }
  2774 |     |             m0 := mload(0x00)
  2775 |     |             m1 := mload(0x20)
  2776 |     |             m2 := mload(0x40)
  2777 |     |             m3 := mload(0x60)
  2778 |     |             m4 := mload(0x80)
  2779 |     |             m5 := mload(0xa0)
  2780 |     |             m6 := mload(0xc0)
  2781 |     |             m7 := mload(0xe0)
  2782 |     |             m8 := mload(0x100)
  2783 |     |             m9 := mload(0x120)
  2784 |     |             // Selector of `log(string,string,string)`.
  2785 |     |             mstore(0x00, 0x2ced7cef)
  2786 |     |             mstore(0x20, 0x60)
  2787 |     |             mstore(0x40, 0xa0)
  2788 |     |             mstore(0x60, 0xe0)
  2789 |     |             writeString(0x80, p0)
  2790 |     |             writeString(0xc0, p1)
  2791 |     |             writeString(0x100, p2)
  2792 |     |         }
  2793 |     |         _sendLogPayload(0x1c, 0x124);
  2794 |     |         assembly {
  2795 |     |             mstore(0x00, m0)
  2796 |     |             mstore(0x20, m1)
  2797 |     |             mstore(0x40, m2)
  2798 |     |             mstore(0x60, m3)
  2799 |     |             mstore(0x80, m4)
  2800 |     |             mstore(0xa0, m5)
  2801 |     |             mstore(0xc0, m6)
  2802 |     |             mstore(0xe0, m7)
  2803 |     |             mstore(0x100, m8)
  2804 |     |             mstore(0x120, m9)
  2805 |     |         }
  2806 |     |     }
  2807 |     | 
  2808 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
  2809 |     |         bytes32 m0;
  2810 |     |         bytes32 m1;
  2811 |     |         bytes32 m2;
  2812 |     |         bytes32 m3;
  2813 |     |         bytes32 m4;
  2814 |     |         assembly {
  2815 |     |             m0 := mload(0x00)
  2816 |     |             m1 := mload(0x20)
  2817 |     |             m2 := mload(0x40)
  2818 |     |             m3 := mload(0x60)
  2819 |     |             m4 := mload(0x80)
  2820 |     |             // Selector of `log(address,address,address,address)`.
  2821 |     |             mstore(0x00, 0x665bf134)
  2822 |     |             mstore(0x20, p0)
  2823 |     |             mstore(0x40, p1)
  2824 |     |             mstore(0x60, p2)
  2825 |     |             mstore(0x80, p3)
  2826 |     |         }
  2827 |     |         _sendLogPayload(0x1c, 0x84);
  2828 |     |         assembly {
  2829 |     |             mstore(0x00, m0)
  2830 |     |             mstore(0x20, m1)
  2831 |     |             mstore(0x40, m2)
  2832 |     |             mstore(0x60, m3)
  2833 |     |             mstore(0x80, m4)
  2834 |     |         }
  2835 |     |     }
  2836 |     | 
  2837 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
  2838 |     |         bytes32 m0;
  2839 |     |         bytes32 m1;
  2840 |     |         bytes32 m2;
  2841 |     |         bytes32 m3;
  2842 |     |         bytes32 m4;
  2843 |     |         assembly {
  2844 |     |             m0 := mload(0x00)
  2845 |     |             m1 := mload(0x20)
  2846 |     |             m2 := mload(0x40)
  2847 |     |             m3 := mload(0x60)
  2848 |     |             m4 := mload(0x80)
  2849 |     |             // Selector of `log(address,address,address,bool)`.
  2850 |     |             mstore(0x00, 0x0e378994)
  2851 |     |             mstore(0x20, p0)
  2852 |     |             mstore(0x40, p1)
  2853 |     |             mstore(0x60, p2)
  2854 |     |             mstore(0x80, p3)
  2855 |     |         }
  2856 |     |         _sendLogPayload(0x1c, 0x84);
  2857 |     |         assembly {
  2858 |     |             mstore(0x00, m0)
  2859 |     |             mstore(0x20, m1)
  2860 |     |             mstore(0x40, m2)
  2861 |     |             mstore(0x60, m3)
  2862 |     |             mstore(0x80, m4)
  2863 |     |         }
  2864 |     |     }
  2865 |     | 
  2866 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
  2867 |     |         bytes32 m0;
  2868 |     |         bytes32 m1;
  2869 |     |         bytes32 m2;
  2870 |     |         bytes32 m3;
  2871 |     |         bytes32 m4;
  2872 |     |         assembly {
  2873 |     |             m0 := mload(0x00)
  2874 |     |             m1 := mload(0x20)
  2875 |     |             m2 := mload(0x40)
  2876 |     |             m3 := mload(0x60)
  2877 |     |             m4 := mload(0x80)
  2878 |     |             // Selector of `log(address,address,address,uint256)`.
  2879 |     |             mstore(0x00, 0x94250d77)
  2880 |     |             mstore(0x20, p0)
  2881 |     |             mstore(0x40, p1)
  2882 |     |             mstore(0x60, p2)
  2883 |     |             mstore(0x80, p3)
  2884 |     |         }
  2885 |     |         _sendLogPayload(0x1c, 0x84);
  2886 |     |         assembly {
  2887 |     |             mstore(0x00, m0)
  2888 |     |             mstore(0x20, m1)
  2889 |     |             mstore(0x40, m2)
  2890 |     |             mstore(0x60, m3)
  2891 |     |             mstore(0x80, m4)
  2892 |     |         }
  2893 |     |     }
  2894 |     | 
  2895 |     |     function log(address p0, address p1, address p2, bytes32 p3) internal pure {
  2896 |     |         bytes32 m0;
  2897 |     |         bytes32 m1;
  2898 |     |         bytes32 m2;
  2899 |     |         bytes32 m3;
  2900 |     |         bytes32 m4;
  2901 |     |         bytes32 m5;
  2902 |     |         bytes32 m6;
  2903 |     |         assembly {
  2904 |     |             function writeString(pos, w) {
  2905 |     |                 let length := 0
  2906 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2907 |     |                 mstore(pos, length)
  2908 |     |                 let shift := sub(256, shl(3, length))
  2909 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2910 |     |             }
  2911 |     |             m0 := mload(0x00)
  2912 |     |             m1 := mload(0x20)
  2913 |     |             m2 := mload(0x40)
  2914 |     |             m3 := mload(0x60)
  2915 |     |             m4 := mload(0x80)
  2916 |     |             m5 := mload(0xa0)
  2917 |     |             m6 := mload(0xc0)
  2918 |     |             // Selector of `log(address,address,address,string)`.
  2919 |     |             mstore(0x00, 0xf808da20)
  2920 |     |             mstore(0x20, p0)
  2921 |     |             mstore(0x40, p1)
  2922 |     |             mstore(0x60, p2)
  2923 |     |             mstore(0x80, 0x80)
  2924 |     |             writeString(0xa0, p3)
  2925 |     |         }
  2926 |     |         _sendLogPayload(0x1c, 0xc4);
  2927 |     |         assembly {
  2928 |     |             mstore(0x00, m0)
  2929 |     |             mstore(0x20, m1)
  2930 |     |             mstore(0x40, m2)
  2931 |     |             mstore(0x60, m3)
  2932 |     |             mstore(0x80, m4)
  2933 |     |             mstore(0xa0, m5)
  2934 |     |             mstore(0xc0, m6)
  2935 |     |         }
  2936 |     |     }
  2937 |     | 
  2938 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
  2939 |     |         bytes32 m0;
  2940 |     |         bytes32 m1;
  2941 |     |         bytes32 m2;
  2942 |     |         bytes32 m3;
  2943 |     |         bytes32 m4;
  2944 |     |         assembly {
  2945 |     |             m0 := mload(0x00)
  2946 |     |             m1 := mload(0x20)
  2947 |     |             m2 := mload(0x40)
  2948 |     |             m3 := mload(0x60)
  2949 |     |             m4 := mload(0x80)
  2950 |     |             // Selector of `log(address,address,bool,address)`.
  2951 |     |             mstore(0x00, 0x9f1bc36e)
  2952 |     |             mstore(0x20, p0)
  2953 |     |             mstore(0x40, p1)
  2954 |     |             mstore(0x60, p2)
  2955 |     |             mstore(0x80, p3)
  2956 |     |         }
  2957 |     |         _sendLogPayload(0x1c, 0x84);
  2958 |     |         assembly {
  2959 |     |             mstore(0x00, m0)
  2960 |     |             mstore(0x20, m1)
  2961 |     |             mstore(0x40, m2)
  2962 |     |             mstore(0x60, m3)
  2963 |     |             mstore(0x80, m4)
  2964 |     |         }
  2965 |     |     }
  2966 |     | 
  2967 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
  2968 |     |         bytes32 m0;
  2969 |     |         bytes32 m1;
  2970 |     |         bytes32 m2;
  2971 |     |         bytes32 m3;
  2972 |     |         bytes32 m4;
  2973 |     |         assembly {
  2974 |     |             m0 := mload(0x00)
  2975 |     |             m1 := mload(0x20)
  2976 |     |             m2 := mload(0x40)
  2977 |     |             m3 := mload(0x60)
  2978 |     |             m4 := mload(0x80)
  2979 |     |             // Selector of `log(address,address,bool,bool)`.
  2980 |     |             mstore(0x00, 0x2cd4134a)
  2981 |     |             mstore(0x20, p0)
  2982 |     |             mstore(0x40, p1)
  2983 |     |             mstore(0x60, p2)
  2984 |     |             mstore(0x80, p3)
  2985 |     |         }
  2986 |     |         _sendLogPayload(0x1c, 0x84);
  2987 |     |         assembly {
  2988 |     |             mstore(0x00, m0)
  2989 |     |             mstore(0x20, m1)
  2990 |     |             mstore(0x40, m2)
  2991 |     |             mstore(0x60, m3)
  2992 |     |             mstore(0x80, m4)
  2993 |     |         }
  2994 |     |     }
  2995 |     | 
  2996 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
  2997 |     |         bytes32 m0;
  2998 |     |         bytes32 m1;
  2999 |     |         bytes32 m2;
  3000 |     |         bytes32 m3;
  3001 |     |         bytes32 m4;
  3002 |     |         assembly {
  3003 |     |             m0 := mload(0x00)
  3004 |     |             m1 := mload(0x20)
  3005 |     |             m2 := mload(0x40)
  3006 |     |             m3 := mload(0x60)
  3007 |     |             m4 := mload(0x80)
  3008 |     |             // Selector of `log(address,address,bool,uint256)`.
  3009 |     |             mstore(0x00, 0x3971e78c)
  3010 |     |             mstore(0x20, p0)
  3011 |     |             mstore(0x40, p1)
  3012 |     |             mstore(0x60, p2)
  3013 |     |             mstore(0x80, p3)
  3014 |     |         }
  3015 |     |         _sendLogPayload(0x1c, 0x84);
  3016 |     |         assembly {
  3017 |     |             mstore(0x00, m0)
  3018 |     |             mstore(0x20, m1)
  3019 |     |             mstore(0x40, m2)
  3020 |     |             mstore(0x60, m3)
  3021 |     |             mstore(0x80, m4)
  3022 |     |         }
  3023 |     |     }
  3024 |     | 
  3025 |     |     function log(address p0, address p1, bool p2, bytes32 p3) internal pure {
  3026 |     |         bytes32 m0;
  3027 |     |         bytes32 m1;
  3028 |     |         bytes32 m2;
  3029 |     |         bytes32 m3;
  3030 |     |         bytes32 m4;
  3031 |     |         bytes32 m5;
  3032 |     |         bytes32 m6;
  3033 |     |         assembly {
  3034 |     |             function writeString(pos, w) {
  3035 |     |                 let length := 0
  3036 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3037 |     |                 mstore(pos, length)
  3038 |     |                 let shift := sub(256, shl(3, length))
  3039 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3040 |     |             }
  3041 |     |             m0 := mload(0x00)
  3042 |     |             m1 := mload(0x20)
  3043 |     |             m2 := mload(0x40)
  3044 |     |             m3 := mload(0x60)
  3045 |     |             m4 := mload(0x80)
  3046 |     |             m5 := mload(0xa0)
  3047 |     |             m6 := mload(0xc0)
  3048 |     |             // Selector of `log(address,address,bool,string)`.
  3049 |     |             mstore(0x00, 0xaa6540c8)
  3050 |     |             mstore(0x20, p0)
  3051 |     |             mstore(0x40, p1)
  3052 |     |             mstore(0x60, p2)
  3053 |     |             mstore(0x80, 0x80)
  3054 |     |             writeString(0xa0, p3)
  3055 |     |         }
  3056 |     |         _sendLogPayload(0x1c, 0xc4);
  3057 |     |         assembly {
  3058 |     |             mstore(0x00, m0)
  3059 |     |             mstore(0x20, m1)
  3060 |     |             mstore(0x40, m2)
  3061 |     |             mstore(0x60, m3)
  3062 |     |             mstore(0x80, m4)
  3063 |     |             mstore(0xa0, m5)
  3064 |     |             mstore(0xc0, m6)
  3065 |     |         }
  3066 |     |     }
  3067 |     | 
  3068 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
  3069 |     |         bytes32 m0;
  3070 |     |         bytes32 m1;
  3071 |     |         bytes32 m2;
  3072 |     |         bytes32 m3;
  3073 |     |         bytes32 m4;
  3074 |     |         assembly {
  3075 |     |             m0 := mload(0x00)
  3076 |     |             m1 := mload(0x20)
  3077 |     |             m2 := mload(0x40)
  3078 |     |             m3 := mload(0x60)
  3079 |     |             m4 := mload(0x80)
  3080 |     |             // Selector of `log(address,address,uint256,address)`.
  3081 |     |             mstore(0x00, 0x8da6def5)
  3082 |     |             mstore(0x20, p0)
  3083 |     |             mstore(0x40, p1)
  3084 |     |             mstore(0x60, p2)
  3085 |     |             mstore(0x80, p3)
  3086 |     |         }
  3087 |     |         _sendLogPayload(0x1c, 0x84);
  3088 |     |         assembly {
  3089 |     |             mstore(0x00, m0)
  3090 |     |             mstore(0x20, m1)
  3091 |     |             mstore(0x40, m2)
  3092 |     |             mstore(0x60, m3)
  3093 |     |             mstore(0x80, m4)
  3094 |     |         }
  3095 |     |     }
  3096 |     | 
  3097 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
  3098 |     |         bytes32 m0;
  3099 |     |         bytes32 m1;
  3100 |     |         bytes32 m2;
  3101 |     |         bytes32 m3;
  3102 |     |         bytes32 m4;
  3103 |     |         assembly {
  3104 |     |             m0 := mload(0x00)
  3105 |     |             m1 := mload(0x20)
  3106 |     |             m2 := mload(0x40)
  3107 |     |             m3 := mload(0x60)
  3108 |     |             m4 := mload(0x80)
  3109 |     |             // Selector of `log(address,address,uint256,bool)`.
  3110 |     |             mstore(0x00, 0x9b4254e2)
  3111 |     |             mstore(0x20, p0)
  3112 |     |             mstore(0x40, p1)
  3113 |     |             mstore(0x60, p2)
  3114 |     |             mstore(0x80, p3)
  3115 |     |         }
  3116 |     |         _sendLogPayload(0x1c, 0x84);
  3117 |     |         assembly {
  3118 |     |             mstore(0x00, m0)
  3119 |     |             mstore(0x20, m1)
  3120 |     |             mstore(0x40, m2)
  3121 |     |             mstore(0x60, m3)
  3122 |     |             mstore(0x80, m4)
  3123 |     |         }
  3124 |     |     }
  3125 |     | 
  3126 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
  3127 |     |         bytes32 m0;
  3128 |     |         bytes32 m1;
  3129 |     |         bytes32 m2;
  3130 |     |         bytes32 m3;
  3131 |     |         bytes32 m4;
  3132 |     |         assembly {
  3133 |     |             m0 := mload(0x00)
  3134 |     |             m1 := mload(0x20)
  3135 |     |             m2 := mload(0x40)
  3136 |     |             m3 := mload(0x60)
  3137 |     |             m4 := mload(0x80)
  3138 |     |             // Selector of `log(address,address,uint256,uint256)`.
  3139 |     |             mstore(0x00, 0xbe553481)
  3140 |     |             mstore(0x20, p0)
  3141 |     |             mstore(0x40, p1)
  3142 |     |             mstore(0x60, p2)
  3143 |     |             mstore(0x80, p3)
  3144 |     |         }
  3145 |     |         _sendLogPayload(0x1c, 0x84);
  3146 |     |         assembly {
  3147 |     |             mstore(0x00, m0)
  3148 |     |             mstore(0x20, m1)
  3149 |     |             mstore(0x40, m2)
  3150 |     |             mstore(0x60, m3)
  3151 |     |             mstore(0x80, m4)
  3152 |     |         }
  3153 |     |     }
  3154 |     | 
  3155 |     |     function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {
  3156 |     |         bytes32 m0;
  3157 |     |         bytes32 m1;
  3158 |     |         bytes32 m2;
  3159 |     |         bytes32 m3;
  3160 |     |         bytes32 m4;
  3161 |     |         bytes32 m5;
  3162 |     |         bytes32 m6;
  3163 |     |         assembly {
  3164 |     |             function writeString(pos, w) {
  3165 |     |                 let length := 0
  3166 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3167 |     |                 mstore(pos, length)
  3168 |     |                 let shift := sub(256, shl(3, length))
  3169 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3170 |     |             }
  3171 |     |             m0 := mload(0x00)
  3172 |     |             m1 := mload(0x20)
  3173 |     |             m2 := mload(0x40)
  3174 |     |             m3 := mload(0x60)
  3175 |     |             m4 := mload(0x80)
  3176 |     |             m5 := mload(0xa0)
  3177 |     |             m6 := mload(0xc0)
  3178 |     |             // Selector of `log(address,address,uint256,string)`.
  3179 |     |             mstore(0x00, 0xfdb4f990)
  3180 |     |             mstore(0x20, p0)
  3181 |     |             mstore(0x40, p1)
  3182 |     |             mstore(0x60, p2)
  3183 |     |             mstore(0x80, 0x80)
  3184 |     |             writeString(0xa0, p3)
  3185 |     |         }
  3186 |     |         _sendLogPayload(0x1c, 0xc4);
  3187 |     |         assembly {
  3188 |     |             mstore(0x00, m0)
  3189 |     |             mstore(0x20, m1)
  3190 |     |             mstore(0x40, m2)
  3191 |     |             mstore(0x60, m3)
  3192 |     |             mstore(0x80, m4)
  3193 |     |             mstore(0xa0, m5)
  3194 |     |             mstore(0xc0, m6)
  3195 |     |         }
  3196 |     |     }
  3197 |     | 
  3198 |     |     function log(address p0, address p1, bytes32 p2, address p3) internal pure {
  3199 |     |         bytes32 m0;
  3200 |     |         bytes32 m1;
  3201 |     |         bytes32 m2;
  3202 |     |         bytes32 m3;
  3203 |     |         bytes32 m4;
  3204 |     |         bytes32 m5;
  3205 |     |         bytes32 m6;
  3206 |     |         assembly {
  3207 |     |             function writeString(pos, w) {
  3208 |     |                 let length := 0
  3209 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3210 |     |                 mstore(pos, length)
  3211 |     |                 let shift := sub(256, shl(3, length))
  3212 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3213 |     |             }
  3214 |     |             m0 := mload(0x00)
  3215 |     |             m1 := mload(0x20)
  3216 |     |             m2 := mload(0x40)
  3217 |     |             m3 := mload(0x60)
  3218 |     |             m4 := mload(0x80)
  3219 |     |             m5 := mload(0xa0)
  3220 |     |             m6 := mload(0xc0)
  3221 |     |             // Selector of `log(address,address,string,address)`.
  3222 |     |             mstore(0x00, 0x8f736d16)
  3223 |     |             mstore(0x20, p0)
  3224 |     |             mstore(0x40, p1)
  3225 |     |             mstore(0x60, 0x80)
  3226 |     |             mstore(0x80, p3)
  3227 |     |             writeString(0xa0, p2)
  3228 |     |         }
  3229 |     |         _sendLogPayload(0x1c, 0xc4);
  3230 |     |         assembly {
  3231 |     |             mstore(0x00, m0)
  3232 |     |             mstore(0x20, m1)
  3233 |     |             mstore(0x40, m2)
  3234 |     |             mstore(0x60, m3)
  3235 |     |             mstore(0x80, m4)
  3236 |     |             mstore(0xa0, m5)
  3237 |     |             mstore(0xc0, m6)
  3238 |     |         }
  3239 |     |     }
  3240 |     | 
  3241 |     |     function log(address p0, address p1, bytes32 p2, bool p3) internal pure {
  3242 |     |         bytes32 m0;
  3243 |     |         bytes32 m1;
  3244 |     |         bytes32 m2;
  3245 |     |         bytes32 m3;
  3246 |     |         bytes32 m4;
  3247 |     |         bytes32 m5;
  3248 |     |         bytes32 m6;
  3249 |     |         assembly {
  3250 |     |             function writeString(pos, w) {
  3251 |     |                 let length := 0
  3252 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3253 |     |                 mstore(pos, length)
  3254 |     |                 let shift := sub(256, shl(3, length))
  3255 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3256 |     |             }
  3257 |     |             m0 := mload(0x00)
  3258 |     |             m1 := mload(0x20)
  3259 |     |             m2 := mload(0x40)
  3260 |     |             m3 := mload(0x60)
  3261 |     |             m4 := mload(0x80)
  3262 |     |             m5 := mload(0xa0)
  3263 |     |             m6 := mload(0xc0)
  3264 |     |             // Selector of `log(address,address,string,bool)`.
  3265 |     |             mstore(0x00, 0x6f1a594e)
  3266 |     |             mstore(0x20, p0)
  3267 |     |             mstore(0x40, p1)
  3268 |     |             mstore(0x60, 0x80)
  3269 |     |             mstore(0x80, p3)
  3270 |     |             writeString(0xa0, p2)
  3271 |     |         }
  3272 |     |         _sendLogPayload(0x1c, 0xc4);
  3273 |     |         assembly {
  3274 |     |             mstore(0x00, m0)
  3275 |     |             mstore(0x20, m1)
  3276 |     |             mstore(0x40, m2)
  3277 |     |             mstore(0x60, m3)
  3278 |     |             mstore(0x80, m4)
  3279 |     |             mstore(0xa0, m5)
  3280 |     |             mstore(0xc0, m6)
  3281 |     |         }
  3282 |     |     }
  3283 |     | 
  3284 |     |     function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {
  3285 |     |         bytes32 m0;
  3286 |     |         bytes32 m1;
  3287 |     |         bytes32 m2;
  3288 |     |         bytes32 m3;
  3289 |     |         bytes32 m4;
  3290 |     |         bytes32 m5;
  3291 |     |         bytes32 m6;
  3292 |     |         assembly {
  3293 |     |             function writeString(pos, w) {
  3294 |     |                 let length := 0
  3295 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3296 |     |                 mstore(pos, length)
  3297 |     |                 let shift := sub(256, shl(3, length))
  3298 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3299 |     |             }
  3300 |     |             m0 := mload(0x00)
  3301 |     |             m1 := mload(0x20)
  3302 |     |             m2 := mload(0x40)
  3303 |     |             m3 := mload(0x60)
  3304 |     |             m4 := mload(0x80)
  3305 |     |             m5 := mload(0xa0)
  3306 |     |             m6 := mload(0xc0)
  3307 |     |             // Selector of `log(address,address,string,uint256)`.
  3308 |     |             mstore(0x00, 0xef1cefe7)
  3309 |     |             mstore(0x20, p0)
  3310 |     |             mstore(0x40, p1)
  3311 |     |             mstore(0x60, 0x80)
  3312 |     |             mstore(0x80, p3)
  3313 |     |             writeString(0xa0, p2)
  3314 |     |         }
  3315 |     |         _sendLogPayload(0x1c, 0xc4);
  3316 |     |         assembly {
  3317 |     |             mstore(0x00, m0)
  3318 |     |             mstore(0x20, m1)
  3319 |     |             mstore(0x40, m2)
  3320 |     |             mstore(0x60, m3)
  3321 |     |             mstore(0x80, m4)
  3322 |     |             mstore(0xa0, m5)
  3323 |     |             mstore(0xc0, m6)
  3324 |     |         }
  3325 |     |     }
  3326 |     | 
  3327 |     |     function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  3328 |     |         bytes32 m0;
  3329 |     |         bytes32 m1;
  3330 |     |         bytes32 m2;
  3331 |     |         bytes32 m3;
  3332 |     |         bytes32 m4;
  3333 |     |         bytes32 m5;
  3334 |     |         bytes32 m6;
  3335 |     |         bytes32 m7;
  3336 |     |         bytes32 m8;
  3337 |     |         assembly {
  3338 |     |             function writeString(pos, w) {
  3339 |     |                 let length := 0
  3340 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3341 |     |                 mstore(pos, length)
  3342 |     |                 let shift := sub(256, shl(3, length))
  3343 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3344 |     |             }
  3345 |     |             m0 := mload(0x00)
  3346 |     |             m1 := mload(0x20)
  3347 |     |             m2 := mload(0x40)
  3348 |     |             m3 := mload(0x60)
  3349 |     |             m4 := mload(0x80)
  3350 |     |             m5 := mload(0xa0)
  3351 |     |             m6 := mload(0xc0)
  3352 |     |             m7 := mload(0xe0)
  3353 |     |             m8 := mload(0x100)
  3354 |     |             // Selector of `log(address,address,string,string)`.
  3355 |     |             mstore(0x00, 0x21bdaf25)
  3356 |     |             mstore(0x20, p0)
  3357 |     |             mstore(0x40, p1)
  3358 |     |             mstore(0x60, 0x80)
  3359 |     |             mstore(0x80, 0xc0)
  3360 |     |             writeString(0xa0, p2)
  3361 |     |             writeString(0xe0, p3)
  3362 |     |         }
  3363 |     |         _sendLogPayload(0x1c, 0x104);
  3364 |     |         assembly {
  3365 |     |             mstore(0x00, m0)
  3366 |     |             mstore(0x20, m1)
  3367 |     |             mstore(0x40, m2)
  3368 |     |             mstore(0x60, m3)
  3369 |     |             mstore(0x80, m4)
  3370 |     |             mstore(0xa0, m5)
  3371 |     |             mstore(0xc0, m6)
  3372 |     |             mstore(0xe0, m7)
  3373 |     |             mstore(0x100, m8)
  3374 |     |         }
  3375 |     |     }
  3376 |     | 
  3377 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
  3378 |     |         bytes32 m0;
  3379 |     |         bytes32 m1;
  3380 |     |         bytes32 m2;
  3381 |     |         bytes32 m3;
  3382 |     |         bytes32 m4;
  3383 |     |         assembly {
  3384 |     |             m0 := mload(0x00)
  3385 |     |             m1 := mload(0x20)
  3386 |     |             m2 := mload(0x40)
  3387 |     |             m3 := mload(0x60)
  3388 |     |             m4 := mload(0x80)
  3389 |     |             // Selector of `log(address,bool,address,address)`.
  3390 |     |             mstore(0x00, 0x660375dd)
  3391 |     |             mstore(0x20, p0)
  3392 |     |             mstore(0x40, p1)
  3393 |     |             mstore(0x60, p2)
  3394 |     |             mstore(0x80, p3)
  3395 |     |         }
  3396 |     |         _sendLogPayload(0x1c, 0x84);
  3397 |     |         assembly {
  3398 |     |             mstore(0x00, m0)
  3399 |     |             mstore(0x20, m1)
  3400 |     |             mstore(0x40, m2)
  3401 |     |             mstore(0x60, m3)
  3402 |     |             mstore(0x80, m4)
  3403 |     |         }
  3404 |     |     }
  3405 |     | 
  3406 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
  3407 |     |         bytes32 m0;
  3408 |     |         bytes32 m1;
  3409 |     |         bytes32 m2;
  3410 |     |         bytes32 m3;
  3411 |     |         bytes32 m4;
  3412 |     |         assembly {
  3413 |     |             m0 := mload(0x00)
  3414 |     |             m1 := mload(0x20)
  3415 |     |             m2 := mload(0x40)
  3416 |     |             m3 := mload(0x60)
  3417 |     |             m4 := mload(0x80)
  3418 |     |             // Selector of `log(address,bool,address,bool)`.
  3419 |     |             mstore(0x00, 0xa6f50b0f)
  3420 |     |             mstore(0x20, p0)
  3421 |     |             mstore(0x40, p1)
  3422 |     |             mstore(0x60, p2)
  3423 |     |             mstore(0x80, p3)
  3424 |     |         }
  3425 |     |         _sendLogPayload(0x1c, 0x84);
  3426 |     |         assembly {
  3427 |     |             mstore(0x00, m0)
  3428 |     |             mstore(0x20, m1)
  3429 |     |             mstore(0x40, m2)
  3430 |     |             mstore(0x60, m3)
  3431 |     |             mstore(0x80, m4)
  3432 |     |         }
  3433 |     |     }
  3434 |     | 
  3435 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
  3436 |     |         bytes32 m0;
  3437 |     |         bytes32 m1;
  3438 |     |         bytes32 m2;
  3439 |     |         bytes32 m3;
  3440 |     |         bytes32 m4;
  3441 |     |         assembly {
  3442 |     |             m0 := mload(0x00)
  3443 |     |             m1 := mload(0x20)
  3444 |     |             m2 := mload(0x40)
  3445 |     |             m3 := mload(0x60)
  3446 |     |             m4 := mload(0x80)
  3447 |     |             // Selector of `log(address,bool,address,uint256)`.
  3448 |     |             mstore(0x00, 0xa75c59de)
  3449 |     |             mstore(0x20, p0)
  3450 |     |             mstore(0x40, p1)
  3451 |     |             mstore(0x60, p2)
  3452 |     |             mstore(0x80, p3)
  3453 |     |         }
  3454 |     |         _sendLogPayload(0x1c, 0x84);
  3455 |     |         assembly {
  3456 |     |             mstore(0x00, m0)
  3457 |     |             mstore(0x20, m1)
  3458 |     |             mstore(0x40, m2)
  3459 |     |             mstore(0x60, m3)
  3460 |     |             mstore(0x80, m4)
  3461 |     |         }
  3462 |     |     }
  3463 |     | 
  3464 |     |     function log(address p0, bool p1, address p2, bytes32 p3) internal pure {
  3465 |     |         bytes32 m0;
  3466 |     |         bytes32 m1;
  3467 |     |         bytes32 m2;
  3468 |     |         bytes32 m3;
  3469 |     |         bytes32 m4;
  3470 |     |         bytes32 m5;
  3471 |     |         bytes32 m6;
  3472 |     |         assembly {
  3473 |     |             function writeString(pos, w) {
  3474 |     |                 let length := 0
  3475 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3476 |     |                 mstore(pos, length)
  3477 |     |                 let shift := sub(256, shl(3, length))
  3478 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3479 |     |             }
  3480 |     |             m0 := mload(0x00)
  3481 |     |             m1 := mload(0x20)
  3482 |     |             m2 := mload(0x40)
  3483 |     |             m3 := mload(0x60)
  3484 |     |             m4 := mload(0x80)
  3485 |     |             m5 := mload(0xa0)
  3486 |     |             m6 := mload(0xc0)
  3487 |     |             // Selector of `log(address,bool,address,string)`.
  3488 |     |             mstore(0x00, 0x2dd778e6)
  3489 |     |             mstore(0x20, p0)
  3490 |     |             mstore(0x40, p1)
  3491 |     |             mstore(0x60, p2)
  3492 |     |             mstore(0x80, 0x80)
  3493 |     |             writeString(0xa0, p3)
  3494 |     |         }
  3495 |     |         _sendLogPayload(0x1c, 0xc4);
  3496 |     |         assembly {
  3497 |     |             mstore(0x00, m0)
  3498 |     |             mstore(0x20, m1)
  3499 |     |             mstore(0x40, m2)
  3500 |     |             mstore(0x60, m3)
  3501 |     |             mstore(0x80, m4)
  3502 |     |             mstore(0xa0, m5)
  3503 |     |             mstore(0xc0, m6)
  3504 |     |         }
  3505 |     |     }
  3506 |     | 
  3507 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
  3508 |     |         bytes32 m0;
  3509 |     |         bytes32 m1;
  3510 |     |         bytes32 m2;
  3511 |     |         bytes32 m3;
  3512 |     |         bytes32 m4;
  3513 |     |         assembly {
  3514 |     |             m0 := mload(0x00)
  3515 |     |             m1 := mload(0x20)
  3516 |     |             m2 := mload(0x40)
  3517 |     |             m3 := mload(0x60)
  3518 |     |             m4 := mload(0x80)
  3519 |     |             // Selector of `log(address,bool,bool,address)`.
  3520 |     |             mstore(0x00, 0xcf394485)
  3521 |     |             mstore(0x20, p0)
  3522 |     |             mstore(0x40, p1)
  3523 |     |             mstore(0x60, p2)
  3524 |     |             mstore(0x80, p3)
  3525 |     |         }
  3526 |     |         _sendLogPayload(0x1c, 0x84);
  3527 |     |         assembly {
  3528 |     |             mstore(0x00, m0)
  3529 |     |             mstore(0x20, m1)
  3530 |     |             mstore(0x40, m2)
  3531 |     |             mstore(0x60, m3)
  3532 |     |             mstore(0x80, m4)
  3533 |     |         }
  3534 |     |     }
  3535 |     | 
  3536 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
  3537 |     |         bytes32 m0;
  3538 |     |         bytes32 m1;
  3539 |     |         bytes32 m2;
  3540 |     |         bytes32 m3;
  3541 |     |         bytes32 m4;
  3542 |     |         assembly {
  3543 |     |             m0 := mload(0x00)
  3544 |     |             m1 := mload(0x20)
  3545 |     |             m2 := mload(0x40)
  3546 |     |             m3 := mload(0x60)
  3547 |     |             m4 := mload(0x80)
  3548 |     |             // Selector of `log(address,bool,bool,bool)`.
  3549 |     |             mstore(0x00, 0xcac43479)
  3550 |     |             mstore(0x20, p0)
  3551 |     |             mstore(0x40, p1)
  3552 |     |             mstore(0x60, p2)
  3553 |     |             mstore(0x80, p3)
  3554 |     |         }
  3555 |     |         _sendLogPayload(0x1c, 0x84);
  3556 |     |         assembly {
  3557 |     |             mstore(0x00, m0)
  3558 |     |             mstore(0x20, m1)
  3559 |     |             mstore(0x40, m2)
  3560 |     |             mstore(0x60, m3)
  3561 |     |             mstore(0x80, m4)
  3562 |     |         }
  3563 |     |     }
  3564 |     | 
  3565 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
  3566 |     |         bytes32 m0;
  3567 |     |         bytes32 m1;
  3568 |     |         bytes32 m2;
  3569 |     |         bytes32 m3;
  3570 |     |         bytes32 m4;
  3571 |     |         assembly {
  3572 |     |             m0 := mload(0x00)
  3573 |     |             m1 := mload(0x20)
  3574 |     |             m2 := mload(0x40)
  3575 |     |             m3 := mload(0x60)
  3576 |     |             m4 := mload(0x80)
  3577 |     |             // Selector of `log(address,bool,bool,uint256)`.
  3578 |     |             mstore(0x00, 0x8c4e5de6)
  3579 |     |             mstore(0x20, p0)
  3580 |     |             mstore(0x40, p1)
  3581 |     |             mstore(0x60, p2)
  3582 |     |             mstore(0x80, p3)
  3583 |     |         }
  3584 |     |         _sendLogPayload(0x1c, 0x84);
  3585 |     |         assembly {
  3586 |     |             mstore(0x00, m0)
  3587 |     |             mstore(0x20, m1)
  3588 |     |             mstore(0x40, m2)
  3589 |     |             mstore(0x60, m3)
  3590 |     |             mstore(0x80, m4)
  3591 |     |         }
  3592 |     |     }
  3593 |     | 
  3594 |     |     function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {
  3595 |     |         bytes32 m0;
  3596 |     |         bytes32 m1;
  3597 |     |         bytes32 m2;
  3598 |     |         bytes32 m3;
  3599 |     |         bytes32 m4;
  3600 |     |         bytes32 m5;
  3601 |     |         bytes32 m6;
  3602 |     |         assembly {
  3603 |     |             function writeString(pos, w) {
  3604 |     |                 let length := 0
  3605 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3606 |     |                 mstore(pos, length)
  3607 |     |                 let shift := sub(256, shl(3, length))
  3608 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3609 |     |             }
  3610 |     |             m0 := mload(0x00)
  3611 |     |             m1 := mload(0x20)
  3612 |     |             m2 := mload(0x40)
  3613 |     |             m3 := mload(0x60)
  3614 |     |             m4 := mload(0x80)
  3615 |     |             m5 := mload(0xa0)
  3616 |     |             m6 := mload(0xc0)
  3617 |     |             // Selector of `log(address,bool,bool,string)`.
  3618 |     |             mstore(0x00, 0xdfc4a2e8)
  3619 |     |             mstore(0x20, p0)
  3620 |     |             mstore(0x40, p1)
  3621 |     |             mstore(0x60, p2)
  3622 |     |             mstore(0x80, 0x80)
  3623 |     |             writeString(0xa0, p3)
  3624 |     |         }
  3625 |     |         _sendLogPayload(0x1c, 0xc4);
  3626 |     |         assembly {
  3627 |     |             mstore(0x00, m0)
  3628 |     |             mstore(0x20, m1)
  3629 |     |             mstore(0x40, m2)
  3630 |     |             mstore(0x60, m3)
  3631 |     |             mstore(0x80, m4)
  3632 |     |             mstore(0xa0, m5)
  3633 |     |             mstore(0xc0, m6)
  3634 |     |         }
  3635 |     |     }
  3636 |     | 
  3637 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
  3638 |     |         bytes32 m0;
  3639 |     |         bytes32 m1;
  3640 |     |         bytes32 m2;
  3641 |     |         bytes32 m3;
  3642 |     |         bytes32 m4;
  3643 |     |         assembly {
  3644 |     |             m0 := mload(0x00)
  3645 |     |             m1 := mload(0x20)
  3646 |     |             m2 := mload(0x40)
  3647 |     |             m3 := mload(0x60)
  3648 |     |             m4 := mload(0x80)
  3649 |     |             // Selector of `log(address,bool,uint256,address)`.
  3650 |     |             mstore(0x00, 0xccf790a1)
  3651 |     |             mstore(0x20, p0)
  3652 |     |             mstore(0x40, p1)
  3653 |     |             mstore(0x60, p2)
  3654 |     |             mstore(0x80, p3)
  3655 |     |         }
  3656 |     |         _sendLogPayload(0x1c, 0x84);
  3657 |     |         assembly {
  3658 |     |             mstore(0x00, m0)
  3659 |     |             mstore(0x20, m1)
  3660 |     |             mstore(0x40, m2)
  3661 |     |             mstore(0x60, m3)
  3662 |     |             mstore(0x80, m4)
  3663 |     |         }
  3664 |     |     }
  3665 |     | 
  3666 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
  3667 |     |         bytes32 m0;
  3668 |     |         bytes32 m1;
  3669 |     |         bytes32 m2;
  3670 |     |         bytes32 m3;
  3671 |     |         bytes32 m4;
  3672 |     |         assembly {
  3673 |     |             m0 := mload(0x00)
  3674 |     |             m1 := mload(0x20)
  3675 |     |             m2 := mload(0x40)
  3676 |     |             m3 := mload(0x60)
  3677 |     |             m4 := mload(0x80)
  3678 |     |             // Selector of `log(address,bool,uint256,bool)`.
  3679 |     |             mstore(0x00, 0xc4643e20)
  3680 |     |             mstore(0x20, p0)
  3681 |     |             mstore(0x40, p1)
  3682 |     |             mstore(0x60, p2)
  3683 |     |             mstore(0x80, p3)
  3684 |     |         }
  3685 |     |         _sendLogPayload(0x1c, 0x84);
  3686 |     |         assembly {
  3687 |     |             mstore(0x00, m0)
  3688 |     |             mstore(0x20, m1)
  3689 |     |             mstore(0x40, m2)
  3690 |     |             mstore(0x60, m3)
  3691 |     |             mstore(0x80, m4)
  3692 |     |         }
  3693 |     |     }
  3694 |     | 
  3695 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
  3696 |     |         bytes32 m0;
  3697 |     |         bytes32 m1;
  3698 |     |         bytes32 m2;
  3699 |     |         bytes32 m3;
  3700 |     |         bytes32 m4;
  3701 |     |         assembly {
  3702 |     |             m0 := mload(0x00)
  3703 |     |             m1 := mload(0x20)
  3704 |     |             m2 := mload(0x40)
  3705 |     |             m3 := mload(0x60)
  3706 |     |             m4 := mload(0x80)
  3707 |     |             // Selector of `log(address,bool,uint256,uint256)`.
  3708 |     |             mstore(0x00, 0x386ff5f4)
  3709 |     |             mstore(0x20, p0)
  3710 |     |             mstore(0x40, p1)
  3711 |     |             mstore(0x60, p2)
  3712 |     |             mstore(0x80, p3)
  3713 |     |         }
  3714 |     |         _sendLogPayload(0x1c, 0x84);
  3715 |     |         assembly {
  3716 |     |             mstore(0x00, m0)
  3717 |     |             mstore(0x20, m1)
  3718 |     |             mstore(0x40, m2)
  3719 |     |             mstore(0x60, m3)
  3720 |     |             mstore(0x80, m4)
  3721 |     |         }
  3722 |     |     }
  3723 |     | 
  3724 |     |     function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  3725 |     |         bytes32 m0;
  3726 |     |         bytes32 m1;
  3727 |     |         bytes32 m2;
  3728 |     |         bytes32 m3;
  3729 |     |         bytes32 m4;
  3730 |     |         bytes32 m5;
  3731 |     |         bytes32 m6;
  3732 |     |         assembly {
  3733 |     |             function writeString(pos, w) {
  3734 |     |                 let length := 0
  3735 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3736 |     |                 mstore(pos, length)
  3737 |     |                 let shift := sub(256, shl(3, length))
  3738 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3739 |     |             }
  3740 |     |             m0 := mload(0x00)
  3741 |     |             m1 := mload(0x20)
  3742 |     |             m2 := mload(0x40)
  3743 |     |             m3 := mload(0x60)
  3744 |     |             m4 := mload(0x80)
  3745 |     |             m5 := mload(0xa0)
  3746 |     |             m6 := mload(0xc0)
  3747 |     |             // Selector of `log(address,bool,uint256,string)`.
  3748 |     |             mstore(0x00, 0x0aa6cfad)
  3749 |     |             mstore(0x20, p0)
  3750 |     |             mstore(0x40, p1)
  3751 |     |             mstore(0x60, p2)
  3752 |     |             mstore(0x80, 0x80)
  3753 |     |             writeString(0xa0, p3)
  3754 |     |         }
  3755 |     |         _sendLogPayload(0x1c, 0xc4);
  3756 |     |         assembly {
  3757 |     |             mstore(0x00, m0)
  3758 |     |             mstore(0x20, m1)
  3759 |     |             mstore(0x40, m2)
  3760 |     |             mstore(0x60, m3)
  3761 |     |             mstore(0x80, m4)
  3762 |     |             mstore(0xa0, m5)
  3763 |     |             mstore(0xc0, m6)
  3764 |     |         }
  3765 |     |     }
  3766 |     | 
  3767 |     |     function log(address p0, bool p1, bytes32 p2, address p3) internal pure {
  3768 |     |         bytes32 m0;
  3769 |     |         bytes32 m1;
  3770 |     |         bytes32 m2;
  3771 |     |         bytes32 m3;
  3772 |     |         bytes32 m4;
  3773 |     |         bytes32 m5;
  3774 |     |         bytes32 m6;
  3775 |     |         assembly {
  3776 |     |             function writeString(pos, w) {
  3777 |     |                 let length := 0
  3778 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3779 |     |                 mstore(pos, length)
  3780 |     |                 let shift := sub(256, shl(3, length))
  3781 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3782 |     |             }
  3783 |     |             m0 := mload(0x00)
  3784 |     |             m1 := mload(0x20)
  3785 |     |             m2 := mload(0x40)
  3786 |     |             m3 := mload(0x60)
  3787 |     |             m4 := mload(0x80)
  3788 |     |             m5 := mload(0xa0)
  3789 |     |             m6 := mload(0xc0)
  3790 |     |             // Selector of `log(address,bool,string,address)`.
  3791 |     |             mstore(0x00, 0x19fd4956)
  3792 |     |             mstore(0x20, p0)
  3793 |     |             mstore(0x40, p1)
  3794 |     |             mstore(0x60, 0x80)
  3795 |     |             mstore(0x80, p3)
  3796 |     |             writeString(0xa0, p2)
  3797 |     |         }
  3798 |     |         _sendLogPayload(0x1c, 0xc4);
  3799 |     |         assembly {
  3800 |     |             mstore(0x00, m0)
  3801 |     |             mstore(0x20, m1)
  3802 |     |             mstore(0x40, m2)
  3803 |     |             mstore(0x60, m3)
  3804 |     |             mstore(0x80, m4)
  3805 |     |             mstore(0xa0, m5)
  3806 |     |             mstore(0xc0, m6)
  3807 |     |         }
  3808 |     |     }
  3809 |     | 
  3810 |     |     function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {
  3811 |     |         bytes32 m0;
  3812 |     |         bytes32 m1;
  3813 |     |         bytes32 m2;
  3814 |     |         bytes32 m3;
  3815 |     |         bytes32 m4;
  3816 |     |         bytes32 m5;
  3817 |     |         bytes32 m6;
  3818 |     |         assembly {
  3819 |     |             function writeString(pos, w) {
  3820 |     |                 let length := 0
  3821 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3822 |     |                 mstore(pos, length)
  3823 |     |                 let shift := sub(256, shl(3, length))
  3824 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3825 |     |             }
  3826 |     |             m0 := mload(0x00)
  3827 |     |             m1 := mload(0x20)
  3828 |     |             m2 := mload(0x40)
  3829 |     |             m3 := mload(0x60)
  3830 |     |             m4 := mload(0x80)
  3831 |     |             m5 := mload(0xa0)
  3832 |     |             m6 := mload(0xc0)
  3833 |     |             // Selector of `log(address,bool,string,bool)`.
  3834 |     |             mstore(0x00, 0x50ad461d)
  3835 |     |             mstore(0x20, p0)
  3836 |     |             mstore(0x40, p1)
  3837 |     |             mstore(0x60, 0x80)
  3838 |     |             mstore(0x80, p3)
  3839 |     |             writeString(0xa0, p2)
  3840 |     |         }
  3841 |     |         _sendLogPayload(0x1c, 0xc4);
  3842 |     |         assembly {
  3843 |     |             mstore(0x00, m0)
  3844 |     |             mstore(0x20, m1)
  3845 |     |             mstore(0x40, m2)
  3846 |     |             mstore(0x60, m3)
  3847 |     |             mstore(0x80, m4)
  3848 |     |             mstore(0xa0, m5)
  3849 |     |             mstore(0xc0, m6)
  3850 |     |         }
  3851 |     |     }
  3852 |     | 
  3853 |     |     function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  3854 |     |         bytes32 m0;
  3855 |     |         bytes32 m1;
  3856 |     |         bytes32 m2;
  3857 |     |         bytes32 m3;
  3858 |     |         bytes32 m4;
  3859 |     |         bytes32 m5;
  3860 |     |         bytes32 m6;
  3861 |     |         assembly {
  3862 |     |             function writeString(pos, w) {
  3863 |     |                 let length := 0
  3864 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3865 |     |                 mstore(pos, length)
  3866 |     |                 let shift := sub(256, shl(3, length))
  3867 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3868 |     |             }
  3869 |     |             m0 := mload(0x00)
  3870 |     |             m1 := mload(0x20)
  3871 |     |             m2 := mload(0x40)
  3872 |     |             m3 := mload(0x60)
  3873 |     |             m4 := mload(0x80)
  3874 |     |             m5 := mload(0xa0)
  3875 |     |             m6 := mload(0xc0)
  3876 |     |             // Selector of `log(address,bool,string,uint256)`.
  3877 |     |             mstore(0x00, 0x80e6a20b)
  3878 |     |             mstore(0x20, p0)
  3879 |     |             mstore(0x40, p1)
  3880 |     |             mstore(0x60, 0x80)
  3881 |     |             mstore(0x80, p3)
  3882 |     |             writeString(0xa0, p2)
  3883 |     |         }
  3884 |     |         _sendLogPayload(0x1c, 0xc4);
  3885 |     |         assembly {
  3886 |     |             mstore(0x00, m0)
  3887 |     |             mstore(0x20, m1)
  3888 |     |             mstore(0x40, m2)
  3889 |     |             mstore(0x60, m3)
  3890 |     |             mstore(0x80, m4)
  3891 |     |             mstore(0xa0, m5)
  3892 |     |             mstore(0xc0, m6)
  3893 |     |         }
  3894 |     |     }
  3895 |     | 
  3896 |     |     function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  3897 |     |         bytes32 m0;
  3898 |     |         bytes32 m1;
  3899 |     |         bytes32 m2;
  3900 |     |         bytes32 m3;
  3901 |     |         bytes32 m4;
  3902 |     |         bytes32 m5;
  3903 |     |         bytes32 m6;
  3904 |     |         bytes32 m7;
  3905 |     |         bytes32 m8;
  3906 |     |         assembly {
  3907 |     |             function writeString(pos, w) {
  3908 |     |                 let length := 0
  3909 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3910 |     |                 mstore(pos, length)
  3911 |     |                 let shift := sub(256, shl(3, length))
  3912 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3913 |     |             }
  3914 |     |             m0 := mload(0x00)
  3915 |     |             m1 := mload(0x20)
  3916 |     |             m2 := mload(0x40)
  3917 |     |             m3 := mload(0x60)
  3918 |     |             m4 := mload(0x80)
  3919 |     |             m5 := mload(0xa0)
  3920 |     |             m6 := mload(0xc0)
  3921 |     |             m7 := mload(0xe0)
  3922 |     |             m8 := mload(0x100)
  3923 |     |             // Selector of `log(address,bool,string,string)`.
  3924 |     |             mstore(0x00, 0x475c5c33)
  3925 |     |             mstore(0x20, p0)
  3926 |     |             mstore(0x40, p1)
  3927 |     |             mstore(0x60, 0x80)
  3928 |     |             mstore(0x80, 0xc0)
  3929 |     |             writeString(0xa0, p2)
  3930 |     |             writeString(0xe0, p3)
  3931 |     |         }
  3932 |     |         _sendLogPayload(0x1c, 0x104);
  3933 |     |         assembly {
  3934 |     |             mstore(0x00, m0)
  3935 |     |             mstore(0x20, m1)
  3936 |     |             mstore(0x40, m2)
  3937 |     |             mstore(0x60, m3)
  3938 |     |             mstore(0x80, m4)
  3939 |     |             mstore(0xa0, m5)
  3940 |     |             mstore(0xc0, m6)
  3941 |     |             mstore(0xe0, m7)
  3942 |     |             mstore(0x100, m8)
  3943 |     |         }
  3944 |     |     }
  3945 |     | 
  3946 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
  3947 |     |         bytes32 m0;
  3948 |     |         bytes32 m1;
  3949 |     |         bytes32 m2;
  3950 |     |         bytes32 m3;
  3951 |     |         bytes32 m4;
  3952 |     |         assembly {
  3953 |     |             m0 := mload(0x00)
  3954 |     |             m1 := mload(0x20)
  3955 |     |             m2 := mload(0x40)
  3956 |     |             m3 := mload(0x60)
  3957 |     |             m4 := mload(0x80)
  3958 |     |             // Selector of `log(address,uint256,address,address)`.
  3959 |     |             mstore(0x00, 0x478d1c62)
  3960 |     |             mstore(0x20, p0)
  3961 |     |             mstore(0x40, p1)
  3962 |     |             mstore(0x60, p2)
  3963 |     |             mstore(0x80, p3)
  3964 |     |         }
  3965 |     |         _sendLogPayload(0x1c, 0x84);
  3966 |     |         assembly {
  3967 |     |             mstore(0x00, m0)
  3968 |     |             mstore(0x20, m1)
  3969 |     |             mstore(0x40, m2)
  3970 |     |             mstore(0x60, m3)
  3971 |     |             mstore(0x80, m4)
  3972 |     |         }
  3973 |     |     }
  3974 |     | 
  3975 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
  3976 |     |         bytes32 m0;
  3977 |     |         bytes32 m1;
  3978 |     |         bytes32 m2;
  3979 |     |         bytes32 m3;
  3980 |     |         bytes32 m4;
  3981 |     |         assembly {
  3982 |     |             m0 := mload(0x00)
  3983 |     |             m1 := mload(0x20)
  3984 |     |             m2 := mload(0x40)
  3985 |     |             m3 := mload(0x60)
  3986 |     |             m4 := mload(0x80)
  3987 |     |             // Selector of `log(address,uint256,address,bool)`.
  3988 |     |             mstore(0x00, 0xa1bcc9b3)
  3989 |     |             mstore(0x20, p0)
  3990 |     |             mstore(0x40, p1)
  3991 |     |             mstore(0x60, p2)
  3992 |     |             mstore(0x80, p3)
  3993 |     |         }
  3994 |     |         _sendLogPayload(0x1c, 0x84);
  3995 |     |         assembly {
  3996 |     |             mstore(0x00, m0)
  3997 |     |             mstore(0x20, m1)
  3998 |     |             mstore(0x40, m2)
  3999 |     |             mstore(0x60, m3)
  4000 |     |             mstore(0x80, m4)
  4001 |     |         }
  4002 |     |     }
  4003 |     | 
  4004 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
  4005 |     |         bytes32 m0;
  4006 |     |         bytes32 m1;
  4007 |     |         bytes32 m2;
  4008 |     |         bytes32 m3;
  4009 |     |         bytes32 m4;
  4010 |     |         assembly {
  4011 |     |             m0 := mload(0x00)
  4012 |     |             m1 := mload(0x20)
  4013 |     |             m2 := mload(0x40)
  4014 |     |             m3 := mload(0x60)
  4015 |     |             m4 := mload(0x80)
  4016 |     |             // Selector of `log(address,uint256,address,uint256)`.
  4017 |     |             mstore(0x00, 0x100f650e)
  4018 |     |             mstore(0x20, p0)
  4019 |     |             mstore(0x40, p1)
  4020 |     |             mstore(0x60, p2)
  4021 |     |             mstore(0x80, p3)
  4022 |     |         }
  4023 |     |         _sendLogPayload(0x1c, 0x84);
  4024 |     |         assembly {
  4025 |     |             mstore(0x00, m0)
  4026 |     |             mstore(0x20, m1)
  4027 |     |             mstore(0x40, m2)
  4028 |     |             mstore(0x60, m3)
  4029 |     |             mstore(0x80, m4)
  4030 |     |         }
  4031 |     |     }
  4032 |     | 
  4033 |     |     function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {
  4034 |     |         bytes32 m0;
  4035 |     |         bytes32 m1;
  4036 |     |         bytes32 m2;
  4037 |     |         bytes32 m3;
  4038 |     |         bytes32 m4;
  4039 |     |         bytes32 m5;
  4040 |     |         bytes32 m6;
  4041 |     |         assembly {
  4042 |     |             function writeString(pos, w) {
  4043 |     |                 let length := 0
  4044 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4045 |     |                 mstore(pos, length)
  4046 |     |                 let shift := sub(256, shl(3, length))
  4047 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4048 |     |             }
  4049 |     |             m0 := mload(0x00)
  4050 |     |             m1 := mload(0x20)
  4051 |     |             m2 := mload(0x40)
  4052 |     |             m3 := mload(0x60)
  4053 |     |             m4 := mload(0x80)
  4054 |     |             m5 := mload(0xa0)
  4055 |     |             m6 := mload(0xc0)
  4056 |     |             // Selector of `log(address,uint256,address,string)`.
  4057 |     |             mstore(0x00, 0x1da986ea)
  4058 |     |             mstore(0x20, p0)
  4059 |     |             mstore(0x40, p1)
  4060 |     |             mstore(0x60, p2)
  4061 |     |             mstore(0x80, 0x80)
  4062 |     |             writeString(0xa0, p3)
  4063 |     |         }
  4064 |     |         _sendLogPayload(0x1c, 0xc4);
  4065 |     |         assembly {
  4066 |     |             mstore(0x00, m0)
  4067 |     |             mstore(0x20, m1)
  4068 |     |             mstore(0x40, m2)
  4069 |     |             mstore(0x60, m3)
  4070 |     |             mstore(0x80, m4)
  4071 |     |             mstore(0xa0, m5)
  4072 |     |             mstore(0xc0, m6)
  4073 |     |         }
  4074 |     |     }
  4075 |     | 
  4076 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
  4077 |     |         bytes32 m0;
  4078 |     |         bytes32 m1;
  4079 |     |         bytes32 m2;
  4080 |     |         bytes32 m3;
  4081 |     |         bytes32 m4;
  4082 |     |         assembly {
  4083 |     |             m0 := mload(0x00)
  4084 |     |             m1 := mload(0x20)
  4085 |     |             m2 := mload(0x40)
  4086 |     |             m3 := mload(0x60)
  4087 |     |             m4 := mload(0x80)
  4088 |     |             // Selector of `log(address,uint256,bool,address)`.
  4089 |     |             mstore(0x00, 0xa31bfdcc)
  4090 |     |             mstore(0x20, p0)
  4091 |     |             mstore(0x40, p1)
  4092 |     |             mstore(0x60, p2)
  4093 |     |             mstore(0x80, p3)
  4094 |     |         }
  4095 |     |         _sendLogPayload(0x1c, 0x84);
  4096 |     |         assembly {
  4097 |     |             mstore(0x00, m0)
  4098 |     |             mstore(0x20, m1)
  4099 |     |             mstore(0x40, m2)
  4100 |     |             mstore(0x60, m3)
  4101 |     |             mstore(0x80, m4)
  4102 |     |         }
  4103 |     |     }
  4104 |     | 
  4105 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
  4106 |     |         bytes32 m0;
  4107 |     |         bytes32 m1;
  4108 |     |         bytes32 m2;
  4109 |     |         bytes32 m3;
  4110 |     |         bytes32 m4;
  4111 |     |         assembly {
  4112 |     |             m0 := mload(0x00)
  4113 |     |             m1 := mload(0x20)
  4114 |     |             m2 := mload(0x40)
  4115 |     |             m3 := mload(0x60)
  4116 |     |             m4 := mload(0x80)
  4117 |     |             // Selector of `log(address,uint256,bool,bool)`.
  4118 |     |             mstore(0x00, 0x3bf5e537)
  4119 |     |             mstore(0x20, p0)
  4120 |     |             mstore(0x40, p1)
  4121 |     |             mstore(0x60, p2)
  4122 |     |             mstore(0x80, p3)
  4123 |     |         }
  4124 |     |         _sendLogPayload(0x1c, 0x84);
  4125 |     |         assembly {
  4126 |     |             mstore(0x00, m0)
  4127 |     |             mstore(0x20, m1)
  4128 |     |             mstore(0x40, m2)
  4129 |     |             mstore(0x60, m3)
  4130 |     |             mstore(0x80, m4)
  4131 |     |         }
  4132 |     |     }
  4133 |     | 
  4134 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
  4135 |     |         bytes32 m0;
  4136 |     |         bytes32 m1;
  4137 |     |         bytes32 m2;
  4138 |     |         bytes32 m3;
  4139 |     |         bytes32 m4;
  4140 |     |         assembly {
  4141 |     |             m0 := mload(0x00)
  4142 |     |             m1 := mload(0x20)
  4143 |     |             m2 := mload(0x40)
  4144 |     |             m3 := mload(0x60)
  4145 |     |             m4 := mload(0x80)
  4146 |     |             // Selector of `log(address,uint256,bool,uint256)`.
  4147 |     |             mstore(0x00, 0x22f6b999)
  4148 |     |             mstore(0x20, p0)
  4149 |     |             mstore(0x40, p1)
  4150 |     |             mstore(0x60, p2)
  4151 |     |             mstore(0x80, p3)
  4152 |     |         }
  4153 |     |         _sendLogPayload(0x1c, 0x84);
  4154 |     |         assembly {
  4155 |     |             mstore(0x00, m0)
  4156 |     |             mstore(0x20, m1)
  4157 |     |             mstore(0x40, m2)
  4158 |     |             mstore(0x60, m3)
  4159 |     |             mstore(0x80, m4)
  4160 |     |         }
  4161 |     |     }
  4162 |     | 
  4163 |     |     function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  4164 |     |         bytes32 m0;
  4165 |     |         bytes32 m1;
  4166 |     |         bytes32 m2;
  4167 |     |         bytes32 m3;
  4168 |     |         bytes32 m4;
  4169 |     |         bytes32 m5;
  4170 |     |         bytes32 m6;
  4171 |     |         assembly {
  4172 |     |             function writeString(pos, w) {
  4173 |     |                 let length := 0
  4174 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4175 |     |                 mstore(pos, length)
  4176 |     |                 let shift := sub(256, shl(3, length))
  4177 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4178 |     |             }
  4179 |     |             m0 := mload(0x00)
  4180 |     |             m1 := mload(0x20)
  4181 |     |             m2 := mload(0x40)
  4182 |     |             m3 := mload(0x60)
  4183 |     |             m4 := mload(0x80)
  4184 |     |             m5 := mload(0xa0)
  4185 |     |             m6 := mload(0xc0)
  4186 |     |             // Selector of `log(address,uint256,bool,string)`.
  4187 |     |             mstore(0x00, 0xc5ad85f9)
  4188 |     |             mstore(0x20, p0)
  4189 |     |             mstore(0x40, p1)
  4190 |     |             mstore(0x60, p2)
  4191 |     |             mstore(0x80, 0x80)
  4192 |     |             writeString(0xa0, p3)
  4193 |     |         }
  4194 |     |         _sendLogPayload(0x1c, 0xc4);
  4195 |     |         assembly {
  4196 |     |             mstore(0x00, m0)
  4197 |     |             mstore(0x20, m1)
  4198 |     |             mstore(0x40, m2)
  4199 |     |             mstore(0x60, m3)
  4200 |     |             mstore(0x80, m4)
  4201 |     |             mstore(0xa0, m5)
  4202 |     |             mstore(0xc0, m6)
  4203 |     |         }
  4204 |     |     }
  4205 |     | 
  4206 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
  4207 |     |         bytes32 m0;
  4208 |     |         bytes32 m1;
  4209 |     |         bytes32 m2;
  4210 |     |         bytes32 m3;
  4211 |     |         bytes32 m4;
  4212 |     |         assembly {
  4213 |     |             m0 := mload(0x00)
  4214 |     |             m1 := mload(0x20)
  4215 |     |             m2 := mload(0x40)
  4216 |     |             m3 := mload(0x60)
  4217 |     |             m4 := mload(0x80)
  4218 |     |             // Selector of `log(address,uint256,uint256,address)`.
  4219 |     |             mstore(0x00, 0x20e3984d)
  4220 |     |             mstore(0x20, p0)
  4221 |     |             mstore(0x40, p1)
  4222 |     |             mstore(0x60, p2)
  4223 |     |             mstore(0x80, p3)
  4224 |     |         }
  4225 |     |         _sendLogPayload(0x1c, 0x84);
  4226 |     |         assembly {
  4227 |     |             mstore(0x00, m0)
  4228 |     |             mstore(0x20, m1)
  4229 |     |             mstore(0x40, m2)
  4230 |     |             mstore(0x60, m3)
  4231 |     |             mstore(0x80, m4)
  4232 |     |         }
  4233 |     |     }
  4234 |     | 
  4235 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
  4236 |     |         bytes32 m0;
  4237 |     |         bytes32 m1;
  4238 |     |         bytes32 m2;
  4239 |     |         bytes32 m3;
  4240 |     |         bytes32 m4;
  4241 |     |         assembly {
  4242 |     |             m0 := mload(0x00)
  4243 |     |             m1 := mload(0x20)
  4244 |     |             m2 := mload(0x40)
  4245 |     |             m3 := mload(0x60)
  4246 |     |             m4 := mload(0x80)
  4247 |     |             // Selector of `log(address,uint256,uint256,bool)`.
  4248 |     |             mstore(0x00, 0x66f1bc67)
  4249 |     |             mstore(0x20, p0)
  4250 |     |             mstore(0x40, p1)
  4251 |     |             mstore(0x60, p2)
  4252 |     |             mstore(0x80, p3)
  4253 |     |         }
  4254 |     |         _sendLogPayload(0x1c, 0x84);
  4255 |     |         assembly {
  4256 |     |             mstore(0x00, m0)
  4257 |     |             mstore(0x20, m1)
  4258 |     |             mstore(0x40, m2)
  4259 |     |             mstore(0x60, m3)
  4260 |     |             mstore(0x80, m4)
  4261 |     |         }
  4262 |     |     }
  4263 |     | 
  4264 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  4265 |     |         bytes32 m0;
  4266 |     |         bytes32 m1;
  4267 |     |         bytes32 m2;
  4268 |     |         bytes32 m3;
  4269 |     |         bytes32 m4;
  4270 |     |         assembly {
  4271 |     |             m0 := mload(0x00)
  4272 |     |             m1 := mload(0x20)
  4273 |     |             m2 := mload(0x40)
  4274 |     |             m3 := mload(0x60)
  4275 |     |             m4 := mload(0x80)
  4276 |     |             // Selector of `log(address,uint256,uint256,uint256)`.
  4277 |     |             mstore(0x00, 0x34f0e636)
  4278 |     |             mstore(0x20, p0)
  4279 |     |             mstore(0x40, p1)
  4280 |     |             mstore(0x60, p2)
  4281 |     |             mstore(0x80, p3)
  4282 |     |         }
  4283 |     |         _sendLogPayload(0x1c, 0x84);
  4284 |     |         assembly {
  4285 |     |             mstore(0x00, m0)
  4286 |     |             mstore(0x20, m1)
  4287 |     |             mstore(0x40, m2)
  4288 |     |             mstore(0x60, m3)
  4289 |     |             mstore(0x80, m4)
  4290 |     |         }
  4291 |     |     }
  4292 |     | 
  4293 |     |     function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  4294 |     |         bytes32 m0;
  4295 |     |         bytes32 m1;
  4296 |     |         bytes32 m2;
  4297 |     |         bytes32 m3;
  4298 |     |         bytes32 m4;
  4299 |     |         bytes32 m5;
  4300 |     |         bytes32 m6;
  4301 |     |         assembly {
  4302 |     |             function writeString(pos, w) {
  4303 |     |                 let length := 0
  4304 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4305 |     |                 mstore(pos, length)
  4306 |     |                 let shift := sub(256, shl(3, length))
  4307 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4308 |     |             }
  4309 |     |             m0 := mload(0x00)
  4310 |     |             m1 := mload(0x20)
  4311 |     |             m2 := mload(0x40)
  4312 |     |             m3 := mload(0x60)
  4313 |     |             m4 := mload(0x80)
  4314 |     |             m5 := mload(0xa0)
  4315 |     |             m6 := mload(0xc0)
  4316 |     |             // Selector of `log(address,uint256,uint256,string)`.
  4317 |     |             mstore(0x00, 0x4a28c017)
  4318 |     |             mstore(0x20, p0)
  4319 |     |             mstore(0x40, p1)
  4320 |     |             mstore(0x60, p2)
  4321 |     |             mstore(0x80, 0x80)
  4322 |     |             writeString(0xa0, p3)
  4323 |     |         }
  4324 |     |         _sendLogPayload(0x1c, 0xc4);
  4325 |     |         assembly {
  4326 |     |             mstore(0x00, m0)
  4327 |     |             mstore(0x20, m1)
  4328 |     |             mstore(0x40, m2)
  4329 |     |             mstore(0x60, m3)
  4330 |     |             mstore(0x80, m4)
  4331 |     |             mstore(0xa0, m5)
  4332 |     |             mstore(0xc0, m6)
  4333 |     |         }
  4334 |     |     }
  4335 |     | 
  4336 |     |     function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {
  4337 |     |         bytes32 m0;
  4338 |     |         bytes32 m1;
  4339 |     |         bytes32 m2;
  4340 |     |         bytes32 m3;
  4341 |     |         bytes32 m4;
  4342 |     |         bytes32 m5;
  4343 |     |         bytes32 m6;
  4344 |     |         assembly {
  4345 |     |             function writeString(pos, w) {
  4346 |     |                 let length := 0
  4347 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4348 |     |                 mstore(pos, length)
  4349 |     |                 let shift := sub(256, shl(3, length))
  4350 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4351 |     |             }
  4352 |     |             m0 := mload(0x00)
  4353 |     |             m1 := mload(0x20)
  4354 |     |             m2 := mload(0x40)
  4355 |     |             m3 := mload(0x60)
  4356 |     |             m4 := mload(0x80)
  4357 |     |             m5 := mload(0xa0)
  4358 |     |             m6 := mload(0xc0)
  4359 |     |             // Selector of `log(address,uint256,string,address)`.
  4360 |     |             mstore(0x00, 0x5c430d47)
  4361 |     |             mstore(0x20, p0)
  4362 |     |             mstore(0x40, p1)
  4363 |     |             mstore(0x60, 0x80)
  4364 |     |             mstore(0x80, p3)
  4365 |     |             writeString(0xa0, p2)
  4366 |     |         }
  4367 |     |         _sendLogPayload(0x1c, 0xc4);
  4368 |     |         assembly {
  4369 |     |             mstore(0x00, m0)
  4370 |     |             mstore(0x20, m1)
  4371 |     |             mstore(0x40, m2)
  4372 |     |             mstore(0x60, m3)
  4373 |     |             mstore(0x80, m4)
  4374 |     |             mstore(0xa0, m5)
  4375 |     |             mstore(0xc0, m6)
  4376 |     |         }
  4377 |     |     }
  4378 |     | 
  4379 |     |     function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  4380 |     |         bytes32 m0;
  4381 |     |         bytes32 m1;
  4382 |     |         bytes32 m2;
  4383 |     |         bytes32 m3;
  4384 |     |         bytes32 m4;
  4385 |     |         bytes32 m5;
  4386 |     |         bytes32 m6;
  4387 |     |         assembly {
  4388 |     |             function writeString(pos, w) {
  4389 |     |                 let length := 0
  4390 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4391 |     |                 mstore(pos, length)
  4392 |     |                 let shift := sub(256, shl(3, length))
  4393 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4394 |     |             }
  4395 |     |             m0 := mload(0x00)
  4396 |     |             m1 := mload(0x20)
  4397 |     |             m2 := mload(0x40)
  4398 |     |             m3 := mload(0x60)
  4399 |     |             m4 := mload(0x80)
  4400 |     |             m5 := mload(0xa0)
  4401 |     |             m6 := mload(0xc0)
  4402 |     |             // Selector of `log(address,uint256,string,bool)`.
  4403 |     |             mstore(0x00, 0xcf18105c)
  4404 |     |             mstore(0x20, p0)
  4405 |     |             mstore(0x40, p1)
  4406 |     |             mstore(0x60, 0x80)
  4407 |     |             mstore(0x80, p3)
  4408 |     |             writeString(0xa0, p2)
  4409 |     |         }
  4410 |     |         _sendLogPayload(0x1c, 0xc4);
  4411 |     |         assembly {
  4412 |     |             mstore(0x00, m0)
  4413 |     |             mstore(0x20, m1)
  4414 |     |             mstore(0x40, m2)
  4415 |     |             mstore(0x60, m3)
  4416 |     |             mstore(0x80, m4)
  4417 |     |             mstore(0xa0, m5)
  4418 |     |             mstore(0xc0, m6)
  4419 |     |         }
  4420 |     |     }
  4421 |     | 
  4422 |     |     function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  4423 |     |         bytes32 m0;
  4424 |     |         bytes32 m1;
  4425 |     |         bytes32 m2;
  4426 |     |         bytes32 m3;
  4427 |     |         bytes32 m4;
  4428 |     |         bytes32 m5;
  4429 |     |         bytes32 m6;
  4430 |     |         assembly {
  4431 |     |             function writeString(pos, w) {
  4432 |     |                 let length := 0
  4433 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4434 |     |                 mstore(pos, length)
  4435 |     |                 let shift := sub(256, shl(3, length))
  4436 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4437 |     |             }
  4438 |     |             m0 := mload(0x00)
  4439 |     |             m1 := mload(0x20)
  4440 |     |             m2 := mload(0x40)
  4441 |     |             m3 := mload(0x60)
  4442 |     |             m4 := mload(0x80)
  4443 |     |             m5 := mload(0xa0)
  4444 |     |             m6 := mload(0xc0)
  4445 |     |             // Selector of `log(address,uint256,string,uint256)`.
  4446 |     |             mstore(0x00, 0xbf01f891)
  4447 |     |             mstore(0x20, p0)
  4448 |     |             mstore(0x40, p1)
  4449 |     |             mstore(0x60, 0x80)
  4450 |     |             mstore(0x80, p3)
  4451 |     |             writeString(0xa0, p2)
  4452 |     |         }
  4453 |     |         _sendLogPayload(0x1c, 0xc4);
  4454 |     |         assembly {
  4455 |     |             mstore(0x00, m0)
  4456 |     |             mstore(0x20, m1)
  4457 |     |             mstore(0x40, m2)
  4458 |     |             mstore(0x60, m3)
  4459 |     |             mstore(0x80, m4)
  4460 |     |             mstore(0xa0, m5)
  4461 |     |             mstore(0xc0, m6)
  4462 |     |         }
  4463 |     |     }
  4464 |     | 
  4465 |     |     function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  4466 |     |         bytes32 m0;
  4467 |     |         bytes32 m1;
  4468 |     |         bytes32 m2;
  4469 |     |         bytes32 m3;
  4470 |     |         bytes32 m4;
  4471 |     |         bytes32 m5;
  4472 |     |         bytes32 m6;
  4473 |     |         bytes32 m7;
  4474 |     |         bytes32 m8;
  4475 |     |         assembly {
  4476 |     |             function writeString(pos, w) {
  4477 |     |                 let length := 0
  4478 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4479 |     |                 mstore(pos, length)
  4480 |     |                 let shift := sub(256, shl(3, length))
  4481 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4482 |     |             }
  4483 |     |             m0 := mload(0x00)
  4484 |     |             m1 := mload(0x20)
  4485 |     |             m2 := mload(0x40)
  4486 |     |             m3 := mload(0x60)
  4487 |     |             m4 := mload(0x80)
  4488 |     |             m5 := mload(0xa0)
  4489 |     |             m6 := mload(0xc0)
  4490 |     |             m7 := mload(0xe0)
  4491 |     |             m8 := mload(0x100)
  4492 |     |             // Selector of `log(address,uint256,string,string)`.
  4493 |     |             mstore(0x00, 0x88a8c406)
  4494 |     |             mstore(0x20, p0)
  4495 |     |             mstore(0x40, p1)
  4496 |     |             mstore(0x60, 0x80)
  4497 |     |             mstore(0x80, 0xc0)
  4498 |     |             writeString(0xa0, p2)
  4499 |     |             writeString(0xe0, p3)
  4500 |     |         }
  4501 |     |         _sendLogPayload(0x1c, 0x104);
  4502 |     |         assembly {
  4503 |     |             mstore(0x00, m0)
  4504 |     |             mstore(0x20, m1)
  4505 |     |             mstore(0x40, m2)
  4506 |     |             mstore(0x60, m3)
  4507 |     |             mstore(0x80, m4)
  4508 |     |             mstore(0xa0, m5)
  4509 |     |             mstore(0xc0, m6)
  4510 |     |             mstore(0xe0, m7)
  4511 |     |             mstore(0x100, m8)
  4512 |     |         }
  4513 |     |     }
  4514 |     | 
  4515 |     |     function log(address p0, bytes32 p1, address p2, address p3) internal pure {
  4516 |     |         bytes32 m0;
  4517 |     |         bytes32 m1;
  4518 |     |         bytes32 m2;
  4519 |     |         bytes32 m3;
  4520 |     |         bytes32 m4;
  4521 |     |         bytes32 m5;
  4522 |     |         bytes32 m6;
  4523 |     |         assembly {
  4524 |     |             function writeString(pos, w) {
  4525 |     |                 let length := 0
  4526 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4527 |     |                 mstore(pos, length)
  4528 |     |                 let shift := sub(256, shl(3, length))
  4529 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4530 |     |             }
  4531 |     |             m0 := mload(0x00)
  4532 |     |             m1 := mload(0x20)
  4533 |     |             m2 := mload(0x40)
  4534 |     |             m3 := mload(0x60)
  4535 |     |             m4 := mload(0x80)
  4536 |     |             m5 := mload(0xa0)
  4537 |     |             m6 := mload(0xc0)
  4538 |     |             // Selector of `log(address,string,address,address)`.
  4539 |     |             mstore(0x00, 0x0d36fa20)
  4540 |     |             mstore(0x20, p0)
  4541 |     |             mstore(0x40, 0x80)
  4542 |     |             mstore(0x60, p2)
  4543 |     |             mstore(0x80, p3)
  4544 |     |             writeString(0xa0, p1)
  4545 |     |         }
  4546 |     |         _sendLogPayload(0x1c, 0xc4);
  4547 |     |         assembly {
  4548 |     |             mstore(0x00, m0)
  4549 |     |             mstore(0x20, m1)
  4550 |     |             mstore(0x40, m2)
  4551 |     |             mstore(0x60, m3)
  4552 |     |             mstore(0x80, m4)
  4553 |     |             mstore(0xa0, m5)
  4554 |     |             mstore(0xc0, m6)
  4555 |     |         }
  4556 |     |     }
  4557 |     | 
  4558 |     |     function log(address p0, bytes32 p1, address p2, bool p3) internal pure {
  4559 |     |         bytes32 m0;
  4560 |     |         bytes32 m1;
  4561 |     |         bytes32 m2;
  4562 |     |         bytes32 m3;
  4563 |     |         bytes32 m4;
  4564 |     |         bytes32 m5;
  4565 |     |         bytes32 m6;
  4566 |     |         assembly {
  4567 |     |             function writeString(pos, w) {
  4568 |     |                 let length := 0
  4569 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4570 |     |                 mstore(pos, length)
  4571 |     |                 let shift := sub(256, shl(3, length))
  4572 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4573 |     |             }
  4574 |     |             m0 := mload(0x00)
  4575 |     |             m1 := mload(0x20)
  4576 |     |             m2 := mload(0x40)
  4577 |     |             m3 := mload(0x60)
  4578 |     |             m4 := mload(0x80)
  4579 |     |             m5 := mload(0xa0)
  4580 |     |             m6 := mload(0xc0)
  4581 |     |             // Selector of `log(address,string,address,bool)`.
  4582 |     |             mstore(0x00, 0x0df12b76)
  4583 |     |             mstore(0x20, p0)
  4584 |     |             mstore(0x40, 0x80)
  4585 |     |             mstore(0x60, p2)
  4586 |     |             mstore(0x80, p3)
  4587 |     |             writeString(0xa0, p1)
  4588 |     |         }
  4589 |     |         _sendLogPayload(0x1c, 0xc4);
  4590 |     |         assembly {
  4591 |     |             mstore(0x00, m0)
  4592 |     |             mstore(0x20, m1)
  4593 |     |             mstore(0x40, m2)
  4594 |     |             mstore(0x60, m3)
  4595 |     |             mstore(0x80, m4)
  4596 |     |             mstore(0xa0, m5)
  4597 |     |             mstore(0xc0, m6)
  4598 |     |         }
  4599 |     |     }
  4600 |     | 
  4601 |     |     function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {
  4602 |     |         bytes32 m0;
  4603 |     |         bytes32 m1;
  4604 |     |         bytes32 m2;
  4605 |     |         bytes32 m3;
  4606 |     |         bytes32 m4;
  4607 |     |         bytes32 m5;
  4608 |     |         bytes32 m6;
  4609 |     |         assembly {
  4610 |     |             function writeString(pos, w) {
  4611 |     |                 let length := 0
  4612 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4613 |     |                 mstore(pos, length)
  4614 |     |                 let shift := sub(256, shl(3, length))
  4615 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4616 |     |             }
  4617 |     |             m0 := mload(0x00)
  4618 |     |             m1 := mload(0x20)
  4619 |     |             m2 := mload(0x40)
  4620 |     |             m3 := mload(0x60)
  4621 |     |             m4 := mload(0x80)
  4622 |     |             m5 := mload(0xa0)
  4623 |     |             m6 := mload(0xc0)
  4624 |     |             // Selector of `log(address,string,address,uint256)`.
  4625 |     |             mstore(0x00, 0x457fe3cf)
  4626 |     |             mstore(0x20, p0)
  4627 |     |             mstore(0x40, 0x80)
  4628 |     |             mstore(0x60, p2)
  4629 |     |             mstore(0x80, p3)
  4630 |     |             writeString(0xa0, p1)
  4631 |     |         }
  4632 |     |         _sendLogPayload(0x1c, 0xc4);
  4633 |     |         assembly {
  4634 |     |             mstore(0x00, m0)
  4635 |     |             mstore(0x20, m1)
  4636 |     |             mstore(0x40, m2)
  4637 |     |             mstore(0x60, m3)
  4638 |     |             mstore(0x80, m4)
  4639 |     |             mstore(0xa0, m5)
  4640 |     |             mstore(0xc0, m6)
  4641 |     |         }
  4642 |     |     }
  4643 |     | 
  4644 |     |     function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  4645 |     |         bytes32 m0;
  4646 |     |         bytes32 m1;
  4647 |     |         bytes32 m2;
  4648 |     |         bytes32 m3;
  4649 |     |         bytes32 m4;
  4650 |     |         bytes32 m5;
  4651 |     |         bytes32 m6;
  4652 |     |         bytes32 m7;
  4653 |     |         bytes32 m8;
  4654 |     |         assembly {
  4655 |     |             function writeString(pos, w) {
  4656 |     |                 let length := 0
  4657 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4658 |     |                 mstore(pos, length)
  4659 |     |                 let shift := sub(256, shl(3, length))
  4660 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4661 |     |             }
  4662 |     |             m0 := mload(0x00)
  4663 |     |             m1 := mload(0x20)
  4664 |     |             m2 := mload(0x40)
  4665 |     |             m3 := mload(0x60)
  4666 |     |             m4 := mload(0x80)
  4667 |     |             m5 := mload(0xa0)
  4668 |     |             m6 := mload(0xc0)
  4669 |     |             m7 := mload(0xe0)
  4670 |     |             m8 := mload(0x100)
  4671 |     |             // Selector of `log(address,string,address,string)`.
  4672 |     |             mstore(0x00, 0xf7e36245)
  4673 |     |             mstore(0x20, p0)
  4674 |     |             mstore(0x40, 0x80)
  4675 |     |             mstore(0x60, p2)
  4676 |     |             mstore(0x80, 0xc0)
  4677 |     |             writeString(0xa0, p1)
  4678 |     |             writeString(0xe0, p3)
  4679 |     |         }
  4680 |     |         _sendLogPayload(0x1c, 0x104);
  4681 |     |         assembly {
  4682 |     |             mstore(0x00, m0)
  4683 |     |             mstore(0x20, m1)
  4684 |     |             mstore(0x40, m2)
  4685 |     |             mstore(0x60, m3)
  4686 |     |             mstore(0x80, m4)
  4687 |     |             mstore(0xa0, m5)
  4688 |     |             mstore(0xc0, m6)
  4689 |     |             mstore(0xe0, m7)
  4690 |     |             mstore(0x100, m8)
  4691 |     |         }
  4692 |     |     }
  4693 |     | 
  4694 |     |     function log(address p0, bytes32 p1, bool p2, address p3) internal pure {
  4695 |     |         bytes32 m0;
  4696 |     |         bytes32 m1;
  4697 |     |         bytes32 m2;
  4698 |     |         bytes32 m3;
  4699 |     |         bytes32 m4;
  4700 |     |         bytes32 m5;
  4701 |     |         bytes32 m6;
  4702 |     |         assembly {
  4703 |     |             function writeString(pos, w) {
  4704 |     |                 let length := 0
  4705 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4706 |     |                 mstore(pos, length)
  4707 |     |                 let shift := sub(256, shl(3, length))
  4708 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4709 |     |             }
  4710 |     |             m0 := mload(0x00)
  4711 |     |             m1 := mload(0x20)
  4712 |     |             m2 := mload(0x40)
  4713 |     |             m3 := mload(0x60)
  4714 |     |             m4 := mload(0x80)
  4715 |     |             m5 := mload(0xa0)
  4716 |     |             m6 := mload(0xc0)
  4717 |     |             // Selector of `log(address,string,bool,address)`.
  4718 |     |             mstore(0x00, 0x205871c2)
  4719 |     |             mstore(0x20, p0)
  4720 |     |             mstore(0x40, 0x80)
  4721 |     |             mstore(0x60, p2)
  4722 |     |             mstore(0x80, p3)
  4723 |     |             writeString(0xa0, p1)
  4724 |     |         }
  4725 |     |         _sendLogPayload(0x1c, 0xc4);
  4726 |     |         assembly {
  4727 |     |             mstore(0x00, m0)
  4728 |     |             mstore(0x20, m1)
  4729 |     |             mstore(0x40, m2)
  4730 |     |             mstore(0x60, m3)
  4731 |     |             mstore(0x80, m4)
  4732 |     |             mstore(0xa0, m5)
  4733 |     |             mstore(0xc0, m6)
  4734 |     |         }
  4735 |     |     }
  4736 |     | 
  4737 |     |     function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {
  4738 |     |         bytes32 m0;
  4739 |     |         bytes32 m1;
  4740 |     |         bytes32 m2;
  4741 |     |         bytes32 m3;
  4742 |     |         bytes32 m4;
  4743 |     |         bytes32 m5;
  4744 |     |         bytes32 m6;
  4745 |     |         assembly {
  4746 |     |             function writeString(pos, w) {
  4747 |     |                 let length := 0
  4748 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4749 |     |                 mstore(pos, length)
  4750 |     |                 let shift := sub(256, shl(3, length))
  4751 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4752 |     |             }
  4753 |     |             m0 := mload(0x00)
  4754 |     |             m1 := mload(0x20)
  4755 |     |             m2 := mload(0x40)
  4756 |     |             m3 := mload(0x60)
  4757 |     |             m4 := mload(0x80)
  4758 |     |             m5 := mload(0xa0)
  4759 |     |             m6 := mload(0xc0)
  4760 |     |             // Selector of `log(address,string,bool,bool)`.
  4761 |     |             mstore(0x00, 0x5f1d5c9f)
  4762 |     |             mstore(0x20, p0)
  4763 |     |             mstore(0x40, 0x80)
  4764 |     |             mstore(0x60, p2)
  4765 |     |             mstore(0x80, p3)
  4766 |     |             writeString(0xa0, p1)
  4767 |     |         }
  4768 |     |         _sendLogPayload(0x1c, 0xc4);
  4769 |     |         assembly {
  4770 |     |             mstore(0x00, m0)
  4771 |     |             mstore(0x20, m1)
  4772 |     |             mstore(0x40, m2)
  4773 |     |             mstore(0x60, m3)
  4774 |     |             mstore(0x80, m4)
  4775 |     |             mstore(0xa0, m5)
  4776 |     |             mstore(0xc0, m6)
  4777 |     |         }
  4778 |     |     }
  4779 |     | 
  4780 |     |     function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  4781 |     |         bytes32 m0;
  4782 |     |         bytes32 m1;
  4783 |     |         bytes32 m2;
  4784 |     |         bytes32 m3;
  4785 |     |         bytes32 m4;
  4786 |     |         bytes32 m5;
  4787 |     |         bytes32 m6;
  4788 |     |         assembly {
  4789 |     |             function writeString(pos, w) {
  4790 |     |                 let length := 0
  4791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4792 |     |                 mstore(pos, length)
  4793 |     |                 let shift := sub(256, shl(3, length))
  4794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4795 |     |             }
  4796 |     |             m0 := mload(0x00)
  4797 |     |             m1 := mload(0x20)
  4798 |     |             m2 := mload(0x40)
  4799 |     |             m3 := mload(0x60)
  4800 |     |             m4 := mload(0x80)
  4801 |     |             m5 := mload(0xa0)
  4802 |     |             m6 := mload(0xc0)
  4803 |     |             // Selector of `log(address,string,bool,uint256)`.
  4804 |     |             mstore(0x00, 0x515e38b6)
  4805 |     |             mstore(0x20, p0)
  4806 |     |             mstore(0x40, 0x80)
  4807 |     |             mstore(0x60, p2)
  4808 |     |             mstore(0x80, p3)
  4809 |     |             writeString(0xa0, p1)
  4810 |     |         }
  4811 |     |         _sendLogPayload(0x1c, 0xc4);
  4812 |     |         assembly {
  4813 |     |             mstore(0x00, m0)
  4814 |     |             mstore(0x20, m1)
  4815 |     |             mstore(0x40, m2)
  4816 |     |             mstore(0x60, m3)
  4817 |     |             mstore(0x80, m4)
  4818 |     |             mstore(0xa0, m5)
  4819 |     |             mstore(0xc0, m6)
  4820 |     |         }
  4821 |     |     }
  4822 |     | 
  4823 |     |     function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  4824 |     |         bytes32 m0;
  4825 |     |         bytes32 m1;
  4826 |     |         bytes32 m2;
  4827 |     |         bytes32 m3;
  4828 |     |         bytes32 m4;
  4829 |     |         bytes32 m5;
  4830 |     |         bytes32 m6;
  4831 |     |         bytes32 m7;
  4832 |     |         bytes32 m8;
  4833 |     |         assembly {
  4834 |     |             function writeString(pos, w) {
  4835 |     |                 let length := 0
  4836 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4837 |     |                 mstore(pos, length)
  4838 |     |                 let shift := sub(256, shl(3, length))
  4839 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4840 |     |             }
  4841 |     |             m0 := mload(0x00)
  4842 |     |             m1 := mload(0x20)
  4843 |     |             m2 := mload(0x40)
  4844 |     |             m3 := mload(0x60)
  4845 |     |             m4 := mload(0x80)
  4846 |     |             m5 := mload(0xa0)
  4847 |     |             m6 := mload(0xc0)
  4848 |     |             m7 := mload(0xe0)
  4849 |     |             m8 := mload(0x100)
  4850 |     |             // Selector of `log(address,string,bool,string)`.
  4851 |     |             mstore(0x00, 0xbc0b61fe)
  4852 |     |             mstore(0x20, p0)
  4853 |     |             mstore(0x40, 0x80)
  4854 |     |             mstore(0x60, p2)
  4855 |     |             mstore(0x80, 0xc0)
  4856 |     |             writeString(0xa0, p1)
  4857 |     |             writeString(0xe0, p3)
  4858 |     |         }
  4859 |     |         _sendLogPayload(0x1c, 0x104);
  4860 |     |         assembly {
  4861 |     |             mstore(0x00, m0)
  4862 |     |             mstore(0x20, m1)
  4863 |     |             mstore(0x40, m2)
  4864 |     |             mstore(0x60, m3)
  4865 |     |             mstore(0x80, m4)
  4866 |     |             mstore(0xa0, m5)
  4867 |     |             mstore(0xc0, m6)
  4868 |     |             mstore(0xe0, m7)
  4869 |     |             mstore(0x100, m8)
  4870 |     |         }
  4871 |     |     }
  4872 |     | 
  4873 |     |     function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {
  4874 |     |         bytes32 m0;
  4875 |     |         bytes32 m1;
  4876 |     |         bytes32 m2;
  4877 |     |         bytes32 m3;
  4878 |     |         bytes32 m4;
  4879 |     |         bytes32 m5;
  4880 |     |         bytes32 m6;
  4881 |     |         assembly {
  4882 |     |             function writeString(pos, w) {
  4883 |     |                 let length := 0
  4884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4885 |     |                 mstore(pos, length)
  4886 |     |                 let shift := sub(256, shl(3, length))
  4887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4888 |     |             }
  4889 |     |             m0 := mload(0x00)
  4890 |     |             m1 := mload(0x20)
  4891 |     |             m2 := mload(0x40)
  4892 |     |             m3 := mload(0x60)
  4893 |     |             m4 := mload(0x80)
  4894 |     |             m5 := mload(0xa0)
  4895 |     |             m6 := mload(0xc0)
  4896 |     |             // Selector of `log(address,string,uint256,address)`.
  4897 |     |             mstore(0x00, 0x63183678)
  4898 |     |             mstore(0x20, p0)
  4899 |     |             mstore(0x40, 0x80)
  4900 |     |             mstore(0x60, p2)
  4901 |     |             mstore(0x80, p3)
  4902 |     |             writeString(0xa0, p1)
  4903 |     |         }
  4904 |     |         _sendLogPayload(0x1c, 0xc4);
  4905 |     |         assembly {
  4906 |     |             mstore(0x00, m0)
  4907 |     |             mstore(0x20, m1)
  4908 |     |             mstore(0x40, m2)
  4909 |     |             mstore(0x60, m3)
  4910 |     |             mstore(0x80, m4)
  4911 |     |             mstore(0xa0, m5)
  4912 |     |             mstore(0xc0, m6)
  4913 |     |         }
  4914 |     |     }
  4915 |     | 
  4916 |     |     function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  4917 |     |         bytes32 m0;
  4918 |     |         bytes32 m1;
  4919 |     |         bytes32 m2;
  4920 |     |         bytes32 m3;
  4921 |     |         bytes32 m4;
  4922 |     |         bytes32 m5;
  4923 |     |         bytes32 m6;
  4924 |     |         assembly {
  4925 |     |             function writeString(pos, w) {
  4926 |     |                 let length := 0
  4927 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4928 |     |                 mstore(pos, length)
  4929 |     |                 let shift := sub(256, shl(3, length))
  4930 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4931 |     |             }
  4932 |     |             m0 := mload(0x00)
  4933 |     |             m1 := mload(0x20)
  4934 |     |             m2 := mload(0x40)
  4935 |     |             m3 := mload(0x60)
  4936 |     |             m4 := mload(0x80)
  4937 |     |             m5 := mload(0xa0)
  4938 |     |             m6 := mload(0xc0)
  4939 |     |             // Selector of `log(address,string,uint256,bool)`.
  4940 |     |             mstore(0x00, 0x0ef7e050)
  4941 |     |             mstore(0x20, p0)
  4942 |     |             mstore(0x40, 0x80)
  4943 |     |             mstore(0x60, p2)
  4944 |     |             mstore(0x80, p3)
  4945 |     |             writeString(0xa0, p1)
  4946 |     |         }
  4947 |     |         _sendLogPayload(0x1c, 0xc4);
  4948 |     |         assembly {
  4949 |     |             mstore(0x00, m0)
  4950 |     |             mstore(0x20, m1)
  4951 |     |             mstore(0x40, m2)
  4952 |     |             mstore(0x60, m3)
  4953 |     |             mstore(0x80, m4)
  4954 |     |             mstore(0xa0, m5)
  4955 |     |             mstore(0xc0, m6)
  4956 |     |         }
  4957 |     |     }
  4958 |     | 
  4959 |     |     function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  4960 |     |         bytes32 m0;
  4961 |     |         bytes32 m1;
  4962 |     |         bytes32 m2;
  4963 |     |         bytes32 m3;
  4964 |     |         bytes32 m4;
  4965 |     |         bytes32 m5;
  4966 |     |         bytes32 m6;
  4967 |     |         assembly {
  4968 |     |             function writeString(pos, w) {
  4969 |     |                 let length := 0
  4970 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4971 |     |                 mstore(pos, length)
  4972 |     |                 let shift := sub(256, shl(3, length))
  4973 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4974 |     |             }
  4975 |     |             m0 := mload(0x00)
  4976 |     |             m1 := mload(0x20)
  4977 |     |             m2 := mload(0x40)
  4978 |     |             m3 := mload(0x60)
  4979 |     |             m4 := mload(0x80)
  4980 |     |             m5 := mload(0xa0)
  4981 |     |             m6 := mload(0xc0)
  4982 |     |             // Selector of `log(address,string,uint256,uint256)`.
  4983 |     |             mstore(0x00, 0x1dc8e1b8)
  4984 |     |             mstore(0x20, p0)
  4985 |     |             mstore(0x40, 0x80)
  4986 |     |             mstore(0x60, p2)
  4987 |     |             mstore(0x80, p3)
  4988 |     |             writeString(0xa0, p1)
  4989 |     |         }
  4990 |     |         _sendLogPayload(0x1c, 0xc4);
  4991 |     |         assembly {
  4992 |     |             mstore(0x00, m0)
  4993 |     |             mstore(0x20, m1)
  4994 |     |             mstore(0x40, m2)
  4995 |     |             mstore(0x60, m3)
  4996 |     |             mstore(0x80, m4)
  4997 |     |             mstore(0xa0, m5)
  4998 |     |             mstore(0xc0, m6)
  4999 |     |         }
  5000 |     |     }
  5001 |     | 
  5002 |     |     function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  5003 |     |         bytes32 m0;
  5004 |     |         bytes32 m1;
  5005 |     |         bytes32 m2;
  5006 |     |         bytes32 m3;
  5007 |     |         bytes32 m4;
  5008 |     |         bytes32 m5;
  5009 |     |         bytes32 m6;
  5010 |     |         bytes32 m7;
  5011 |     |         bytes32 m8;
  5012 |     |         assembly {
  5013 |     |             function writeString(pos, w) {
  5014 |     |                 let length := 0
  5015 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5016 |     |                 mstore(pos, length)
  5017 |     |                 let shift := sub(256, shl(3, length))
  5018 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5019 |     |             }
  5020 |     |             m0 := mload(0x00)
  5021 |     |             m1 := mload(0x20)
  5022 |     |             m2 := mload(0x40)
  5023 |     |             m3 := mload(0x60)
  5024 |     |             m4 := mload(0x80)
  5025 |     |             m5 := mload(0xa0)
  5026 |     |             m6 := mload(0xc0)
  5027 |     |             m7 := mload(0xe0)
  5028 |     |             m8 := mload(0x100)
  5029 |     |             // Selector of `log(address,string,uint256,string)`.
  5030 |     |             mstore(0x00, 0x448830a8)
  5031 |     |             mstore(0x20, p0)
  5032 |     |             mstore(0x40, 0x80)
  5033 |     |             mstore(0x60, p2)
  5034 |     |             mstore(0x80, 0xc0)
  5035 |     |             writeString(0xa0, p1)
  5036 |     |             writeString(0xe0, p3)
  5037 |     |         }
  5038 |     |         _sendLogPayload(0x1c, 0x104);
  5039 |     |         assembly {
  5040 |     |             mstore(0x00, m0)
  5041 |     |             mstore(0x20, m1)
  5042 |     |             mstore(0x40, m2)
  5043 |     |             mstore(0x60, m3)
  5044 |     |             mstore(0x80, m4)
  5045 |     |             mstore(0xa0, m5)
  5046 |     |             mstore(0xc0, m6)
  5047 |     |             mstore(0xe0, m7)
  5048 |     |             mstore(0x100, m8)
  5049 |     |         }
  5050 |     |     }
  5051 |     | 
  5052 |     |     function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  5053 |     |         bytes32 m0;
  5054 |     |         bytes32 m1;
  5055 |     |         bytes32 m2;
  5056 |     |         bytes32 m3;
  5057 |     |         bytes32 m4;
  5058 |     |         bytes32 m5;
  5059 |     |         bytes32 m6;
  5060 |     |         bytes32 m7;
  5061 |     |         bytes32 m8;
  5062 |     |         assembly {
  5063 |     |             function writeString(pos, w) {
  5064 |     |                 let length := 0
  5065 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5066 |     |                 mstore(pos, length)
  5067 |     |                 let shift := sub(256, shl(3, length))
  5068 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5069 |     |             }
  5070 |     |             m0 := mload(0x00)
  5071 |     |             m1 := mload(0x20)
  5072 |     |             m2 := mload(0x40)
  5073 |     |             m3 := mload(0x60)
  5074 |     |             m4 := mload(0x80)
  5075 |     |             m5 := mload(0xa0)
  5076 |     |             m6 := mload(0xc0)
  5077 |     |             m7 := mload(0xe0)
  5078 |     |             m8 := mload(0x100)
  5079 |     |             // Selector of `log(address,string,string,address)`.
  5080 |     |             mstore(0x00, 0xa04e2f87)
  5081 |     |             mstore(0x20, p0)
  5082 |     |             mstore(0x40, 0x80)
  5083 |     |             mstore(0x60, 0xc0)
  5084 |     |             mstore(0x80, p3)
  5085 |     |             writeString(0xa0, p1)
  5086 |     |             writeString(0xe0, p2)
  5087 |     |         }
  5088 |     |         _sendLogPayload(0x1c, 0x104);
  5089 |     |         assembly {
  5090 |     |             mstore(0x00, m0)
  5091 |     |             mstore(0x20, m1)
  5092 |     |             mstore(0x40, m2)
  5093 |     |             mstore(0x60, m3)
  5094 |     |             mstore(0x80, m4)
  5095 |     |             mstore(0xa0, m5)
  5096 |     |             mstore(0xc0, m6)
  5097 |     |             mstore(0xe0, m7)
  5098 |     |             mstore(0x100, m8)
  5099 |     |         }
  5100 |     |     }
  5101 |     | 
  5102 |     |     function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  5103 |     |         bytes32 m0;
  5104 |     |         bytes32 m1;
  5105 |     |         bytes32 m2;
  5106 |     |         bytes32 m3;
  5107 |     |         bytes32 m4;
  5108 |     |         bytes32 m5;
  5109 |     |         bytes32 m6;
  5110 |     |         bytes32 m7;
  5111 |     |         bytes32 m8;
  5112 |     |         assembly {
  5113 |     |             function writeString(pos, w) {
  5114 |     |                 let length := 0
  5115 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5116 |     |                 mstore(pos, length)
  5117 |     |                 let shift := sub(256, shl(3, length))
  5118 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5119 |     |             }
  5120 |     |             m0 := mload(0x00)
  5121 |     |             m1 := mload(0x20)
  5122 |     |             m2 := mload(0x40)
  5123 |     |             m3 := mload(0x60)
  5124 |     |             m4 := mload(0x80)
  5125 |     |             m5 := mload(0xa0)
  5126 |     |             m6 := mload(0xc0)
  5127 |     |             m7 := mload(0xe0)
  5128 |     |             m8 := mload(0x100)
  5129 |     |             // Selector of `log(address,string,string,bool)`.
  5130 |     |             mstore(0x00, 0x35a5071f)
  5131 |     |             mstore(0x20, p0)
  5132 |     |             mstore(0x40, 0x80)
  5133 |     |             mstore(0x60, 0xc0)
  5134 |     |             mstore(0x80, p3)
  5135 |     |             writeString(0xa0, p1)
  5136 |     |             writeString(0xe0, p2)
  5137 |     |         }
  5138 |     |         _sendLogPayload(0x1c, 0x104);
  5139 |     |         assembly {
  5140 |     |             mstore(0x00, m0)
  5141 |     |             mstore(0x20, m1)
  5142 |     |             mstore(0x40, m2)
  5143 |     |             mstore(0x60, m3)
  5144 |     |             mstore(0x80, m4)
  5145 |     |             mstore(0xa0, m5)
  5146 |     |             mstore(0xc0, m6)
  5147 |     |             mstore(0xe0, m7)
  5148 |     |             mstore(0x100, m8)
  5149 |     |         }
  5150 |     |     }
  5151 |     | 
  5152 |     |     function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  5153 |     |         bytes32 m0;
  5154 |     |         bytes32 m1;
  5155 |     |         bytes32 m2;
  5156 |     |         bytes32 m3;
  5157 |     |         bytes32 m4;
  5158 |     |         bytes32 m5;
  5159 |     |         bytes32 m6;
  5160 |     |         bytes32 m7;
  5161 |     |         bytes32 m8;
  5162 |     |         assembly {
  5163 |     |             function writeString(pos, w) {
  5164 |     |                 let length := 0
  5165 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5166 |     |                 mstore(pos, length)
  5167 |     |                 let shift := sub(256, shl(3, length))
  5168 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5169 |     |             }
  5170 |     |             m0 := mload(0x00)
  5171 |     |             m1 := mload(0x20)
  5172 |     |             m2 := mload(0x40)
  5173 |     |             m3 := mload(0x60)
  5174 |     |             m4 := mload(0x80)
  5175 |     |             m5 := mload(0xa0)
  5176 |     |             m6 := mload(0xc0)
  5177 |     |             m7 := mload(0xe0)
  5178 |     |             m8 := mload(0x100)
  5179 |     |             // Selector of `log(address,string,string,uint256)`.
  5180 |     |             mstore(0x00, 0x159f8927)
  5181 |     |             mstore(0x20, p0)
  5182 |     |             mstore(0x40, 0x80)
  5183 |     |             mstore(0x60, 0xc0)
  5184 |     |             mstore(0x80, p3)
  5185 |     |             writeString(0xa0, p1)
  5186 |     |             writeString(0xe0, p2)
  5187 |     |         }
  5188 |     |         _sendLogPayload(0x1c, 0x104);
  5189 |     |         assembly {
  5190 |     |             mstore(0x00, m0)
  5191 |     |             mstore(0x20, m1)
  5192 |     |             mstore(0x40, m2)
  5193 |     |             mstore(0x60, m3)
  5194 |     |             mstore(0x80, m4)
  5195 |     |             mstore(0xa0, m5)
  5196 |     |             mstore(0xc0, m6)
  5197 |     |             mstore(0xe0, m7)
  5198 |     |             mstore(0x100, m8)
  5199 |     |         }
  5200 |     |     }
  5201 |     | 
  5202 |     |     function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  5203 |     |         bytes32 m0;
  5204 |     |         bytes32 m1;
  5205 |     |         bytes32 m2;
  5206 |     |         bytes32 m3;
  5207 |     |         bytes32 m4;
  5208 |     |         bytes32 m5;
  5209 |     |         bytes32 m6;
  5210 |     |         bytes32 m7;
  5211 |     |         bytes32 m8;
  5212 |     |         bytes32 m9;
  5213 |     |         bytes32 m10;
  5214 |     |         assembly {
  5215 |     |             function writeString(pos, w) {
  5216 |     |                 let length := 0
  5217 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5218 |     |                 mstore(pos, length)
  5219 |     |                 let shift := sub(256, shl(3, length))
  5220 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5221 |     |             }
  5222 |     |             m0 := mload(0x00)
  5223 |     |             m1 := mload(0x20)
  5224 |     |             m2 := mload(0x40)
  5225 |     |             m3 := mload(0x60)
  5226 |     |             m4 := mload(0x80)
  5227 |     |             m5 := mload(0xa0)
  5228 |     |             m6 := mload(0xc0)
  5229 |     |             m7 := mload(0xe0)
  5230 |     |             m8 := mload(0x100)
  5231 |     |             m9 := mload(0x120)
  5232 |     |             m10 := mload(0x140)
  5233 |     |             // Selector of `log(address,string,string,string)`.
  5234 |     |             mstore(0x00, 0x5d02c50b)
  5235 |     |             mstore(0x20, p0)
  5236 |     |             mstore(0x40, 0x80)
  5237 |     |             mstore(0x60, 0xc0)
  5238 |     |             mstore(0x80, 0x100)
  5239 |     |             writeString(0xa0, p1)
  5240 |     |             writeString(0xe0, p2)
  5241 |     |             writeString(0x120, p3)
  5242 |     |         }
  5243 |     |         _sendLogPayload(0x1c, 0x144);
  5244 |     |         assembly {
  5245 |     |             mstore(0x00, m0)
  5246 |     |             mstore(0x20, m1)
  5247 |     |             mstore(0x40, m2)
  5248 |     |             mstore(0x60, m3)
  5249 |     |             mstore(0x80, m4)
  5250 |     |             mstore(0xa0, m5)
  5251 |     |             mstore(0xc0, m6)
  5252 |     |             mstore(0xe0, m7)
  5253 |     |             mstore(0x100, m8)
  5254 |     |             mstore(0x120, m9)
  5255 |     |             mstore(0x140, m10)
  5256 |     |         }
  5257 |     |     }
  5258 |     | 
  5259 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
  5260 |     |         bytes32 m0;
  5261 |     |         bytes32 m1;
  5262 |     |         bytes32 m2;
  5263 |     |         bytes32 m3;
  5264 |     |         bytes32 m4;
  5265 |     |         assembly {
  5266 |     |             m0 := mload(0x00)
  5267 |     |             m1 := mload(0x20)
  5268 |     |             m2 := mload(0x40)
  5269 |     |             m3 := mload(0x60)
  5270 |     |             m4 := mload(0x80)
  5271 |     |             // Selector of `log(bool,address,address,address)`.
  5272 |     |             mstore(0x00, 0x1d14d001)
  5273 |     |             mstore(0x20, p0)
  5274 |     |             mstore(0x40, p1)
  5275 |     |             mstore(0x60, p2)
  5276 |     |             mstore(0x80, p3)
  5277 |     |         }
  5278 |     |         _sendLogPayload(0x1c, 0x84);
  5279 |     |         assembly {
  5280 |     |             mstore(0x00, m0)
  5281 |     |             mstore(0x20, m1)
  5282 |     |             mstore(0x40, m2)
  5283 |     |             mstore(0x60, m3)
  5284 |     |             mstore(0x80, m4)
  5285 |     |         }
  5286 |     |     }
  5287 |     | 
  5288 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
  5289 |     |         bytes32 m0;
  5290 |     |         bytes32 m1;
  5291 |     |         bytes32 m2;
  5292 |     |         bytes32 m3;
  5293 |     |         bytes32 m4;
  5294 |     |         assembly {
  5295 |     |             m0 := mload(0x00)
  5296 |     |             m1 := mload(0x20)
  5297 |     |             m2 := mload(0x40)
  5298 |     |             m3 := mload(0x60)
  5299 |     |             m4 := mload(0x80)
  5300 |     |             // Selector of `log(bool,address,address,bool)`.
  5301 |     |             mstore(0x00, 0x46600be0)
  5302 |     |             mstore(0x20, p0)
  5303 |     |             mstore(0x40, p1)
  5304 |     |             mstore(0x60, p2)
  5305 |     |             mstore(0x80, p3)
  5306 |     |         }
  5307 |     |         _sendLogPayload(0x1c, 0x84);
  5308 |     |         assembly {
  5309 |     |             mstore(0x00, m0)
  5310 |     |             mstore(0x20, m1)
  5311 |     |             mstore(0x40, m2)
  5312 |     |             mstore(0x60, m3)
  5313 |     |             mstore(0x80, m4)
  5314 |     |         }
  5315 |     |     }
  5316 |     | 
  5317 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
  5318 |     |         bytes32 m0;
  5319 |     |         bytes32 m1;
  5320 |     |         bytes32 m2;
  5321 |     |         bytes32 m3;
  5322 |     |         bytes32 m4;
  5323 |     |         assembly {
  5324 |     |             m0 := mload(0x00)
  5325 |     |             m1 := mload(0x20)
  5326 |     |             m2 := mload(0x40)
  5327 |     |             m3 := mload(0x60)
  5328 |     |             m4 := mload(0x80)
  5329 |     |             // Selector of `log(bool,address,address,uint256)`.
  5330 |     |             mstore(0x00, 0x0c66d1be)
  5331 |     |             mstore(0x20, p0)
  5332 |     |             mstore(0x40, p1)
  5333 |     |             mstore(0x60, p2)
  5334 |     |             mstore(0x80, p3)
  5335 |     |         }
  5336 |     |         _sendLogPayload(0x1c, 0x84);
  5337 |     |         assembly {
  5338 |     |             mstore(0x00, m0)
  5339 |     |             mstore(0x20, m1)
  5340 |     |             mstore(0x40, m2)
  5341 |     |             mstore(0x60, m3)
  5342 |     |             mstore(0x80, m4)
  5343 |     |         }
  5344 |     |     }
  5345 |     | 
  5346 |     |     function log(bool p0, address p1, address p2, bytes32 p3) internal pure {
  5347 |     |         bytes32 m0;
  5348 |     |         bytes32 m1;
  5349 |     |         bytes32 m2;
  5350 |     |         bytes32 m3;
  5351 |     |         bytes32 m4;
  5352 |     |         bytes32 m5;
  5353 |     |         bytes32 m6;
  5354 |     |         assembly {
  5355 |     |             function writeString(pos, w) {
  5356 |     |                 let length := 0
  5357 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5358 |     |                 mstore(pos, length)
  5359 |     |                 let shift := sub(256, shl(3, length))
  5360 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5361 |     |             }
  5362 |     |             m0 := mload(0x00)
  5363 |     |             m1 := mload(0x20)
  5364 |     |             m2 := mload(0x40)
  5365 |     |             m3 := mload(0x60)
  5366 |     |             m4 := mload(0x80)
  5367 |     |             m5 := mload(0xa0)
  5368 |     |             m6 := mload(0xc0)
  5369 |     |             // Selector of `log(bool,address,address,string)`.
  5370 |     |             mstore(0x00, 0xd812a167)
  5371 |     |             mstore(0x20, p0)
  5372 |     |             mstore(0x40, p1)
  5373 |     |             mstore(0x60, p2)
  5374 |     |             mstore(0x80, 0x80)
  5375 |     |             writeString(0xa0, p3)
  5376 |     |         }
  5377 |     |         _sendLogPayload(0x1c, 0xc4);
  5378 |     |         assembly {
  5379 |     |             mstore(0x00, m0)
  5380 |     |             mstore(0x20, m1)
  5381 |     |             mstore(0x40, m2)
  5382 |     |             mstore(0x60, m3)
  5383 |     |             mstore(0x80, m4)
  5384 |     |             mstore(0xa0, m5)
  5385 |     |             mstore(0xc0, m6)
  5386 |     |         }
  5387 |     |     }
  5388 |     | 
  5389 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
  5390 |     |         bytes32 m0;
  5391 |     |         bytes32 m1;
  5392 |     |         bytes32 m2;
  5393 |     |         bytes32 m3;
  5394 |     |         bytes32 m4;
  5395 |     |         assembly {
  5396 |     |             m0 := mload(0x00)
  5397 |     |             m1 := mload(0x20)
  5398 |     |             m2 := mload(0x40)
  5399 |     |             m3 := mload(0x60)
  5400 |     |             m4 := mload(0x80)
  5401 |     |             // Selector of `log(bool,address,bool,address)`.
  5402 |     |             mstore(0x00, 0x1c41a336)
  5403 |     |             mstore(0x20, p0)
  5404 |     |             mstore(0x40, p1)
  5405 |     |             mstore(0x60, p2)
  5406 |     |             mstore(0x80, p3)
  5407 |     |         }
  5408 |     |         _sendLogPayload(0x1c, 0x84);
  5409 |     |         assembly {
  5410 |     |             mstore(0x00, m0)
  5411 |     |             mstore(0x20, m1)
  5412 |     |             mstore(0x40, m2)
  5413 |     |             mstore(0x60, m3)
  5414 |     |             mstore(0x80, m4)
  5415 |     |         }
  5416 |     |     }
  5417 |     | 
  5418 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
  5419 |     |         bytes32 m0;
  5420 |     |         bytes32 m1;
  5421 |     |         bytes32 m2;
  5422 |     |         bytes32 m3;
  5423 |     |         bytes32 m4;
  5424 |     |         assembly {
  5425 |     |             m0 := mload(0x00)
  5426 |     |             m1 := mload(0x20)
  5427 |     |             m2 := mload(0x40)
  5428 |     |             m3 := mload(0x60)
  5429 |     |             m4 := mload(0x80)
  5430 |     |             // Selector of `log(bool,address,bool,bool)`.
  5431 |     |             mstore(0x00, 0x6a9c478b)
  5432 |     |             mstore(0x20, p0)
  5433 |     |             mstore(0x40, p1)
  5434 |     |             mstore(0x60, p2)
  5435 |     |             mstore(0x80, p3)
  5436 |     |         }
  5437 |     |         _sendLogPayload(0x1c, 0x84);
  5438 |     |         assembly {
  5439 |     |             mstore(0x00, m0)
  5440 |     |             mstore(0x20, m1)
  5441 |     |             mstore(0x40, m2)
  5442 |     |             mstore(0x60, m3)
  5443 |     |             mstore(0x80, m4)
  5444 |     |         }
  5445 |     |     }
  5446 |     | 
  5447 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
  5448 |     |         bytes32 m0;
  5449 |     |         bytes32 m1;
  5450 |     |         bytes32 m2;
  5451 |     |         bytes32 m3;
  5452 |     |         bytes32 m4;
  5453 |     |         assembly {
  5454 |     |             m0 := mload(0x00)
  5455 |     |             m1 := mload(0x20)
  5456 |     |             m2 := mload(0x40)
  5457 |     |             m3 := mload(0x60)
  5458 |     |             m4 := mload(0x80)
  5459 |     |             // Selector of `log(bool,address,bool,uint256)`.
  5460 |     |             mstore(0x00, 0x07831502)
  5461 |     |             mstore(0x20, p0)
  5462 |     |             mstore(0x40, p1)
  5463 |     |             mstore(0x60, p2)
  5464 |     |             mstore(0x80, p3)
  5465 |     |         }
  5466 |     |         _sendLogPayload(0x1c, 0x84);
  5467 |     |         assembly {
  5468 |     |             mstore(0x00, m0)
  5469 |     |             mstore(0x20, m1)
  5470 |     |             mstore(0x40, m2)
  5471 |     |             mstore(0x60, m3)
  5472 |     |             mstore(0x80, m4)
  5473 |     |         }
  5474 |     |     }
  5475 |     | 
  5476 |     |     function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {
  5477 |     |         bytes32 m0;
  5478 |     |         bytes32 m1;
  5479 |     |         bytes32 m2;
  5480 |     |         bytes32 m3;
  5481 |     |         bytes32 m4;
  5482 |     |         bytes32 m5;
  5483 |     |         bytes32 m6;
  5484 |     |         assembly {
  5485 |     |             function writeString(pos, w) {
  5486 |     |                 let length := 0
  5487 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5488 |     |                 mstore(pos, length)
  5489 |     |                 let shift := sub(256, shl(3, length))
  5490 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5491 |     |             }
  5492 |     |             m0 := mload(0x00)
  5493 |     |             m1 := mload(0x20)
  5494 |     |             m2 := mload(0x40)
  5495 |     |             m3 := mload(0x60)
  5496 |     |             m4 := mload(0x80)
  5497 |     |             m5 := mload(0xa0)
  5498 |     |             m6 := mload(0xc0)
  5499 |     |             // Selector of `log(bool,address,bool,string)`.
  5500 |     |             mstore(0x00, 0x4a66cb34)
  5501 |     |             mstore(0x20, p0)
  5502 |     |             mstore(0x40, p1)
  5503 |     |             mstore(0x60, p2)
  5504 |     |             mstore(0x80, 0x80)
  5505 |     |             writeString(0xa0, p3)
  5506 |     |         }
  5507 |     |         _sendLogPayload(0x1c, 0xc4);
  5508 |     |         assembly {
  5509 |     |             mstore(0x00, m0)
  5510 |     |             mstore(0x20, m1)
  5511 |     |             mstore(0x40, m2)
  5512 |     |             mstore(0x60, m3)
  5513 |     |             mstore(0x80, m4)
  5514 |     |             mstore(0xa0, m5)
  5515 |     |             mstore(0xc0, m6)
  5516 |     |         }
  5517 |     |     }
  5518 |     | 
  5519 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
  5520 |     |         bytes32 m0;
  5521 |     |         bytes32 m1;
  5522 |     |         bytes32 m2;
  5523 |     |         bytes32 m3;
  5524 |     |         bytes32 m4;
  5525 |     |         assembly {
  5526 |     |             m0 := mload(0x00)
  5527 |     |             m1 := mload(0x20)
  5528 |     |             m2 := mload(0x40)
  5529 |     |             m3 := mload(0x60)
  5530 |     |             m4 := mload(0x80)
  5531 |     |             // Selector of `log(bool,address,uint256,address)`.
  5532 |     |             mstore(0x00, 0x136b05dd)
  5533 |     |             mstore(0x20, p0)
  5534 |     |             mstore(0x40, p1)
  5535 |     |             mstore(0x60, p2)
  5536 |     |             mstore(0x80, p3)
  5537 |     |         }
  5538 |     |         _sendLogPayload(0x1c, 0x84);
  5539 |     |         assembly {
  5540 |     |             mstore(0x00, m0)
  5541 |     |             mstore(0x20, m1)
  5542 |     |             mstore(0x40, m2)
  5543 |     |             mstore(0x60, m3)
  5544 |     |             mstore(0x80, m4)
  5545 |     |         }
  5546 |     |     }
  5547 |     | 
  5548 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
  5549 |     |         bytes32 m0;
  5550 |     |         bytes32 m1;
  5551 |     |         bytes32 m2;
  5552 |     |         bytes32 m3;
  5553 |     |         bytes32 m4;
  5554 |     |         assembly {
  5555 |     |             m0 := mload(0x00)
  5556 |     |             m1 := mload(0x20)
  5557 |     |             m2 := mload(0x40)
  5558 |     |             m3 := mload(0x60)
  5559 |     |             m4 := mload(0x80)
  5560 |     |             // Selector of `log(bool,address,uint256,bool)`.
  5561 |     |             mstore(0x00, 0xd6019f1c)
  5562 |     |             mstore(0x20, p0)
  5563 |     |             mstore(0x40, p1)
  5564 |     |             mstore(0x60, p2)
  5565 |     |             mstore(0x80, p3)
  5566 |     |         }
  5567 |     |         _sendLogPayload(0x1c, 0x84);
  5568 |     |         assembly {
  5569 |     |             mstore(0x00, m0)
  5570 |     |             mstore(0x20, m1)
  5571 |     |             mstore(0x40, m2)
  5572 |     |             mstore(0x60, m3)
  5573 |     |             mstore(0x80, m4)
  5574 |     |         }
  5575 |     |     }
  5576 |     | 
  5577 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
  5578 |     |         bytes32 m0;
  5579 |     |         bytes32 m1;
  5580 |     |         bytes32 m2;
  5581 |     |         bytes32 m3;
  5582 |     |         bytes32 m4;
  5583 |     |         assembly {
  5584 |     |             m0 := mload(0x00)
  5585 |     |             m1 := mload(0x20)
  5586 |     |             m2 := mload(0x40)
  5587 |     |             m3 := mload(0x60)
  5588 |     |             m4 := mload(0x80)
  5589 |     |             // Selector of `log(bool,address,uint256,uint256)`.
  5590 |     |             mstore(0x00, 0x7bf181a1)
  5591 |     |             mstore(0x20, p0)
  5592 |     |             mstore(0x40, p1)
  5593 |     |             mstore(0x60, p2)
  5594 |     |             mstore(0x80, p3)
  5595 |     |         }
  5596 |     |         _sendLogPayload(0x1c, 0x84);
  5597 |     |         assembly {
  5598 |     |             mstore(0x00, m0)
  5599 |     |             mstore(0x20, m1)
  5600 |     |             mstore(0x40, m2)
  5601 |     |             mstore(0x60, m3)
  5602 |     |             mstore(0x80, m4)
  5603 |     |         }
  5604 |     |     }
  5605 |     | 
  5606 |     |     function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {
  5607 |     |         bytes32 m0;
  5608 |     |         bytes32 m1;
  5609 |     |         bytes32 m2;
  5610 |     |         bytes32 m3;
  5611 |     |         bytes32 m4;
  5612 |     |         bytes32 m5;
  5613 |     |         bytes32 m6;
  5614 |     |         assembly {
  5615 |     |             function writeString(pos, w) {
  5616 |     |                 let length := 0
  5617 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5618 |     |                 mstore(pos, length)
  5619 |     |                 let shift := sub(256, shl(3, length))
  5620 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5621 |     |             }
  5622 |     |             m0 := mload(0x00)
  5623 |     |             m1 := mload(0x20)
  5624 |     |             m2 := mload(0x40)
  5625 |     |             m3 := mload(0x60)
  5626 |     |             m4 := mload(0x80)
  5627 |     |             m5 := mload(0xa0)
  5628 |     |             m6 := mload(0xc0)
  5629 |     |             // Selector of `log(bool,address,uint256,string)`.
  5630 |     |             mstore(0x00, 0x51f09ff8)
  5631 |     |             mstore(0x20, p0)
  5632 |     |             mstore(0x40, p1)
  5633 |     |             mstore(0x60, p2)
  5634 |     |             mstore(0x80, 0x80)
  5635 |     |             writeString(0xa0, p3)
  5636 |     |         }
  5637 |     |         _sendLogPayload(0x1c, 0xc4);
  5638 |     |         assembly {
  5639 |     |             mstore(0x00, m0)
  5640 |     |             mstore(0x20, m1)
  5641 |     |             mstore(0x40, m2)
  5642 |     |             mstore(0x60, m3)
  5643 |     |             mstore(0x80, m4)
  5644 |     |             mstore(0xa0, m5)
  5645 |     |             mstore(0xc0, m6)
  5646 |     |         }
  5647 |     |     }
  5648 |     | 
  5649 |     |     function log(bool p0, address p1, bytes32 p2, address p3) internal pure {
  5650 |     |         bytes32 m0;
  5651 |     |         bytes32 m1;
  5652 |     |         bytes32 m2;
  5653 |     |         bytes32 m3;
  5654 |     |         bytes32 m4;
  5655 |     |         bytes32 m5;
  5656 |     |         bytes32 m6;
  5657 |     |         assembly {
  5658 |     |             function writeString(pos, w) {
  5659 |     |                 let length := 0
  5660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5661 |     |                 mstore(pos, length)
  5662 |     |                 let shift := sub(256, shl(3, length))
  5663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5664 |     |             }
  5665 |     |             m0 := mload(0x00)
  5666 |     |             m1 := mload(0x20)
  5667 |     |             m2 := mload(0x40)
  5668 |     |             m3 := mload(0x60)
  5669 |     |             m4 := mload(0x80)
  5670 |     |             m5 := mload(0xa0)
  5671 |     |             m6 := mload(0xc0)
  5672 |     |             // Selector of `log(bool,address,string,address)`.
  5673 |     |             mstore(0x00, 0x6f7c603e)
  5674 |     |             mstore(0x20, p0)
  5675 |     |             mstore(0x40, p1)
  5676 |     |             mstore(0x60, 0x80)
  5677 |     |             mstore(0x80, p3)
  5678 |     |             writeString(0xa0, p2)
  5679 |     |         }
  5680 |     |         _sendLogPayload(0x1c, 0xc4);
  5681 |     |         assembly {
  5682 |     |             mstore(0x00, m0)
  5683 |     |             mstore(0x20, m1)
  5684 |     |             mstore(0x40, m2)
  5685 |     |             mstore(0x60, m3)
  5686 |     |             mstore(0x80, m4)
  5687 |     |             mstore(0xa0, m5)
  5688 |     |             mstore(0xc0, m6)
  5689 |     |         }
  5690 |     |     }
  5691 |     | 
  5692 |     |     function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {
  5693 |     |         bytes32 m0;
  5694 |     |         bytes32 m1;
  5695 |     |         bytes32 m2;
  5696 |     |         bytes32 m3;
  5697 |     |         bytes32 m4;
  5698 |     |         bytes32 m5;
  5699 |     |         bytes32 m6;
  5700 |     |         assembly {
  5701 |     |             function writeString(pos, w) {
  5702 |     |                 let length := 0
  5703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5704 |     |                 mstore(pos, length)
  5705 |     |                 let shift := sub(256, shl(3, length))
  5706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5707 |     |             }
  5708 |     |             m0 := mload(0x00)
  5709 |     |             m1 := mload(0x20)
  5710 |     |             m2 := mload(0x40)
  5711 |     |             m3 := mload(0x60)
  5712 |     |             m4 := mload(0x80)
  5713 |     |             m5 := mload(0xa0)
  5714 |     |             m6 := mload(0xc0)
  5715 |     |             // Selector of `log(bool,address,string,bool)`.
  5716 |     |             mstore(0x00, 0xe2bfd60b)
  5717 |     |             mstore(0x20, p0)
  5718 |     |             mstore(0x40, p1)
  5719 |     |             mstore(0x60, 0x80)
  5720 |     |             mstore(0x80, p3)
  5721 |     |             writeString(0xa0, p2)
  5722 |     |         }
  5723 |     |         _sendLogPayload(0x1c, 0xc4);
  5724 |     |         assembly {
  5725 |     |             mstore(0x00, m0)
  5726 |     |             mstore(0x20, m1)
  5727 |     |             mstore(0x40, m2)
  5728 |     |             mstore(0x60, m3)
  5729 |     |             mstore(0x80, m4)
  5730 |     |             mstore(0xa0, m5)
  5731 |     |             mstore(0xc0, m6)
  5732 |     |         }
  5733 |     |     }
  5734 |     | 
  5735 |     |     function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {
  5736 |     |         bytes32 m0;
  5737 |     |         bytes32 m1;
  5738 |     |         bytes32 m2;
  5739 |     |         bytes32 m3;
  5740 |     |         bytes32 m4;
  5741 |     |         bytes32 m5;
  5742 |     |         bytes32 m6;
  5743 |     |         assembly {
  5744 |     |             function writeString(pos, w) {
  5745 |     |                 let length := 0
  5746 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5747 |     |                 mstore(pos, length)
  5748 |     |                 let shift := sub(256, shl(3, length))
  5749 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5750 |     |             }
  5751 |     |             m0 := mload(0x00)
  5752 |     |             m1 := mload(0x20)
  5753 |     |             m2 := mload(0x40)
  5754 |     |             m3 := mload(0x60)
  5755 |     |             m4 := mload(0x80)
  5756 |     |             m5 := mload(0xa0)
  5757 |     |             m6 := mload(0xc0)
  5758 |     |             // Selector of `log(bool,address,string,uint256)`.
  5759 |     |             mstore(0x00, 0xc21f64c7)
  5760 |     |             mstore(0x20, p0)
  5761 |     |             mstore(0x40, p1)
  5762 |     |             mstore(0x60, 0x80)
  5763 |     |             mstore(0x80, p3)
  5764 |     |             writeString(0xa0, p2)
  5765 |     |         }
  5766 |     |         _sendLogPayload(0x1c, 0xc4);
  5767 |     |         assembly {
  5768 |     |             mstore(0x00, m0)
  5769 |     |             mstore(0x20, m1)
  5770 |     |             mstore(0x40, m2)
  5771 |     |             mstore(0x60, m3)
  5772 |     |             mstore(0x80, m4)
  5773 |     |             mstore(0xa0, m5)
  5774 |     |             mstore(0xc0, m6)
  5775 |     |         }
  5776 |     |     }
  5777 |     | 
  5778 |     |     function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  5779 |     |         bytes32 m0;
  5780 |     |         bytes32 m1;
  5781 |     |         bytes32 m2;
  5782 |     |         bytes32 m3;
  5783 |     |         bytes32 m4;
  5784 |     |         bytes32 m5;
  5785 |     |         bytes32 m6;
  5786 |     |         bytes32 m7;
  5787 |     |         bytes32 m8;
  5788 |     |         assembly {
  5789 |     |             function writeString(pos, w) {
  5790 |     |                 let length := 0
  5791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5792 |     |                 mstore(pos, length)
  5793 |     |                 let shift := sub(256, shl(3, length))
  5794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5795 |     |             }
  5796 |     |             m0 := mload(0x00)
  5797 |     |             m1 := mload(0x20)
  5798 |     |             m2 := mload(0x40)
  5799 |     |             m3 := mload(0x60)
  5800 |     |             m4 := mload(0x80)
  5801 |     |             m5 := mload(0xa0)
  5802 |     |             m6 := mload(0xc0)
  5803 |     |             m7 := mload(0xe0)
  5804 |     |             m8 := mload(0x100)
  5805 |     |             // Selector of `log(bool,address,string,string)`.
  5806 |     |             mstore(0x00, 0xa73c1db6)
  5807 |     |             mstore(0x20, p0)
  5808 |     |             mstore(0x40, p1)
  5809 |     |             mstore(0x60, 0x80)
  5810 |     |             mstore(0x80, 0xc0)
  5811 |     |             writeString(0xa0, p2)
  5812 |     |             writeString(0xe0, p3)
  5813 |     |         }
  5814 |     |         _sendLogPayload(0x1c, 0x104);
  5815 |     |         assembly {
  5816 |     |             mstore(0x00, m0)
  5817 |     |             mstore(0x20, m1)
  5818 |     |             mstore(0x40, m2)
  5819 |     |             mstore(0x60, m3)
  5820 |     |             mstore(0x80, m4)
  5821 |     |             mstore(0xa0, m5)
  5822 |     |             mstore(0xc0, m6)
  5823 |     |             mstore(0xe0, m7)
  5824 |     |             mstore(0x100, m8)
  5825 |     |         }
  5826 |     |     }
  5827 |     | 
  5828 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
  5829 |     |         bytes32 m0;
  5830 |     |         bytes32 m1;
  5831 |     |         bytes32 m2;
  5832 |     |         bytes32 m3;
  5833 |     |         bytes32 m4;
  5834 |     |         assembly {
  5835 |     |             m0 := mload(0x00)
  5836 |     |             m1 := mload(0x20)
  5837 |     |             m2 := mload(0x40)
  5838 |     |             m3 := mload(0x60)
  5839 |     |             m4 := mload(0x80)
  5840 |     |             // Selector of `log(bool,bool,address,address)`.
  5841 |     |             mstore(0x00, 0xf4880ea4)
  5842 |     |             mstore(0x20, p0)
  5843 |     |             mstore(0x40, p1)
  5844 |     |             mstore(0x60, p2)
  5845 |     |             mstore(0x80, p3)
  5846 |     |         }
  5847 |     |         _sendLogPayload(0x1c, 0x84);
  5848 |     |         assembly {
  5849 |     |             mstore(0x00, m0)
  5850 |     |             mstore(0x20, m1)
  5851 |     |             mstore(0x40, m2)
  5852 |     |             mstore(0x60, m3)
  5853 |     |             mstore(0x80, m4)
  5854 |     |         }
  5855 |     |     }
  5856 |     | 
  5857 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
  5858 |     |         bytes32 m0;
  5859 |     |         bytes32 m1;
  5860 |     |         bytes32 m2;
  5861 |     |         bytes32 m3;
  5862 |     |         bytes32 m4;
  5863 |     |         assembly {
  5864 |     |             m0 := mload(0x00)
  5865 |     |             m1 := mload(0x20)
  5866 |     |             m2 := mload(0x40)
  5867 |     |             m3 := mload(0x60)
  5868 |     |             m4 := mload(0x80)
  5869 |     |             // Selector of `log(bool,bool,address,bool)`.
  5870 |     |             mstore(0x00, 0xc0a302d8)
  5871 |     |             mstore(0x20, p0)
  5872 |     |             mstore(0x40, p1)
  5873 |     |             mstore(0x60, p2)
  5874 |     |             mstore(0x80, p3)
  5875 |     |         }
  5876 |     |         _sendLogPayload(0x1c, 0x84);
  5877 |     |         assembly {
  5878 |     |             mstore(0x00, m0)
  5879 |     |             mstore(0x20, m1)
  5880 |     |             mstore(0x40, m2)
  5881 |     |             mstore(0x60, m3)
  5882 |     |             mstore(0x80, m4)
  5883 |     |         }
  5884 |     |     }
  5885 |     | 
  5886 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
  5887 |     |         bytes32 m0;
  5888 |     |         bytes32 m1;
  5889 |     |         bytes32 m2;
  5890 |     |         bytes32 m3;
  5891 |     |         bytes32 m4;
  5892 |     |         assembly {
  5893 |     |             m0 := mload(0x00)
  5894 |     |             m1 := mload(0x20)
  5895 |     |             m2 := mload(0x40)
  5896 |     |             m3 := mload(0x60)
  5897 |     |             m4 := mload(0x80)
  5898 |     |             // Selector of `log(bool,bool,address,uint256)`.
  5899 |     |             mstore(0x00, 0x4c123d57)
  5900 |     |             mstore(0x20, p0)
  5901 |     |             mstore(0x40, p1)
  5902 |     |             mstore(0x60, p2)
  5903 |     |             mstore(0x80, p3)
  5904 |     |         }
  5905 |     |         _sendLogPayload(0x1c, 0x84);
  5906 |     |         assembly {
  5907 |     |             mstore(0x00, m0)
  5908 |     |             mstore(0x20, m1)
  5909 |     |             mstore(0x40, m2)
  5910 |     |             mstore(0x60, m3)
  5911 |     |             mstore(0x80, m4)
  5912 |     |         }
  5913 |     |     }
  5914 |     | 
  5915 |     |     function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {
  5916 |     |         bytes32 m0;
  5917 |     |         bytes32 m1;
  5918 |     |         bytes32 m2;
  5919 |     |         bytes32 m3;
  5920 |     |         bytes32 m4;
  5921 |     |         bytes32 m5;
  5922 |     |         bytes32 m6;
  5923 |     |         assembly {
  5924 |     |             function writeString(pos, w) {
  5925 |     |                 let length := 0
  5926 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5927 |     |                 mstore(pos, length)
  5928 |     |                 let shift := sub(256, shl(3, length))
  5929 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5930 |     |             }
  5931 |     |             m0 := mload(0x00)
  5932 |     |             m1 := mload(0x20)
  5933 |     |             m2 := mload(0x40)
  5934 |     |             m3 := mload(0x60)
  5935 |     |             m4 := mload(0x80)
  5936 |     |             m5 := mload(0xa0)
  5937 |     |             m6 := mload(0xc0)
  5938 |     |             // Selector of `log(bool,bool,address,string)`.
  5939 |     |             mstore(0x00, 0xa0a47963)
  5940 |     |             mstore(0x20, p0)
  5941 |     |             mstore(0x40, p1)
  5942 |     |             mstore(0x60, p2)
  5943 |     |             mstore(0x80, 0x80)
  5944 |     |             writeString(0xa0, p3)
  5945 |     |         }
  5946 |     |         _sendLogPayload(0x1c, 0xc4);
  5947 |     |         assembly {
  5948 |     |             mstore(0x00, m0)
  5949 |     |             mstore(0x20, m1)
  5950 |     |             mstore(0x40, m2)
  5951 |     |             mstore(0x60, m3)
  5952 |     |             mstore(0x80, m4)
  5953 |     |             mstore(0xa0, m5)
  5954 |     |             mstore(0xc0, m6)
  5955 |     |         }
  5956 |     |     }
  5957 |     | 
  5958 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
  5959 |     |         bytes32 m0;
  5960 |     |         bytes32 m1;
  5961 |     |         bytes32 m2;
  5962 |     |         bytes32 m3;
  5963 |     |         bytes32 m4;
  5964 |     |         assembly {
  5965 |     |             m0 := mload(0x00)
  5966 |     |             m1 := mload(0x20)
  5967 |     |             m2 := mload(0x40)
  5968 |     |             m3 := mload(0x60)
  5969 |     |             m4 := mload(0x80)
  5970 |     |             // Selector of `log(bool,bool,bool,address)`.
  5971 |     |             mstore(0x00, 0x8c329b1a)
  5972 |     |             mstore(0x20, p0)
  5973 |     |             mstore(0x40, p1)
  5974 |     |             mstore(0x60, p2)
  5975 |     |             mstore(0x80, p3)
  5976 |     |         }
  5977 |     |         _sendLogPayload(0x1c, 0x84);
  5978 |     |         assembly {
  5979 |     |             mstore(0x00, m0)
  5980 |     |             mstore(0x20, m1)
  5981 |     |             mstore(0x40, m2)
  5982 |     |             mstore(0x60, m3)
  5983 |     |             mstore(0x80, m4)
  5984 |     |         }
  5985 |     |     }
  5986 |     | 
  5987 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
  5988 |     |         bytes32 m0;
  5989 |     |         bytes32 m1;
  5990 |     |         bytes32 m2;
  5991 |     |         bytes32 m3;
  5992 |     |         bytes32 m4;
  5993 |     |         assembly {
  5994 |     |             m0 := mload(0x00)
  5995 |     |             m1 := mload(0x20)
  5996 |     |             m2 := mload(0x40)
  5997 |     |             m3 := mload(0x60)
  5998 |     |             m4 := mload(0x80)
  5999 |     |             // Selector of `log(bool,bool,bool,bool)`.
  6000 |     |             mstore(0x00, 0x3b2a5ce0)
  6001 |     |             mstore(0x20, p0)
  6002 |     |             mstore(0x40, p1)
  6003 |     |             mstore(0x60, p2)
  6004 |     |             mstore(0x80, p3)
  6005 |     |         }
  6006 |     |         _sendLogPayload(0x1c, 0x84);
  6007 |     |         assembly {
  6008 |     |             mstore(0x00, m0)
  6009 |     |             mstore(0x20, m1)
  6010 |     |             mstore(0x40, m2)
  6011 |     |             mstore(0x60, m3)
  6012 |     |             mstore(0x80, m4)
  6013 |     |         }
  6014 |     |     }
  6015 |     | 
  6016 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
  6017 |     |         bytes32 m0;
  6018 |     |         bytes32 m1;
  6019 |     |         bytes32 m2;
  6020 |     |         bytes32 m3;
  6021 |     |         bytes32 m4;
  6022 |     |         assembly {
  6023 |     |             m0 := mload(0x00)
  6024 |     |             m1 := mload(0x20)
  6025 |     |             m2 := mload(0x40)
  6026 |     |             m3 := mload(0x60)
  6027 |     |             m4 := mload(0x80)
  6028 |     |             // Selector of `log(bool,bool,bool,uint256)`.
  6029 |     |             mstore(0x00, 0x6d7045c1)
  6030 |     |             mstore(0x20, p0)
  6031 |     |             mstore(0x40, p1)
  6032 |     |             mstore(0x60, p2)
  6033 |     |             mstore(0x80, p3)
  6034 |     |         }
  6035 |     |         _sendLogPayload(0x1c, 0x84);
  6036 |     |         assembly {
  6037 |     |             mstore(0x00, m0)
  6038 |     |             mstore(0x20, m1)
  6039 |     |             mstore(0x40, m2)
  6040 |     |             mstore(0x60, m3)
  6041 |     |             mstore(0x80, m4)
  6042 |     |         }
  6043 |     |     }
  6044 |     | 
  6045 |     |     function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {
  6046 |     |         bytes32 m0;
  6047 |     |         bytes32 m1;
  6048 |     |         bytes32 m2;
  6049 |     |         bytes32 m3;
  6050 |     |         bytes32 m4;
  6051 |     |         bytes32 m5;
  6052 |     |         bytes32 m6;
  6053 |     |         assembly {
  6054 |     |             function writeString(pos, w) {
  6055 |     |                 let length := 0
  6056 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6057 |     |                 mstore(pos, length)
  6058 |     |                 let shift := sub(256, shl(3, length))
  6059 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6060 |     |             }
  6061 |     |             m0 := mload(0x00)
  6062 |     |             m1 := mload(0x20)
  6063 |     |             m2 := mload(0x40)
  6064 |     |             m3 := mload(0x60)
  6065 |     |             m4 := mload(0x80)
  6066 |     |             m5 := mload(0xa0)
  6067 |     |             m6 := mload(0xc0)
  6068 |     |             // Selector of `log(bool,bool,bool,string)`.
  6069 |     |             mstore(0x00, 0x2ae408d4)
  6070 |     |             mstore(0x20, p0)
  6071 |     |             mstore(0x40, p1)
  6072 |     |             mstore(0x60, p2)
  6073 |     |             mstore(0x80, 0x80)
  6074 |     |             writeString(0xa0, p3)
  6075 |     |         }
  6076 |     |         _sendLogPayload(0x1c, 0xc4);
  6077 |     |         assembly {
  6078 |     |             mstore(0x00, m0)
  6079 |     |             mstore(0x20, m1)
  6080 |     |             mstore(0x40, m2)
  6081 |     |             mstore(0x60, m3)
  6082 |     |             mstore(0x80, m4)
  6083 |     |             mstore(0xa0, m5)
  6084 |     |             mstore(0xc0, m6)
  6085 |     |         }
  6086 |     |     }
  6087 |     | 
  6088 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
  6089 |     |         bytes32 m0;
  6090 |     |         bytes32 m1;
  6091 |     |         bytes32 m2;
  6092 |     |         bytes32 m3;
  6093 |     |         bytes32 m4;
  6094 |     |         assembly {
  6095 |     |             m0 := mload(0x00)
  6096 |     |             m1 := mload(0x20)
  6097 |     |             m2 := mload(0x40)
  6098 |     |             m3 := mload(0x60)
  6099 |     |             m4 := mload(0x80)
  6100 |     |             // Selector of `log(bool,bool,uint256,address)`.
  6101 |     |             mstore(0x00, 0x54a7a9a0)
  6102 |     |             mstore(0x20, p0)
  6103 |     |             mstore(0x40, p1)
  6104 |     |             mstore(0x60, p2)
  6105 |     |             mstore(0x80, p3)
  6106 |     |         }
  6107 |     |         _sendLogPayload(0x1c, 0x84);
  6108 |     |         assembly {
  6109 |     |             mstore(0x00, m0)
  6110 |     |             mstore(0x20, m1)
  6111 |     |             mstore(0x40, m2)
  6112 |     |             mstore(0x60, m3)
  6113 |     |             mstore(0x80, m4)
  6114 |     |         }
  6115 |     |     }
  6116 |     | 
  6117 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
  6118 |     |         bytes32 m0;
  6119 |     |         bytes32 m1;
  6120 |     |         bytes32 m2;
  6121 |     |         bytes32 m3;
  6122 |     |         bytes32 m4;
  6123 |     |         assembly {
  6124 |     |             m0 := mload(0x00)
  6125 |     |             m1 := mload(0x20)
  6126 |     |             m2 := mload(0x40)
  6127 |     |             m3 := mload(0x60)
  6128 |     |             m4 := mload(0x80)
  6129 |     |             // Selector of `log(bool,bool,uint256,bool)`.
  6130 |     |             mstore(0x00, 0x619e4d0e)
  6131 |     |             mstore(0x20, p0)
  6132 |     |             mstore(0x40, p1)
  6133 |     |             mstore(0x60, p2)
  6134 |     |             mstore(0x80, p3)
  6135 |     |         }
  6136 |     |         _sendLogPayload(0x1c, 0x84);
  6137 |     |         assembly {
  6138 |     |             mstore(0x00, m0)
  6139 |     |             mstore(0x20, m1)
  6140 |     |             mstore(0x40, m2)
  6141 |     |             mstore(0x60, m3)
  6142 |     |             mstore(0x80, m4)
  6143 |     |         }
  6144 |     |     }
  6145 |     | 
  6146 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
  6147 |     |         bytes32 m0;
  6148 |     |         bytes32 m1;
  6149 |     |         bytes32 m2;
  6150 |     |         bytes32 m3;
  6151 |     |         bytes32 m4;
  6152 |     |         assembly {
  6153 |     |             m0 := mload(0x00)
  6154 |     |             m1 := mload(0x20)
  6155 |     |             m2 := mload(0x40)
  6156 |     |             m3 := mload(0x60)
  6157 |     |             m4 := mload(0x80)
  6158 |     |             // Selector of `log(bool,bool,uint256,uint256)`.
  6159 |     |             mstore(0x00, 0x0bb00eab)
  6160 |     |             mstore(0x20, p0)
  6161 |     |             mstore(0x40, p1)
  6162 |     |             mstore(0x60, p2)
  6163 |     |             mstore(0x80, p3)
  6164 |     |         }
  6165 |     |         _sendLogPayload(0x1c, 0x84);
  6166 |     |         assembly {
  6167 |     |             mstore(0x00, m0)
  6168 |     |             mstore(0x20, m1)
  6169 |     |             mstore(0x40, m2)
  6170 |     |             mstore(0x60, m3)
  6171 |     |             mstore(0x80, m4)
  6172 |     |         }
  6173 |     |     }
  6174 |     | 
  6175 |     |     function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  6176 |     |         bytes32 m0;
  6177 |     |         bytes32 m1;
  6178 |     |         bytes32 m2;
  6179 |     |         bytes32 m3;
  6180 |     |         bytes32 m4;
  6181 |     |         bytes32 m5;
  6182 |     |         bytes32 m6;
  6183 |     |         assembly {
  6184 |     |             function writeString(pos, w) {
  6185 |     |                 let length := 0
  6186 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6187 |     |                 mstore(pos, length)
  6188 |     |                 let shift := sub(256, shl(3, length))
  6189 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6190 |     |             }
  6191 |     |             m0 := mload(0x00)
  6192 |     |             m1 := mload(0x20)
  6193 |     |             m2 := mload(0x40)
  6194 |     |             m3 := mload(0x60)
  6195 |     |             m4 := mload(0x80)
  6196 |     |             m5 := mload(0xa0)
  6197 |     |             m6 := mload(0xc0)
  6198 |     |             // Selector of `log(bool,bool,uint256,string)`.
  6199 |     |             mstore(0x00, 0x7dd4d0e0)
  6200 |     |             mstore(0x20, p0)
  6201 |     |             mstore(0x40, p1)
  6202 |     |             mstore(0x60, p2)
  6203 |     |             mstore(0x80, 0x80)
  6204 |     |             writeString(0xa0, p3)
  6205 |     |         }
  6206 |     |         _sendLogPayload(0x1c, 0xc4);
  6207 |     |         assembly {
  6208 |     |             mstore(0x00, m0)
  6209 |     |             mstore(0x20, m1)
  6210 |     |             mstore(0x40, m2)
  6211 |     |             mstore(0x60, m3)
  6212 |     |             mstore(0x80, m4)
  6213 |     |             mstore(0xa0, m5)
  6214 |     |             mstore(0xc0, m6)
  6215 |     |         }
  6216 |     |     }
  6217 |     | 
  6218 |     |     function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {
  6219 |     |         bytes32 m0;
  6220 |     |         bytes32 m1;
  6221 |     |         bytes32 m2;
  6222 |     |         bytes32 m3;
  6223 |     |         bytes32 m4;
  6224 |     |         bytes32 m5;
  6225 |     |         bytes32 m6;
  6226 |     |         assembly {
  6227 |     |             function writeString(pos, w) {
  6228 |     |                 let length := 0
  6229 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6230 |     |                 mstore(pos, length)
  6231 |     |                 let shift := sub(256, shl(3, length))
  6232 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6233 |     |             }
  6234 |     |             m0 := mload(0x00)
  6235 |     |             m1 := mload(0x20)
  6236 |     |             m2 := mload(0x40)
  6237 |     |             m3 := mload(0x60)
  6238 |     |             m4 := mload(0x80)
  6239 |     |             m5 := mload(0xa0)
  6240 |     |             m6 := mload(0xc0)
  6241 |     |             // Selector of `log(bool,bool,string,address)`.
  6242 |     |             mstore(0x00, 0xf9ad2b89)
  6243 |     |             mstore(0x20, p0)
  6244 |     |             mstore(0x40, p1)
  6245 |     |             mstore(0x60, 0x80)
  6246 |     |             mstore(0x80, p3)
  6247 |     |             writeString(0xa0, p2)
  6248 |     |         }
  6249 |     |         _sendLogPayload(0x1c, 0xc4);
  6250 |     |         assembly {
  6251 |     |             mstore(0x00, m0)
  6252 |     |             mstore(0x20, m1)
  6253 |     |             mstore(0x40, m2)
  6254 |     |             mstore(0x60, m3)
  6255 |     |             mstore(0x80, m4)
  6256 |     |             mstore(0xa0, m5)
  6257 |     |             mstore(0xc0, m6)
  6258 |     |         }
  6259 |     |     }
  6260 |     | 
  6261 |     |     function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {
  6262 |     |         bytes32 m0;
  6263 |     |         bytes32 m1;
  6264 |     |         bytes32 m2;
  6265 |     |         bytes32 m3;
  6266 |     |         bytes32 m4;
  6267 |     |         bytes32 m5;
  6268 |     |         bytes32 m6;
  6269 |     |         assembly {
  6270 |     |             function writeString(pos, w) {
  6271 |     |                 let length := 0
  6272 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6273 |     |                 mstore(pos, length)
  6274 |     |                 let shift := sub(256, shl(3, length))
  6275 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6276 |     |             }
  6277 |     |             m0 := mload(0x00)
  6278 |     |             m1 := mload(0x20)
  6279 |     |             m2 := mload(0x40)
  6280 |     |             m3 := mload(0x60)
  6281 |     |             m4 := mload(0x80)
  6282 |     |             m5 := mload(0xa0)
  6283 |     |             m6 := mload(0xc0)
  6284 |     |             // Selector of `log(bool,bool,string,bool)`.
  6285 |     |             mstore(0x00, 0xb857163a)
  6286 |     |             mstore(0x20, p0)
  6287 |     |             mstore(0x40, p1)
  6288 |     |             mstore(0x60, 0x80)
  6289 |     |             mstore(0x80, p3)
  6290 |     |             writeString(0xa0, p2)
  6291 |     |         }
  6292 |     |         _sendLogPayload(0x1c, 0xc4);
  6293 |     |         assembly {
  6294 |     |             mstore(0x00, m0)
  6295 |     |             mstore(0x20, m1)
  6296 |     |             mstore(0x40, m2)
  6297 |     |             mstore(0x60, m3)
  6298 |     |             mstore(0x80, m4)
  6299 |     |             mstore(0xa0, m5)
  6300 |     |             mstore(0xc0, m6)
  6301 |     |         }
  6302 |     |     }
  6303 |     | 
  6304 |     |     function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  6305 |     |         bytes32 m0;
  6306 |     |         bytes32 m1;
  6307 |     |         bytes32 m2;
  6308 |     |         bytes32 m3;
  6309 |     |         bytes32 m4;
  6310 |     |         bytes32 m5;
  6311 |     |         bytes32 m6;
  6312 |     |         assembly {
  6313 |     |             function writeString(pos, w) {
  6314 |     |                 let length := 0
  6315 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6316 |     |                 mstore(pos, length)
  6317 |     |                 let shift := sub(256, shl(3, length))
  6318 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6319 |     |             }
  6320 |     |             m0 := mload(0x00)
  6321 |     |             m1 := mload(0x20)
  6322 |     |             m2 := mload(0x40)
  6323 |     |             m3 := mload(0x60)
  6324 |     |             m4 := mload(0x80)
  6325 |     |             m5 := mload(0xa0)
  6326 |     |             m6 := mload(0xc0)
  6327 |     |             // Selector of `log(bool,bool,string,uint256)`.
  6328 |     |             mstore(0x00, 0xe3a9ca2f)
  6329 |     |             mstore(0x20, p0)
  6330 |     |             mstore(0x40, p1)
  6331 |     |             mstore(0x60, 0x80)
  6332 |     |             mstore(0x80, p3)
  6333 |     |             writeString(0xa0, p2)
  6334 |     |         }
  6335 |     |         _sendLogPayload(0x1c, 0xc4);
  6336 |     |         assembly {
  6337 |     |             mstore(0x00, m0)
  6338 |     |             mstore(0x20, m1)
  6339 |     |             mstore(0x40, m2)
  6340 |     |             mstore(0x60, m3)
  6341 |     |             mstore(0x80, m4)
  6342 |     |             mstore(0xa0, m5)
  6343 |     |             mstore(0xc0, m6)
  6344 |     |         }
  6345 |     |     }
  6346 |     | 
  6347 |     |     function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  6348 |     |         bytes32 m0;
  6349 |     |         bytes32 m1;
  6350 |     |         bytes32 m2;
  6351 |     |         bytes32 m3;
  6352 |     |         bytes32 m4;
  6353 |     |         bytes32 m5;
  6354 |     |         bytes32 m6;
  6355 |     |         bytes32 m7;
  6356 |     |         bytes32 m8;
  6357 |     |         assembly {
  6358 |     |             function writeString(pos, w) {
  6359 |     |                 let length := 0
  6360 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6361 |     |                 mstore(pos, length)
  6362 |     |                 let shift := sub(256, shl(3, length))
  6363 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6364 |     |             }
  6365 |     |             m0 := mload(0x00)
  6366 |     |             m1 := mload(0x20)
  6367 |     |             m2 := mload(0x40)
  6368 |     |             m3 := mload(0x60)
  6369 |     |             m4 := mload(0x80)
  6370 |     |             m5 := mload(0xa0)
  6371 |     |             m6 := mload(0xc0)
  6372 |     |             m7 := mload(0xe0)
  6373 |     |             m8 := mload(0x100)
  6374 |     |             // Selector of `log(bool,bool,string,string)`.
  6375 |     |             mstore(0x00, 0x6d1e8751)
  6376 |     |             mstore(0x20, p0)
  6377 |     |             mstore(0x40, p1)
  6378 |     |             mstore(0x60, 0x80)
  6379 |     |             mstore(0x80, 0xc0)
  6380 |     |             writeString(0xa0, p2)
  6381 |     |             writeString(0xe0, p3)
  6382 |     |         }
  6383 |     |         _sendLogPayload(0x1c, 0x104);
  6384 |     |         assembly {
  6385 |     |             mstore(0x00, m0)
  6386 |     |             mstore(0x20, m1)
  6387 |     |             mstore(0x40, m2)
  6388 |     |             mstore(0x60, m3)
  6389 |     |             mstore(0x80, m4)
  6390 |     |             mstore(0xa0, m5)
  6391 |     |             mstore(0xc0, m6)
  6392 |     |             mstore(0xe0, m7)
  6393 |     |             mstore(0x100, m8)
  6394 |     |         }
  6395 |     |     }
  6396 |     | 
  6397 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
  6398 |     |         bytes32 m0;
  6399 |     |         bytes32 m1;
  6400 |     |         bytes32 m2;
  6401 |     |         bytes32 m3;
  6402 |     |         bytes32 m4;
  6403 |     |         assembly {
  6404 |     |             m0 := mload(0x00)
  6405 |     |             m1 := mload(0x20)
  6406 |     |             m2 := mload(0x40)
  6407 |     |             m3 := mload(0x60)
  6408 |     |             m4 := mload(0x80)
  6409 |     |             // Selector of `log(bool,uint256,address,address)`.
  6410 |     |             mstore(0x00, 0x26f560a8)
  6411 |     |             mstore(0x20, p0)
  6412 |     |             mstore(0x40, p1)
  6413 |     |             mstore(0x60, p2)
  6414 |     |             mstore(0x80, p3)
  6415 |     |         }
  6416 |     |         _sendLogPayload(0x1c, 0x84);
  6417 |     |         assembly {
  6418 |     |             mstore(0x00, m0)
  6419 |     |             mstore(0x20, m1)
  6420 |     |             mstore(0x40, m2)
  6421 |     |             mstore(0x60, m3)
  6422 |     |             mstore(0x80, m4)
  6423 |     |         }
  6424 |     |     }
  6425 |     | 
  6426 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
  6427 |     |         bytes32 m0;
  6428 |     |         bytes32 m1;
  6429 |     |         bytes32 m2;
  6430 |     |         bytes32 m3;
  6431 |     |         bytes32 m4;
  6432 |     |         assembly {
  6433 |     |             m0 := mload(0x00)
  6434 |     |             m1 := mload(0x20)
  6435 |     |             m2 := mload(0x40)
  6436 |     |             m3 := mload(0x60)
  6437 |     |             m4 := mload(0x80)
  6438 |     |             // Selector of `log(bool,uint256,address,bool)`.
  6439 |     |             mstore(0x00, 0xb4c314ff)
  6440 |     |             mstore(0x20, p0)
  6441 |     |             mstore(0x40, p1)
  6442 |     |             mstore(0x60, p2)
  6443 |     |             mstore(0x80, p3)
  6444 |     |         }
  6445 |     |         _sendLogPayload(0x1c, 0x84);
  6446 |     |         assembly {
  6447 |     |             mstore(0x00, m0)
  6448 |     |             mstore(0x20, m1)
  6449 |     |             mstore(0x40, m2)
  6450 |     |             mstore(0x60, m3)
  6451 |     |             mstore(0x80, m4)
  6452 |     |         }
  6453 |     |     }
  6454 |     | 
  6455 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
  6456 |     |         bytes32 m0;
  6457 |     |         bytes32 m1;
  6458 |     |         bytes32 m2;
  6459 |     |         bytes32 m3;
  6460 |     |         bytes32 m4;
  6461 |     |         assembly {
  6462 |     |             m0 := mload(0x00)
  6463 |     |             m1 := mload(0x20)
  6464 |     |             m2 := mload(0x40)
  6465 |     |             m3 := mload(0x60)
  6466 |     |             m4 := mload(0x80)
  6467 |     |             // Selector of `log(bool,uint256,address,uint256)`.
  6468 |     |             mstore(0x00, 0x1537dc87)
  6469 |     |             mstore(0x20, p0)
  6470 |     |             mstore(0x40, p1)
  6471 |     |             mstore(0x60, p2)
  6472 |     |             mstore(0x80, p3)
  6473 |     |         }
  6474 |     |         _sendLogPayload(0x1c, 0x84);
  6475 |     |         assembly {
  6476 |     |             mstore(0x00, m0)
  6477 |     |             mstore(0x20, m1)
  6478 |     |             mstore(0x40, m2)
  6479 |     |             mstore(0x60, m3)
  6480 |     |             mstore(0x80, m4)
  6481 |     |         }
  6482 |     |     }
  6483 |     | 
  6484 |     |     function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {
  6485 |     |         bytes32 m0;
  6486 |     |         bytes32 m1;
  6487 |     |         bytes32 m2;
  6488 |     |         bytes32 m3;
  6489 |     |         bytes32 m4;
  6490 |     |         bytes32 m5;
  6491 |     |         bytes32 m6;
  6492 |     |         assembly {
  6493 |     |             function writeString(pos, w) {
  6494 |     |                 let length := 0
  6495 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6496 |     |                 mstore(pos, length)
  6497 |     |                 let shift := sub(256, shl(3, length))
  6498 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6499 |     |             }
  6500 |     |             m0 := mload(0x00)
  6501 |     |             m1 := mload(0x20)
  6502 |     |             m2 := mload(0x40)
  6503 |     |             m3 := mload(0x60)
  6504 |     |             m4 := mload(0x80)
  6505 |     |             m5 := mload(0xa0)
  6506 |     |             m6 := mload(0xc0)
  6507 |     |             // Selector of `log(bool,uint256,address,string)`.
  6508 |     |             mstore(0x00, 0x1bb3b09a)
  6509 |     |             mstore(0x20, p0)
  6510 |     |             mstore(0x40, p1)
  6511 |     |             mstore(0x60, p2)
  6512 |     |             mstore(0x80, 0x80)
  6513 |     |             writeString(0xa0, p3)
  6514 |     |         }
  6515 |     |         _sendLogPayload(0x1c, 0xc4);
  6516 |     |         assembly {
  6517 |     |             mstore(0x00, m0)
  6518 |     |             mstore(0x20, m1)
  6519 |     |             mstore(0x40, m2)
  6520 |     |             mstore(0x60, m3)
  6521 |     |             mstore(0x80, m4)
  6522 |     |             mstore(0xa0, m5)
  6523 |     |             mstore(0xc0, m6)
  6524 |     |         }
  6525 |     |     }
  6526 |     | 
  6527 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
  6528 |     |         bytes32 m0;
  6529 |     |         bytes32 m1;
  6530 |     |         bytes32 m2;
  6531 |     |         bytes32 m3;
  6532 |     |         bytes32 m4;
  6533 |     |         assembly {
  6534 |     |             m0 := mload(0x00)
  6535 |     |             m1 := mload(0x20)
  6536 |     |             m2 := mload(0x40)
  6537 |     |             m3 := mload(0x60)
  6538 |     |             m4 := mload(0x80)
  6539 |     |             // Selector of `log(bool,uint256,bool,address)`.
  6540 |     |             mstore(0x00, 0x9acd3616)
  6541 |     |             mstore(0x20, p0)
  6542 |     |             mstore(0x40, p1)
  6543 |     |             mstore(0x60, p2)
  6544 |     |             mstore(0x80, p3)
  6545 |     |         }
  6546 |     |         _sendLogPayload(0x1c, 0x84);
  6547 |     |         assembly {
  6548 |     |             mstore(0x00, m0)
  6549 |     |             mstore(0x20, m1)
  6550 |     |             mstore(0x40, m2)
  6551 |     |             mstore(0x60, m3)
  6552 |     |             mstore(0x80, m4)
  6553 |     |         }
  6554 |     |     }
  6555 |     | 
  6556 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
  6557 |     |         bytes32 m0;
  6558 |     |         bytes32 m1;
  6559 |     |         bytes32 m2;
  6560 |     |         bytes32 m3;
  6561 |     |         bytes32 m4;
  6562 |     |         assembly {
  6563 |     |             m0 := mload(0x00)
  6564 |     |             m1 := mload(0x20)
  6565 |     |             m2 := mload(0x40)
  6566 |     |             m3 := mload(0x60)
  6567 |     |             m4 := mload(0x80)
  6568 |     |             // Selector of `log(bool,uint256,bool,bool)`.
  6569 |     |             mstore(0x00, 0xceb5f4d7)
  6570 |     |             mstore(0x20, p0)
  6571 |     |             mstore(0x40, p1)
  6572 |     |             mstore(0x60, p2)
  6573 |     |             mstore(0x80, p3)
  6574 |     |         }
  6575 |     |         _sendLogPayload(0x1c, 0x84);
  6576 |     |         assembly {
  6577 |     |             mstore(0x00, m0)
  6578 |     |             mstore(0x20, m1)
  6579 |     |             mstore(0x40, m2)
  6580 |     |             mstore(0x60, m3)
  6581 |     |             mstore(0x80, m4)
  6582 |     |         }
  6583 |     |     }
  6584 |     | 
  6585 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
  6586 |     |         bytes32 m0;
  6587 |     |         bytes32 m1;
  6588 |     |         bytes32 m2;
  6589 |     |         bytes32 m3;
  6590 |     |         bytes32 m4;
  6591 |     |         assembly {
  6592 |     |             m0 := mload(0x00)
  6593 |     |             m1 := mload(0x20)
  6594 |     |             m2 := mload(0x40)
  6595 |     |             m3 := mload(0x60)
  6596 |     |             m4 := mload(0x80)
  6597 |     |             // Selector of `log(bool,uint256,bool,uint256)`.
  6598 |     |             mstore(0x00, 0x7f9bbca2)
  6599 |     |             mstore(0x20, p0)
  6600 |     |             mstore(0x40, p1)
  6601 |     |             mstore(0x60, p2)
  6602 |     |             mstore(0x80, p3)
  6603 |     |         }
  6604 |     |         _sendLogPayload(0x1c, 0x84);
  6605 |     |         assembly {
  6606 |     |             mstore(0x00, m0)
  6607 |     |             mstore(0x20, m1)
  6608 |     |             mstore(0x40, m2)
  6609 |     |             mstore(0x60, m3)
  6610 |     |             mstore(0x80, m4)
  6611 |     |         }
  6612 |     |     }
  6613 |     | 
  6614 |     |     function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  6615 |     |         bytes32 m0;
  6616 |     |         bytes32 m1;
  6617 |     |         bytes32 m2;
  6618 |     |         bytes32 m3;
  6619 |     |         bytes32 m4;
  6620 |     |         bytes32 m5;
  6621 |     |         bytes32 m6;
  6622 |     |         assembly {
  6623 |     |             function writeString(pos, w) {
  6624 |     |                 let length := 0
  6625 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6626 |     |                 mstore(pos, length)
  6627 |     |                 let shift := sub(256, shl(3, length))
  6628 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6629 |     |             }
  6630 |     |             m0 := mload(0x00)
  6631 |     |             m1 := mload(0x20)
  6632 |     |             m2 := mload(0x40)
  6633 |     |             m3 := mload(0x60)
  6634 |     |             m4 := mload(0x80)
  6635 |     |             m5 := mload(0xa0)
  6636 |     |             m6 := mload(0xc0)
  6637 |     |             // Selector of `log(bool,uint256,bool,string)`.
  6638 |     |             mstore(0x00, 0x9143dbb1)
  6639 |     |             mstore(0x20, p0)
  6640 |     |             mstore(0x40, p1)
  6641 |     |             mstore(0x60, p2)
  6642 |     |             mstore(0x80, 0x80)
  6643 |     |             writeString(0xa0, p3)
  6644 |     |         }
  6645 |     |         _sendLogPayload(0x1c, 0xc4);
  6646 |     |         assembly {
  6647 |     |             mstore(0x00, m0)
  6648 |     |             mstore(0x20, m1)
  6649 |     |             mstore(0x40, m2)
  6650 |     |             mstore(0x60, m3)
  6651 |     |             mstore(0x80, m4)
  6652 |     |             mstore(0xa0, m5)
  6653 |     |             mstore(0xc0, m6)
  6654 |     |         }
  6655 |     |     }
  6656 |     | 
  6657 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
  6658 |     |         bytes32 m0;
  6659 |     |         bytes32 m1;
  6660 |     |         bytes32 m2;
  6661 |     |         bytes32 m3;
  6662 |     |         bytes32 m4;
  6663 |     |         assembly {
  6664 |     |             m0 := mload(0x00)
  6665 |     |             m1 := mload(0x20)
  6666 |     |             m2 := mload(0x40)
  6667 |     |             m3 := mload(0x60)
  6668 |     |             m4 := mload(0x80)
  6669 |     |             // Selector of `log(bool,uint256,uint256,address)`.
  6670 |     |             mstore(0x00, 0x00dd87b9)
  6671 |     |             mstore(0x20, p0)
  6672 |     |             mstore(0x40, p1)
  6673 |     |             mstore(0x60, p2)
  6674 |     |             mstore(0x80, p3)
  6675 |     |         }
  6676 |     |         _sendLogPayload(0x1c, 0x84);
  6677 |     |         assembly {
  6678 |     |             mstore(0x00, m0)
  6679 |     |             mstore(0x20, m1)
  6680 |     |             mstore(0x40, m2)
  6681 |     |             mstore(0x60, m3)
  6682 |     |             mstore(0x80, m4)
  6683 |     |         }
  6684 |     |     }
  6685 |     | 
  6686 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
  6687 |     |         bytes32 m0;
  6688 |     |         bytes32 m1;
  6689 |     |         bytes32 m2;
  6690 |     |         bytes32 m3;
  6691 |     |         bytes32 m4;
  6692 |     |         assembly {
  6693 |     |             m0 := mload(0x00)
  6694 |     |             m1 := mload(0x20)
  6695 |     |             m2 := mload(0x40)
  6696 |     |             m3 := mload(0x60)
  6697 |     |             m4 := mload(0x80)
  6698 |     |             // Selector of `log(bool,uint256,uint256,bool)`.
  6699 |     |             mstore(0x00, 0xbe984353)
  6700 |     |             mstore(0x20, p0)
  6701 |     |             mstore(0x40, p1)
  6702 |     |             mstore(0x60, p2)
  6703 |     |             mstore(0x80, p3)
  6704 |     |         }
  6705 |     |         _sendLogPayload(0x1c, 0x84);
  6706 |     |         assembly {
  6707 |     |             mstore(0x00, m0)
  6708 |     |             mstore(0x20, m1)
  6709 |     |             mstore(0x40, m2)
  6710 |     |             mstore(0x60, m3)
  6711 |     |             mstore(0x80, m4)
  6712 |     |         }
  6713 |     |     }
  6714 |     | 
  6715 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  6716 |     |         bytes32 m0;
  6717 |     |         bytes32 m1;
  6718 |     |         bytes32 m2;
  6719 |     |         bytes32 m3;
  6720 |     |         bytes32 m4;
  6721 |     |         assembly {
  6722 |     |             m0 := mload(0x00)
  6723 |     |             m1 := mload(0x20)
  6724 |     |             m2 := mload(0x40)
  6725 |     |             m3 := mload(0x60)
  6726 |     |             m4 := mload(0x80)
  6727 |     |             // Selector of `log(bool,uint256,uint256,uint256)`.
  6728 |     |             mstore(0x00, 0x374bb4b2)
  6729 |     |             mstore(0x20, p0)
  6730 |     |             mstore(0x40, p1)
  6731 |     |             mstore(0x60, p2)
  6732 |     |             mstore(0x80, p3)
  6733 |     |         }
  6734 |     |         _sendLogPayload(0x1c, 0x84);
  6735 |     |         assembly {
  6736 |     |             mstore(0x00, m0)
  6737 |     |             mstore(0x20, m1)
  6738 |     |             mstore(0x40, m2)
  6739 |     |             mstore(0x60, m3)
  6740 |     |             mstore(0x80, m4)
  6741 |     |         }
  6742 |     |     }
  6743 |     | 
  6744 |     |     function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  6745 |     |         bytes32 m0;
  6746 |     |         bytes32 m1;
  6747 |     |         bytes32 m2;
  6748 |     |         bytes32 m3;
  6749 |     |         bytes32 m4;
  6750 |     |         bytes32 m5;
  6751 |     |         bytes32 m6;
  6752 |     |         assembly {
  6753 |     |             function writeString(pos, w) {
  6754 |     |                 let length := 0
  6755 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6756 |     |                 mstore(pos, length)
  6757 |     |                 let shift := sub(256, shl(3, length))
  6758 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6759 |     |             }
  6760 |     |             m0 := mload(0x00)
  6761 |     |             m1 := mload(0x20)
  6762 |     |             m2 := mload(0x40)
  6763 |     |             m3 := mload(0x60)
  6764 |     |             m4 := mload(0x80)
  6765 |     |             m5 := mload(0xa0)
  6766 |     |             m6 := mload(0xc0)
  6767 |     |             // Selector of `log(bool,uint256,uint256,string)`.
  6768 |     |             mstore(0x00, 0x8e69fb5d)
  6769 |     |             mstore(0x20, p0)
  6770 |     |             mstore(0x40, p1)
  6771 |     |             mstore(0x60, p2)
  6772 |     |             mstore(0x80, 0x80)
  6773 |     |             writeString(0xa0, p3)
  6774 |     |         }
  6775 |     |         _sendLogPayload(0x1c, 0xc4);
  6776 |     |         assembly {
  6777 |     |             mstore(0x00, m0)
  6778 |     |             mstore(0x20, m1)
  6779 |     |             mstore(0x40, m2)
  6780 |     |             mstore(0x60, m3)
  6781 |     |             mstore(0x80, m4)
  6782 |     |             mstore(0xa0, m5)
  6783 |     |             mstore(0xc0, m6)
  6784 |     |         }
  6785 |     |     }
  6786 |     | 
  6787 |     |     function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {
  6788 |     |         bytes32 m0;
  6789 |     |         bytes32 m1;
  6790 |     |         bytes32 m2;
  6791 |     |         bytes32 m3;
  6792 |     |         bytes32 m4;
  6793 |     |         bytes32 m5;
  6794 |     |         bytes32 m6;
  6795 |     |         assembly {
  6796 |     |             function writeString(pos, w) {
  6797 |     |                 let length := 0
  6798 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6799 |     |                 mstore(pos, length)
  6800 |     |                 let shift := sub(256, shl(3, length))
  6801 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6802 |     |             }
  6803 |     |             m0 := mload(0x00)
  6804 |     |             m1 := mload(0x20)
  6805 |     |             m2 := mload(0x40)
  6806 |     |             m3 := mload(0x60)
  6807 |     |             m4 := mload(0x80)
  6808 |     |             m5 := mload(0xa0)
  6809 |     |             m6 := mload(0xc0)
  6810 |     |             // Selector of `log(bool,uint256,string,address)`.
  6811 |     |             mstore(0x00, 0xfedd1fff)
  6812 |     |             mstore(0x20, p0)
  6813 |     |             mstore(0x40, p1)
  6814 |     |             mstore(0x60, 0x80)
  6815 |     |             mstore(0x80, p3)
  6816 |     |             writeString(0xa0, p2)
  6817 |     |         }
  6818 |     |         _sendLogPayload(0x1c, 0xc4);
  6819 |     |         assembly {
  6820 |     |             mstore(0x00, m0)
  6821 |     |             mstore(0x20, m1)
  6822 |     |             mstore(0x40, m2)
  6823 |     |             mstore(0x60, m3)
  6824 |     |             mstore(0x80, m4)
  6825 |     |             mstore(0xa0, m5)
  6826 |     |             mstore(0xc0, m6)
  6827 |     |         }
  6828 |     |     }
  6829 |     | 
  6830 |     |     function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  6831 |     |         bytes32 m0;
  6832 |     |         bytes32 m1;
  6833 |     |         bytes32 m2;
  6834 |     |         bytes32 m3;
  6835 |     |         bytes32 m4;
  6836 |     |         bytes32 m5;
  6837 |     |         bytes32 m6;
  6838 |     |         assembly {
  6839 |     |             function writeString(pos, w) {
  6840 |     |                 let length := 0
  6841 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6842 |     |                 mstore(pos, length)
  6843 |     |                 let shift := sub(256, shl(3, length))
  6844 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6845 |     |             }
  6846 |     |             m0 := mload(0x00)
  6847 |     |             m1 := mload(0x20)
  6848 |     |             m2 := mload(0x40)
  6849 |     |             m3 := mload(0x60)
  6850 |     |             m4 := mload(0x80)
  6851 |     |             m5 := mload(0xa0)
  6852 |     |             m6 := mload(0xc0)
  6853 |     |             // Selector of `log(bool,uint256,string,bool)`.
  6854 |     |             mstore(0x00, 0xe5e70b2b)
  6855 |     |             mstore(0x20, p0)
  6856 |     |             mstore(0x40, p1)
  6857 |     |             mstore(0x60, 0x80)
  6858 |     |             mstore(0x80, p3)
  6859 |     |             writeString(0xa0, p2)
  6860 |     |         }
  6861 |     |         _sendLogPayload(0x1c, 0xc4);
  6862 |     |         assembly {
  6863 |     |             mstore(0x00, m0)
  6864 |     |             mstore(0x20, m1)
  6865 |     |             mstore(0x40, m2)
  6866 |     |             mstore(0x60, m3)
  6867 |     |             mstore(0x80, m4)
  6868 |     |             mstore(0xa0, m5)
  6869 |     |             mstore(0xc0, m6)
  6870 |     |         }
  6871 |     |     }
  6872 |     | 
  6873 |     |     function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  6874 |     |         bytes32 m0;
  6875 |     |         bytes32 m1;
  6876 |     |         bytes32 m2;
  6877 |     |         bytes32 m3;
  6878 |     |         bytes32 m4;
  6879 |     |         bytes32 m5;
  6880 |     |         bytes32 m6;
  6881 |     |         assembly {
  6882 |     |             function writeString(pos, w) {
  6883 |     |                 let length := 0
  6884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6885 |     |                 mstore(pos, length)
  6886 |     |                 let shift := sub(256, shl(3, length))
  6887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6888 |     |             }
  6889 |     |             m0 := mload(0x00)
  6890 |     |             m1 := mload(0x20)
  6891 |     |             m2 := mload(0x40)
  6892 |     |             m3 := mload(0x60)
  6893 |     |             m4 := mload(0x80)
  6894 |     |             m5 := mload(0xa0)
  6895 |     |             m6 := mload(0xc0)
  6896 |     |             // Selector of `log(bool,uint256,string,uint256)`.
  6897 |     |             mstore(0x00, 0x6a1199e2)
  6898 |     |             mstore(0x20, p0)
  6899 |     |             mstore(0x40, p1)
  6900 |     |             mstore(0x60, 0x80)
  6901 |     |             mstore(0x80, p3)
  6902 |     |             writeString(0xa0, p2)
  6903 |     |         }
  6904 |     |         _sendLogPayload(0x1c, 0xc4);
  6905 |     |         assembly {
  6906 |     |             mstore(0x00, m0)
  6907 |     |             mstore(0x20, m1)
  6908 |     |             mstore(0x40, m2)
  6909 |     |             mstore(0x60, m3)
  6910 |     |             mstore(0x80, m4)
  6911 |     |             mstore(0xa0, m5)
  6912 |     |             mstore(0xc0, m6)
  6913 |     |         }
  6914 |     |     }
  6915 |     | 
  6916 |     |     function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  6917 |     |         bytes32 m0;
  6918 |     |         bytes32 m1;
  6919 |     |         bytes32 m2;
  6920 |     |         bytes32 m3;
  6921 |     |         bytes32 m4;
  6922 |     |         bytes32 m5;
  6923 |     |         bytes32 m6;
  6924 |     |         bytes32 m7;
  6925 |     |         bytes32 m8;
  6926 |     |         assembly {
  6927 |     |             function writeString(pos, w) {
  6928 |     |                 let length := 0
  6929 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6930 |     |                 mstore(pos, length)
  6931 |     |                 let shift := sub(256, shl(3, length))
  6932 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6933 |     |             }
  6934 |     |             m0 := mload(0x00)
  6935 |     |             m1 := mload(0x20)
  6936 |     |             m2 := mload(0x40)
  6937 |     |             m3 := mload(0x60)
  6938 |     |             m4 := mload(0x80)
  6939 |     |             m5 := mload(0xa0)
  6940 |     |             m6 := mload(0xc0)
  6941 |     |             m7 := mload(0xe0)
  6942 |     |             m8 := mload(0x100)
  6943 |     |             // Selector of `log(bool,uint256,string,string)`.
  6944 |     |             mstore(0x00, 0xf5bc2249)
  6945 |     |             mstore(0x20, p0)
  6946 |     |             mstore(0x40, p1)
  6947 |     |             mstore(0x60, 0x80)
  6948 |     |             mstore(0x80, 0xc0)
  6949 |     |             writeString(0xa0, p2)
  6950 |     |             writeString(0xe0, p3)
  6951 |     |         }
  6952 |     |         _sendLogPayload(0x1c, 0x104);
  6953 |     |         assembly {
  6954 |     |             mstore(0x00, m0)
  6955 |     |             mstore(0x20, m1)
  6956 |     |             mstore(0x40, m2)
  6957 |     |             mstore(0x60, m3)
  6958 |     |             mstore(0x80, m4)
  6959 |     |             mstore(0xa0, m5)
  6960 |     |             mstore(0xc0, m6)
  6961 |     |             mstore(0xe0, m7)
  6962 |     |             mstore(0x100, m8)
  6963 |     |         }
  6964 |     |     }
  6965 |     | 
  6966 |     |     function log(bool p0, bytes32 p1, address p2, address p3) internal pure {
  6967 |     |         bytes32 m0;
  6968 |     |         bytes32 m1;
  6969 |     |         bytes32 m2;
  6970 |     |         bytes32 m3;
  6971 |     |         bytes32 m4;
  6972 |     |         bytes32 m5;
  6973 |     |         bytes32 m6;
  6974 |     |         assembly {
  6975 |     |             function writeString(pos, w) {
  6976 |     |                 let length := 0
  6977 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6978 |     |                 mstore(pos, length)
  6979 |     |                 let shift := sub(256, shl(3, length))
  6980 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6981 |     |             }
  6982 |     |             m0 := mload(0x00)
  6983 |     |             m1 := mload(0x20)
  6984 |     |             m2 := mload(0x40)
  6985 |     |             m3 := mload(0x60)
  6986 |     |             m4 := mload(0x80)
  6987 |     |             m5 := mload(0xa0)
  6988 |     |             m6 := mload(0xc0)
  6989 |     |             // Selector of `log(bool,string,address,address)`.
  6990 |     |             mstore(0x00, 0x2b2b18dc)
  6991 |     |             mstore(0x20, p0)
  6992 |     |             mstore(0x40, 0x80)
  6993 |     |             mstore(0x60, p2)
  6994 |     |             mstore(0x80, p3)
  6995 |     |             writeString(0xa0, p1)
  6996 |     |         }
  6997 |     |         _sendLogPayload(0x1c, 0xc4);
  6998 |     |         assembly {
  6999 |     |             mstore(0x00, m0)
  7000 |     |             mstore(0x20, m1)
  7001 |     |             mstore(0x40, m2)
  7002 |     |             mstore(0x60, m3)
  7003 |     |             mstore(0x80, m4)
  7004 |     |             mstore(0xa0, m5)
  7005 |     |             mstore(0xc0, m6)
  7006 |     |         }
  7007 |     |     }
  7008 |     | 
  7009 |     |     function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {
  7010 |     |         bytes32 m0;
  7011 |     |         bytes32 m1;
  7012 |     |         bytes32 m2;
  7013 |     |         bytes32 m3;
  7014 |     |         bytes32 m4;
  7015 |     |         bytes32 m5;
  7016 |     |         bytes32 m6;
  7017 |     |         assembly {
  7018 |     |             function writeString(pos, w) {
  7019 |     |                 let length := 0
  7020 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7021 |     |                 mstore(pos, length)
  7022 |     |                 let shift := sub(256, shl(3, length))
  7023 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7024 |     |             }
  7025 |     |             m0 := mload(0x00)
  7026 |     |             m1 := mload(0x20)
  7027 |     |             m2 := mload(0x40)
  7028 |     |             m3 := mload(0x60)
  7029 |     |             m4 := mload(0x80)
  7030 |     |             m5 := mload(0xa0)
  7031 |     |             m6 := mload(0xc0)
  7032 |     |             // Selector of `log(bool,string,address,bool)`.
  7033 |     |             mstore(0x00, 0x6dd434ca)
  7034 |     |             mstore(0x20, p0)
  7035 |     |             mstore(0x40, 0x80)
  7036 |     |             mstore(0x60, p2)
  7037 |     |             mstore(0x80, p3)
  7038 |     |             writeString(0xa0, p1)
  7039 |     |         }
  7040 |     |         _sendLogPayload(0x1c, 0xc4);
  7041 |     |         assembly {
  7042 |     |             mstore(0x00, m0)
  7043 |     |             mstore(0x20, m1)
  7044 |     |             mstore(0x40, m2)
  7045 |     |             mstore(0x60, m3)
  7046 |     |             mstore(0x80, m4)
  7047 |     |             mstore(0xa0, m5)
  7048 |     |             mstore(0xc0, m6)
  7049 |     |         }
  7050 |     |     }
  7051 |     | 
  7052 |     |     function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {
  7053 |     |         bytes32 m0;
  7054 |     |         bytes32 m1;
  7055 |     |         bytes32 m2;
  7056 |     |         bytes32 m3;
  7057 |     |         bytes32 m4;
  7058 |     |         bytes32 m5;
  7059 |     |         bytes32 m6;
  7060 |     |         assembly {
  7061 |     |             function writeString(pos, w) {
  7062 |     |                 let length := 0
  7063 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7064 |     |                 mstore(pos, length)
  7065 |     |                 let shift := sub(256, shl(3, length))
  7066 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7067 |     |             }
  7068 |     |             m0 := mload(0x00)
  7069 |     |             m1 := mload(0x20)
  7070 |     |             m2 := mload(0x40)
  7071 |     |             m3 := mload(0x60)
  7072 |     |             m4 := mload(0x80)
  7073 |     |             m5 := mload(0xa0)
  7074 |     |             m6 := mload(0xc0)
  7075 |     |             // Selector of `log(bool,string,address,uint256)`.
  7076 |     |             mstore(0x00, 0xa5cada94)
  7077 |     |             mstore(0x20, p0)
  7078 |     |             mstore(0x40, 0x80)
  7079 |     |             mstore(0x60, p2)
  7080 |     |             mstore(0x80, p3)
  7081 |     |             writeString(0xa0, p1)
  7082 |     |         }
  7083 |     |         _sendLogPayload(0x1c, 0xc4);
  7084 |     |         assembly {
  7085 |     |             mstore(0x00, m0)
  7086 |     |             mstore(0x20, m1)
  7087 |     |             mstore(0x40, m2)
  7088 |     |             mstore(0x60, m3)
  7089 |     |             mstore(0x80, m4)
  7090 |     |             mstore(0xa0, m5)
  7091 |     |             mstore(0xc0, m6)
  7092 |     |         }
  7093 |     |     }
  7094 |     | 
  7095 |     |     function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  7096 |     |         bytes32 m0;
  7097 |     |         bytes32 m1;
  7098 |     |         bytes32 m2;
  7099 |     |         bytes32 m3;
  7100 |     |         bytes32 m4;
  7101 |     |         bytes32 m5;
  7102 |     |         bytes32 m6;
  7103 |     |         bytes32 m7;
  7104 |     |         bytes32 m8;
  7105 |     |         assembly {
  7106 |     |             function writeString(pos, w) {
  7107 |     |                 let length := 0
  7108 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7109 |     |                 mstore(pos, length)
  7110 |     |                 let shift := sub(256, shl(3, length))
  7111 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7112 |     |             }
  7113 |     |             m0 := mload(0x00)
  7114 |     |             m1 := mload(0x20)
  7115 |     |             m2 := mload(0x40)
  7116 |     |             m3 := mload(0x60)
  7117 |     |             m4 := mload(0x80)
  7118 |     |             m5 := mload(0xa0)
  7119 |     |             m6 := mload(0xc0)
  7120 |     |             m7 := mload(0xe0)
  7121 |     |             m8 := mload(0x100)
  7122 |     |             // Selector of `log(bool,string,address,string)`.
  7123 |     |             mstore(0x00, 0x12d6c788)
  7124 |     |             mstore(0x20, p0)
  7125 |     |             mstore(0x40, 0x80)
  7126 |     |             mstore(0x60, p2)
  7127 |     |             mstore(0x80, 0xc0)
  7128 |     |             writeString(0xa0, p1)
  7129 |     |             writeString(0xe0, p3)
  7130 |     |         }
  7131 |     |         _sendLogPayload(0x1c, 0x104);
  7132 |     |         assembly {
  7133 |     |             mstore(0x00, m0)
  7134 |     |             mstore(0x20, m1)
  7135 |     |             mstore(0x40, m2)
  7136 |     |             mstore(0x60, m3)
  7137 |     |             mstore(0x80, m4)
  7138 |     |             mstore(0xa0, m5)
  7139 |     |             mstore(0xc0, m6)
  7140 |     |             mstore(0xe0, m7)
  7141 |     |             mstore(0x100, m8)
  7142 |     |         }
  7143 |     |     }
  7144 |     | 
  7145 |     |     function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {
  7146 |     |         bytes32 m0;
  7147 |     |         bytes32 m1;
  7148 |     |         bytes32 m2;
  7149 |     |         bytes32 m3;
  7150 |     |         bytes32 m4;
  7151 |     |         bytes32 m5;
  7152 |     |         bytes32 m6;
  7153 |     |         assembly {
  7154 |     |             function writeString(pos, w) {
  7155 |     |                 let length := 0
  7156 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7157 |     |                 mstore(pos, length)
  7158 |     |                 let shift := sub(256, shl(3, length))
  7159 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7160 |     |             }
  7161 |     |             m0 := mload(0x00)
  7162 |     |             m1 := mload(0x20)
  7163 |     |             m2 := mload(0x40)
  7164 |     |             m3 := mload(0x60)
  7165 |     |             m4 := mload(0x80)
  7166 |     |             m5 := mload(0xa0)
  7167 |     |             m6 := mload(0xc0)
  7168 |     |             // Selector of `log(bool,string,bool,address)`.
  7169 |     |             mstore(0x00, 0x538e06ab)
  7170 |     |             mstore(0x20, p0)
  7171 |     |             mstore(0x40, 0x80)
  7172 |     |             mstore(0x60, p2)
  7173 |     |             mstore(0x80, p3)
  7174 |     |             writeString(0xa0, p1)
  7175 |     |         }
  7176 |     |         _sendLogPayload(0x1c, 0xc4);
  7177 |     |         assembly {
  7178 |     |             mstore(0x00, m0)
  7179 |     |             mstore(0x20, m1)
  7180 |     |             mstore(0x40, m2)
  7181 |     |             mstore(0x60, m3)
  7182 |     |             mstore(0x80, m4)
  7183 |     |             mstore(0xa0, m5)
  7184 |     |             mstore(0xc0, m6)
  7185 |     |         }
  7186 |     |     }
  7187 |     | 
  7188 |     |     function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {
  7189 |     |         bytes32 m0;
  7190 |     |         bytes32 m1;
  7191 |     |         bytes32 m2;
  7192 |     |         bytes32 m3;
  7193 |     |         bytes32 m4;
  7194 |     |         bytes32 m5;
  7195 |     |         bytes32 m6;
  7196 |     |         assembly {
  7197 |     |             function writeString(pos, w) {
  7198 |     |                 let length := 0
  7199 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7200 |     |                 mstore(pos, length)
  7201 |     |                 let shift := sub(256, shl(3, length))
  7202 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7203 |     |             }
  7204 |     |             m0 := mload(0x00)
  7205 |     |             m1 := mload(0x20)
  7206 |     |             m2 := mload(0x40)
  7207 |     |             m3 := mload(0x60)
  7208 |     |             m4 := mload(0x80)
  7209 |     |             m5 := mload(0xa0)
  7210 |     |             m6 := mload(0xc0)
  7211 |     |             // Selector of `log(bool,string,bool,bool)`.
  7212 |     |             mstore(0x00, 0xdc5e935b)
  7213 |     |             mstore(0x20, p0)
  7214 |     |             mstore(0x40, 0x80)
  7215 |     |             mstore(0x60, p2)
  7216 |     |             mstore(0x80, p3)
  7217 |     |             writeString(0xa0, p1)
  7218 |     |         }
  7219 |     |         _sendLogPayload(0x1c, 0xc4);
  7220 |     |         assembly {
  7221 |     |             mstore(0x00, m0)
  7222 |     |             mstore(0x20, m1)
  7223 |     |             mstore(0x40, m2)
  7224 |     |             mstore(0x60, m3)
  7225 |     |             mstore(0x80, m4)
  7226 |     |             mstore(0xa0, m5)
  7227 |     |             mstore(0xc0, m6)
  7228 |     |         }
  7229 |     |     }
  7230 |     | 
  7231 |     |     function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  7232 |     |         bytes32 m0;
  7233 |     |         bytes32 m1;
  7234 |     |         bytes32 m2;
  7235 |     |         bytes32 m3;
  7236 |     |         bytes32 m4;
  7237 |     |         bytes32 m5;
  7238 |     |         bytes32 m6;
  7239 |     |         assembly {
  7240 |     |             function writeString(pos, w) {
  7241 |     |                 let length := 0
  7242 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7243 |     |                 mstore(pos, length)
  7244 |     |                 let shift := sub(256, shl(3, length))
  7245 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7246 |     |             }
  7247 |     |             m0 := mload(0x00)
  7248 |     |             m1 := mload(0x20)
  7249 |     |             m2 := mload(0x40)
  7250 |     |             m3 := mload(0x60)
  7251 |     |             m4 := mload(0x80)
  7252 |     |             m5 := mload(0xa0)
  7253 |     |             m6 := mload(0xc0)
  7254 |     |             // Selector of `log(bool,string,bool,uint256)`.
  7255 |     |             mstore(0x00, 0x1606a393)
  7256 |     |             mstore(0x20, p0)
  7257 |     |             mstore(0x40, 0x80)
  7258 |     |             mstore(0x60, p2)
  7259 |     |             mstore(0x80, p3)
  7260 |     |             writeString(0xa0, p1)
  7261 |     |         }
  7262 |     |         _sendLogPayload(0x1c, 0xc4);
  7263 |     |         assembly {
  7264 |     |             mstore(0x00, m0)
  7265 |     |             mstore(0x20, m1)
  7266 |     |             mstore(0x40, m2)
  7267 |     |             mstore(0x60, m3)
  7268 |     |             mstore(0x80, m4)
  7269 |     |             mstore(0xa0, m5)
  7270 |     |             mstore(0xc0, m6)
  7271 |     |         }
  7272 |     |     }
  7273 |     | 
  7274 |     |     function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  7275 |     |         bytes32 m0;
  7276 |     |         bytes32 m1;
  7277 |     |         bytes32 m2;
  7278 |     |         bytes32 m3;
  7279 |     |         bytes32 m4;
  7280 |     |         bytes32 m5;
  7281 |     |         bytes32 m6;
  7282 |     |         bytes32 m7;
  7283 |     |         bytes32 m8;
  7284 |     |         assembly {
  7285 |     |             function writeString(pos, w) {
  7286 |     |                 let length := 0
  7287 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7288 |     |                 mstore(pos, length)
  7289 |     |                 let shift := sub(256, shl(3, length))
  7290 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7291 |     |             }
  7292 |     |             m0 := mload(0x00)
  7293 |     |             m1 := mload(0x20)
  7294 |     |             m2 := mload(0x40)
  7295 |     |             m3 := mload(0x60)
  7296 |     |             m4 := mload(0x80)
  7297 |     |             m5 := mload(0xa0)
  7298 |     |             m6 := mload(0xc0)
  7299 |     |             m7 := mload(0xe0)
  7300 |     |             m8 := mload(0x100)
  7301 |     |             // Selector of `log(bool,string,bool,string)`.
  7302 |     |             mstore(0x00, 0x483d0416)
  7303 |     |             mstore(0x20, p0)
  7304 |     |             mstore(0x40, 0x80)
  7305 |     |             mstore(0x60, p2)
  7306 |     |             mstore(0x80, 0xc0)
  7307 |     |             writeString(0xa0, p1)
  7308 |     |             writeString(0xe0, p3)
  7309 |     |         }
  7310 |     |         _sendLogPayload(0x1c, 0x104);
  7311 |     |         assembly {
  7312 |     |             mstore(0x00, m0)
  7313 |     |             mstore(0x20, m1)
  7314 |     |             mstore(0x40, m2)
  7315 |     |             mstore(0x60, m3)
  7316 |     |             mstore(0x80, m4)
  7317 |     |             mstore(0xa0, m5)
  7318 |     |             mstore(0xc0, m6)
  7319 |     |             mstore(0xe0, m7)
  7320 |     |             mstore(0x100, m8)
  7321 |     |         }
  7322 |     |     }
  7323 |     | 
  7324 |     |     function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {
  7325 |     |         bytes32 m0;
  7326 |     |         bytes32 m1;
  7327 |     |         bytes32 m2;
  7328 |     |         bytes32 m3;
  7329 |     |         bytes32 m4;
  7330 |     |         bytes32 m5;
  7331 |     |         bytes32 m6;
  7332 |     |         assembly {
  7333 |     |             function writeString(pos, w) {
  7334 |     |                 let length := 0
  7335 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7336 |     |                 mstore(pos, length)
  7337 |     |                 let shift := sub(256, shl(3, length))
  7338 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7339 |     |             }
  7340 |     |             m0 := mload(0x00)
  7341 |     |             m1 := mload(0x20)
  7342 |     |             m2 := mload(0x40)
  7343 |     |             m3 := mload(0x60)
  7344 |     |             m4 := mload(0x80)
  7345 |     |             m5 := mload(0xa0)
  7346 |     |             m6 := mload(0xc0)
  7347 |     |             // Selector of `log(bool,string,uint256,address)`.
  7348 |     |             mstore(0x00, 0x1596a1ce)
  7349 |     |             mstore(0x20, p0)
  7350 |     |             mstore(0x40, 0x80)
  7351 |     |             mstore(0x60, p2)
  7352 |     |             mstore(0x80, p3)
  7353 |     |             writeString(0xa0, p1)
  7354 |     |         }
  7355 |     |         _sendLogPayload(0x1c, 0xc4);
  7356 |     |         assembly {
  7357 |     |             mstore(0x00, m0)
  7358 |     |             mstore(0x20, m1)
  7359 |     |             mstore(0x40, m2)
  7360 |     |             mstore(0x60, m3)
  7361 |     |             mstore(0x80, m4)
  7362 |     |             mstore(0xa0, m5)
  7363 |     |             mstore(0xc0, m6)
  7364 |     |         }
  7365 |     |     }
  7366 |     | 
  7367 |     |     function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  7368 |     |         bytes32 m0;
  7369 |     |         bytes32 m1;
  7370 |     |         bytes32 m2;
  7371 |     |         bytes32 m3;
  7372 |     |         bytes32 m4;
  7373 |     |         bytes32 m5;
  7374 |     |         bytes32 m6;
  7375 |     |         assembly {
  7376 |     |             function writeString(pos, w) {
  7377 |     |                 let length := 0
  7378 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7379 |     |                 mstore(pos, length)
  7380 |     |                 let shift := sub(256, shl(3, length))
  7381 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7382 |     |             }
  7383 |     |             m0 := mload(0x00)
  7384 |     |             m1 := mload(0x20)
  7385 |     |             m2 := mload(0x40)
  7386 |     |             m3 := mload(0x60)
  7387 |     |             m4 := mload(0x80)
  7388 |     |             m5 := mload(0xa0)
  7389 |     |             m6 := mload(0xc0)
  7390 |     |             // Selector of `log(bool,string,uint256,bool)`.
  7391 |     |             mstore(0x00, 0x6b0e5d53)
  7392 |     |             mstore(0x20, p0)
  7393 |     |             mstore(0x40, 0x80)
  7394 |     |             mstore(0x60, p2)
  7395 |     |             mstore(0x80, p3)
  7396 |     |             writeString(0xa0, p1)
  7397 |     |         }
  7398 |     |         _sendLogPayload(0x1c, 0xc4);
  7399 |     |         assembly {
  7400 |     |             mstore(0x00, m0)
  7401 |     |             mstore(0x20, m1)
  7402 |     |             mstore(0x40, m2)
  7403 |     |             mstore(0x60, m3)
  7404 |     |             mstore(0x80, m4)
  7405 |     |             mstore(0xa0, m5)
  7406 |     |             mstore(0xc0, m6)
  7407 |     |         }
  7408 |     |     }
  7409 |     | 
  7410 |     |     function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  7411 |     |         bytes32 m0;
  7412 |     |         bytes32 m1;
  7413 |     |         bytes32 m2;
  7414 |     |         bytes32 m3;
  7415 |     |         bytes32 m4;
  7416 |     |         bytes32 m5;
  7417 |     |         bytes32 m6;
  7418 |     |         assembly {
  7419 |     |             function writeString(pos, w) {
  7420 |     |                 let length := 0
  7421 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7422 |     |                 mstore(pos, length)
  7423 |     |                 let shift := sub(256, shl(3, length))
  7424 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7425 |     |             }
  7426 |     |             m0 := mload(0x00)
  7427 |     |             m1 := mload(0x20)
  7428 |     |             m2 := mload(0x40)
  7429 |     |             m3 := mload(0x60)
  7430 |     |             m4 := mload(0x80)
  7431 |     |             m5 := mload(0xa0)
  7432 |     |             m6 := mload(0xc0)
  7433 |     |             // Selector of `log(bool,string,uint256,uint256)`.
  7434 |     |             mstore(0x00, 0x28863fcb)
  7435 |     |             mstore(0x20, p0)
  7436 |     |             mstore(0x40, 0x80)
  7437 |     |             mstore(0x60, p2)
  7438 |     |             mstore(0x80, p3)
  7439 |     |             writeString(0xa0, p1)
  7440 |     |         }
  7441 |     |         _sendLogPayload(0x1c, 0xc4);
  7442 |     |         assembly {
  7443 |     |             mstore(0x00, m0)
  7444 |     |             mstore(0x20, m1)
  7445 |     |             mstore(0x40, m2)
  7446 |     |             mstore(0x60, m3)
  7447 |     |             mstore(0x80, m4)
  7448 |     |             mstore(0xa0, m5)
  7449 |     |             mstore(0xc0, m6)
  7450 |     |         }
  7451 |     |     }
  7452 |     | 
  7453 |     |     function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  7454 |     |         bytes32 m0;
  7455 |     |         bytes32 m1;
  7456 |     |         bytes32 m2;
  7457 |     |         bytes32 m3;
  7458 |     |         bytes32 m4;
  7459 |     |         bytes32 m5;
  7460 |     |         bytes32 m6;
  7461 |     |         bytes32 m7;
  7462 |     |         bytes32 m8;
  7463 |     |         assembly {
  7464 |     |             function writeString(pos, w) {
  7465 |     |                 let length := 0
  7466 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7467 |     |                 mstore(pos, length)
  7468 |     |                 let shift := sub(256, shl(3, length))
  7469 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7470 |     |             }
  7471 |     |             m0 := mload(0x00)
  7472 |     |             m1 := mload(0x20)
  7473 |     |             m2 := mload(0x40)
  7474 |     |             m3 := mload(0x60)
  7475 |     |             m4 := mload(0x80)
  7476 |     |             m5 := mload(0xa0)
  7477 |     |             m6 := mload(0xc0)
  7478 |     |             m7 := mload(0xe0)
  7479 |     |             m8 := mload(0x100)
  7480 |     |             // Selector of `log(bool,string,uint256,string)`.
  7481 |     |             mstore(0x00, 0x1ad96de6)
  7482 |     |             mstore(0x20, p0)
  7483 |     |             mstore(0x40, 0x80)
  7484 |     |             mstore(0x60, p2)
  7485 |     |             mstore(0x80, 0xc0)
  7486 |     |             writeString(0xa0, p1)
  7487 |     |             writeString(0xe0, p3)
  7488 |     |         }
  7489 |     |         _sendLogPayload(0x1c, 0x104);
  7490 |     |         assembly {
  7491 |     |             mstore(0x00, m0)
  7492 |     |             mstore(0x20, m1)
  7493 |     |             mstore(0x40, m2)
  7494 |     |             mstore(0x60, m3)
  7495 |     |             mstore(0x80, m4)
  7496 |     |             mstore(0xa0, m5)
  7497 |     |             mstore(0xc0, m6)
  7498 |     |             mstore(0xe0, m7)
  7499 |     |             mstore(0x100, m8)
  7500 |     |         }
  7501 |     |     }
  7502 |     | 
  7503 |     |     function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  7504 |     |         bytes32 m0;
  7505 |     |         bytes32 m1;
  7506 |     |         bytes32 m2;
  7507 |     |         bytes32 m3;
  7508 |     |         bytes32 m4;
  7509 |     |         bytes32 m5;
  7510 |     |         bytes32 m6;
  7511 |     |         bytes32 m7;
  7512 |     |         bytes32 m8;
  7513 |     |         assembly {
  7514 |     |             function writeString(pos, w) {
  7515 |     |                 let length := 0
  7516 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7517 |     |                 mstore(pos, length)
  7518 |     |                 let shift := sub(256, shl(3, length))
  7519 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7520 |     |             }
  7521 |     |             m0 := mload(0x00)
  7522 |     |             m1 := mload(0x20)
  7523 |     |             m2 := mload(0x40)
  7524 |     |             m3 := mload(0x60)
  7525 |     |             m4 := mload(0x80)
  7526 |     |             m5 := mload(0xa0)
  7527 |     |             m6 := mload(0xc0)
  7528 |     |             m7 := mload(0xe0)
  7529 |     |             m8 := mload(0x100)
  7530 |     |             // Selector of `log(bool,string,string,address)`.
  7531 |     |             mstore(0x00, 0x97d394d8)
  7532 |     |             mstore(0x20, p0)
  7533 |     |             mstore(0x40, 0x80)
  7534 |     |             mstore(0x60, 0xc0)
  7535 |     |             mstore(0x80, p3)
  7536 |     |             writeString(0xa0, p1)
  7537 |     |             writeString(0xe0, p2)
  7538 |     |         }
  7539 |     |         _sendLogPayload(0x1c, 0x104);
  7540 |     |         assembly {
  7541 |     |             mstore(0x00, m0)
  7542 |     |             mstore(0x20, m1)
  7543 |     |             mstore(0x40, m2)
  7544 |     |             mstore(0x60, m3)
  7545 |     |             mstore(0x80, m4)
  7546 |     |             mstore(0xa0, m5)
  7547 |     |             mstore(0xc0, m6)
  7548 |     |             mstore(0xe0, m7)
  7549 |     |             mstore(0x100, m8)
  7550 |     |         }
  7551 |     |     }
  7552 |     | 
  7553 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  7554 |     |         bytes32 m0;
  7555 |     |         bytes32 m1;
  7556 |     |         bytes32 m2;
  7557 |     |         bytes32 m3;
  7558 |     |         bytes32 m4;
  7559 |     |         bytes32 m5;
  7560 |     |         bytes32 m6;
  7561 |     |         bytes32 m7;
  7562 |     |         bytes32 m8;
  7563 |     |         assembly {
  7564 |     |             function writeString(pos, w) {
  7565 |     |                 let length := 0
  7566 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7567 |     |                 mstore(pos, length)
  7568 |     |                 let shift := sub(256, shl(3, length))
  7569 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7570 |     |             }
  7571 |     |             m0 := mload(0x00)
  7572 |     |             m1 := mload(0x20)
  7573 |     |             m2 := mload(0x40)
  7574 |     |             m3 := mload(0x60)
  7575 |     |             m4 := mload(0x80)
  7576 |     |             m5 := mload(0xa0)
  7577 |     |             m6 := mload(0xc0)
  7578 |     |             m7 := mload(0xe0)
  7579 |     |             m8 := mload(0x100)
  7580 |     |             // Selector of `log(bool,string,string,bool)`.
  7581 |     |             mstore(0x00, 0x1e4b87e5)
  7582 |     |             mstore(0x20, p0)
  7583 |     |             mstore(0x40, 0x80)
  7584 |     |             mstore(0x60, 0xc0)
  7585 |     |             mstore(0x80, p3)
  7586 |     |             writeString(0xa0, p1)
  7587 |     |             writeString(0xe0, p2)
  7588 |     |         }
  7589 |     |         _sendLogPayload(0x1c, 0x104);
  7590 |     |         assembly {
  7591 |     |             mstore(0x00, m0)
  7592 |     |             mstore(0x20, m1)
  7593 |     |             mstore(0x40, m2)
  7594 |     |             mstore(0x60, m3)
  7595 |     |             mstore(0x80, m4)
  7596 |     |             mstore(0xa0, m5)
  7597 |     |             mstore(0xc0, m6)
  7598 |     |             mstore(0xe0, m7)
  7599 |     |             mstore(0x100, m8)
  7600 |     |         }
  7601 |     |     }
  7602 |     | 
  7603 |     |     function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  7604 |     |         bytes32 m0;
  7605 |     |         bytes32 m1;
  7606 |     |         bytes32 m2;
  7607 |     |         bytes32 m3;
  7608 |     |         bytes32 m4;
  7609 |     |         bytes32 m5;
  7610 |     |         bytes32 m6;
  7611 |     |         bytes32 m7;
  7612 |     |         bytes32 m8;
  7613 |     |         assembly {
  7614 |     |             function writeString(pos, w) {
  7615 |     |                 let length := 0
  7616 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7617 |     |                 mstore(pos, length)
  7618 |     |                 let shift := sub(256, shl(3, length))
  7619 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7620 |     |             }
  7621 |     |             m0 := mload(0x00)
  7622 |     |             m1 := mload(0x20)
  7623 |     |             m2 := mload(0x40)
  7624 |     |             m3 := mload(0x60)
  7625 |     |             m4 := mload(0x80)
  7626 |     |             m5 := mload(0xa0)
  7627 |     |             m6 := mload(0xc0)
  7628 |     |             m7 := mload(0xe0)
  7629 |     |             m8 := mload(0x100)
  7630 |     |             // Selector of `log(bool,string,string,uint256)`.
  7631 |     |             mstore(0x00, 0x7be0c3eb)
  7632 |     |             mstore(0x20, p0)
  7633 |     |             mstore(0x40, 0x80)
  7634 |     |             mstore(0x60, 0xc0)
  7635 |     |             mstore(0x80, p3)
  7636 |     |             writeString(0xa0, p1)
  7637 |     |             writeString(0xe0, p2)
  7638 |     |         }
  7639 |     |         _sendLogPayload(0x1c, 0x104);
  7640 |     |         assembly {
  7641 |     |             mstore(0x00, m0)
  7642 |     |             mstore(0x20, m1)
  7643 |     |             mstore(0x40, m2)
  7644 |     |             mstore(0x60, m3)
  7645 |     |             mstore(0x80, m4)
  7646 |     |             mstore(0xa0, m5)
  7647 |     |             mstore(0xc0, m6)
  7648 |     |             mstore(0xe0, m7)
  7649 |     |             mstore(0x100, m8)
  7650 |     |         }
  7651 |     |     }
  7652 |     | 
  7653 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  7654 |     |         bytes32 m0;
  7655 |     |         bytes32 m1;
  7656 |     |         bytes32 m2;
  7657 |     |         bytes32 m3;
  7658 |     |         bytes32 m4;
  7659 |     |         bytes32 m5;
  7660 |     |         bytes32 m6;
  7661 |     |         bytes32 m7;
  7662 |     |         bytes32 m8;
  7663 |     |         bytes32 m9;
  7664 |     |         bytes32 m10;
  7665 |     |         assembly {
  7666 |     |             function writeString(pos, w) {
  7667 |     |                 let length := 0
  7668 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7669 |     |                 mstore(pos, length)
  7670 |     |                 let shift := sub(256, shl(3, length))
  7671 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7672 |     |             }
  7673 |     |             m0 := mload(0x00)
  7674 |     |             m1 := mload(0x20)
  7675 |     |             m2 := mload(0x40)
  7676 |     |             m3 := mload(0x60)
  7677 |     |             m4 := mload(0x80)
  7678 |     |             m5 := mload(0xa0)
  7679 |     |             m6 := mload(0xc0)
  7680 |     |             m7 := mload(0xe0)
  7681 |     |             m8 := mload(0x100)
  7682 |     |             m9 := mload(0x120)
  7683 |     |             m10 := mload(0x140)
  7684 |     |             // Selector of `log(bool,string,string,string)`.
  7685 |     |             mstore(0x00, 0x1762e32a)
  7686 |     |             mstore(0x20, p0)
  7687 |     |             mstore(0x40, 0x80)
  7688 |     |             mstore(0x60, 0xc0)
  7689 |     |             mstore(0x80, 0x100)
  7690 |     |             writeString(0xa0, p1)
  7691 |     |             writeString(0xe0, p2)
  7692 |     |             writeString(0x120, p3)
  7693 |     |         }
  7694 |     |         _sendLogPayload(0x1c, 0x144);
  7695 |     |         assembly {
  7696 |     |             mstore(0x00, m0)
  7697 |     |             mstore(0x20, m1)
  7698 |     |             mstore(0x40, m2)
  7699 |     |             mstore(0x60, m3)
  7700 |     |             mstore(0x80, m4)
  7701 |     |             mstore(0xa0, m5)
  7702 |     |             mstore(0xc0, m6)
  7703 |     |             mstore(0xe0, m7)
  7704 |     |             mstore(0x100, m8)
  7705 |     |             mstore(0x120, m9)
  7706 |     |             mstore(0x140, m10)
  7707 |     |         }
  7708 |     |     }
  7709 |     | 
  7710 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  7711 |     |         bytes32 m0;
  7712 |     |         bytes32 m1;
  7713 |     |         bytes32 m2;
  7714 |     |         bytes32 m3;
  7715 |     |         bytes32 m4;
  7716 |     |         assembly {
  7717 |     |             m0 := mload(0x00)
  7718 |     |             m1 := mload(0x20)
  7719 |     |             m2 := mload(0x40)
  7720 |     |             m3 := mload(0x60)
  7721 |     |             m4 := mload(0x80)
  7722 |     |             // Selector of `log(uint256,address,address,address)`.
  7723 |     |             mstore(0x00, 0x2488b414)
  7724 |     |             mstore(0x20, p0)
  7725 |     |             mstore(0x40, p1)
  7726 |     |             mstore(0x60, p2)
  7727 |     |             mstore(0x80, p3)
  7728 |     |         }
  7729 |     |         _sendLogPayload(0x1c, 0x84);
  7730 |     |         assembly {
  7731 |     |             mstore(0x00, m0)
  7732 |     |             mstore(0x20, m1)
  7733 |     |             mstore(0x40, m2)
  7734 |     |             mstore(0x60, m3)
  7735 |     |             mstore(0x80, m4)
  7736 |     |         }
  7737 |     |     }
  7738 |     | 
  7739 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  7740 |     |         bytes32 m0;
  7741 |     |         bytes32 m1;
  7742 |     |         bytes32 m2;
  7743 |     |         bytes32 m3;
  7744 |     |         bytes32 m4;
  7745 |     |         assembly {
  7746 |     |             m0 := mload(0x00)
  7747 |     |             m1 := mload(0x20)
  7748 |     |             m2 := mload(0x40)
  7749 |     |             m3 := mload(0x60)
  7750 |     |             m4 := mload(0x80)
  7751 |     |             // Selector of `log(uint256,address,address,bool)`.
  7752 |     |             mstore(0x00, 0x091ffaf5)
  7753 |     |             mstore(0x20, p0)
  7754 |     |             mstore(0x40, p1)
  7755 |     |             mstore(0x60, p2)
  7756 |     |             mstore(0x80, p3)
  7757 |     |         }
  7758 |     |         _sendLogPayload(0x1c, 0x84);
  7759 |     |         assembly {
  7760 |     |             mstore(0x00, m0)
  7761 |     |             mstore(0x20, m1)
  7762 |     |             mstore(0x40, m2)
  7763 |     |             mstore(0x60, m3)
  7764 |     |             mstore(0x80, m4)
  7765 |     |         }
  7766 |     |     }
  7767 |     | 
  7768 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  7769 |     |         bytes32 m0;
  7770 |     |         bytes32 m1;
  7771 |     |         bytes32 m2;
  7772 |     |         bytes32 m3;
  7773 |     |         bytes32 m4;
  7774 |     |         assembly {
  7775 |     |             m0 := mload(0x00)
  7776 |     |             m1 := mload(0x20)
  7777 |     |             m2 := mload(0x40)
  7778 |     |             m3 := mload(0x60)
  7779 |     |             m4 := mload(0x80)
  7780 |     |             // Selector of `log(uint256,address,address,uint256)`.
  7781 |     |             mstore(0x00, 0x736efbb6)
  7782 |     |             mstore(0x20, p0)
  7783 |     |             mstore(0x40, p1)
  7784 |     |             mstore(0x60, p2)
  7785 |     |             mstore(0x80, p3)
  7786 |     |         }
  7787 |     |         _sendLogPayload(0x1c, 0x84);
  7788 |     |         assembly {
  7789 |     |             mstore(0x00, m0)
  7790 |     |             mstore(0x20, m1)
  7791 |     |             mstore(0x40, m2)
  7792 |     |             mstore(0x60, m3)
  7793 |     |             mstore(0x80, m4)
  7794 |     |         }
  7795 |     |     }
  7796 |     | 
  7797 |     |     function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {
  7798 |     |         bytes32 m0;
  7799 |     |         bytes32 m1;
  7800 |     |         bytes32 m2;
  7801 |     |         bytes32 m3;
  7802 |     |         bytes32 m4;
  7803 |     |         bytes32 m5;
  7804 |     |         bytes32 m6;
  7805 |     |         assembly {
  7806 |     |             function writeString(pos, w) {
  7807 |     |                 let length := 0
  7808 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7809 |     |                 mstore(pos, length)
  7810 |     |                 let shift := sub(256, shl(3, length))
  7811 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7812 |     |             }
  7813 |     |             m0 := mload(0x00)
  7814 |     |             m1 := mload(0x20)
  7815 |     |             m2 := mload(0x40)
  7816 |     |             m3 := mload(0x60)
  7817 |     |             m4 := mload(0x80)
  7818 |     |             m5 := mload(0xa0)
  7819 |     |             m6 := mload(0xc0)
  7820 |     |             // Selector of `log(uint256,address,address,string)`.
  7821 |     |             mstore(0x00, 0x031c6f73)
  7822 |     |             mstore(0x20, p0)
  7823 |     |             mstore(0x40, p1)
  7824 |     |             mstore(0x60, p2)
  7825 |     |             mstore(0x80, 0x80)
  7826 |     |             writeString(0xa0, p3)
  7827 |     |         }
  7828 |     |         _sendLogPayload(0x1c, 0xc4);
  7829 |     |         assembly {
  7830 |     |             mstore(0x00, m0)
  7831 |     |             mstore(0x20, m1)
  7832 |     |             mstore(0x40, m2)
  7833 |     |             mstore(0x60, m3)
  7834 |     |             mstore(0x80, m4)
  7835 |     |             mstore(0xa0, m5)
  7836 |     |             mstore(0xc0, m6)
  7837 |     |         }
  7838 |     |     }
  7839 |     | 
  7840 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  7841 |     |         bytes32 m0;
  7842 |     |         bytes32 m1;
  7843 |     |         bytes32 m2;
  7844 |     |         bytes32 m3;
  7845 |     |         bytes32 m4;
  7846 |     |         assembly {
  7847 |     |             m0 := mload(0x00)
  7848 |     |             m1 := mload(0x20)
  7849 |     |             m2 := mload(0x40)
  7850 |     |             m3 := mload(0x60)
  7851 |     |             m4 := mload(0x80)
  7852 |     |             // Selector of `log(uint256,address,bool,address)`.
  7853 |     |             mstore(0x00, 0xef72c513)
  7854 |     |             mstore(0x20, p0)
  7855 |     |             mstore(0x40, p1)
  7856 |     |             mstore(0x60, p2)
  7857 |     |             mstore(0x80, p3)
  7858 |     |         }
  7859 |     |         _sendLogPayload(0x1c, 0x84);
  7860 |     |         assembly {
  7861 |     |             mstore(0x00, m0)
  7862 |     |             mstore(0x20, m1)
  7863 |     |             mstore(0x40, m2)
  7864 |     |             mstore(0x60, m3)
  7865 |     |             mstore(0x80, m4)
  7866 |     |         }
  7867 |     |     }
  7868 |     | 
  7869 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  7870 |     |         bytes32 m0;
  7871 |     |         bytes32 m1;
  7872 |     |         bytes32 m2;
  7873 |     |         bytes32 m3;
  7874 |     |         bytes32 m4;
  7875 |     |         assembly {
  7876 |     |             m0 := mload(0x00)
  7877 |     |             m1 := mload(0x20)
  7878 |     |             m2 := mload(0x40)
  7879 |     |             m3 := mload(0x60)
  7880 |     |             m4 := mload(0x80)
  7881 |     |             // Selector of `log(uint256,address,bool,bool)`.
  7882 |     |             mstore(0x00, 0xe351140f)
  7883 |     |             mstore(0x20, p0)
  7884 |     |             mstore(0x40, p1)
  7885 |     |             mstore(0x60, p2)
  7886 |     |             mstore(0x80, p3)
  7887 |     |         }
  7888 |     |         _sendLogPayload(0x1c, 0x84);
  7889 |     |         assembly {
  7890 |     |             mstore(0x00, m0)
  7891 |     |             mstore(0x20, m1)
  7892 |     |             mstore(0x40, m2)
  7893 |     |             mstore(0x60, m3)
  7894 |     |             mstore(0x80, m4)
  7895 |     |         }
  7896 |     |     }
  7897 |     | 
  7898 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  7899 |     |         bytes32 m0;
  7900 |     |         bytes32 m1;
  7901 |     |         bytes32 m2;
  7902 |     |         bytes32 m3;
  7903 |     |         bytes32 m4;
  7904 |     |         assembly {
  7905 |     |             m0 := mload(0x00)
  7906 |     |             m1 := mload(0x20)
  7907 |     |             m2 := mload(0x40)
  7908 |     |             m3 := mload(0x60)
  7909 |     |             m4 := mload(0x80)
  7910 |     |             // Selector of `log(uint256,address,bool,uint256)`.
  7911 |     |             mstore(0x00, 0x5abd992a)
  7912 |     |             mstore(0x20, p0)
  7913 |     |             mstore(0x40, p1)
  7914 |     |             mstore(0x60, p2)
  7915 |     |             mstore(0x80, p3)
  7916 |     |         }
  7917 |     |         _sendLogPayload(0x1c, 0x84);
  7918 |     |         assembly {
  7919 |     |             mstore(0x00, m0)
  7920 |     |             mstore(0x20, m1)
  7921 |     |             mstore(0x40, m2)
  7922 |     |             mstore(0x60, m3)
  7923 |     |             mstore(0x80, m4)
  7924 |     |         }
  7925 |     |     }
  7926 |     | 
  7927 |     |     function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {
  7928 |     |         bytes32 m0;
  7929 |     |         bytes32 m1;
  7930 |     |         bytes32 m2;
  7931 |     |         bytes32 m3;
  7932 |     |         bytes32 m4;
  7933 |     |         bytes32 m5;
  7934 |     |         bytes32 m6;
  7935 |     |         assembly {
  7936 |     |             function writeString(pos, w) {
  7937 |     |                 let length := 0
  7938 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7939 |     |                 mstore(pos, length)
  7940 |     |                 let shift := sub(256, shl(3, length))
  7941 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7942 |     |             }
  7943 |     |             m0 := mload(0x00)
  7944 |     |             m1 := mload(0x20)
  7945 |     |             m2 := mload(0x40)
  7946 |     |             m3 := mload(0x60)
  7947 |     |             m4 := mload(0x80)
  7948 |     |             m5 := mload(0xa0)
  7949 |     |             m6 := mload(0xc0)
  7950 |     |             // Selector of `log(uint256,address,bool,string)`.
  7951 |     |             mstore(0x00, 0x90fb06aa)
  7952 |     |             mstore(0x20, p0)
  7953 |     |             mstore(0x40, p1)
  7954 |     |             mstore(0x60, p2)
  7955 |     |             mstore(0x80, 0x80)
  7956 |     |             writeString(0xa0, p3)
  7957 |     |         }
  7958 |     |         _sendLogPayload(0x1c, 0xc4);
  7959 |     |         assembly {
  7960 |     |             mstore(0x00, m0)
  7961 |     |             mstore(0x20, m1)
  7962 |     |             mstore(0x40, m2)
  7963 |     |             mstore(0x60, m3)
  7964 |     |             mstore(0x80, m4)
  7965 |     |             mstore(0xa0, m5)
  7966 |     |             mstore(0xc0, m6)
  7967 |     |         }
  7968 |     |     }
  7969 |     | 
  7970 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  7971 |     |         bytes32 m0;
  7972 |     |         bytes32 m1;
  7973 |     |         bytes32 m2;
  7974 |     |         bytes32 m3;
  7975 |     |         bytes32 m4;
  7976 |     |         assembly {
  7977 |     |             m0 := mload(0x00)
  7978 |     |             m1 := mload(0x20)
  7979 |     |             m2 := mload(0x40)
  7980 |     |             m3 := mload(0x60)
  7981 |     |             m4 := mload(0x80)
  7982 |     |             // Selector of `log(uint256,address,uint256,address)`.
  7983 |     |             mstore(0x00, 0x15c127b5)
  7984 |     |             mstore(0x20, p0)
  7985 |     |             mstore(0x40, p1)
  7986 |     |             mstore(0x60, p2)
  7987 |     |             mstore(0x80, p3)
  7988 |     |         }
  7989 |     |         _sendLogPayload(0x1c, 0x84);
  7990 |     |         assembly {
  7991 |     |             mstore(0x00, m0)
  7992 |     |             mstore(0x20, m1)
  7993 |     |             mstore(0x40, m2)
  7994 |     |             mstore(0x60, m3)
  7995 |     |             mstore(0x80, m4)
  7996 |     |         }
  7997 |     |     }
  7998 |     | 
  7999 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  8000 |     |         bytes32 m0;
  8001 |     |         bytes32 m1;
  8002 |     |         bytes32 m2;
  8003 |     |         bytes32 m3;
  8004 |     |         bytes32 m4;
  8005 |     |         assembly {
  8006 |     |             m0 := mload(0x00)
  8007 |     |             m1 := mload(0x20)
  8008 |     |             m2 := mload(0x40)
  8009 |     |             m3 := mload(0x60)
  8010 |     |             m4 := mload(0x80)
  8011 |     |             // Selector of `log(uint256,address,uint256,bool)`.
  8012 |     |             mstore(0x00, 0x5f743a7c)
  8013 |     |             mstore(0x20, p0)
  8014 |     |             mstore(0x40, p1)
  8015 |     |             mstore(0x60, p2)
  8016 |     |             mstore(0x80, p3)
  8017 |     |         }
  8018 |     |         _sendLogPayload(0x1c, 0x84);
  8019 |     |         assembly {
  8020 |     |             mstore(0x00, m0)
  8021 |     |             mstore(0x20, m1)
  8022 |     |             mstore(0x40, m2)
  8023 |     |             mstore(0x60, m3)
  8024 |     |             mstore(0x80, m4)
  8025 |     |         }
  8026 |     |     }
  8027 |     | 
  8028 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  8029 |     |         bytes32 m0;
  8030 |     |         bytes32 m1;
  8031 |     |         bytes32 m2;
  8032 |     |         bytes32 m3;
  8033 |     |         bytes32 m4;
  8034 |     |         assembly {
  8035 |     |             m0 := mload(0x00)
  8036 |     |             m1 := mload(0x20)
  8037 |     |             m2 := mload(0x40)
  8038 |     |             m3 := mload(0x60)
  8039 |     |             m4 := mload(0x80)
  8040 |     |             // Selector of `log(uint256,address,uint256,uint256)`.
  8041 |     |             mstore(0x00, 0x0c9cd9c1)
  8042 |     |             mstore(0x20, p0)
  8043 |     |             mstore(0x40, p1)
  8044 |     |             mstore(0x60, p2)
  8045 |     |             mstore(0x80, p3)
  8046 |     |         }
  8047 |     |         _sendLogPayload(0x1c, 0x84);
  8048 |     |         assembly {
  8049 |     |             mstore(0x00, m0)
  8050 |     |             mstore(0x20, m1)
  8051 |     |             mstore(0x40, m2)
  8052 |     |             mstore(0x60, m3)
  8053 |     |             mstore(0x80, m4)
  8054 |     |         }
  8055 |     |     }
  8056 |     | 
  8057 |     |     function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {
  8058 |     |         bytes32 m0;
  8059 |     |         bytes32 m1;
  8060 |     |         bytes32 m2;
  8061 |     |         bytes32 m3;
  8062 |     |         bytes32 m4;
  8063 |     |         bytes32 m5;
  8064 |     |         bytes32 m6;
  8065 |     |         assembly {
  8066 |     |             function writeString(pos, w) {
  8067 |     |                 let length := 0
  8068 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8069 |     |                 mstore(pos, length)
  8070 |     |                 let shift := sub(256, shl(3, length))
  8071 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8072 |     |             }
  8073 |     |             m0 := mload(0x00)
  8074 |     |             m1 := mload(0x20)
  8075 |     |             m2 := mload(0x40)
  8076 |     |             m3 := mload(0x60)
  8077 |     |             m4 := mload(0x80)
  8078 |     |             m5 := mload(0xa0)
  8079 |     |             m6 := mload(0xc0)
  8080 |     |             // Selector of `log(uint256,address,uint256,string)`.
  8081 |     |             mstore(0x00, 0xddb06521)
  8082 |     |             mstore(0x20, p0)
  8083 |     |             mstore(0x40, p1)
  8084 |     |             mstore(0x60, p2)
  8085 |     |             mstore(0x80, 0x80)
  8086 |     |             writeString(0xa0, p3)
  8087 |     |         }
  8088 |     |         _sendLogPayload(0x1c, 0xc4);
  8089 |     |         assembly {
  8090 |     |             mstore(0x00, m0)
  8091 |     |             mstore(0x20, m1)
  8092 |     |             mstore(0x40, m2)
  8093 |     |             mstore(0x60, m3)
  8094 |     |             mstore(0x80, m4)
  8095 |     |             mstore(0xa0, m5)
  8096 |     |             mstore(0xc0, m6)
  8097 |     |         }
  8098 |     |     }
  8099 |     | 
  8100 |     |     function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {
  8101 |     |         bytes32 m0;
  8102 |     |         bytes32 m1;
  8103 |     |         bytes32 m2;
  8104 |     |         bytes32 m3;
  8105 |     |         bytes32 m4;
  8106 |     |         bytes32 m5;
  8107 |     |         bytes32 m6;
  8108 |     |         assembly {
  8109 |     |             function writeString(pos, w) {
  8110 |     |                 let length := 0
  8111 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8112 |     |                 mstore(pos, length)
  8113 |     |                 let shift := sub(256, shl(3, length))
  8114 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8115 |     |             }
  8116 |     |             m0 := mload(0x00)
  8117 |     |             m1 := mload(0x20)
  8118 |     |             m2 := mload(0x40)
  8119 |     |             m3 := mload(0x60)
  8120 |     |             m4 := mload(0x80)
  8121 |     |             m5 := mload(0xa0)
  8122 |     |             m6 := mload(0xc0)
  8123 |     |             // Selector of `log(uint256,address,string,address)`.
  8124 |     |             mstore(0x00, 0x9cba8fff)
  8125 |     |             mstore(0x20, p0)
  8126 |     |             mstore(0x40, p1)
  8127 |     |             mstore(0x60, 0x80)
  8128 |     |             mstore(0x80, p3)
  8129 |     |             writeString(0xa0, p2)
  8130 |     |         }
  8131 |     |         _sendLogPayload(0x1c, 0xc4);
  8132 |     |         assembly {
  8133 |     |             mstore(0x00, m0)
  8134 |     |             mstore(0x20, m1)
  8135 |     |             mstore(0x40, m2)
  8136 |     |             mstore(0x60, m3)
  8137 |     |             mstore(0x80, m4)
  8138 |     |             mstore(0xa0, m5)
  8139 |     |             mstore(0xc0, m6)
  8140 |     |         }
  8141 |     |     }
  8142 |     | 
  8143 |     |     function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {
  8144 |     |         bytes32 m0;
  8145 |     |         bytes32 m1;
  8146 |     |         bytes32 m2;
  8147 |     |         bytes32 m3;
  8148 |     |         bytes32 m4;
  8149 |     |         bytes32 m5;
  8150 |     |         bytes32 m6;
  8151 |     |         assembly {
  8152 |     |             function writeString(pos, w) {
  8153 |     |                 let length := 0
  8154 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8155 |     |                 mstore(pos, length)
  8156 |     |                 let shift := sub(256, shl(3, length))
  8157 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8158 |     |             }
  8159 |     |             m0 := mload(0x00)
  8160 |     |             m1 := mload(0x20)
  8161 |     |             m2 := mload(0x40)
  8162 |     |             m3 := mload(0x60)
  8163 |     |             m4 := mload(0x80)
  8164 |     |             m5 := mload(0xa0)
  8165 |     |             m6 := mload(0xc0)
  8166 |     |             // Selector of `log(uint256,address,string,bool)`.
  8167 |     |             mstore(0x00, 0xcc32ab07)
  8168 |     |             mstore(0x20, p0)
  8169 |     |             mstore(0x40, p1)
  8170 |     |             mstore(0x60, 0x80)
  8171 |     |             mstore(0x80, p3)
  8172 |     |             writeString(0xa0, p2)
  8173 |     |         }
  8174 |     |         _sendLogPayload(0x1c, 0xc4);
  8175 |     |         assembly {
  8176 |     |             mstore(0x00, m0)
  8177 |     |             mstore(0x20, m1)
  8178 |     |             mstore(0x40, m2)
  8179 |     |             mstore(0x60, m3)
  8180 |     |             mstore(0x80, m4)
  8181 |     |             mstore(0xa0, m5)
  8182 |     |             mstore(0xc0, m6)
  8183 |     |         }
  8184 |     |     }
  8185 |     | 
  8186 |     |     function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {
  8187 |     |         bytes32 m0;
  8188 |     |         bytes32 m1;
  8189 |     |         bytes32 m2;
  8190 |     |         bytes32 m3;
  8191 |     |         bytes32 m4;
  8192 |     |         bytes32 m5;
  8193 |     |         bytes32 m6;
  8194 |     |         assembly {
  8195 |     |             function writeString(pos, w) {
  8196 |     |                 let length := 0
  8197 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8198 |     |                 mstore(pos, length)
  8199 |     |                 let shift := sub(256, shl(3, length))
  8200 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8201 |     |             }
  8202 |     |             m0 := mload(0x00)
  8203 |     |             m1 := mload(0x20)
  8204 |     |             m2 := mload(0x40)
  8205 |     |             m3 := mload(0x60)
  8206 |     |             m4 := mload(0x80)
  8207 |     |             m5 := mload(0xa0)
  8208 |     |             m6 := mload(0xc0)
  8209 |     |             // Selector of `log(uint256,address,string,uint256)`.
  8210 |     |             mstore(0x00, 0x46826b5d)
  8211 |     |             mstore(0x20, p0)
  8212 |     |             mstore(0x40, p1)
  8213 |     |             mstore(0x60, 0x80)
  8214 |     |             mstore(0x80, p3)
  8215 |     |             writeString(0xa0, p2)
  8216 |     |         }
  8217 |     |         _sendLogPayload(0x1c, 0xc4);
  8218 |     |         assembly {
  8219 |     |             mstore(0x00, m0)
  8220 |     |             mstore(0x20, m1)
  8221 |     |             mstore(0x40, m2)
  8222 |     |             mstore(0x60, m3)
  8223 |     |             mstore(0x80, m4)
  8224 |     |             mstore(0xa0, m5)
  8225 |     |             mstore(0xc0, m6)
  8226 |     |         }
  8227 |     |     }
  8228 |     | 
  8229 |     |     function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  8230 |     |         bytes32 m0;
  8231 |     |         bytes32 m1;
  8232 |     |         bytes32 m2;
  8233 |     |         bytes32 m3;
  8234 |     |         bytes32 m4;
  8235 |     |         bytes32 m5;
  8236 |     |         bytes32 m6;
  8237 |     |         bytes32 m7;
  8238 |     |         bytes32 m8;
  8239 |     |         assembly {
  8240 |     |             function writeString(pos, w) {
  8241 |     |                 let length := 0
  8242 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8243 |     |                 mstore(pos, length)
  8244 |     |                 let shift := sub(256, shl(3, length))
  8245 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8246 |     |             }
  8247 |     |             m0 := mload(0x00)
  8248 |     |             m1 := mload(0x20)
  8249 |     |             m2 := mload(0x40)
  8250 |     |             m3 := mload(0x60)
  8251 |     |             m4 := mload(0x80)
  8252 |     |             m5 := mload(0xa0)
  8253 |     |             m6 := mload(0xc0)
  8254 |     |             m7 := mload(0xe0)
  8255 |     |             m8 := mload(0x100)
  8256 |     |             // Selector of `log(uint256,address,string,string)`.
  8257 |     |             mstore(0x00, 0x3e128ca3)
  8258 |     |             mstore(0x20, p0)
  8259 |     |             mstore(0x40, p1)
  8260 |     |             mstore(0x60, 0x80)
  8261 |     |             mstore(0x80, 0xc0)
  8262 |     |             writeString(0xa0, p2)
  8263 |     |             writeString(0xe0, p3)
  8264 |     |         }
  8265 |     |         _sendLogPayload(0x1c, 0x104);
  8266 |     |         assembly {
  8267 |     |             mstore(0x00, m0)
  8268 |     |             mstore(0x20, m1)
  8269 |     |             mstore(0x40, m2)
  8270 |     |             mstore(0x60, m3)
  8271 |     |             mstore(0x80, m4)
  8272 |     |             mstore(0xa0, m5)
  8273 |     |             mstore(0xc0, m6)
  8274 |     |             mstore(0xe0, m7)
  8275 |     |             mstore(0x100, m8)
  8276 |     |         }
  8277 |     |     }
  8278 |     | 
  8279 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  8280 |     |         bytes32 m0;
  8281 |     |         bytes32 m1;
  8282 |     |         bytes32 m2;
  8283 |     |         bytes32 m3;
  8284 |     |         bytes32 m4;
  8285 |     |         assembly {
  8286 |     |             m0 := mload(0x00)
  8287 |     |             m1 := mload(0x20)
  8288 |     |             m2 := mload(0x40)
  8289 |     |             m3 := mload(0x60)
  8290 |     |             m4 := mload(0x80)
  8291 |     |             // Selector of `log(uint256,bool,address,address)`.
  8292 |     |             mstore(0x00, 0xa1ef4cbb)
  8293 |     |             mstore(0x20, p0)
  8294 |     |             mstore(0x40, p1)
  8295 |     |             mstore(0x60, p2)
  8296 |     |             mstore(0x80, p3)
  8297 |     |         }
  8298 |     |         _sendLogPayload(0x1c, 0x84);
  8299 |     |         assembly {
  8300 |     |             mstore(0x00, m0)
  8301 |     |             mstore(0x20, m1)
  8302 |     |             mstore(0x40, m2)
  8303 |     |             mstore(0x60, m3)
  8304 |     |             mstore(0x80, m4)
  8305 |     |         }
  8306 |     |     }
  8307 |     | 
  8308 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  8309 |     |         bytes32 m0;
  8310 |     |         bytes32 m1;
  8311 |     |         bytes32 m2;
  8312 |     |         bytes32 m3;
  8313 |     |         bytes32 m4;
  8314 |     |         assembly {
  8315 |     |             m0 := mload(0x00)
  8316 |     |             m1 := mload(0x20)
  8317 |     |             m2 := mload(0x40)
  8318 |     |             m3 := mload(0x60)
  8319 |     |             m4 := mload(0x80)
  8320 |     |             // Selector of `log(uint256,bool,address,bool)`.
  8321 |     |             mstore(0x00, 0x454d54a5)
  8322 |     |             mstore(0x20, p0)
  8323 |     |             mstore(0x40, p1)
  8324 |     |             mstore(0x60, p2)
  8325 |     |             mstore(0x80, p3)
  8326 |     |         }
  8327 |     |         _sendLogPayload(0x1c, 0x84);
  8328 |     |         assembly {
  8329 |     |             mstore(0x00, m0)
  8330 |     |             mstore(0x20, m1)
  8331 |     |             mstore(0x40, m2)
  8332 |     |             mstore(0x60, m3)
  8333 |     |             mstore(0x80, m4)
  8334 |     |         }
  8335 |     |     }
  8336 |     | 
  8337 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  8338 |     |         bytes32 m0;
  8339 |     |         bytes32 m1;
  8340 |     |         bytes32 m2;
  8341 |     |         bytes32 m3;
  8342 |     |         bytes32 m4;
  8343 |     |         assembly {
  8344 |     |             m0 := mload(0x00)
  8345 |     |             m1 := mload(0x20)
  8346 |     |             m2 := mload(0x40)
  8347 |     |             m3 := mload(0x60)
  8348 |     |             m4 := mload(0x80)
  8349 |     |             // Selector of `log(uint256,bool,address,uint256)`.
  8350 |     |             mstore(0x00, 0x078287f5)
  8351 |     |             mstore(0x20, p0)
  8352 |     |             mstore(0x40, p1)
  8353 |     |             mstore(0x60, p2)
  8354 |     |             mstore(0x80, p3)
  8355 |     |         }
  8356 |     |         _sendLogPayload(0x1c, 0x84);
  8357 |     |         assembly {
  8358 |     |             mstore(0x00, m0)
  8359 |     |             mstore(0x20, m1)
  8360 |     |             mstore(0x40, m2)
  8361 |     |             mstore(0x60, m3)
  8362 |     |             mstore(0x80, m4)
  8363 |     |         }
  8364 |     |     }
  8365 |     | 
  8366 |     |     function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {
  8367 |     |         bytes32 m0;
  8368 |     |         bytes32 m1;
  8369 |     |         bytes32 m2;
  8370 |     |         bytes32 m3;
  8371 |     |         bytes32 m4;
  8372 |     |         bytes32 m5;
  8373 |     |         bytes32 m6;
  8374 |     |         assembly {
  8375 |     |             function writeString(pos, w) {
  8376 |     |                 let length := 0
  8377 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8378 |     |                 mstore(pos, length)
  8379 |     |                 let shift := sub(256, shl(3, length))
  8380 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8381 |     |             }
  8382 |     |             m0 := mload(0x00)
  8383 |     |             m1 := mload(0x20)
  8384 |     |             m2 := mload(0x40)
  8385 |     |             m3 := mload(0x60)
  8386 |     |             m4 := mload(0x80)
  8387 |     |             m5 := mload(0xa0)
  8388 |     |             m6 := mload(0xc0)
  8389 |     |             // Selector of `log(uint256,bool,address,string)`.
  8390 |     |             mstore(0x00, 0xade052c7)
  8391 |     |             mstore(0x20, p0)
  8392 |     |             mstore(0x40, p1)
  8393 |     |             mstore(0x60, p2)
  8394 |     |             mstore(0x80, 0x80)
  8395 |     |             writeString(0xa0, p3)
  8396 |     |         }
  8397 |     |         _sendLogPayload(0x1c, 0xc4);
  8398 |     |         assembly {
  8399 |     |             mstore(0x00, m0)
  8400 |     |             mstore(0x20, m1)
  8401 |     |             mstore(0x40, m2)
  8402 |     |             mstore(0x60, m3)
  8403 |     |             mstore(0x80, m4)
  8404 |     |             mstore(0xa0, m5)
  8405 |     |             mstore(0xc0, m6)
  8406 |     |         }
  8407 |     |     }
  8408 |     | 
  8409 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  8410 |     |         bytes32 m0;
  8411 |     |         bytes32 m1;
  8412 |     |         bytes32 m2;
  8413 |     |         bytes32 m3;
  8414 |     |         bytes32 m4;
  8415 |     |         assembly {
  8416 |     |             m0 := mload(0x00)
  8417 |     |             m1 := mload(0x20)
  8418 |     |             m2 := mload(0x40)
  8419 |     |             m3 := mload(0x60)
  8420 |     |             m4 := mload(0x80)
  8421 |     |             // Selector of `log(uint256,bool,bool,address)`.
  8422 |     |             mstore(0x00, 0x69640b59)
  8423 |     |             mstore(0x20, p0)
  8424 |     |             mstore(0x40, p1)
  8425 |     |             mstore(0x60, p2)
  8426 |     |             mstore(0x80, p3)
  8427 |     |         }
  8428 |     |         _sendLogPayload(0x1c, 0x84);
  8429 |     |         assembly {
  8430 |     |             mstore(0x00, m0)
  8431 |     |             mstore(0x20, m1)
  8432 |     |             mstore(0x40, m2)
  8433 |     |             mstore(0x60, m3)
  8434 |     |             mstore(0x80, m4)
  8435 |     |         }
  8436 |     |     }
  8437 |     | 
  8438 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  8439 |     |         bytes32 m0;
  8440 |     |         bytes32 m1;
  8441 |     |         bytes32 m2;
  8442 |     |         bytes32 m3;
  8443 |     |         bytes32 m4;
  8444 |     |         assembly {
  8445 |     |             m0 := mload(0x00)
  8446 |     |             m1 := mload(0x20)
  8447 |     |             m2 := mload(0x40)
  8448 |     |             m3 := mload(0x60)
  8449 |     |             m4 := mload(0x80)
  8450 |     |             // Selector of `log(uint256,bool,bool,bool)`.
  8451 |     |             mstore(0x00, 0xb6f577a1)
  8452 |     |             mstore(0x20, p0)
  8453 |     |             mstore(0x40, p1)
  8454 |     |             mstore(0x60, p2)
  8455 |     |             mstore(0x80, p3)
  8456 |     |         }
  8457 |     |         _sendLogPayload(0x1c, 0x84);
  8458 |     |         assembly {
  8459 |     |             mstore(0x00, m0)
  8460 |     |             mstore(0x20, m1)
  8461 |     |             mstore(0x40, m2)
  8462 |     |             mstore(0x60, m3)
  8463 |     |             mstore(0x80, m4)
  8464 |     |         }
  8465 |     |     }
  8466 |     | 
  8467 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  8468 |     |         bytes32 m0;
  8469 |     |         bytes32 m1;
  8470 |     |         bytes32 m2;
  8471 |     |         bytes32 m3;
  8472 |     |         bytes32 m4;
  8473 |     |         assembly {
  8474 |     |             m0 := mload(0x00)
  8475 |     |             m1 := mload(0x20)
  8476 |     |             m2 := mload(0x40)
  8477 |     |             m3 := mload(0x60)
  8478 |     |             m4 := mload(0x80)
  8479 |     |             // Selector of `log(uint256,bool,bool,uint256)`.
  8480 |     |             mstore(0x00, 0x7464ce23)
  8481 |     |             mstore(0x20, p0)
  8482 |     |             mstore(0x40, p1)
  8483 |     |             mstore(0x60, p2)
  8484 |     |             mstore(0x80, p3)
  8485 |     |         }
  8486 |     |         _sendLogPayload(0x1c, 0x84);
  8487 |     |         assembly {
  8488 |     |             mstore(0x00, m0)
  8489 |     |             mstore(0x20, m1)
  8490 |     |             mstore(0x40, m2)
  8491 |     |             mstore(0x60, m3)
  8492 |     |             mstore(0x80, m4)
  8493 |     |         }
  8494 |     |     }
  8495 |     | 
  8496 |     |     function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {
  8497 |     |         bytes32 m0;
  8498 |     |         bytes32 m1;
  8499 |     |         bytes32 m2;
  8500 |     |         bytes32 m3;
  8501 |     |         bytes32 m4;
  8502 |     |         bytes32 m5;
  8503 |     |         bytes32 m6;
  8504 |     |         assembly {
  8505 |     |             function writeString(pos, w) {
  8506 |     |                 let length := 0
  8507 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8508 |     |                 mstore(pos, length)
  8509 |     |                 let shift := sub(256, shl(3, length))
  8510 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8511 |     |             }
  8512 |     |             m0 := mload(0x00)
  8513 |     |             m1 := mload(0x20)
  8514 |     |             m2 := mload(0x40)
  8515 |     |             m3 := mload(0x60)
  8516 |     |             m4 := mload(0x80)
  8517 |     |             m5 := mload(0xa0)
  8518 |     |             m6 := mload(0xc0)
  8519 |     |             // Selector of `log(uint256,bool,bool,string)`.
  8520 |     |             mstore(0x00, 0xdddb9561)
  8521 |     |             mstore(0x20, p0)
  8522 |     |             mstore(0x40, p1)
  8523 |     |             mstore(0x60, p2)
  8524 |     |             mstore(0x80, 0x80)
  8525 |     |             writeString(0xa0, p3)
  8526 |     |         }
  8527 |     |         _sendLogPayload(0x1c, 0xc4);
  8528 |     |         assembly {
  8529 |     |             mstore(0x00, m0)
  8530 |     |             mstore(0x20, m1)
  8531 |     |             mstore(0x40, m2)
  8532 |     |             mstore(0x60, m3)
  8533 |     |             mstore(0x80, m4)
  8534 |     |             mstore(0xa0, m5)
  8535 |     |             mstore(0xc0, m6)
  8536 |     |         }
  8537 |     |     }
  8538 |     | 
  8539 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  8540 |     |         bytes32 m0;
  8541 |     |         bytes32 m1;
  8542 |     |         bytes32 m2;
  8543 |     |         bytes32 m3;
  8544 |     |         bytes32 m4;
  8545 |     |         assembly {
  8546 |     |             m0 := mload(0x00)
  8547 |     |             m1 := mload(0x20)
  8548 |     |             m2 := mload(0x40)
  8549 |     |             m3 := mload(0x60)
  8550 |     |             m4 := mload(0x80)
  8551 |     |             // Selector of `log(uint256,bool,uint256,address)`.
  8552 |     |             mstore(0x00, 0x88cb6041)
  8553 |     |             mstore(0x20, p0)
  8554 |     |             mstore(0x40, p1)
  8555 |     |             mstore(0x60, p2)
  8556 |     |             mstore(0x80, p3)
  8557 |     |         }
  8558 |     |         _sendLogPayload(0x1c, 0x84);
  8559 |     |         assembly {
  8560 |     |             mstore(0x00, m0)
  8561 |     |             mstore(0x20, m1)
  8562 |     |             mstore(0x40, m2)
  8563 |     |             mstore(0x60, m3)
  8564 |     |             mstore(0x80, m4)
  8565 |     |         }
  8566 |     |     }
  8567 |     | 
  8568 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  8569 |     |         bytes32 m0;
  8570 |     |         bytes32 m1;
  8571 |     |         bytes32 m2;
  8572 |     |         bytes32 m3;
  8573 |     |         bytes32 m4;
  8574 |     |         assembly {
  8575 |     |             m0 := mload(0x00)
  8576 |     |             m1 := mload(0x20)
  8577 |     |             m2 := mload(0x40)
  8578 |     |             m3 := mload(0x60)
  8579 |     |             m4 := mload(0x80)
  8580 |     |             // Selector of `log(uint256,bool,uint256,bool)`.
  8581 |     |             mstore(0x00, 0x91a02e2a)
  8582 |     |             mstore(0x20, p0)
  8583 |     |             mstore(0x40, p1)
  8584 |     |             mstore(0x60, p2)
  8585 |     |             mstore(0x80, p3)
  8586 |     |         }
  8587 |     |         _sendLogPayload(0x1c, 0x84);
  8588 |     |         assembly {
  8589 |     |             mstore(0x00, m0)
  8590 |     |             mstore(0x20, m1)
  8591 |     |             mstore(0x40, m2)
  8592 |     |             mstore(0x60, m3)
  8593 |     |             mstore(0x80, m4)
  8594 |     |         }
  8595 |     |     }
  8596 |     | 
  8597 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  8598 |     |         bytes32 m0;
  8599 |     |         bytes32 m1;
  8600 |     |         bytes32 m2;
  8601 |     |         bytes32 m3;
  8602 |     |         bytes32 m4;
  8603 |     |         assembly {
  8604 |     |             m0 := mload(0x00)
  8605 |     |             m1 := mload(0x20)
  8606 |     |             m2 := mload(0x40)
  8607 |     |             m3 := mload(0x60)
  8608 |     |             m4 := mload(0x80)
  8609 |     |             // Selector of `log(uint256,bool,uint256,uint256)`.
  8610 |     |             mstore(0x00, 0xc6acc7a8)
  8611 |     |             mstore(0x20, p0)
  8612 |     |             mstore(0x40, p1)
  8613 |     |             mstore(0x60, p2)
  8614 |     |             mstore(0x80, p3)
  8615 |     |         }
  8616 |     |         _sendLogPayload(0x1c, 0x84);
  8617 |     |         assembly {
  8618 |     |             mstore(0x00, m0)
  8619 |     |             mstore(0x20, m1)
  8620 |     |             mstore(0x40, m2)
  8621 |     |             mstore(0x60, m3)
  8622 |     |             mstore(0x80, m4)
  8623 |     |         }
  8624 |     |     }
  8625 |     | 
  8626 |     |     function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  8627 |     |         bytes32 m0;
  8628 |     |         bytes32 m1;
  8629 |     |         bytes32 m2;
  8630 |     |         bytes32 m3;
  8631 |     |         bytes32 m4;
  8632 |     |         bytes32 m5;
  8633 |     |         bytes32 m6;
  8634 |     |         assembly {
  8635 |     |             function writeString(pos, w) {
  8636 |     |                 let length := 0
  8637 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8638 |     |                 mstore(pos, length)
  8639 |     |                 let shift := sub(256, shl(3, length))
  8640 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8641 |     |             }
  8642 |     |             m0 := mload(0x00)
  8643 |     |             m1 := mload(0x20)
  8644 |     |             m2 := mload(0x40)
  8645 |     |             m3 := mload(0x60)
  8646 |     |             m4 := mload(0x80)
  8647 |     |             m5 := mload(0xa0)
  8648 |     |             m6 := mload(0xc0)
  8649 |     |             // Selector of `log(uint256,bool,uint256,string)`.
  8650 |     |             mstore(0x00, 0xde03e774)
  8651 |     |             mstore(0x20, p0)
  8652 |     |             mstore(0x40, p1)
  8653 |     |             mstore(0x60, p2)
  8654 |     |             mstore(0x80, 0x80)
  8655 |     |             writeString(0xa0, p3)
  8656 |     |         }
  8657 |     |         _sendLogPayload(0x1c, 0xc4);
  8658 |     |         assembly {
  8659 |     |             mstore(0x00, m0)
  8660 |     |             mstore(0x20, m1)
  8661 |     |             mstore(0x40, m2)
  8662 |     |             mstore(0x60, m3)
  8663 |     |             mstore(0x80, m4)
  8664 |     |             mstore(0xa0, m5)
  8665 |     |             mstore(0xc0, m6)
  8666 |     |         }
  8667 |     |     }
  8668 |     | 
  8669 |     |     function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {
  8670 |     |         bytes32 m0;
  8671 |     |         bytes32 m1;
  8672 |     |         bytes32 m2;
  8673 |     |         bytes32 m3;
  8674 |     |         bytes32 m4;
  8675 |     |         bytes32 m5;
  8676 |     |         bytes32 m6;
  8677 |     |         assembly {
  8678 |     |             function writeString(pos, w) {
  8679 |     |                 let length := 0
  8680 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8681 |     |                 mstore(pos, length)
  8682 |     |                 let shift := sub(256, shl(3, length))
  8683 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8684 |     |             }
  8685 |     |             m0 := mload(0x00)
  8686 |     |             m1 := mload(0x20)
  8687 |     |             m2 := mload(0x40)
  8688 |     |             m3 := mload(0x60)
  8689 |     |             m4 := mload(0x80)
  8690 |     |             m5 := mload(0xa0)
  8691 |     |             m6 := mload(0xc0)
  8692 |     |             // Selector of `log(uint256,bool,string,address)`.
  8693 |     |             mstore(0x00, 0xef529018)
  8694 |     |             mstore(0x20, p0)
  8695 |     |             mstore(0x40, p1)
  8696 |     |             mstore(0x60, 0x80)
  8697 |     |             mstore(0x80, p3)
  8698 |     |             writeString(0xa0, p2)
  8699 |     |         }
  8700 |     |         _sendLogPayload(0x1c, 0xc4);
  8701 |     |         assembly {
  8702 |     |             mstore(0x00, m0)
  8703 |     |             mstore(0x20, m1)
  8704 |     |             mstore(0x40, m2)
  8705 |     |             mstore(0x60, m3)
  8706 |     |             mstore(0x80, m4)
  8707 |     |             mstore(0xa0, m5)
  8708 |     |             mstore(0xc0, m6)
  8709 |     |         }
  8710 |     |     }
  8711 |     | 
  8712 |     |     function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {
  8713 |     |         bytes32 m0;
  8714 |     |         bytes32 m1;
  8715 |     |         bytes32 m2;
  8716 |     |         bytes32 m3;
  8717 |     |         bytes32 m4;
  8718 |     |         bytes32 m5;
  8719 |     |         bytes32 m6;
  8720 |     |         assembly {
  8721 |     |             function writeString(pos, w) {
  8722 |     |                 let length := 0
  8723 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8724 |     |                 mstore(pos, length)
  8725 |     |                 let shift := sub(256, shl(3, length))
  8726 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8727 |     |             }
  8728 |     |             m0 := mload(0x00)
  8729 |     |             m1 := mload(0x20)
  8730 |     |             m2 := mload(0x40)
  8731 |     |             m3 := mload(0x60)
  8732 |     |             m4 := mload(0x80)
  8733 |     |             m5 := mload(0xa0)
  8734 |     |             m6 := mload(0xc0)
  8735 |     |             // Selector of `log(uint256,bool,string,bool)`.
  8736 |     |             mstore(0x00, 0xeb928d7f)
  8737 |     |             mstore(0x20, p0)
  8738 |     |             mstore(0x40, p1)
  8739 |     |             mstore(0x60, 0x80)
  8740 |     |             mstore(0x80, p3)
  8741 |     |             writeString(0xa0, p2)
  8742 |     |         }
  8743 |     |         _sendLogPayload(0x1c, 0xc4);
  8744 |     |         assembly {
  8745 |     |             mstore(0x00, m0)
  8746 |     |             mstore(0x20, m1)
  8747 |     |             mstore(0x40, m2)
  8748 |     |             mstore(0x60, m3)
  8749 |     |             mstore(0x80, m4)
  8750 |     |             mstore(0xa0, m5)
  8751 |     |             mstore(0xc0, m6)
  8752 |     |         }
  8753 |     |     }
  8754 |     | 
  8755 |     |     function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  8756 |     |         bytes32 m0;
  8757 |     |         bytes32 m1;
  8758 |     |         bytes32 m2;
  8759 |     |         bytes32 m3;
  8760 |     |         bytes32 m4;
  8761 |     |         bytes32 m5;
  8762 |     |         bytes32 m6;
  8763 |     |         assembly {
  8764 |     |             function writeString(pos, w) {
  8765 |     |                 let length := 0
  8766 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8767 |     |                 mstore(pos, length)
  8768 |     |                 let shift := sub(256, shl(3, length))
  8769 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8770 |     |             }
  8771 |     |             m0 := mload(0x00)
  8772 |     |             m1 := mload(0x20)
  8773 |     |             m2 := mload(0x40)
  8774 |     |             m3 := mload(0x60)
  8775 |     |             m4 := mload(0x80)
  8776 |     |             m5 := mload(0xa0)
  8777 |     |             m6 := mload(0xc0)
  8778 |     |             // Selector of `log(uint256,bool,string,uint256)`.
  8779 |     |             mstore(0x00, 0x2c1d0746)
  8780 |     |             mstore(0x20, p0)
  8781 |     |             mstore(0x40, p1)
  8782 |     |             mstore(0x60, 0x80)
  8783 |     |             mstore(0x80, p3)
  8784 |     |             writeString(0xa0, p2)
  8785 |     |         }
  8786 |     |         _sendLogPayload(0x1c, 0xc4);
  8787 |     |         assembly {
  8788 |     |             mstore(0x00, m0)
  8789 |     |             mstore(0x20, m1)
  8790 |     |             mstore(0x40, m2)
  8791 |     |             mstore(0x60, m3)
  8792 |     |             mstore(0x80, m4)
  8793 |     |             mstore(0xa0, m5)
  8794 |     |             mstore(0xc0, m6)
  8795 |     |         }
  8796 |     |     }
  8797 |     | 
  8798 |     |     function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  8799 |     |         bytes32 m0;
  8800 |     |         bytes32 m1;
  8801 |     |         bytes32 m2;
  8802 |     |         bytes32 m3;
  8803 |     |         bytes32 m4;
  8804 |     |         bytes32 m5;
  8805 |     |         bytes32 m6;
  8806 |     |         bytes32 m7;
  8807 |     |         bytes32 m8;
  8808 |     |         assembly {
  8809 |     |             function writeString(pos, w) {
  8810 |     |                 let length := 0
  8811 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8812 |     |                 mstore(pos, length)
  8813 |     |                 let shift := sub(256, shl(3, length))
  8814 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8815 |     |             }
  8816 |     |             m0 := mload(0x00)
  8817 |     |             m1 := mload(0x20)
  8818 |     |             m2 := mload(0x40)
  8819 |     |             m3 := mload(0x60)
  8820 |     |             m4 := mload(0x80)
  8821 |     |             m5 := mload(0xa0)
  8822 |     |             m6 := mload(0xc0)
  8823 |     |             m7 := mload(0xe0)
  8824 |     |             m8 := mload(0x100)
  8825 |     |             // Selector of `log(uint256,bool,string,string)`.
  8826 |     |             mstore(0x00, 0x68c8b8bd)
  8827 |     |             mstore(0x20, p0)
  8828 |     |             mstore(0x40, p1)
  8829 |     |             mstore(0x60, 0x80)
  8830 |     |             mstore(0x80, 0xc0)
  8831 |     |             writeString(0xa0, p2)
  8832 |     |             writeString(0xe0, p3)
  8833 |     |         }
  8834 |     |         _sendLogPayload(0x1c, 0x104);
  8835 |     |         assembly {
  8836 |     |             mstore(0x00, m0)
  8837 |     |             mstore(0x20, m1)
  8838 |     |             mstore(0x40, m2)
  8839 |     |             mstore(0x60, m3)
  8840 |     |             mstore(0x80, m4)
  8841 |     |             mstore(0xa0, m5)
  8842 |     |             mstore(0xc0, m6)
  8843 |     |             mstore(0xe0, m7)
  8844 |     |             mstore(0x100, m8)
  8845 |     |         }
  8846 |     |     }
  8847 |     | 
  8848 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  8849 |     |         bytes32 m0;
  8850 |     |         bytes32 m1;
  8851 |     |         bytes32 m2;
  8852 |     |         bytes32 m3;
  8853 |     |         bytes32 m4;
  8854 |     |         assembly {
  8855 |     |             m0 := mload(0x00)
  8856 |     |             m1 := mload(0x20)
  8857 |     |             m2 := mload(0x40)
  8858 |     |             m3 := mload(0x60)
  8859 |     |             m4 := mload(0x80)
  8860 |     |             // Selector of `log(uint256,uint256,address,address)`.
  8861 |     |             mstore(0x00, 0x56a5d1b1)
  8862 |     |             mstore(0x20, p0)
  8863 |     |             mstore(0x40, p1)
  8864 |     |             mstore(0x60, p2)
  8865 |     |             mstore(0x80, p3)
  8866 |     |         }
  8867 |     |         _sendLogPayload(0x1c, 0x84);
  8868 |     |         assembly {
  8869 |     |             mstore(0x00, m0)
  8870 |     |             mstore(0x20, m1)
  8871 |     |             mstore(0x40, m2)
  8872 |     |             mstore(0x60, m3)
  8873 |     |             mstore(0x80, m4)
  8874 |     |         }
  8875 |     |     }
  8876 |     | 
  8877 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  8878 |     |         bytes32 m0;
  8879 |     |         bytes32 m1;
  8880 |     |         bytes32 m2;
  8881 |     |         bytes32 m3;
  8882 |     |         bytes32 m4;
  8883 |     |         assembly {
  8884 |     |             m0 := mload(0x00)
  8885 |     |             m1 := mload(0x20)
  8886 |     |             m2 := mload(0x40)
  8887 |     |             m3 := mload(0x60)
  8888 |     |             m4 := mload(0x80)
  8889 |     |             // Selector of `log(uint256,uint256,address,bool)`.
  8890 |     |             mstore(0x00, 0x15cac476)
  8891 |     |             mstore(0x20, p0)
  8892 |     |             mstore(0x40, p1)
  8893 |     |             mstore(0x60, p2)
  8894 |     |             mstore(0x80, p3)
  8895 |     |         }
  8896 |     |         _sendLogPayload(0x1c, 0x84);
  8897 |     |         assembly {
  8898 |     |             mstore(0x00, m0)
  8899 |     |             mstore(0x20, m1)
  8900 |     |             mstore(0x40, m2)
  8901 |     |             mstore(0x60, m3)
  8902 |     |             mstore(0x80, m4)
  8903 |     |         }
  8904 |     |     }
  8905 |     | 
  8906 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  8907 |     |         bytes32 m0;
  8908 |     |         bytes32 m1;
  8909 |     |         bytes32 m2;
  8910 |     |         bytes32 m3;
  8911 |     |         bytes32 m4;
  8912 |     |         assembly {
  8913 |     |             m0 := mload(0x00)
  8914 |     |             m1 := mload(0x20)
  8915 |     |             m2 := mload(0x40)
  8916 |     |             m3 := mload(0x60)
  8917 |     |             m4 := mload(0x80)
  8918 |     |             // Selector of `log(uint256,uint256,address,uint256)`.
  8919 |     |             mstore(0x00, 0x88f6e4b2)
  8920 |     |             mstore(0x20, p0)
  8921 |     |             mstore(0x40, p1)
  8922 |     |             mstore(0x60, p2)
  8923 |     |             mstore(0x80, p3)
  8924 |     |         }
  8925 |     |         _sendLogPayload(0x1c, 0x84);
  8926 |     |         assembly {
  8927 |     |             mstore(0x00, m0)
  8928 |     |             mstore(0x20, m1)
  8929 |     |             mstore(0x40, m2)
  8930 |     |             mstore(0x60, m3)
  8931 |     |             mstore(0x80, m4)
  8932 |     |         }
  8933 |     |     }
  8934 |     | 
  8935 |     |     function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {
  8936 |     |         bytes32 m0;
  8937 |     |         bytes32 m1;
  8938 |     |         bytes32 m2;
  8939 |     |         bytes32 m3;
  8940 |     |         bytes32 m4;
  8941 |     |         bytes32 m5;
  8942 |     |         bytes32 m6;
  8943 |     |         assembly {
  8944 |     |             function writeString(pos, w) {
  8945 |     |                 let length := 0
  8946 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8947 |     |                 mstore(pos, length)
  8948 |     |                 let shift := sub(256, shl(3, length))
  8949 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8950 |     |             }
  8951 |     |             m0 := mload(0x00)
  8952 |     |             m1 := mload(0x20)
  8953 |     |             m2 := mload(0x40)
  8954 |     |             m3 := mload(0x60)
  8955 |     |             m4 := mload(0x80)
  8956 |     |             m5 := mload(0xa0)
  8957 |     |             m6 := mload(0xc0)
  8958 |     |             // Selector of `log(uint256,uint256,address,string)`.
  8959 |     |             mstore(0x00, 0x6cde40b8)
  8960 |     |             mstore(0x20, p0)
  8961 |     |             mstore(0x40, p1)
  8962 |     |             mstore(0x60, p2)
  8963 |     |             mstore(0x80, 0x80)
  8964 |     |             writeString(0xa0, p3)
  8965 |     |         }
  8966 |     |         _sendLogPayload(0x1c, 0xc4);
  8967 |     |         assembly {
  8968 |     |             mstore(0x00, m0)
  8969 |     |             mstore(0x20, m1)
  8970 |     |             mstore(0x40, m2)
  8971 |     |             mstore(0x60, m3)
  8972 |     |             mstore(0x80, m4)
  8973 |     |             mstore(0xa0, m5)
  8974 |     |             mstore(0xc0, m6)
  8975 |     |         }
  8976 |     |     }
  8977 |     | 
  8978 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  8979 |     |         bytes32 m0;
  8980 |     |         bytes32 m1;
  8981 |     |         bytes32 m2;
  8982 |     |         bytes32 m3;
  8983 |     |         bytes32 m4;
  8984 |     |         assembly {
  8985 |     |             m0 := mload(0x00)
  8986 |     |             m1 := mload(0x20)
  8987 |     |             m2 := mload(0x40)
  8988 |     |             m3 := mload(0x60)
  8989 |     |             m4 := mload(0x80)
  8990 |     |             // Selector of `log(uint256,uint256,bool,address)`.
  8991 |     |             mstore(0x00, 0x9a816a83)
  8992 |     |             mstore(0x20, p0)
  8993 |     |             mstore(0x40, p1)
  8994 |     |             mstore(0x60, p2)
  8995 |     |             mstore(0x80, p3)
  8996 |     |         }
  8997 |     |         _sendLogPayload(0x1c, 0x84);
  8998 |     |         assembly {
  8999 |     |             mstore(0x00, m0)
  9000 |     |             mstore(0x20, m1)
  9001 |     |             mstore(0x40, m2)
  9002 |     |             mstore(0x60, m3)
  9003 |     |             mstore(0x80, m4)
  9004 |     |         }
  9005 |     |     }
  9006 |     | 
  9007 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  9008 |     |         bytes32 m0;
  9009 |     |         bytes32 m1;
  9010 |     |         bytes32 m2;
  9011 |     |         bytes32 m3;
  9012 |     |         bytes32 m4;
  9013 |     |         assembly {
  9014 |     |             m0 := mload(0x00)
  9015 |     |             m1 := mload(0x20)
  9016 |     |             m2 := mload(0x40)
  9017 |     |             m3 := mload(0x60)
  9018 |     |             m4 := mload(0x80)
  9019 |     |             // Selector of `log(uint256,uint256,bool,bool)`.
  9020 |     |             mstore(0x00, 0xab085ae6)
  9021 |     |             mstore(0x20, p0)
  9022 |     |             mstore(0x40, p1)
  9023 |     |             mstore(0x60, p2)
  9024 |     |             mstore(0x80, p3)
  9025 |     |         }
  9026 |     |         _sendLogPayload(0x1c, 0x84);
  9027 |     |         assembly {
  9028 |     |             mstore(0x00, m0)
  9029 |     |             mstore(0x20, m1)
  9030 |     |             mstore(0x40, m2)
  9031 |     |             mstore(0x60, m3)
  9032 |     |             mstore(0x80, m4)
  9033 |     |         }
  9034 |     |     }
  9035 |     | 
  9036 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  9037 |     |         bytes32 m0;
  9038 |     |         bytes32 m1;
  9039 |     |         bytes32 m2;
  9040 |     |         bytes32 m3;
  9041 |     |         bytes32 m4;
  9042 |     |         assembly {
  9043 |     |             m0 := mload(0x00)
  9044 |     |             m1 := mload(0x20)
  9045 |     |             m2 := mload(0x40)
  9046 |     |             m3 := mload(0x60)
  9047 |     |             m4 := mload(0x80)
  9048 |     |             // Selector of `log(uint256,uint256,bool,uint256)`.
  9049 |     |             mstore(0x00, 0xeb7f6fd2)
  9050 |     |             mstore(0x20, p0)
  9051 |     |             mstore(0x40, p1)
  9052 |     |             mstore(0x60, p2)
  9053 |     |             mstore(0x80, p3)
  9054 |     |         }
  9055 |     |         _sendLogPayload(0x1c, 0x84);
  9056 |     |         assembly {
  9057 |     |             mstore(0x00, m0)
  9058 |     |             mstore(0x20, m1)
  9059 |     |             mstore(0x40, m2)
  9060 |     |             mstore(0x60, m3)
  9061 |     |             mstore(0x80, m4)
  9062 |     |         }
  9063 |     |     }
  9064 |     | 
  9065 |     |     function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  9066 |     |         bytes32 m0;
  9067 |     |         bytes32 m1;
  9068 |     |         bytes32 m2;
  9069 |     |         bytes32 m3;
  9070 |     |         bytes32 m4;
  9071 |     |         bytes32 m5;
  9072 |     |         bytes32 m6;
  9073 |     |         assembly {
  9074 |     |             function writeString(pos, w) {
  9075 |     |                 let length := 0
  9076 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9077 |     |                 mstore(pos, length)
  9078 |     |                 let shift := sub(256, shl(3, length))
  9079 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9080 |     |             }
  9081 |     |             m0 := mload(0x00)
  9082 |     |             m1 := mload(0x20)
  9083 |     |             m2 := mload(0x40)
  9084 |     |             m3 := mload(0x60)
  9085 |     |             m4 := mload(0x80)
  9086 |     |             m5 := mload(0xa0)
  9087 |     |             m6 := mload(0xc0)
  9088 |     |             // Selector of `log(uint256,uint256,bool,string)`.
  9089 |     |             mstore(0x00, 0xa5b4fc99)
  9090 |     |             mstore(0x20, p0)
  9091 |     |             mstore(0x40, p1)
  9092 |     |             mstore(0x60, p2)
  9093 |     |             mstore(0x80, 0x80)
  9094 |     |             writeString(0xa0, p3)
  9095 |     |         }
  9096 |     |         _sendLogPayload(0x1c, 0xc4);
  9097 |     |         assembly {
  9098 |     |             mstore(0x00, m0)
  9099 |     |             mstore(0x20, m1)
  9100 |     |             mstore(0x40, m2)
  9101 |     |             mstore(0x60, m3)
  9102 |     |             mstore(0x80, m4)
  9103 |     |             mstore(0xa0, m5)
  9104 |     |             mstore(0xc0, m6)
  9105 |     |         }
  9106 |     |     }
  9107 |     | 
  9108 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  9109 |     |         bytes32 m0;
  9110 |     |         bytes32 m1;
  9111 |     |         bytes32 m2;
  9112 |     |         bytes32 m3;
  9113 |     |         bytes32 m4;
  9114 |     |         assembly {
  9115 |     |             m0 := mload(0x00)
  9116 |     |             m1 := mload(0x20)
  9117 |     |             m2 := mload(0x40)
  9118 |     |             m3 := mload(0x60)
  9119 |     |             m4 := mload(0x80)
  9120 |     |             // Selector of `log(uint256,uint256,uint256,address)`.
  9121 |     |             mstore(0x00, 0xfa8185af)
  9122 |     |             mstore(0x20, p0)
  9123 |     |             mstore(0x40, p1)
  9124 |     |             mstore(0x60, p2)
  9125 |     |             mstore(0x80, p3)
  9126 |     |         }
  9127 |     |         _sendLogPayload(0x1c, 0x84);
  9128 |     |         assembly {
  9129 |     |             mstore(0x00, m0)
  9130 |     |             mstore(0x20, m1)
  9131 |     |             mstore(0x40, m2)
  9132 |     |             mstore(0x60, m3)
  9133 |     |             mstore(0x80, m4)
  9134 |     |         }
  9135 |     |     }
  9136 |     | 
  9137 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  9138 |     |         bytes32 m0;
  9139 |     |         bytes32 m1;
  9140 |     |         bytes32 m2;
  9141 |     |         bytes32 m3;
  9142 |     |         bytes32 m4;
  9143 |     |         assembly {
  9144 |     |             m0 := mload(0x00)
  9145 |     |             m1 := mload(0x20)
  9146 |     |             m2 := mload(0x40)
  9147 |     |             m3 := mload(0x60)
  9148 |     |             m4 := mload(0x80)
  9149 |     |             // Selector of `log(uint256,uint256,uint256,bool)`.
  9150 |     |             mstore(0x00, 0xc598d185)
  9151 |     |             mstore(0x20, p0)
  9152 |     |             mstore(0x40, p1)
  9153 |     |             mstore(0x60, p2)
  9154 |     |             mstore(0x80, p3)
  9155 |     |         }
  9156 |     |         _sendLogPayload(0x1c, 0x84);
  9157 |     |         assembly {
  9158 |     |             mstore(0x00, m0)
  9159 |     |             mstore(0x20, m1)
  9160 |     |             mstore(0x40, m2)
  9161 |     |             mstore(0x60, m3)
  9162 |     |             mstore(0x80, m4)
  9163 |     |         }
  9164 |     |     }
  9165 |     | 
  9166 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  9167 |     |         bytes32 m0;
  9168 |     |         bytes32 m1;
  9169 |     |         bytes32 m2;
  9170 |     |         bytes32 m3;
  9171 |     |         bytes32 m4;
  9172 |     |         assembly {
  9173 |     |             m0 := mload(0x00)
  9174 |     |             m1 := mload(0x20)
  9175 |     |             m2 := mload(0x40)
  9176 |     |             m3 := mload(0x60)
  9177 |     |             m4 := mload(0x80)
  9178 |     |             // Selector of `log(uint256,uint256,uint256,uint256)`.
  9179 |     |             mstore(0x00, 0x193fb800)
  9180 |     |             mstore(0x20, p0)
  9181 |     |             mstore(0x40, p1)
  9182 |     |             mstore(0x60, p2)
  9183 |     |             mstore(0x80, p3)
  9184 |     |         }
  9185 |     |         _sendLogPayload(0x1c, 0x84);
  9186 |     |         assembly {
  9187 |     |             mstore(0x00, m0)
  9188 |     |             mstore(0x20, m1)
  9189 |     |             mstore(0x40, m2)
  9190 |     |             mstore(0x60, m3)
  9191 |     |             mstore(0x80, m4)
  9192 |     |         }
  9193 |     |     }
  9194 |     | 
  9195 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  9196 |     |         bytes32 m0;
  9197 |     |         bytes32 m1;
  9198 |     |         bytes32 m2;
  9199 |     |         bytes32 m3;
  9200 |     |         bytes32 m4;
  9201 |     |         bytes32 m5;
  9202 |     |         bytes32 m6;
  9203 |     |         assembly {
  9204 |     |             function writeString(pos, w) {
  9205 |     |                 let length := 0
  9206 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9207 |     |                 mstore(pos, length)
  9208 |     |                 let shift := sub(256, shl(3, length))
  9209 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9210 |     |             }
  9211 |     |             m0 := mload(0x00)
  9212 |     |             m1 := mload(0x20)
  9213 |     |             m2 := mload(0x40)
  9214 |     |             m3 := mload(0x60)
  9215 |     |             m4 := mload(0x80)
  9216 |     |             m5 := mload(0xa0)
  9217 |     |             m6 := mload(0xc0)
  9218 |     |             // Selector of `log(uint256,uint256,uint256,string)`.
  9219 |     |             mstore(0x00, 0x59cfcbe3)
  9220 |     |             mstore(0x20, p0)
  9221 |     |             mstore(0x40, p1)
  9222 |     |             mstore(0x60, p2)
  9223 |     |             mstore(0x80, 0x80)
  9224 |     |             writeString(0xa0, p3)
  9225 |     |         }
  9226 |     |         _sendLogPayload(0x1c, 0xc4);
  9227 |     |         assembly {
  9228 |     |             mstore(0x00, m0)
  9229 |     |             mstore(0x20, m1)
  9230 |     |             mstore(0x40, m2)
  9231 |     |             mstore(0x60, m3)
  9232 |     |             mstore(0x80, m4)
  9233 |     |             mstore(0xa0, m5)
  9234 |     |             mstore(0xc0, m6)
  9235 |     |         }
  9236 |     |     }
  9237 |     | 
  9238 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {
  9239 |     |         bytes32 m0;
  9240 |     |         bytes32 m1;
  9241 |     |         bytes32 m2;
  9242 |     |         bytes32 m3;
  9243 |     |         bytes32 m4;
  9244 |     |         bytes32 m5;
  9245 |     |         bytes32 m6;
  9246 |     |         assembly {
  9247 |     |             function writeString(pos, w) {
  9248 |     |                 let length := 0
  9249 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9250 |     |                 mstore(pos, length)
  9251 |     |                 let shift := sub(256, shl(3, length))
  9252 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9253 |     |             }
  9254 |     |             m0 := mload(0x00)
  9255 |     |             m1 := mload(0x20)
  9256 |     |             m2 := mload(0x40)
  9257 |     |             m3 := mload(0x60)
  9258 |     |             m4 := mload(0x80)
  9259 |     |             m5 := mload(0xa0)
  9260 |     |             m6 := mload(0xc0)
  9261 |     |             // Selector of `log(uint256,uint256,string,address)`.
  9262 |     |             mstore(0x00, 0x42d21db7)
  9263 |     |             mstore(0x20, p0)
  9264 |     |             mstore(0x40, p1)
  9265 |     |             mstore(0x60, 0x80)
  9266 |     |             mstore(0x80, p3)
  9267 |     |             writeString(0xa0, p2)
  9268 |     |         }
  9269 |     |         _sendLogPayload(0x1c, 0xc4);
  9270 |     |         assembly {
  9271 |     |             mstore(0x00, m0)
  9272 |     |             mstore(0x20, m1)
  9273 |     |             mstore(0x40, m2)
  9274 |     |             mstore(0x60, m3)
  9275 |     |             mstore(0x80, m4)
  9276 |     |             mstore(0xa0, m5)
  9277 |     |             mstore(0xc0, m6)
  9278 |     |         }
  9279 |     |     }
  9280 |     | 
  9281 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  9282 |     |         bytes32 m0;
  9283 |     |         bytes32 m1;
  9284 |     |         bytes32 m2;
  9285 |     |         bytes32 m3;
  9286 |     |         bytes32 m4;
  9287 |     |         bytes32 m5;
  9288 |     |         bytes32 m6;
  9289 |     |         assembly {
  9290 |     |             function writeString(pos, w) {
  9291 |     |                 let length := 0
  9292 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9293 |     |                 mstore(pos, length)
  9294 |     |                 let shift := sub(256, shl(3, length))
  9295 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9296 |     |             }
  9297 |     |             m0 := mload(0x00)
  9298 |     |             m1 := mload(0x20)
  9299 |     |             m2 := mload(0x40)
  9300 |     |             m3 := mload(0x60)
  9301 |     |             m4 := mload(0x80)
  9302 |     |             m5 := mload(0xa0)
  9303 |     |             m6 := mload(0xc0)
  9304 |     |             // Selector of `log(uint256,uint256,string,bool)`.
  9305 |     |             mstore(0x00, 0x7af6ab25)
  9306 |     |             mstore(0x20, p0)
  9307 |     |             mstore(0x40, p1)
  9308 |     |             mstore(0x60, 0x80)
  9309 |     |             mstore(0x80, p3)
  9310 |     |             writeString(0xa0, p2)
  9311 |     |         }
  9312 |     |         _sendLogPayload(0x1c, 0xc4);
  9313 |     |         assembly {
  9314 |     |             mstore(0x00, m0)
  9315 |     |             mstore(0x20, m1)
  9316 |     |             mstore(0x40, m2)
  9317 |     |             mstore(0x60, m3)
  9318 |     |             mstore(0x80, m4)
  9319 |     |             mstore(0xa0, m5)
  9320 |     |             mstore(0xc0, m6)
  9321 |     |         }
  9322 |     |     }
  9323 |     | 
  9324 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  9325 |     |         bytes32 m0;
  9326 |     |         bytes32 m1;
  9327 |     |         bytes32 m2;
  9328 |     |         bytes32 m3;
  9329 |     |         bytes32 m4;
  9330 |     |         bytes32 m5;
  9331 |     |         bytes32 m6;
  9332 |     |         assembly {
  9333 |     |             function writeString(pos, w) {
  9334 |     |                 let length := 0
  9335 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9336 |     |                 mstore(pos, length)
  9337 |     |                 let shift := sub(256, shl(3, length))
  9338 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9339 |     |             }
  9340 |     |             m0 := mload(0x00)
  9341 |     |             m1 := mload(0x20)
  9342 |     |             m2 := mload(0x40)
  9343 |     |             m3 := mload(0x60)
  9344 |     |             m4 := mload(0x80)
  9345 |     |             m5 := mload(0xa0)
  9346 |     |             m6 := mload(0xc0)
  9347 |     |             // Selector of `log(uint256,uint256,string,uint256)`.
  9348 |     |             mstore(0x00, 0x5da297eb)
  9349 |     |             mstore(0x20, p0)
  9350 |     |             mstore(0x40, p1)
  9351 |     |             mstore(0x60, 0x80)
  9352 |     |             mstore(0x80, p3)
  9353 |     |             writeString(0xa0, p2)
  9354 |     |         }
  9355 |     |         _sendLogPayload(0x1c, 0xc4);
  9356 |     |         assembly {
  9357 |     |             mstore(0x00, m0)
  9358 |     |             mstore(0x20, m1)
  9359 |     |             mstore(0x40, m2)
  9360 |     |             mstore(0x60, m3)
  9361 |     |             mstore(0x80, m4)
  9362 |     |             mstore(0xa0, m5)
  9363 |     |             mstore(0xc0, m6)
  9364 |     |         }
  9365 |     |     }
  9366 |     | 
  9367 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  9368 |     |         bytes32 m0;
  9369 |     |         bytes32 m1;
  9370 |     |         bytes32 m2;
  9371 |     |         bytes32 m3;
  9372 |     |         bytes32 m4;
  9373 |     |         bytes32 m5;
  9374 |     |         bytes32 m6;
  9375 |     |         bytes32 m7;
  9376 |     |         bytes32 m8;
  9377 |     |         assembly {
  9378 |     |             function writeString(pos, w) {
  9379 |     |                 let length := 0
  9380 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9381 |     |                 mstore(pos, length)
  9382 |     |                 let shift := sub(256, shl(3, length))
  9383 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9384 |     |             }
  9385 |     |             m0 := mload(0x00)
  9386 |     |             m1 := mload(0x20)
  9387 |     |             m2 := mload(0x40)
  9388 |     |             m3 := mload(0x60)
  9389 |     |             m4 := mload(0x80)
  9390 |     |             m5 := mload(0xa0)
  9391 |     |             m6 := mload(0xc0)
  9392 |     |             m7 := mload(0xe0)
  9393 |     |             m8 := mload(0x100)
  9394 |     |             // Selector of `log(uint256,uint256,string,string)`.
  9395 |     |             mstore(0x00, 0x27d8afd2)
  9396 |     |             mstore(0x20, p0)
  9397 |     |             mstore(0x40, p1)
  9398 |     |             mstore(0x60, 0x80)
  9399 |     |             mstore(0x80, 0xc0)
  9400 |     |             writeString(0xa0, p2)
  9401 |     |             writeString(0xe0, p3)
  9402 |     |         }
  9403 |     |         _sendLogPayload(0x1c, 0x104);
  9404 |     |         assembly {
  9405 |     |             mstore(0x00, m0)
  9406 |     |             mstore(0x20, m1)
  9407 |     |             mstore(0x40, m2)
  9408 |     |             mstore(0x60, m3)
  9409 |     |             mstore(0x80, m4)
  9410 |     |             mstore(0xa0, m5)
  9411 |     |             mstore(0xc0, m6)
  9412 |     |             mstore(0xe0, m7)
  9413 |     |             mstore(0x100, m8)
  9414 |     |         }
  9415 |     |     }
  9416 |     | 
  9417 |     |     function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {
  9418 |     |         bytes32 m0;
  9419 |     |         bytes32 m1;
  9420 |     |         bytes32 m2;
  9421 |     |         bytes32 m3;
  9422 |     |         bytes32 m4;
  9423 |     |         bytes32 m5;
  9424 |     |         bytes32 m6;
  9425 |     |         assembly {
  9426 |     |             function writeString(pos, w) {
  9427 |     |                 let length := 0
  9428 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9429 |     |                 mstore(pos, length)
  9430 |     |                 let shift := sub(256, shl(3, length))
  9431 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9432 |     |             }
  9433 |     |             m0 := mload(0x00)
  9434 |     |             m1 := mload(0x20)
  9435 |     |             m2 := mload(0x40)
  9436 |     |             m3 := mload(0x60)
  9437 |     |             m4 := mload(0x80)
  9438 |     |             m5 := mload(0xa0)
  9439 |     |             m6 := mload(0xc0)
  9440 |     |             // Selector of `log(uint256,string,address,address)`.
  9441 |     |             mstore(0x00, 0x6168ed61)
  9442 |     |             mstore(0x20, p0)
  9443 |     |             mstore(0x40, 0x80)
  9444 |     |             mstore(0x60, p2)
  9445 |     |             mstore(0x80, p3)
  9446 |     |             writeString(0xa0, p1)
  9447 |     |         }
  9448 |     |         _sendLogPayload(0x1c, 0xc4);
  9449 |     |         assembly {
  9450 |     |             mstore(0x00, m0)
  9451 |     |             mstore(0x20, m1)
  9452 |     |             mstore(0x40, m2)
  9453 |     |             mstore(0x60, m3)
  9454 |     |             mstore(0x80, m4)
  9455 |     |             mstore(0xa0, m5)
  9456 |     |             mstore(0xc0, m6)
  9457 |     |         }
  9458 |     |     }
  9459 |     | 
  9460 |     |     function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {
  9461 |     |         bytes32 m0;
  9462 |     |         bytes32 m1;
  9463 |     |         bytes32 m2;
  9464 |     |         bytes32 m3;
  9465 |     |         bytes32 m4;
  9466 |     |         bytes32 m5;
  9467 |     |         bytes32 m6;
  9468 |     |         assembly {
  9469 |     |             function writeString(pos, w) {
  9470 |     |                 let length := 0
  9471 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9472 |     |                 mstore(pos, length)
  9473 |     |                 let shift := sub(256, shl(3, length))
  9474 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9475 |     |             }
  9476 |     |             m0 := mload(0x00)
  9477 |     |             m1 := mload(0x20)
  9478 |     |             m2 := mload(0x40)
  9479 |     |             m3 := mload(0x60)
  9480 |     |             m4 := mload(0x80)
  9481 |     |             m5 := mload(0xa0)
  9482 |     |             m6 := mload(0xc0)
  9483 |     |             // Selector of `log(uint256,string,address,bool)`.
  9484 |     |             mstore(0x00, 0x90c30a56)
  9485 |     |             mstore(0x20, p0)
  9486 |     |             mstore(0x40, 0x80)
  9487 |     |             mstore(0x60, p2)
  9488 |     |             mstore(0x80, p3)
  9489 |     |             writeString(0xa0, p1)
  9490 |     |         }
  9491 |     |         _sendLogPayload(0x1c, 0xc4);
  9492 |     |         assembly {
  9493 |     |             mstore(0x00, m0)
  9494 |     |             mstore(0x20, m1)
  9495 |     |             mstore(0x40, m2)
  9496 |     |             mstore(0x60, m3)
  9497 |     |             mstore(0x80, m4)
  9498 |     |             mstore(0xa0, m5)
  9499 |     |             mstore(0xc0, m6)
  9500 |     |         }
  9501 |     |     }
  9502 |     | 
  9503 |     |     function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {
  9504 |     |         bytes32 m0;
  9505 |     |         bytes32 m1;
  9506 |     |         bytes32 m2;
  9507 |     |         bytes32 m3;
  9508 |     |         bytes32 m4;
  9509 |     |         bytes32 m5;
  9510 |     |         bytes32 m6;
  9511 |     |         assembly {
  9512 |     |             function writeString(pos, w) {
  9513 |     |                 let length := 0
  9514 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9515 |     |                 mstore(pos, length)
  9516 |     |                 let shift := sub(256, shl(3, length))
  9517 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9518 |     |             }
  9519 |     |             m0 := mload(0x00)
  9520 |     |             m1 := mload(0x20)
  9521 |     |             m2 := mload(0x40)
  9522 |     |             m3 := mload(0x60)
  9523 |     |             m4 := mload(0x80)
  9524 |     |             m5 := mload(0xa0)
  9525 |     |             m6 := mload(0xc0)
  9526 |     |             // Selector of `log(uint256,string,address,uint256)`.
  9527 |     |             mstore(0x00, 0xe8d3018d)
  9528 |     |             mstore(0x20, p0)
  9529 |     |             mstore(0x40, 0x80)
  9530 |     |             mstore(0x60, p2)
  9531 |     |             mstore(0x80, p3)
  9532 |     |             writeString(0xa0, p1)
  9533 |     |         }
  9534 |     |         _sendLogPayload(0x1c, 0xc4);
  9535 |     |         assembly {
  9536 |     |             mstore(0x00, m0)
  9537 |     |             mstore(0x20, m1)
  9538 |     |             mstore(0x40, m2)
  9539 |     |             mstore(0x60, m3)
  9540 |     |             mstore(0x80, m4)
  9541 |     |             mstore(0xa0, m5)
  9542 |     |             mstore(0xc0, m6)
  9543 |     |         }
  9544 |     |     }
  9545 |     | 
  9546 |     |     function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  9547 |     |         bytes32 m0;
  9548 |     |         bytes32 m1;
  9549 |     |         bytes32 m2;
  9550 |     |         bytes32 m3;
  9551 |     |         bytes32 m4;
  9552 |     |         bytes32 m5;
  9553 |     |         bytes32 m6;
  9554 |     |         bytes32 m7;
  9555 |     |         bytes32 m8;
  9556 |     |         assembly {
  9557 |     |             function writeString(pos, w) {
  9558 |     |                 let length := 0
  9559 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9560 |     |                 mstore(pos, length)
  9561 |     |                 let shift := sub(256, shl(3, length))
  9562 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9563 |     |             }
  9564 |     |             m0 := mload(0x00)
  9565 |     |             m1 := mload(0x20)
  9566 |     |             m2 := mload(0x40)
  9567 |     |             m3 := mload(0x60)
  9568 |     |             m4 := mload(0x80)
  9569 |     |             m5 := mload(0xa0)
  9570 |     |             m6 := mload(0xc0)
  9571 |     |             m7 := mload(0xe0)
  9572 |     |             m8 := mload(0x100)
  9573 |     |             // Selector of `log(uint256,string,address,string)`.
  9574 |     |             mstore(0x00, 0x9c3adfa1)
  9575 |     |             mstore(0x20, p0)
  9576 |     |             mstore(0x40, 0x80)
  9577 |     |             mstore(0x60, p2)
  9578 |     |             mstore(0x80, 0xc0)
  9579 |     |             writeString(0xa0, p1)
  9580 |     |             writeString(0xe0, p3)
  9581 |     |         }
  9582 |     |         _sendLogPayload(0x1c, 0x104);
  9583 |     |         assembly {
  9584 |     |             mstore(0x00, m0)
  9585 |     |             mstore(0x20, m1)
  9586 |     |             mstore(0x40, m2)
  9587 |     |             mstore(0x60, m3)
  9588 |     |             mstore(0x80, m4)
  9589 |     |             mstore(0xa0, m5)
  9590 |     |             mstore(0xc0, m6)
  9591 |     |             mstore(0xe0, m7)
  9592 |     |             mstore(0x100, m8)
  9593 |     |         }
  9594 |     |     }
  9595 |     | 
  9596 |     |     function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {
  9597 |     |         bytes32 m0;
  9598 |     |         bytes32 m1;
  9599 |     |         bytes32 m2;
  9600 |     |         bytes32 m3;
  9601 |     |         bytes32 m4;
  9602 |     |         bytes32 m5;
  9603 |     |         bytes32 m6;
  9604 |     |         assembly {
  9605 |     |             function writeString(pos, w) {
  9606 |     |                 let length := 0
  9607 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9608 |     |                 mstore(pos, length)
  9609 |     |                 let shift := sub(256, shl(3, length))
  9610 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9611 |     |             }
  9612 |     |             m0 := mload(0x00)
  9613 |     |             m1 := mload(0x20)
  9614 |     |             m2 := mload(0x40)
  9615 |     |             m3 := mload(0x60)
  9616 |     |             m4 := mload(0x80)
  9617 |     |             m5 := mload(0xa0)
  9618 |     |             m6 := mload(0xc0)
  9619 |     |             // Selector of `log(uint256,string,bool,address)`.
  9620 |     |             mstore(0x00, 0xae2ec581)
  9621 |     |             mstore(0x20, p0)
  9622 |     |             mstore(0x40, 0x80)
  9623 |     |             mstore(0x60, p2)
  9624 |     |             mstore(0x80, p3)
  9625 |     |             writeString(0xa0, p1)
  9626 |     |         }
  9627 |     |         _sendLogPayload(0x1c, 0xc4);
  9628 |     |         assembly {
  9629 |     |             mstore(0x00, m0)
  9630 |     |             mstore(0x20, m1)
  9631 |     |             mstore(0x40, m2)
  9632 |     |             mstore(0x60, m3)
  9633 |     |             mstore(0x80, m4)
  9634 |     |             mstore(0xa0, m5)
  9635 |     |             mstore(0xc0, m6)
  9636 |     |         }
  9637 |     |     }
  9638 |     | 
  9639 |     |     function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {
  9640 |     |         bytes32 m0;
  9641 |     |         bytes32 m1;
  9642 |     |         bytes32 m2;
  9643 |     |         bytes32 m3;
  9644 |     |         bytes32 m4;
  9645 |     |         bytes32 m5;
  9646 |     |         bytes32 m6;
  9647 |     |         assembly {
  9648 |     |             function writeString(pos, w) {
  9649 |     |                 let length := 0
  9650 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9651 |     |                 mstore(pos, length)
  9652 |     |                 let shift := sub(256, shl(3, length))
  9653 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9654 |     |             }
  9655 |     |             m0 := mload(0x00)
  9656 |     |             m1 := mload(0x20)
  9657 |     |             m2 := mload(0x40)
  9658 |     |             m3 := mload(0x60)
  9659 |     |             m4 := mload(0x80)
  9660 |     |             m5 := mload(0xa0)
  9661 |     |             m6 := mload(0xc0)
  9662 |     |             // Selector of `log(uint256,string,bool,bool)`.
  9663 |     |             mstore(0x00, 0xba535d9c)
  9664 |     |             mstore(0x20, p0)
  9665 |     |             mstore(0x40, 0x80)
  9666 |     |             mstore(0x60, p2)
  9667 |     |             mstore(0x80, p3)
  9668 |     |             writeString(0xa0, p1)
  9669 |     |         }
  9670 |     |         _sendLogPayload(0x1c, 0xc4);
  9671 |     |         assembly {
  9672 |     |             mstore(0x00, m0)
  9673 |     |             mstore(0x20, m1)
  9674 |     |             mstore(0x40, m2)
  9675 |     |             mstore(0x60, m3)
  9676 |     |             mstore(0x80, m4)
  9677 |     |             mstore(0xa0, m5)
  9678 |     |             mstore(0xc0, m6)
  9679 |     |         }
  9680 |     |     }
  9681 |     | 
  9682 |     |     function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  9683 |     |         bytes32 m0;
  9684 |     |         bytes32 m1;
  9685 |     |         bytes32 m2;
  9686 |     |         bytes32 m3;
  9687 |     |         bytes32 m4;
  9688 |     |         bytes32 m5;
  9689 |     |         bytes32 m6;
  9690 |     |         assembly {
  9691 |     |             function writeString(pos, w) {
  9692 |     |                 let length := 0
  9693 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9694 |     |                 mstore(pos, length)
  9695 |     |                 let shift := sub(256, shl(3, length))
  9696 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9697 |     |             }
  9698 |     |             m0 := mload(0x00)
  9699 |     |             m1 := mload(0x20)
  9700 |     |             m2 := mload(0x40)
  9701 |     |             m3 := mload(0x60)
  9702 |     |             m4 := mload(0x80)
  9703 |     |             m5 := mload(0xa0)
  9704 |     |             m6 := mload(0xc0)
  9705 |     |             // Selector of `log(uint256,string,bool,uint256)`.
  9706 |     |             mstore(0x00, 0xcf009880)
  9707 |     |             mstore(0x20, p0)
  9708 |     |             mstore(0x40, 0x80)
  9709 |     |             mstore(0x60, p2)
  9710 |     |             mstore(0x80, p3)
  9711 |     |             writeString(0xa0, p1)
  9712 |     |         }
  9713 |     |         _sendLogPayload(0x1c, 0xc4);
  9714 |     |         assembly {
  9715 |     |             mstore(0x00, m0)
  9716 |     |             mstore(0x20, m1)
  9717 |     |             mstore(0x40, m2)
  9718 |     |             mstore(0x60, m3)
  9719 |     |             mstore(0x80, m4)
  9720 |     |             mstore(0xa0, m5)
  9721 |     |             mstore(0xc0, m6)
  9722 |     |         }
  9723 |     |     }
  9724 |     | 
  9725 |     |     function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  9726 |     |         bytes32 m0;
  9727 |     |         bytes32 m1;
  9728 |     |         bytes32 m2;
  9729 |     |         bytes32 m3;
  9730 |     |         bytes32 m4;
  9731 |     |         bytes32 m5;
  9732 |     |         bytes32 m6;
  9733 |     |         bytes32 m7;
  9734 |     |         bytes32 m8;
  9735 |     |         assembly {
  9736 |     |             function writeString(pos, w) {
  9737 |     |                 let length := 0
  9738 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9739 |     |                 mstore(pos, length)
  9740 |     |                 let shift := sub(256, shl(3, length))
  9741 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9742 |     |             }
  9743 |     |             m0 := mload(0x00)
  9744 |     |             m1 := mload(0x20)
  9745 |     |             m2 := mload(0x40)
  9746 |     |             m3 := mload(0x60)
  9747 |     |             m4 := mload(0x80)
  9748 |     |             m5 := mload(0xa0)
  9749 |     |             m6 := mload(0xc0)
  9750 |     |             m7 := mload(0xe0)
  9751 |     |             m8 := mload(0x100)
  9752 |     |             // Selector of `log(uint256,string,bool,string)`.
  9753 |     |             mstore(0x00, 0xd2d423cd)
  9754 |     |             mstore(0x20, p0)
  9755 |     |             mstore(0x40, 0x80)
  9756 |     |             mstore(0x60, p2)
  9757 |     |             mstore(0x80, 0xc0)
  9758 |     |             writeString(0xa0, p1)
  9759 |     |             writeString(0xe0, p3)
  9760 |     |         }
  9761 |     |         _sendLogPayload(0x1c, 0x104);
  9762 |     |         assembly {
  9763 |     |             mstore(0x00, m0)
  9764 |     |             mstore(0x20, m1)
  9765 |     |             mstore(0x40, m2)
  9766 |     |             mstore(0x60, m3)
  9767 |     |             mstore(0x80, m4)
  9768 |     |             mstore(0xa0, m5)
  9769 |     |             mstore(0xc0, m6)
  9770 |     |             mstore(0xe0, m7)
  9771 |     |             mstore(0x100, m8)
  9772 |     |         }
  9773 |     |     }
  9774 |     | 
  9775 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {
  9776 |     |         bytes32 m0;
  9777 |     |         bytes32 m1;
  9778 |     |         bytes32 m2;
  9779 |     |         bytes32 m3;
  9780 |     |         bytes32 m4;
  9781 |     |         bytes32 m5;
  9782 |     |         bytes32 m6;
  9783 |     |         assembly {
  9784 |     |             function writeString(pos, w) {
  9785 |     |                 let length := 0
  9786 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9787 |     |                 mstore(pos, length)
  9788 |     |                 let shift := sub(256, shl(3, length))
  9789 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9790 |     |             }
  9791 |     |             m0 := mload(0x00)
  9792 |     |             m1 := mload(0x20)
  9793 |     |             m2 := mload(0x40)
  9794 |     |             m3 := mload(0x60)
  9795 |     |             m4 := mload(0x80)
  9796 |     |             m5 := mload(0xa0)
  9797 |     |             m6 := mload(0xc0)
  9798 |     |             // Selector of `log(uint256,string,uint256,address)`.
  9799 |     |             mstore(0x00, 0x3b2279b4)
  9800 |     |             mstore(0x20, p0)
  9801 |     |             mstore(0x40, 0x80)
  9802 |     |             mstore(0x60, p2)
  9803 |     |             mstore(0x80, p3)
  9804 |     |             writeString(0xa0, p1)
  9805 |     |         }
  9806 |     |         _sendLogPayload(0x1c, 0xc4);
  9807 |     |         assembly {
  9808 |     |             mstore(0x00, m0)
  9809 |     |             mstore(0x20, m1)
  9810 |     |             mstore(0x40, m2)
  9811 |     |             mstore(0x60, m3)
  9812 |     |             mstore(0x80, m4)
  9813 |     |             mstore(0xa0, m5)
  9814 |     |             mstore(0xc0, m6)
  9815 |     |         }
  9816 |     |     }
  9817 |     | 
  9818 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  9819 |     |         bytes32 m0;
  9820 |     |         bytes32 m1;
  9821 |     |         bytes32 m2;
  9822 |     |         bytes32 m3;
  9823 |     |         bytes32 m4;
  9824 |     |         bytes32 m5;
  9825 |     |         bytes32 m6;
  9826 |     |         assembly {
  9827 |     |             function writeString(pos, w) {
  9828 |     |                 let length := 0
  9829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9830 |     |                 mstore(pos, length)
  9831 |     |                 let shift := sub(256, shl(3, length))
  9832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9833 |     |             }
  9834 |     |             m0 := mload(0x00)
  9835 |     |             m1 := mload(0x20)
  9836 |     |             m2 := mload(0x40)
  9837 |     |             m3 := mload(0x60)
  9838 |     |             m4 := mload(0x80)
  9839 |     |             m5 := mload(0xa0)
  9840 |     |             m6 := mload(0xc0)
  9841 |     |             // Selector of `log(uint256,string,uint256,bool)`.
  9842 |     |             mstore(0x00, 0x691a8f74)
  9843 |     |             mstore(0x20, p0)
  9844 |     |             mstore(0x40, 0x80)
  9845 |     |             mstore(0x60, p2)
  9846 |     |             mstore(0x80, p3)
  9847 |     |             writeString(0xa0, p1)
  9848 |     |         }
  9849 |     |         _sendLogPayload(0x1c, 0xc4);
  9850 |     |         assembly {
  9851 |     |             mstore(0x00, m0)
  9852 |     |             mstore(0x20, m1)
  9853 |     |             mstore(0x40, m2)
  9854 |     |             mstore(0x60, m3)
  9855 |     |             mstore(0x80, m4)
  9856 |     |             mstore(0xa0, m5)
  9857 |     |             mstore(0xc0, m6)
  9858 |     |         }
  9859 |     |     }
  9860 |     | 
  9861 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  9862 |     |         bytes32 m0;
  9863 |     |         bytes32 m1;
  9864 |     |         bytes32 m2;
  9865 |     |         bytes32 m3;
  9866 |     |         bytes32 m4;
  9867 |     |         bytes32 m5;
  9868 |     |         bytes32 m6;
  9869 |     |         assembly {
  9870 |     |             function writeString(pos, w) {
  9871 |     |                 let length := 0
  9872 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9873 |     |                 mstore(pos, length)
  9874 |     |                 let shift := sub(256, shl(3, length))
  9875 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9876 |     |             }
  9877 |     |             m0 := mload(0x00)
  9878 |     |             m1 := mload(0x20)
  9879 |     |             m2 := mload(0x40)
  9880 |     |             m3 := mload(0x60)
  9881 |     |             m4 := mload(0x80)
  9882 |     |             m5 := mload(0xa0)
  9883 |     |             m6 := mload(0xc0)
  9884 |     |             // Selector of `log(uint256,string,uint256,uint256)`.
  9885 |     |             mstore(0x00, 0x82c25b74)
  9886 |     |             mstore(0x20, p0)
  9887 |     |             mstore(0x40, 0x80)
  9888 |     |             mstore(0x60, p2)
  9889 |     |             mstore(0x80, p3)
  9890 |     |             writeString(0xa0, p1)
  9891 |     |         }
  9892 |     |         _sendLogPayload(0x1c, 0xc4);
  9893 |     |         assembly {
  9894 |     |             mstore(0x00, m0)
  9895 |     |             mstore(0x20, m1)
  9896 |     |             mstore(0x40, m2)
  9897 |     |             mstore(0x60, m3)
  9898 |     |             mstore(0x80, m4)
  9899 |     |             mstore(0xa0, m5)
  9900 |     |             mstore(0xc0, m6)
  9901 |     |         }
  9902 |     |     }
  9903 |     | 
  9904 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  9905 |     |         bytes32 m0;
  9906 |     |         bytes32 m1;
  9907 |     |         bytes32 m2;
  9908 |     |         bytes32 m3;
  9909 |     |         bytes32 m4;
  9910 |     |         bytes32 m5;
  9911 |     |         bytes32 m6;
  9912 |     |         bytes32 m7;
  9913 |     |         bytes32 m8;
  9914 |     |         assembly {
  9915 |     |             function writeString(pos, w) {
  9916 |     |                 let length := 0
  9917 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9918 |     |                 mstore(pos, length)
  9919 |     |                 let shift := sub(256, shl(3, length))
  9920 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9921 |     |             }
  9922 |     |             m0 := mload(0x00)
  9923 |     |             m1 := mload(0x20)
  9924 |     |             m2 := mload(0x40)
  9925 |     |             m3 := mload(0x60)
  9926 |     |             m4 := mload(0x80)
  9927 |     |             m5 := mload(0xa0)
  9928 |     |             m6 := mload(0xc0)
  9929 |     |             m7 := mload(0xe0)
  9930 |     |             m8 := mload(0x100)
  9931 |     |             // Selector of `log(uint256,string,uint256,string)`.
  9932 |     |             mstore(0x00, 0xb7b914ca)
  9933 |     |             mstore(0x20, p0)
  9934 |     |             mstore(0x40, 0x80)
  9935 |     |             mstore(0x60, p2)
  9936 |     |             mstore(0x80, 0xc0)
  9937 |     |             writeString(0xa0, p1)
  9938 |     |             writeString(0xe0, p3)
  9939 |     |         }
  9940 |     |         _sendLogPayload(0x1c, 0x104);
  9941 |     |         assembly {
  9942 |     |             mstore(0x00, m0)
  9943 |     |             mstore(0x20, m1)
  9944 |     |             mstore(0x40, m2)
  9945 |     |             mstore(0x60, m3)
  9946 |     |             mstore(0x80, m4)
  9947 |     |             mstore(0xa0, m5)
  9948 |     |             mstore(0xc0, m6)
  9949 |     |             mstore(0xe0, m7)
  9950 |     |             mstore(0x100, m8)
  9951 |     |         }
  9952 |     |     }
  9953 |     | 
  9954 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  9955 |     |         bytes32 m0;
  9956 |     |         bytes32 m1;
  9957 |     |         bytes32 m2;
  9958 |     |         bytes32 m3;
  9959 |     |         bytes32 m4;
  9960 |     |         bytes32 m5;
  9961 |     |         bytes32 m6;
  9962 |     |         bytes32 m7;
  9963 |     |         bytes32 m8;
  9964 |     |         assembly {
  9965 |     |             function writeString(pos, w) {
  9966 |     |                 let length := 0
  9967 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9968 |     |                 mstore(pos, length)
  9969 |     |                 let shift := sub(256, shl(3, length))
  9970 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9971 |     |             }
  9972 |     |             m0 := mload(0x00)
  9973 |     |             m1 := mload(0x20)
  9974 |     |             m2 := mload(0x40)
  9975 |     |             m3 := mload(0x60)
  9976 |     |             m4 := mload(0x80)
  9977 |     |             m5 := mload(0xa0)
  9978 |     |             m6 := mload(0xc0)
  9979 |     |             m7 := mload(0xe0)
  9980 |     |             m8 := mload(0x100)
  9981 |     |             // Selector of `log(uint256,string,string,address)`.
  9982 |     |             mstore(0x00, 0xd583c602)
  9983 |     |             mstore(0x20, p0)
  9984 |     |             mstore(0x40, 0x80)
  9985 |     |             mstore(0x60, 0xc0)
  9986 |     |             mstore(0x80, p3)
  9987 |     |             writeString(0xa0, p1)
  9988 |     |             writeString(0xe0, p2)
  9989 |     |         }
  9990 |     |         _sendLogPayload(0x1c, 0x104);
  9991 |     |         assembly {
  9992 |     |             mstore(0x00, m0)
  9993 |     |             mstore(0x20, m1)
  9994 |     |             mstore(0x40, m2)
  9995 |     |             mstore(0x60, m3)
  9996 |     |             mstore(0x80, m4)
  9997 |     |             mstore(0xa0, m5)
  9998 |     |             mstore(0xc0, m6)
  9999 |     |             mstore(0xe0, m7)
 10000 |     |             mstore(0x100, m8)
 10001 |     |         }
 10002 |     |     }
 10003 |     | 
 10004 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 10005 |     |         bytes32 m0;
 10006 |     |         bytes32 m1;
 10007 |     |         bytes32 m2;
 10008 |     |         bytes32 m3;
 10009 |     |         bytes32 m4;
 10010 |     |         bytes32 m5;
 10011 |     |         bytes32 m6;
 10012 |     |         bytes32 m7;
 10013 |     |         bytes32 m8;
 10014 |     |         assembly {
 10015 |     |             function writeString(pos, w) {
 10016 |     |                 let length := 0
 10017 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10018 |     |                 mstore(pos, length)
 10019 |     |                 let shift := sub(256, shl(3, length))
 10020 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10021 |     |             }
 10022 |     |             m0 := mload(0x00)
 10023 |     |             m1 := mload(0x20)
 10024 |     |             m2 := mload(0x40)
 10025 |     |             m3 := mload(0x60)
 10026 |     |             m4 := mload(0x80)
 10027 |     |             m5 := mload(0xa0)
 10028 |     |             m6 := mload(0xc0)
 10029 |     |             m7 := mload(0xe0)
 10030 |     |             m8 := mload(0x100)
 10031 |     |             // Selector of `log(uint256,string,string,bool)`.
 10032 |     |             mstore(0x00, 0xb3a6b6bd)
 10033 |     |             mstore(0x20, p0)
 10034 |     |             mstore(0x40, 0x80)
 10035 |     |             mstore(0x60, 0xc0)
 10036 |     |             mstore(0x80, p3)
 10037 |     |             writeString(0xa0, p1)
 10038 |     |             writeString(0xe0, p2)
 10039 |     |         }
 10040 |     |         _sendLogPayload(0x1c, 0x104);
 10041 |     |         assembly {
 10042 |     |             mstore(0x00, m0)
 10043 |     |             mstore(0x20, m1)
 10044 |     |             mstore(0x40, m2)
 10045 |     |             mstore(0x60, m3)
 10046 |     |             mstore(0x80, m4)
 10047 |     |             mstore(0xa0, m5)
 10048 |     |             mstore(0xc0, m6)
 10049 |     |             mstore(0xe0, m7)
 10050 |     |             mstore(0x100, m8)
 10051 |     |         }
 10052 |     |     }
 10053 |     | 
 10054 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 10055 |     |         bytes32 m0;
 10056 |     |         bytes32 m1;
 10057 |     |         bytes32 m2;
 10058 |     |         bytes32 m3;
 10059 |     |         bytes32 m4;
 10060 |     |         bytes32 m5;
 10061 |     |         bytes32 m6;
 10062 |     |         bytes32 m7;
 10063 |     |         bytes32 m8;
 10064 |     |         assembly {
 10065 |     |             function writeString(pos, w) {
 10066 |     |                 let length := 0
 10067 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10068 |     |                 mstore(pos, length)
 10069 |     |                 let shift := sub(256, shl(3, length))
 10070 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10071 |     |             }
 10072 |     |             m0 := mload(0x00)
 10073 |     |             m1 := mload(0x20)
 10074 |     |             m2 := mload(0x40)
 10075 |     |             m3 := mload(0x60)
 10076 |     |             m4 := mload(0x80)
 10077 |     |             m5 := mload(0xa0)
 10078 |     |             m6 := mload(0xc0)
 10079 |     |             m7 := mload(0xe0)
 10080 |     |             m8 := mload(0x100)
 10081 |     |             // Selector of `log(uint256,string,string,uint256)`.
 10082 |     |             mstore(0x00, 0xb028c9bd)
 10083 |     |             mstore(0x20, p0)
 10084 |     |             mstore(0x40, 0x80)
 10085 |     |             mstore(0x60, 0xc0)
 10086 |     |             mstore(0x80, p3)
 10087 |     |             writeString(0xa0, p1)
 10088 |     |             writeString(0xe0, p2)
 10089 |     |         }
 10090 |     |         _sendLogPayload(0x1c, 0x104);
 10091 |     |         assembly {
 10092 |     |             mstore(0x00, m0)
 10093 |     |             mstore(0x20, m1)
 10094 |     |             mstore(0x40, m2)
 10095 |     |             mstore(0x60, m3)
 10096 |     |             mstore(0x80, m4)
 10097 |     |             mstore(0xa0, m5)
 10098 |     |             mstore(0xc0, m6)
 10099 |     |             mstore(0xe0, m7)
 10100 |     |             mstore(0x100, m8)
 10101 |     |         }
 10102 |     |     }
 10103 |     | 
 10104 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 10105 |     |         bytes32 m0;
 10106 |     |         bytes32 m1;
 10107 |     |         bytes32 m2;
 10108 |     |         bytes32 m3;
 10109 |     |         bytes32 m4;
 10110 |     |         bytes32 m5;
 10111 |     |         bytes32 m6;
 10112 |     |         bytes32 m7;
 10113 |     |         bytes32 m8;
 10114 |     |         bytes32 m9;
 10115 |     |         bytes32 m10;
 10116 |     |         assembly {
 10117 |     |             function writeString(pos, w) {
 10118 |     |                 let length := 0
 10119 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10120 |     |                 mstore(pos, length)
 10121 |     |                 let shift := sub(256, shl(3, length))
 10122 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10123 |     |             }
 10124 |     |             m0 := mload(0x00)
 10125 |     |             m1 := mload(0x20)
 10126 |     |             m2 := mload(0x40)
 10127 |     |             m3 := mload(0x60)
 10128 |     |             m4 := mload(0x80)
 10129 |     |             m5 := mload(0xa0)
 10130 |     |             m6 := mload(0xc0)
 10131 |     |             m7 := mload(0xe0)
 10132 |     |             m8 := mload(0x100)
 10133 |     |             m9 := mload(0x120)
 10134 |     |             m10 := mload(0x140)
 10135 |     |             // Selector of `log(uint256,string,string,string)`.
 10136 |     |             mstore(0x00, 0x21ad0683)
 10137 |     |             mstore(0x20, p0)
 10138 |     |             mstore(0x40, 0x80)
 10139 |     |             mstore(0x60, 0xc0)
 10140 |     |             mstore(0x80, 0x100)
 10141 |     |             writeString(0xa0, p1)
 10142 |     |             writeString(0xe0, p2)
 10143 |     |             writeString(0x120, p3)
 10144 |     |         }
 10145 |     |         _sendLogPayload(0x1c, 0x144);
 10146 |     |         assembly {
 10147 |     |             mstore(0x00, m0)
 10148 |     |             mstore(0x20, m1)
 10149 |     |             mstore(0x40, m2)
 10150 |     |             mstore(0x60, m3)
 10151 |     |             mstore(0x80, m4)
 10152 |     |             mstore(0xa0, m5)
 10153 |     |             mstore(0xc0, m6)
 10154 |     |             mstore(0xe0, m7)
 10155 |     |             mstore(0x100, m8)
 10156 |     |             mstore(0x120, m9)
 10157 |     |             mstore(0x140, m10)
 10158 |     |         }
 10159 |     |     }
 10160 |     | 
 10161 |     |     function log(bytes32 p0, address p1, address p2, address p3) internal pure {
 10162 |     |         bytes32 m0;
 10163 |     |         bytes32 m1;
 10164 |     |         bytes32 m2;
 10165 |     |         bytes32 m3;
 10166 |     |         bytes32 m4;
 10167 |     |         bytes32 m5;
 10168 |     |         bytes32 m6;
 10169 |     |         assembly {
 10170 |     |             function writeString(pos, w) {
 10171 |     |                 let length := 0
 10172 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10173 |     |                 mstore(pos, length)
 10174 |     |                 let shift := sub(256, shl(3, length))
 10175 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10176 |     |             }
 10177 |     |             m0 := mload(0x00)
 10178 |     |             m1 := mload(0x20)
 10179 |     |             m2 := mload(0x40)
 10180 |     |             m3 := mload(0x60)
 10181 |     |             m4 := mload(0x80)
 10182 |     |             m5 := mload(0xa0)
 10183 |     |             m6 := mload(0xc0)
 10184 |     |             // Selector of `log(string,address,address,address)`.
 10185 |     |             mstore(0x00, 0xed8f28f6)
 10186 |     |             mstore(0x20, 0x80)
 10187 |     |             mstore(0x40, p1)
 10188 |     |             mstore(0x60, p2)
 10189 |     |             mstore(0x80, p3)
 10190 |     |             writeString(0xa0, p0)
 10191 |     |         }
 10192 |     |         _sendLogPayload(0x1c, 0xc4);
 10193 |     |         assembly {
 10194 |     |             mstore(0x00, m0)
 10195 |     |             mstore(0x20, m1)
 10196 |     |             mstore(0x40, m2)
 10197 |     |             mstore(0x60, m3)
 10198 |     |             mstore(0x80, m4)
 10199 |     |             mstore(0xa0, m5)
 10200 |     |             mstore(0xc0, m6)
 10201 |     |         }
 10202 |     |     }
 10203 |     | 
 10204 |     |     function log(bytes32 p0, address p1, address p2, bool p3) internal pure {
 10205 |     |         bytes32 m0;
 10206 |     |         bytes32 m1;
 10207 |     |         bytes32 m2;
 10208 |     |         bytes32 m3;
 10209 |     |         bytes32 m4;
 10210 |     |         bytes32 m5;
 10211 |     |         bytes32 m6;
 10212 |     |         assembly {
 10213 |     |             function writeString(pos, w) {
 10214 |     |                 let length := 0
 10215 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10216 |     |                 mstore(pos, length)
 10217 |     |                 let shift := sub(256, shl(3, length))
 10218 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10219 |     |             }
 10220 |     |             m0 := mload(0x00)
 10221 |     |             m1 := mload(0x20)
 10222 |     |             m2 := mload(0x40)
 10223 |     |             m3 := mload(0x60)
 10224 |     |             m4 := mload(0x80)
 10225 |     |             m5 := mload(0xa0)
 10226 |     |             m6 := mload(0xc0)
 10227 |     |             // Selector of `log(string,address,address,bool)`.
 10228 |     |             mstore(0x00, 0xb59dbd60)
 10229 |     |             mstore(0x20, 0x80)
 10230 |     |             mstore(0x40, p1)
 10231 |     |             mstore(0x60, p2)
 10232 |     |             mstore(0x80, p3)
 10233 |     |             writeString(0xa0, p0)
 10234 |     |         }
 10235 |     |         _sendLogPayload(0x1c, 0xc4);
 10236 |     |         assembly {
 10237 |     |             mstore(0x00, m0)
 10238 |     |             mstore(0x20, m1)
 10239 |     |             mstore(0x40, m2)
 10240 |     |             mstore(0x60, m3)
 10241 |     |             mstore(0x80, m4)
 10242 |     |             mstore(0xa0, m5)
 10243 |     |             mstore(0xc0, m6)
 10244 |     |         }
 10245 |     |     }
 10246 |     | 
 10247 |     |     function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {
 10248 |     |         bytes32 m0;
 10249 |     |         bytes32 m1;
 10250 |     |         bytes32 m2;
 10251 |     |         bytes32 m3;
 10252 |     |         bytes32 m4;
 10253 |     |         bytes32 m5;
 10254 |     |         bytes32 m6;
 10255 |     |         assembly {
 10256 |     |             function writeString(pos, w) {
 10257 |     |                 let length := 0
 10258 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10259 |     |                 mstore(pos, length)
 10260 |     |                 let shift := sub(256, shl(3, length))
 10261 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10262 |     |             }
 10263 |     |             m0 := mload(0x00)
 10264 |     |             m1 := mload(0x20)
 10265 |     |             m2 := mload(0x40)
 10266 |     |             m3 := mload(0x60)
 10267 |     |             m4 := mload(0x80)
 10268 |     |             m5 := mload(0xa0)
 10269 |     |             m6 := mload(0xc0)
 10270 |     |             // Selector of `log(string,address,address,uint256)`.
 10271 |     |             mstore(0x00, 0x8ef3f399)
 10272 |     |             mstore(0x20, 0x80)
 10273 |     |             mstore(0x40, p1)
 10274 |     |             mstore(0x60, p2)
 10275 |     |             mstore(0x80, p3)
 10276 |     |             writeString(0xa0, p0)
 10277 |     |         }
 10278 |     |         _sendLogPayload(0x1c, 0xc4);
 10279 |     |         assembly {
 10280 |     |             mstore(0x00, m0)
 10281 |     |             mstore(0x20, m1)
 10282 |     |             mstore(0x40, m2)
 10283 |     |             mstore(0x60, m3)
 10284 |     |             mstore(0x80, m4)
 10285 |     |             mstore(0xa0, m5)
 10286 |     |             mstore(0xc0, m6)
 10287 |     |         }
 10288 |     |     }
 10289 |     | 
 10290 |     |     function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {
 10291 |     |         bytes32 m0;
 10292 |     |         bytes32 m1;
 10293 |     |         bytes32 m2;
 10294 |     |         bytes32 m3;
 10295 |     |         bytes32 m4;
 10296 |     |         bytes32 m5;
 10297 |     |         bytes32 m6;
 10298 |     |         bytes32 m7;
 10299 |     |         bytes32 m8;
 10300 |     |         assembly {
 10301 |     |             function writeString(pos, w) {
 10302 |     |                 let length := 0
 10303 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10304 |     |                 mstore(pos, length)
 10305 |     |                 let shift := sub(256, shl(3, length))
 10306 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10307 |     |             }
 10308 |     |             m0 := mload(0x00)
 10309 |     |             m1 := mload(0x20)
 10310 |     |             m2 := mload(0x40)
 10311 |     |             m3 := mload(0x60)
 10312 |     |             m4 := mload(0x80)
 10313 |     |             m5 := mload(0xa0)
 10314 |     |             m6 := mload(0xc0)
 10315 |     |             m7 := mload(0xe0)
 10316 |     |             m8 := mload(0x100)
 10317 |     |             // Selector of `log(string,address,address,string)`.
 10318 |     |             mstore(0x00, 0x800a1c67)
 10319 |     |             mstore(0x20, 0x80)
 10320 |     |             mstore(0x40, p1)
 10321 |     |             mstore(0x60, p2)
 10322 |     |             mstore(0x80, 0xc0)
 10323 |     |             writeString(0xa0, p0)
 10324 |     |             writeString(0xe0, p3)
 10325 |     |         }
 10326 |     |         _sendLogPayload(0x1c, 0x104);
 10327 |     |         assembly {
 10328 |     |             mstore(0x00, m0)
 10329 |     |             mstore(0x20, m1)
 10330 |     |             mstore(0x40, m2)
 10331 |     |             mstore(0x60, m3)
 10332 |     |             mstore(0x80, m4)
 10333 |     |             mstore(0xa0, m5)
 10334 |     |             mstore(0xc0, m6)
 10335 |     |             mstore(0xe0, m7)
 10336 |     |             mstore(0x100, m8)
 10337 |     |         }
 10338 |     |     }
 10339 |     | 
 10340 |     |     function log(bytes32 p0, address p1, bool p2, address p3) internal pure {
 10341 |     |         bytes32 m0;
 10342 |     |         bytes32 m1;
 10343 |     |         bytes32 m2;
 10344 |     |         bytes32 m3;
 10345 |     |         bytes32 m4;
 10346 |     |         bytes32 m5;
 10347 |     |         bytes32 m6;
 10348 |     |         assembly {
 10349 |     |             function writeString(pos, w) {
 10350 |     |                 let length := 0
 10351 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10352 |     |                 mstore(pos, length)
 10353 |     |                 let shift := sub(256, shl(3, length))
 10354 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10355 |     |             }
 10356 |     |             m0 := mload(0x00)
 10357 |     |             m1 := mload(0x20)
 10358 |     |             m2 := mload(0x40)
 10359 |     |             m3 := mload(0x60)
 10360 |     |             m4 := mload(0x80)
 10361 |     |             m5 := mload(0xa0)
 10362 |     |             m6 := mload(0xc0)
 10363 |     |             // Selector of `log(string,address,bool,address)`.
 10364 |     |             mstore(0x00, 0x223603bd)
 10365 |     |             mstore(0x20, 0x80)
 10366 |     |             mstore(0x40, p1)
 10367 |     |             mstore(0x60, p2)
 10368 |     |             mstore(0x80, p3)
 10369 |     |             writeString(0xa0, p0)
 10370 |     |         }
 10371 |     |         _sendLogPayload(0x1c, 0xc4);
 10372 |     |         assembly {
 10373 |     |             mstore(0x00, m0)
 10374 |     |             mstore(0x20, m1)
 10375 |     |             mstore(0x40, m2)
 10376 |     |             mstore(0x60, m3)
 10377 |     |             mstore(0x80, m4)
 10378 |     |             mstore(0xa0, m5)
 10379 |     |             mstore(0xc0, m6)
 10380 |     |         }
 10381 |     |     }
 10382 |     | 
 10383 |     |     function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {
 10384 |     |         bytes32 m0;
 10385 |     |         bytes32 m1;
 10386 |     |         bytes32 m2;
 10387 |     |         bytes32 m3;
 10388 |     |         bytes32 m4;
 10389 |     |         bytes32 m5;
 10390 |     |         bytes32 m6;
 10391 |     |         assembly {
 10392 |     |             function writeString(pos, w) {
 10393 |     |                 let length := 0
 10394 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10395 |     |                 mstore(pos, length)
 10396 |     |                 let shift := sub(256, shl(3, length))
 10397 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10398 |     |             }
 10399 |     |             m0 := mload(0x00)
 10400 |     |             m1 := mload(0x20)
 10401 |     |             m2 := mload(0x40)
 10402 |     |             m3 := mload(0x60)
 10403 |     |             m4 := mload(0x80)
 10404 |     |             m5 := mload(0xa0)
 10405 |     |             m6 := mload(0xc0)
 10406 |     |             // Selector of `log(string,address,bool,bool)`.
 10407 |     |             mstore(0x00, 0x79884c2b)
 10408 |     |             mstore(0x20, 0x80)
 10409 |     |             mstore(0x40, p1)
 10410 |     |             mstore(0x60, p2)
 10411 |     |             mstore(0x80, p3)
 10412 |     |             writeString(0xa0, p0)
 10413 |     |         }
 10414 |     |         _sendLogPayload(0x1c, 0xc4);
 10415 |     |         assembly {
 10416 |     |             mstore(0x00, m0)
 10417 |     |             mstore(0x20, m1)
 10418 |     |             mstore(0x40, m2)
 10419 |     |             mstore(0x60, m3)
 10420 |     |             mstore(0x80, m4)
 10421 |     |             mstore(0xa0, m5)
 10422 |     |             mstore(0xc0, m6)
 10423 |     |         }
 10424 |     |     }
 10425 |     | 
 10426 |     |     function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {
 10427 |     |         bytes32 m0;
 10428 |     |         bytes32 m1;
 10429 |     |         bytes32 m2;
 10430 |     |         bytes32 m3;
 10431 |     |         bytes32 m4;
 10432 |     |         bytes32 m5;
 10433 |     |         bytes32 m6;
 10434 |     |         assembly {
 10435 |     |             function writeString(pos, w) {
 10436 |     |                 let length := 0
 10437 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10438 |     |                 mstore(pos, length)
 10439 |     |                 let shift := sub(256, shl(3, length))
 10440 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10441 |     |             }
 10442 |     |             m0 := mload(0x00)
 10443 |     |             m1 := mload(0x20)
 10444 |     |             m2 := mload(0x40)
 10445 |     |             m3 := mload(0x60)
 10446 |     |             m4 := mload(0x80)
 10447 |     |             m5 := mload(0xa0)
 10448 |     |             m6 := mload(0xc0)
 10449 |     |             // Selector of `log(string,address,bool,uint256)`.
 10450 |     |             mstore(0x00, 0x3e9f866a)
 10451 |     |             mstore(0x20, 0x80)
 10452 |     |             mstore(0x40, p1)
 10453 |     |             mstore(0x60, p2)
 10454 |     |             mstore(0x80, p3)
 10455 |     |             writeString(0xa0, p0)
 10456 |     |         }
 10457 |     |         _sendLogPayload(0x1c, 0xc4);
 10458 |     |         assembly {
 10459 |     |             mstore(0x00, m0)
 10460 |     |             mstore(0x20, m1)
 10461 |     |             mstore(0x40, m2)
 10462 |     |             mstore(0x60, m3)
 10463 |     |             mstore(0x80, m4)
 10464 |     |             mstore(0xa0, m5)
 10465 |     |             mstore(0xc0, m6)
 10466 |     |         }
 10467 |     |     }
 10468 |     | 
 10469 |     |     function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {
 10470 |     |         bytes32 m0;
 10471 |     |         bytes32 m1;
 10472 |     |         bytes32 m2;
 10473 |     |         bytes32 m3;
 10474 |     |         bytes32 m4;
 10475 |     |         bytes32 m5;
 10476 |     |         bytes32 m6;
 10477 |     |         bytes32 m7;
 10478 |     |         bytes32 m8;
 10479 |     |         assembly {
 10480 |     |             function writeString(pos, w) {
 10481 |     |                 let length := 0
 10482 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10483 |     |                 mstore(pos, length)
 10484 |     |                 let shift := sub(256, shl(3, length))
 10485 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10486 |     |             }
 10487 |     |             m0 := mload(0x00)
 10488 |     |             m1 := mload(0x20)
 10489 |     |             m2 := mload(0x40)
 10490 |     |             m3 := mload(0x60)
 10491 |     |             m4 := mload(0x80)
 10492 |     |             m5 := mload(0xa0)
 10493 |     |             m6 := mload(0xc0)
 10494 |     |             m7 := mload(0xe0)
 10495 |     |             m8 := mload(0x100)
 10496 |     |             // Selector of `log(string,address,bool,string)`.
 10497 |     |             mstore(0x00, 0x0454c079)
 10498 |     |             mstore(0x20, 0x80)
 10499 |     |             mstore(0x40, p1)
 10500 |     |             mstore(0x60, p2)
 10501 |     |             mstore(0x80, 0xc0)
 10502 |     |             writeString(0xa0, p0)
 10503 |     |             writeString(0xe0, p3)
 10504 |     |         }
 10505 |     |         _sendLogPayload(0x1c, 0x104);
 10506 |     |         assembly {
 10507 |     |             mstore(0x00, m0)
 10508 |     |             mstore(0x20, m1)
 10509 |     |             mstore(0x40, m2)
 10510 |     |             mstore(0x60, m3)
 10511 |     |             mstore(0x80, m4)
 10512 |     |             mstore(0xa0, m5)
 10513 |     |             mstore(0xc0, m6)
 10514 |     |             mstore(0xe0, m7)
 10515 |     |             mstore(0x100, m8)
 10516 |     |         }
 10517 |     |     }
 10518 |     | 
 10519 |     |     function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {
 10520 |     |         bytes32 m0;
 10521 |     |         bytes32 m1;
 10522 |     |         bytes32 m2;
 10523 |     |         bytes32 m3;
 10524 |     |         bytes32 m4;
 10525 |     |         bytes32 m5;
 10526 |     |         bytes32 m6;
 10527 |     |         assembly {
 10528 |     |             function writeString(pos, w) {
 10529 |     |                 let length := 0
 10530 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10531 |     |                 mstore(pos, length)
 10532 |     |                 let shift := sub(256, shl(3, length))
 10533 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10534 |     |             }
 10535 |     |             m0 := mload(0x00)
 10536 |     |             m1 := mload(0x20)
 10537 |     |             m2 := mload(0x40)
 10538 |     |             m3 := mload(0x60)
 10539 |     |             m4 := mload(0x80)
 10540 |     |             m5 := mload(0xa0)
 10541 |     |             m6 := mload(0xc0)
 10542 |     |             // Selector of `log(string,address,uint256,address)`.
 10543 |     |             mstore(0x00, 0x63fb8bc5)
 10544 |     |             mstore(0x20, 0x80)
 10545 |     |             mstore(0x40, p1)
 10546 |     |             mstore(0x60, p2)
 10547 |     |             mstore(0x80, p3)
 10548 |     |             writeString(0xa0, p0)
 10549 |     |         }
 10550 |     |         _sendLogPayload(0x1c, 0xc4);
 10551 |     |         assembly {
 10552 |     |             mstore(0x00, m0)
 10553 |     |             mstore(0x20, m1)
 10554 |     |             mstore(0x40, m2)
 10555 |     |             mstore(0x60, m3)
 10556 |     |             mstore(0x80, m4)
 10557 |     |             mstore(0xa0, m5)
 10558 |     |             mstore(0xc0, m6)
 10559 |     |         }
 10560 |     |     }
 10561 |     | 
 10562 |     |     function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {
 10563 |     |         bytes32 m0;
 10564 |     |         bytes32 m1;
 10565 |     |         bytes32 m2;
 10566 |     |         bytes32 m3;
 10567 |     |         bytes32 m4;
 10568 |     |         bytes32 m5;
 10569 |     |         bytes32 m6;
 10570 |     |         assembly {
 10571 |     |             function writeString(pos, w) {
 10572 |     |                 let length := 0
 10573 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10574 |     |                 mstore(pos, length)
 10575 |     |                 let shift := sub(256, shl(3, length))
 10576 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10577 |     |             }
 10578 |     |             m0 := mload(0x00)
 10579 |     |             m1 := mload(0x20)
 10580 |     |             m2 := mload(0x40)
 10581 |     |             m3 := mload(0x60)
 10582 |     |             m4 := mload(0x80)
 10583 |     |             m5 := mload(0xa0)
 10584 |     |             m6 := mload(0xc0)
 10585 |     |             // Selector of `log(string,address,uint256,bool)`.
 10586 |     |             mstore(0x00, 0xfc4845f0)
 10587 |     |             mstore(0x20, 0x80)
 10588 |     |             mstore(0x40, p1)
 10589 |     |             mstore(0x60, p2)
 10590 |     |             mstore(0x80, p3)
 10591 |     |             writeString(0xa0, p0)
 10592 |     |         }
 10593 |     |         _sendLogPayload(0x1c, 0xc4);
 10594 |     |         assembly {
 10595 |     |             mstore(0x00, m0)
 10596 |     |             mstore(0x20, m1)
 10597 |     |             mstore(0x40, m2)
 10598 |     |             mstore(0x60, m3)
 10599 |     |             mstore(0x80, m4)
 10600 |     |             mstore(0xa0, m5)
 10601 |     |             mstore(0xc0, m6)
 10602 |     |         }
 10603 |     |     }
 10604 |     | 
 10605 |     |     function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {
 10606 |     |         bytes32 m0;
 10607 |     |         bytes32 m1;
 10608 |     |         bytes32 m2;
 10609 |     |         bytes32 m3;
 10610 |     |         bytes32 m4;
 10611 |     |         bytes32 m5;
 10612 |     |         bytes32 m6;
 10613 |     |         assembly {
 10614 |     |             function writeString(pos, w) {
 10615 |     |                 let length := 0
 10616 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10617 |     |                 mstore(pos, length)
 10618 |     |                 let shift := sub(256, shl(3, length))
 10619 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10620 |     |             }
 10621 |     |             m0 := mload(0x00)
 10622 |     |             m1 := mload(0x20)
 10623 |     |             m2 := mload(0x40)
 10624 |     |             m3 := mload(0x60)
 10625 |     |             m4 := mload(0x80)
 10626 |     |             m5 := mload(0xa0)
 10627 |     |             m6 := mload(0xc0)
 10628 |     |             // Selector of `log(string,address,uint256,uint256)`.
 10629 |     |             mstore(0x00, 0xf8f51b1e)
 10630 |     |             mstore(0x20, 0x80)
 10631 |     |             mstore(0x40, p1)
 10632 |     |             mstore(0x60, p2)
 10633 |     |             mstore(0x80, p3)
 10634 |     |             writeString(0xa0, p0)
 10635 |     |         }
 10636 |     |         _sendLogPayload(0x1c, 0xc4);
 10637 |     |         assembly {
 10638 |     |             mstore(0x00, m0)
 10639 |     |             mstore(0x20, m1)
 10640 |     |             mstore(0x40, m2)
 10641 |     |             mstore(0x60, m3)
 10642 |     |             mstore(0x80, m4)
 10643 |     |             mstore(0xa0, m5)
 10644 |     |             mstore(0xc0, m6)
 10645 |     |         }
 10646 |     |     }
 10647 |     | 
 10648 |     |     function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {
 10649 |     |         bytes32 m0;
 10650 |     |         bytes32 m1;
 10651 |     |         bytes32 m2;
 10652 |     |         bytes32 m3;
 10653 |     |         bytes32 m4;
 10654 |     |         bytes32 m5;
 10655 |     |         bytes32 m6;
 10656 |     |         bytes32 m7;
 10657 |     |         bytes32 m8;
 10658 |     |         assembly {
 10659 |     |             function writeString(pos, w) {
 10660 |     |                 let length := 0
 10661 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10662 |     |                 mstore(pos, length)
 10663 |     |                 let shift := sub(256, shl(3, length))
 10664 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10665 |     |             }
 10666 |     |             m0 := mload(0x00)
 10667 |     |             m1 := mload(0x20)
 10668 |     |             m2 := mload(0x40)
 10669 |     |             m3 := mload(0x60)
 10670 |     |             m4 := mload(0x80)
 10671 |     |             m5 := mload(0xa0)
 10672 |     |             m6 := mload(0xc0)
 10673 |     |             m7 := mload(0xe0)
 10674 |     |             m8 := mload(0x100)
 10675 |     |             // Selector of `log(string,address,uint256,string)`.
 10676 |     |             mstore(0x00, 0x5a477632)
 10677 |     |             mstore(0x20, 0x80)
 10678 |     |             mstore(0x40, p1)
 10679 |     |             mstore(0x60, p2)
 10680 |     |             mstore(0x80, 0xc0)
 10681 |     |             writeString(0xa0, p0)
 10682 |     |             writeString(0xe0, p3)
 10683 |     |         }
 10684 |     |         _sendLogPayload(0x1c, 0x104);
 10685 |     |         assembly {
 10686 |     |             mstore(0x00, m0)
 10687 |     |             mstore(0x20, m1)
 10688 |     |             mstore(0x40, m2)
 10689 |     |             mstore(0x60, m3)
 10690 |     |             mstore(0x80, m4)
 10691 |     |             mstore(0xa0, m5)
 10692 |     |             mstore(0xc0, m6)
 10693 |     |             mstore(0xe0, m7)
 10694 |     |             mstore(0x100, m8)
 10695 |     |         }
 10696 |     |     }
 10697 |     | 
 10698 |     |     function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {
 10699 |     |         bytes32 m0;
 10700 |     |         bytes32 m1;
 10701 |     |         bytes32 m2;
 10702 |     |         bytes32 m3;
 10703 |     |         bytes32 m4;
 10704 |     |         bytes32 m5;
 10705 |     |         bytes32 m6;
 10706 |     |         bytes32 m7;
 10707 |     |         bytes32 m8;
 10708 |     |         assembly {
 10709 |     |             function writeString(pos, w) {
 10710 |     |                 let length := 0
 10711 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10712 |     |                 mstore(pos, length)
 10713 |     |                 let shift := sub(256, shl(3, length))
 10714 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10715 |     |             }
 10716 |     |             m0 := mload(0x00)
 10717 |     |             m1 := mload(0x20)
 10718 |     |             m2 := mload(0x40)
 10719 |     |             m3 := mload(0x60)
 10720 |     |             m4 := mload(0x80)
 10721 |     |             m5 := mload(0xa0)
 10722 |     |             m6 := mload(0xc0)
 10723 |     |             m7 := mload(0xe0)
 10724 |     |             m8 := mload(0x100)
 10725 |     |             // Selector of `log(string,address,string,address)`.
 10726 |     |             mstore(0x00, 0xaabc9a31)
 10727 |     |             mstore(0x20, 0x80)
 10728 |     |             mstore(0x40, p1)
 10729 |     |             mstore(0x60, 0xc0)
 10730 |     |             mstore(0x80, p3)
 10731 |     |             writeString(0xa0, p0)
 10732 |     |             writeString(0xe0, p2)
 10733 |     |         }
 10734 |     |         _sendLogPayload(0x1c, 0x104);
 10735 |     |         assembly {
 10736 |     |             mstore(0x00, m0)
 10737 |     |             mstore(0x20, m1)
 10738 |     |             mstore(0x40, m2)
 10739 |     |             mstore(0x60, m3)
 10740 |     |             mstore(0x80, m4)
 10741 |     |             mstore(0xa0, m5)
 10742 |     |             mstore(0xc0, m6)
 10743 |     |             mstore(0xe0, m7)
 10744 |     |             mstore(0x100, m8)
 10745 |     |         }
 10746 |     |     }
 10747 |     | 
 10748 |     |     function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {
 10749 |     |         bytes32 m0;
 10750 |     |         bytes32 m1;
 10751 |     |         bytes32 m2;
 10752 |     |         bytes32 m3;
 10753 |     |         bytes32 m4;
 10754 |     |         bytes32 m5;
 10755 |     |         bytes32 m6;
 10756 |     |         bytes32 m7;
 10757 |     |         bytes32 m8;
 10758 |     |         assembly {
 10759 |     |             function writeString(pos, w) {
 10760 |     |                 let length := 0
 10761 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10762 |     |                 mstore(pos, length)
 10763 |     |                 let shift := sub(256, shl(3, length))
 10764 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10765 |     |             }
 10766 |     |             m0 := mload(0x00)
 10767 |     |             m1 := mload(0x20)
 10768 |     |             m2 := mload(0x40)
 10769 |     |             m3 := mload(0x60)
 10770 |     |             m4 := mload(0x80)
 10771 |     |             m5 := mload(0xa0)
 10772 |     |             m6 := mload(0xc0)
 10773 |     |             m7 := mload(0xe0)
 10774 |     |             m8 := mload(0x100)
 10775 |     |             // Selector of `log(string,address,string,bool)`.
 10776 |     |             mstore(0x00, 0x5f15d28c)
 10777 |     |             mstore(0x20, 0x80)
 10778 |     |             mstore(0x40, p1)
 10779 |     |             mstore(0x60, 0xc0)
 10780 |     |             mstore(0x80, p3)
 10781 |     |             writeString(0xa0, p0)
 10782 |     |             writeString(0xe0, p2)
 10783 |     |         }
 10784 |     |         _sendLogPayload(0x1c, 0x104);
 10785 |     |         assembly {
 10786 |     |             mstore(0x00, m0)
 10787 |     |             mstore(0x20, m1)
 10788 |     |             mstore(0x40, m2)
 10789 |     |             mstore(0x60, m3)
 10790 |     |             mstore(0x80, m4)
 10791 |     |             mstore(0xa0, m5)
 10792 |     |             mstore(0xc0, m6)
 10793 |     |             mstore(0xe0, m7)
 10794 |     |             mstore(0x100, m8)
 10795 |     |         }
 10796 |     |     }
 10797 |     | 
 10798 |     |     function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {
 10799 |     |         bytes32 m0;
 10800 |     |         bytes32 m1;
 10801 |     |         bytes32 m2;
 10802 |     |         bytes32 m3;
 10803 |     |         bytes32 m4;
 10804 |     |         bytes32 m5;
 10805 |     |         bytes32 m6;
 10806 |     |         bytes32 m7;
 10807 |     |         bytes32 m8;
 10808 |     |         assembly {
 10809 |     |             function writeString(pos, w) {
 10810 |     |                 let length := 0
 10811 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10812 |     |                 mstore(pos, length)
 10813 |     |                 let shift := sub(256, shl(3, length))
 10814 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10815 |     |             }
 10816 |     |             m0 := mload(0x00)
 10817 |     |             m1 := mload(0x20)
 10818 |     |             m2 := mload(0x40)
 10819 |     |             m3 := mload(0x60)
 10820 |     |             m4 := mload(0x80)
 10821 |     |             m5 := mload(0xa0)
 10822 |     |             m6 := mload(0xc0)
 10823 |     |             m7 := mload(0xe0)
 10824 |     |             m8 := mload(0x100)
 10825 |     |             // Selector of `log(string,address,string,uint256)`.
 10826 |     |             mstore(0x00, 0x91d1112e)
 10827 |     |             mstore(0x20, 0x80)
 10828 |     |             mstore(0x40, p1)
 10829 |     |             mstore(0x60, 0xc0)
 10830 |     |             mstore(0x80, p3)
 10831 |     |             writeString(0xa0, p0)
 10832 |     |             writeString(0xe0, p2)
 10833 |     |         }
 10834 |     |         _sendLogPayload(0x1c, 0x104);
 10835 |     |         assembly {
 10836 |     |             mstore(0x00, m0)
 10837 |     |             mstore(0x20, m1)
 10838 |     |             mstore(0x40, m2)
 10839 |     |             mstore(0x60, m3)
 10840 |     |             mstore(0x80, m4)
 10841 |     |             mstore(0xa0, m5)
 10842 |     |             mstore(0xc0, m6)
 10843 |     |             mstore(0xe0, m7)
 10844 |     |             mstore(0x100, m8)
 10845 |     |         }
 10846 |     |     }
 10847 |     | 
 10848 |     |     function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
 10849 |     |         bytes32 m0;
 10850 |     |         bytes32 m1;
 10851 |     |         bytes32 m2;
 10852 |     |         bytes32 m3;
 10853 |     |         bytes32 m4;
 10854 |     |         bytes32 m5;
 10855 |     |         bytes32 m6;
 10856 |     |         bytes32 m7;
 10857 |     |         bytes32 m8;
 10858 |     |         bytes32 m9;
 10859 |     |         bytes32 m10;
 10860 |     |         assembly {
 10861 |     |             function writeString(pos, w) {
 10862 |     |                 let length := 0
 10863 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10864 |     |                 mstore(pos, length)
 10865 |     |                 let shift := sub(256, shl(3, length))
 10866 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10867 |     |             }
 10868 |     |             m0 := mload(0x00)
 10869 |     |             m1 := mload(0x20)
 10870 |     |             m2 := mload(0x40)
 10871 |     |             m3 := mload(0x60)
 10872 |     |             m4 := mload(0x80)
 10873 |     |             m5 := mload(0xa0)
 10874 |     |             m6 := mload(0xc0)
 10875 |     |             m7 := mload(0xe0)
 10876 |     |             m8 := mload(0x100)
 10877 |     |             m9 := mload(0x120)
 10878 |     |             m10 := mload(0x140)
 10879 |     |             // Selector of `log(string,address,string,string)`.
 10880 |     |             mstore(0x00, 0x245986f2)
 10881 |     |             mstore(0x20, 0x80)
 10882 |     |             mstore(0x40, p1)
 10883 |     |             mstore(0x60, 0xc0)
 10884 |     |             mstore(0x80, 0x100)
 10885 |     |             writeString(0xa0, p0)
 10886 |     |             writeString(0xe0, p2)
 10887 |     |             writeString(0x120, p3)
 10888 |     |         }
 10889 |     |         _sendLogPayload(0x1c, 0x144);
 10890 |     |         assembly {
 10891 |     |             mstore(0x00, m0)
 10892 |     |             mstore(0x20, m1)
 10893 |     |             mstore(0x40, m2)
 10894 |     |             mstore(0x60, m3)
 10895 |     |             mstore(0x80, m4)
 10896 |     |             mstore(0xa0, m5)
 10897 |     |             mstore(0xc0, m6)
 10898 |     |             mstore(0xe0, m7)
 10899 |     |             mstore(0x100, m8)
 10900 |     |             mstore(0x120, m9)
 10901 |     |             mstore(0x140, m10)
 10902 |     |         }
 10903 |     |     }
 10904 |     | 
 10905 |     |     function log(bytes32 p0, bool p1, address p2, address p3) internal pure {
 10906 |     |         bytes32 m0;
 10907 |     |         bytes32 m1;
 10908 |     |         bytes32 m2;
 10909 |     |         bytes32 m3;
 10910 |     |         bytes32 m4;
 10911 |     |         bytes32 m5;
 10912 |     |         bytes32 m6;
 10913 |     |         assembly {
 10914 |     |             function writeString(pos, w) {
 10915 |     |                 let length := 0
 10916 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10917 |     |                 mstore(pos, length)
 10918 |     |                 let shift := sub(256, shl(3, length))
 10919 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10920 |     |             }
 10921 |     |             m0 := mload(0x00)
 10922 |     |             m1 := mload(0x20)
 10923 |     |             m2 := mload(0x40)
 10924 |     |             m3 := mload(0x60)
 10925 |     |             m4 := mload(0x80)
 10926 |     |             m5 := mload(0xa0)
 10927 |     |             m6 := mload(0xc0)
 10928 |     |             // Selector of `log(string,bool,address,address)`.
 10929 |     |             mstore(0x00, 0x33e9dd1d)
 10930 |     |             mstore(0x20, 0x80)
 10931 |     |             mstore(0x40, p1)
 10932 |     |             mstore(0x60, p2)
 10933 |     |             mstore(0x80, p3)
 10934 |     |             writeString(0xa0, p0)
 10935 |     |         }
 10936 |     |         _sendLogPayload(0x1c, 0xc4);
 10937 |     |         assembly {
 10938 |     |             mstore(0x00, m0)
 10939 |     |             mstore(0x20, m1)
 10940 |     |             mstore(0x40, m2)
 10941 |     |             mstore(0x60, m3)
 10942 |     |             mstore(0x80, m4)
 10943 |     |             mstore(0xa0, m5)
 10944 |     |             mstore(0xc0, m6)
 10945 |     |         }
 10946 |     |     }
 10947 |     | 
 10948 |     |     function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {
 10949 |     |         bytes32 m0;
 10950 |     |         bytes32 m1;
 10951 |     |         bytes32 m2;
 10952 |     |         bytes32 m3;
 10953 |     |         bytes32 m4;
 10954 |     |         bytes32 m5;
 10955 |     |         bytes32 m6;
 10956 |     |         assembly {
 10957 |     |             function writeString(pos, w) {
 10958 |     |                 let length := 0
 10959 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10960 |     |                 mstore(pos, length)
 10961 |     |                 let shift := sub(256, shl(3, length))
 10962 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10963 |     |             }
 10964 |     |             m0 := mload(0x00)
 10965 |     |             m1 := mload(0x20)
 10966 |     |             m2 := mload(0x40)
 10967 |     |             m3 := mload(0x60)
 10968 |     |             m4 := mload(0x80)
 10969 |     |             m5 := mload(0xa0)
 10970 |     |             m6 := mload(0xc0)
 10971 |     |             // Selector of `log(string,bool,address,bool)`.
 10972 |     |             mstore(0x00, 0x958c28c6)
 10973 |     |             mstore(0x20, 0x80)
 10974 |     |             mstore(0x40, p1)
 10975 |     |             mstore(0x60, p2)
 10976 |     |             mstore(0x80, p3)
 10977 |     |             writeString(0xa0, p0)
 10978 |     |         }
 10979 |     |         _sendLogPayload(0x1c, 0xc4);
 10980 |     |         assembly {
 10981 |     |             mstore(0x00, m0)
 10982 |     |             mstore(0x20, m1)
 10983 |     |             mstore(0x40, m2)
 10984 |     |             mstore(0x60, m3)
 10985 |     |             mstore(0x80, m4)
 10986 |     |             mstore(0xa0, m5)
 10987 |     |             mstore(0xc0, m6)
 10988 |     |         }
 10989 |     |     }
 10990 |     | 
 10991 |     |     function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {
 10992 |     |         bytes32 m0;
 10993 |     |         bytes32 m1;
 10994 |     |         bytes32 m2;
 10995 |     |         bytes32 m3;
 10996 |     |         bytes32 m4;
 10997 |     |         bytes32 m5;
 10998 |     |         bytes32 m6;
 10999 |     |         assembly {
 11000 |     |             function writeString(pos, w) {
 11001 |     |                 let length := 0
 11002 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11003 |     |                 mstore(pos, length)
 11004 |     |                 let shift := sub(256, shl(3, length))
 11005 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11006 |     |             }
 11007 |     |             m0 := mload(0x00)
 11008 |     |             m1 := mload(0x20)
 11009 |     |             m2 := mload(0x40)
 11010 |     |             m3 := mload(0x60)
 11011 |     |             m4 := mload(0x80)
 11012 |     |             m5 := mload(0xa0)
 11013 |     |             m6 := mload(0xc0)
 11014 |     |             // Selector of `log(string,bool,address,uint256)`.
 11015 |     |             mstore(0x00, 0x5d08bb05)
 11016 |     |             mstore(0x20, 0x80)
 11017 |     |             mstore(0x40, p1)
 11018 |     |             mstore(0x60, p2)
 11019 |     |             mstore(0x80, p3)
 11020 |     |             writeString(0xa0, p0)
 11021 |     |         }
 11022 |     |         _sendLogPayload(0x1c, 0xc4);
 11023 |     |         assembly {
 11024 |     |             mstore(0x00, m0)
 11025 |     |             mstore(0x20, m1)
 11026 |     |             mstore(0x40, m2)
 11027 |     |             mstore(0x60, m3)
 11028 |     |             mstore(0x80, m4)
 11029 |     |             mstore(0xa0, m5)
 11030 |     |             mstore(0xc0, m6)
 11031 |     |         }
 11032 |     |     }
 11033 |     | 
 11034 |     |     function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {
 11035 |     |         bytes32 m0;
 11036 |     |         bytes32 m1;
 11037 |     |         bytes32 m2;
 11038 |     |         bytes32 m3;
 11039 |     |         bytes32 m4;
 11040 |     |         bytes32 m5;
 11041 |     |         bytes32 m6;
 11042 |     |         bytes32 m7;
 11043 |     |         bytes32 m8;
 11044 |     |         assembly {
 11045 |     |             function writeString(pos, w) {
 11046 |     |                 let length := 0
 11047 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11048 |     |                 mstore(pos, length)
 11049 |     |                 let shift := sub(256, shl(3, length))
 11050 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11051 |     |             }
 11052 |     |             m0 := mload(0x00)
 11053 |     |             m1 := mload(0x20)
 11054 |     |             m2 := mload(0x40)
 11055 |     |             m3 := mload(0x60)
 11056 |     |             m4 := mload(0x80)
 11057 |     |             m5 := mload(0xa0)
 11058 |     |             m6 := mload(0xc0)
 11059 |     |             m7 := mload(0xe0)
 11060 |     |             m8 := mload(0x100)
 11061 |     |             // Selector of `log(string,bool,address,string)`.
 11062 |     |             mstore(0x00, 0x2d8e33a4)
 11063 |     |             mstore(0x20, 0x80)
 11064 |     |             mstore(0x40, p1)
 11065 |     |             mstore(0x60, p2)
 11066 |     |             mstore(0x80, 0xc0)
 11067 |     |             writeString(0xa0, p0)
 11068 |     |             writeString(0xe0, p3)
 11069 |     |         }
 11070 |     |         _sendLogPayload(0x1c, 0x104);
 11071 |     |         assembly {
 11072 |     |             mstore(0x00, m0)
 11073 |     |             mstore(0x20, m1)
 11074 |     |             mstore(0x40, m2)
 11075 |     |             mstore(0x60, m3)
 11076 |     |             mstore(0x80, m4)
 11077 |     |             mstore(0xa0, m5)
 11078 |     |             mstore(0xc0, m6)
 11079 |     |             mstore(0xe0, m7)
 11080 |     |             mstore(0x100, m8)
 11081 |     |         }
 11082 |     |     }
 11083 |     | 
 11084 |     |     function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {
 11085 |     |         bytes32 m0;
 11086 |     |         bytes32 m1;
 11087 |     |         bytes32 m2;
 11088 |     |         bytes32 m3;
 11089 |     |         bytes32 m4;
 11090 |     |         bytes32 m5;
 11091 |     |         bytes32 m6;
 11092 |     |         assembly {
 11093 |     |             function writeString(pos, w) {
 11094 |     |                 let length := 0
 11095 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11096 |     |                 mstore(pos, length)
 11097 |     |                 let shift := sub(256, shl(3, length))
 11098 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11099 |     |             }
 11100 |     |             m0 := mload(0x00)
 11101 |     |             m1 := mload(0x20)
 11102 |     |             m2 := mload(0x40)
 11103 |     |             m3 := mload(0x60)
 11104 |     |             m4 := mload(0x80)
 11105 |     |             m5 := mload(0xa0)
 11106 |     |             m6 := mload(0xc0)
 11107 |     |             // Selector of `log(string,bool,bool,address)`.
 11108 |     |             mstore(0x00, 0x7190a529)
 11109 |     |             mstore(0x20, 0x80)
 11110 |     |             mstore(0x40, p1)
 11111 |     |             mstore(0x60, p2)
 11112 |     |             mstore(0x80, p3)
 11113 |     |             writeString(0xa0, p0)
 11114 |     |         }
 11115 |     |         _sendLogPayload(0x1c, 0xc4);
 11116 |     |         assembly {
 11117 |     |             mstore(0x00, m0)
 11118 |     |             mstore(0x20, m1)
 11119 |     |             mstore(0x40, m2)
 11120 |     |             mstore(0x60, m3)
 11121 |     |             mstore(0x80, m4)
 11122 |     |             mstore(0xa0, m5)
 11123 |     |             mstore(0xc0, m6)
 11124 |     |         }
 11125 |     |     }
 11126 |     | 
 11127 |     |     function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {
 11128 |     |         bytes32 m0;
 11129 |     |         bytes32 m1;
 11130 |     |         bytes32 m2;
 11131 |     |         bytes32 m3;
 11132 |     |         bytes32 m4;
 11133 |     |         bytes32 m5;
 11134 |     |         bytes32 m6;
 11135 |     |         assembly {
 11136 |     |             function writeString(pos, w) {
 11137 |     |                 let length := 0
 11138 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11139 |     |                 mstore(pos, length)
 11140 |     |                 let shift := sub(256, shl(3, length))
 11141 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11142 |     |             }
 11143 |     |             m0 := mload(0x00)
 11144 |     |             m1 := mload(0x20)
 11145 |     |             m2 := mload(0x40)
 11146 |     |             m3 := mload(0x60)
 11147 |     |             m4 := mload(0x80)
 11148 |     |             m5 := mload(0xa0)
 11149 |     |             m6 := mload(0xc0)
 11150 |     |             // Selector of `log(string,bool,bool,bool)`.
 11151 |     |             mstore(0x00, 0x895af8c5)
 11152 |     |             mstore(0x20, 0x80)
 11153 |     |             mstore(0x40, p1)
 11154 |     |             mstore(0x60, p2)
 11155 |     |             mstore(0x80, p3)
 11156 |     |             writeString(0xa0, p0)
 11157 |     |         }
 11158 |     |         _sendLogPayload(0x1c, 0xc4);
 11159 |     |         assembly {
 11160 |     |             mstore(0x00, m0)
 11161 |     |             mstore(0x20, m1)
 11162 |     |             mstore(0x40, m2)
 11163 |     |             mstore(0x60, m3)
 11164 |     |             mstore(0x80, m4)
 11165 |     |             mstore(0xa0, m5)
 11166 |     |             mstore(0xc0, m6)
 11167 |     |         }
 11168 |     |     }
 11169 |     | 
 11170 |     |     function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {
 11171 |     |         bytes32 m0;
 11172 |     |         bytes32 m1;
 11173 |     |         bytes32 m2;
 11174 |     |         bytes32 m3;
 11175 |     |         bytes32 m4;
 11176 |     |         bytes32 m5;
 11177 |     |         bytes32 m6;
 11178 |     |         assembly {
 11179 |     |             function writeString(pos, w) {
 11180 |     |                 let length := 0
 11181 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11182 |     |                 mstore(pos, length)
 11183 |     |                 let shift := sub(256, shl(3, length))
 11184 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11185 |     |             }
 11186 |     |             m0 := mload(0x00)
 11187 |     |             m1 := mload(0x20)
 11188 |     |             m2 := mload(0x40)
 11189 |     |             m3 := mload(0x60)
 11190 |     |             m4 := mload(0x80)
 11191 |     |             m5 := mload(0xa0)
 11192 |     |             m6 := mload(0xc0)
 11193 |     |             // Selector of `log(string,bool,bool,uint256)`.
 11194 |     |             mstore(0x00, 0x8e3f78a9)
 11195 |     |             mstore(0x20, 0x80)
 11196 |     |             mstore(0x40, p1)
 11197 |     |             mstore(0x60, p2)
 11198 |     |             mstore(0x80, p3)
 11199 |     |             writeString(0xa0, p0)
 11200 |     |         }
 11201 |     |         _sendLogPayload(0x1c, 0xc4);
 11202 |     |         assembly {
 11203 |     |             mstore(0x00, m0)
 11204 |     |             mstore(0x20, m1)
 11205 |     |             mstore(0x40, m2)
 11206 |     |             mstore(0x60, m3)
 11207 |     |             mstore(0x80, m4)
 11208 |     |             mstore(0xa0, m5)
 11209 |     |             mstore(0xc0, m6)
 11210 |     |         }
 11211 |     |     }
 11212 |     | 
 11213 |     |     function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {
 11214 |     |         bytes32 m0;
 11215 |     |         bytes32 m1;
 11216 |     |         bytes32 m2;
 11217 |     |         bytes32 m3;
 11218 |     |         bytes32 m4;
 11219 |     |         bytes32 m5;
 11220 |     |         bytes32 m6;
 11221 |     |         bytes32 m7;
 11222 |     |         bytes32 m8;
 11223 |     |         assembly {
 11224 |     |             function writeString(pos, w) {
 11225 |     |                 let length := 0
 11226 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11227 |     |                 mstore(pos, length)
 11228 |     |                 let shift := sub(256, shl(3, length))
 11229 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11230 |     |             }
 11231 |     |             m0 := mload(0x00)
 11232 |     |             m1 := mload(0x20)
 11233 |     |             m2 := mload(0x40)
 11234 |     |             m3 := mload(0x60)
 11235 |     |             m4 := mload(0x80)
 11236 |     |             m5 := mload(0xa0)
 11237 |     |             m6 := mload(0xc0)
 11238 |     |             m7 := mload(0xe0)
 11239 |     |             m8 := mload(0x100)
 11240 |     |             // Selector of `log(string,bool,bool,string)`.
 11241 |     |             mstore(0x00, 0x9d22d5dd)
 11242 |     |             mstore(0x20, 0x80)
 11243 |     |             mstore(0x40, p1)
 11244 |     |             mstore(0x60, p2)
 11245 |     |             mstore(0x80, 0xc0)
 11246 |     |             writeString(0xa0, p0)
 11247 |     |             writeString(0xe0, p3)
 11248 |     |         }
 11249 |     |         _sendLogPayload(0x1c, 0x104);
 11250 |     |         assembly {
 11251 |     |             mstore(0x00, m0)
 11252 |     |             mstore(0x20, m1)
 11253 |     |             mstore(0x40, m2)
 11254 |     |             mstore(0x60, m3)
 11255 |     |             mstore(0x80, m4)
 11256 |     |             mstore(0xa0, m5)
 11257 |     |             mstore(0xc0, m6)
 11258 |     |             mstore(0xe0, m7)
 11259 |     |             mstore(0x100, m8)
 11260 |     |         }
 11261 |     |     }
 11262 |     | 
 11263 |     |     function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {
 11264 |     |         bytes32 m0;
 11265 |     |         bytes32 m1;
 11266 |     |         bytes32 m2;
 11267 |     |         bytes32 m3;
 11268 |     |         bytes32 m4;
 11269 |     |         bytes32 m5;
 11270 |     |         bytes32 m6;
 11271 |     |         assembly {
 11272 |     |             function writeString(pos, w) {
 11273 |     |                 let length := 0
 11274 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11275 |     |                 mstore(pos, length)
 11276 |     |                 let shift := sub(256, shl(3, length))
 11277 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11278 |     |             }
 11279 |     |             m0 := mload(0x00)
 11280 |     |             m1 := mload(0x20)
 11281 |     |             m2 := mload(0x40)
 11282 |     |             m3 := mload(0x60)
 11283 |     |             m4 := mload(0x80)
 11284 |     |             m5 := mload(0xa0)
 11285 |     |             m6 := mload(0xc0)
 11286 |     |             // Selector of `log(string,bool,uint256,address)`.
 11287 |     |             mstore(0x00, 0x935e09bf)
 11288 |     |             mstore(0x20, 0x80)
 11289 |     |             mstore(0x40, p1)
 11290 |     |             mstore(0x60, p2)
 11291 |     |             mstore(0x80, p3)
 11292 |     |             writeString(0xa0, p0)
 11293 |     |         }
 11294 |     |         _sendLogPayload(0x1c, 0xc4);
 11295 |     |         assembly {
 11296 |     |             mstore(0x00, m0)
 11297 |     |             mstore(0x20, m1)
 11298 |     |             mstore(0x40, m2)
 11299 |     |             mstore(0x60, m3)
 11300 |     |             mstore(0x80, m4)
 11301 |     |             mstore(0xa0, m5)
 11302 |     |             mstore(0xc0, m6)
 11303 |     |         }
 11304 |     |     }
 11305 |     | 
 11306 |     |     function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {
 11307 |     |         bytes32 m0;
 11308 |     |         bytes32 m1;
 11309 |     |         bytes32 m2;
 11310 |     |         bytes32 m3;
 11311 |     |         bytes32 m4;
 11312 |     |         bytes32 m5;
 11313 |     |         bytes32 m6;
 11314 |     |         assembly {
 11315 |     |             function writeString(pos, w) {
 11316 |     |                 let length := 0
 11317 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11318 |     |                 mstore(pos, length)
 11319 |     |                 let shift := sub(256, shl(3, length))
 11320 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11321 |     |             }
 11322 |     |             m0 := mload(0x00)
 11323 |     |             m1 := mload(0x20)
 11324 |     |             m2 := mload(0x40)
 11325 |     |             m3 := mload(0x60)
 11326 |     |             m4 := mload(0x80)
 11327 |     |             m5 := mload(0xa0)
 11328 |     |             m6 := mload(0xc0)
 11329 |     |             // Selector of `log(string,bool,uint256,bool)`.
 11330 |     |             mstore(0x00, 0x8af7cf8a)
 11331 |     |             mstore(0x20, 0x80)
 11332 |     |             mstore(0x40, p1)
 11333 |     |             mstore(0x60, p2)
 11334 |     |             mstore(0x80, p3)
 11335 |     |             writeString(0xa0, p0)
 11336 |     |         }
 11337 |     |         _sendLogPayload(0x1c, 0xc4);
 11338 |     |         assembly {
 11339 |     |             mstore(0x00, m0)
 11340 |     |             mstore(0x20, m1)
 11341 |     |             mstore(0x40, m2)
 11342 |     |             mstore(0x60, m3)
 11343 |     |             mstore(0x80, m4)
 11344 |     |             mstore(0xa0, m5)
 11345 |     |             mstore(0xc0, m6)
 11346 |     |         }
 11347 |     |     }
 11348 |     | 
 11349 |     |     function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {
 11350 |     |         bytes32 m0;
 11351 |     |         bytes32 m1;
 11352 |     |         bytes32 m2;
 11353 |     |         bytes32 m3;
 11354 |     |         bytes32 m4;
 11355 |     |         bytes32 m5;
 11356 |     |         bytes32 m6;
 11357 |     |         assembly {
 11358 |     |             function writeString(pos, w) {
 11359 |     |                 let length := 0
 11360 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11361 |     |                 mstore(pos, length)
 11362 |     |                 let shift := sub(256, shl(3, length))
 11363 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11364 |     |             }
 11365 |     |             m0 := mload(0x00)
 11366 |     |             m1 := mload(0x20)
 11367 |     |             m2 := mload(0x40)
 11368 |     |             m3 := mload(0x60)
 11369 |     |             m4 := mload(0x80)
 11370 |     |             m5 := mload(0xa0)
 11371 |     |             m6 := mload(0xc0)
 11372 |     |             // Selector of `log(string,bool,uint256,uint256)`.
 11373 |     |             mstore(0x00, 0x64b5bb67)
 11374 |     |             mstore(0x20, 0x80)
 11375 |     |             mstore(0x40, p1)
 11376 |     |             mstore(0x60, p2)
 11377 |     |             mstore(0x80, p3)
 11378 |     |             writeString(0xa0, p0)
 11379 |     |         }
 11380 |     |         _sendLogPayload(0x1c, 0xc4);
 11381 |     |         assembly {
 11382 |     |             mstore(0x00, m0)
 11383 |     |             mstore(0x20, m1)
 11384 |     |             mstore(0x40, m2)
 11385 |     |             mstore(0x60, m3)
 11386 |     |             mstore(0x80, m4)
 11387 |     |             mstore(0xa0, m5)
 11388 |     |             mstore(0xc0, m6)
 11389 |     |         }
 11390 |     |     }
 11391 |     | 
 11392 |     |     function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
 11393 |     |         bytes32 m0;
 11394 |     |         bytes32 m1;
 11395 |     |         bytes32 m2;
 11396 |     |         bytes32 m3;
 11397 |     |         bytes32 m4;
 11398 |     |         bytes32 m5;
 11399 |     |         bytes32 m6;
 11400 |     |         bytes32 m7;
 11401 |     |         bytes32 m8;
 11402 |     |         assembly {
 11403 |     |             function writeString(pos, w) {
 11404 |     |                 let length := 0
 11405 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11406 |     |                 mstore(pos, length)
 11407 |     |                 let shift := sub(256, shl(3, length))
 11408 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11409 |     |             }
 11410 |     |             m0 := mload(0x00)
 11411 |     |             m1 := mload(0x20)
 11412 |     |             m2 := mload(0x40)
 11413 |     |             m3 := mload(0x60)
 11414 |     |             m4 := mload(0x80)
 11415 |     |             m5 := mload(0xa0)
 11416 |     |             m6 := mload(0xc0)
 11417 |     |             m7 := mload(0xe0)
 11418 |     |             m8 := mload(0x100)
 11419 |     |             // Selector of `log(string,bool,uint256,string)`.
 11420 |     |             mstore(0x00, 0x742d6ee7)
 11421 |     |             mstore(0x20, 0x80)
 11422 |     |             mstore(0x40, p1)
 11423 |     |             mstore(0x60, p2)
 11424 |     |             mstore(0x80, 0xc0)
 11425 |     |             writeString(0xa0, p0)
 11426 |     |             writeString(0xe0, p3)
 11427 |     |         }
 11428 |     |         _sendLogPayload(0x1c, 0x104);
 11429 |     |         assembly {
 11430 |     |             mstore(0x00, m0)
 11431 |     |             mstore(0x20, m1)
 11432 |     |             mstore(0x40, m2)
 11433 |     |             mstore(0x60, m3)
 11434 |     |             mstore(0x80, m4)
 11435 |     |             mstore(0xa0, m5)
 11436 |     |             mstore(0xc0, m6)
 11437 |     |             mstore(0xe0, m7)
 11438 |     |             mstore(0x100, m8)
 11439 |     |         }
 11440 |     |     }
 11441 |     | 
 11442 |     |     function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {
 11443 |     |         bytes32 m0;
 11444 |     |         bytes32 m1;
 11445 |     |         bytes32 m2;
 11446 |     |         bytes32 m3;
 11447 |     |         bytes32 m4;
 11448 |     |         bytes32 m5;
 11449 |     |         bytes32 m6;
 11450 |     |         bytes32 m7;
 11451 |     |         bytes32 m8;
 11452 |     |         assembly {
 11453 |     |             function writeString(pos, w) {
 11454 |     |                 let length := 0
 11455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11456 |     |                 mstore(pos, length)
 11457 |     |                 let shift := sub(256, shl(3, length))
 11458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11459 |     |             }
 11460 |     |             m0 := mload(0x00)
 11461 |     |             m1 := mload(0x20)
 11462 |     |             m2 := mload(0x40)
 11463 |     |             m3 := mload(0x60)
 11464 |     |             m4 := mload(0x80)
 11465 |     |             m5 := mload(0xa0)
 11466 |     |             m6 := mload(0xc0)
 11467 |     |             m7 := mload(0xe0)
 11468 |     |             m8 := mload(0x100)
 11469 |     |             // Selector of `log(string,bool,string,address)`.
 11470 |     |             mstore(0x00, 0xe0625b29)
 11471 |     |             mstore(0x20, 0x80)
 11472 |     |             mstore(0x40, p1)
 11473 |     |             mstore(0x60, 0xc0)
 11474 |     |             mstore(0x80, p3)
 11475 |     |             writeString(0xa0, p0)
 11476 |     |             writeString(0xe0, p2)
 11477 |     |         }
 11478 |     |         _sendLogPayload(0x1c, 0x104);
 11479 |     |         assembly {
 11480 |     |             mstore(0x00, m0)
 11481 |     |             mstore(0x20, m1)
 11482 |     |             mstore(0x40, m2)
 11483 |     |             mstore(0x60, m3)
 11484 |     |             mstore(0x80, m4)
 11485 |     |             mstore(0xa0, m5)
 11486 |     |             mstore(0xc0, m6)
 11487 |     |             mstore(0xe0, m7)
 11488 |     |             mstore(0x100, m8)
 11489 |     |         }
 11490 |     |     }
 11491 |     | 
 11492 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {
 11493 |     |         bytes32 m0;
 11494 |     |         bytes32 m1;
 11495 |     |         bytes32 m2;
 11496 |     |         bytes32 m3;
 11497 |     |         bytes32 m4;
 11498 |     |         bytes32 m5;
 11499 |     |         bytes32 m6;
 11500 |     |         bytes32 m7;
 11501 |     |         bytes32 m8;
 11502 |     |         assembly {
 11503 |     |             function writeString(pos, w) {
 11504 |     |                 let length := 0
 11505 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11506 |     |                 mstore(pos, length)
 11507 |     |                 let shift := sub(256, shl(3, length))
 11508 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11509 |     |             }
 11510 |     |             m0 := mload(0x00)
 11511 |     |             m1 := mload(0x20)
 11512 |     |             m2 := mload(0x40)
 11513 |     |             m3 := mload(0x60)
 11514 |     |             m4 := mload(0x80)
 11515 |     |             m5 := mload(0xa0)
 11516 |     |             m6 := mload(0xc0)
 11517 |     |             m7 := mload(0xe0)
 11518 |     |             m8 := mload(0x100)
 11519 |     |             // Selector of `log(string,bool,string,bool)`.
 11520 |     |             mstore(0x00, 0x3f8a701d)
 11521 |     |             mstore(0x20, 0x80)
 11522 |     |             mstore(0x40, p1)
 11523 |     |             mstore(0x60, 0xc0)
 11524 |     |             mstore(0x80, p3)
 11525 |     |             writeString(0xa0, p0)
 11526 |     |             writeString(0xe0, p2)
 11527 |     |         }
 11528 |     |         _sendLogPayload(0x1c, 0x104);
 11529 |     |         assembly {
 11530 |     |             mstore(0x00, m0)
 11531 |     |             mstore(0x20, m1)
 11532 |     |             mstore(0x40, m2)
 11533 |     |             mstore(0x60, m3)
 11534 |     |             mstore(0x80, m4)
 11535 |     |             mstore(0xa0, m5)
 11536 |     |             mstore(0xc0, m6)
 11537 |     |             mstore(0xe0, m7)
 11538 |     |             mstore(0x100, m8)
 11539 |     |         }
 11540 |     |     }
 11541 |     | 
 11542 |     |     function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
 11543 |     |         bytes32 m0;
 11544 |     |         bytes32 m1;
 11545 |     |         bytes32 m2;
 11546 |     |         bytes32 m3;
 11547 |     |         bytes32 m4;
 11548 |     |         bytes32 m5;
 11549 |     |         bytes32 m6;
 11550 |     |         bytes32 m7;
 11551 |     |         bytes32 m8;
 11552 |     |         assembly {
 11553 |     |             function writeString(pos, w) {
 11554 |     |                 let length := 0
 11555 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11556 |     |                 mstore(pos, length)
 11557 |     |                 let shift := sub(256, shl(3, length))
 11558 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11559 |     |             }
 11560 |     |             m0 := mload(0x00)
 11561 |     |             m1 := mload(0x20)
 11562 |     |             m2 := mload(0x40)
 11563 |     |             m3 := mload(0x60)
 11564 |     |             m4 := mload(0x80)
 11565 |     |             m5 := mload(0xa0)
 11566 |     |             m6 := mload(0xc0)
 11567 |     |             m7 := mload(0xe0)
 11568 |     |             m8 := mload(0x100)
 11569 |     |             // Selector of `log(string,bool,string,uint256)`.
 11570 |     |             mstore(0x00, 0x24f91465)
 11571 |     |             mstore(0x20, 0x80)
 11572 |     |             mstore(0x40, p1)
 11573 |     |             mstore(0x60, 0xc0)
 11574 |     |             mstore(0x80, p3)
 11575 |     |             writeString(0xa0, p0)
 11576 |     |             writeString(0xe0, p2)
 11577 |     |         }
 11578 |     |         _sendLogPayload(0x1c, 0x104);
 11579 |     |         assembly {
 11580 |     |             mstore(0x00, m0)
 11581 |     |             mstore(0x20, m1)
 11582 |     |             mstore(0x40, m2)
 11583 |     |             mstore(0x60, m3)
 11584 |     |             mstore(0x80, m4)
 11585 |     |             mstore(0xa0, m5)
 11586 |     |             mstore(0xc0, m6)
 11587 |     |             mstore(0xe0, m7)
 11588 |     |             mstore(0x100, m8)
 11589 |     |         }
 11590 |     |     }
 11591 |     | 
 11592 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
 11593 |     |         bytes32 m0;
 11594 |     |         bytes32 m1;
 11595 |     |         bytes32 m2;
 11596 |     |         bytes32 m3;
 11597 |     |         bytes32 m4;
 11598 |     |         bytes32 m5;
 11599 |     |         bytes32 m6;
 11600 |     |         bytes32 m7;
 11601 |     |         bytes32 m8;
 11602 |     |         bytes32 m9;
 11603 |     |         bytes32 m10;
 11604 |     |         assembly {
 11605 |     |             function writeString(pos, w) {
 11606 |     |                 let length := 0
 11607 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11608 |     |                 mstore(pos, length)
 11609 |     |                 let shift := sub(256, shl(3, length))
 11610 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11611 |     |             }
 11612 |     |             m0 := mload(0x00)
 11613 |     |             m1 := mload(0x20)
 11614 |     |             m2 := mload(0x40)
 11615 |     |             m3 := mload(0x60)
 11616 |     |             m4 := mload(0x80)
 11617 |     |             m5 := mload(0xa0)
 11618 |     |             m6 := mload(0xc0)
 11619 |     |             m7 := mload(0xe0)
 11620 |     |             m8 := mload(0x100)
 11621 |     |             m9 := mload(0x120)
 11622 |     |             m10 := mload(0x140)
 11623 |     |             // Selector of `log(string,bool,string,string)`.
 11624 |     |             mstore(0x00, 0xa826caeb)
 11625 |     |             mstore(0x20, 0x80)
 11626 |     |             mstore(0x40, p1)
 11627 |     |             mstore(0x60, 0xc0)
 11628 |     |             mstore(0x80, 0x100)
 11629 |     |             writeString(0xa0, p0)
 11630 |     |             writeString(0xe0, p2)
 11631 |     |             writeString(0x120, p3)
 11632 |     |         }
 11633 |     |         _sendLogPayload(0x1c, 0x144);
 11634 |     |         assembly {
 11635 |     |             mstore(0x00, m0)
 11636 |     |             mstore(0x20, m1)
 11637 |     |             mstore(0x40, m2)
 11638 |     |             mstore(0x60, m3)
 11639 |     |             mstore(0x80, m4)
 11640 |     |             mstore(0xa0, m5)
 11641 |     |             mstore(0xc0, m6)
 11642 |     |             mstore(0xe0, m7)
 11643 |     |             mstore(0x100, m8)
 11644 |     |             mstore(0x120, m9)
 11645 |     |             mstore(0x140, m10)
 11646 |     |         }
 11647 |     |     }
 11648 |     | 
 11649 |     |     function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {
 11650 |     |         bytes32 m0;
 11651 |     |         bytes32 m1;
 11652 |     |         bytes32 m2;
 11653 |     |         bytes32 m3;
 11654 |     |         bytes32 m4;
 11655 |     |         bytes32 m5;
 11656 |     |         bytes32 m6;
 11657 |     |         assembly {
 11658 |     |             function writeString(pos, w) {
 11659 |     |                 let length := 0
 11660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11661 |     |                 mstore(pos, length)
 11662 |     |                 let shift := sub(256, shl(3, length))
 11663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11664 |     |             }
 11665 |     |             m0 := mload(0x00)
 11666 |     |             m1 := mload(0x20)
 11667 |     |             m2 := mload(0x40)
 11668 |     |             m3 := mload(0x60)
 11669 |     |             m4 := mload(0x80)
 11670 |     |             m5 := mload(0xa0)
 11671 |     |             m6 := mload(0xc0)
 11672 |     |             // Selector of `log(string,uint256,address,address)`.
 11673 |     |             mstore(0x00, 0x5ea2b7ae)
 11674 |     |             mstore(0x20, 0x80)
 11675 |     |             mstore(0x40, p1)
 11676 |     |             mstore(0x60, p2)
 11677 |     |             mstore(0x80, p3)
 11678 |     |             writeString(0xa0, p0)
 11679 |     |         }
 11680 |     |         _sendLogPayload(0x1c, 0xc4);
 11681 |     |         assembly {
 11682 |     |             mstore(0x00, m0)
 11683 |     |             mstore(0x20, m1)
 11684 |     |             mstore(0x40, m2)
 11685 |     |             mstore(0x60, m3)
 11686 |     |             mstore(0x80, m4)
 11687 |     |             mstore(0xa0, m5)
 11688 |     |             mstore(0xc0, m6)
 11689 |     |         }
 11690 |     |     }
 11691 |     | 
 11692 |     |     function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {
 11693 |     |         bytes32 m0;
 11694 |     |         bytes32 m1;
 11695 |     |         bytes32 m2;
 11696 |     |         bytes32 m3;
 11697 |     |         bytes32 m4;
 11698 |     |         bytes32 m5;
 11699 |     |         bytes32 m6;
 11700 |     |         assembly {
 11701 |     |             function writeString(pos, w) {
 11702 |     |                 let length := 0
 11703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11704 |     |                 mstore(pos, length)
 11705 |     |                 let shift := sub(256, shl(3, length))
 11706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11707 |     |             }
 11708 |     |             m0 := mload(0x00)
 11709 |     |             m1 := mload(0x20)
 11710 |     |             m2 := mload(0x40)
 11711 |     |             m3 := mload(0x60)
 11712 |     |             m4 := mload(0x80)
 11713 |     |             m5 := mload(0xa0)
 11714 |     |             m6 := mload(0xc0)
 11715 |     |             // Selector of `log(string,uint256,address,bool)`.
 11716 |     |             mstore(0x00, 0x82112a42)
 11717 |     |             mstore(0x20, 0x80)
 11718 |     |             mstore(0x40, p1)
 11719 |     |             mstore(0x60, p2)
 11720 |     |             mstore(0x80, p3)
 11721 |     |             writeString(0xa0, p0)
 11722 |     |         }
 11723 |     |         _sendLogPayload(0x1c, 0xc4);
 11724 |     |         assembly {
 11725 |     |             mstore(0x00, m0)
 11726 |     |             mstore(0x20, m1)
 11727 |     |             mstore(0x40, m2)
 11728 |     |             mstore(0x60, m3)
 11729 |     |             mstore(0x80, m4)
 11730 |     |             mstore(0xa0, m5)
 11731 |     |             mstore(0xc0, m6)
 11732 |     |         }
 11733 |     |     }
 11734 |     | 
 11735 |     |     function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {
 11736 |     |         bytes32 m0;
 11737 |     |         bytes32 m1;
 11738 |     |         bytes32 m2;
 11739 |     |         bytes32 m3;
 11740 |     |         bytes32 m4;
 11741 |     |         bytes32 m5;
 11742 |     |         bytes32 m6;
 11743 |     |         assembly {
 11744 |     |             function writeString(pos, w) {
 11745 |     |                 let length := 0
 11746 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11747 |     |                 mstore(pos, length)
 11748 |     |                 let shift := sub(256, shl(3, length))
 11749 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11750 |     |             }
 11751 |     |             m0 := mload(0x00)
 11752 |     |             m1 := mload(0x20)
 11753 |     |             m2 := mload(0x40)
 11754 |     |             m3 := mload(0x60)
 11755 |     |             m4 := mload(0x80)
 11756 |     |             m5 := mload(0xa0)
 11757 |     |             m6 := mload(0xc0)
 11758 |     |             // Selector of `log(string,uint256,address,uint256)`.
 11759 |     |             mstore(0x00, 0x4f04fdc6)
 11760 |     |             mstore(0x20, 0x80)
 11761 |     |             mstore(0x40, p1)
 11762 |     |             mstore(0x60, p2)
 11763 |     |             mstore(0x80, p3)
 11764 |     |             writeString(0xa0, p0)
 11765 |     |         }
 11766 |     |         _sendLogPayload(0x1c, 0xc4);
 11767 |     |         assembly {
 11768 |     |             mstore(0x00, m0)
 11769 |     |             mstore(0x20, m1)
 11770 |     |             mstore(0x40, m2)
 11771 |     |             mstore(0x60, m3)
 11772 |     |             mstore(0x80, m4)
 11773 |     |             mstore(0xa0, m5)
 11774 |     |             mstore(0xc0, m6)
 11775 |     |         }
 11776 |     |     }
 11777 |     | 
 11778 |     |     function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {
 11779 |     |         bytes32 m0;
 11780 |     |         bytes32 m1;
 11781 |     |         bytes32 m2;
 11782 |     |         bytes32 m3;
 11783 |     |         bytes32 m4;
 11784 |     |         bytes32 m5;
 11785 |     |         bytes32 m6;
 11786 |     |         bytes32 m7;
 11787 |     |         bytes32 m8;
 11788 |     |         assembly {
 11789 |     |             function writeString(pos, w) {
 11790 |     |                 let length := 0
 11791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11792 |     |                 mstore(pos, length)
 11793 |     |                 let shift := sub(256, shl(3, length))
 11794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11795 |     |             }
 11796 |     |             m0 := mload(0x00)
 11797 |     |             m1 := mload(0x20)
 11798 |     |             m2 := mload(0x40)
 11799 |     |             m3 := mload(0x60)
 11800 |     |             m4 := mload(0x80)
 11801 |     |             m5 := mload(0xa0)
 11802 |     |             m6 := mload(0xc0)
 11803 |     |             m7 := mload(0xe0)
 11804 |     |             m8 := mload(0x100)
 11805 |     |             // Selector of `log(string,uint256,address,string)`.
 11806 |     |             mstore(0x00, 0x9ffb2f93)
 11807 |     |             mstore(0x20, 0x80)
 11808 |     |             mstore(0x40, p1)
 11809 |     |             mstore(0x60, p2)
 11810 |     |             mstore(0x80, 0xc0)
 11811 |     |             writeString(0xa0, p0)
 11812 |     |             writeString(0xe0, p3)
 11813 |     |         }
 11814 |     |         _sendLogPayload(0x1c, 0x104);
 11815 |     |         assembly {
 11816 |     |             mstore(0x00, m0)
 11817 |     |             mstore(0x20, m1)
 11818 |     |             mstore(0x40, m2)
 11819 |     |             mstore(0x60, m3)
 11820 |     |             mstore(0x80, m4)
 11821 |     |             mstore(0xa0, m5)
 11822 |     |             mstore(0xc0, m6)
 11823 |     |             mstore(0xe0, m7)
 11824 |     |             mstore(0x100, m8)
 11825 |     |         }
 11826 |     |     }
 11827 |     | 
 11828 |     |     function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {
 11829 |     |         bytes32 m0;
 11830 |     |         bytes32 m1;
 11831 |     |         bytes32 m2;
 11832 |     |         bytes32 m3;
 11833 |     |         bytes32 m4;
 11834 |     |         bytes32 m5;
 11835 |     |         bytes32 m6;
 11836 |     |         assembly {
 11837 |     |             function writeString(pos, w) {
 11838 |     |                 let length := 0
 11839 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11840 |     |                 mstore(pos, length)
 11841 |     |                 let shift := sub(256, shl(3, length))
 11842 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11843 |     |             }
 11844 |     |             m0 := mload(0x00)
 11845 |     |             m1 := mload(0x20)
 11846 |     |             m2 := mload(0x40)
 11847 |     |             m3 := mload(0x60)
 11848 |     |             m4 := mload(0x80)
 11849 |     |             m5 := mload(0xa0)
 11850 |     |             m6 := mload(0xc0)
 11851 |     |             // Selector of `log(string,uint256,bool,address)`.
 11852 |     |             mstore(0x00, 0xe0e95b98)
 11853 |     |             mstore(0x20, 0x80)
 11854 |     |             mstore(0x40, p1)
 11855 |     |             mstore(0x60, p2)
 11856 |     |             mstore(0x80, p3)
 11857 |     |             writeString(0xa0, p0)
 11858 |     |         }
 11859 |     |         _sendLogPayload(0x1c, 0xc4);
 11860 |     |         assembly {
 11861 |     |             mstore(0x00, m0)
 11862 |     |             mstore(0x20, m1)
 11863 |     |             mstore(0x40, m2)
 11864 |     |             mstore(0x60, m3)
 11865 |     |             mstore(0x80, m4)
 11866 |     |             mstore(0xa0, m5)
 11867 |     |             mstore(0xc0, m6)
 11868 |     |         }
 11869 |     |     }
 11870 |     | 
 11871 |     |     function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {
 11872 |     |         bytes32 m0;
 11873 |     |         bytes32 m1;
 11874 |     |         bytes32 m2;
 11875 |     |         bytes32 m3;
 11876 |     |         bytes32 m4;
 11877 |     |         bytes32 m5;
 11878 |     |         bytes32 m6;
 11879 |     |         assembly {
 11880 |     |             function writeString(pos, w) {
 11881 |     |                 let length := 0
 11882 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11883 |     |                 mstore(pos, length)
 11884 |     |                 let shift := sub(256, shl(3, length))
 11885 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11886 |     |             }
 11887 |     |             m0 := mload(0x00)
 11888 |     |             m1 := mload(0x20)
 11889 |     |             m2 := mload(0x40)
 11890 |     |             m3 := mload(0x60)
 11891 |     |             m4 := mload(0x80)
 11892 |     |             m5 := mload(0xa0)
 11893 |     |             m6 := mload(0xc0)
 11894 |     |             // Selector of `log(string,uint256,bool,bool)`.
 11895 |     |             mstore(0x00, 0x354c36d6)
 11896 |     |             mstore(0x20, 0x80)
 11897 |     |             mstore(0x40, p1)
 11898 |     |             mstore(0x60, p2)
 11899 |     |             mstore(0x80, p3)
 11900 |     |             writeString(0xa0, p0)
 11901 |     |         }
 11902 |     |         _sendLogPayload(0x1c, 0xc4);
 11903 |     |         assembly {
 11904 |     |             mstore(0x00, m0)
 11905 |     |             mstore(0x20, m1)
 11906 |     |             mstore(0x40, m2)
 11907 |     |             mstore(0x60, m3)
 11908 |     |             mstore(0x80, m4)
 11909 |     |             mstore(0xa0, m5)
 11910 |     |             mstore(0xc0, m6)
 11911 |     |         }
 11912 |     |     }
 11913 |     | 
 11914 |     |     function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {
 11915 |     |         bytes32 m0;
 11916 |     |         bytes32 m1;
 11917 |     |         bytes32 m2;
 11918 |     |         bytes32 m3;
 11919 |     |         bytes32 m4;
 11920 |     |         bytes32 m5;
 11921 |     |         bytes32 m6;
 11922 |     |         assembly {
 11923 |     |             function writeString(pos, w) {
 11924 |     |                 let length := 0
 11925 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11926 |     |                 mstore(pos, length)
 11927 |     |                 let shift := sub(256, shl(3, length))
 11928 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11929 |     |             }
 11930 |     |             m0 := mload(0x00)
 11931 |     |             m1 := mload(0x20)
 11932 |     |             m2 := mload(0x40)
 11933 |     |             m3 := mload(0x60)
 11934 |     |             m4 := mload(0x80)
 11935 |     |             m5 := mload(0xa0)
 11936 |     |             m6 := mload(0xc0)
 11937 |     |             // Selector of `log(string,uint256,bool,uint256)`.
 11938 |     |             mstore(0x00, 0xe41b6f6f)
 11939 |     |             mstore(0x20, 0x80)
 11940 |     |             mstore(0x40, p1)
 11941 |     |             mstore(0x60, p2)
 11942 |     |             mstore(0x80, p3)
 11943 |     |             writeString(0xa0, p0)
 11944 |     |         }
 11945 |     |         _sendLogPayload(0x1c, 0xc4);
 11946 |     |         assembly {
 11947 |     |             mstore(0x00, m0)
 11948 |     |             mstore(0x20, m1)
 11949 |     |             mstore(0x40, m2)
 11950 |     |             mstore(0x60, m3)
 11951 |     |             mstore(0x80, m4)
 11952 |     |             mstore(0xa0, m5)
 11953 |     |             mstore(0xc0, m6)
 11954 |     |         }
 11955 |     |     }
 11956 |     | 
 11957 |     |     function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
 11958 |     |         bytes32 m0;
 11959 |     |         bytes32 m1;
 11960 |     |         bytes32 m2;
 11961 |     |         bytes32 m3;
 11962 |     |         bytes32 m4;
 11963 |     |         bytes32 m5;
 11964 |     |         bytes32 m6;
 11965 |     |         bytes32 m7;
 11966 |     |         bytes32 m8;
 11967 |     |         assembly {
 11968 |     |             function writeString(pos, w) {
 11969 |     |                 let length := 0
 11970 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11971 |     |                 mstore(pos, length)
 11972 |     |                 let shift := sub(256, shl(3, length))
 11973 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11974 |     |             }
 11975 |     |             m0 := mload(0x00)
 11976 |     |             m1 := mload(0x20)
 11977 |     |             m2 := mload(0x40)
 11978 |     |             m3 := mload(0x60)
 11979 |     |             m4 := mload(0x80)
 11980 |     |             m5 := mload(0xa0)
 11981 |     |             m6 := mload(0xc0)
 11982 |     |             m7 := mload(0xe0)
 11983 |     |             m8 := mload(0x100)
 11984 |     |             // Selector of `log(string,uint256,bool,string)`.
 11985 |     |             mstore(0x00, 0xabf73a98)
 11986 |     |             mstore(0x20, 0x80)
 11987 |     |             mstore(0x40, p1)
 11988 |     |             mstore(0x60, p2)
 11989 |     |             mstore(0x80, 0xc0)
 11990 |     |             writeString(0xa0, p0)
 11991 |     |             writeString(0xe0, p3)
 11992 |     |         }
 11993 |     |         _sendLogPayload(0x1c, 0x104);
 11994 |     |         assembly {
 11995 |     |             mstore(0x00, m0)
 11996 |     |             mstore(0x20, m1)
 11997 |     |             mstore(0x40, m2)
 11998 |     |             mstore(0x60, m3)
 11999 |     |             mstore(0x80, m4)
 12000 |     |             mstore(0xa0, m5)
 12001 |     |             mstore(0xc0, m6)
 12002 |     |             mstore(0xe0, m7)
 12003 |     |             mstore(0x100, m8)
 12004 |     |         }
 12005 |     |     }
 12006 |     | 
 12007 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {
 12008 |     |         bytes32 m0;
 12009 |     |         bytes32 m1;
 12010 |     |         bytes32 m2;
 12011 |     |         bytes32 m3;
 12012 |     |         bytes32 m4;
 12013 |     |         bytes32 m5;
 12014 |     |         bytes32 m6;
 12015 |     |         assembly {
 12016 |     |             function writeString(pos, w) {
 12017 |     |                 let length := 0
 12018 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12019 |     |                 mstore(pos, length)
 12020 |     |                 let shift := sub(256, shl(3, length))
 12021 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12022 |     |             }
 12023 |     |             m0 := mload(0x00)
 12024 |     |             m1 := mload(0x20)
 12025 |     |             m2 := mload(0x40)
 12026 |     |             m3 := mload(0x60)
 12027 |     |             m4 := mload(0x80)
 12028 |     |             m5 := mload(0xa0)
 12029 |     |             m6 := mload(0xc0)
 12030 |     |             // Selector of `log(string,uint256,uint256,address)`.
 12031 |     |             mstore(0x00, 0xe21de278)
 12032 |     |             mstore(0x20, 0x80)
 12033 |     |             mstore(0x40, p1)
 12034 |     |             mstore(0x60, p2)
 12035 |     |             mstore(0x80, p3)
 12036 |     |             writeString(0xa0, p0)
 12037 |     |         }
 12038 |     |         _sendLogPayload(0x1c, 0xc4);
 12039 |     |         assembly {
 12040 |     |             mstore(0x00, m0)
 12041 |     |             mstore(0x20, m1)
 12042 |     |             mstore(0x40, m2)
 12043 |     |             mstore(0x60, m3)
 12044 |     |             mstore(0x80, m4)
 12045 |     |             mstore(0xa0, m5)
 12046 |     |             mstore(0xc0, m6)
 12047 |     |         }
 12048 |     |     }
 12049 |     | 
 12050 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {
 12051 |     |         bytes32 m0;
 12052 |     |         bytes32 m1;
 12053 |     |         bytes32 m2;
 12054 |     |         bytes32 m3;
 12055 |     |         bytes32 m4;
 12056 |     |         bytes32 m5;
 12057 |     |         bytes32 m6;
 12058 |     |         assembly {
 12059 |     |             function writeString(pos, w) {
 12060 |     |                 let length := 0
 12061 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12062 |     |                 mstore(pos, length)
 12063 |     |                 let shift := sub(256, shl(3, length))
 12064 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12065 |     |             }
 12066 |     |             m0 := mload(0x00)
 12067 |     |             m1 := mload(0x20)
 12068 |     |             m2 := mload(0x40)
 12069 |     |             m3 := mload(0x60)
 12070 |     |             m4 := mload(0x80)
 12071 |     |             m5 := mload(0xa0)
 12072 |     |             m6 := mload(0xc0)
 12073 |     |             // Selector of `log(string,uint256,uint256,bool)`.
 12074 |     |             mstore(0x00, 0x7626db92)
 12075 |     |             mstore(0x20, 0x80)
 12076 |     |             mstore(0x40, p1)
 12077 |     |             mstore(0x60, p2)
 12078 |     |             mstore(0x80, p3)
 12079 |     |             writeString(0xa0, p0)
 12080 |     |         }
 12081 |     |         _sendLogPayload(0x1c, 0xc4);
 12082 |     |         assembly {
 12083 |     |             mstore(0x00, m0)
 12084 |     |             mstore(0x20, m1)
 12085 |     |             mstore(0x40, m2)
 12086 |     |             mstore(0x60, m3)
 12087 |     |             mstore(0x80, m4)
 12088 |     |             mstore(0xa0, m5)
 12089 |     |             mstore(0xc0, m6)
 12090 |     |         }
 12091 |     |     }
 12092 |     | 
 12093 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 12094 |     |         bytes32 m0;
 12095 |     |         bytes32 m1;
 12096 |     |         bytes32 m2;
 12097 |     |         bytes32 m3;
 12098 |     |         bytes32 m4;
 12099 |     |         bytes32 m5;
 12100 |     |         bytes32 m6;
 12101 |     |         assembly {
 12102 |     |             function writeString(pos, w) {
 12103 |     |                 let length := 0
 12104 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12105 |     |                 mstore(pos, length)
 12106 |     |                 let shift := sub(256, shl(3, length))
 12107 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12108 |     |             }
 12109 |     |             m0 := mload(0x00)
 12110 |     |             m1 := mload(0x20)
 12111 |     |             m2 := mload(0x40)
 12112 |     |             m3 := mload(0x60)
 12113 |     |             m4 := mload(0x80)
 12114 |     |             m5 := mload(0xa0)
 12115 |     |             m6 := mload(0xc0)
 12116 |     |             // Selector of `log(string,uint256,uint256,uint256)`.
 12117 |     |             mstore(0x00, 0xa7a87853)
 12118 |     |             mstore(0x20, 0x80)
 12119 |     |             mstore(0x40, p1)
 12120 |     |             mstore(0x60, p2)
 12121 |     |             mstore(0x80, p3)
 12122 |     |             writeString(0xa0, p0)
 12123 |     |         }
 12124 |     |         _sendLogPayload(0x1c, 0xc4);
 12125 |     |         assembly {
 12126 |     |             mstore(0x00, m0)
 12127 |     |             mstore(0x20, m1)
 12128 |     |             mstore(0x40, m2)
 12129 |     |             mstore(0x60, m3)
 12130 |     |             mstore(0x80, m4)
 12131 |     |             mstore(0xa0, m5)
 12132 |     |             mstore(0xc0, m6)
 12133 |     |         }
 12134 |     |     }
 12135 |     | 
 12136 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
 12137 |     |         bytes32 m0;
 12138 |     |         bytes32 m1;
 12139 |     |         bytes32 m2;
 12140 |     |         bytes32 m3;
 12141 |     |         bytes32 m4;
 12142 |     |         bytes32 m5;
 12143 |     |         bytes32 m6;
 12144 |     |         bytes32 m7;
 12145 |     |         bytes32 m8;
 12146 |     |         assembly {
 12147 |     |             function writeString(pos, w) {
 12148 |     |                 let length := 0
 12149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12150 |     |                 mstore(pos, length)
 12151 |     |                 let shift := sub(256, shl(3, length))
 12152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12153 |     |             }
 12154 |     |             m0 := mload(0x00)
 12155 |     |             m1 := mload(0x20)
 12156 |     |             m2 := mload(0x40)
 12157 |     |             m3 := mload(0x60)
 12158 |     |             m4 := mload(0x80)
 12159 |     |             m5 := mload(0xa0)
 12160 |     |             m6 := mload(0xc0)
 12161 |     |             m7 := mload(0xe0)
 12162 |     |             m8 := mload(0x100)
 12163 |     |             // Selector of `log(string,uint256,uint256,string)`.
 12164 |     |             mstore(0x00, 0x854b3496)
 12165 |     |             mstore(0x20, 0x80)
 12166 |     |             mstore(0x40, p1)
 12167 |     |             mstore(0x60, p2)
 12168 |     |             mstore(0x80, 0xc0)
 12169 |     |             writeString(0xa0, p0)
 12170 |     |             writeString(0xe0, p3)
 12171 |     |         }
 12172 |     |         _sendLogPayload(0x1c, 0x104);
 12173 |     |         assembly {
 12174 |     |             mstore(0x00, m0)
 12175 |     |             mstore(0x20, m1)
 12176 |     |             mstore(0x40, m2)
 12177 |     |             mstore(0x60, m3)
 12178 |     |             mstore(0x80, m4)
 12179 |     |             mstore(0xa0, m5)
 12180 |     |             mstore(0xc0, m6)
 12181 |     |             mstore(0xe0, m7)
 12182 |     |             mstore(0x100, m8)
 12183 |     |         }
 12184 |     |     }
 12185 |     | 
 12186 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {
 12187 |     |         bytes32 m0;
 12188 |     |         bytes32 m1;
 12189 |     |         bytes32 m2;
 12190 |     |         bytes32 m3;
 12191 |     |         bytes32 m4;
 12192 |     |         bytes32 m5;
 12193 |     |         bytes32 m6;
 12194 |     |         bytes32 m7;
 12195 |     |         bytes32 m8;
 12196 |     |         assembly {
 12197 |     |             function writeString(pos, w) {
 12198 |     |                 let length := 0
 12199 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12200 |     |                 mstore(pos, length)
 12201 |     |                 let shift := sub(256, shl(3, length))
 12202 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12203 |     |             }
 12204 |     |             m0 := mload(0x00)
 12205 |     |             m1 := mload(0x20)
 12206 |     |             m2 := mload(0x40)
 12207 |     |             m3 := mload(0x60)
 12208 |     |             m4 := mload(0x80)
 12209 |     |             m5 := mload(0xa0)
 12210 |     |             m6 := mload(0xc0)
 12211 |     |             m7 := mload(0xe0)
 12212 |     |             m8 := mload(0x100)
 12213 |     |             // Selector of `log(string,uint256,string,address)`.
 12214 |     |             mstore(0x00, 0x7c4632a4)
 12215 |     |             mstore(0x20, 0x80)
 12216 |     |             mstore(0x40, p1)
 12217 |     |             mstore(0x60, 0xc0)
 12218 |     |             mstore(0x80, p3)
 12219 |     |             writeString(0xa0, p0)
 12220 |     |             writeString(0xe0, p2)
 12221 |     |         }
 12222 |     |         _sendLogPayload(0x1c, 0x104);
 12223 |     |         assembly {
 12224 |     |             mstore(0x00, m0)
 12225 |     |             mstore(0x20, m1)
 12226 |     |             mstore(0x40, m2)
 12227 |     |             mstore(0x60, m3)
 12228 |     |             mstore(0x80, m4)
 12229 |     |             mstore(0xa0, m5)
 12230 |     |             mstore(0xc0, m6)
 12231 |     |             mstore(0xe0, m7)
 12232 |     |             mstore(0x100, m8)
 12233 |     |         }
 12234 |     |     }
 12235 |     | 
 12236 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
 12237 |     |         bytes32 m0;
 12238 |     |         bytes32 m1;
 12239 |     |         bytes32 m2;
 12240 |     |         bytes32 m3;
 12241 |     |         bytes32 m4;
 12242 |     |         bytes32 m5;
 12243 |     |         bytes32 m6;
 12244 |     |         bytes32 m7;
 12245 |     |         bytes32 m8;
 12246 |     |         assembly {
 12247 |     |             function writeString(pos, w) {
 12248 |     |                 let length := 0
 12249 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12250 |     |                 mstore(pos, length)
 12251 |     |                 let shift := sub(256, shl(3, length))
 12252 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12253 |     |             }
 12254 |     |             m0 := mload(0x00)
 12255 |     |             m1 := mload(0x20)
 12256 |     |             m2 := mload(0x40)
 12257 |     |             m3 := mload(0x60)
 12258 |     |             m4 := mload(0x80)
 12259 |     |             m5 := mload(0xa0)
 12260 |     |             m6 := mload(0xc0)
 12261 |     |             m7 := mload(0xe0)
 12262 |     |             m8 := mload(0x100)
 12263 |     |             // Selector of `log(string,uint256,string,bool)`.
 12264 |     |             mstore(0x00, 0x7d24491d)
 12265 |     |             mstore(0x20, 0x80)
 12266 |     |             mstore(0x40, p1)
 12267 |     |             mstore(0x60, 0xc0)
 12268 |     |             mstore(0x80, p3)
 12269 |     |             writeString(0xa0, p0)
 12270 |     |             writeString(0xe0, p2)
 12271 |     |         }
 12272 |     |         _sendLogPayload(0x1c, 0x104);
 12273 |     |         assembly {
 12274 |     |             mstore(0x00, m0)
 12275 |     |             mstore(0x20, m1)
 12276 |     |             mstore(0x40, m2)
 12277 |     |             mstore(0x60, m3)
 12278 |     |             mstore(0x80, m4)
 12279 |     |             mstore(0xa0, m5)
 12280 |     |             mstore(0xc0, m6)
 12281 |     |             mstore(0xe0, m7)
 12282 |     |             mstore(0x100, m8)
 12283 |     |         }
 12284 |     |     }
 12285 |     | 
 12286 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
 12287 |     |         bytes32 m0;
 12288 |     |         bytes32 m1;
 12289 |     |         bytes32 m2;
 12290 |     |         bytes32 m3;
 12291 |     |         bytes32 m4;
 12292 |     |         bytes32 m5;
 12293 |     |         bytes32 m6;
 12294 |     |         bytes32 m7;
 12295 |     |         bytes32 m8;
 12296 |     |         assembly {
 12297 |     |             function writeString(pos, w) {
 12298 |     |                 let length := 0
 12299 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12300 |     |                 mstore(pos, length)
 12301 |     |                 let shift := sub(256, shl(3, length))
 12302 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12303 |     |             }
 12304 |     |             m0 := mload(0x00)
 12305 |     |             m1 := mload(0x20)
 12306 |     |             m2 := mload(0x40)
 12307 |     |             m3 := mload(0x60)
 12308 |     |             m4 := mload(0x80)
 12309 |     |             m5 := mload(0xa0)
 12310 |     |             m6 := mload(0xc0)
 12311 |     |             m7 := mload(0xe0)
 12312 |     |             m8 := mload(0x100)
 12313 |     |             // Selector of `log(string,uint256,string,uint256)`.
 12314 |     |             mstore(0x00, 0xc67ea9d1)
 12315 |     |             mstore(0x20, 0x80)
 12316 |     |             mstore(0x40, p1)
 12317 |     |             mstore(0x60, 0xc0)
 12318 |     |             mstore(0x80, p3)
 12319 |     |             writeString(0xa0, p0)
 12320 |     |             writeString(0xe0, p2)
 12321 |     |         }
 12322 |     |         _sendLogPayload(0x1c, 0x104);
 12323 |     |         assembly {
 12324 |     |             mstore(0x00, m0)
 12325 |     |             mstore(0x20, m1)
 12326 |     |             mstore(0x40, m2)
 12327 |     |             mstore(0x60, m3)
 12328 |     |             mstore(0x80, m4)
 12329 |     |             mstore(0xa0, m5)
 12330 |     |             mstore(0xc0, m6)
 12331 |     |             mstore(0xe0, m7)
 12332 |     |             mstore(0x100, m8)
 12333 |     |         }
 12334 |     |     }
 12335 |     | 
 12336 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
 12337 |     |         bytes32 m0;
 12338 |     |         bytes32 m1;
 12339 |     |         bytes32 m2;
 12340 |     |         bytes32 m3;
 12341 |     |         bytes32 m4;
 12342 |     |         bytes32 m5;
 12343 |     |         bytes32 m6;
 12344 |     |         bytes32 m7;
 12345 |     |         bytes32 m8;
 12346 |     |         bytes32 m9;
 12347 |     |         bytes32 m10;
 12348 |     |         assembly {
 12349 |     |             function writeString(pos, w) {
 12350 |     |                 let length := 0
 12351 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12352 |     |                 mstore(pos, length)
 12353 |     |                 let shift := sub(256, shl(3, length))
 12354 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12355 |     |             }
 12356 |     |             m0 := mload(0x00)
 12357 |     |             m1 := mload(0x20)
 12358 |     |             m2 := mload(0x40)
 12359 |     |             m3 := mload(0x60)
 12360 |     |             m4 := mload(0x80)
 12361 |     |             m5 := mload(0xa0)
 12362 |     |             m6 := mload(0xc0)
 12363 |     |             m7 := mload(0xe0)
 12364 |     |             m8 := mload(0x100)
 12365 |     |             m9 := mload(0x120)
 12366 |     |             m10 := mload(0x140)
 12367 |     |             // Selector of `log(string,uint256,string,string)`.
 12368 |     |             mstore(0x00, 0x5ab84e1f)
 12369 |     |             mstore(0x20, 0x80)
 12370 |     |             mstore(0x40, p1)
 12371 |     |             mstore(0x60, 0xc0)
 12372 |     |             mstore(0x80, 0x100)
 12373 |     |             writeString(0xa0, p0)
 12374 |     |             writeString(0xe0, p2)
 12375 |     |             writeString(0x120, p3)
 12376 |     |         }
 12377 |     |         _sendLogPayload(0x1c, 0x144);
 12378 |     |         assembly {
 12379 |     |             mstore(0x00, m0)
 12380 |     |             mstore(0x20, m1)
 12381 |     |             mstore(0x40, m2)
 12382 |     |             mstore(0x60, m3)
 12383 |     |             mstore(0x80, m4)
 12384 |     |             mstore(0xa0, m5)
 12385 |     |             mstore(0xc0, m6)
 12386 |     |             mstore(0xe0, m7)
 12387 |     |             mstore(0x100, m8)
 12388 |     |             mstore(0x120, m9)
 12389 |     |             mstore(0x140, m10)
 12390 |     |         }
 12391 |     |     }
 12392 |     | 
 12393 |     |     function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {
 12394 |     |         bytes32 m0;
 12395 |     |         bytes32 m1;
 12396 |     |         bytes32 m2;
 12397 |     |         bytes32 m3;
 12398 |     |         bytes32 m4;
 12399 |     |         bytes32 m5;
 12400 |     |         bytes32 m6;
 12401 |     |         bytes32 m7;
 12402 |     |         bytes32 m8;
 12403 |     |         assembly {
 12404 |     |             function writeString(pos, w) {
 12405 |     |                 let length := 0
 12406 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12407 |     |                 mstore(pos, length)
 12408 |     |                 let shift := sub(256, shl(3, length))
 12409 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12410 |     |             }
 12411 |     |             m0 := mload(0x00)
 12412 |     |             m1 := mload(0x20)
 12413 |     |             m2 := mload(0x40)
 12414 |     |             m3 := mload(0x60)
 12415 |     |             m4 := mload(0x80)
 12416 |     |             m5 := mload(0xa0)
 12417 |     |             m6 := mload(0xc0)
 12418 |     |             m7 := mload(0xe0)
 12419 |     |             m8 := mload(0x100)
 12420 |     |             // Selector of `log(string,string,address,address)`.
 12421 |     |             mstore(0x00, 0x439c7bef)
 12422 |     |             mstore(0x20, 0x80)
 12423 |     |             mstore(0x40, 0xc0)
 12424 |     |             mstore(0x60, p2)
 12425 |     |             mstore(0x80, p3)
 12426 |     |             writeString(0xa0, p0)
 12427 |     |             writeString(0xe0, p1)
 12428 |     |         }
 12429 |     |         _sendLogPayload(0x1c, 0x104);
 12430 |     |         assembly {
 12431 |     |             mstore(0x00, m0)
 12432 |     |             mstore(0x20, m1)
 12433 |     |             mstore(0x40, m2)
 12434 |     |             mstore(0x60, m3)
 12435 |     |             mstore(0x80, m4)
 12436 |     |             mstore(0xa0, m5)
 12437 |     |             mstore(0xc0, m6)
 12438 |     |             mstore(0xe0, m7)
 12439 |     |             mstore(0x100, m8)
 12440 |     |         }
 12441 |     |     }
 12442 |     | 
 12443 |     |     function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {
 12444 |     |         bytes32 m0;
 12445 |     |         bytes32 m1;
 12446 |     |         bytes32 m2;
 12447 |     |         bytes32 m3;
 12448 |     |         bytes32 m4;
 12449 |     |         bytes32 m5;
 12450 |     |         bytes32 m6;
 12451 |     |         bytes32 m7;
 12452 |     |         bytes32 m8;
 12453 |     |         assembly {
 12454 |     |             function writeString(pos, w) {
 12455 |     |                 let length := 0
 12456 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12457 |     |                 mstore(pos, length)
 12458 |     |                 let shift := sub(256, shl(3, length))
 12459 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12460 |     |             }
 12461 |     |             m0 := mload(0x00)
 12462 |     |             m1 := mload(0x20)
 12463 |     |             m2 := mload(0x40)
 12464 |     |             m3 := mload(0x60)
 12465 |     |             m4 := mload(0x80)
 12466 |     |             m5 := mload(0xa0)
 12467 |     |             m6 := mload(0xc0)
 12468 |     |             m7 := mload(0xe0)
 12469 |     |             m8 := mload(0x100)
 12470 |     |             // Selector of `log(string,string,address,bool)`.
 12471 |     |             mstore(0x00, 0x5ccd4e37)
 12472 |     |             mstore(0x20, 0x80)
 12473 |     |             mstore(0x40, 0xc0)
 12474 |     |             mstore(0x60, p2)
 12475 |     |             mstore(0x80, p3)
 12476 |     |             writeString(0xa0, p0)
 12477 |     |             writeString(0xe0, p1)
 12478 |     |         }
 12479 |     |         _sendLogPayload(0x1c, 0x104);
 12480 |     |         assembly {
 12481 |     |             mstore(0x00, m0)
 12482 |     |             mstore(0x20, m1)
 12483 |     |             mstore(0x40, m2)
 12484 |     |             mstore(0x60, m3)
 12485 |     |             mstore(0x80, m4)
 12486 |     |             mstore(0xa0, m5)
 12487 |     |             mstore(0xc0, m6)
 12488 |     |             mstore(0xe0, m7)
 12489 |     |             mstore(0x100, m8)
 12490 |     |         }
 12491 |     |     }
 12492 |     | 
 12493 |     |     function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 12494 |     |         bytes32 m0;
 12495 |     |         bytes32 m1;
 12496 |     |         bytes32 m2;
 12497 |     |         bytes32 m3;
 12498 |     |         bytes32 m4;
 12499 |     |         bytes32 m5;
 12500 |     |         bytes32 m6;
 12501 |     |         bytes32 m7;
 12502 |     |         bytes32 m8;
 12503 |     |         assembly {
 12504 |     |             function writeString(pos, w) {
 12505 |     |                 let length := 0
 12506 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12507 |     |                 mstore(pos, length)
 12508 |     |                 let shift := sub(256, shl(3, length))
 12509 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12510 |     |             }
 12511 |     |             m0 := mload(0x00)
 12512 |     |             m1 := mload(0x20)
 12513 |     |             m2 := mload(0x40)
 12514 |     |             m3 := mload(0x60)
 12515 |     |             m4 := mload(0x80)
 12516 |     |             m5 := mload(0xa0)
 12517 |     |             m6 := mload(0xc0)
 12518 |     |             m7 := mload(0xe0)
 12519 |     |             m8 := mload(0x100)
 12520 |     |             // Selector of `log(string,string,address,uint256)`.
 12521 |     |             mstore(0x00, 0x7cc3c607)
 12522 |     |             mstore(0x20, 0x80)
 12523 |     |             mstore(0x40, 0xc0)
 12524 |     |             mstore(0x60, p2)
 12525 |     |             mstore(0x80, p3)
 12526 |     |             writeString(0xa0, p0)
 12527 |     |             writeString(0xe0, p1)
 12528 |     |         }
 12529 |     |         _sendLogPayload(0x1c, 0x104);
 12530 |     |         assembly {
 12531 |     |             mstore(0x00, m0)
 12532 |     |             mstore(0x20, m1)
 12533 |     |             mstore(0x40, m2)
 12534 |     |             mstore(0x60, m3)
 12535 |     |             mstore(0x80, m4)
 12536 |     |             mstore(0xa0, m5)
 12537 |     |             mstore(0xc0, m6)
 12538 |     |             mstore(0xe0, m7)
 12539 |     |             mstore(0x100, m8)
 12540 |     |         }
 12541 |     |     }
 12542 |     | 
 12543 |     |     function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 12544 |     |         bytes32 m0;
 12545 |     |         bytes32 m1;
 12546 |     |         bytes32 m2;
 12547 |     |         bytes32 m3;
 12548 |     |         bytes32 m4;
 12549 |     |         bytes32 m5;
 12550 |     |         bytes32 m6;
 12551 |     |         bytes32 m7;
 12552 |     |         bytes32 m8;
 12553 |     |         bytes32 m9;
 12554 |     |         bytes32 m10;
 12555 |     |         assembly {
 12556 |     |             function writeString(pos, w) {
 12557 |     |                 let length := 0
 12558 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12559 |     |                 mstore(pos, length)
 12560 |     |                 let shift := sub(256, shl(3, length))
 12561 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12562 |     |             }
 12563 |     |             m0 := mload(0x00)
 12564 |     |             m1 := mload(0x20)
 12565 |     |             m2 := mload(0x40)
 12566 |     |             m3 := mload(0x60)
 12567 |     |             m4 := mload(0x80)
 12568 |     |             m5 := mload(0xa0)
 12569 |     |             m6 := mload(0xc0)
 12570 |     |             m7 := mload(0xe0)
 12571 |     |             m8 := mload(0x100)
 12572 |     |             m9 := mload(0x120)
 12573 |     |             m10 := mload(0x140)
 12574 |     |             // Selector of `log(string,string,address,string)`.
 12575 |     |             mstore(0x00, 0xeb1bff80)
 12576 |     |             mstore(0x20, 0x80)
 12577 |     |             mstore(0x40, 0xc0)
 12578 |     |             mstore(0x60, p2)
 12579 |     |             mstore(0x80, 0x100)
 12580 |     |             writeString(0xa0, p0)
 12581 |     |             writeString(0xe0, p1)
 12582 |     |             writeString(0x120, p3)
 12583 |     |         }
 12584 |     |         _sendLogPayload(0x1c, 0x144);
 12585 |     |         assembly {
 12586 |     |             mstore(0x00, m0)
 12587 |     |             mstore(0x20, m1)
 12588 |     |             mstore(0x40, m2)
 12589 |     |             mstore(0x60, m3)
 12590 |     |             mstore(0x80, m4)
 12591 |     |             mstore(0xa0, m5)
 12592 |     |             mstore(0xc0, m6)
 12593 |     |             mstore(0xe0, m7)
 12594 |     |             mstore(0x100, m8)
 12595 |     |             mstore(0x120, m9)
 12596 |     |             mstore(0x140, m10)
 12597 |     |         }
 12598 |     |     }
 12599 |     | 
 12600 |     |     function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {
 12601 |     |         bytes32 m0;
 12602 |     |         bytes32 m1;
 12603 |     |         bytes32 m2;
 12604 |     |         bytes32 m3;
 12605 |     |         bytes32 m4;
 12606 |     |         bytes32 m5;
 12607 |     |         bytes32 m6;
 12608 |     |         bytes32 m7;
 12609 |     |         bytes32 m8;
 12610 |     |         assembly {
 12611 |     |             function writeString(pos, w) {
 12612 |     |                 let length := 0
 12613 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12614 |     |                 mstore(pos, length)
 12615 |     |                 let shift := sub(256, shl(3, length))
 12616 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12617 |     |             }
 12618 |     |             m0 := mload(0x00)
 12619 |     |             m1 := mload(0x20)
 12620 |     |             m2 := mload(0x40)
 12621 |     |             m3 := mload(0x60)
 12622 |     |             m4 := mload(0x80)
 12623 |     |             m5 := mload(0xa0)
 12624 |     |             m6 := mload(0xc0)
 12625 |     |             m7 := mload(0xe0)
 12626 |     |             m8 := mload(0x100)
 12627 |     |             // Selector of `log(string,string,bool,address)`.
 12628 |     |             mstore(0x00, 0xc371c7db)
 12629 |     |             mstore(0x20, 0x80)
 12630 |     |             mstore(0x40, 0xc0)
 12631 |     |             mstore(0x60, p2)
 12632 |     |             mstore(0x80, p3)
 12633 |     |             writeString(0xa0, p0)
 12634 |     |             writeString(0xe0, p1)
 12635 |     |         }
 12636 |     |         _sendLogPayload(0x1c, 0x104);
 12637 |     |         assembly {
 12638 |     |             mstore(0x00, m0)
 12639 |     |             mstore(0x20, m1)
 12640 |     |             mstore(0x40, m2)
 12641 |     |             mstore(0x60, m3)
 12642 |     |             mstore(0x80, m4)
 12643 |     |             mstore(0xa0, m5)
 12644 |     |             mstore(0xc0, m6)
 12645 |     |             mstore(0xe0, m7)
 12646 |     |             mstore(0x100, m8)
 12647 |     |         }
 12648 |     |     }
 12649 |     | 
 12650 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {
 12651 |     |         bytes32 m0;
 12652 |     |         bytes32 m1;
 12653 |     |         bytes32 m2;
 12654 |     |         bytes32 m3;
 12655 |     |         bytes32 m4;
 12656 |     |         bytes32 m5;
 12657 |     |         bytes32 m6;
 12658 |     |         bytes32 m7;
 12659 |     |         bytes32 m8;
 12660 |     |         assembly {
 12661 |     |             function writeString(pos, w) {
 12662 |     |                 let length := 0
 12663 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12664 |     |                 mstore(pos, length)
 12665 |     |                 let shift := sub(256, shl(3, length))
 12666 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12667 |     |             }
 12668 |     |             m0 := mload(0x00)
 12669 |     |             m1 := mload(0x20)
 12670 |     |             m2 := mload(0x40)
 12671 |     |             m3 := mload(0x60)
 12672 |     |             m4 := mload(0x80)
 12673 |     |             m5 := mload(0xa0)
 12674 |     |             m6 := mload(0xc0)
 12675 |     |             m7 := mload(0xe0)
 12676 |     |             m8 := mload(0x100)
 12677 |     |             // Selector of `log(string,string,bool,bool)`.
 12678 |     |             mstore(0x00, 0x40785869)
 12679 |     |             mstore(0x20, 0x80)
 12680 |     |             mstore(0x40, 0xc0)
 12681 |     |             mstore(0x60, p2)
 12682 |     |             mstore(0x80, p3)
 12683 |     |             writeString(0xa0, p0)
 12684 |     |             writeString(0xe0, p1)
 12685 |     |         }
 12686 |     |         _sendLogPayload(0x1c, 0x104);
 12687 |     |         assembly {
 12688 |     |             mstore(0x00, m0)
 12689 |     |             mstore(0x20, m1)
 12690 |     |             mstore(0x40, m2)
 12691 |     |             mstore(0x60, m3)
 12692 |     |             mstore(0x80, m4)
 12693 |     |             mstore(0xa0, m5)
 12694 |     |             mstore(0xc0, m6)
 12695 |     |             mstore(0xe0, m7)
 12696 |     |             mstore(0x100, m8)
 12697 |     |         }
 12698 |     |     }
 12699 |     | 
 12700 |     |     function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 12701 |     |         bytes32 m0;
 12702 |     |         bytes32 m1;
 12703 |     |         bytes32 m2;
 12704 |     |         bytes32 m3;
 12705 |     |         bytes32 m4;
 12706 |     |         bytes32 m5;
 12707 |     |         bytes32 m6;
 12708 |     |         bytes32 m7;
 12709 |     |         bytes32 m8;
 12710 |     |         assembly {
 12711 |     |             function writeString(pos, w) {
 12712 |     |                 let length := 0
 12713 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12714 |     |                 mstore(pos, length)
 12715 |     |                 let shift := sub(256, shl(3, length))
 12716 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12717 |     |             }
 12718 |     |             m0 := mload(0x00)
 12719 |     |             m1 := mload(0x20)
 12720 |     |             m2 := mload(0x40)
 12721 |     |             m3 := mload(0x60)
 12722 |     |             m4 := mload(0x80)
 12723 |     |             m5 := mload(0xa0)
 12724 |     |             m6 := mload(0xc0)
 12725 |     |             m7 := mload(0xe0)
 12726 |     |             m8 := mload(0x100)
 12727 |     |             // Selector of `log(string,string,bool,uint256)`.
 12728 |     |             mstore(0x00, 0xd6aefad2)
 12729 |     |             mstore(0x20, 0x80)
 12730 |     |             mstore(0x40, 0xc0)
 12731 |     |             mstore(0x60, p2)
 12732 |     |             mstore(0x80, p3)
 12733 |     |             writeString(0xa0, p0)
 12734 |     |             writeString(0xe0, p1)
 12735 |     |         }
 12736 |     |         _sendLogPayload(0x1c, 0x104);
 12737 |     |         assembly {
 12738 |     |             mstore(0x00, m0)
 12739 |     |             mstore(0x20, m1)
 12740 |     |             mstore(0x40, m2)
 12741 |     |             mstore(0x60, m3)
 12742 |     |             mstore(0x80, m4)
 12743 |     |             mstore(0xa0, m5)
 12744 |     |             mstore(0xc0, m6)
 12745 |     |             mstore(0xe0, m7)
 12746 |     |             mstore(0x100, m8)
 12747 |     |         }
 12748 |     |     }
 12749 |     | 
 12750 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 12751 |     |         bytes32 m0;
 12752 |     |         bytes32 m1;
 12753 |     |         bytes32 m2;
 12754 |     |         bytes32 m3;
 12755 |     |         bytes32 m4;
 12756 |     |         bytes32 m5;
 12757 |     |         bytes32 m6;
 12758 |     |         bytes32 m7;
 12759 |     |         bytes32 m8;
 12760 |     |         bytes32 m9;
 12761 |     |         bytes32 m10;
 12762 |     |         assembly {
 12763 |     |             function writeString(pos, w) {
 12764 |     |                 let length := 0
 12765 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12766 |     |                 mstore(pos, length)
 12767 |     |                 let shift := sub(256, shl(3, length))
 12768 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12769 |     |             }
 12770 |     |             m0 := mload(0x00)
 12771 |     |             m1 := mload(0x20)
 12772 |     |             m2 := mload(0x40)
 12773 |     |             m3 := mload(0x60)
 12774 |     |             m4 := mload(0x80)
 12775 |     |             m5 := mload(0xa0)
 12776 |     |             m6 := mload(0xc0)
 12777 |     |             m7 := mload(0xe0)
 12778 |     |             m8 := mload(0x100)
 12779 |     |             m9 := mload(0x120)
 12780 |     |             m10 := mload(0x140)
 12781 |     |             // Selector of `log(string,string,bool,string)`.
 12782 |     |             mstore(0x00, 0x5e84b0ea)
 12783 |     |             mstore(0x20, 0x80)
 12784 |     |             mstore(0x40, 0xc0)
 12785 |     |             mstore(0x60, p2)
 12786 |     |             mstore(0x80, 0x100)
 12787 |     |             writeString(0xa0, p0)
 12788 |     |             writeString(0xe0, p1)
 12789 |     |             writeString(0x120, p3)
 12790 |     |         }
 12791 |     |         _sendLogPayload(0x1c, 0x144);
 12792 |     |         assembly {
 12793 |     |             mstore(0x00, m0)
 12794 |     |             mstore(0x20, m1)
 12795 |     |             mstore(0x40, m2)
 12796 |     |             mstore(0x60, m3)
 12797 |     |             mstore(0x80, m4)
 12798 |     |             mstore(0xa0, m5)
 12799 |     |             mstore(0xc0, m6)
 12800 |     |             mstore(0xe0, m7)
 12801 |     |             mstore(0x100, m8)
 12802 |     |             mstore(0x120, m9)
 12803 |     |             mstore(0x140, m10)
 12804 |     |         }
 12805 |     |     }
 12806 |     | 
 12807 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 12808 |     |         bytes32 m0;
 12809 |     |         bytes32 m1;
 12810 |     |         bytes32 m2;
 12811 |     |         bytes32 m3;
 12812 |     |         bytes32 m4;
 12813 |     |         bytes32 m5;
 12814 |     |         bytes32 m6;
 12815 |     |         bytes32 m7;
 12816 |     |         bytes32 m8;
 12817 |     |         assembly {
 12818 |     |             function writeString(pos, w) {
 12819 |     |                 let length := 0
 12820 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12821 |     |                 mstore(pos, length)
 12822 |     |                 let shift := sub(256, shl(3, length))
 12823 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12824 |     |             }
 12825 |     |             m0 := mload(0x00)
 12826 |     |             m1 := mload(0x20)
 12827 |     |             m2 := mload(0x40)
 12828 |     |             m3 := mload(0x60)
 12829 |     |             m4 := mload(0x80)
 12830 |     |             m5 := mload(0xa0)
 12831 |     |             m6 := mload(0xc0)
 12832 |     |             m7 := mload(0xe0)
 12833 |     |             m8 := mload(0x100)
 12834 |     |             // Selector of `log(string,string,uint256,address)`.
 12835 |     |             mstore(0x00, 0x1023f7b2)
 12836 |     |             mstore(0x20, 0x80)
 12837 |     |             mstore(0x40, 0xc0)
 12838 |     |             mstore(0x60, p2)
 12839 |     |             mstore(0x80, p3)
 12840 |     |             writeString(0xa0, p0)
 12841 |     |             writeString(0xe0, p1)
 12842 |     |         }
 12843 |     |         _sendLogPayload(0x1c, 0x104);
 12844 |     |         assembly {
 12845 |     |             mstore(0x00, m0)
 12846 |     |             mstore(0x20, m1)
 12847 |     |             mstore(0x40, m2)
 12848 |     |             mstore(0x60, m3)
 12849 |     |             mstore(0x80, m4)
 12850 |     |             mstore(0xa0, m5)
 12851 |     |             mstore(0xc0, m6)
 12852 |     |             mstore(0xe0, m7)
 12853 |     |             mstore(0x100, m8)
 12854 |     |         }
 12855 |     |     }
 12856 |     | 
 12857 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 12858 |     |         bytes32 m0;
 12859 |     |         bytes32 m1;
 12860 |     |         bytes32 m2;
 12861 |     |         bytes32 m3;
 12862 |     |         bytes32 m4;
 12863 |     |         bytes32 m5;
 12864 |     |         bytes32 m6;
 12865 |     |         bytes32 m7;
 12866 |     |         bytes32 m8;
 12867 |     |         assembly {
 12868 |     |             function writeString(pos, w) {
 12869 |     |                 let length := 0
 12870 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12871 |     |                 mstore(pos, length)
 12872 |     |                 let shift := sub(256, shl(3, length))
 12873 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12874 |     |             }
 12875 |     |             m0 := mload(0x00)
 12876 |     |             m1 := mload(0x20)
 12877 |     |             m2 := mload(0x40)
 12878 |     |             m3 := mload(0x60)
 12879 |     |             m4 := mload(0x80)
 12880 |     |             m5 := mload(0xa0)
 12881 |     |             m6 := mload(0xc0)
 12882 |     |             m7 := mload(0xe0)
 12883 |     |             m8 := mload(0x100)
 12884 |     |             // Selector of `log(string,string,uint256,bool)`.
 12885 |     |             mstore(0x00, 0xc3a8a654)
 12886 |     |             mstore(0x20, 0x80)
 12887 |     |             mstore(0x40, 0xc0)
 12888 |     |             mstore(0x60, p2)
 12889 |     |             mstore(0x80, p3)
 12890 |     |             writeString(0xa0, p0)
 12891 |     |             writeString(0xe0, p1)
 12892 |     |         }
 12893 |     |         _sendLogPayload(0x1c, 0x104);
 12894 |     |         assembly {
 12895 |     |             mstore(0x00, m0)
 12896 |     |             mstore(0x20, m1)
 12897 |     |             mstore(0x40, m2)
 12898 |     |             mstore(0x60, m3)
 12899 |     |             mstore(0x80, m4)
 12900 |     |             mstore(0xa0, m5)
 12901 |     |             mstore(0xc0, m6)
 12902 |     |             mstore(0xe0, m7)
 12903 |     |             mstore(0x100, m8)
 12904 |     |         }
 12905 |     |     }
 12906 |     | 
 12907 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 12908 |     |         bytes32 m0;
 12909 |     |         bytes32 m1;
 12910 |     |         bytes32 m2;
 12911 |     |         bytes32 m3;
 12912 |     |         bytes32 m4;
 12913 |     |         bytes32 m5;
 12914 |     |         bytes32 m6;
 12915 |     |         bytes32 m7;
 12916 |     |         bytes32 m8;
 12917 |     |         assembly {
 12918 |     |             function writeString(pos, w) {
 12919 |     |                 let length := 0
 12920 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12921 |     |                 mstore(pos, length)
 12922 |     |                 let shift := sub(256, shl(3, length))
 12923 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12924 |     |             }
 12925 |     |             m0 := mload(0x00)
 12926 |     |             m1 := mload(0x20)
 12927 |     |             m2 := mload(0x40)
 12928 |     |             m3 := mload(0x60)
 12929 |     |             m4 := mload(0x80)
 12930 |     |             m5 := mload(0xa0)
 12931 |     |             m6 := mload(0xc0)
 12932 |     |             m7 := mload(0xe0)
 12933 |     |             m8 := mload(0x100)
 12934 |     |             // Selector of `log(string,string,uint256,uint256)`.
 12935 |     |             mstore(0x00, 0xf45d7d2c)
 12936 |     |             mstore(0x20, 0x80)
 12937 |     |             mstore(0x40, 0xc0)
 12938 |     |             mstore(0x60, p2)
 12939 |     |             mstore(0x80, p3)
 12940 |     |             writeString(0xa0, p0)
 12941 |     |             writeString(0xe0, p1)
 12942 |     |         }
 12943 |     |         _sendLogPayload(0x1c, 0x104);
 12944 |     |         assembly {
 12945 |     |             mstore(0x00, m0)
 12946 |     |             mstore(0x20, m1)
 12947 |     |             mstore(0x40, m2)
 12948 |     |             mstore(0x60, m3)
 12949 |     |             mstore(0x80, m4)
 12950 |     |             mstore(0xa0, m5)
 12951 |     |             mstore(0xc0, m6)
 12952 |     |             mstore(0xe0, m7)
 12953 |     |             mstore(0x100, m8)
 12954 |     |         }
 12955 |     |     }
 12956 |     | 
 12957 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 12958 |     |         bytes32 m0;
 12959 |     |         bytes32 m1;
 12960 |     |         bytes32 m2;
 12961 |     |         bytes32 m3;
 12962 |     |         bytes32 m4;
 12963 |     |         bytes32 m5;
 12964 |     |         bytes32 m6;
 12965 |     |         bytes32 m7;
 12966 |     |         bytes32 m8;
 12967 |     |         bytes32 m9;
 12968 |     |         bytes32 m10;
 12969 |     |         assembly {
 12970 |     |             function writeString(pos, w) {
 12971 |     |                 let length := 0
 12972 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12973 |     |                 mstore(pos, length)
 12974 |     |                 let shift := sub(256, shl(3, length))
 12975 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12976 |     |             }
 12977 |     |             m0 := mload(0x00)
 12978 |     |             m1 := mload(0x20)
 12979 |     |             m2 := mload(0x40)
 12980 |     |             m3 := mload(0x60)
 12981 |     |             m4 := mload(0x80)
 12982 |     |             m5 := mload(0xa0)
 12983 |     |             m6 := mload(0xc0)
 12984 |     |             m7 := mload(0xe0)
 12985 |     |             m8 := mload(0x100)
 12986 |     |             m9 := mload(0x120)
 12987 |     |             m10 := mload(0x140)
 12988 |     |             // Selector of `log(string,string,uint256,string)`.
 12989 |     |             mstore(0x00, 0x5d1a971a)
 12990 |     |             mstore(0x20, 0x80)
 12991 |     |             mstore(0x40, 0xc0)
 12992 |     |             mstore(0x60, p2)
 12993 |     |             mstore(0x80, 0x100)
 12994 |     |             writeString(0xa0, p0)
 12995 |     |             writeString(0xe0, p1)
 12996 |     |             writeString(0x120, p3)
 12997 |     |         }
 12998 |     |         _sendLogPayload(0x1c, 0x144);
 12999 |     |         assembly {
 13000 |     |             mstore(0x00, m0)
 13001 |     |             mstore(0x20, m1)
 13002 |     |             mstore(0x40, m2)
 13003 |     |             mstore(0x60, m3)
 13004 |     |             mstore(0x80, m4)
 13005 |     |             mstore(0xa0, m5)
 13006 |     |             mstore(0xc0, m6)
 13007 |     |             mstore(0xe0, m7)
 13008 |     |             mstore(0x100, m8)
 13009 |     |             mstore(0x120, m9)
 13010 |     |             mstore(0x140, m10)
 13011 |     |         }
 13012 |     |     }
 13013 |     | 
 13014 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 13015 |     |         bytes32 m0;
 13016 |     |         bytes32 m1;
 13017 |     |         bytes32 m2;
 13018 |     |         bytes32 m3;
 13019 |     |         bytes32 m4;
 13020 |     |         bytes32 m5;
 13021 |     |         bytes32 m6;
 13022 |     |         bytes32 m7;
 13023 |     |         bytes32 m8;
 13024 |     |         bytes32 m9;
 13025 |     |         bytes32 m10;
 13026 |     |         assembly {
 13027 |     |             function writeString(pos, w) {
 13028 |     |                 let length := 0
 13029 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13030 |     |                 mstore(pos, length)
 13031 |     |                 let shift := sub(256, shl(3, length))
 13032 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13033 |     |             }
 13034 |     |             m0 := mload(0x00)
 13035 |     |             m1 := mload(0x20)
 13036 |     |             m2 := mload(0x40)
 13037 |     |             m3 := mload(0x60)
 13038 |     |             m4 := mload(0x80)
 13039 |     |             m5 := mload(0xa0)
 13040 |     |             m6 := mload(0xc0)
 13041 |     |             m7 := mload(0xe0)
 13042 |     |             m8 := mload(0x100)
 13043 |     |             m9 := mload(0x120)
 13044 |     |             m10 := mload(0x140)
 13045 |     |             // Selector of `log(string,string,string,address)`.
 13046 |     |             mstore(0x00, 0x6d572f44)
 13047 |     |             mstore(0x20, 0x80)
 13048 |     |             mstore(0x40, 0xc0)
 13049 |     |             mstore(0x60, 0x100)
 13050 |     |             mstore(0x80, p3)
 13051 |     |             writeString(0xa0, p0)
 13052 |     |             writeString(0xe0, p1)
 13053 |     |             writeString(0x120, p2)
 13054 |     |         }
 13055 |     |         _sendLogPayload(0x1c, 0x144);
 13056 |     |         assembly {
 13057 |     |             mstore(0x00, m0)
 13058 |     |             mstore(0x20, m1)
 13059 |     |             mstore(0x40, m2)
 13060 |     |             mstore(0x60, m3)
 13061 |     |             mstore(0x80, m4)
 13062 |     |             mstore(0xa0, m5)
 13063 |     |             mstore(0xc0, m6)
 13064 |     |             mstore(0xe0, m7)
 13065 |     |             mstore(0x100, m8)
 13066 |     |             mstore(0x120, m9)
 13067 |     |             mstore(0x140, m10)
 13068 |     |         }
 13069 |     |     }
 13070 |     | 
 13071 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 13072 |     |         bytes32 m0;
 13073 |     |         bytes32 m1;
 13074 |     |         bytes32 m2;
 13075 |     |         bytes32 m3;
 13076 |     |         bytes32 m4;
 13077 |     |         bytes32 m5;
 13078 |     |         bytes32 m6;
 13079 |     |         bytes32 m7;
 13080 |     |         bytes32 m8;
 13081 |     |         bytes32 m9;
 13082 |     |         bytes32 m10;
 13083 |     |         assembly {
 13084 |     |             function writeString(pos, w) {
 13085 |     |                 let length := 0
 13086 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13087 |     |                 mstore(pos, length)
 13088 |     |                 let shift := sub(256, shl(3, length))
 13089 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13090 |     |             }
 13091 |     |             m0 := mload(0x00)
 13092 |     |             m1 := mload(0x20)
 13093 |     |             m2 := mload(0x40)
 13094 |     |             m3 := mload(0x60)
 13095 |     |             m4 := mload(0x80)
 13096 |     |             m5 := mload(0xa0)
 13097 |     |             m6 := mload(0xc0)
 13098 |     |             m7 := mload(0xe0)
 13099 |     |             m8 := mload(0x100)
 13100 |     |             m9 := mload(0x120)
 13101 |     |             m10 := mload(0x140)
 13102 |     |             // Selector of `log(string,string,string,bool)`.
 13103 |     |             mstore(0x00, 0x2c1754ed)
 13104 |     |             mstore(0x20, 0x80)
 13105 |     |             mstore(0x40, 0xc0)
 13106 |     |             mstore(0x60, 0x100)
 13107 |     |             mstore(0x80, p3)
 13108 |     |             writeString(0xa0, p0)
 13109 |     |             writeString(0xe0, p1)
 13110 |     |             writeString(0x120, p2)
 13111 |     |         }
 13112 |     |         _sendLogPayload(0x1c, 0x144);
 13113 |     |         assembly {
 13114 |     |             mstore(0x00, m0)
 13115 |     |             mstore(0x20, m1)
 13116 |     |             mstore(0x40, m2)
 13117 |     |             mstore(0x60, m3)
 13118 |     |             mstore(0x80, m4)
 13119 |     |             mstore(0xa0, m5)
 13120 |     |             mstore(0xc0, m6)
 13121 |     |             mstore(0xe0, m7)
 13122 |     |             mstore(0x100, m8)
 13123 |     |             mstore(0x120, m9)
 13124 |     |             mstore(0x140, m10)
 13125 |     |         }
 13126 |     |     }
 13127 |     | 
 13128 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 13129 |     |         bytes32 m0;
 13130 |     |         bytes32 m1;
 13131 |     |         bytes32 m2;
 13132 |     |         bytes32 m3;
 13133 |     |         bytes32 m4;
 13134 |     |         bytes32 m5;
 13135 |     |         bytes32 m6;
 13136 |     |         bytes32 m7;
 13137 |     |         bytes32 m8;
 13138 |     |         bytes32 m9;
 13139 |     |         bytes32 m10;
 13140 |     |         assembly {
 13141 |     |             function writeString(pos, w) {
 13142 |     |                 let length := 0
 13143 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13144 |     |                 mstore(pos, length)
 13145 |     |                 let shift := sub(256, shl(3, length))
 13146 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13147 |     |             }
 13148 |     |             m0 := mload(0x00)
 13149 |     |             m1 := mload(0x20)
 13150 |     |             m2 := mload(0x40)
 13151 |     |             m3 := mload(0x60)
 13152 |     |             m4 := mload(0x80)
 13153 |     |             m5 := mload(0xa0)
 13154 |     |             m6 := mload(0xc0)
 13155 |     |             m7 := mload(0xe0)
 13156 |     |             m8 := mload(0x100)
 13157 |     |             m9 := mload(0x120)
 13158 |     |             m10 := mload(0x140)
 13159 |     |             // Selector of `log(string,string,string,uint256)`.
 13160 |     |             mstore(0x00, 0x8eafb02b)
 13161 |     |             mstore(0x20, 0x80)
 13162 |     |             mstore(0x40, 0xc0)
 13163 |     |             mstore(0x60, 0x100)
 13164 |     |             mstore(0x80, p3)
 13165 |     |             writeString(0xa0, p0)
 13166 |     |             writeString(0xe0, p1)
 13167 |     |             writeString(0x120, p2)
 13168 |     |         }
 13169 |     |         _sendLogPayload(0x1c, 0x144);
 13170 |     |         assembly {
 13171 |     |             mstore(0x00, m0)
 13172 |     |             mstore(0x20, m1)
 13173 |     |             mstore(0x40, m2)
 13174 |     |             mstore(0x60, m3)
 13175 |     |             mstore(0x80, m4)
 13176 |     |             mstore(0xa0, m5)
 13177 |     |             mstore(0xc0, m6)
 13178 |     |             mstore(0xe0, m7)
 13179 |     |             mstore(0x100, m8)
 13180 |     |             mstore(0x120, m9)
 13181 |     |             mstore(0x140, m10)
 13182 |     |         }
 13183 |     |     }
 13184 |     | 
 13185 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 13186 |     |         bytes32 m0;
 13187 |     |         bytes32 m1;
 13188 |     |         bytes32 m2;
 13189 |     |         bytes32 m3;
 13190 |     |         bytes32 m4;
 13191 |     |         bytes32 m5;
 13192 |     |         bytes32 m6;
 13193 |     |         bytes32 m7;
 13194 |     |         bytes32 m8;
 13195 |     |         bytes32 m9;
 13196 |     |         bytes32 m10;
 13197 |     |         bytes32 m11;
 13198 |     |         bytes32 m12;
 13199 |     |         assembly {
 13200 |     |             function writeString(pos, w) {
 13201 |     |                 let length := 0
 13202 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13203 |     |                 mstore(pos, length)
 13204 |     |                 let shift := sub(256, shl(3, length))
 13205 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13206 |     |             }
 13207 |     |             m0 := mload(0x00)
 13208 |     |             m1 := mload(0x20)
 13209 |     |             m2 := mload(0x40)
 13210 |     |             m3 := mload(0x60)
 13211 |     |             m4 := mload(0x80)
 13212 |     |             m5 := mload(0xa0)
 13213 |     |             m6 := mload(0xc0)
 13214 |     |             m7 := mload(0xe0)
 13215 |     |             m8 := mload(0x100)
 13216 |     |             m9 := mload(0x120)
 13217 |     |             m10 := mload(0x140)
 13218 |     |             m11 := mload(0x160)
 13219 |     |             m12 := mload(0x180)
 13220 |     |             // Selector of `log(string,string,string,string)`.
 13221 |     |             mstore(0x00, 0xde68f20a)
 13222 |     |             mstore(0x20, 0x80)
 13223 |     |             mstore(0x40, 0xc0)
 13224 |     |             mstore(0x60, 0x100)
 13225 |     |             mstore(0x80, 0x140)
 13226 |     |             writeString(0xa0, p0)
 13227 |     |             writeString(0xe0, p1)
 13228 |     |             writeString(0x120, p2)
 13229 |     |             writeString(0x160, p3)
 13230 |     |         }
 13231 |     |         _sendLogPayload(0x1c, 0x184);
 13232 |     |         assembly {
 13233 |     |             mstore(0x00, m0)
 13234 |     |             mstore(0x20, m1)
 13235 |     |             mstore(0x40, m2)
 13236 |     |             mstore(0x60, m3)
 13237 |     |             mstore(0x80, m4)
 13238 |     |             mstore(0xa0, m5)
 13239 |     |             mstore(0xc0, m6)
 13240 |     |             mstore(0xe0, m7)
 13241 |     |             mstore(0x100, m8)
 13242 |     |             mstore(0x120, m9)
 13243 |     |             mstore(0x140, m10)
 13244 |     |             mstore(0x160, m11)
 13245 |     |             mstore(0x180, m12)
 13246 |     |         }
 13247 |     |     }
 13248 |     | }
 13249 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/FuzzBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Fuzzlib} from "./Fuzzlib.sol";
  5 |     | import {PlatformCrytic} from "./platform/PlatformCrytic.sol";
  6 |     | 
  7 |     | abstract contract FuzzBase {
  8 |     |     Fuzzlib internal fl = new Fuzzlib();
  9 |     | 
 10 |     |     constructor() {
 11 |     |         fl.setPlatform(address(new PlatformCrytic()));
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/FuzzLibString.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @notice Efficient library for creating string representations of integers.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
   6 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
   7 |     | /// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | library FuzzLibString {
   9 |     |     bytes16 internal constant HEX_DIGITS = "0123456789abcdef";
  10 |     | 
  11 | *   |     function toString(int256 value) internal pure returns (string memory str) {
  12 | *   |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
  13 | *   |         str = toString(absValue);
  14 |     | 
  15 | *   |         if (value < 0) {
  16 | *   |             str = string(abi.encodePacked("-", str));
  17 |     |         }
  18 |     |     }
  19 |     | 
  20 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
  21 |     |         /// @solidity memory-safe-assembly
  22 |     |         assembly {
  23 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
  24 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
  25 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
  26 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
  27 |     | 
  28 |     |             // Update the free memory pointer to avoid overriding our string.
  29 | *   |             mstore(0x40, newFreeMemoryPointer)
  30 |     | 
  31 |     |             // Assign str to the end of the zone of newly allocated memory.
  32 | *   |             str := sub(newFreeMemoryPointer, 32)
  33 |     | 
  34 |     |             // Clean the last word of memory it may not be overwritten.
  35 | *   |             mstore(str, 0)
  36 |     | 
  37 |     |             // Cache the end of the memory to calculate the length later.
  38 | *   |             let end := str
  39 |     | 
  40 |     |             // We write the string from rightmost digit to leftmost digit.
  41 |     |             // The following is essentially a do-while loop that also handles the zero case.
  42 |     |             // prettier-ignore
  43 | *   |             for { let temp := value } 1 {} {
  44 |     |                 // Move the pointer 1 byte to the left.
  45 | *   |                 str := sub(str, 1)
  46 |     | 
  47 |     |                 // Write the character to the pointer.
  48 |     |                 // The ASCII index of the '0' character is 48.
  49 | *   |                 mstore8(str, add(48, mod(temp, 10)))
  50 |     | 
  51 |     |                 // Keep dividing temp until zero.
  52 | *   |                 temp := div(temp, 10)
  53 |     | 
  54 |     |                  // prettier-ignore
  55 | *   |                 if iszero(temp) { break }
  56 |     |             }
  57 |     | 
  58 |     |             // Compute and cache the final total length of the string.
  59 | *   |             let length := sub(end, str)
  60 |     | 
  61 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
  62 | *   |             str := sub(str, 32)
  63 |     | 
  64 |     |             // Store the string's length at the start of memory allocated for our string.
  65 | *   |             mstore(str, length)
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 | *   |     function toString(address value) internal pure returns (string memory str) {
  70 |     |         bytes memory s = new bytes(40);
  71 | *   |         for (uint256 i = 0; i < 20; i++) {
  72 |     |             bytes1 b = bytes1(
  73 |     |                 uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))
  74 |     |             );
  75 |     |             bytes1 hi = bytes1(uint8(b) / 16);
  76 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
  77 |     |             s[2 * i] = char(hi);
  78 |     |             s[2 * i + 1] = char(lo);
  79 |     |         }
  80 | *   |         return string(s);
  81 |     |     }
  82 |     | 
  83 | *   |     function char(bytes1 b) internal pure returns (bytes1 c) {
  84 | *   |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
  85 |     |         else return bytes1(uint8(b) + 0x57);
  86 |     |     }
  87 |     | 
  88 |     |     // based on OZ's toHexString
  89 |     |     // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol
  90 |     |     function toHexString(bytes memory value)
  91 |     |         internal
  92 |     |         pure
  93 |     |         returns (string memory)
  94 |     |     {
  95 |     |         bytes memory buffer = new bytes(2 * value.length + 2);
  96 |     |         buffer[0] = "0";
  97 |     |         buffer[1] = "x";
  98 |     |         for (uint256 i = 0; i < value.length; i++) {
  99 |     |             uint8 valueByte = uint8(value[i]);
 100 |     |             buffer[2 * i + 2] = HEX_DIGITS[valueByte >> 4];
 101 |     |             buffer[2 * i + 3] = HEX_DIGITS[valueByte & 0xf];
 102 |     |         }
 103 |     |         return string(buffer);
 104 |     |     }
 105 |     | 
 106 |     |     // https://ethereum.stackexchange.com/a/83577
 107 |     |     function getRevertMsg(bytes memory returnData)
 108 |     |         internal
 109 |     |         pure
 110 |     |         returns (string memory)
 111 |     |     {
 112 |     |         // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code
 113 |     |         if (returnData.length == 4 + 32) {
 114 |     |             // Check that the data starts with the Panic signature
 115 |     |             bytes4 panicSignature = bytes4(keccak256(bytes("Panic(uint256)")));
 116 |     |             for (uint256 i = 0; i < 4; i++) {
 117 |     |                 if (returnData[i] != panicSignature[i])
 118 |     |                     return "Undefined signature";
 119 |     |             }
 120 |     | 
 121 |     |             uint256 panicCode;
 122 |     |             for (uint256 i = 4; i < 36; i++) {
 123 |     |                 panicCode = panicCode << 8;
 124 |     |                 panicCode |= uint8(returnData[i]);
 125 |     |             }
 126 |     | 
 127 |     |             // Now convert the panic code into its string representation
 128 |     |             if (panicCode == 17) {
 129 |     |                 return "Panic(17)";
 130 |     |             }
 131 |     | 
 132 |     |             // Add other panic codes as needed or return a generic "Unknown panic"
 133 |     |             return "Undefined panic code";
 134 |     |         }
 135 |     | 
 136 |     |         // If the returnData length is less than 68, then the transaction failed silently (without a revert message)
 137 |     |         if (returnData.length < 68) return "Transaction reverted silently";
 138 |     | 
 139 |     |         assembly {
 140 |     |             // Slice the sighash.
 141 |     |             returnData := add(returnData, 0x04)
 142 |     |         }
 143 |     |         return abi.decode(returnData, (string)); // All that remains is the revert string
 144 |     |     }
 145 |     | 
 146 |     |     function isRevertReasonEqual(bytes memory returnData, string memory reason)
 147 |     |         internal
 148 |     |         pure
 149 |     |         returns (bool)
 150 |     |     {
 151 |     |         return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==
 152 |     |             keccak256(abi.encodePacked(reason)));
 153 |     |     }
 154 |     | }
 155 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/Fuzzlib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {HelperBase} from "./helpers/HelperBase.sol";
  5 |     | import {HelperAssert} from "./helpers/HelperAssert.sol";
  6 |     | import {HelperClamp} from "./helpers/HelperClamp.sol";
  7 |     | import {HelperLog} from "./helpers/HelperLog.sol";
  8 |     | import {HelperMath} from "./helpers/HelperMath.sol";
  9 |     | import {HelperRandom} from "./helpers/HelperRandom.sol";
 10 |     | 
 11 | *   | contract Fuzzlib is
 12 |     |     HelperBase,
 13 |     |     HelperAssert,
 14 |     |     HelperClamp,
 15 |     |     HelperLog,
 16 |     |     HelperMath,
 17 |     |     HelperRandom
 18 |     | {}
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperAssert.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./HelperBase.sol";
   5 |     | 
   6 |     | import "../FuzzLibString.sol";
   7 |     | 
   8 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   9 |     | abstract contract HelperAssert is HelperBase {
  10 |     |     event AssertFail(string);
  11 |     |     event AssertEqFail(string);
  12 |     |     event AssertNeqFail(string);
  13 |     |     event AssertGteFail(string);
  14 |     |     event AssertGtFail(string);
  15 |     |     event AssertLteFail(string);
  16 |     |     event AssertLtFail(string);
  17 |     | 
  18 | *   |     function t(bool b, string memory reason) public {
  19 | *   |         if (!b) {
  20 |     |             emit AssertFail(reason);
  21 |     |             platform.assertFail();
  22 |     |         }
  23 |     |     }
  24 |     | 
  25 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  26 | *   |     function eq(
  27 |     |         uint256 a,
  28 |     |         uint256 b,
  29 |     |         string memory reason
  30 |     |     ) public {
  31 | *   |         if (a != b) {
  32 |     |             string memory aStr = FuzzLibString.toString(a);
  33 |     |             string memory bStr = FuzzLibString.toString(b);
  34 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  35 |     |             emit AssertEqFail(assertMsg);
  36 |     |             platform.assertFail();
  37 |     |         }
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of eq
  41 | *   |     function eq(
  42 |     |         int256 a,
  43 |     |         int256 b,
  44 |     |         string memory reason
  45 |     |     ) public {
  46 | *   |         if (a != b) {
  47 |     |             string memory aStr = FuzzLibString.toString(a);
  48 |     |             string memory bStr = FuzzLibString.toString(b);
  49 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  50 |     |            emit AssertEqFail(assertMsg);
  51 |     |             platform.assertFail();
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice bool version of eq
  56 |     |     function eq(
  57 |     |         bool a,
  58 |     |         bool b,
  59 |     |         string memory reason
  60 |     |     ) public {
  61 |     |         if (a != b) {
  62 |     |             string memory aStr = a ? "true" : "false";
  63 |     |             string memory bStr = b ? "true" : "false";
  64 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  65 |     |             emit AssertEqFail(assertMsg);
  66 |     |             platform.assertFail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice address version of eq
  71 |     |     function eq(
  72 |     |         address a,
  73 |     |         address b,
  74 |     |         string memory reason
  75 |     |     ) public {
  76 |     |         if (a != b) {
  77 |     |             string memory aStr = FuzzLibString.toString(a);
  78 |     |             string memory bStr = FuzzLibString.toString(b);
  79 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  80 |     |             emit AssertEqFail(assertMsg);
  81 |     |             platform.assertFail();
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice bytes4 version of eq
  86 |     |     function eq(
  87 |     |         bytes4 a,
  88 |     |         bytes4 b,
  89 |     |         string memory reason
  90 |     |     ) public {
  91 |     |         if (a != b) {
  92 |     |             bytes memory aBytes = abi.encodePacked(a);
  93 |     |             bytes memory bBytes = abi.encodePacked(b);
  94 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
  95 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
  96 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  97 |     |             emit AssertEqFail(assertMsg);
  98 |     |             platform.assertFail();
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
 103 |     |     function neq(
 104 |     |         uint256 a,
 105 |     |         uint256 b,
 106 |     |         string memory reason
 107 |     |     ) public {
 108 |     |         if (a == b) {
 109 |     |             string memory aStr = FuzzLibString.toString(a);
 110 |     |             string memory bStr = FuzzLibString.toString(b);
 111 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 112 |     |             emit AssertNeqFail(assertMsg);
 113 |     |             platform.assertFail();
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /// @notice int256 version of neq
 118 |     |     function neq(
 119 |     |         int256 a,
 120 |     |         int256 b,
 121 |     |         string memory reason
 122 |     |     ) public {
 123 |     |         if (a == b) {
 124 |     |             string memory aStr = FuzzLibString.toString(a);
 125 |     |             string memory bStr = FuzzLibString.toString(b);
 126 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 127 |     |             emit AssertNeqFail(assertMsg);
 128 |     |             platform.assertFail();
 129 |     |         }
 130 |     |     }
 131 |     | 
 132 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
 133 | *   |     function gte(
 134 |     |         uint256 a,
 135 |     |         uint256 b,
 136 |     |         string memory reason
 137 |     |     ) public {
 138 | *   |         if (!(a >= b)) {
 139 |     |             string memory aStr = FuzzLibString.toString(a);
 140 |     |             string memory bStr = FuzzLibString.toString(b);
 141 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 142 |     |             emit AssertGteFail(assertMsg);
 143 |     |             platform.assertFail();
 144 |     |         }
 145 |     |     }
 146 |     | 
 147 |     |     /// @notice int256 version of gte
 148 |     |     function gte(
 149 |     |         int256 a,
 150 |     |         int256 b,
 151 |     |         string memory reason
 152 |     |     ) public {
 153 |     |         if (!(a >= b)) {
 154 |     |             string memory aStr = FuzzLibString.toString(a);
 155 |     |             string memory bStr = FuzzLibString.toString(b);
 156 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 157 |     |             emit AssertGteFail(assertMsg);
 158 |     |             platform.assertFail();
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 163 | *   |     function gt(
 164 |     |         uint256 a,
 165 |     |         uint256 b,
 166 |     |         string memory reason
 167 |     |     ) public {
 168 | *   |         if (!(a > b)) {
 169 |     |             string memory aStr = FuzzLibString.toString(a);
 170 |     |             string memory bStr = FuzzLibString.toString(b);
 171 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 172 |     |             emit AssertGtFail(assertMsg);
 173 |     |             platform.assertFail();
 174 |     |         }
 175 |     |     }
 176 |     | 
 177 |     |     /// @notice int256 version of gt
 178 | *   |     function gt(
 179 |     |         int256 a,
 180 |     |         int256 b,
 181 |     |         string memory reason
 182 |     |     ) public {
 183 | *   |         if (!(a > b)) {
 184 |     |             string memory aStr = FuzzLibString.toString(a);
 185 |     |             string memory bStr = FuzzLibString.toString(b);
 186 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 187 |     |             emit AssertGtFail(assertMsg);
 188 |     |             platform.assertFail();
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 193 | *   |     function lte(
 194 |     |         uint256 a,
 195 |     |         uint256 b,
 196 |     |         string memory reason
 197 |     |     ) public {
 198 | *   |         if (!(a <= b)) {
 199 |     |             string memory aStr = FuzzLibString.toString(a);
 200 |     |             string memory bStr = FuzzLibString.toString(b);
 201 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 202 |     |             emit AssertLteFail(assertMsg);
 203 |     |             platform.assertFail();
 204 |     |         }
 205 |     |     }
 206 |     | 
 207 |     |     /// @notice int256 version of lte
 208 |     |     function lte(
 209 |     |         int256 a,
 210 |     |         int256 b,
 211 |     |         string memory reason
 212 |     |     ) public {
 213 |     |         if (!(a <= b)) {
 214 |     |             string memory aStr = FuzzLibString.toString(a);
 215 |     |             string memory bStr = FuzzLibString.toString(b);
 216 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 217 |     |             emit AssertLteFail(assertMsg);
 218 |     |             platform.assertFail();
 219 |     |         }
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 223 | *   |     function lt(
 224 |     |         uint256 a,
 225 |     |         uint256 b,
 226 |     |         string memory reason
 227 |     |     ) public {
 228 | *   |         if (!(a < b)) {
 229 |     |             string memory aStr = FuzzLibString.toString(a);
 230 |     |             string memory bStr = FuzzLibString.toString(b);
 231 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 232 |     |             emit AssertLtFail(assertMsg);
 233 |     |             platform.assertFail();
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     /// @notice int256 version of lt
 238 |     |     function lt(
 239 |     |         int256 a,
 240 |     |         int256 b,
 241 |     |         string memory reason
 242 |     |     ) public {
 243 |     |         if (!(a < b)) {
 244 |     |             string memory aStr = FuzzLibString.toString(a);
 245 |     |             string memory bStr = FuzzLibString.toString(b);
 246 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 247 |     |             emit AssertLtFail(assertMsg);
 248 |     |             platform.assertFail();
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     function assertRevertReasonNotEqual(
 253 |     |         bytes memory returnData,
 254 |     |         string memory reason
 255 |     |     ) public {
 256 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 257 |     |         t(!isEqual, reason);
 258 |     |     }
 259 |     | 
 260 |     |     function assertRevertReasonEqual(
 261 |     |         bytes memory returnData,
 262 |     |         string memory reason
 263 |     |     ) public {
 264 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 265 |     |         t(isEqual, reason);
 266 |     |     }
 267 |     | 
 268 |     |     function assertRevertReasonEqual(
 269 |     |         bytes memory returnData,
 270 |     |         string memory reason1,
 271 |     |         string memory reason2
 272 |     |     ) public {
 273 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 274 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2);
 275 |     |         string memory assertMsg = string(
 276 |     |             abi.encodePacked(reason1, " OR ", reason2)
 277 |     |         );
 278 |     |         t(isEqual, assertMsg);
 279 |     |     }
 280 |     | 
 281 |     |     function assertRevertReasonEqual(
 282 |     |         bytes memory returnData,
 283 |     |         string memory reason1,
 284 |     |         string memory reason2,
 285 |     |         string memory reason3
 286 |     |     ) public {
 287 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 288 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 289 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3);
 290 |     |         string memory assertMsg = string(
 291 |     |             abi.encodePacked(reason1, " OR ", reason2, " OR ", reason3)
 292 |     |         );
 293 |     |         t(isEqual, assertMsg);
 294 |     |     }
 295 |     | 
 296 |     |     function assertRevertReasonEqual(
 297 |     |         bytes memory returnData,
 298 |     |         string memory reason1,
 299 |     |         string memory reason2,
 300 |     |         string memory reason3,
 301 |     |         string memory reason4
 302 |     |     ) public {
 303 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 304 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 305 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3) ||
 306 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason4);
 307 |     |         string memory assertMsg = string(
 308 |     |             abi.encodePacked(
 309 |     |                 reason1,
 310 |     |                 " OR ",
 311 |     |                 reason2,
 312 |     |                 " OR ",
 313 |     |                 reason3,
 314 |     |                 " OR ",
 315 |     |                 reason4
 316 |     |             )
 317 |     |         );
 318 |     |         t(isEqual, assertMsg);
 319 |     |     }
 320 |     | 
 321 |     |     function errAllow(
 322 |     |         bytes4 errorSelector,
 323 |     |         bytes4[] memory allowedErrors,
 324 |     |         string memory message
 325 |     |     ) public {
 326 |     |         bool allowed = false;
 327 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 328 |     |             if (errorSelector == allowedErrors[i]) {
 329 |     |                 allowed = true;
 330 |     |                 break;
 331 |     |             }
 332 |     |         }
 333 |     |         t(allowed, message);
 334 |     |     }
 335 |     | 
 336 |     |     function errsAllow(
 337 |     |         bytes4 errorSelector,
 338 |     |         bytes4[] memory allowedErrors,
 339 |     |         string[] memory messages
 340 |     |     ) public {
 341 |     |         bool allowed = false;
 342 |     |         uint256 passIndex = 0;
 343 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 344 |     |             if (errorSelector == allowedErrors[i]) {
 345 |     |                 allowed = true;
 346 |     |                 passIndex = i;
 347 |     |                 break;
 348 |     |             }
 349 |     |         }
 350 |     |         t(allowed, messages[passIndex]);
 351 |     |     }
 352 |     | 
 353 |     |     function createAssertFailMessage(string memory aStr, string memory bStr, string memory operator, string memory reason)internal pure returns (string memory) {
 354 |     |         return string(abi.encodePacked("Invalid: ", aStr, operator, bStr, ", reason: ", reason));
 355 |     |     }
 356 |     | 
 357 |     | }
 358 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {IPlatform} from "../platform/IPlatform.sol";
  5 |     | 
  6 |     | contract HelperBase {
  7 |     |     IPlatform public platform;
  8 |     | 
  9 |     |     function setPlatform(address _platform) public {
 10 |     |         platform = IPlatform(_platform);
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperClamp.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../FuzzLibString.sol";
   5 |     | import "./HelperAssert.sol";
   6 |     | 
   7 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | abstract contract HelperClamp is HelperAssert {
   9 |     |     event Clamped(string);
  10 |     | 
  11 |     |     /*
  12 |     |      **************************************************************************
  13 |     |      * Clamp functions with logging enabled
  14 |     |      **************************************************************************
  15 |     |      */
  16 |     | 
  17 |     |     /// @notice Clamps value to be between low and high, both inclusive
  18 | *   |     function clamp(
  19 |     |         uint256 value,
  20 |     |         uint256 low,
  21 |     |         uint256 high
  22 | *   |     ) public returns (uint256) {
  23 | *   |         return clamp(value, low, high, true);
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice int256 version of clamp
  27 | *   |     function clamp(
  28 |     |         int256 value,
  29 |     |         int256 low,
  30 |     |         int256 high
  31 | *   |     ) public returns (int256) {
  32 | *   |         return clamp(value, low, high, true);
  33 |     |     }
  34 |     | 
  35 |     |     /// @notice clamps a to be less than b
  36 |     |     function clampLt(uint256 a, uint256 b) public returns (uint256) {
  37 |     |         return clampLt(a, b);
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of clampLt
  41 |     |     function clampLt(int256 a, int256 b) public returns (int256) {
  42 |     |         return clampLt(a, b, true);
  43 |     |     }
  44 |     | 
  45 |     |     /// @notice clamps a to be less than or equal to b
  46 |     |     function clampLte(uint256 a, uint256 b) public returns (uint256) {
  47 |     |         return clampLte(a, b, true);
  48 |     |     }
  49 |     | 
  50 |     |     /// @notice int256 version of clampLte
  51 |     |     function clampLte(int256 a, int256 b) public returns (int256) {
  52 |     |         return clampLte(a, b, true);
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice clamps a to be greater than b
  56 |     |     function clampGt(uint256 a, uint256 b) public returns (uint256) {
  57 |     |         return clampGt(a, b, true);
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice int256 version of clampGt
  61 |     |     function clampGt(int256 a, int256 b) public returns (int256) {
  62 |     |         return clampGt(a, b, true);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice clamps a to be greater than or equal to b
  66 |     |     function clampGte(uint256 a, uint256 b) public returns (uint256) {
  67 |     |         return clampGte(a, b, true);
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice int256 version of clampGte
  71 |     |     function clampGte(int256 a, int256 b) public returns (int256) {
  72 |     |         return clampGte(a, b, true);
  73 |     |     }
  74 |     | 
  75 |     |     /*
  76 |     |      **************************************************************************
  77 |     |      * Clamp functions with optional logging
  78 |     |      **************************************************************************
  79 |     |      */
  80 |     | 
  81 |     |     /// @notice Clamps value to be between low and high, both inclusive
  82 | *   |     function clamp(
  83 |     |         uint256 value,
  84 |     |         uint256 low,
  85 |     |         uint256 high,
  86 |     |         bool enableLogs
  87 | *   |     ) public returns (uint256) {
  88 | *   |         if (value < low || value > high) {
  89 | *   |             uint256 ans = low + (value % (high - low + 1));
  90 | *   |             if (enableLogs) {
  91 | *   |                 string memory valueStr = FuzzLibString.toString(value);
  92 | *   |                 string memory ansStr = FuzzLibString.toString(ans);
  93 | *   |                 bytes memory message = abi.encodePacked(
  94 |     |                     "Clamping value ",
  95 | *   |                     valueStr,
  96 |     |                     " to ",
  97 | *   |                     ansStr
  98 |     |                 );
  99 | *   |                 emit Clamped(string(message));
 100 |     |             }
 101 | *   |             return ans;
 102 |     |         }
 103 | *   |         return value;
 104 |     |     }
 105 |     | 
 106 |     |     /// @notice int256 version of clamp
 107 | *   |     function clamp(
 108 |     |         int256 value,
 109 |     |         int256 low,
 110 |     |         int256 high,
 111 |     |         bool enableLogs
 112 | *   |     ) public returns (int256) {
 113 | *   |         if (value < low || value > high) {
 114 | *   |             int256 range = high - low + 1;
 115 | *   |             int256 clamped = (value - low) % (range);
 116 | *   |             if (clamped < 0) clamped += range;
 117 | *   |             int256 ans = low + clamped;
 118 | *   |             if (enableLogs) {
 119 | *   |                 string memory valueStr = FuzzLibString.toString(value);
 120 | *   |                 string memory ansStr = FuzzLibString.toString(ans);
 121 | *   |                 bytes memory message = abi.encodePacked(
 122 |     |                     "Clamping value ",
 123 | *   |                     valueStr,
 124 |     |                     " to ",
 125 | *   |                     ansStr
 126 |     |                 );
 127 | *   |                 emit Clamped(string(message));
 128 |     |             }
 129 | *   |             return ans;
 130 |     |         }
 131 |     |         return value;
 132 |     |     }
 133 |     | 
 134 |     |     /// @notice clamps a to be less than b
 135 |     |     function clampLt(
 136 |     |         uint256 a,
 137 |     |         uint256 b,
 138 |     |         bool enableLogs
 139 |     |     ) public returns (uint256) {
 140 |     |         if (!(a < b)) {
 141 |     |             neq(
 142 |     |                 b,
 143 |     |                 0,
 144 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 145 |     |             );
 146 |     |             uint256 value = a % b;
 147 |     |             if (enableLogs) {
 148 |     |                 string memory aStr = FuzzLibString.toString(a);
 149 |     |                 string memory valueStr = FuzzLibString.toString(value);
 150 |     |                 bytes memory message = abi.encodePacked(
 151 |     |                     "Clamping value ",
 152 |     |                     aStr,
 153 |     |                     " to ",
 154 |     |                     valueStr
 155 |     |                 );
 156 |     |                 emit Clamped(string(message));
 157 |     |             }
 158 |     |             return value;
 159 |     |         }
 160 |     |         return a;
 161 |     |     }
 162 |     | 
 163 |     |     /// @notice int256 version of clampLt
 164 |     |     function clampLt(
 165 |     |         int256 a,
 166 |     |         int256 b,
 167 |     |         bool enableLogs
 168 |     |     ) public returns (int256) {
 169 |     |         if (!(a < b)) {
 170 |     |             int256 value = b - 1;
 171 |     |             if (enableLogs) {
 172 |     |                 string memory aStr = FuzzLibString.toString(a);
 173 |     |                 string memory valueStr = FuzzLibString.toString(value);
 174 |     |                 bytes memory message = abi.encodePacked(
 175 |     |                     "Clamping value ",
 176 |     |                     aStr,
 177 |     |                     " to ",
 178 |     |                     valueStr
 179 |     |                 );
 180 |     |                 emit Clamped(string(message));
 181 |     |             }
 182 |     |             return value;
 183 |     |         }
 184 |     |         return a;
 185 |     |     }
 186 |     | 
 187 |     |     /// @notice clamps a to be less than or equal to b
 188 |     |     function clampLte(
 189 |     |         uint256 a,
 190 |     |         uint256 b,
 191 |     |         bool enableLogs
 192 |     |     ) public returns (uint256) {
 193 |     |         if (!(a <= b)) {
 194 |     |             uint256 value = a % (b + 1);
 195 |     |             if (enableLogs) {
 196 |     |                 string memory aStr = FuzzLibString.toString(a);
 197 |     |                 string memory valueStr = FuzzLibString.toString(value);
 198 |     |                 bytes memory message = abi.encodePacked(
 199 |     |                     "Clamping value ",
 200 |     |                     aStr,
 201 |     |                     " to ",
 202 |     |                     valueStr
 203 |     |                 );
 204 |     |                 emit Clamped(string(message));
 205 |     |             }
 206 |     |             return value;
 207 |     |         }
 208 |     |         return a;
 209 |     |     }
 210 |     | 
 211 |     |     /// @notice int256 version of clampLte
 212 | *   |     function clampLte(
 213 |     |         int256 a,
 214 |     |         int256 b,
 215 |     |         bool enableLogs
 216 |     |     ) public returns (int256) {
 217 |     |         if (!(a <= b)) {
 218 |     |             int256 value = b;
 219 |     |             if (enableLogs) {
 220 |     |                 string memory aStr = FuzzLibString.toString(a);
 221 |     |                 string memory valueStr = FuzzLibString.toString(value);
 222 |     |                 bytes memory message = abi.encodePacked(
 223 |     |                     "Clamping value ",
 224 |     |                     aStr,
 225 |     |                     " to ",
 226 |     |                     valueStr
 227 |     |                 );
 228 |     |                 emit Clamped(string(message));
 229 |     |             }
 230 |     |             return value;
 231 |     |         }
 232 |     |         return a;
 233 |     |     }
 234 |     | 
 235 |     |     /// @notice clamps a to be greater than b
 236 |     |     function clampGt(
 237 |     |         uint256 a,
 238 |     |         uint256 b,
 239 |     |         bool enableLogs
 240 |     |     ) public returns (uint256) {
 241 |     |         if (!(a > b)) {
 242 |     |             neq(
 243 |     |                 b,
 244 |     |                 type(uint256).max,
 245 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 246 |     |             );
 247 |     |             uint256 value = b + 1;
 248 |     |             if (enableLogs) {
 249 |     |                 string memory aStr = FuzzLibString.toString(a);
 250 |     |                 string memory valueStr = FuzzLibString.toString(value);
 251 |     |                 bytes memory message = abi.encodePacked(
 252 |     |                     "Clamping value ",
 253 |     |                     aStr,
 254 |     |                     " to ",
 255 |     |                     valueStr
 256 |     |                 );
 257 |     |                 emit Clamped(string(message));
 258 |     |             }
 259 |     |             return value;
 260 |     |         } else {
 261 |     |             return a;
 262 |     |         }
 263 |     |     }
 264 |     | 
 265 |     |     /// @notice int256 version of clampGt
 266 |     |     function clampGt(
 267 |     |         int256 a,
 268 |     |         int256 b,
 269 |     |         bool enableLogs
 270 |     |     ) public returns (int256) {
 271 |     |         if (!(a > b)) {
 272 |     |             int256 value = b + 1;
 273 |     |             if (enableLogs) {
 274 |     |                 string memory aStr = FuzzLibString.toString(a);
 275 |     |                 string memory valueStr = FuzzLibString.toString(value);
 276 |     |                 bytes memory message = abi.encodePacked(
 277 |     |                     "Clamping value ",
 278 |     |                     aStr,
 279 |     |                     " to ",
 280 |     |                     valueStr
 281 |     |                 );
 282 |     |                 emit Clamped(string(message));
 283 |     |             }
 284 |     |             return value;
 285 |     |         } else {
 286 |     |             return a;
 287 |     |         }
 288 |     |     }
 289 |     | 
 290 |     |     /// @notice clamps a to be greater than or equal to b
 291 |     |     function clampGte(
 292 |     |         uint256 a,
 293 |     |         uint256 b,
 294 |     |         bool enableLogs
 295 |     |     ) public returns (uint256) {
 296 |     |         if (!(a > b)) {
 297 |     |             uint256 value = b;
 298 |     |             if (enableLogs) {
 299 |     |                 string memory aStr = FuzzLibString.toString(a);
 300 |     |                 string memory valueStr = FuzzLibString.toString(value);
 301 |     |                 bytes memory message = abi.encodePacked(
 302 |     |                     "Clamping value ",
 303 |     |                     aStr,
 304 |     |                     " to ",
 305 |     |                     valueStr
 306 |     |                 );
 307 |     |                 emit Clamped(string(message));
 308 |     |             }
 309 |     |             return value;
 310 |     |         }
 311 |     |         return a;
 312 |     |     }
 313 |     | 
 314 |     |     /// @notice int256 version of clampGte
 315 |     |     function clampGte(
 316 |     |         int256 a,
 317 |     |         int256 b,
 318 |     |         bool enableLogs
 319 |     |     ) public returns (int256) {
 320 |     |         if (!(a > b)) {
 321 |     |             int256 value = b;
 322 |     |             if (enableLogs) {
 323 |     |                 string memory aStr = FuzzLibString.toString(a);
 324 |     |                 string memory valueStr = FuzzLibString.toString(value);
 325 |     |                 bytes memory message = abi.encodePacked(
 326 |     |                     "Clamping value ",
 327 |     |                     aStr,
 328 |     |                     " to ",
 329 |     |                     valueStr
 330 |     |                 );
 331 |     |                 emit Clamped(string(message));
 332 |     |             }
 333 |     |             return value;
 334 |     |         }
 335 |     |         return a;
 336 |     |     }
 337 |     | }
 338 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {LibLog} from "../libraries/LibLog.sol";
  5 |     | 
  6 |     | abstract contract HelperLog {
  7 | *   |     function log(string memory message) public {
  8 | *   |         LibLog.log(message);
  9 |     |     }
 10 |     | 
 11 |     |     function log(string memory message, string memory data) public {
 12 |     |         LibLog.log(message, data);
 13 |     |     }
 14 |     | 
 15 |     |     function log(string memory message, bytes memory data) public {
 16 |     |         LibLog.log(message, data);
 17 |     |     }
 18 |     | 
 19 | *   |     function log(string memory message, uint256 data) public {
 20 | *   |         LibLog.log(message, data);
 21 |     |     }
 22 |     | 
 23 | *   |     function log(string memory message, int256 data) public {
 24 | *   |         LibLog.log(message, data);
 25 |     |     }
 26 |     | 
 27 | *   |     function log(string memory message, address data) public {
 28 | *   |         LibLog.log(message, data);
 29 |     |     }
 30 |     | 
 31 | *   |     function log(string memory message, bool data) public {
 32 | *   |         LibLog.log(message, data);
 33 |     |     }
 34 |     | 
 35 |     |     function log(string memory message, bytes32 data) public {
 36 |     |         LibLog.log(message, data);
 37 |     |     }
 38 |     | 
 39 |     |     function logFail() public {
 40 |     |         LibLog.logFail();
 41 |     |     }
 42 |     | 
 43 |     |     function logFail(string memory message) public {
 44 |     |         LibLog.logFail(message);
 45 |     |     }
 46 |     | 
 47 |     |     function logFail(string memory message, string memory data) public {
 48 |     |         LibLog.logFail(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function logFail(string memory message, bytes memory data) public {
 52 |     |         LibLog.logFail(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail(string memory message, uint256 data) public {
 56 |     |         LibLog.logFail(message, data);
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message, int256 data) public {
 60 |     |         LibLog.logFail(message, data);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, address data) public {
 64 |     |         LibLog.logFail(message, data);
 65 |     |     }
 66 |     | 
 67 | *   |     function logFail(string memory message, bool data) public {
 68 | *   |         LibLog.logFail(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, bytes32 data) public {
 72 |     |         LibLog.log(message, data);
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperMath {
  5 |     |     function min(uint256 a, uint256 b) public pure returns (uint256) {
  6 |     |         return a < b ? a : b;
  7 |     |     }
  8 |     | 
  9 |     |     function max(uint256 a, uint256 b) public pure returns (uint256) {
 10 |     |         return a > b ? a : b;
 11 |     |     }
 12 |     | 
 13 |     |     // Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/utils/math/SignedMath.sol
 14 |     |     function max(int256 a, int256 b) public pure returns (int256) {
 15 |     |         return a > b ? a : b;
 16 |     |     }
 17 |     | 
 18 |     |     // Forked with modifications from https://ethereum.stackexchange.com/a/84391
 19 |     |     function abs(int128 n) public pure returns (int128) {
 20 |     |         return n >= 0 ? n : -n;
 21 |     |     }
 22 |     | 
 23 | *   |     function abs(int256 n) public pure returns (uint256) {
 24 | *   |         return n >= 0 ? uint256(n) : uint256(-n);
 25 |     |     }
 26 |     | 
 27 |     |     function diff(int256 a, int256 b) public pure returns (uint256) {
 28 |     |         return a >= b ? uint256(a - b) : uint256(b - a);
 29 |     |     }
 30 |     | 
 31 |     |     function diff(uint256 a, uint256 b) public pure returns (uint256) {
 32 |     |         return a >= b ? a - b : b - a;
 33 |     |     }
 34 |     | }
 35 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/helpers/HelperRandom.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperRandom {
  5 |     |     /// @notice Shuffle an array using Fisher-Yates algorithm
  6 |     |     /// @dev Based on https://gist.github.com/scammi/602387a22e04c77beb73c0ebc0f0bc18
  7 |     |     function shuffleArray(
  8 |     |         uint256[] memory shuffle,
  9 |     |         uint256 entropy
 10 |     |     ) public pure {
 11 |     |         for (uint256 i = shuffle.length - 1; i > 0; i--) {
 12 |     |             uint256 swapIndex = entropy % (shuffle.length - i);
 13 |     | 
 14 |     |             uint256 currentIndex = shuffle[i];
 15 |     |             uint256 indexToSwap = shuffle[swapIndex];
 16 |     | 
 17 |     |             shuffle[i] = indexToSwap;
 18 |     |             shuffle[swapIndex] = currentIndex;
 19 |     |         }
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/libraries/LibLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | library LibLog {
  5 |     |     event Log(string message);
  6 |     |     event LogString(string message, string data);
  7 |     |     event LogBytes(string message, bytes data);
  8 |     |     event LogUint(string message, uint256 data);
  9 |     |     event LogInt(string message, int256 data);
 10 |     |     event LogAddress(string message, address data);
 11 |     |     event LogBool(string message, bool data);
 12 |     |     event LogBytes32(string message, bytes32 data);
 13 |     | 
 14 |     |     event AssertionFailed();
 15 |     |     event AssertionFailed(string message);
 16 |     |     event AssertionFailed(string message, string data);
 17 |     |     event AssertionFailed(string message, bytes data);
 18 |     |     event AssertionFailed(string message, uint256 data);
 19 |     |     event AssertionFailed(string message, int256 data);
 20 |     |     event AssertionFailed(string message, address data);
 21 |     |     event AssertionFailed(string message, bool data);
 22 |     | 
 23 | *   |     function log(string memory message) internal {
 24 | *   |         emit Log(message);
 25 |     |     }
 26 |     | 
 27 |     |     function log(string memory message, string memory data) internal {
 28 |     |         emit LogString(message, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory message, bytes memory data) internal {
 32 |     |         emit LogBytes(message, data);
 33 |     |     }
 34 |     | 
 35 | *   |     function log(string memory message, uint256 data) internal {
 36 | *   |         emit LogUint(message, data);
 37 |     |     }
 38 |     | 
 39 | *   |     function log(string memory message, int256 data) internal {
 40 | *   |         emit LogInt(message, data);
 41 |     |     }
 42 |     | 
 43 | *   |     function log(string memory message, address data) internal {
 44 | *   |         emit LogAddress(message, data);
 45 |     |     }
 46 |     | 
 47 | *   |     function log(string memory message, bool data) internal {
 48 | *   |         emit LogBool(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function log(string memory message, bytes32 data) internal {
 52 |     |         emit LogBytes32(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail() internal {
 56 |     |         emit AssertionFailed();
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message) internal {
 60 |     |         emit AssertionFailed(message);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, string memory data) internal {
 64 |     |         emit AssertionFailed(message, data);
 65 |     |     }
 66 |     | 
 67 |     |     function logFail(string memory message, bytes memory data) internal {
 68 |     |         emit AssertionFailed(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, uint256 data) internal {
 72 |     |         emit AssertionFailed(message, data);
 73 |     |     }
 74 |     | 
 75 |     |     function logFail(string memory message, int256 data) internal {
 76 |     |         emit AssertionFailed(message, data);
 77 |     |     }
 78 |     | 
 79 |     |     function logFail(string memory message, address data) internal {
 80 |     |         emit AssertionFailed(message, data);
 81 |     |     }
 82 |     | 
 83 | *   |     function logFail(string memory message, bool data) internal {
 84 | *   |         emit AssertionFailed(message, data);
 85 |     |     }
 86 |     | 
 87 |     |     function logFail(string memory message, bytes32 data) internal {
 88 |     |         emit LogBytes32(message, data);
 89 |     |     }
 90 |     | }
 91 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/platform/IPlatform.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | interface IPlatform {
 5 |     |     function assertFail() pure external;
 6 |     | }
 7 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/lib/fuzzlib/src/platform/PlatformCrytic.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: MIT
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {IPlatform} from "./IPlatform.sol";
  6 |     | 
  7 |     | contract PlatformCrytic is IPlatform {
  8 |     |     function assertFail() pure public override{
  9 |     |         assert(false);
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 | *   |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 | *   |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 | *   |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 |     |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 |     |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 | *   |     function _burn(address account, uint256 amount) internal virtual {
 278 | *   |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 | *   |         uint256 accountBalance = _balances[account];
 283 | *   |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 | *   |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 | *   |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 | *   |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 |     |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 | *   |         if (currentAllowance != type(uint256).max) {
 327 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 | *   |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/AccessError.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Library for access related errors.
  6 |     |  */
  7 |     | library AccessError {
  8 |     |     /**
  9 |     |      * @dev Thrown when an address tries to perform an unauthorized action.
 10 |     |      * @param addr The address that attempts the action.
 11 |     |      */
 12 |     |     error Unauthorized(address addr);
 13 |     | }
 14 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/AddressError.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Library for address related errors.
  6 |     |  */
  7 |     | library AddressError {
  8 |     |     /**
  9 |     |      * @dev Thrown when a zero address was passed as a function parameter (0x0000000000000000000000000000000000000000).
 10 |     |      */
 11 |     |     error ZeroAddress();
 12 |     | 
 13 |     |     /**
 14 |     |      * @dev Thrown when an address representing a contract is expected, but no code is found at the address.
 15 |     |      * @param contr The address that was expected to be a contract.
 16 |     |      */
 17 |     |     error NotAContract(address contr);
 18 |     | }
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/ChangeError.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Library for change related errors.
  6 |     |  */
  7 |     | library ChangeError {
  8 |     |     /**
  9 |     |      * @dev Thrown when a change is expected but none is detected.
 10 |     |      */
 11 |     |     error NoChange();
 12 |     | }
 13 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/InitError.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Library for initialization related errors.
  6 |     |  */
  7 |     | library InitError {
  8 |     |     /**
  9 |     |      * @dev Thrown when attempting to initialize a contract that is already initialized.
 10 |     |      */
 11 |     |     error AlreadyInitialized();
 12 |     | 
 13 |     |     /**
 14 |     |      * @dev Thrown when attempting to interact with a contract that has not been initialized yet.
 15 |     |      */
 16 |     |     error NotInitialized();
 17 |     | }
 18 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/errors/ParameterError.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Library for errors related with expected function parameters.
  6 |     |  */
  7 |     | library ParameterError {
  8 |     |     /**
  9 |     |      * @dev Thrown when an invalid parameter is used in a function.
 10 |     |      * @param parameter The name of the parameter.
 11 |     |      * @param reason The reason why the received parameter is invalid.
 12 |     |      */
 13 |     |     error InvalidParameter(string parameter, string reason);
 14 |     | }
 15 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/initializable/InitializableMixin.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../errors/InitError.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Mixin for contracts that require initialization.
  8 |     |  */
  9 |     | abstract contract InitializableMixin {
 10 |     |     /**
 11 |     |      * @dev Reverts if contract is not initialized.
 12 |     |      */
 13 |     |     modifier onlyIfInitialized() {
 14 |     |         if (!_isInitialized()) {
 15 |     |             revert InitError.NotInitialized();
 16 |     |         }
 17 |     | 
 18 |     |         _;
 19 |     |     }
 20 |     | 
 21 |     |     /**
 22 |     |      * @dev Reverts if contract is already initialized.
 23 |     |      */
 24 |     |     modifier onlyIfNotInitialized() {
 25 |     |         if (_isInitialized()) {
 26 |     |             revert InitError.AlreadyInitialized();
 27 |     |         }
 28 |     | 
 29 |     |         _;
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Override this function to determine if the contract is initialized.
 34 |     |      * @return True if initialized, false otherwise.
 35 |     |      */
 36 |     |     function _isInitialized() internal view virtual returns (bool);
 37 |     | }
 38 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IERC165.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title ERC165 interface for determining if a contract supports a given interface.
  6 |     |  */
  7 |     | interface IERC165 {
  8 |     |     /**
  9 |     |      * @notice Determines if the contract in question supports the specified interface.
 10 |     |      * @param interfaceID XOR of all selectors in the contract.
 11 |     |      * @return True if the contract supports the specified interface.
 12 |     |      */
 13 |     |     function supportsInterface(bytes4 interfaceID) external view returns (bool);
 14 |     | }
 15 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IERC20.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title ERC20 token implementation.
   6 |     |  */
   7 |     | interface IERC20 {
   8 |     |     /**
   9 |     |      * @notice Emitted when tokens have been transferred.
  10 |     |      * @param from The address that originally owned the tokens.
  11 |     |      * @param to The address that received the tokens.
  12 |     |      * @param amount The number of tokens that were transferred.
  13 |     |      */
  14 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  15 |     | 
  16 |     |     /**
  17 |     |      * @notice Emitted when a user has provided allowance to another user for transferring tokens on its behalf.
  18 |     |      * @param owner The address that is providing the allowance.
  19 |     |      * @param spender The address that received the allowance.
  20 |     |      * @param amount The number of tokens that were added to `spender`'s allowance.
  21 |     |      */
  22 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  23 |     | 
  24 |     |     /**
  25 |     |      * @notice Thrown when the address interacting with the contract does not have sufficient allowance to transfer tokens from another contract.
  26 |     |      * @param required The necessary allowance.
  27 |     |      * @param existing The current allowance.
  28 |     |      */
  29 |     |     error InsufficientAllowance(uint256 required, uint256 existing);
  30 |     | 
  31 |     |     /**
  32 |     |      * @notice Thrown when the address interacting with the contract does not have sufficient tokens.
  33 |     |      * @param required The necessary balance.
  34 |     |      * @param existing The current balance.
  35 |     |      */
  36 |     |     error InsufficientBalance(uint256 required, uint256 existing);
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Retrieves the name of the token, e.g. "Synthetix Network Token".
  40 |     |      * @return A string with the name of the token.
  41 |     |      */
  42 |     |     function name() external view returns (string memory);
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Retrieves the symbol of the token, e.g. "SNX".
  46 |     |      * @return A string with the symbol of the token.
  47 |     |      */
  48 |     |     function symbol() external view returns (string memory);
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Retrieves the number of decimals used by the token. The default is 18.
  52 |     |      * @return The number of decimals.
  53 |     |      */
  54 |     |     function decimals() external view returns (uint8);
  55 |     | 
  56 |     |     /**
  57 |     |      * @notice Returns the total number of tokens in circulation (minted - burnt).
  58 |     |      * @return The total number of tokens.
  59 |     |      */
  60 |     |     function totalSupply() external view returns (uint256);
  61 |     | 
  62 |     |     /**
  63 |     |      * @notice Returns the balance of a user.
  64 |     |      * @param owner The address whose balance is being retrieved.
  65 |     |      * @return The number of tokens owned by the user.
  66 |     |      */
  67 |     |     function balanceOf(address owner) external view returns (uint256);
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Returns how many tokens a user has allowed another user to transfer on its behalf.
  71 |     |      * @param owner The user who has given the allowance.
  72 |     |      * @param spender The user who was given the allowance.
  73 |     |      * @return The amount of tokens `spender` can transfer on `owner`'s behalf.
  74 |     |      */
  75 |     |     function allowance(address owner, address spender) external view returns (uint256);
  76 |     | 
  77 |     |     /**
  78 |     |      * @notice Transfer tokens from one address to another.
  79 |     |      * @param to The address that will receive the tokens.
  80 |     |      * @param amount The amount of tokens to be transferred.
  81 |     |      * @return A boolean which is true if the operation succeeded.
  82 |     |      */
  83 |     |     function transfer(address to, uint256 amount) external returns (bool);
  84 |     | 
  85 |     |     /**
  86 |     |      * @notice Allows users to provide allowance to other users so that they can transfer tokens on their behalf.
  87 |     |      * @param spender The address that is receiving the allowance.
  88 |     |      * @param amount The amount of tokens that are being added to the allowance.
  89 |     |      * @return A boolean which is true if the operation succeeded.
  90 |     |      */
  91 |     |     function approve(address spender, uint256 amount) external returns (bool);
  92 |     | 
  93 |     |     /**
  94 |     |      * @notice Atomically increases the allowance granted to `spender` by the caller.
  95 |     |      *
  96 |     |      * This is an alternative to {approve} that can be used as a mitigation for
  97 |     |      * problems described in {IERC20-approve}.
  98 |     |      *
  99 |     |      * Emits an {Approval} event indicating the updated allowance.
 100 |     |      *
 101 |     |      * Requirements:
 102 |     |      *
 103 |     |      * - `spender` cannot be the zero address.
 104 |     |      */
 105 |     |     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
 106 |     | 
 107 |     |     /**
 108 |     |      * @notice Atomically decreases the allowance granted to `spender` by the caller.
 109 |     |      *
 110 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 111 |     |      * problems described in {IERC20-approve}.
 112 |     |      *
 113 |     |      * Emits an {Approval} event indicating the updated allowance.
 114 |     |      *
 115 |     |      * Requirements:
 116 |     |      *
 117 |     |      * - `spender` cannot be the zero address.
 118 |     |      * - `spender` must have allowance for the caller of at least
 119 |     |      * `subtractedValue`.
 120 |     |      */
 121 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Allows a user who has been given allowance to transfer tokens on another user's behalf.
 125 |     |      * @param from The address that owns the tokens that are being transferred.
 126 |     |      * @param to The address that will receive the tokens.
 127 |     |      * @param amount The number of tokens to transfer.
 128 |     |      * @return A boolean which is true if the operation succeeded.
 129 |     |      */
 130 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 131 |     | }
 132 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IOwnable.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Contract for facilitating ownership by a single address.
  6 |     |  */
  7 |     | interface IOwnable {
  8 |     |     /**
  9 |     |      * @notice Thrown when an address tries to accept ownership but has not been nominated.
 10 |     |      * @param addr The address that is trying to accept ownership.
 11 |     |      */
 12 |     |     error NotNominated(address addr);
 13 |     | 
 14 |     |     /**
 15 |     |      * @notice Emitted when an address has been nominated.
 16 |     |      * @param newOwner The address that has been nominated.
 17 |     |      */
 18 |     |     event OwnerNominated(address newOwner);
 19 |     | 
 20 |     |     /**
 21 |     |      * @notice Emitted when the owner of the contract has changed.
 22 |     |      * @param oldOwner The previous owner of the contract.
 23 |     |      * @param newOwner The new owner of the contract.
 24 |     |      */
 25 |     |     event OwnerChanged(address oldOwner, address newOwner);
 26 |     | 
 27 |     |     /**
 28 |     |      * @notice Allows a nominated address to accept ownership of the contract.
 29 |     |      * @dev Reverts if the caller is not nominated.
 30 |     |      */
 31 |     |     function acceptOwnership() external;
 32 |     | 
 33 |     |     /**
 34 |     |      * @notice Allows the current owner to nominate a new owner.
 35 |     |      * @dev The nominated owner will have to call `acceptOwnership` in a separate transaction in order to finalize the action and become the new contract owner.
 36 |     |      * @param newNominatedOwner The address that is to become nominated.
 37 |     |      */
 38 |     |     function nominateNewOwner(address newNominatedOwner) external;
 39 |     | 
 40 |     |     /**
 41 |     |      * @notice Allows a nominated owner to reject the nomination.
 42 |     |      */
 43 |     |     function renounceNomination() external;
 44 |     | 
 45 |     |     /**
 46 |     |      * @notice Returns the current owner of the contract.
 47 |     |      */
 48 |     |     function owner() external view returns (address);
 49 |     | 
 50 |     |     /**
 51 |     |      * @notice Returns the current nominated owner of the contract.
 52 |     |      * @dev Only one address can be nominated at a time.
 53 |     |      */
 54 |     |     function nominatedOwner() external view returns (address);
 55 |     | }
 56 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/interfaces/IUUPSImplementation.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Contract to be used as the implementation of a Universal Upgradeable Proxy Standard (UUPS) proxy.
  6 |     |  *
  7 |     |  * Important: A UUPS proxy requires its upgradeability functions to be in the implementation as opposed to the proxy. This means that if the proxy is upgraded to an implementation that does not support this interface, it will no longer be upgradeable.
  8 |     |  */
  9 |     | interface IUUPSImplementation {
 10 |     |     /**
 11 |     |      * @notice Thrown when an incoming implementation will not be able to receive future upgrades.
 12 |     |      */
 13 |     |     error ImplementationIsSterile(address implementation);
 14 |     | 
 15 |     |     /**
 16 |     |      * @notice Thrown intentionally when testing future upgradeability of an implementation.
 17 |     |      */
 18 |     |     error UpgradeSimulationFailed();
 19 |     | 
 20 |     |     /**
 21 |     |      * @notice Emitted when the implementation of the proxy has been upgraded.
 22 |     |      * @param self The address of the proxy whose implementation was upgraded.
 23 |     |      * @param implementation The address of the proxy's new implementation.
 24 |     |      */
 25 |     |     event Upgraded(address indexed self, address implementation);
 26 |     | 
 27 |     |     /**
 28 |     |      * @notice Allows the proxy to be upgraded to a new implementation.
 29 |     |      * @param newImplementation The address of the proxy's new implementation.
 30 |     |      * @dev Will revert if `newImplementation` is not upgradeable.
 31 |     |      * @dev The implementation of this function needs to be protected by some sort of access control such as `onlyOwner`.
 32 |     |      */
 33 |     |     function upgradeTo(address newImplementation) external;
 34 |     | 
 35 |     |     /**
 36 |     |      * @notice Function used to determine if a new implementation will be able to receive future upgrades in `upgradeTo`.
 37 |     |      * @param newImplementation The address of the new implementation being tested for future upgradeability.
 38 |     |      * @dev This function will always revert, but will revert with different error messages. The function `upgradeTo` uses this error to determine the future upgradeability of the implementation in question.
 39 |     |      */
 40 |     |     function simulateUpgradeTo(address newImplementation) external;
 41 |     | 
 42 |     |     /**
 43 |     |      * @notice Retrieves the current implementation of the proxy.
 44 |     |      * @return The address of the current implementation.
 45 |     |      */
 46 |     |     function getImplementation() external view returns (address);
 47 |     | }
 48 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/ownership/Ownable.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "./OwnableStorage.sol";
  5 |     | import "../interfaces/IOwnable.sol";
  6 |     | import "../errors/AddressError.sol";
  7 |     | import "../errors/ChangeError.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title Contract for facilitating ownership by a single address.
 11 |     |  * See IOwnable.
 12 |     |  */
 13 |     | contract Ownable is IOwnable {
 14 |     |     constructor(address initialOwner) {
 15 |     |         OwnableStorage.load().owner = initialOwner;
 16 |     |     }
 17 |     | 
 18 |     |     /**
 19 |     |      * @inheritdoc IOwnable
 20 |     |      */
 21 |     |     function acceptOwnership() public override {
 22 |     |         OwnableStorage.Data storage store = OwnableStorage.load();
 23 |     | 
 24 |     |         address currentNominatedOwner = store.nominatedOwner;
 25 |     |         if (msg.sender != currentNominatedOwner) {
 26 |     |             revert NotNominated(msg.sender);
 27 |     |         }
 28 |     | 
 29 |     |         emit OwnerChanged(store.owner, currentNominatedOwner);
 30 |     |         store.owner = currentNominatedOwner;
 31 |     | 
 32 |     |         store.nominatedOwner = address(0);
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @inheritdoc IOwnable
 37 |     |      */
 38 |     |     function nominateNewOwner(address newNominatedOwner) public override onlyOwner {
 39 |     |         OwnableStorage.Data storage store = OwnableStorage.load();
 40 |     | 
 41 |     |         if (newNominatedOwner == address(0)) {
 42 |     |             revert AddressError.ZeroAddress();
 43 |     |         }
 44 |     | 
 45 |     |         if (newNominatedOwner == store.nominatedOwner) {
 46 |     |             revert ChangeError.NoChange();
 47 |     |         }
 48 |     | 
 49 |     |         store.nominatedOwner = newNominatedOwner;
 50 |     |         emit OwnerNominated(newNominatedOwner);
 51 |     |     }
 52 |     | 
 53 |     |     /**
 54 |     |      * @inheritdoc IOwnable
 55 |     |      */
 56 |     |     function renounceNomination() external override {
 57 |     |         OwnableStorage.Data storage store = OwnableStorage.load();
 58 |     | 
 59 |     |         if (store.nominatedOwner != msg.sender) {
 60 |     |             revert NotNominated(msg.sender);
 61 |     |         }
 62 |     | 
 63 |     |         store.nominatedOwner = address(0);
 64 |     |     }
 65 |     | 
 66 |     |     /**
 67 |     |      * @inheritdoc IOwnable
 68 |     |      */
 69 |     |     function owner() external view override returns (address) {
 70 |     |         return OwnableStorage.load().owner;
 71 |     |     }
 72 |     | 
 73 |     |     /**
 74 |     |      * @inheritdoc IOwnable
 75 |     |      */
 76 |     |     function nominatedOwner() external view override returns (address) {
 77 |     |         return OwnableStorage.load().nominatedOwner;
 78 |     |     }
 79 |     | 
 80 |     |     /**
 81 |     |      * @dev Reverts if the caller is not the owner.
 82 |     |      */
 83 |     |     modifier onlyOwner() {
 84 |     |         OwnableStorage.onlyOwner();
 85 |     | 
 86 |     |         _;
 87 |     |     }
 88 |     | }
 89 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../errors/AccessError.sol";
  5 |     | 
  6 |     | library OwnableStorage {
  7 |     |     bytes32 private constant _SLOT_OWNABLE_STORAGE =
  8 | *   |         keccak256(abi.encode("io.synthetix.core-contracts.Ownable"));
  9 |     | 
 10 |     |     struct Data {
 11 |     |         address owner;
 12 |     |         address nominatedOwner;
 13 |     |     }
 14 |     | 
 15 | *   |     function load() internal pure returns (Data storage store) {
 16 |     |         bytes32 s = _SLOT_OWNABLE_STORAGE;
 17 |     |         assembly {
 18 |     |             store.slot := s
 19 |     |         }
 20 |     |     }
 21 |     | 
 22 |     |     function onlyOwner() internal view {
 23 |     |         if (msg.sender != getOwner()) {
 24 |     |             revert AccessError.Unauthorized(msg.sender);
 25 |     |         }
 26 |     |     }
 27 |     | 
 28 |     |     function getOwner() internal view returns (address) {
 29 |     |         return OwnableStorage.load().owner;
 30 |     |     }
 31 |     | }
 32 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/AbstractProxy.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | abstract contract AbstractProxy {
  5 |     |     fallback() external payable {
  6 | *   |         _forward();
  7 |     |     }
  8 |     | 
  9 |     |     receive() external payable {
 10 |     |         _forward();
 11 |     |     }
 12 |     | 
 13 | *   |     function _forward() internal {
 14 | *   |         address implementation = _getImplementation();
 15 |     | 
 16 |     |         // solhint-disable-next-line no-inline-assembly
 17 |     |         assembly {
 18 | *   |             calldatacopy(0, 0, calldatasize())
 19 |     | 
 20 | *   |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 21 |     | 
 22 | *   |             returndatacopy(0, 0, returndatasize())
 23 |     | 
 24 | *   |             switch result
 25 | *   |             case 0 {
 26 | *   |                 revert(0, returndatasize())
 27 |     |             }
 28 |     |             default {
 29 | *   |                 return(0, returndatasize())
 30 |     |             }
 31 |     |         }
 32 |     |     }
 33 |     | 
 34 |     |     function _getImplementation() internal view virtual returns (address);
 35 |     | }
 36 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/ProxyStorage.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | contract ProxyStorage {
  5 |     |     bytes32 private constant _SLOT_PROXY_STORAGE =
  6 | *   |         keccak256(abi.encode("io.synthetix.core-contracts.Proxy"));
  7 |     | 
  8 |     |     struct ProxyStore {
  9 |     |         address implementation;
 10 |     |         bool simulatingUpgrade;
 11 |     |     }
 12 |     | 
 13 | *   |     function _proxyStore() internal pure returns (ProxyStore storage store) {
 14 | *   |         bytes32 s = _SLOT_PROXY_STORAGE;
 15 |     |         assembly {
 16 |     |             store.slot := s
 17 |     |         }
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../interfaces/IUUPSImplementation.sol";
  5 |     | import "../errors/AddressError.sol";
  6 |     | import "../errors/ChangeError.sol";
  7 |     | import "../utils/AddressUtil.sol";
  8 |     | import "./ProxyStorage.sol";
  9 |     | 
 10 |     | abstract contract UUPSImplementation is IUUPSImplementation, ProxyStorage {
 11 |     |     /**
 12 |     |      * @inheritdoc IUUPSImplementation
 13 |     |      */
 14 |     |     function simulateUpgradeTo(address newImplementation) public override {
 15 |     |         ProxyStore storage store = _proxyStore();
 16 |     | 
 17 |     |         store.simulatingUpgrade = true;
 18 |     | 
 19 |     |         address currentImplementation = store.implementation;
 20 |     |         store.implementation = newImplementation;
 21 |     | 
 22 |     |         (bool rollbackSuccessful, ) = newImplementation.delegatecall(
 23 |     |             abi.encodeCall(this.upgradeTo, (currentImplementation))
 24 |     |         );
 25 |     | 
 26 |     |         if (!rollbackSuccessful || _proxyStore().implementation != currentImplementation) {
 27 |     |             revert UpgradeSimulationFailed();
 28 |     |         }
 29 |     | 
 30 |     |         store.simulatingUpgrade = false;
 31 |     | 
 32 |     |         // solhint-disable-next-line reason-string
 33 |     |         revert();
 34 |     |     }
 35 |     | 
 36 |     |     /**
 37 |     |      * @inheritdoc IUUPSImplementation
 38 |     |      */
 39 |     |     function getImplementation() external view override returns (address) {
 40 |     |         return _proxyStore().implementation;
 41 |     |     }
 42 |     | 
 43 |     |     function _upgradeTo(address newImplementation) internal virtual {
 44 |     |         if (newImplementation == address(0)) {
 45 |     |             revert AddressError.ZeroAddress();
 46 |     |         }
 47 |     | 
 48 |     |         if (!AddressUtil.isContract(newImplementation)) {
 49 |     |             revert AddressError.NotAContract(newImplementation);
 50 |     |         }
 51 |     | 
 52 |     |         ProxyStore storage store = _proxyStore();
 53 |     | 
 54 |     |         if (newImplementation == store.implementation) {
 55 |     |             revert ChangeError.NoChange();
 56 |     |         }
 57 |     | 
 58 |     |         if (!store.simulatingUpgrade && _implementationIsSterile(newImplementation)) {
 59 |     |             revert ImplementationIsSterile(newImplementation);
 60 |     |         }
 61 |     | 
 62 |     |         store.implementation = newImplementation;
 63 |     | 
 64 |     |         emit Upgraded(address(this), newImplementation);
 65 |     |     }
 66 |     | 
 67 |     |     function _implementationIsSterile(
 68 |     |         address candidateImplementation
 69 |     |     ) internal virtual returns (bool) {
 70 |     |         (bool simulationReverted, bytes memory simulationResponse) = address(this).delegatecall(
 71 |     |             abi.encodeCall(this.simulateUpgradeTo, (candidateImplementation))
 72 |     |         );
 73 |     | 
 74 |     |         return
 75 |     |             !simulationReverted &&
 76 |     |             keccak256(abi.encodePacked(simulationResponse)) ==
 77 |     |             keccak256(abi.encodePacked(UpgradeSimulationFailed.selector));
 78 |     |     }
 79 |     | }
 80 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/UUPSProxy.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "./AbstractProxy.sol";
  5 |     | import "./ProxyStorage.sol";
  6 |     | import "../errors/AddressError.sol";
  7 |     | import "../utils/AddressUtil.sol";
  8 |     | 
  9 |     | contract UUPSProxy is AbstractProxy, ProxyStorage {
 10 |     |     constructor(address firstImplementation) {
 11 |     |         if (firstImplementation == address(0)) {
 12 |     |             revert AddressError.ZeroAddress();
 13 |     |         }
 14 |     | 
 15 |     |         if (!AddressUtil.isContract(firstImplementation)) {
 16 |     |             revert AddressError.NotAContract(firstImplementation);
 17 |     |         }
 18 |     | 
 19 |     |         _proxyStore().implementation = firstImplementation;
 20 |     |     }
 21 |     | 
 22 | *   |     function _getImplementation() internal view virtual override returns (address) {
 23 | *   |         return _proxyStore().implementation;
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/proxy/UUPSProxyWithOwner.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {UUPSProxy} from "./UUPSProxy.sol";
  5 |     | import {OwnableStorage} from "../ownership/OwnableStorage.sol";
  6 |     | 
  7 | *   | contract UUPSProxyWithOwner is UUPSProxy {
  8 |     |     // solhint-disable-next-line no-empty-blocks
  9 |     |     constructor(address firstImplementation, address initialOwner) UUPSProxy(firstImplementation) {
 10 |     |         OwnableStorage.load().owner = initialOwner;
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/token/ERC20Helper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../interfaces/IERC20.sol";
  5 |     | 
  6 |     | library ERC20Helper {
  7 |     |     error FailedTransfer(address from, address to, uint256 value);
  8 |     | 
  9 |     |     function safeTransfer(address token, address to, uint256 value) internal {
 10 |     |         (bool success, bytes memory data) = token.call(
 11 |     |             abi.encodeWithSelector(IERC20.transfer.selector, to, value)
 12 |     |         );
 13 |     |         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {
 14 |     |             revert FailedTransfer(address(this), to, value);
 15 |     |         }
 16 |     |     }
 17 |     | 
 18 |     |     function safeTransferFrom(address token, address from, address to, uint256 value) internal {
 19 |     |         (bool success, bytes memory data) = token.call(
 20 |     |             abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)
 21 |     |         );
 22 |     |         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {
 23 |     |             revert FailedTransfer(from, to, value);
 24 |     |         }
 25 |     |     }
 26 |     | }
 27 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/AddressUtil.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | library AddressUtil {
  5 |     |     function isContract(address account) internal view returns (bool) {
  6 |     |         uint256 size;
  7 |     | 
  8 |     |         assembly {
  9 |     |             size := extcodesize(account)
 10 |     |         }
 11 |     | 
 12 |     |         return size > 0;
 13 |     |     }
 14 |     | }
 15 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/DecimalMath.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "./SafeCast.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title Utility library used to represent "decimals" (fixed point numbers) with integers, with two different levels of precision.
   8 |     |  *
   9 |     |  * They are represented by N * UNIT, where UNIT is the number of decimals of precision in the representation.
  10 |     |  *
  11 |     |  * Examples:
  12 |     |  * 1) Given UNIT = 100
  13 |     |  * then if A = 50, A represents the decimal 0.50
  14 |     |  * 2) Given UNIT = 1000000000000000000
  15 |     |  * then if A = 500000000000000000, A represents the decimal 0.500000000000000000
  16 |     |  *
  17 |     |  * Note: An accompanying naming convention of the postfix "D<Precision>" is helpful with this utility. I.e. if a variable "myValue" represents a low resolution decimal, it should be named "myValueD18", and if it was a high resolution decimal "myValueD27". While scaling, intermediate precision decimals like "myValue45" could arise. Non-decimals should have no postfix, i.e. just "myValue".
  18 |     |  *
  19 |     |  * Important: Multiplication and division operations are currently not supported for high precision decimals. Using these operations on them will yield incorrect results and fail silently.
  20 |     |  */
  21 |     | library DecimalMath {
  22 |     |     using SafeCastU256 for uint256;
  23 |     |     using SafeCastI256 for int256;
  24 |     | 
  25 |     |     // solhint-disable numcast/safe-cast
  26 |     | 
  27 |     |     // Numbers representing 1.0 (low precision).
  28 | *   |     uint256 public constant UNIT = 1e18;
  29 |     |     int256 public constant UNIT_INT = int256(UNIT);
  30 |     |     uint128 public constant UNIT_UINT128 = uint128(UNIT);
  31 |     |     int128 public constant UNIT_INT128 = int128(UNIT_INT);
  32 |     | 
  33 |     |     // Numbers representing 1.0 (high precision).
  34 |     |     uint256 public constant UNIT_PRECISE = 1e27;
  35 |     |     int256 public constant UNIT_PRECISE_INT = int256(UNIT_PRECISE);
  36 |     |     int128 public constant UNIT_PRECISE_INT128 = int128(UNIT_PRECISE_INT);
  37 |     | 
  38 |     |     // Precision scaling, (used to scale down/up from one precision to the other).
  39 |     |     uint256 public constant PRECISION_FACTOR = 9; // 27 - 18 = 9 :)
  40 |     | 
  41 |     |     // solhint-enable numcast/safe-cast
  42 |     | 
  43 |     |     // -----------------
  44 |     |     // uint256
  45 |     |     // -----------------
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Multiplies two low precision decimals.
  49 |     |      *
  50 |     |      * Since the two numbers are assumed to be fixed point numbers,
  51 |     |      * (x * UNIT) * (y * UNIT) = x * y * UNIT ^ 2,
  52 |     |      * the result is divided by UNIT to remove double scaling.
  53 |     |      */
  54 | *   |     function mulDecimal(uint256 x, uint256 y) internal pure returns (uint256 z) {
  55 | *   |         return (x * y) / UNIT;
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Divides two low precision decimals.
  60 |     |      *
  61 |     |      * Since the two numbers are assumed to be fixed point numbers,
  62 |     |      * (x * UNIT) / (y * UNIT) = x / y (Decimal representation is lost),
  63 |     |      * x is first scaled up to end up with a decimal representation.
  64 |     |      */
  65 | *   |     function divDecimal(uint256 x, uint256 y) internal pure returns (uint256 z) {
  66 | *   |         return (x * UNIT) / y;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Scales up a value.
  71 |     |      *
  72 |     |      * E.g. if value is not a decimal, a scale up by 18 makes it a low precision decimal.
  73 |     |      * If value is a low precision decimal, a scale up by 9 makes it a high precision decimal.
  74 |     |      */
  75 |     |     function upscale(uint256 x, uint256 factor) internal pure returns (uint256) {
  76 |     |         return x * 10 ** factor;
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Scales down a value.
  81 |     |      *
  82 |     |      * E.g. if value is a high precision decimal, a scale down by 9 makes it a low precision decimal.
  83 |     |      * If value is a low precision decimal, a scale down by 9 makes it a regular integer.
  84 |     |      *
  85 |     |      * Scaling down a regular integer would not make sense.
  86 |     |      */
  87 |     |     function downscale(uint256 x, uint256 factor) internal pure returns (uint256) {
  88 |     |         return x / 10 ** factor;
  89 |     |     }
  90 |     | 
  91 |     |     // -----------------
  92 |     |     // uint128
  93 |     |     // -----------------
  94 |     | 
  95 |     |     // Note: Overloading doesn't seem to work for similar types, i.e. int256 and int128, uint256 and uint128, etc, so explicitly naming the functions differently here.
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev See mulDecimal for uint256.
  99 |     |      */
 100 | *   |     function mulDecimalUint128(uint128 x, uint128 y) internal pure returns (uint128) {
 101 | *   |         return (x * y) / UNIT_UINT128;
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev See divDecimal for uint256.
 106 |     |      */
 107 |     |     function divDecimalUint128(uint128 x, uint128 y) internal pure returns (uint128) {
 108 |     |         return (x * UNIT_UINT128) / y;
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev See upscale for uint256.
 113 |     |      */
 114 |     |     function upscaleUint128(uint128 x, uint256 factor) internal pure returns (uint128) {
 115 |     |         return x * (10 ** factor).to128();
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev See downscale for uint256.
 120 |     |      */
 121 |     |     function downscaleUint128(uint128 x, uint256 factor) internal pure returns (uint128) {
 122 |     |         return x / (10 ** factor).to128();
 123 |     |     }
 124 |     | 
 125 |     |     // -----------------
 126 |     |     // int256
 127 |     |     // -----------------
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev See mulDecimal for uint256.
 131 |     |      */
 132 | *   |     function mulDecimal(int256 x, int256 y) internal pure returns (int256) {
 133 | *   |         return (x * y) / UNIT_INT;
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @dev See divDecimal for uint256.
 138 |     |      */
 139 | *   |     function divDecimal(int256 x, int256 y) internal pure returns (int256) {
 140 | *   |         return (x * UNIT_INT) / y;
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev See upscale for uint256.
 145 |     |      */
 146 |     |     function upscale(int256 x, uint256 factor) internal pure returns (int256) {
 147 |     |         return x * (10 ** factor).toInt();
 148 |     |     }
 149 |     | 
 150 |     |     /**
 151 |     |      * @dev See downscale for uint256.
 152 |     |      */
 153 |     |     function downscale(int256 x, uint256 factor) internal pure returns (int256) {
 154 |     |         return x / (10 ** factor).toInt();
 155 |     |     }
 156 |     | 
 157 |     |     // -----------------
 158 |     |     // int128
 159 |     |     // -----------------
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev See mulDecimal for uint256.
 163 |     |      */
 164 |     |     function mulDecimalInt128(int128 x, int128 y) internal pure returns (int128) {
 165 |     |         return (x * y) / UNIT_INT128;
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @dev See divDecimal for uint256.
 170 |     |      */
 171 |     |     function divDecimalInt128(int128 x, int128 y) internal pure returns (int128) {
 172 |     |         return (x * UNIT_INT128) / y;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev See upscale for uint256.
 177 |     |      */
 178 |     |     function upscaleInt128(int128 x, uint256 factor) internal pure returns (int128) {
 179 |     |         return x * ((10 ** factor).toInt()).to128();
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @dev See downscale for uint256.
 184 |     |      */
 185 |     |     function downscaleInt128(int128 x, uint256 factor) internal pure returns (int128) {
 186 |     |         return x / ((10 ** factor).toInt().to128());
 187 |     |     }
 188 |     | }
 189 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../interfaces/IERC165.sol";
  5 |     | 
  6 |     | library ERC165Helper {
  7 | *   |     function safeSupportsInterface(
  8 |     |         address candidate,
  9 |     |         bytes4 interfaceID
 10 |     |     ) internal returns (bool supportsInterface) {
 11 |     |         (bool success, bytes memory response) = candidate.call(
 12 |     |             abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceID)
 13 |     |         );
 14 |     | 
 15 |     |         if (!success) {
 16 |     |             return false;
 17 |     |         }
 18 |     | 
 19 |     |         if (response.length == 0) {
 20 |     |             return false;
 21 |     |         }
 22 |     | 
 23 |     |         assembly {
 24 |     |             supportsInterface := mload(add(response, 32))
 25 |     |         }
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.4;
  3 |     | 
  4 |     | /* solhint-disable meta-transactions/no-msg-sender */
  5 |     | /* solhint-disable meta-transactions/no-msg-data */
  6 |     | 
  7 |     | library ERC2771Context {
  8 |     |     // This is the trusted-multicall-forwarder. The address is constant due to CREATE2.
  9 | *   |     address private constant TRUSTED_FORWARDER = 0xE2C5658cC5C448B48141168f3e475dF8f65A1e3e;
 10 |     | 
 11 | *   |     function _msgSender() internal view returns (address sender) {
 12 | *   |         if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {
 13 |     |             // The assembly code is more direct than the Solidity version using `abi.decode`.
 14 |     |             /// @solidity memory-safe-assembly
 15 |     |             assembly {
 16 |     |                 sender := shr(96, calldataload(sub(calldatasize(), 20)))
 17 |     |             }
 18 |     |         } else {
 19 | *   |             return msg.sender;
 20 |     |         }
 21 |     |     }
 22 |     | 
 23 |     |     function _msgData() internal view returns (bytes calldata) {
 24 |     |         if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {
 25 |     |             return msg.data[:msg.data.length - 20];
 26 |     |         } else {
 27 |     |             return msg.data;
 28 |     |         }
 29 |     |     }
 30 |     | 
 31 |     |     function isTrustedForwarder(address forwarder) internal pure returns (bool) {
 32 | *   |         return forwarder == TRUSTED_FORWARDER;
 33 |     |     }
 34 |     | 
 35 |     |     function trustedForwarder() internal pure returns (address) {
 36 |     |         return TRUSTED_FORWARDER;
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/HeapUtil.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | // Eth Heap
   5 |     | // Author: Zac Mitton
   6 |     | // License: MIT
   7 |     | 
   8 |     | library HeapUtil {
   9 |     |     // default max-heap
  10 |     | 
  11 |     |     uint256 private constant _ROOT_INDEX = 1;
  12 |     | 
  13 |     |     struct Data {
  14 |     |         uint128 idCount;
  15 |     |         Node[] nodes; // root is index 1; index 0 not used
  16 |     |         mapping(uint128 => uint256) indices; // unique id => node index
  17 |     |     }
  18 |     |     struct Node {
  19 |     |         uint128 id; //use with another mapping to store arbitrary object types
  20 |     |         int128 priority;
  21 |     |     }
  22 |     | 
  23 |     |     //call init before anything else
  24 |     |     function init(Data storage self) internal {
  25 |     |         if (self.nodes.length == 0) self.nodes.push(Node(0, 0));
  26 |     |     }
  27 |     | 
  28 |     |     function insert(Data storage self, uint128 id, int128 priority) internal returns (Node memory) {
  29 |     |         //√
  30 |     |         if (self.nodes.length == 0) {
  31 |     |             init(self);
  32 |     |         } // test on-the-fly-init
  33 |     | 
  34 |     |         Node memory n;
  35 |     | 
  36 |     |         // MODIFIED: support updates
  37 |     |         extractById(self, id);
  38 |     | 
  39 |     |         self.idCount++;
  40 |     |         self.nodes.push();
  41 |     |         n = Node(id, priority);
  42 |     |         _bubbleUp(self, n, self.nodes.length - 1);
  43 |     | 
  44 |     |         return n;
  45 |     |     }
  46 |     | 
  47 |     |     function extractMax(Data storage self) internal returns (Node memory) {
  48 |     |         //√
  49 |     |         return _extract(self, _ROOT_INDEX);
  50 |     |     }
  51 |     | 
  52 |     |     function extractById(Data storage self, uint128 id) internal returns (Node memory) {
  53 |     |         //√
  54 |     |         return _extract(self, self.indices[id]);
  55 |     |     }
  56 |     | 
  57 |     |     //view
  58 |     |     function dump(Data storage self) internal view returns (Node[] memory) {
  59 |     |         //note: Empty set will return `[Node(0,0)]`. uninitialized will return `[]`.
  60 |     |         return self.nodes;
  61 |     |     }
  62 |     | 
  63 |     |     function getById(Data storage self, uint128 id) internal view returns (Node memory) {
  64 |     |         return getByIndex(self, self.indices[id]); //test that all these return the emptyNode
  65 |     |     }
  66 |     | 
  67 |     |     function getByIndex(Data storage self, uint256 i) internal view returns (Node memory) {
  68 |     |         return self.nodes.length > i ? self.nodes[i] : Node(0, 0);
  69 |     |     }
  70 |     | 
  71 |     |     function getMax(Data storage self) internal view returns (Node memory) {
  72 |     |         return getByIndex(self, _ROOT_INDEX);
  73 |     |     }
  74 |     | 
  75 |     |     function size(Data storage self) internal view returns (uint256) {
  76 |     |         return self.nodes.length > 0 ? self.nodes.length - 1 : 0;
  77 |     |     }
  78 |     | 
  79 |     |     function isNode(Node memory n) internal pure returns (bool) {
  80 |     |         return n.id > 0;
  81 |     |     }
  82 |     | 
  83 |     |     //private
  84 |     |     function _extract(Data storage self, uint256 i) private returns (Node memory) {
  85 |     |         //√
  86 |     |         if (self.nodes.length <= i || i <= 0) {
  87 |     |             return Node(0, 0);
  88 |     |         }
  89 |     | 
  90 |     |         Node memory extractedNode = self.nodes[i];
  91 |     |         delete self.indices[extractedNode.id];
  92 |     | 
  93 |     |         Node memory tailNode = self.nodes[self.nodes.length - 1];
  94 |     |         self.nodes.pop();
  95 |     | 
  96 |     |         if (i < self.nodes.length) {
  97 |     |             // if extracted node was not tail
  98 |     |             _bubbleUp(self, tailNode, i);
  99 |     |             _bubbleDown(self, self.nodes[i], i); // then try bubbling down
 100 |     |         }
 101 |     |         return extractedNode;
 102 |     |     }
 103 |     | 
 104 |     |     function _bubbleUp(Data storage self, Node memory n, uint256 i) private {
 105 |     |         //√
 106 |     |         if (i == _ROOT_INDEX || n.priority <= self.nodes[i / 2].priority) {
 107 |     |             _insert(self, n, i);
 108 |     |         } else {
 109 |     |             _insert(self, self.nodes[i / 2], i);
 110 |     |             _bubbleUp(self, n, i / 2);
 111 |     |         }
 112 |     |     }
 113 |     | 
 114 |     |     function _bubbleDown(Data storage self, Node memory n, uint256 i) private {
 115 |     |         //
 116 |     |         uint256 length = self.nodes.length;
 117 |     |         uint256 cIndex = i * 2; // left child index
 118 |     | 
 119 |     |         if (length <= cIndex) {
 120 |     |             _insert(self, n, i);
 121 |     |         } else {
 122 |     |             Node memory largestChild = self.nodes[cIndex];
 123 |     | 
 124 |     |             if (length > cIndex + 1 && self.nodes[cIndex + 1].priority > largestChild.priority) {
 125 |     |                 largestChild = self.nodes[++cIndex]; // TEST ++ gets executed first here
 126 |     |             }
 127 |     | 
 128 |     |             if (largestChild.priority <= n.priority) {
 129 |     |                 //TEST: priority 0 is valid! negative ints work
 130 |     |                 _insert(self, n, i);
 131 |     |             } else {
 132 |     |                 _insert(self, largestChild, i);
 133 |     |                 _bubbleDown(self, n, cIndex);
 134 |     |             }
 135 |     |         }
 136 |     |     }
 137 |     | 
 138 |     |     function _insert(Data storage self, Node memory n, uint256 i) private {
 139 |     |         //√
 140 |     |         self.nodes[i] = n;
 141 |     |         self.indices[n.id] = i;
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * Utilities that convert numeric types avoiding silent overflows.
  6 |     |  */
  7 |     | import "./SafeCast/SafeCastU32.sol";
  8 |     | import "./SafeCast/SafeCastI32.sol";
  9 |     | import "./SafeCast/SafeCastI24.sol";
 10 |     | import "./SafeCast/SafeCastU56.sol";
 11 |     | import "./SafeCast/SafeCastI56.sol";
 12 |     | import "./SafeCast/SafeCastU64.sol";
 13 |     | import "./SafeCast/SafeCastI64.sol";
 14 |     | import "./SafeCast/SafeCastI128.sol";
 15 |     | import "./SafeCast/SafeCastI256.sol";
 16 |     | import "./SafeCast/SafeCastU128.sol";
 17 |     | import "./SafeCast/SafeCastU160.sol";
 18 |     | import "./SafeCast/SafeCastU256.sol";
 19 |     | import "./SafeCast/SafeCastAddress.sol";
 20 |     | import "./SafeCast/SafeCastBytes32.sol";
 21 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastAddress.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastAddress {
  8 |     |     function toBytes32(address x) internal pure returns (bytes32) {
  9 |     |         return bytes32(uint256(uint160(x)));
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastBytes32.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastBytes32 {
  8 |     |     function toAddress(bytes32 x) internal pure returns (address) {
  9 |     |         return address(uint160(uint256(x)));
 10 |     |     }
 11 |     | 
 12 | *   |     function toUint(bytes32 x) internal pure returns (uint) {
 13 | *   |         return uint(x);
 14 |     |     }
 15 |     | }
 16 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI128.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastI128 {
  8 |     |     error OverflowInt128ToUint128();
  9 |     |     error OverflowInt128ToInt32();
 10 |     | 
 11 | *   |     function toUint(int128 x) internal pure returns (uint128) {
 12 |     |         // ----------------<==============o==============>-----------------
 13 |     |         // ----------------xxxxxxxxxxxxxxxo===============>----------------
 14 | *   |         if (x < 0) {
 15 |     |             revert OverflowInt128ToUint128();
 16 |     |         }
 17 |     | 
 18 |     |         return uint128(x);
 19 |     |     }
 20 |     | 
 21 |     |     function to256(int128 x) internal pure returns (int256) {
 22 |     |         return int256(x);
 23 |     |     }
 24 |     | 
 25 |     |     function to32(int128 x) internal pure returns (int32) {
 26 |     |         // ----------------<==============o==============>-----------------
 27 |     |         // ----------------xxxxxxxxxxxx<==o==>xxxxxxxxxxxx-----------------
 28 |     |         if (x < int256(type(int32).min) || x > int256(type(int32).max)) {
 29 |     |             revert OverflowInt128ToInt32();
 30 |     |         }
 31 |     | 
 32 |     |         return int32(x);
 33 |     |     }
 34 |     | 
 35 |     |     function zero() internal pure returns (int128) {
 36 |     |         return int128(0);
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI24.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastI24 {
  8 |     |     function to256(int24 x) internal pure returns (int256) {
  9 |     |         return int256(x);
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI256.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastI256 {
  8 |     |     error OverflowInt256ToUint256();
  9 |     |     error OverflowInt256ToInt128();
 10 |     |     error OverflowInt256ToInt24();
 11 |     | 
 12 | *   |     function to128(int256 x) internal pure returns (int128) {
 13 |     |         // ----<==========================o===========================>----
 14 |     |         // ----xxxxxxxxxxxx<==============o==============>xxxxxxxxxxxxx----
 15 | *   |         if (x < int256(type(int128).min) || x > int256(type(int128).max)) {
 16 |     |             revert OverflowInt256ToInt128();
 17 |     |         }
 18 |     | 
 19 |     |         return int128(x);
 20 |     |     }
 21 |     | 
 22 |     |     function to24(int256 x) internal pure returns (int24) {
 23 |     |         // ----<==========================o===========================>----
 24 |     |         // ----xxxxxxxxxxxxxxxxxxxx<======o=======>xxxxxxxxxxxxxxxxxxxx----
 25 |     |         if (x < int256(type(int24).min) || x > int256(type(int24).max)) {
 26 |     |             revert OverflowInt256ToInt24();
 27 |     |         }
 28 |     | 
 29 |     |         return int24(x);
 30 |     |     }
 31 |     | 
 32 | *   |     function toUint(int256 x) internal pure returns (uint256) {
 33 |     |         // ----<==========================o===========================>----
 34 |     |         // ----xxxxxxxxxxxxxxxxxxxxxxxxxxxo===============================>
 35 | *   |         if (x < 0) {
 36 |     |             revert OverflowInt256ToUint256();
 37 |     |         }
 38 |     | 
 39 | *   |         return uint256(x);
 40 |     |     }
 41 |     | 
 42 |     |     function zero() internal pure returns (int256) {
 43 |     |         return int256(0);
 44 |     |     }
 45 |     | }
 46 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI32.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastI32 {
  8 |     |     error OverflowInt32ToUint32();
  9 |     | 
 10 |     |     function toUint(int32 x) internal pure returns (uint32) {
 11 |     |         // ----------------------<========o========>----------------------
 12 |     |         // ----------------------xxxxxxxxxo=========>----------------------
 13 |     |         if (x < 0) {
 14 |     |             revert OverflowInt32ToUint32();
 15 |     |         }
 16 |     | 
 17 |     |         return uint32(x);
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI56.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastI56 {
  8 |     |     error OverflowInt56ToInt24();
  9 |     | 
 10 |     |     function to24(int56 x) internal pure returns (int24) {
 11 |     |         // ----------------------<========o========>-----------------------
 12 |     |         // ----------------------xxx<=====o=====>xxx-----------------------
 13 |     |         if (x < int256(type(int24).min) || x > int256(type(int24).max)) {
 14 |     |             revert OverflowInt56ToInt24();
 15 |     |         }
 16 |     | 
 17 |     |         return int24(x);
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastI64.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastI64 {
  8 |     |     error OverflowInt64ToUint64();
  9 |     | 
 10 |     |     function toUint(int64 x) internal pure returns (uint64) {
 11 |     |         // ----------------------<========o========>----------------------
 12 |     |         // ----------------------xxxxxxxxxo=========>----------------------
 13 |     |         if (x < 0) {
 14 |     |             revert OverflowInt64ToUint64();
 15 |     |         }
 16 |     | 
 17 |     |         return uint64(x);
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU128.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastU128 {
  8 |     |     error OverflowUint128ToInt128();
  9 |     | 
 10 | *   |     function to256(uint128 x) internal pure returns (uint256) {
 11 |     |         return uint256(x);
 12 |     |     }
 13 |     | 
 14 | *   |     function toInt(uint128 x) internal pure returns (int128) {
 15 |     |         // -------------------------------o===============>----------------
 16 |     |         // ----------------<==============o==============>x----------------
 17 | *   |         if (x > uint128(type(int128).max)) {
 18 |     |             revert OverflowUint128ToInt128();
 19 |     |         }
 20 |     | 
 21 |     |         return int128(x);
 22 |     |     }
 23 |     | 
 24 |     |     function toBytes32(uint128 x) internal pure returns (bytes32) {
 25 |     |         return bytes32(uint256(x));
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU160.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastU160 {
  8 |     |     function to256(uint160 x) internal pure returns (uint256) {
  9 |     |         return uint256(x);
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU256.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastU256 {
  8 |     |     error OverflowUint256ToUint128();
  9 |     |     error OverflowUint256ToInt256();
 10 |     |     error OverflowUint256ToUint64();
 11 |     |     error OverflowUint256ToUint32();
 12 |     |     error OverflowUint256ToUint160();
 13 |     | 
 14 | *   |     function to128(uint256 x) internal pure returns (uint128) {
 15 |     |         // -------------------------------o===============================>
 16 |     |         // -------------------------------o===============>xxxxxxxxxxxxxxxx
 17 | *   |         if (x > type(uint128).max) {
 18 |     |             revert OverflowUint256ToUint128();
 19 |     |         }
 20 |     | 
 21 | *   |         return uint128(x);
 22 |     |     }
 23 |     | 
 24 | *   |     function to64(uint256 x) internal pure returns (uint64) {
 25 |     |         // -------------------------------o===============================>
 26 |     |         // -------------------------------o======>xxxxxxxxxxxxxxxxxxxxxxxxx
 27 | *   |         if (x > type(uint64).max) {
 28 |     |             revert OverflowUint256ToUint64();
 29 |     |         }
 30 |     | 
 31 | *   |         return uint64(x);
 32 |     |     }
 33 |     | 
 34 |     |     function to32(uint256 x) internal pure returns (uint32) {
 35 |     |         // -------------------------------o===============================>
 36 |     |         // -------------------------------o===>xxxxxxxxxxxxxxxxxxxxxxxxxxxx
 37 |     |         if (x > type(uint32).max) {
 38 |     |             revert OverflowUint256ToUint32();
 39 |     |         }
 40 |     | 
 41 |     |         return uint32(x);
 42 |     |     }
 43 |     | 
 44 |     |     function to160(uint256 x) internal pure returns (uint160) {
 45 |     |         // -------------------------------o===============================>
 46 |     |         // -------------------------------o==================>xxxxxxxxxxxxx
 47 |     |         if (x > type(uint160).max) {
 48 |     |             revert OverflowUint256ToUint160();
 49 |     |         }
 50 |     | 
 51 |     |         return uint160(x);
 52 |     |     }
 53 |     | 
 54 |     |     function toBytes32(uint256 x) internal pure returns (bytes32) {
 55 |     |         return bytes32(x);
 56 |     |     }
 57 |     | 
 58 | *   |     function toInt(uint256 x) internal pure returns (int256) {
 59 |     |         // -------------------------------o===============================>
 60 |     |         // ----<==========================o===========================>xxxx
 61 | *   |         if (x > uint256(type(int256).max)) {
 62 |     |             revert OverflowUint256ToInt256();
 63 |     |         }
 64 |     | 
 65 | *   |         return int256(x);
 66 |     |     }
 67 |     | }
 68 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU32.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastU32 {
  8 |     |     error OverflowUint32ToInt32();
  9 |     | 
 10 |     |     function toInt(uint32 x) internal pure returns (int32) {
 11 |     |         // -------------------------------o=========>----------------------
 12 |     |         // ----------------------<========o========>x----------------------
 13 |     |         if (x > uint32(type(int32).max)) {
 14 |     |             revert OverflowUint32ToInt32();
 15 |     |         }
 16 |     | 
 17 |     |         return int32(x);
 18 |     |     }
 19 |     | 
 20 |     |     function to256(uint32 x) internal pure returns (uint256) {
 21 |     |         return uint256(x);
 22 |     |     }
 23 |     | 
 24 |     |     function to56(uint32 x) internal pure returns (uint56) {
 25 |     |         return uint56(x);
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU56.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastU56 {
  8 |     |     error OverflowUint56ToInt56();
  9 |     | 
 10 |     |     function toInt(uint56 x) internal pure returns (int56) {
 11 |     |         // -------------------------------o=========>----------------------
 12 |     |         // ----------------------<========o========>x----------------------
 13 |     |         if (x > uint56(type(int56).max)) {
 14 |     |             revert OverflowUint56ToInt56();
 15 |     |         }
 16 |     | 
 17 |     |         return int56(x);
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SafeCast/SafeCastU64.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title See SafeCast.sol.
  6 |     |  */
  7 |     | library SafeCastU64 {
  8 |     |     error OverflowUint64ToInt64();
  9 |     | 
 10 |     |     function toInt(uint64 x) internal pure returns (int64) {
 11 |     |         // -------------------------------o=========>----------------------
 12 |     |         // ----------------------<========o========>x----------------------
 13 |     |         if (x > uint64(type(int64).max)) {
 14 |     |             revert OverflowUint64ToInt64();
 15 |     |         }
 16 |     | 
 17 |     |         return int64(x);
 18 |     |     }
 19 |     | 
 20 |     |     function to256(uint64 x) internal pure returns (uint256) {
 21 |     |         return uint256(x);
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-contracts/contracts/utils/SetUtil.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "./SafeCast.sol";
   5 |     | 
   6 |     | library SetUtil {
   7 |     |     using SafeCastAddress for address;
   8 |     |     using SafeCastBytes32 for bytes32;
   9 |     |     using SafeCastU256 for uint256;
  10 |     | 
  11 |     |     // ----------------------------------------
  12 |     |     // Uint support
  13 |     |     // ----------------------------------------
  14 |     | 
  15 |     |     struct UintSet {
  16 |     |         Bytes32Set raw;
  17 |     |     }
  18 |     | 
  19 | *   |     function add(UintSet storage set, uint256 value) internal {
  20 | *   |         add(set.raw, value.toBytes32());
  21 |     |     }
  22 |     | 
  23 | *   |     function remove(UintSet storage set, uint256 value) internal {
  24 | *   |         remove(set.raw, value.toBytes32());
  25 |     |     }
  26 |     | 
  27 |     |     function replace(UintSet storage set, uint256 value, uint256 newValue) internal {
  28 |     |         replace(set.raw, value.toBytes32(), newValue.toBytes32());
  29 |     |     }
  30 |     | 
  31 | *   |     function contains(UintSet storage set, uint256 value) internal view returns (bool) {
  32 | *   |         return contains(set.raw, value.toBytes32());
  33 |     |     }
  34 |     | 
  35 | *   |     function length(UintSet storage set) internal view returns (uint256) {
  36 | *   |         return length(set.raw);
  37 |     |     }
  38 |     | 
  39 | *   |     function valueAt(UintSet storage set, uint256 position) internal view returns (uint256) {
  40 | *   |         return valueAt(set.raw, position).toUint();
  41 |     |     }
  42 |     | 
  43 |     |     function positionOf(UintSet storage set, uint256 value) internal view returns (uint256) {
  44 |     |         return positionOf(set.raw, value.toBytes32());
  45 |     |     }
  46 |     | 
  47 | *   |     function values(UintSet storage set) internal view returns (uint256[] memory) {
  48 | *   |         bytes32[] memory store = values(set.raw);
  49 |     |         uint256[] memory result;
  50 |     | 
  51 |     |         assembly {
  52 |     |             result := store
  53 |     |         }
  54 |     | 
  55 |     |         return result;
  56 |     |     }
  57 |     | 
  58 |     |     // ----------------------------------------
  59 |     |     // Address support
  60 |     |     // ----------------------------------------
  61 |     | 
  62 |     |     struct AddressSet {
  63 |     |         Bytes32Set raw;
  64 |     |     }
  65 |     | 
  66 |     |     function add(AddressSet storage set, address value) internal {
  67 |     |         add(set.raw, value.toBytes32());
  68 |     |     }
  69 |     | 
  70 |     |     function remove(AddressSet storage set, address value) internal {
  71 |     |         remove(set.raw, value.toBytes32());
  72 |     |     }
  73 |     | 
  74 |     |     function replace(AddressSet storage set, address value, address newValue) internal {
  75 |     |         replace(set.raw, value.toBytes32(), newValue.toBytes32());
  76 |     |     }
  77 |     | 
  78 | *   |     function contains(AddressSet storage set, address value) internal view returns (bool) {
  79 | *   |         return contains(set.raw, value.toBytes32());
  80 |     |     }
  81 |     | 
  82 |     |     function length(AddressSet storage set) internal view returns (uint256) {
  83 |     |         return length(set.raw);
  84 |     |     }
  85 |     | 
  86 |     |     function valueAt(AddressSet storage set, uint256 position) internal view returns (address) {
  87 |     |         return valueAt(set.raw, position).toAddress();
  88 |     |     }
  89 |     | 
  90 |     |     function positionOf(AddressSet storage set, address value) internal view returns (uint256) {
  91 |     |         return positionOf(set.raw, value.toBytes32());
  92 |     |     }
  93 |     | 
  94 |     |     function values(AddressSet storage set) internal view returns (address[] memory) {
  95 |     |         bytes32[] memory store = values(set.raw);
  96 |     |         address[] memory result;
  97 |     | 
  98 |     |         assembly {
  99 |     |             result := store
 100 |     |         }
 101 |     | 
 102 |     |         return result;
 103 |     |     }
 104 |     | 
 105 |     |     // ----------------------------------------
 106 |     |     // Core bytes32 support
 107 |     |     // ----------------------------------------
 108 |     | 
 109 |     |     error PositionOutOfBounds();
 110 |     |     error ValueNotInSet();
 111 |     |     error ValueAlreadyInSet();
 112 |     | 
 113 |     |     struct Bytes32Set {
 114 |     |         bytes32[] _values;
 115 |     |         mapping(bytes32 => uint256) _positions; // Position zero is never used.
 116 |     |     }
 117 |     | 
 118 | *   |     function add(Bytes32Set storage set, bytes32 value) internal {
 119 | *   |         if (contains(set, value)) {
 120 |     |             revert ValueAlreadyInSet();
 121 |     |         }
 122 |     | 
 123 | *   |         set._values.push(value);
 124 | *   |         set._positions[value] = set._values.length;
 125 |     |     }
 126 |     | 
 127 | *   |     function remove(Bytes32Set storage set, bytes32 value) internal {
 128 | *   |         uint256 position = set._positions[value];
 129 | *   |         if (position == 0) {
 130 |     |             revert ValueNotInSet();
 131 |     |         }
 132 |     | 
 133 | *   |         uint256 index = position - 1;
 134 | *   |         uint256 lastIndex = set._values.length - 1;
 135 |     | 
 136 |     |         // If the element being deleted is not the last in the values,
 137 |     |         // move the last element to its position.
 138 | *   |         if (index != lastIndex) {
 139 | *   |             bytes32 lastValue = set._values[lastIndex];
 140 |     | 
 141 | *   |             set._values[index] = lastValue;
 142 | *   |             set._positions[lastValue] = position;
 143 |     |         }
 144 |     | 
 145 |     |         // Remove the last element in the values.
 146 | *   |         set._values.pop();
 147 | *   |         delete set._positions[value];
 148 |     |     }
 149 |     | 
 150 |     |     function replace(Bytes32Set storage set, bytes32 value, bytes32 newValue) internal {
 151 |     |         if (!contains(set, value)) {
 152 |     |             revert ValueNotInSet();
 153 |     |         }
 154 |     | 
 155 |     |         if (contains(set, newValue)) {
 156 |     |             revert ValueAlreadyInSet();
 157 |     |         }
 158 |     | 
 159 |     |         uint256 position = set._positions[value];
 160 |     |         delete set._positions[value];
 161 |     | 
 162 |     |         uint256 index = position - 1;
 163 |     | 
 164 |     |         set._values[index] = newValue;
 165 |     |         set._positions[newValue] = position;
 166 |     |     }
 167 |     | 
 168 | *   |     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
 169 | *   |         return set._positions[value] != 0;
 170 |     |     }
 171 |     | 
 172 | *   |     function length(Bytes32Set storage set) internal view returns (uint256) {
 173 | *   |         return set._values.length;
 174 |     |     }
 175 |     | 
 176 | *   |     function valueAt(Bytes32Set storage set, uint256 position) internal view returns (bytes32) {
 177 | *   |         if (position == 0 || position > set._values.length) {
 178 |     |             revert PositionOutOfBounds();
 179 |     |         }
 180 |     | 
 181 | *   |         uint256 index = position - 1;
 182 |     | 
 183 | *   |         return set._values[index];
 184 |     |     }
 185 |     | 
 186 |     |     function positionOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {
 187 |     |         if (!contains(set, value)) {
 188 |     |             revert ValueNotInSet();
 189 |     |         }
 190 |     | 
 191 |     |         return set._positions[value];
 192 |     |     }
 193 |     | 
 194 | *   |     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
 195 | *   |         return set._values;
 196 |     |     }
 197 |     | }
 198 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/IAssociatedSystemsModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Module for connecting a system with other associated systems.
  6 |     | 
  7 |     |  * Associated systems become available to all system modules for communication and interaction, but as opposed to inter-modular communications, interactions with associated systems will require the use of `CALL`.
  8 |     |  *
  9 |     |  * Associated systems can be managed or unmanaged.
 10 |     |  * - Managed systems are connected via a proxy, which means that their implementation can be updated, and the system controls the execution context of the associated system. Example, an snxUSD token connected to the system, and controlled by the system.
 11 |     |  * - Unmanaged systems are just addresses tracked by the system, for which it has no control whatsoever. Example, Uniswap v3, Curve, etc.
 12 |     |  *
 13 |     |  * Furthermore, associated systems are typed in the AssociatedSystem utility library (See AssociatedSystem.sol):
 14 |     |  * - KIND_ERC20: A managed associated system specifically wrapping an ERC20 implementation.
 15 |     |  * - KIND_ERC721: A managed associated system specifically wrapping an ERC721 implementation.
 16 |     |  * - KIND_UNMANAGED: Any unmanaged associated system.
 17 |     |  */
 18 |     | interface IAssociatedSystemsModule {
 19 |     |     /**
 20 |     |      * @notice Emitted when an associated system is set.
 21 |     |      * @param kind The type of associated system (managed ERC20, managed ERC721, unmanaged, etc - See the AssociatedSystem util).
 22 |     |      * @param id The bytes32 identifier of the associated system.
 23 |     |      * @param proxy The main external contract address of the associated system.
 24 |     |      * @param impl The address of the implementation of the associated system (if not behind a proxy, will equal `proxy`).
 25 |     |      */
 26 |     |     event AssociatedSystemSet(
 27 |     |         bytes32 indexed kind,
 28 |     |         bytes32 indexed id,
 29 |     |         address proxy,
 30 |     |         address impl
 31 |     |     );
 32 |     | 
 33 |     |     /**
 34 |     |      * @notice Emitted when the function you are calling requires an associated system, but it
 35 |     |      * has not been registered
 36 |     |      */
 37 |     |     error MissingAssociatedSystem(bytes32 id);
 38 |     | 
 39 |     |     /**
 40 |     |      * @notice Creates or initializes a managed associated ERC20 token.
 41 |     |      * @param id The bytes32 identifier of the associated system. If the id is new to the system, it will create a new proxy for the associated system.
 42 |     |      * @param name The token name that will be used to initialize the proxy.
 43 |     |      * @param symbol The token symbol that will be used to initialize the proxy.
 44 |     |      * @param decimals The token decimals that will be used to initialize the proxy.
 45 |     |      * @param impl The ERC20 implementation of the proxy.
 46 |     |      */
 47 |     |     function initOrUpgradeToken(
 48 |     |         bytes32 id,
 49 |     |         string memory name,
 50 |     |         string memory symbol,
 51 |     |         uint8 decimals,
 52 |     |         address impl
 53 |     |     ) external;
 54 |     | 
 55 |     |     /**
 56 |     |      * @notice Creates or initializes a managed associated ERC721 token.
 57 |     |      * @param id The bytes32 identifier of the associated system. If the id is new to the system, it will create a new proxy for the associated system.
 58 |     |      * @param name The token name that will be used to initialize the proxy.
 59 |     |      * @param symbol The token symbol that will be used to initialize the proxy.
 60 |     |      * @param uri The token uri that will be used to initialize the proxy.
 61 |     |      * @param impl The ERC721 implementation of the proxy.
 62 |     |      */
 63 |     |     function initOrUpgradeNft(
 64 |     |         bytes32 id,
 65 |     |         string memory name,
 66 |     |         string memory symbol,
 67 |     |         string memory uri,
 68 |     |         address impl
 69 |     |     ) external;
 70 |     | 
 71 |     |     /**
 72 |     |      * @notice Registers an unmanaged external contract in the system.
 73 |     |      * @param id The bytes32 identifier to use to reference the associated system.
 74 |     |      * @param endpoint The address of the associated system.
 75 |     |      *
 76 |     |      * Note: The system will not be able to control or upgrade the associated system, only communicate with it.
 77 |     |      */
 78 |     |     function registerUnmanagedSystem(bytes32 id, address endpoint) external;
 79 |     | 
 80 |     |     /**
 81 |     |      * @notice Retrieves an associated system.
 82 |     |      * @param id The bytes32 identifier used to reference the associated system.
 83 |     |      * @return addr The external contract address of the associated system.
 84 |     |      * @return kind The type of associated system (managed ERC20, managed ERC721, unmanaged, etc - See the AssociatedSystem util).
 85 |     |      */
 86 |     |     function getAssociatedSystem(bytes32 id) external view returns (address addr, bytes32 kind);
 87 |     | }
 88 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/IFeatureFlagModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Module for granular enabling and disabling of system features and functions.
   6 |     |  *
   7 |     |  * Interface functions that are controlled by a feature flag simply need to add this line to their body:
   8 |     |  * `FeatureFlag.ensureAccessToFeature(FLAG_ID);`
   9 |     |  *
  10 |     |  * If such a line is not present in a function, then it is not controlled by a feature flag.
  11 |     |  *
  12 |     |  * If a feature flag is set and then removed forever, consider deleting the line mentioned above from the function's body.
  13 |     |  */
  14 |     | interface IFeatureFlagModule {
  15 |     |     /**
  16 |     |      * @notice Emitted when general access has been given or removed for a feature.
  17 |     |      * @param feature The bytes32 id of the feature.
  18 |     |      * @param allowAll True if the feature was allowed for everyone and false if it is only allowed for those included in the allowlist.
  19 |     |      */
  20 |     |     event FeatureFlagAllowAllSet(bytes32 indexed feature, bool allowAll);
  21 |     | 
  22 |     |     /**
  23 |     |      * @notice Emitted when general access has been blocked for a feature.
  24 |     |      * @param feature The bytes32 id of the feature.
  25 |     |      * @param denyAll True if the feature was blocked for everyone and false if it is only allowed for those included in the allowlist or if allowAll is set to true.
  26 |     |      */
  27 |     |     event FeatureFlagDenyAllSet(bytes32 indexed feature, bool denyAll);
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Emitted when an address was given access to a feature.
  31 |     |      * @param feature The bytes32 id of the feature.
  32 |     |      * @param account The address that was given access to the feature.
  33 |     |      */
  34 |     |     event FeatureFlagAllowlistAdded(bytes32 indexed feature, address account);
  35 |     | 
  36 |     |     /**
  37 |     |      * @notice Emitted when access to a feature has been removed from an address.
  38 |     |      * @param feature The bytes32 id of the feature.
  39 |     |      * @param account The address that no longer has access to the feature.
  40 |     |      */
  41 |     |     event FeatureFlagAllowlistRemoved(bytes32 indexed feature, address account);
  42 |     | 
  43 |     |     /**
  44 |     |      * @notice Emitted when the list of addresses which can block a feature has been updated
  45 |     |      * @param feature The bytes32 id of the feature.
  46 |     |      * @param deniers The list of addresses which are allowed to block a feature
  47 |     |      */
  48 |     |     event FeatureFlagDeniersReset(bytes32 indexed feature, address[] deniers);
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Enables or disables free access to a feature.
  52 |     |      * @param feature The bytes32 id of the feature.
  53 |     |      * @param allowAll True to allow anyone to use the feature, false to fallback to the allowlist.
  54 |     |      */
  55 |     |     function setFeatureFlagAllowAll(bytes32 feature, bool allowAll) external;
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice Enables or disables free access to a feature.
  59 |     |      * @param feature The bytes32 id of the feature.
  60 |     |      * @param denyAll True to allow noone to use the feature, false to fallback to the allowlist.
  61 |     |      */
  62 |     |     function setFeatureFlagDenyAll(bytes32 feature, bool denyAll) external;
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Allows an address to use a feature.
  66 |     |      * @dev This function does nothing if the specified account is already on the allowlist.
  67 |     |      * @param feature The bytes32 id of the feature.
  68 |     |      * @param account The address that is allowed to use the feature.
  69 |     |      */
  70 |     |     function addToFeatureFlagAllowlist(bytes32 feature, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @notice Disallows an address from using a feature.
  74 |     |      * @dev This function does nothing if the specified account is already on the allowlist.
  75 |     |      * @param feature The bytes32 id of the feature.
  76 |     |      * @param account The address that is disallowed from using the feature.
  77 |     |      */
  78 |     |     function removeFromFeatureFlagAllowlist(bytes32 feature, address account) external;
  79 |     | 
  80 |     |     /**
  81 |     |      * @notice Sets addresses which can disable a feature (but not enable it). Overwrites any preexisting data.
  82 |     |      * @param feature The bytes32 id of the feature.
  83 |     |      * @param deniers The addresses which should have the ability to unilaterally disable the feature
  84 |     |      */
  85 |     |     function setDeniers(bytes32 feature, address[] memory deniers) external;
  86 |     | 
  87 |     |     /**
  88 |     |      * @notice Gets the list of address which can block a feature
  89 |     |      * @param feature The bytes32 id of the feature.
  90 |     |      */
  91 |     |     function getDeniers(bytes32 feature) external view returns (address[] memory);
  92 |     | 
  93 |     |     /**
  94 |     |      * @notice Determines if the given feature is freely allowed to all users.
  95 |     |      * @param feature The bytes32 id of the feature.
  96 |     |      * @return True if anyone is allowed to use the feature, false if per-user control is used.
  97 |     |      */
  98 |     |     function getFeatureFlagAllowAll(bytes32 feature) external view returns (bool);
  99 |     | 
 100 |     |     /**
 101 |     |      * @notice Determines if the given feature is denied to all users.
 102 |     |      * @param feature The bytes32 id of the feature.
 103 |     |      * @return True if noone is allowed to use the feature.
 104 |     |      */
 105 |     |     function getFeatureFlagDenyAll(bytes32 feature) external view returns (bool);
 106 |     | 
 107 |     |     /**
 108 |     |      * @notice Returns a list of addresses that are allowed to use the specified feature.
 109 |     |      * @param feature The bytes32 id of the feature.
 110 |     |      * @return The queried list of addresses.
 111 |     |      */
 112 |     |     function getFeatureFlagAllowlist(bytes32 feature) external view returns (address[] memory);
 113 |     | 
 114 |     |     /**
 115 |     |      * @notice Determines if an address can use the specified feature.
 116 |     |      * @param feature The bytes32 id of the feature.
 117 |     |      * @param account The address that is being queried for access to the feature.
 118 |     |      * @return A boolean with the response to the query.
 119 |     |      */
 120 |     |     function isFeatureAllowed(bytes32 feature, address account) external view returns (bool);
 121 |     | }
 122 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/IOwnerModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Module for giving a system owner based access control.
  6 |     |  */
  7 |     | // solhint-disable-next-line no-empty-blocks
  8 |     | interface IOwnerModule {
  9 |     | 
 10 |     | }
 11 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC20.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Module wrapping an ERC20 token implementation.
  8 |     |  */
  9 |     | interface ITokenModule is IERC20 {
 10 |     |     /**
 11 |     |      * @notice Returns wether the token has been initialized.
 12 |     |      * @return A boolean with the result of the query.
 13 |     |      */
 14 |     |     function isInitialized() external view returns (bool);
 15 |     | 
 16 |     |     /**
 17 |     |      * @notice Initializes the token with name, symbol, and decimals.
 18 |     |      */
 19 |     |     function initialize(
 20 |     |         string memory tokenName,
 21 |     |         string memory tokenSymbol,
 22 |     |         uint8 tokenDecimals
 23 |     |     ) external;
 24 |     | 
 25 |     |     /**
 26 |     |      * @notice Allows the owner to mint tokens.
 27 |     |      * @param to The address to receive the newly minted tokens.
 28 |     |      * @param amount The amount of tokens to mint.
 29 |     |      */
 30 |     |     function mint(address to, uint256 amount) external;
 31 |     | 
 32 |     |     /**
 33 |     |      * @notice Allows the owner to burn tokens.
 34 |     |      * @param from The address whose tokens will be burnt.
 35 |     |      * @param amount The amount of tokens to burn.
 36 |     |      */
 37 |     |     function burn(address from, uint256 amount) external;
 38 |     | 
 39 |     |     /**
 40 |     |      * @notice Allows an address that holds tokens to provide allowance to another.
 41 |     |      * @param from The address that is providing allowance.
 42 |     |      * @param spender The address that is given allowance.
 43 |     |      * @param amount The amount of allowance being given.
 44 |     |      */
 45 |     |     function setAllowance(address from, address spender, uint256 amount) external;
 46 |     | }
 47 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/CoreModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {OwnerModule} from "./OwnerModule.sol";
  5 |     | import {UpgradeModule} from "./UpgradeModule.sol";
  6 |     | 
  7 |     | // solhint-disable-next-line no-empty-blocks
  8 |     | contract CoreModule is OwnerModule, UpgradeModule {
  9 |     | 
 10 |     | }
 11 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/FeatureFlagModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol";
   5 |     | import "../storage/FeatureFlag.sol";
   6 |     | 
   7 |     | import "../interfaces/IFeatureFlagModule.sol";
   8 |     | import {console2} from "lib/forge-std/src/Test.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title Module for granular enabling and disabling of system features and functions.
  12 |     |  * See IFeatureFlagModule.
  13 |     |  */
  14 |     | contract FeatureFlagModule is IFeatureFlagModule {
  15 |     |     using SetUtil for SetUtil.AddressSet;
  16 |     |     using FeatureFlag for FeatureFlag.Data;
  17 |     | 
  18 |     |     /**
  19 |     |      * @inheritdoc IFeatureFlagModule
  20 |     |      */
  21 |     |     function setFeatureFlagAllowAll(bytes32 feature, bool allowAll) external override {
  22 |     |         console2.log("===== FeatureFlagModule::setFeatureFlagAllowAll START =====");
  23 |     |         console2.log("Before only owner");
  24 |     |         OwnableStorage.onlyOwner();
  25 |     |         console2.log("After only owner");
  26 |     |         FeatureFlag.load(feature).allowAll = allowAll;
  27 |     | 
  28 |     |         if (allowAll) {
  29 |     |             FeatureFlag.load(feature).denyAll = false;
  30 |     |         }
  31 |     | 
  32 |     |         emit FeatureFlagAllowAllSet(feature, allowAll);
  33 |     |         console2.log("===== FeatureFlagModule::setFeatureFlagAllowAll END =====");
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @inheritdoc IFeatureFlagModule
  38 |     |      */
  39 |     |     function setFeatureFlagDenyAll(bytes32 feature, bool denyAll) external override {
  40 |     |         FeatureFlag.Data storage flag = FeatureFlag.load(feature);
  41 |     | 
  42 |     |         if (!denyAll || !flag.isDenier(ERC2771Context._msgSender())) {
  43 |     |             OwnableStorage.onlyOwner();
  44 |     |         }
  45 |     | 
  46 |     |         flag.denyAll = denyAll;
  47 |     | 
  48 |     |         emit FeatureFlagDenyAllSet(feature, denyAll);
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @inheritdoc IFeatureFlagModule
  53 |     |      */
  54 |     |     function addToFeatureFlagAllowlist(bytes32 feature, address account) external override {
  55 |     |         OwnableStorage.onlyOwner();
  56 |     | 
  57 |     |         SetUtil.AddressSet storage permissionedAddresses = FeatureFlag
  58 |     |             .load(feature)
  59 |     |             .permissionedAddresses;
  60 |     | 
  61 |     |         if (!permissionedAddresses.contains(account)) {
  62 |     |             permissionedAddresses.add(account);
  63 |     |             emit FeatureFlagAllowlistAdded(feature, account);
  64 |     |         }
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @inheritdoc IFeatureFlagModule
  69 |     |      */
  70 |     |     function removeFromFeatureFlagAllowlist(bytes32 feature, address account) external override {
  71 |     |         OwnableStorage.onlyOwner();
  72 |     | 
  73 |     |         SetUtil.AddressSet storage permissionedAddresses = FeatureFlag
  74 |     |             .load(feature)
  75 |     |             .permissionedAddresses;
  76 |     | 
  77 |     |         if (permissionedAddresses.contains(account)) {
  78 |     |             FeatureFlag.load(feature).permissionedAddresses.remove(account);
  79 |     |             emit FeatureFlagAllowlistRemoved(feature, account);
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @inheritdoc IFeatureFlagModule
  85 |     |      */
  86 |     |     function setDeniers(bytes32 feature, address[] memory deniers) external override {
  87 |     |         OwnableStorage.onlyOwner();
  88 |     |         FeatureFlag.Data storage flag = FeatureFlag.load(feature);
  89 |     | 
  90 |     |         // resize array (its really dumb how you have to do this)
  91 |     |         uint256 storageLen = flag.deniers.length;
  92 |     |         for (uint256 i = storageLen; i > deniers.length; i--) {
  93 |     |             flag.deniers.pop();
  94 |     |         }
  95 |     | 
  96 |     |         for (uint256 i = 0; i < deniers.length; i++) {
  97 |     |             if (i >= storageLen) {
  98 |     |                 flag.deniers.push(deniers[i]);
  99 |     |             } else {
 100 |     |                 flag.deniers[i] = deniers[i];
 101 |     |             }
 102 |     |         }
 103 |     | 
 104 |     |         emit FeatureFlagDeniersReset(feature, deniers);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @inheritdoc IFeatureFlagModule
 109 |     |      */
 110 |     |     function getDeniers(bytes32 feature) external view override returns (address[] memory) {
 111 |     |         FeatureFlag.Data storage flag = FeatureFlag.load(feature);
 112 |     |         address[] memory addrs = new address[](flag.deniers.length);
 113 |     |         for (uint256 i = 0; i < addrs.length; i++) {
 114 |     |             addrs[i] = flag.deniers[i];
 115 |     |         }
 116 |     | 
 117 |     |         return addrs;
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @inheritdoc IFeatureFlagModule
 122 |     |      */
 123 |     |     function getFeatureFlagAllowAll(bytes32 feature) external view override returns (bool) {
 124 |     |         return FeatureFlag.load(feature).allowAll;
 125 |     |     }
 126 |     | 
 127 |     |     /**
 128 |     |      * @inheritdoc IFeatureFlagModule
 129 |     |      */
 130 |     |     function getFeatureFlagDenyAll(bytes32 feature) external view override returns (bool) {
 131 |     |         return FeatureFlag.load(feature).denyAll;
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @inheritdoc IFeatureFlagModule
 136 |     |      */
 137 |     |     function getFeatureFlagAllowlist(
 138 |     |         bytes32 feature
 139 |     |     ) external view override returns (address[] memory) {
 140 |     |         return FeatureFlag.load(feature).permissionedAddresses.values();
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @inheritdoc IFeatureFlagModule
 145 |     |      */
 146 |     |     function isFeatureAllowed(
 147 |     |         bytes32 feature,
 148 |     |         address account
 149 |     |     ) external view override returns (bool) {
 150 |     |         return FeatureFlag.hasAccess(feature, account);
 151 |     |     }
 152 |     | }
 153 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/OwnerModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/ownership/Ownable.sol";
  5 |     | import "@synthetixio/core-contracts/contracts/initializable/InitializableMixin.sol";
  6 |     | import "../interfaces/IOwnerModule.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title Module for giving a system owner based access control.
 10 |     |  * See IOwnerModule.
 11 |     |  */
 12 |     | contract OwnerModule is Ownable, IOwnerModule {
 13 |     |     // solhint-disable-next-line no-empty-blocks
 14 |     |     constructor() Ownable(address(0)) {
 15 |     |         // empty intentionally
 16 |     |     }
 17 |     | 
 18 |     |     // no impl intentionally
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/modules/UpgradeModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/proxy/UUPSImplementation.sol";
  5 |     | import "@synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol";
  6 |     | 
  7 |     | contract UpgradeModule is UUPSImplementation {
  8 |     |     function upgradeTo(address newImplementation) public override {
  9 |     |         OwnableStorage.onlyOwner();
 10 |     |         _upgradeTo(newImplementation);
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/core-modules/contracts/storage/FeatureFlag.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  5 |     | import "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
  6 |     | 
  7 |     | library FeatureFlag {
  8 |     |     using SetUtil for SetUtil.AddressSet;
  9 |     | 
 10 |     |     error FeatureUnavailable(bytes32 which);
 11 |     | 
 12 |     |     struct Data {
 13 |     |         bytes32 name;
 14 |     |         bool allowAll;
 15 |     |         bool denyAll;
 16 |     |         SetUtil.AddressSet permissionedAddresses;
 17 |     |         address[] deniers;
 18 |     |     }
 19 |     | 
 20 | *   |     function load(bytes32 featureName) internal pure returns (Data storage store) {
 21 | *   |         bytes32 s = keccak256(abi.encode("io.synthetix.core-modules.FeatureFlag", featureName));
 22 |     |         assembly {
 23 |     |             store.slot := s
 24 |     |         }
 25 |     |     }
 26 |     | 
 27 | *   |     function ensureAccessToFeature(bytes32 feature) internal view {
 28 | *   |         if (!hasAccess(feature, ERC2771Context._msgSender())) {
 29 | *   |             revert FeatureUnavailable(feature);
 30 |     |         }
 31 |     |     }
 32 |     | 
 33 | *   |     function hasAccess(bytes32 feature, address value) internal view returns (bool) {
 34 | *   |         Data storage store = FeatureFlag.load(feature);
 35 |     | 
 36 | *   |         if (store.denyAll) {
 37 |     |             return false;
 38 |     |         }
 39 |     | 
 40 | *   |         return store.allowAll || store.permissionedAddresses.contains(value);
 41 |     |     }
 42 |     | 
 43 |     |     function isDenier(Data storage self, address possibleDenier) internal view returns (bool) {
 44 |     |         for (uint256 i = 0; i < self.deniers.length; i++) {
 45 |     |             if (self.deniers[i] == possibleDenier) {
 46 |     |                 return true;
 47 |     |             }
 48 |     |         }
 49 |     | 
 50 |     |         return false;
 51 |     |     }
 52 |     | }
 53 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/ICollateralConfigurationModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../storage/CollateralConfiguration.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Module for configuring system wide collateral.
  8 |     |  * @notice Allows the owner to configure collaterals at a system wide level.
  9 |     |  */
 10 |     | interface ICollateralConfigurationModule {
 11 |     |     /**
 12 |     |      * @notice Emitted when a collateral type’s configuration is created or updated.
 13 |     |      * @param collateralType The address of the collateral type that was just configured.
 14 |     |      * @param config The object with the newly configured details.
 15 |     |      */
 16 |     |     event CollateralConfigured(address indexed collateralType, CollateralConfiguration.Data config);
 17 |     | 
 18 |     |     /**
 19 |     |      * @notice Creates or updates the configuration for the given `collateralType`.
 20 |     |      * @param config The CollateralConfiguration object describing the new configuration.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - `ERC2771Context._msgSender()` must be the owner of the system.
 25 |     |      *
 26 |     |      * Emits a {CollateralConfigured} event.
 27 |     |      *
 28 |     |      */
 29 |     |     function configureCollateral(CollateralConfiguration.Data memory config) external;
 30 |     | 
 31 |     |     /**
 32 |     |      * @notice Returns a list of detailed information pertaining to all collateral types registered in the system.
 33 |     |      * @dev Optionally returns only those that are currently enabled.
 34 |     |      * @param hideDisabled Wether to hide disabled collaterals or just return the full list of collaterals in the system.
 35 |     |      * @return collaterals The list of collateral configuration objects set in the system.
 36 |     |      */
 37 |     |     function getCollateralConfigurations(
 38 |     |         bool hideDisabled
 39 |     |     ) external view returns (CollateralConfiguration.Data[] memory collaterals);
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Returns detailed information pertaining the specified collateral type.
 43 |     |      * @param collateralType The address for the collateral whose configuration is being queried.
 44 |     |      * @return collateral The configuration object describing the given collateral.
 45 |     |      */
 46 |     |     function getCollateralConfiguration(
 47 |     |         address collateralType
 48 |     |     ) external view returns (CollateralConfiguration.Data memory collateral);
 49 |     | 
 50 |     |     /**
 51 |     |      * @notice Returns the current value of a specified collateral type.
 52 |     |      * @param collateralType The address for the collateral whose price is being queried.
 53 |     |      * @return priceD18 The price of the given collateral, denominated with 18 decimals of precision.
 54 |     |      */
 55 |     |     function getCollateralPrice(address collateralType) external view returns (uint256 priceD18);
 56 |     | }
 57 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/ICollateralModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "../storage/CollateralLock.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title Module for managing user collateral.
   8 |     |  * @notice Allows users to deposit and withdraw collateral from the system.
   9 |     |  */
  10 |     | interface ICollateralModule {
  11 |     |     /**
  12 |     |      * @notice Thrown when an interacting account does not have sufficient collateral for an operation (withdrawal, lock, etc).
  13 |     |      */
  14 |     |     error InsufficientAccountCollateral(uint256 amount);
  15 |     | 
  16 |     |     /**
  17 |     |      * @notice Emitted when `tokenAmount` of collateral of type `collateralType` is deposited to account `accountId` by `sender`.
  18 |     |      * @param accountId The id of the account that deposited collateral.
  19 |     |      * @param collateralType The address of the collateral that was deposited.
  20 |     |      * @param tokenAmount The amount of collateral that was deposited, denominated in the token's native decimal representation.
  21 |     |      * @param sender The address of the account that triggered the deposit.
  22 |     |      */
  23 |     |     event Deposited(
  24 |     |         uint128 indexed accountId,
  25 |     |         address indexed collateralType,
  26 |     |         uint256 tokenAmount,
  27 |     |         address indexed sender
  28 |     |     );
  29 |     | 
  30 |     |     /**
  31 |     |      * @notice Emitted when a lock is created on someone's account
  32 |     |      * @param accountId The id of the account that received a lock
  33 |     |      * @param collateralType The address of the collateral type that was locked
  34 |     |      * @param tokenAmount The amount of collateral that was locked, demoninated in system units (1e18)
  35 |     |      * @param expireTimestamp unix timestamp at which the lock is due to expire
  36 |     |      */
  37 |     |     event CollateralLockCreated(
  38 |     |         uint128 indexed accountId,
  39 |     |         address indexed collateralType,
  40 |     |         uint256 tokenAmount,
  41 |     |         uint64 expireTimestamp
  42 |     |     );
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Emitted when a lock is cleared from an account due to expiration
  46 |     |      * @param accountId The id of the account that has the expired lock
  47 |     |      * @param collateralType The address of the collateral type that was unlocked
  48 |     |      * @param tokenAmount The amount of collateral that was unlocked, demoninated in system units (1e18)
  49 |     |      * @param expireTimestamp unix timestamp at which the unlock is due to expire
  50 |     |      */
  51 |     |     event CollateralLockExpired(
  52 |     |         uint128 indexed accountId,
  53 |     |         address indexed collateralType,
  54 |     |         uint256 tokenAmount,
  55 |     |         uint64 expireTimestamp
  56 |     |     );
  57 |     | 
  58 |     |     /**
  59 |     |      * @notice Emitted when `tokenAmount` of collateral of type `collateralType` is withdrawn from account `accountId` by `sender`.
  60 |     |      * @param accountId The id of the account that withdrew collateral.
  61 |     |      * @param collateralType The address of the collateral that was withdrawn.
  62 |     |      * @param tokenAmount The amount of collateral that was withdrawn, denominated in the token's native decimal representation.
  63 |     |      * @param sender The address of the account that triggered the withdrawal.
  64 |     |      */
  65 |     |     event Withdrawn(
  66 |     |         uint128 indexed accountId,
  67 |     |         address indexed collateralType,
  68 |     |         uint256 tokenAmount,
  69 |     |         address indexed sender
  70 |     |     );
  71 |     | 
  72 |     |     /**
  73 |     |      * @notice Deposits `tokenAmount` of collateral of type `collateralType` into account `accountId`.
  74 |     |      * @dev Anyone can deposit into anyone's active account without restriction.
  75 |     |      * @param accountId The id of the account that is making the deposit.
  76 |     |      * @param collateralType The address of the token to be deposited.
  77 |     |      * @param tokenAmount The amount being deposited, denominated in the token's native decimal representation.
  78 |     |      *
  79 |     |      * Emits a {Deposited} event.
  80 |     |      */
  81 |     |     function deposit(uint128 accountId, address collateralType, uint256 tokenAmount) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @notice Withdraws `tokenAmount` of collateral of type `collateralType` from account `accountId`.
  85 |     |      * @param accountId The id of the account that is making the withdrawal.
  86 |     |      * @param collateralType The address of the token to be withdrawn.
  87 |     |      * @param tokenAmount The amount being withdrawn, denominated in the token's native decimal representation.
  88 |     |      *
  89 |     |      * Requirements:
  90 |     |      *
  91 |     |      * - `ERC2771Context._msgSender()` must be the owner of the account, have the `ADMIN` permission, or have the `WITHDRAW` permission.
  92 |     |      *
  93 |     |      * Emits a {Withdrawn} event.
  94 |     |      *
  95 |     |      */
  96 |     |     function withdraw(uint128 accountId, address collateralType, uint256 tokenAmount) external;
  97 |     | 
  98 |     |     /**
  99 |     |      * @notice Returns the total values pertaining to account `accountId` for `collateralType`.
 100 |     |      * @param accountId The id of the account whose collateral is being queried.
 101 |     |      * @param collateralType The address of the collateral type whose amount is being queried.
 102 |     |      * @return totalDeposited The total collateral deposited in the account, denominated with 18 decimals of precision.
 103 |     |      * @return totalAssigned The amount of collateral in the account that is delegated to pools, denominated with 18 decimals of precision.
 104 |     |      * @return totalLocked The amount of collateral in the account that cannot currently be undelegated from a pool, denominated with 18 decimals of precision.
 105 |     |      */
 106 |     |     function getAccountCollateral(
 107 |     |         uint128 accountId,
 108 |     |         address collateralType
 109 |     |     ) external view returns (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked);
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice Returns the amount of collateral of type `collateralType` deposited with account `accountId` that can be withdrawn or delegated to pools.
 113 |     |      * @param accountId The id of the account whose collateral is being queried.
 114 |     |      * @param collateralType The address of the collateral type whose amount is being queried.
 115 |     |      * @return amountD18 The amount of collateral that is available for withdrawal or delegation, denominated with 18 decimals of precision.
 116 |     |      */
 117 |     |     function getAccountAvailableCollateral(
 118 |     |         uint128 accountId,
 119 |     |         address collateralType
 120 |     |     ) external view returns (uint256 amountD18);
 121 |     | 
 122 |     |     /**
 123 |     |      * @notice Clean expired locks from locked collateral arrays for an account/collateral type. It includes offset and items to prevent gas exhaustion. If both, offset and items, are 0 it will traverse the whole array (unlimited).
 124 |     |      * @param accountId The id of the account whose locks are being cleared.
 125 |     |      * @param collateralType The address of the collateral type to clean locks for.
 126 |     |      * @param offset The index of the first lock to clear.
 127 |     |      * @param count The number of slots to check for cleaning locks. Set to 0 to clean all locks at/after offset
 128 |     |      * @return cleared the number of locks that were actually expired (and therefore cleared)
 129 |     |      */
 130 |     |     function cleanExpiredLocks(
 131 |     |         uint128 accountId,
 132 |     |         address collateralType,
 133 |     |         uint256 offset,
 134 |     |         uint256 count
 135 |     |     ) external returns (uint256 cleared);
 136 |     | 
 137 |     |     /**
 138 |     |      * @notice Get a list of locks existing in account. Lists all locks in storage, even if they are expired
 139 |     |      * @param accountId The id of the account whose locks we want to read
 140 |     |      * @param collateralType The address of the collateral type for locks we want to read
 141 |     |      * @param offset The index of the first lock to read
 142 |     |      * @param count The number of slots to check for cleaning locks. Set to 0 to read all locks after offset
 143 |     |      */
 144 |     |     function getLocks(
 145 |     |         uint128 accountId,
 146 |     |         address collateralType,
 147 |     |         uint256 offset,
 148 |     |         uint256 count
 149 |     |     ) external view returns (CollateralLock.Data[] memory locks);
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice Create a new lock on the given account. you must have `admin` permission on the specified account to create a lock.
 153 |     |      * @dev Collateral can be withdrawn from the system if it is not assigned or delegated to a pool. Collateral locks are an additional restriction that applies on top of that. I.e. if collateral is not assigned to a pool, but has a lock, it cannot be withdrawn.
 154 |     |      * @dev Collateral locks are initially intended for the Synthetix v2 to v3 migration, but may be used in the future by the Spartan Council, for example, to create and hand off accounts whose withdrawals from the system are locked for a given amount of time.
 155 |     |      * @param accountId The id of the account for which a lock is to be created.
 156 |     |      * @param collateralType The address of the collateral type for which the lock will be created.
 157 |     |      * @param amount The amount of collateral tokens to wrap in the lock being created, denominated with 18 decimals of precision.
 158 |     |      * @param expireTimestamp The date in which the lock will become clearable.
 159 |     |      */
 160 |     |     function createLock(
 161 |     |         uint128 accountId,
 162 |     |         address collateralType,
 163 |     |         uint256 amount,
 164 |     |         uint64 expireTimestamp
 165 |     |     ) external;
 166 |     | }
 167 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IMarketCollateralModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Module for allowing markets to directly increase their credit capacity by providing their own collateral.
   6 |     |  */
   7 |     | interface IMarketCollateralModule {
   8 |     |     /**
   9 |     |      * @notice Thrown when a user attempts to deposit more collateral than that allowed by a market.
  10 |     |      */
  11 |     |     error InsufficientMarketCollateralDepositable(
  12 |     |         uint128 marketId,
  13 |     |         address collateralType,
  14 |     |         uint256 tokenAmountToDeposit
  15 |     |     );
  16 |     | 
  17 |     |     /**
  18 |     |      * @notice Thrown when a user attempts to withdraw more collateral from the market than what it has provided.
  19 |     |      */
  20 |     |     error InsufficientMarketCollateralWithdrawable(
  21 |     |         uint128 marketId,
  22 |     |         address collateralType,
  23 |     |         uint256 tokenAmountToWithdraw
  24 |     |     );
  25 |     | 
  26 |     |     /**
  27 |     |      * @notice Emitted when `amount` of collateral of type `collateralType` is deposited to market `marketId` by `sender`.
  28 |     |      * @param marketId The id of the market in which collateral was deposited.
  29 |     |      * @param collateralType The address of the collateral that was directly deposited in the market.
  30 |     |      * @param tokenAmount The amount of tokens that were deposited, denominated in the token's native decimal representation.
  31 |     |      * @param sender The address that triggered the deposit.
  32 |     |      * @param creditCapacity Updated credit capacity of the market after depositing collateral.
  33 |     |      * @param netIssuance Updated net issuance.
  34 |     |      * @param depositedCollateralValue Updated deposited collateral value of the market.
  35 |     |      * @param reportedDebt Updated reported debt of the market after depositing collateral.
  36 |     |      */
  37 |     |     event MarketCollateralDeposited(
  38 |     |         uint128 indexed marketId,
  39 |     |         address indexed collateralType,
  40 |     |         uint256 tokenAmount,
  41 |     |         address indexed sender,
  42 |     |         int128 creditCapacity,
  43 |     |         int128 netIssuance,
  44 |     |         uint256 depositedCollateralValue,
  45 |     |         uint256 reportedDebt
  46 |     |     );
  47 |     | 
  48 |     |     /**
  49 |     |      * @notice Emitted when `amount` of collateral of type `collateralType` is withdrawn from market `marketId` by `sender`.
  50 |     |      * @param marketId The id of the market from which collateral was withdrawn.
  51 |     |      * @param collateralType The address of the collateral that was withdrawn from the market.
  52 |     |      * @param tokenAmount The amount of tokens that were withdrawn, denominated in the token's native decimal representation.
  53 |     |      * @param sender The address that triggered the withdrawal.
  54 |     |      * @param creditCapacity Updated credit capacity of the market after withdrawing.
  55 |     |      * @param netIssuance Updated net issuance.
  56 |     |      * @param depositedCollateralValue Updated deposited collateral value of the market.
  57 |     |      * @param reportedDebt Updated reported debt of the market after withdrawing collateral.
  58 |     |      */
  59 |     |     event MarketCollateralWithdrawn(
  60 |     |         uint128 indexed marketId,
  61 |     |         address indexed collateralType,
  62 |     |         uint256 tokenAmount,
  63 |     |         address indexed sender,
  64 |     |         int128 creditCapacity,
  65 |     |         int128 netIssuance,
  66 |     |         uint256 depositedCollateralValue,
  67 |     |         uint256 reportedDebt
  68 |     |     );
  69 |     | 
  70 |     |     /**
  71 |     |      * @notice Emitted when the system owner specifies the maximum depositable collateral of a given type in a given market.
  72 |     |      * @param marketId The id of the market for which the maximum was configured.
  73 |     |      * @param collateralType The address of the collateral for which the maximum was configured.
  74 |     |      * @param systemAmount The amount to which the maximum was set, denominated with 18 decimals of precision.
  75 |     |      * @param owner The owner of the system, which triggered the configuration change.
  76 |     |      */
  77 |     |     event MaximumMarketCollateralConfigured(
  78 |     |         uint128 indexed marketId,
  79 |     |         address indexed collateralType,
  80 |     |         uint256 systemAmount,
  81 |     |         address indexed owner
  82 |     |     );
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Allows a market to deposit collateral.
  86 |     |      * @param marketId The id of the market in which the collateral was directly deposited.
  87 |     |      * @param collateralType The address of the collateral that was deposited in the market.
  88 |     |      * @param amount The amount of collateral that was deposited, denominated in the token's native decimal representation.
  89 |     |      */
  90 |     |     function depositMarketCollateral(
  91 |     |         uint128 marketId,
  92 |     |         address collateralType,
  93 |     |         uint256 amount
  94 |     |     ) external;
  95 |     | 
  96 |     |     /**
  97 |     |      * @notice Allows a market to withdraw collateral that it has previously deposited.
  98 |     |      * @param marketId The id of the market from which the collateral was withdrawn.
  99 |     |      * @param collateralType The address of the collateral that was withdrawn from the market.
 100 |     |      * @param amount The amount of collateral that was withdrawn, denominated in the token's native decimal representation.
 101 |     |      */
 102 |     |     function withdrawMarketCollateral(
 103 |     |         uint128 marketId,
 104 |     |         address collateralType,
 105 |     |         uint256 amount
 106 |     |     ) external;
 107 |     | 
 108 |     |     /**
 109 |     |      * @notice Allow the system owner to configure the maximum amount of a given collateral type that a specified market is allowed to deposit.
 110 |     |      * @param marketId The id of the market for which the maximum is to be configured.
 111 |     |      * @param collateralType The address of the collateral for which the maximum is to be applied.
 112 |     |      * @param amount The amount that is to be set as the new maximum, denominated with 18 decimals of precision.
 113 |     |      */
 114 |     |     function configureMaximumMarketCollateral(
 115 |     |         uint128 marketId,
 116 |     |         address collateralType,
 117 |     |         uint256 amount
 118 |     |     ) external;
 119 |     | 
 120 |     |     /**
 121 |     |      * @notice Return the total maximum amount of a given collateral type that a specified market is allowed to deposit.
 122 |     |      * @param marketId The id of the market for which the maximum is being queried.
 123 |     |      * @param collateralType The address of the collateral for which the maximum is being queried.
 124 |     |      * @return amountD18 The maximum amount of collateral set for the market, denominated with 18 decimals of precision.
 125 |     |      */
 126 |     |     function getMaximumMarketCollateral(
 127 |     |         uint128 marketId,
 128 |     |         address collateralType
 129 |     |     ) external view returns (uint256 amountD18);
 130 |     | 
 131 |     |     /**
 132 |     |      * @notice Return the total amount of a given collateral type that a specified market has deposited.
 133 |     |      * @param marketId The id of the market for which the directly deposited collateral amount is being queried.
 134 |     |      * @param collateralType The address of the collateral for which the amount is being queried.
 135 |     |      * @return amountD18 The total amount of collateral of this type delegated to the market, denominated with 18 decimals of precision.
 136 |     |      */
 137 |     |     function getMarketCollateralAmount(
 138 |     |         uint128 marketId,
 139 |     |         address collateralType
 140 |     |     ) external view returns (uint256 amountD18);
 141 |     | 
 142 |     |     /**
 143 |     |      * @notice Return the total value of collateral that a specified market has deposited.
 144 |     |      * @param marketId The id of the market for which the directly deposited collateral amount is being queried.
 145 |     |      * @return valueD18 The total value of collateral deposited by the market, denominated with 18 decimals of precision.
 146 |     |      */
 147 |     |     function getMarketCollateralValue(uint128 marketId) external view returns (uint256 valueD18);
 148 |     | }
 149 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IMarketManagerModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC20.sol";
   5 |     | import "./external/IOracleManager.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title System-wide entry point for the management of markets connected to the system.
   9 |     |  */
  10 |     | interface IMarketManagerModule {
  11 |     |     /**
  12 |     |      * @notice Thrown when a market does not have enough liquidity for a withdrawal.
  13 |     |      */
  14 |     |     error NotEnoughLiquidity(uint128 marketId, uint256 amount);
  15 |     | 
  16 |     |     /**
  17 |     |      * @notice Thrown when an attempt to register a market that does not conform to the IMarket interface is made.
  18 |     |      */
  19 |     |     error IncorrectMarketInterface(address market);
  20 |     | 
  21 |     |     /**
  22 |     |      * @notice Emitted when a new market is registered in the system.
  23 |     |      * @param market The address of the external market that was registered in the system.
  24 |     |      * @param marketId The id with which the market was registered in the system.
  25 |     |      * @param sender The account that trigger the registration of the market.
  26 |     |      */
  27 |     |     event MarketRegistered(
  28 |     |         address indexed market,
  29 |     |         uint128 indexed marketId,
  30 |     |         address indexed sender
  31 |     |     );
  32 |     | 
  33 |     |     /**
  34 |     |      * @notice Emitted when a market deposits snxUSD in the system.
  35 |     |      * @param marketId The id of the market that deposited snxUSD in the system.
  36 |     |      * @param target The address of the account that provided the snxUSD in the deposit.
  37 |     |      * @param amount The amount of snxUSD deposited in the system, denominated with 18 decimals of precision.
  38 |     |      * @param market The address of the external market that is depositing.
  39 |     |      * @param creditCapacity Updated credit capacity of the market after depositing.
  40 |     |      * @param netIssuance Updated net issuance.
  41 |     |      * @param depositedCollateralValue Updated deposited collateral value of the market.
  42 |     |      */
  43 |     |     event MarketUsdDeposited(
  44 |     |         uint128 indexed marketId,
  45 |     |         address indexed target,
  46 |     |         uint256 amount,
  47 |     |         address indexed market,
  48 |     |         int128 creditCapacity,
  49 |     |         int128 netIssuance,
  50 |     |         uint256 depositedCollateralValue
  51 |     |     );
  52 |     | 
  53 |     |     /**
  54 |     |      * @notice Emitted when a market withdraws snxUSD from the system.
  55 |     |      * @param marketId The id of the market that withdrew snxUSD from the system.
  56 |     |      * @param target The address of the account that received the snxUSD in the withdrawal.
  57 |     |      * @param amount The amount of snxUSD withdrawn from the system, denominated with 18 decimals of precision.
  58 |     |      * @param market The address of the external market that is withdrawing.
  59 |     |      * @param creditCapacity Updated credit capacity of the market after withdrawing.
  60 |     |      * @param netIssuance Updated net issuance.
  61 |     |      * @param depositedCollateralValue Updated deposited collateral value of the market
  62 |     |      */
  63 |     |     event MarketUsdWithdrawn(
  64 |     |         uint128 indexed marketId,
  65 |     |         address indexed target,
  66 |     |         uint256 amount,
  67 |     |         address indexed market,
  68 |     |         int128 creditCapacity,
  69 |     |         int128 netIssuance,
  70 |     |         uint256 depositedCollateralValue
  71 |     |     );
  72 |     | 
  73 |     |     event MarketSystemFeePaid(uint128 indexed marketId, uint256 feeAmount);
  74 |     | 
  75 |     |     /**
  76 |     |      * @notice Emitted when a market sets an updated minimum delegation time
  77 |     |      * @param marketId The id of the market that the setting is applied to
  78 |     |      * @param minDelegateTime The minimum amount of time between delegation changes
  79 |     |      */
  80 |     |     event SetMinDelegateTime(uint128 indexed marketId, uint32 minDelegateTime);
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice Emitted when a market-specific minimum liquidity ratio is set
  84 |     |      * @param marketId The id of the market that the setting is applied to
  85 |     |      * @param minLiquidityRatio The new market-specific minimum liquidity ratio
  86 |     |      */
  87 |     |     event SetMarketMinLiquidityRatio(uint128 indexed marketId, uint256 minLiquidityRatio);
  88 |     | 
  89 |     |     /**
  90 |     |      * @notice Connects an external market to the system.
  91 |     |      * @dev Creates a Market object to track the external market, and returns the newly created market id.
  92 |     |      * @param market The address of the external market that is to be registered in the system.
  93 |     |      * @return newMarketId The id with which the market will be registered in the system.
  94 |     |      */
  95 |     |     function registerMarket(address market) external returns (uint128 newMarketId);
  96 |     | 
  97 |     |     /**
  98 |     |      * @notice Allows an external market connected to the system to deposit USD in the system.
  99 |     |      * @dev The system burns the incoming USD, increases the market's credit capacity, and reduces its issuance.
 100 |     |      * @dev See `IMarket`.
 101 |     |      * @param marketId The id of the market in which snxUSD will be deposited.
 102 |     |      * @param target The address of the account on who's behalf the deposit will be made.
 103 |     |      * @param amount The amount of snxUSD to be deposited, denominated with 18 decimals of precision.
 104 |     |      * @return feeAmount the amount of fees paid (billed as additional debt towards liquidity providers)
 105 |     |      */
 106 |     |     function depositMarketUsd(
 107 |     |         uint128 marketId,
 108 |     |         address target,
 109 |     |         uint256 amount
 110 |     |     ) external returns (uint256 feeAmount);
 111 |     | 
 112 |     |     /**
 113 |     |      * @notice Allows an external market connected to the system to withdraw snxUSD from the system.
 114 |     |      * @dev The system mints the requested snxUSD (provided that the market has sufficient credit), reduces the market's credit capacity, and increases its net issuance.
 115 |     |      * @dev See `IMarket`.
 116 |     |      * @param marketId The id of the market from which snxUSD will be withdrawn.
 117 |     |      * @param target The address of the account that will receive the withdrawn snxUSD.
 118 |     |      * @param amount The amount of snxUSD to be withdraw, denominated with 18 decimals of precision.
 119 |     |      * @return feeAmount the amount of fees paid (billed as additional debt towards liquidity providers)
 120 |     |      */
 121 |     |     function withdrawMarketUsd(
 122 |     |         uint128 marketId,
 123 |     |         address target,
 124 |     |         uint256 amount
 125 |     |     ) external returns (uint256 feeAmount);
 126 |     | 
 127 |     |     /**
 128 |     |      * @notice Get the amount of fees paid in USD for a call to `depositMarketUsd` and `withdrawMarketUsd` for the given market and amount
 129 |     |      * @param marketId The market to check fees for
 130 |     |      * @param amount The amount deposited or withdrawn in USD
 131 |     |      * @return depositFeeAmount the amount of USD paid for a call to `depositMarketUsd`
 132 |     |      * @return withdrawFeeAmount the amount of USD paid for a call to `withdrawMarketUsd`
 133 |     |      */
 134 |     |     function getMarketFees(
 135 |     |         uint128 marketId,
 136 |     |         uint256 amount
 137 |     |     ) external view returns (uint256 depositFeeAmount, uint256 withdrawFeeAmount);
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Returns the total withdrawable snxUSD amount for the specified market.
 141 |     |      * @param marketId The id of the market whose withdrawable USD amount is being queried.
 142 |     |      * @return withdrawableD18 The total amount of snxUSD that the market could withdraw at the time of the query, denominated with 18 decimals of precision.
 143 |     |      */
 144 |     |     function getWithdrawableMarketUsd(
 145 |     |         uint128 marketId
 146 |     |     ) external view returns (uint256 withdrawableD18);
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice Returns the contract address for the specified market.
 150 |     |      * @param marketId The id of the market
 151 |     |      * @return marketAddress The contract address for the specified market
 152 |     |      */
 153 |     |     function getMarketAddress(uint128 marketId) external view returns (address marketAddress);
 154 |     | 
 155 |     |     /**
 156 |     |      * @notice Returns the net issuance of the specified market (snxUSD withdrawn - snxUSD deposited).
 157 |     |      * @param marketId The id of the market whose net issuance is being queried.
 158 |     |      * @return issuanceD18 The net issuance of the market, denominated with 18 decimals of precision.
 159 |     |      */
 160 |     |     function getMarketNetIssuance(uint128 marketId) external view returns (int128 issuanceD18);
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice Returns the reported debt of the specified market.
 164 |     |      * @param marketId The id of the market whose reported debt is being queried.
 165 |     |      * @return reportedDebtD18 The market's reported debt, denominated with 18 decimals of precision.
 166 |     |      */
 167 |     |     function getMarketReportedDebt(
 168 |     |         uint128 marketId
 169 |     |     ) external view returns (uint256 reportedDebtD18);
 170 |     | 
 171 |     |     /**
 172 |     |      * @notice Returns the total debt of the specified market.
 173 |     |      * @param marketId The id of the market whose debt is being queried.
 174 |     |      * @return totalDebtD18 The total debt of the market, denominated with 18 decimals of precision.
 175 |     |      */
 176 |     |     function getMarketTotalDebt(uint128 marketId) external view returns (int256 totalDebtD18);
 177 |     | 
 178 |     |     /**
 179 |     |      * @notice Returns the total snxUSD value of the collateral for the specified market.
 180 |     |      * @param marketId The id of the market whose collateral is being queried.
 181 |     |      * @return valueD18 The market's total snxUSD value of collateral, denominated with 18 decimals of precision.
 182 |     |      */
 183 |     |     function getMarketCollateral(uint128 marketId) external view returns (uint256 valueD18);
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Returns the value per share of the debt of the specified market.
 187 |     |      * @dev This is not a view function, and actually updates the entire debt distribution chain.
 188 |     |      * @param marketId The id of the market whose debt per share is being queried.
 189 |     |      * @return debtPerShareD18 The market's debt per share value, denominated with 18 decimals of precision.
 190 |     |      */
 191 |     |     function getMarketDebtPerShare(uint128 marketId) external returns (int256 debtPerShareD18);
 192 |     | 
 193 |     |     /**
 194 |     |      * @notice Returns whether the capacity of the specified market is locked.
 195 |     |      * @param marketId The id of the market whose capacity is being queried.
 196 |     |      * @return isLocked A boolean that is true if the market's capacity is locked at the time of the query.
 197 |     |      */
 198 |     |     function isMarketCapacityLocked(uint128 marketId) external view returns (bool isLocked);
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice Returns the USD token associated with this synthetix core system
 202 |     |      */
 203 |     |     function getUsdToken() external view returns (IERC20);
 204 |     | 
 205 |     |     /**
 206 |     |      * @notice Retrieve the systems' configured oracle manager address
 207 |     |      */
 208 |     |     function getOracleManager() external view returns (IOracleManager);
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice Update a market's current debt registration with the system.
 212 |     |      * This function is provided as an escape hatch for pool griefing, preventing
 213 |     |      * overwhelming the system with a series of very small pools and creating high gas
 214 |     |      * costs to update an account.
 215 |     |      * @param marketId the id of the market that needs pools bumped
 216 |     |      * @return finishedDistributing whether or not all bumpable pools have been bumped and target price has been reached
 217 |     |      */
 218 |     |     function distributeDebtToPools(
 219 |     |         uint128 marketId,
 220 |     |         uint256 maxIter
 221 |     |     ) external returns (bool finishedDistributing);
 222 |     | 
 223 |     |     /**
 224 |     |      * @notice allows for a market to set its minimum delegation time. This is useful for preventing stakers from frontrunning rewards or losses
 225 |     |      * by limiting the frequency of `delegateCollateral` (or `setPoolConfiguration`) calls. By default, there is no minimum delegation time.
 226 |     |      * @param marketId the id of the market that wants to set delegation time.
 227 |     |      * @param minDelegateTime the minimum number of seconds between delegation calls. Note: this value must be less than the globally defined maximum minDelegateTime
 228 |     |      */
 229 |     |     function setMarketMinDelegateTime(uint128 marketId, uint32 minDelegateTime) external;
 230 |     | 
 231 |     |     /**
 232 |     |      * @notice Retrieve the minimum delegation time of a market
 233 |     |      * @param marketId the id of the market
 234 |     |      */
 235 |     |     function getMarketMinDelegateTime(uint128 marketId) external view returns (uint32);
 236 |     | 
 237 |     |     /**
 238 |     |      * @notice Allows the system owner (not the pool owner) to set a market-specific minimum liquidity ratio.
 239 |     |      * @param marketId the id of the market
 240 |     |      * @param minLiquidityRatio The new market-specific minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)
 241 |     |      */
 242 |     |     function setMinLiquidityRatio(uint128 marketId, uint256 minLiquidityRatio) external;
 243 |     | 
 244 |     |     /**
 245 |     |      * @notice Retrieves the market-specific minimum liquidity ratio.
 246 |     |      * @param marketId the id of the market
 247 |     |      * @return minRatioD18 The current market-specific minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)
 248 |     |      */
 249 |     |     function getMinLiquidityRatio(uint128 marketId) external view returns (uint256 minRatioD18);
 250 |     | 
 251 |     |     function getMarketPools(
 252 |     |         uint128 marketId
 253 |     |     ) external returns (uint128[] memory inRangePoolIds, uint128[] memory outRangePoolIds);
 254 |     | 
 255 |     |     function getMarketPoolDebtDistribution(
 256 |     |         uint128 marketId,
 257 |     |         uint128 poolId
 258 |     |     ) external returns (uint256 sharesD18, uint128 totalSharesD18, int128 valuePerShareD27);
 259 |     | }
 260 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IPoolModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "../storage/MarketConfiguration.sol";
   5 |     | import "../storage/PoolCollateralConfiguration.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Module for the creation and management of pools.
   9 |     |  * @dev The pool owner can be specified during creation, can be transferred, and has credentials for configuring the pool.
  10 |     |  */
  11 |     | interface IPoolModule {
  12 |     |     /**
  13 |     |      * @notice Thrown when attempting to disconnect a market whose capacity is locked, and whose removal would cause a decrease in its associated pool's credit delegation proportion.
  14 |     |      */
  15 |     |     error CapacityLocked(uint256 marketId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @notice Gets fired when pool will be created.
  19 |     |      * @param poolId The id of the newly created pool.
  20 |     |      * @param owner The owner of the newly created pool.
  21 |     |      * @param sender The address that triggered the creation of the pool.
  22 |     |      */
  23 |     |     event PoolCreated(uint128 indexed poolId, address indexed owner, address indexed sender);
  24 |     | 
  25 |     |     /**
  26 |     |      * @notice Gets fired when pool owner proposes a new owner.
  27 |     |      * @param poolId The id of the pool for which the nomination ocurred.
  28 |     |      * @param nominatedOwner The address that was nominated as the new owner of the pool.
  29 |     |      * @param owner The address of the current owner of the pool.
  30 |     |      */
  31 |     |     event PoolOwnerNominated(
  32 |     |         uint128 indexed poolId,
  33 |     |         address indexed nominatedOwner,
  34 |     |         address indexed owner
  35 |     |     );
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Gets fired when pool nominee accepts nomination.
  39 |     |      * @param poolId The id of the pool for which the owner nomination was accepted.
  40 |     |      * @param owner The address of the new owner of the pool, which accepted the nomination.
  41 |     |      */
  42 |     |     event PoolOwnershipAccepted(uint128 indexed poolId, address indexed owner);
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Gets fired when pool owner revokes nomination.
  46 |     |      * @param poolId The id of the pool in which the nomination was revoked.
  47 |     |      * @param owner The current owner of the pool.
  48 |     |      */
  49 |     |     event PoolNominationRevoked(uint128 indexed poolId, address indexed owner);
  50 |     | 
  51 |     |     /**
  52 |     |      * @notice Gets fired when pool nominee renounces nomination.
  53 |     |      * @param poolId The id of the pool for which the owner nomination was renounced.
  54 |     |      * @param owner The current owner of the pool.
  55 |     |      */
  56 |     |     event PoolNominationRenounced(uint128 indexed poolId, address indexed owner);
  57 |     | 
  58 |     |     /**
  59 |     |      * @notice Gets fired when pool owner renounces his own ownership.
  60 |     |      * @param poolId The id of the pool for which the owner nomination was renounced.
  61 |     |      */
  62 |     |     event PoolOwnershipRenounced(uint128 indexed poolId, address indexed owner);
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Gets fired when pool name changes.
  66 |     |      * @param poolId The id of the pool whose name was updated.
  67 |     |      * @param name The new name of the pool.
  68 |     |      * @param sender The address that triggered the rename of the pool.
  69 |     |      */
  70 |     |     event PoolNameUpdated(uint128 indexed poolId, string name, address indexed sender);
  71 |     | 
  72 |     |     /**
  73 |     |      * @notice Gets fired when pool gets configured.
  74 |     |      * @param poolId The id of the pool whose configuration was set.
  75 |     |      * @param markets Array of configuration data of the markets that were connected to the pool.
  76 |     |      * @param sender The address that triggered the pool configuration.
  77 |     |      */
  78 |     |     event PoolConfigurationSet(
  79 |     |         uint128 indexed poolId,
  80 |     |         MarketConfiguration.Data[] markets,
  81 |     |         address indexed sender
  82 |     |     );
  83 |     | 
  84 |     |     event PoolCollateralConfigurationUpdated(
  85 |     |         uint128 indexed poolId,
  86 |     |         address collateralType,
  87 |     |         PoolCollateralConfiguration.Data config
  88 |     |     );
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice Emitted when a system-wide minimum liquidity ratio is set
  92 |     |      * @param minLiquidityRatio The new system-wide minimum liquidity ratio
  93 |     |      */
  94 |     |     event SetMinLiquidityRatio(uint256 minLiquidityRatio);
  95 |     | 
  96 |     |     /**
  97 |     |      * @notice Allows collaterals accepeted by the system to be accepeted by the pool by default
  98 |     |      * @param poolId The id of the pool.
  99 |     |      * @param disabled Shows if new collateral's will be dsiabled by default for the pool
 100 |     |      */
 101 |     |     event PoolCollateralDisabledByDefaultSet(uint128 poolId, bool disabled);
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice Creates a pool with the requested pool id.
 105 |     |      * @param requestedPoolId The requested id for the new pool. Reverts if the id is not available.
 106 |     |      * @param owner The address that will own the newly created pool.
 107 |     |      */
 108 |     |     function createPool(uint128 requestedPoolId, address owner) external;
 109 |     | 
 110 |     |     /**
 111 |     |      * @notice Allows the pool owner to configure the pool.
 112 |     |      * @dev The pool's configuration is composed of an array of MarketConfiguration objects, which describe which markets the pool provides liquidity to, in what proportion, and to what extent.
 113 |     |      * @dev Incoming market ids need to be provided in ascending order.
 114 |     |      * @param poolId The id of the pool whose configuration is being set.
 115 |     |      * @param marketDistribution The array of market configuration objects that define the list of markets that are connected to the system.
 116 |     |      */
 117 |     |     function setPoolConfiguration(
 118 |     |         uint128 poolId,
 119 |     |         MarketConfiguration.Data[] memory marketDistribution
 120 |     |     ) external;
 121 |     | 
 122 |     |     /**
 123 |     |      * @notice Allows the pool owner to set the configuration of a specific collateral type for their pool.
 124 |     |      * @param poolId The id of the pool whose configuration is being set.
 125 |     |      * @param collateralType The collate
 126 |     |      * @param newConfig The config to set
 127 |     |      */
 128 |     |     function setPoolCollateralConfiguration(
 129 |     |         uint128 poolId,
 130 |     |         address collateralType,
 131 |     |         PoolCollateralConfiguration.Data memory newConfig
 132 |     |     ) external;
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice Retrieves the pool configuration of a specific collateral type.
 136 |     |      * @param poolId The id of the pool whose configuration is being returned.
 137 |     |      * @param collateralType The address of the collateral.
 138 |     |      * @return config The PoolCollateralConfiguration object that describes the requested collateral configuration of the pool.
 139 |     |      */
 140 |     |     function getPoolCollateralConfiguration(
 141 |     |         uint128 poolId,
 142 |     |         address collateralType
 143 |     |     ) external view returns (PoolCollateralConfiguration.Data memory config);
 144 |     | 
 145 |     |     /**
 146 |     |      * @notice Allows collaterals accepeted by the system to be accepeted by the pool by default
 147 |     |      * @param poolId The id of the pool.
 148 |     |      * @param disabled If set to true new collaterals will be disabled for the pool.
 149 |     |      */
 150 |     |     function setPoolCollateralDisabledByDefault(uint128 poolId, bool disabled) external;
 151 |     | 
 152 |     |     /**
 153 |     |      * @notice Retrieves the MarketConfiguration of the specified pool.
 154 |     |      * @param poolId The id of the pool whose configuration is being queried.
 155 |     |      * @return markets The array of MarketConfiguration objects that describe the pool's configuration.
 156 |     |      */
 157 |     |     function getPoolConfiguration(
 158 |     |         uint128 poolId
 159 |     |     ) external view returns (MarketConfiguration.Data[] memory markets);
 160 |     | 
 161 |     |     /**
 162 |     |      * @notice Allows the owner of the pool to set the pool's name.
 163 |     |      * @param poolId The id of the pool whose name is being set.
 164 |     |      * @param name The new name to give to the pool.
 165 |     |      */
 166 |     |     function setPoolName(uint128 poolId, string memory name) external;
 167 |     | 
 168 |     |     /**
 169 |     |      * @notice Returns the pool's name.
 170 |     |      * @param poolId The id of the pool whose name is being queried.
 171 |     |      * @return poolName The current name of the pool.
 172 |     |      */
 173 |     |     function getPoolName(uint128 poolId) external view returns (string memory poolName);
 174 |     | 
 175 |     |     /**
 176 |     |      * @notice Allows the current pool owner to nominate a new owner.
 177 |     |      * @param nominatedOwner The address to nominate os the new pool owner.
 178 |     |      * @param poolId The id whose ownership is being transferred.
 179 |     |      */
 180 |     |     function nominatePoolOwner(address nominatedOwner, uint128 poolId) external;
 181 |     | 
 182 |     |     /**
 183 |     |      * @notice After a new pool owner has been nominated, allows it to accept the nomination and thus ownership of the pool.
 184 |     |      * @param poolId The id of the pool for which the caller is to accept ownership.
 185 |     |      */
 186 |     |     function acceptPoolOwnership(uint128 poolId) external;
 187 |     | 
 188 |     |     /**
 189 |     |      * @notice After a new pool owner has been nominated, allows it to reject the nomination.
 190 |     |      * @param poolId The id of the pool for which the new owner nomination is to be revoked.
 191 |     |      */
 192 |     |     function revokePoolNomination(uint128 poolId) external;
 193 |     | 
 194 |     |     /**
 195 |     |      * @notice Allows the current nominated owner to renounce the nomination.
 196 |     |      * @param poolId The id of the pool for which the caller is renouncing ownership nomination.
 197 |     |      */
 198 |     |     function renouncePoolNomination(uint128 poolId) external;
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice Allows the current owner to renounce his ownership.
 202 |     |      * @param poolId The id of the pool for which the caller is renouncing ownership nomination.
 203 |     |      */
 204 |     |     function renouncePoolOwnership(uint128 poolId) external;
 205 |     | 
 206 |     |     /**
 207 |     |      * @notice Returns the current pool owner.
 208 |     |      * @param poolId The id of the pool whose ownership is being queried.
 209 |     |      * @return owner The current owner of the pool.
 210 |     |      */
 211 |     |     function getPoolOwner(uint128 poolId) external view returns (address owner);
 212 |     | 
 213 |     |     /**
 214 |     |      * @notice Returns the current nominated pool owner.
 215 |     |      * @param poolId The id of the pool whose nominated owner is being queried.
 216 |     |      * @return nominatedOwner The current nominated owner of the pool.
 217 |     |      */
 218 |     |     function getNominatedPoolOwner(uint128 poolId) external view returns (address nominatedOwner);
 219 |     | 
 220 |     |     /**
 221 |     |      * @notice Allows the system owner (not the pool owner) to set the system-wide minimum liquidity ratio.
 222 |     |      * @param minLiquidityRatio The new system-wide minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)
 223 |     |      */
 224 |     |     function setMinLiquidityRatio(uint256 minLiquidityRatio) external;
 225 |     | 
 226 |     |     /**
 227 |     |      @notice returns a pool minimum issuance ratio
 228 |     |      * @param poolId The id of the pool for to check the collateral for.
 229 |     |      * @param collateral The address of the collateral.
 230 |     |      */
 231 |     |     function getPoolCollateralIssuanceRatio(
 232 |     |         uint128 poolId,
 233 |     |         address collateral
 234 |     |     ) external view returns (uint256 issuanceRatioD18);
 235 |     | 
 236 |     |     /**
 237 |     |      * @notice Retrieves the system-wide minimum liquidity ratio.
 238 |     |      * @return minRatioD18 The current system-wide minimum liquidity ratio, denominated with 18 decimals of precision. (100% is represented by 1 followed by 18 zeros.)
 239 |     |      */
 240 |     |     function getMinLiquidityRatio() external view returns (uint256 minRatioD18);
 241 |     | 
 242 |     |     /**
 243 |     |      * @notice Distributes cached debt in a pool to its vaults and updates market credit capacities.
 244 |     |      * @param poolId the pool to rebalance
 245 |     |      * @param optionalCollateralType in addition to rebalancing the pool, calculate updated collaterals and debts for the specified vault
 246 |     |      */
 247 |     |     function rebalancePool(uint128 poolId, address optionalCollateralType) external;
 248 |     | }
 249 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IRewardsManagerModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Module for connecting rewards distributors to vaults.
   6 |     |  */
   7 |     | interface IRewardsManagerModule {
   8 |     |     /**
   9 |     |      * @notice Emitted when a reward distributor returns `false` from `payout` indicating a problem
  10 |     |      * preventing the payout from being executed. In this case, it is advised to check with the
  11 |     |      * project maintainers, and possibly try again in the future.
  12 |     |      * @param distributor the distributor which originated the issue
  13 |     |      */
  14 |     |     error RewardUnavailable(address distributor);
  15 |     | 
  16 |     |     /**
  17 |     |      * @notice Emitted when the pool owner or an existing reward distributor sets up rewards for vault participants.
  18 |     |      * @param poolId The id of the pool on which rewards were distributed.
  19 |     |      * @param collateralType The collateral type of the pool on which rewards were distributed.
  20 |     |      * @param distributor The reward distributor associated to the rewards that were distributed.
  21 |     |      * @param amount The amount of rewards that were distributed.
  22 |     |      * @param start The date one which the rewards will begin to be claimable.
  23 |     |      * @param duration The time in which all of the distributed rewards will be claimable.
  24 |     |      */
  25 |     |     event RewardsDistributed(
  26 |     |         uint128 indexed poolId,
  27 |     |         address indexed collateralType,
  28 |     |         address distributor,
  29 |     |         uint256 amount,
  30 |     |         uint256 start,
  31 |     |         uint256 duration
  32 |     |     );
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Emitted when a vault participant claims rewards.
  36 |     |      * @param accountId The id of the account that claimed the rewards.
  37 |     |      * @param poolId The id of the pool where the rewards were claimed.
  38 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
  39 |     |      * @param distributor The address of the rewards distributor associated with these rewards.
  40 |     |      * @param amount The amount of rewards that were claimed.
  41 |     |      */
  42 |     |     event RewardsClaimed(
  43 |     |         uint128 indexed accountId,
  44 |     |         uint128 indexed poolId,
  45 |     |         address indexed collateralType,
  46 |     |         address distributor,
  47 |     |         uint256 amount
  48 |     |     );
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Emitted when a new rewards distributor is registered.
  52 |     |      * @param poolId The id of the pool whose reward distributor was registered.
  53 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
  54 |     |      * @param distributor The address of the newly registered reward distributor.
  55 |     |      */
  56 |     |     event RewardsDistributorRegistered(
  57 |     |         uint128 indexed poolId,
  58 |     |         address indexed collateralType,
  59 |     |         address indexed distributor
  60 |     |     );
  61 |     | 
  62 |     |     /**
  63 |     |      * @notice Emitted when an already registered rewards distributor is removed.
  64 |     |      * @param poolId The id of the pool whose reward distributor was registered.
  65 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
  66 |     |      * @param distributor The address of the registered reward distributor.
  67 |     |      */
  68 |     |     event RewardsDistributorRemoved(
  69 |     |         uint128 indexed poolId,
  70 |     |         address indexed collateralType,
  71 |     |         address indexed distributor
  72 |     |     );
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Called by pool owner to register rewards for vault participants.
  76 |     |      * @param poolId The id of the pool whose rewards are to be managed by the specified distributor.
  77 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
  78 |     |      * @param distributor The address of the reward distributor to be registered.
  79 |     |      */
  80 |     |     function registerRewardsDistributor(
  81 |     |         uint128 poolId,
  82 |     |         address collateralType,
  83 |     |         address distributor
  84 |     |     ) external;
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Called by pool owner to remove a registered rewards distributor for vault participants.
  88 |     |      * WARNING: if you remove a rewards distributor, the same address can never be re-registered again. If you
  89 |     |      * simply want to turn off
  90 |     |      * rewards, call `distributeRewards` with 0 emission. If you need to completely reset the rewards distributor
  91 |     |      * again, create a new rewards distributor at a new address and register the new one.
  92 |     |      * This function is provided since the number of rewards distributors added to an account is finite,
  93 |     |      * so you can remove an unused rewards distributor if need be.
  94 |     |      * NOTE: unclaimed rewards can still be claimed after a rewards distributor is removed (though any
  95 |     |      * rewards-over-time will be halted)
  96 |     |      * @param poolId The id of the pool whose rewards are to be managed by the specified distributor.
  97 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
  98 |     |      * @param distributor The address of the reward distributor to be registered.
  99 |     |      */
 100 |     |     function removeRewardsDistributor(
 101 |     |         uint128 poolId,
 102 |     |         address collateralType,
 103 |     |         address distributor
 104 |     |     ) external;
 105 |     | 
 106 |     |     /**
 107 |     |      * @notice Called by a registered distributor to set up rewards for vault participants.
 108 |     |      * @dev Will revert if the caller is not a registered distributor.
 109 |     |      * @param poolId The id of the pool to distribute rewards to.
 110 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
 111 |     |      * @param amount The amount of rewards to be distributed.
 112 |     |      * @param start The date at which the rewards will begin to be claimable.
 113 |     |      * @param duration The period after which all distributed rewards will be claimable.
 114 |     |      */
 115 |     |     function distributeRewards(
 116 |     |         uint128 poolId,
 117 |     |         address collateralType,
 118 |     |         uint256 amount,
 119 |     |         uint64 start,
 120 |     |         uint32 duration
 121 |     |     ) external;
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Called by owner of a pool to set rewards for vault participants. This method
 125 |     |      * of reward setting is generally intended to only be used to recover from a case where the
 126 |     |      * distributor state is out of sync with the core system state, or if the distributor is only
 127 |     |      * able to payout and not capable of distributing its own rewards.
 128 |     |      * @dev Will revert if the caller is not the owner of the pool.
 129 |     |      * @param poolId The id of the pool to distribute rewards to.
 130 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
 131 |     |      * @param rewardsDistributor The address of the reward distributor which pays out the tokens.
 132 |     |      * @param amount The amount of rewards to be distributed.
 133 |     |      * @param start The date at which the rewards will begin to be claimable.
 134 |     |      * @param duration The period after which all distributed rewards will be claimable.
 135 |     |      */
 136 |     |     function distributeRewardsByOwner(
 137 |     |         uint128 poolId,
 138 |     |         address collateralType,
 139 |     |         address rewardsDistributor,
 140 |     |         uint256 amount,
 141 |     |         uint64 start,
 142 |     |         uint32 duration
 143 |     |     ) external;
 144 |     | 
 145 |     |     /**
 146 |     |      * @notice Allows a user with appropriate permissions to claim rewards associated with a position.
 147 |     |      * @param accountId The id of the account that is to claim the rewards.
 148 |     |      * @param poolId The id of the pool to claim rewards on.
 149 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
 150 |     |      * @param distributor The address of the rewards distributor associated with the rewards being claimed.
 151 |     |      * @return amountClaimedD18 The amount of rewards that were available for the account and thus claimed.
 152 |     |      */
 153 |     |     function claimRewards(
 154 |     |         uint128 accountId,
 155 |     |         uint128 poolId,
 156 |     |         address collateralType,
 157 |     |         address distributor
 158 |     |     ) external returns (uint256 amountClaimedD18);
 159 |     | 
 160 |     |     /**
 161 |     |      * @notice For a given position, return the rewards that can currently be claimed.
 162 |     |      * @param poolId The id of the pool being queried.
 163 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
 164 |     |      * @param accountId The id of the account whose available rewards are being queried.
 165 |     |      * @return claimableD18 An array of ids of the reward entries that are claimable by the position.
 166 |     |      * @return distributors An array with the addresses of the reward distributors associated with the claimable rewards.
 167 |     |      */
 168 |     |     function updateRewards(
 169 |     |         uint128 poolId,
 170 |     |         address collateralType,
 171 |     |         uint128 accountId
 172 |     |     ) external returns (uint256[] memory claimableD18, address[] memory distributors);
 173 |     | 
 174 |     |     /**
 175 |     |      * @notice Returns the number of individual units of amount emitted per second per share for the given poolId, collateralType, distributor vault.
 176 |     |      * @param poolId The id of the pool being queried.
 177 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
 178 |     |      * @param distributor The address of the rewards distributor associated with the rewards in question.
 179 |     |      * @return rateD18 The queried rewards rate.
 180 |     |      */
 181 |     |     function getRewardRate(
 182 |     |         uint128 poolId,
 183 |     |         address collateralType,
 184 |     |         address distributor
 185 |     |     ) external view returns (uint256 rateD18);
 186 |     | 
 187 |     |     /**
 188 |     |      * @notice Returns the amount of claimable rewards for a given accountId for a vault distributor.
 189 |     |      * @param accountId The id of the account to look up rewards on.
 190 |     |      * @param poolId The id of the pool to claim rewards on.
 191 |     |      * @param collateralType The address of the collateral used in the pool's rewards.
 192 |     |      * @param distributor The address of the rewards distributor associated with the rewards being claimed.
 193 |     |      * @return rewardAmount The amount of available rewards that are available for the provided account.
 194 |     |      */
 195 |     |     function getAvailableRewards(
 196 |     |         uint128 accountId,
 197 |     |         uint128 poolId,
 198 |     |         address collateralType,
 199 |     |         address distributor
 200 |     |     ) external view returns (uint256 rewardAmount);
 201 |     | }
 202 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IUtilsModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {IERC165} from "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title Module with assorted utility functions.
  8 |     |  */
  9 |     | interface IUtilsModule is IERC165 {
 10 |     |     /**
 11 |     |      * @notice Emitted when a new cross chain network becomes supported by the protocol
 12 |     |      */
 13 |     |     event NewSupportedCrossChainNetwork(uint64 newChainId);
 14 |     | 
 15 |     |     /**
 16 |     |      * @notice Configure CCIP addresses on the stablecoin.
 17 |     |      * @param ccipRouter The address on this chain to which CCIP messages will be sent or received.
 18 |     |      * @param ccipTokenPool The address where CCIP fees will be sent to when sending and receiving cross chain messages.
 19 |     |      */
 20 |     |     function configureChainlinkCrossChain(address ccipRouter, address ccipTokenPool) external;
 21 |     | 
 22 |     |     /**
 23 |     |      * @notice Used to add new cross chain networks to the protocol
 24 |     |      * Ignores a network if it matches the current chain id
 25 |     |      * Ignores a network if it has already been added
 26 |     |      * @param supportedNetworks array of all networks that are supported by the protocol
 27 |     |      * @param ccipSelectors the ccip "selector" which maps to the chain id on the same index. must be same length as `supportedNetworks`
 28 |     |      * @return numRegistered the number of networks that were actually registered
 29 |     |      */
 30 |     |     function setSupportedCrossChainNetworks(
 31 |     |         uint64[] memory supportedNetworks,
 32 |     |         uint64[] memory ccipSelectors
 33 |     |     ) external returns (uint256 numRegistered);
 34 |     | 
 35 |     |     /**
 36 |     |      * @notice Configure the system's single oracle manager address.
 37 |     |      * @param oracleManagerAddress The address of the oracle manager.
 38 |     |      */
 39 |     |     function configureOracleManager(address oracleManagerAddress) external;
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Configure a generic value in the KV system
 43 |     |      * @param k the key of the value to set
 44 |     |      * @param v the value that the key should be set to
 45 |     |      */
 46 |     |     function setConfig(bytes32 k, bytes32 v) external;
 47 |     | 
 48 |     |     /**
 49 |     |      * @notice Read a generic value from the KV system
 50 |     |      * @param k the key to read
 51 |     |      * @return v the value set on the specified k
 52 |     |      */
 53 |     |     function getConfig(bytes32 k) external view returns (bytes32 v);
 54 |     | 
 55 |     |     /**
 56 |     |      * @notice Read a UINT value from the KV system
 57 |     |      * @param k the key to read
 58 |     |      * @return v the value set on the specified k
 59 |     |      */
 60 |     |     function getConfigUint(bytes32 k) external view returns (uint256 v);
 61 |     | 
 62 |     |     /**
 63 |     |      * @notice Read a Address value from the KV system
 64 |     |      * @param k the key to read
 65 |     |      * @return v the value set on the specified k
 66 |     |      */
 67 |     |     function getConfigAddress(bytes32 k) external view returns (address v);
 68 |     | 
 69 |     |     /**
 70 |     |      * @notice Checks if the address is the trusted forwarder
 71 |     |      * @param forwarder The address to check
 72 |     |      * @return Whether the address is the trusted forwarder
 73 |     |      */
 74 |     |     function isTrustedForwarder(address forwarder) external pure returns (bool);
 75 |     | 
 76 |     |     /**
 77 |     |      * @notice Provides the address of the trusted forwarder
 78 |     |      * @return Address of the trusted forwarder
 79 |     |      */
 80 |     |     function getTrustedForwarder() external pure returns (address);
 81 |     | }
 82 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/IVaultModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Allows accounts to delegate collateral to a pool.
   6 |     |  * @dev Delegation updates the account's position in the vault that corresponds to the associated pool and collateral type pair.
   7 |     |  * @dev A pool contains one vault for each collateral type it supports, and vaults are not shared between pools.
   8 |     |  */
   9 |     | interface IVaultModule {
  10 |     |     /**
  11 |     |      * @notice Thrown when attempting to delegate collateral to a vault with a leverage amount that is not supported by the system.
  12 |     |      */
  13 |     |     error InvalidLeverage(uint256 leverage);
  14 |     | 
  15 |     |     /**
  16 |     |      * @notice Thrown when attempting to delegate collateral to a market whose capacity is locked.
  17 |     |      */
  18 |     |     error CapacityLocked(uint256 marketId);
  19 |     | 
  20 |     |     /**
  21 |     |      * @notice Thrown when the specified new collateral amount to delegate to the vault equals the current existing amount.
  22 |     |      */
  23 |     |     error InvalidCollateralAmount();
  24 |     | 
  25 |     |     /**
  26 |     |      * @notice Emitted when {sender} updates the delegation of collateral in the specified liquidity position.
  27 |     |      * @param accountId The id of the account whose position was updated.
  28 |     |      * @param poolId The id of the pool in which the position was updated.
  29 |     |      * @param collateralType The address of the collateral associated to the position.
  30 |     |      * @param amount The new amount of the position, denominated with 18 decimals of precision.
  31 |     |      * @param leverage The new leverage value of the position, denominated with 18 decimals of precision.
  32 |     |      * @param sender The address that triggered the update of the position.
  33 |     |      */
  34 |     |     event DelegationUpdated(
  35 |     |         uint128 indexed accountId,
  36 |     |         uint128 indexed poolId,
  37 |     |         address collateralType,
  38 |     |         uint256 amount,
  39 |     |         uint256 leverage,
  40 |     |         address indexed sender
  41 |     |     );
  42 |     | 
  43 |     |     /**
  44 |     |      * @notice Updates an account's delegated collateral amount for the specified pool and collateral type pair.
  45 |     |      * @param accountId The id of the account associated with the position that will be updated.
  46 |     |      * @param poolId The id of the pool associated with the position.
  47 |     |      * @param collateralType The address of the collateral used in the position.
  48 |     |      * @param amount The new amount of collateral delegated in the position, denominated with 18 decimals of precision.
  49 |     |      * @param leverage The new leverage amount used in the position, denominated with 18 decimals of precision.
  50 |     |      *
  51 |     |      * Requirements:
  52 |     |      *
  53 |     |      * - `ERC2771Context._msgSender()` must be the owner of the account, have the `ADMIN` permission, or have the `DELEGATE` permission.
  54 |     |      * - If increasing the amount delegated, it must not exceed the available collateral (`getAccountAvailableCollateral`) associated with the account.
  55 |     |      * - If decreasing the amount delegated, the liquidity position must have a collateralization ratio greater than the target collateralization ratio for the corresponding collateral type.
  56 |     |      *
  57 |     |      * Emits a {DelegationUpdated} event.
  58 |     |      */
  59 |     |     function delegateCollateral(
  60 |     |         uint128 accountId,
  61 |     |         uint128 poolId,
  62 |     |         address collateralType,
  63 |     |         uint256 amount,
  64 |     |         uint256 leverage
  65 |     |     ) external;
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Returns the collateralization ratio of the specified liquidity position. If debt is negative, this function will return 0.
  69 |     |      * @dev Call this function using `callStatic` to treat it as a view function.
  70 |     |      * @dev The return value is a percentage with 18 decimals places.
  71 |     |      * @param accountId The id of the account whose collateralization ratio is being queried.
  72 |     |      * @param poolId The id of the pool in which the account's position is held.
  73 |     |      * @param collateralType The address of the collateral used in the queried position.
  74 |     |      * @return ratioD18 The collateralization ratio of the position (collateral / debt), denominated with 18 decimals of precision.
  75 |     |      */
  76 |     |     function getPositionCollateralRatio(
  77 |     |         uint128 accountId,
  78 |     |         uint128 poolId,
  79 |     |         address collateralType
  80 |     |     ) external returns (uint256 ratioD18);
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice Returns the debt of the specified liquidity position. Credit is expressed as negative debt.
  84 |     |      * @dev This is not a view function, and actually updates the entire debt distribution chain.
  85 |     |      * @dev Call this function using `callStatic` to treat it as a view function.
  86 |     |      * @param accountId The id of the account being queried.
  87 |     |      * @param poolId The id of the pool in which the account's position is held.
  88 |     |      * @param collateralType The address of the collateral used in the queried position.
  89 |     |      * @return debtD18 The amount of debt held by the position, denominated with 18 decimals of precision.
  90 |     |      */
  91 |     |     function getPositionDebt(
  92 |     |         uint128 accountId,
  93 |     |         uint128 poolId,
  94 |     |         address collateralType
  95 |     |     ) external returns (int256 debtD18);
  96 |     | 
  97 |     |     /**
  98 |     |      * @notice Returns the amount of the collateral associated with the specified liquidity position.
  99 |     |      * @dev Call this function using `callStatic` to treat it as a view function.
 100 |     |      * @dev collateralAmount is represented as an integer with 18 decimals.
 101 |     |      * @param accountId The id of the account being queried.
 102 |     |      * @param poolId The id of the pool in which the account's position is held.
 103 |     |      * @param collateralType The address of the collateral used in the queried position.
 104 |     |      * @return collateralAmountD18 The amount of collateral used in the position, denominated with 18 decimals of precision.
 105 |     |      */
 106 |     |     function getPositionCollateral(
 107 |     |         uint128 accountId,
 108 |     |         uint128 poolId,
 109 |     |         address collateralType
 110 |     |     ) external view returns (uint256 collateralAmountD18);
 111 |     | 
 112 |     |     /**
 113 |     |      * @notice Returns all information pertaining to a specified liquidity position in the vault module.
 114 |     |      * @param accountId The id of the account being queried.
 115 |     |      * @param poolId The id of the pool in which the account's position is held.
 116 |     |      * @param collateralType The address of the collateral used in the queried position.
 117 |     |      * @return collateralAmountD18 The amount of collateral used in the position, denominated with 18 decimals of precision.
 118 |     |      * @return collateralValueD18 The value of the collateral used in the position, denominated with 18 decimals of precision.
 119 |     |      * @return debtD18 The amount of debt held in the position, denominated with 18 decimals of precision.
 120 |     |      * @return collateralizationRatioD18 The collateralization ratio of the position (collateral / debt), denominated with 18 decimals of precision.
 121 |     |      **/
 122 |     |     function getPosition(
 123 |     |         uint128 accountId,
 124 |     |         uint128 poolId,
 125 |     |         address collateralType
 126 |     |     )
 127 |     |         external
 128 |     |         returns (
 129 |     |             uint256 collateralAmountD18,
 130 |     |             uint256 collateralValueD18,
 131 |     |             int256 debtD18,
 132 |     |             uint256 collateralizationRatioD18
 133 |     |         );
 134 |     | 
 135 |     |     /**
 136 |     |      * @notice Returns the total debt (or credit) that the vault is responsible for. Credit is expressed as negative debt.
 137 |     |      * @dev This is not a view function, and actually updates the entire debt distribution chain.
 138 |     |      * @dev Call this function using `callStatic` to treat it as a view function.
 139 |     |      * @param poolId The id of the pool that owns the vault whose debt is being queried.
 140 |     |      * @param collateralType The address of the collateral of the associated vault.
 141 |     |      * @return debtD18 The overall debt of the vault, denominated with 18 decimals of precision.
 142 |     |      **/
 143 |     |     function getVaultDebt(uint128 poolId, address collateralType) external returns (int256 debtD18);
 144 |     | 
 145 |     |     /**
 146 |     |      * @notice Returns the amount and value of the collateral held by the vault.
 147 |     |      * @dev Call this function using `callStatic` to treat it as a view function.
 148 |     |      * @dev collateralAmount is represented as an integer with 18 decimals.
 149 |     |      * @dev collateralValue is represented as an integer with the number of decimals specified by the collateralType.
 150 |     |      * @param poolId The id of the pool that owns the vault whose collateral is being queried.
 151 |     |      * @param collateralType The address of the collateral of the associated vault.
 152 |     |      * @return collateralAmountD18 The collateral amount of the vault, denominated with 18 decimals of precision.
 153 |     |      * @return collateralValueD18 The collateral value of the vault, denominated with 18 decimals of precision.
 154 |     |      */
 155 |     |     function getVaultCollateral(
 156 |     |         uint128 poolId,
 157 |     |         address collateralType
 158 |     |     ) external view returns (uint256 collateralAmountD18, uint256 collateralValueD18);
 159 |     | 
 160 |     |     /**
 161 |     |      * @notice Returns the collateralization ratio of the vault. If debt is negative, this function will return 0.
 162 |     |      * @dev Call this function using `callStatic` to treat it as a view function.
 163 |     |      * @dev The return value is a percentage with 18 decimals places.
 164 |     |      * @param poolId The id of the pool that owns the vault whose collateralization ratio is being queried.
 165 |     |      * @param collateralType The address of the collateral of the associated vault.
 166 |     |      * @return ratioD18 The collateralization ratio of the vault, denominated with 18 decimals of precision.
 167 |     |      */
 168 |     |     function getVaultCollateralRatio(
 169 |     |         uint128 poolId,
 170 |     |         address collateralType
 171 |     |     ) external returns (uint256 ratioD18);
 172 |     | }
 173 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/external/IMarket.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
  5 |     | 
  6 |     | /// @title Interface for markets integrated with Synthetix
  7 |     | interface IMarket is IERC165 {
  8 |     |     /// @notice returns a human-readable name for a given market
  9 |     |     function name(uint128 marketId) external view returns (string memory);
 10 |     | 
 11 |     |     /// @notice returns amount of USD that the market would try to mint if everything was withdrawn
 12 |     |     function reportedDebt(uint128 marketId) external view returns (uint256);
 13 |     | 
 14 |     |     /// @notice prevents reduction of available credit capacity by specifying this amount, for which withdrawals will be disallowed
 15 |     |     function minimumCredit(uint128 marketId) external view returns (uint256);
 16 |     | }
 17 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/external/IOracleManager.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
  5 |     | 
  6 |     | /// @title Effective interface for the oracle manager
  7 |     | // solhint-disable-next-line no-empty-blocks
  8 |     | interface IOracleManager is INodeModule {}
  9 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
  5 |     | 
  6 |     | /// @title Interface a reward distributor.
  7 |     | interface IRewardDistributor is IERC165 {
  8 |     |     /// @notice Returns a human-readable name for the reward distributor
  9 |     |     function name() external view returns (string memory);
 10 |     | 
 11 |     |     /// @notice This function should revert if ERC2771Context._msgSender() is not the Synthetix CoreProxy address.
 12 |     |     /// @return whether or not the payout was executed
 13 |     |     function payout(
 14 |     |         uint128 accountId,
 15 |     |         uint128 poolId,
 16 |     |         address collateralType,
 17 |     |         address sender,
 18 |     |         uint256 amount
 19 |     |     ) external returns (bool);
 20 |     | 
 21 |     |     /// @notice This function is called by the Synthetix Core Proxy whenever
 22 |     |     /// a position is updated on a pool which this distributor is registered
 23 |     |     function onPositionUpdated(
 24 |     |         uint128 accountId,
 25 |     |         uint128 poolId,
 26 |     |         address collateralType,
 27 |     |         uint256 newShares
 28 |     |     ) external;
 29 |     | 
 30 |     |     /// @notice Address to ERC-20 token distributed by this distributor, for display purposes only
 31 |     |     /// @dev Return address(0) if providing non ERC-20 rewards
 32 |     |     function token() external view returns (address);
 33 |     | }
 34 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Account.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "./AccountRBAC.sol";
   5 |     | import "./Collateral.sol";
   6 |     | import "./Pool.sol";
   7 |     | 
   8 |     | import "../interfaces/ICollateralModule.sol";
   9 |     | 
  10 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  11 |     | import "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title Object for tracking accounts with access control and collateral tracking.
  15 |     |  */
  16 |     | library Account {
  17 |     |     using AccountRBAC for AccountRBAC.Data;
  18 |     |     using Pool for Pool.Data;
  19 |     |     using Collateral for Collateral.Data;
  20 |     |     using SetUtil for SetUtil.UintSet;
  21 |     |     using SafeCastU128 for uint128;
  22 |     |     using SafeCastU256 for uint256;
  23 |     |     using SafeCastI128 for int128;
  24 |     |     using SafeCastI256 for int256;
  25 |     | 
  26 |     |     /**
  27 |     |      * @dev Thrown when the given target address does not have the given permission with the given account.
  28 |     |      */
  29 |     |     error PermissionDenied(uint128 accountId, bytes32 permission, address target);
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Thrown when an account cannot be found.
  33 |     |      */
  34 |     |     error AccountNotFound(uint128 accountId);
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev Thrown when the requested operation requires an activity timeout before the
  38 |     |      */
  39 |     |     error AccountActivityTimeoutPending(
  40 |     |         uint128 accountId,
  41 |     |         uint256 currentTime,
  42 |     |         uint256 requiredTime
  43 |     |     );
  44 |     | 
  45 |     |     struct Data {
  46 |     |         /**
  47 |     |          * @dev Numeric identifier for the account. Must be unique.
  48 |     |          * @dev There cannot be an account with id zero (See ERC721._mint()).
  49 |     |          */
  50 |     |         uint128 id;
  51 |     |         /**
  52 |     |          * @dev Role based access control data for the account.
  53 |     |          */
  54 |     |         AccountRBAC.Data rbac;
  55 |     |         uint64 lastInteraction;
  56 |     |         uint64 __slotAvailableForFutureUse;
  57 |     |         uint128 __slot2AvailableForFutureUse;
  58 |     |         /**
  59 |     |          * @dev Address set of collaterals that are being used in the system by this account.
  60 |     |          */
  61 |     |         mapping(address => Collateral.Data) collaterals;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev Returns the account stored at the specified account id.
  66 |     |      */
  67 | *   |     function load(uint128 id) internal pure returns (Data storage account) {
  68 | *   |         bytes32 s = keccak256(abi.encode("io.synthetix.synthetix.Account", id));
  69 |     |         assembly {
  70 |     |             account.slot := s
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Creates an account for the given id, and associates it to the given owner.
  76 |     |      *
  77 |     |      * Note: Will not fail if the account already exists, and if so, will overwrite the existing owner. Whatever calls this internal function must first check that the account doesn't exist before re-creating it.
  78 |     |      */
  79 |     |     function create(uint128 id, address owner) internal returns (Data storage account) {
  80 |     |         account = load(id);
  81 |     | 
  82 |     |         account.id = id;
  83 |     |         account.rbac.owner = owner;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Reverts if the account does not exist with appropriate error. Otherwise, returns the account.
  88 |     |      */
  89 | *   |     function exists(uint128 id) internal view returns (Data storage account) {
  90 | *   |         Data storage a = load(id);
  91 | *   |         if (a.rbac.owner == address(0)) {
  92 | *   |             revert AccountNotFound(id);
  93 |     |         }
  94 |     | 
  95 |     |         return a;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Given a collateral type, returns information about the total collateral assigned, deposited, and locked by the account
 100 |     |      */
 101 |     |     function getCollateralTotals(
 102 |     |         Data storage self,
 103 |     |         address collateralType
 104 |     |     )
 105 |     |         internal
 106 |     |         view
 107 |     |         returns (uint256 totalDepositedD18, uint256 totalAssignedD18, uint256 totalLockedD18)
 108 |     |     {
 109 |     |         totalAssignedD18 = getAssignedCollateral(self, collateralType);
 110 |     |         totalDepositedD18 =
 111 |     |             totalAssignedD18 +
 112 |     |             self.collaterals[collateralType].amountAvailableForDelegationD18;
 113 |     |         totalLockedD18 = self.collaterals[collateralType].getTotalLocked();
 114 |     | 
 115 |     |         return (totalDepositedD18, totalAssignedD18, totalLockedD18);
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev Returns the total amount of collateral that has been delegated to pools by the account, for the given collateral type.
 120 |     |      */
 121 |     |     function getAssignedCollateral(
 122 |     |         Data storage self,
 123 |     |         address collateralType
 124 |     |     ) internal view returns (uint256) {
 125 |     |         uint256 totalAssignedD18 = 0;
 126 |     | 
 127 |     |         SetUtil.UintSet storage pools = self.collaterals[collateralType].pools;
 128 |     | 
 129 |     |         for (uint256 i = 1; i <= pools.length(); i++) {
 130 |     |             uint128 poolIdx = pools.valueAt(i).to128();
 131 |     | 
 132 |     |             Pool.Data storage pool = Pool.load(poolIdx);
 133 |     | 
 134 |     |             (uint256 collateralAmountD18, ) = pool.currentAccountCollateral(
 135 |     |                 collateralType,
 136 |     |                 self.id
 137 |     |             );
 138 |     |             totalAssignedD18 += collateralAmountD18;
 139 |     |         }
 140 |     | 
 141 |     |         return totalAssignedD18;
 142 |     |     }
 143 |     | 
 144 | *   |     function recordInteraction(Data storage self) internal {
 145 |     |         // solhint-disable-next-line numcast/safe-cast
 146 | *   |         self.lastInteraction = uint64(block.timestamp);
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Loads the Account object for the specified accountId,
 151 |     |      * and validates that sender has the specified permission. It also resets
 152 |     |      * the interaction timeout. These
 153 |     |      * are different actions but they are merged in a single function
 154 |     |      * because loading an account and checking for a permission is a very
 155 |     |      * common use case in other parts of the code.
 156 |     |      */
 157 | *   |     function loadAccountAndValidatePermission(
 158 |     |         uint128 accountId,
 159 |     |         bytes32 permission
 160 | *   |     ) internal returns (Data storage account) {
 161 | *   |         account = Account.load(accountId);
 162 |     | 
 163 | *   |         if (!account.rbac.authorized(permission, ERC2771Context._msgSender())) {
 164 |     |             revert PermissionDenied(accountId, permission, ERC2771Context._msgSender());
 165 |     |         }
 166 |     | 
 167 | *   |         recordInteraction(account);
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @dev Loads the Account object for the specified accountId,
 172 |     |      * and validates that sender has the specified permission. It also resets
 173 |     |      * the interaction timeout. These
 174 |     |      * are different actions but they are merged in a single function
 175 |     |      * because loading an account and checking for a permission is a very
 176 |     |      * common use case in other parts of the code.
 177 |     |      */
 178 |     |     function loadAccountAndValidatePermissionAndTimeout(
 179 |     |         uint128 accountId,
 180 |     |         bytes32 permission,
 181 |     |         uint256 timeout
 182 |     |     ) internal view returns (Data storage account) {
 183 |     |         account = Account.load(accountId);
 184 |     | 
 185 |     |         if (!account.rbac.authorized(permission, ERC2771Context._msgSender())) {
 186 |     |             revert PermissionDenied(accountId, permission, ERC2771Context._msgSender());
 187 |     |         }
 188 |     | 
 189 |     |         uint256 endWaitingPeriod = account.lastInteraction + timeout;
 190 |     |         if (block.timestamp < endWaitingPeriod) {
 191 |     |             revert AccountActivityTimeoutPending(accountId, block.timestamp, endWaitingPeriod);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Ensure that the account has the required amount of collateral funds remaining
 197 |     |      */
 198 |     |     function requireSufficientCollateral(
 199 |     |         uint128 accountId,
 200 |     |         address collateralType,
 201 |     |         uint256 amountD18
 202 |     |     ) internal view {
 203 |     |         if (
 204 |     |             Account.load(accountId).collaterals[collateralType].amountAvailableForDelegationD18 <
 205 |     |             amountD18
 206 |     |         ) {
 207 |     |             revert ICollateralModule.InsufficientAccountCollateral(amountD18);
 208 |     |         }
 209 |     |     }
 210 |     | }
 211 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/AccountRBAC.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/errors/AddressError.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Object for tracking an accounts permissions (role based access control).
   9 |     |  */
  10 |     | library AccountRBAC {
  11 |     |     using SetUtil for SetUtil.Bytes32Set;
  12 |     |     using SetUtil for SetUtil.AddressSet;
  13 |     | 
  14 |     |     /**
  15 |     |      * @dev All permissions used by the system
  16 |     |      * need to be hardcoded here.
  17 |     |      */
  18 |     |     bytes32 internal constant _ADMIN_PERMISSION = "ADMIN";
  19 |     |     bytes32 internal constant _WITHDRAW_PERMISSION = "WITHDRAW";
  20 |     |     bytes32 internal constant _DELEGATE_PERMISSION = "DELEGATE";
  21 |     |     bytes32 internal constant _MINT_PERMISSION = "MINT";
  22 |     |     bytes32 internal constant _REWARDS_PERMISSION = "REWARDS";
  23 |     |     bytes32 internal constant _PERPS_MODIFY_COLLATERAL_PERMISSION = "PERPS_MODIFY_COLLATERAL";
  24 |     |     bytes32 internal constant _PERPS_COMMIT_ASYNC_ORDER_PERMISSION = "PERPS_COMMIT_ASYNC_ORDER";
  25 |     |     bytes32 internal constant _BURN_PERMISSION = "BURN";
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Thrown when a permission specified by a user does not exist or is invalid.
  29 |     |      */
  30 |     |     error InvalidPermission(bytes32 permission);
  31 |     | 
  32 |     |     struct Data {
  33 |     |         /**
  34 |     |          * @dev The owner of the account and admin of all permissions.
  35 |     |          */
  36 |     |         address owner;
  37 |     |         /**
  38 |     |          * @dev Set of permissions for each address enabled by the account.
  39 |     |          */
  40 |     |         mapping(address => SetUtil.Bytes32Set) permissions;
  41 |     |         /**
  42 |     |          * @dev Array of addresses that this account has given permissions to.
  43 |     |          */
  44 |     |         SetUtil.AddressSet permissionAddresses;
  45 |     |     }
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Reverts if the specified permission is unknown to the account RBAC system.
  49 |     |      */
  50 |     |     function isPermissionValid(bytes32 permission) internal pure {
  51 |     |         if (
  52 |     |             permission != AccountRBAC._WITHDRAW_PERMISSION &&
  53 |     |             permission != AccountRBAC._DELEGATE_PERMISSION &&
  54 |     |             permission != AccountRBAC._MINT_PERMISSION &&
  55 |     |             permission != AccountRBAC._ADMIN_PERMISSION &&
  56 |     |             permission != AccountRBAC._REWARDS_PERMISSION &&
  57 |     |             permission != AccountRBAC._PERPS_MODIFY_COLLATERAL_PERMISSION &&
  58 |     |             permission != AccountRBAC._PERPS_COMMIT_ASYNC_ORDER_PERMISSION &&
  59 |     |             permission != AccountRBAC._BURN_PERMISSION
  60 |     |         ) {
  61 |     |             revert InvalidPermission(permission);
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Sets the owner of the account.
  67 |     |      */
  68 |     |     function setOwner(Data storage self, address owner) internal {
  69 |     |         self.owner = owner;
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Grants a particular permission to the specified target address.
  74 |     |      */
  75 |     |     function grantPermission(Data storage self, bytes32 permission, address target) internal {
  76 |     |         if (target == address(0)) {
  77 |     |             revert AddressError.ZeroAddress();
  78 |     |         }
  79 |     | 
  80 |     |         if (permission == "") {
  81 |     |             revert InvalidPermission("");
  82 |     |         }
  83 |     | 
  84 |     |         if (!self.permissionAddresses.contains(target)) {
  85 |     |             self.permissionAddresses.add(target);
  86 |     |         }
  87 |     | 
  88 |     |         self.permissions[target].add(permission);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Revokes a particular permission from the specified target address.
  93 |     |      */
  94 |     |     function revokePermission(Data storage self, bytes32 permission, address target) internal {
  95 |     |         self.permissions[target].remove(permission);
  96 |     | 
  97 |     |         if (self.permissions[target].length() == 0) {
  98 |     |             self.permissionAddresses.remove(target);
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Revokes all permissions for the specified target address.
 104 |     |      * @notice only removes permissions for the given address, not for the entire account
 105 |     |      */
 106 |     |     function revokeAllPermissions(Data storage self, address target) internal {
 107 |     |         bytes32[] memory permissions = self.permissions[target].values();
 108 |     | 
 109 |     |         if (permissions.length == 0) {
 110 |     |             return;
 111 |     |         }
 112 |     | 
 113 |     |         for (uint256 i = 0; i < permissions.length; i++) {
 114 |     |             self.permissions[target].remove(permissions[i]);
 115 |     |         }
 116 |     | 
 117 |     |         self.permissionAddresses.remove(target);
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Returns wether the specified address has the given permission.
 122 |     |      */
 123 |     |     function hasPermission(
 124 |     |         Data storage self,
 125 |     |         bytes32 permission,
 126 |     |         address target
 127 |     |     ) internal view returns (bool) {
 128 |     |         return target != address(0) && self.permissions[target].contains(permission);
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Returns wether the specified target address has the given permission, or has the high level admin permission.
 133 |     |      */
 134 | *   |     function authorized(
 135 |     |         Data storage self,
 136 |     |         bytes32 permission,
 137 |     |         address target
 138 | *   |     ) internal view returns (bool) {
 139 | *   |         return ((target == self.owner) ||
 140 | *   |             hasPermission(self, _ADMIN_PERMISSION, target) ||
 141 | *   |             hasPermission(self, permission, target));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Collateral.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  5 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  6 |     | 
  7 |     | import "./CollateralLock.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title Stores information about a deposited asset for a given account.
 11 |     |  *
 12 |     |  * Each account will have one of these objects for each type of collateral it deposited in the system.
 13 |     |  */
 14 |     | library Collateral {
 15 |     |     using SafeCastU256 for uint256;
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Thrown when a specified market is not found.
 19 |     |      */
 20 |     |     error InsufficentAvailableCollateral(
 21 |     |         uint256 amountAvailableForDelegationD18,
 22 |     |         uint256 amountD18
 23 |     |     );
 24 |     | 
 25 |     |     struct Data {
 26 |     |         /**
 27 |     |          * @dev The amount that can be withdrawn or delegated in this collateral.
 28 |     |          */
 29 |     |         uint256 amountAvailableForDelegationD18;
 30 |     |         /**
 31 |     |          * @dev The pools to which this collateral delegates to.
 32 |     |          */
 33 |     |         SetUtil.UintSet pools;
 34 |     |         /**
 35 |     |          * @dev Marks portions of the collateral as locked,
 36 |     |          * until a given unlock date.
 37 |     |          *
 38 |     |          * Note: Locks apply to delegated collateral and to collateral not
 39 |     |          * assigned or delegated to a pool (see ICollateralModule).
 40 |     |          */
 41 |     |         CollateralLock.Data[] locks;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Increments the entry's availableCollateral.
 46 |     |      */
 47 |     |     function increaseAvailableCollateral(Data storage self, uint256 amountD18) internal {
 48 |     |         self.amountAvailableForDelegationD18 += amountD18;
 49 |     |     }
 50 |     | 
 51 |     |     /**
 52 |     |      * @dev Decrements the entry's availableCollateral.
 53 |     |      */
 54 |     |     function decreaseAvailableCollateral(Data storage self, uint256 amountD18) internal {
 55 |     |         if (self.amountAvailableForDelegationD18 < amountD18) {
 56 |     |             revert InsufficentAvailableCollateral(self.amountAvailableForDelegationD18, amountD18);
 57 |     |         }
 58 |     |         self.amountAvailableForDelegationD18 -= amountD18;
 59 |     |     }
 60 |     | 
 61 |     |     /**
 62 |     |      * @dev Returns the total amount in this collateral entry that is locked.
 63 |     |      *
 64 |     |      * Sweeps through all existing locks and accumulates their amount,
 65 |     |      * if their unlock date is in the future.
 66 |     |      */
 67 |     |     function getTotalLocked(Data storage self) internal view returns (uint256) {
 68 |     |         uint64 currentTime = block.timestamp.to64();
 69 |     | 
 70 |     |         uint256 lockedD18;
 71 |     |         for (uint256 i = 0; i < self.locks.length; i++) {
 72 |     |             CollateralLock.Data storage lock = self.locks[i];
 73 |     | 
 74 |     |             if (lock.lockExpirationTime > currentTime) {
 75 |     |                 lockedD18 += lock.amountD18;
 76 |     |             }
 77 |     |         }
 78 |     | 
 79 |     |         return lockedD18;
 80 |     |     }
 81 |     | }
 82 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/CollateralConfiguration.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | import "@synthetixio/core-contracts/contracts/errors/ParameterError.sol";
   7 |     | import "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
   8 |     | import "@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol";
   9 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC20.sol";
  10 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  11 |     | 
  12 |     | import "./OracleManager.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title Tracks system-wide settings for each collateral type, as well as helper functions for it, such as retrieving its current price from the oracle manager.
  16 |     |  */
  17 |     | library CollateralConfiguration {
  18 |     |     bytes32 private constant _SLOT_AVAILABLE_COLLATERALS =
  19 |     |         keccak256(
  20 |     |             abi.encode("io.synthetix.synthetix.CollateralConfiguration_availableCollaterals")
  21 |     |         );
  22 |     | 
  23 |     |     using SetUtil for SetUtil.AddressSet;
  24 |     |     using DecimalMath for uint256;
  25 |     |     using SafeCastI256 for int256;
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Thrown when the token address of a collateral cannot be found.
  29 |     |      */
  30 |     |     error CollateralNotFound();
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Thrown when deposits are disabled for the given collateral type.
  34 |     |      * @param collateralType The address of the collateral type for which depositing was disabled.
  35 |     |      */
  36 |     |     error CollateralDepositDisabled(address collateralType);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Thrown when collateral ratio is not sufficient in a given operation in the system.
  40 |     |      * @param collateralValue The net USD value of the position.
  41 |     |      * @param debt The net USD debt of the position.
  42 |     |      * @param ratio The collateralization ratio of the position.
  43 |     |      * @param minRatio The minimum c-ratio which was not met. Could be issuance ratio or liquidation ratio, depending on the case.
  44 |     |      */
  45 |     |     error InsufficientCollateralRatio(
  46 |     |         uint256 collateralValue,
  47 |     |         uint256 debt,
  48 |     |         uint256 ratio,
  49 |     |         uint256 minRatio
  50 |     |     );
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Thrown when the amount being delegated is less than the minimum expected amount.
  54 |     |      * @param minDelegation The current minimum for deposits and delegation set to this collateral type.
  55 |     |      */
  56 |     |     error InsufficientDelegation(uint256 minDelegation);
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Thrown when attempting to convert a token to the system amount and the conversion results in a loss of precision.
  60 |     |      * @param tokenAmount The amount of tokens that were attempted to be converted.
  61 |     |      * @param decimals The number of decimals of the token that was attempted to be converted.
  62 |     |      */
  63 |     |     error PrecisionLost(uint256 tokenAmount, uint8 decimals);
  64 |     | 
  65 |     |     struct Data {
  66 |     |         /**
  67 |     |          * @dev Allows the owner to control deposits and delegation of collateral types.
  68 |     |          */
  69 |     |         bool depositingEnabled;
  70 |     |         /**
  71 |     |          * @dev System-wide collateralization ratio for issuance of snxUSD.
  72 |     |          * Accounts will not be able to mint snxUSD if they are below this issuance c-ratio.
  73 |     |          */
  74 |     |         uint256 issuanceRatioD18;
  75 |     |         /**
  76 |     |          * @dev System-wide collateralization ratio for liquidations of this collateral type.
  77 |     |          * Accounts below this c-ratio can be immediately liquidated.
  78 |     |          */
  79 |     |         uint256 liquidationRatioD18;
  80 |     |         /**
  81 |     |          * @dev Amount of tokens to award when an account is liquidated.
  82 |     |          */
  83 |     |         uint256 liquidationRewardD18;
  84 |     |         /**
  85 |     |          * @dev The oracle manager node id which reports the current price for this collateral type.
  86 |     |          */
  87 |     |         bytes32 oracleNodeId;
  88 |     |         /**
  89 |     |          * @dev The token address for this collateral type.
  90 |     |          */
  91 |     |         address tokenAddress;
  92 |     |         /**
  93 |     |          * @dev Minimum amount that accounts can delegate to pools.
  94 |     |          * Helps prevent spamming on the system.
  95 |     |          * Note: If zero, liquidationRewardD18 will be used.
  96 |     |          */
  97 |     |         uint256 minDelegationD18;
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Loads the CollateralConfiguration object for the given collateral type.
 102 |     |      * @param token The address of the collateral type.
 103 |     |      * @return collateralConfiguration The CollateralConfiguration object.
 104 |     |      */
 105 |     |     function load(address token) internal pure returns (Data storage collateralConfiguration) {
 106 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.synthetix.CollateralConfiguration", token));
 107 |     |         assembly {
 108 |     |             collateralConfiguration.slot := s
 109 |     |         }
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev Loads all available collateral types configured in the system.
 114 |     |      * @return availableCollaterals An array of addresses, one for each collateral type supported by the system.
 115 |     |      */
 116 |     |     function loadAvailableCollaterals()
 117 |     |         internal
 118 |     |         pure
 119 |     |         returns (SetUtil.AddressSet storage availableCollaterals)
 120 |     |     {
 121 |     |         bytes32 s = _SLOT_AVAILABLE_COLLATERALS;
 122 |     |         assembly {
 123 |     |             availableCollaterals.slot := s
 124 |     |         }
 125 |     |     }
 126 |     | 
 127 |     |     /**
 128 |     |      * @dev Configures a collateral type.
 129 |     |      * @param config The CollateralConfiguration object with all the settings for the collateral type being configured.
 130 |     |      */
 131 |     |     function set(Data memory config) internal {
 132 |     |         SetUtil.AddressSet storage collateralTypes = loadAvailableCollaterals();
 133 |     | 
 134 |     |         if (!collateralTypes.contains(config.tokenAddress)) {
 135 |     |             collateralTypes.add(config.tokenAddress);
 136 |     |         }
 137 |     | 
 138 |     |         if (config.minDelegationD18 < config.liquidationRewardD18) {
 139 |     |             revert ParameterError.InvalidParameter(
 140 |     |                 "minDelegation",
 141 |     |                 "must be greater than liquidationReward"
 142 |     |             );
 143 |     |         }
 144 |     | 
 145 |     |         if (config.issuanceRatioD18 <= 1e18) {
 146 |     |             revert ParameterError.InvalidParameter("issuanceRatioD18", "must be greater than 100%");
 147 |     |         }
 148 |     | 
 149 |     |         if (config.liquidationRatioD18 <= 1e18) {
 150 |     |             revert ParameterError.InvalidParameter(
 151 |     |                 "liquidationRatioD18",
 152 |     |                 "must be greater than 100%"
 153 |     |             );
 154 |     |         }
 155 |     | 
 156 |     |         if (config.issuanceRatioD18 < config.liquidationRatioD18) {
 157 |     |             revert ParameterError.InvalidParameter(
 158 |     |                 "issuanceRatioD18",
 159 |     |                 "must be greater than liquidationRatioD18"
 160 |     |             );
 161 |     |         }
 162 |     | 
 163 |     |         Data storage storedConfig = load(config.tokenAddress);
 164 |     | 
 165 |     |         storedConfig.tokenAddress = config.tokenAddress;
 166 |     |         storedConfig.issuanceRatioD18 = config.issuanceRatioD18;
 167 |     |         storedConfig.liquidationRatioD18 = config.liquidationRatioD18;
 168 |     |         storedConfig.oracleNodeId = config.oracleNodeId;
 169 |     |         storedConfig.liquidationRewardD18 = config.liquidationRewardD18;
 170 |     |         storedConfig.minDelegationD18 = config.minDelegationD18;
 171 |     |         storedConfig.depositingEnabled = config.depositingEnabled;
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Shows if a given collateral type is enabled for deposits and delegation.
 176 |     |      * @param token The address of the collateral being queried.
 177 |     |      */
 178 |     |     function collateralEnabled(address token) internal view {
 179 |     |         if (!load(token).depositingEnabled) {
 180 |     |             revert CollateralDepositDisabled(token);
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev Reverts if the amount being delegated is insufficient for the system.
 186 |     |      * @param token The address of the collateral type.
 187 |     |      * @param amountD18 The amount being checked for sufficient delegation.
 188 |     |      */
 189 |     |     function requireSufficientDelegation(address token, uint256 amountD18) internal view {
 190 |     |         CollateralConfiguration.Data storage config = load(token);
 191 |     | 
 192 |     |         uint256 minDelegationD18 = config.minDelegationD18;
 193 |     | 
 194 |     |         if (minDelegationD18 == 0) {
 195 |     |             minDelegationD18 = config.liquidationRewardD18;
 196 |     |         }
 197 |     | 
 198 |     |         if (amountD18 < minDelegationD18) {
 199 |     |             revert InsufficientDelegation(minDelegationD18);
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /**
 204 |     |      * @dev Returns the price of this collateral configuration object.
 205 |     |      * @param self The CollateralConfiguration object.
 206 |     |      * @param collateralAmount The amount of collateral to get the price for.
 207 |     |      * @return The price of the collateral with 18 decimals of precision.
 208 |     |      */
 209 |     |     function getCollateralPrice(
 210 |     |         Data storage self,
 211 |     |         uint256 collateralAmount
 212 |     |     ) internal view returns (uint256) {
 213 |     |         OracleManager.Data memory oracleManager = OracleManager.load();
 214 |     | 
 215 |     |         bytes32[] memory runtimeKeys = new bytes32[](1);
 216 |     |         bytes32[] memory runtimeValues = new bytes32[](1);
 217 |     |         runtimeKeys[0] = bytes32("size");
 218 |     |         runtimeValues[0] = bytes32(collateralAmount);
 219 |     |         NodeOutput.Data memory node = INodeModule(oracleManager.oracleManagerAddress)
 220 |     |             .processWithRuntime(self.oracleNodeId, runtimeKeys, runtimeValues);
 221 |     | 
 222 |     |         return node.price.toUint();
 223 |     |     }
 224 |     | 
 225 |     |     /**
 226 |     |      * @dev Reverts if the specified collateral and debt values produce a collateralization ratio which is below the amount required for new issuance of snxUSD.
 227 |     |      * @param self The CollateralConfiguration object whose collateral and settings are being queried.
 228 |     |      * @param debtD18 The debt component of the ratio.
 229 |     |      * @param collateralValueD18 The collateral component of the ratio.
 230 |     |      */
 231 |     |     function verifyIssuanceRatio(
 232 |     |         Data storage self,
 233 |     |         uint256 debtD18,
 234 |     |         uint256 collateralValueD18,
 235 |     |         uint256 minIssuanceRatioD18
 236 |     |     ) internal view {
 237 |     |         uint256 issuanceRatioD18 = self.issuanceRatioD18 > minIssuanceRatioD18
 238 |     |             ? self.issuanceRatioD18
 239 |     |             : minIssuanceRatioD18;
 240 |     | 
 241 |     |         if (
 242 |     |             debtD18 != 0 &&
 243 |     |             (collateralValueD18 == 0 || collateralValueD18.divDecimal(debtD18) < issuanceRatioD18)
 244 |     |         ) {
 245 |     |             revert InsufficientCollateralRatio(
 246 |     |                 collateralValueD18,
 247 |     |                 debtD18,
 248 |     |                 collateralValueD18.divDecimal(debtD18),
 249 |     |                 issuanceRatioD18
 250 |     |             );
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @dev Converts token amounts with non-system decimal precisions, to 18 decimals of precision.
 256 |     |      * E.g: $TOKEN_A uses 6 decimals of precision, so this would upscale it by 12 decimals.
 257 |     |      * E.g: $TOKEN_B uses 20 decimals of precision, so this would downscale it by 2 decimals.
 258 |     |      * @param self The CollateralConfiguration object corresponding to the collateral type being converted.
 259 |     |      * @param tokenAmount The token amount, denominated in its native decimal precision.
 260 |     |      * @return amountD18 The converted amount, denominated in the system's 18 decimal precision.
 261 |     |      */
 262 |     |     function convertTokenToSystemAmount(
 263 |     |         Data storage self,
 264 |     |         uint256 tokenAmount
 265 |     |     ) internal view returns (uint256 amountD18) {
 266 |     |         // this extra condition is to prevent potentially malicious untrusted code from being executed on the next statement
 267 |     |         if (self.tokenAddress == address(0)) {
 268 |     |             revert CollateralNotFound();
 269 |     |         }
 270 |     | 
 271 |     |         /// @dev this try-catch block assumes there is no malicious code in the token's fallback function
 272 |     |         try IERC20(self.tokenAddress).decimals() returns (uint8 decimals) {
 273 |     |             if (decimals == 18) {
 274 |     |                 amountD18 = tokenAmount;
 275 |     |             } else if (decimals < 18) {
 276 |     |                 amountD18 = (tokenAmount * DecimalMath.UNIT) / (10 ** decimals);
 277 |     |             } else {
 278 |     |                 // ensure no precision is lost when converting to 18 decimals
 279 |     |                 if (tokenAmount % (10 ** (decimals - 18)) != 0) {
 280 |     |                     revert PrecisionLost(tokenAmount, decimals);
 281 |     |                 }
 282 |     | 
 283 |     |                 // this will scale down the amount by the difference between the token's decimals and 18
 284 |     |                 amountD18 = (tokenAmount * DecimalMath.UNIT) / (10 ** decimals);
 285 |     |             }
 286 |     |         } catch {
 287 |     |             // if the token doesn't have a decimals function, assume it's 18 decimals
 288 |     |             amountD18 = tokenAmount;
 289 |     |         }
 290 |     |     }
 291 |     | }
 292 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/CollateralLock.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Represents a given amount of collateral locked until a given date.
  6 |     |  */
  7 |     | library CollateralLock {
  8 |     |     struct Data {
  9 |     |         /**
 10 |     |          * @dev The amount of collateral that has been locked.
 11 |     |          */
 12 |     |         uint128 amountD18;
 13 |     |         /**
 14 |     |          * @dev The date when the locked amount becomes unlocked.
 15 |     |          */
 16 |     |         uint64 lockExpirationTime;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Config.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title System wide configuration for anything
  6 |     |  */
  7 |     | library Config {
  8 |     |     struct Data {
  9 |     |         uint256 __unused;
 10 |     |     }
 11 |     | 
 12 |     |     /**
 13 |     |      * @dev Returns a config value
 14 |     |      */
 15 |     |     function read(bytes32 k, bytes32 zeroValue) internal view returns (bytes32 v) {
 16 |     |         bytes32 s = keccak256(abi.encode("Config", k));
 17 |     |         assembly {
 18 |     |             v := sload(s)
 19 |     |         }
 20 |     | 
 21 |     |         if (v == bytes32(0)) {
 22 |     |             v = zeroValue;
 23 |     |         }
 24 |     |     }
 25 |     | 
 26 |     |     function readUint(bytes32 k, uint256 zeroValue) internal view returns (uint256 v) {
 27 |     |         // solhint-disable-next-line numcast/safe-cast
 28 |     |         return uint(read(k, bytes32(zeroValue)));
 29 |     |     }
 30 |     | 
 31 |     |     function readAddress(bytes32 k, address zeroValue) internal view returns (address v) {
 32 |     |         // solhint-disable-next-line numcast/safe-cast
 33 |     |         return address(uint160(readUint(k, uint160(zeroValue))));
 34 |     |     }
 35 |     | 
 36 |     |     function put(bytes32 k, bytes32 v) internal {
 37 |     |         bytes32 s = keccak256(abi.encode("Config", k));
 38 |     |         assembly {
 39 |     |             sstore(s, v)
 40 |     |         }
 41 |     |     }
 42 |     | }
 43 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Distribution.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   6 |     | 
   7 |     | import "./DistributionActor.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title Data structure that allows you to track some global value, distributed amongst a set of actors.
  11 |     |  *
  12 |     |  * The total value can be scaled with a valuePerShare multiplier, and individual actor shares can be calculated as their amount of shares times this multiplier.
  13 |     |  *
  14 |     |  * Furthermore, changes in the value of individual actors can be tracked since their last update, by keeping track of the value of the multiplier, per user, upon each interaction. See DistributionActor.lastValuePerShare.
  15 |     |  *
  16 |     |  * A distribution is similar to a ScalableMapping, but it has the added functionality of being able to remember the previous value of the scalar multiplier for each actor.
  17 |     |  *
  18 |     |  * Whenever the shares of an actor of the distribution is updated, you get information about how the actor's total value changed since it was last updated.
  19 |     |  */
  20 |     | library Distribution {
  21 |     |     using SafeCastU128 for uint128;
  22 |     |     using SafeCastU256 for uint256;
  23 |     |     using SafeCastI128 for int128;
  24 |     |     using SafeCastI256 for int256;
  25 |     |     using DecimalMath for int256;
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Thrown when an attempt is made to distribute value to a distribution
  29 |     |      * with no shares.
  30 |     |      */
  31 |     |     error EmptyDistribution();
  32 |     | 
  33 |     |     struct Data {
  34 |     |         /**
  35 |     |          * @dev The total number of shares in the distribution.
  36 |     |          */
  37 |     |         uint128 totalSharesD18;
  38 |     |         /**
  39 |     |          * @dev The value per share of the distribution, represented as a high precision decimal.
  40 |     |          */
  41 |     |         int128 valuePerShareD27;
  42 |     |         /**
  43 |     |          * @dev Tracks individual actor information, such as how many shares an actor has, their lastValuePerShare, etc.
  44 |     |          */
  45 |     |         mapping(bytes32 => DistributionActor.Data) actorInfo;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Inflates or deflates the total value of the distribution by the given value.
  50 |     |      *
  51 |     |      * The value being distributed ultimately modifies the distribution's valuePerShare.
  52 |     |      */
  53 |     |     function distributeValue(Data storage self, int256 valueD18) internal {
  54 |     |         if (valueD18 == 0) {
  55 |     |             return;
  56 |     |         }
  57 |     | 
  58 |     |         uint256 totalSharesD18 = self.totalSharesD18;
  59 |     | 
  60 |     |         if (totalSharesD18 == 0) {
  61 |     |             revert EmptyDistribution();
  62 |     |         }
  63 |     | 
  64 |     |         int256 valueD45 = valueD18 * DecimalMath.UNIT_PRECISE_INT;
  65 |     |         int256 deltaValuePerShareD27 = valueD45 / totalSharesD18.toInt();
  66 |     | 
  67 |     |         self.valuePerShareD27 += deltaValuePerShareD27.to128();
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Updates an actor's number of shares in the distribution to the specified amount.
  72 |     |      *
  73 |     |      * Whenever an actor's shares are changed in this way, we record the distribution's current valuePerShare into the actor's lastValuePerShare record.
  74 |     |      *
  75 |     |      * Returns the the amount by which the actors value changed since the last update.
  76 |     |      */
  77 |     |     function setActorShares(
  78 |     |         Data storage self,
  79 |     |         bytes32 actorId,
  80 |     |         uint256 newActorSharesD18
  81 |     |     ) internal returns (int256 valueChangeD18) {
  82 |     |         valueChangeD18 = getActorValueChange(self, actorId);
  83 |     | 
  84 |     |         DistributionActor.Data storage actor = self.actorInfo[actorId];
  85 |     | 
  86 |     |         uint128 sharesUint128D18 = newActorSharesD18.to128();
  87 |     |         self.totalSharesD18 = self.totalSharesD18 + sharesUint128D18 - actor.sharesD18;
  88 |     | 
  89 |     |         actor.sharesD18 = sharesUint128D18;
  90 |     |         _updateLastValuePerShare(self, actor, newActorSharesD18);
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Updates an actor's lastValuePerShare to the distribution's current valuePerShare, and
  95 |     |      * returns the change in value for the actor, since their last update.
  96 |     |      */
  97 |     |     function accumulateActor(
  98 |     |         Data storage self,
  99 |     |         bytes32 actorId
 100 |     |     ) internal returns (int256 valueChangeD18) {
 101 |     |         DistributionActor.Data storage actor = self.actorInfo[actorId];
 102 |     |         return _updateLastValuePerShare(self, actor, actor.sharesD18);
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev Calculates how much an actor's value has changed since its shares were last updated.
 107 |     |      *
 108 |     |      * This change is calculated as:
 109 |     |      * Since `value = valuePerShare * shares`,
 110 |     |      * then `delta_value = valuePerShare_now * shares - valuePerShare_then * shares`,
 111 |     |      * which is `(valuePerShare_now - valuePerShare_then) * shares`,
 112 |     |      * or just `delta_valuePerShare * shares`.
 113 |     |      */
 114 |     |     function getActorValueChange(
 115 |     |         Data storage self,
 116 |     |         bytes32 actorId
 117 |     |     ) internal view returns (int256 valueChangeD18) {
 118 |     |         return _getActorValueChange(self, self.actorInfo[actorId]);
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Returns the number of shares owned by an actor in the distribution.
 123 |     |      */
 124 |     |     function getActorShares(
 125 |     |         Data storage self,
 126 |     |         bytes32 actorId
 127 |     |     ) internal view returns (uint256 sharesD18) {
 128 |     |         return self.actorInfo[actorId].sharesD18;
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Returns the distribution's value per share in normal precision (18 decimals).
 133 |     |      * @param self The distribution whose value per share is being queried.
 134 |     |      * @return The value per share in 18 decimal precision.
 135 |     |      */
 136 |     |     function getValuePerShare(Data storage self) internal view returns (int256) {
 137 |     |         return self.valuePerShareD27.to256().downscale(DecimalMath.PRECISION_FACTOR);
 138 |     |     }
 139 |     | 
 140 |     |     function _updateLastValuePerShare(
 141 |     |         Data storage self,
 142 |     |         DistributionActor.Data storage actor,
 143 |     |         uint256 newActorShares
 144 |     |     ) private returns (int256 valueChangeD18) {
 145 |     |         valueChangeD18 = _getActorValueChange(self, actor);
 146 |     | 
 147 |     |         actor.lastValuePerShareD27 = newActorShares == 0
 148 |     |             ? SafeCastI128.zero()
 149 |     |             : self.valuePerShareD27;
 150 |     |     }
 151 |     | 
 152 |     |     function _getActorValueChange(
 153 |     |         Data storage self,
 154 |     |         DistributionActor.Data storage actor
 155 |     |     ) private view returns (int256 valueChangeD18) {
 156 |     |         int256 deltaValuePerShareD27 = self.valuePerShareD27 - actor.lastValuePerShareD27;
 157 |     | 
 158 |     |         int256 changedValueD45 = deltaValuePerShareD27 * actor.sharesD18.toInt();
 159 |     |         valueChangeD18 = changedValueD45 / DecimalMath.UNIT_PRECISE_INT;
 160 |     |     }
 161 |     | }
 162 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/DistributionActor.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Stores information for specific actors in a Distribution.
  6 |     |  */
  7 |     | library DistributionActor {
  8 |     |     struct Data {
  9 |     |         /**
 10 |     |          * @dev The actor's current number of shares in the associated distribution.
 11 |     |          */
 12 |     |         uint128 sharesD18;
 13 |     |         /**
 14 |     |          * @dev The value per share that the associated distribution had at the time that the actor's number of shares was last modified.
 15 |     |          *
 16 |     |          * Note: This is also a high precision decimal. See Distribution.valuePerShare.
 17 |     |          */
 18 |     |         int128 lastValuePerShareD27;
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Market.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/HeapUtil.sol";
   5 |     | 
   6 |     | import "./Distribution.sol";
   7 |     | import "./CollateralConfiguration.sol";
   8 |     | import "./MarketPoolInfo.sol";
   9 |     | 
  10 |     | import "../interfaces/external/IMarket.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @title Connects external contracts that implement the `IMarket` interface to the system.
  14 |     |  *
  15 |     |  * Pools provide credit capacity (collateral) to the markets, and are reciprocally exposed to the associated market's debt.
  16 |     |  *
  17 |     |  * The Market object's main responsibility is to track collateral provided by the pools that support it, and to trace their debt back to such pools.
  18 |     |  */
  19 |     | library Market {
  20 |     |     using Distribution for Distribution.Data;
  21 |     |     using HeapUtil for HeapUtil.Data;
  22 |     |     using DecimalMath for uint256;
  23 |     |     using DecimalMath for uint128;
  24 |     |     using DecimalMath for int256;
  25 |     |     using DecimalMath for int128;
  26 |     |     using SafeCastU256 for uint256;
  27 |     |     using SafeCastU128 for uint128;
  28 |     |     using SafeCastI256 for int256;
  29 |     |     using SafeCastI128 for int128;
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Thrown when a specified market is not found.
  33 |     |      */
  34 |     |     error MarketNotFound(uint128 marketId);
  35 |     | 
  36 |     |     struct Data {
  37 |     |         /**
  38 |     |          * @dev Numeric identifier for the market. Must be unique.
  39 |     |          * @dev There cannot be a market with id zero (See MarketCreator.create()). Id zero is used as a null market reference.
  40 |     |          */
  41 |     |         uint128 id;
  42 |     |         /**
  43 |     |          * @dev Address for the external contract that implements the `IMarket` interface, which this Market objects connects to.
  44 |     |          *
  45 |     |          * Note: This object is how the system tracks the market. The actual market is external to the system, i.e. its own contract.
  46 |     |          */
  47 |     |         address marketAddress;
  48 |     |         /**
  49 |     |          * @dev Issuance can be seen as how much USD the Market "has issued", printed, or has asked the system to mint on its behalf.
  50 |     |          *
  51 |     |          * More precisely it can be seen as the net difference between the USD burnt and the USD minted by the market.
  52 |     |          *
  53 |     |          * More issuance means that the market owes more USD to the system.
  54 |     |          *
  55 |     |          * A market burns USD when users deposit it in exchange for some asset that the market offers.
  56 |     |          * The Market object calls `MarketManager.depositUSD()`, which burns the USD, and decreases its issuance.
  57 |     |          *
  58 |     |          * A market mints USD when users return the asset that the market offered and thus withdraw their USD.
  59 |     |          * The Market object calls `MarketManager.withdrawUSD()`, which mints the USD, and increases its issuance.
  60 |     |          *
  61 |     |          * Instead of burning, the Market object could transfer USD to and from the MarketManager, but minting and burning takes the USD out of circulation, which doesn't affect `totalSupply`, thus simplifying accounting.
  62 |     |          *
  63 |     |          * How much USD a market can mint depends on how much credit capacity is given to the market by the pools that support it, and reflected in `Market.capacity`.
  64 |     |          *
  65 |     |          */
  66 |     |         int128 netIssuanceD18;
  67 |     |         /**
  68 |     |          * @dev The total amount of USD that the market could withdraw if it were to immediately unwrap all its positions.
  69 |     |          *
  70 |     |          * The Market's credit capacity increases when the market burns USD, i.e. when it deposits USD in the MarketManager.
  71 |     |          *
  72 |     |          * It decreases when the market mints USD, i.e. when it withdraws USD from the MarketManager.
  73 |     |          *
  74 |     |          * The Market's credit capacity also depends on how much credit is given to it by the pools that support it.
  75 |     |          *
  76 |     |          * The Market's credit capacity also has a dependency on the external market reported debt as it will respond to that debt (and hence change the credit capacity if it increases or decreases)
  77 |     |          *
  78 |     |          * The credit capacity can go negative if all of the collateral provided by pools is exhausted, and there is market provided collateral available to consume. in this case, the debt is still being
  79 |     |          * appropriately assigned, but the market has a dynamic cap based on deposited collateral types.
  80 |     |          *
  81 |     |          */
  82 |     |         int128 creditCapacityD18;
  83 |     |         /**
  84 |     |          * @dev The total balance that the market had the last time that its debt was distributed.
  85 |     |          *
  86 |     |          * A Market's debt is distributed when the reported debt of its associated external market is rolled into the pools that provide credit capacity to it.
  87 |     |          */
  88 |     |         int128 lastDistributedMarketBalanceD18;
  89 |     |         /**
  90 |     |          * @dev A heap of pools for which the market has not yet hit its maximum credit capacity.
  91 |     |          *
  92 |     |          * The heap is ordered according to this market's max value per share setting in the pools that provide credit capacity to it. See `MarketConfiguration.maxDebtShareValue`.
  93 |     |          *
  94 |     |          * The heap's getMax() and extractMax() functions allow us to retrieve the pool with the lowest `maxDebtShareValue`, since its elements are inserted and prioritized by negating their `maxDebtShareValue`.
  95 |     |          *
  96 |     |          * Lower max values per share are on the top of the heap. I.e. the heap could look like this:
  97 |     |          *  .    -1
  98 |     |          *      / \
  99 |     |          *     /   \
 100 |     |          *    -2    \
 101 |     |          *   / \    -3
 102 |     |          * -4   -5
 103 |     |          *
 104 |     |          * TL;DR: This data structure allows us to easily find the pool with the lowest or "most vulnerable" max value per share and process it if its actual value per share goes beyond this limit.
 105 |     |          */
 106 |     |         HeapUtil.Data inRangePools;
 107 |     |         /**
 108 |     |          * @dev A heap of pools for which the market has hit its maximum credit capacity.
 109 |     |          *
 110 |     |          * Used to reconnect pools to the market, when it falls back below its maximum credit capacity.
 111 |     |          *
 112 |     |          * See inRangePools for why a heap is used here.
 113 |     |          */
 114 |     |         HeapUtil.Data outRangePools;
 115 |     |         /**
 116 |     |          * @dev A market's debt distribution connects markets to the debt distribution chain, in this case pools. Pools are actors in the market's debt distribution, where the amount of shares they possess depends on the amount of collateral they provide to the market. The value per share of this distribution depends on the total debt or balance of the market (netIssuance + reportedDebt).
 117 |     |          *
 118 |     |          * The debt distribution chain will move debt from the market into its connected pools.
 119 |     |          *
 120 |     |          * Actors: Pools.
 121 |     |          * Shares: The USD denominated credit capacity that the pool provides to the market.
 122 |     |          * Value per share: Debt per dollar of credit that the associated external market accrues.
 123 |     |          *
 124 |     |          */
 125 |     |         Distribution.Data poolsDebtDistribution;
 126 |     |         /**
 127 |     |          * @dev Additional info needed to remember pools when they are removed from the distribution (or subsequently re-added).
 128 |     |          */
 129 |     |         mapping(uint128 => MarketPoolInfo.Data) pools;
 130 |     |         /**
 131 |     |          * @dev Array of entries of market provided collateral.
 132 |     |          *
 133 |     |          * Markets may obtain additional liquidity, beyond that coming from depositors, by providing their own collateral.
 134 |     |          *
 135 |     |          */
 136 |     |         DepositedCollateral[] depositedCollateral;
 137 |     |         /**
 138 |     |          * @dev The maximum amount of market provided collateral, per type, that this market can deposit.
 139 |     |          */
 140 |     |         mapping(address => uint256) maximumDepositableD18;
 141 |     |         uint32 minDelegateTime;
 142 |     |         uint32 __reservedForLater1;
 143 |     |         uint64 __reservedForLater2;
 144 |     |         uint64 __reservedForLater3;
 145 |     |         uint64 __reservedForLater4;
 146 |     |         /**
 147 |     |          * @dev Market-specific override of the minimum liquidity ratio
 148 |     |          */
 149 |     |         uint256 minLiquidityRatioD18;
 150 |     |     }
 151 |     | 
 152 |     |     /**
 153 |     |      * @dev Data structure that allows the Market to track the amount of market provided collateral, per type.
 154 |     |      */
 155 |     |     struct DepositedCollateral {
 156 |     |         address collateralType;
 157 |     |         uint256 amountD18;
 158 |     |     }
 159 |     | 
 160 |     |     /**
 161 |     |      * @dev Returns the market stored at the specified market id.
 162 |     |      */
 163 |     |     function load(uint128 id) internal pure returns (Data storage market) {
 164 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.synthetix.Market", id));
 165 |     |         assembly {
 166 |     |             market.slot := s
 167 |     |         }
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @dev Queries the external market contract for the amount of debt it has issued.
 172 |     |      *
 173 |     |      * The reported debt of a market represents the amount of USD that the market would ask the system to mint, if all of its positions were to be immediately closed.
 174 |     |      *
 175 |     |      * The reported debt of a market is collateralized by the assets in the pools which back it.
 176 |     |      *
 177 |     |      * See the `IMarket` interface.
 178 |     |      */
 179 |     |     function getReportedDebt(Data storage self) internal view returns (uint256) {
 180 |     |         return IMarket(self.marketAddress).reportedDebt(self.id);
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Queries the market for the amount of collateral which should be prevented from withdrawal.
 185 |     |      */
 186 |     |     function getLockedCreditCapacity(Data storage self) internal view returns (uint256) {
 187 |     |         return IMarket(self.marketAddress).minimumCredit(self.id);
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @dev Returns the total debt of the market.
 192 |     |      *
 193 |     |      * A market's total debt represents its debt plus its issuance, and thus represents the total outstanding debt of the market.
 194 |     |      *
 195 |     |      * Note: it also takes into account the deposited collateral value. See note in  getDepositedCollateralValue()
 196 |     |      *
 197 |     |      * Example:
 198 |     |      * (1 EUR = 1.11 USD)
 199 |     |      * If an Euro market has received 100 USD to mint 90 EUR, its reported debt is 90 EUR or 100 USD, and its issuance is -100 USD.
 200 |     |      * Thus, its total balance is 100 USD of reported debt minus 100 USD of issuance, which is 0 USD.
 201 |     |      *
 202 |     |      * Additionally, the market's totalDebt might be affected by price fluctuations via reportedDebt, or fees.
 203 |     |      *
 204 |     |      */
 205 |     |     function totalDebt(Data storage self) internal view returns (int256) {
 206 |     |         return
 207 |     |             getReportedDebt(self).toInt() +
 208 |     |             self.netIssuanceD18 -
 209 |     |             getDepositedCollateralValue(self).toInt();
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Returns the USD value for the total amount of collateral provided by the market itself.
 214 |     |      *
 215 |     |      * Note: This is not credit capacity provided by depositors through pools.
 216 |     |      */
 217 |     |     function getDepositedCollateralValue(Data storage self) internal view returns (uint256) {
 218 |     |         uint256 totalDepositedCollateralValueD18 = 0;
 219 |     | 
 220 |     |         // Sweep all DepositedCollateral entries and aggregate their USD value.
 221 |     |         for (uint256 i = 0; i < self.depositedCollateral.length; i++) {
 222 |     |             DepositedCollateral memory entry = self.depositedCollateral[i];
 223 |     |             CollateralConfiguration.Data storage collateralConfiguration = CollateralConfiguration
 224 |     |                 .load(entry.collateralType);
 225 |     | 
 226 |     |             if (entry.amountD18 == 0) {
 227 |     |                 continue;
 228 |     |             }
 229 |     | 
 230 |     |             uint256 priceD18 = CollateralConfiguration.getCollateralPrice(
 231 |     |                 collateralConfiguration,
 232 |     |                 entry.amountD18
 233 |     |             );
 234 |     | 
 235 |     |             totalDepositedCollateralValueD18 += priceD18.mulDecimal(entry.amountD18);
 236 |     |         }
 237 |     | 
 238 |     |         return totalDepositedCollateralValueD18;
 239 |     |     }
 240 |     | 
 241 |     |     /**
 242 |     |      * @dev Returns the amount of credit capacity that a certain pool provides to the market.
 243 |     | 
 244 |     |      * This credit capacity is obtained by reading the amount of shares that the pool has in the market's debt distribution, which represents the amount of USD denominated credit capacity that the pool has provided to the market.
 245 |     |      */
 246 |     |     function getPoolCreditCapacity(
 247 |     |         Data storage self,
 248 |     |         uint128 poolId
 249 |     |     ) internal view returns (uint256) {
 250 |     |         return self.poolsDebtDistribution.getActorShares(poolId.toBytes32());
 251 |     |     }
 252 |     | 
 253 |     |     /**
 254 |     |      * @dev Given an amount of shares that represent USD credit capacity from a pool, and a maximum value per share, returns the potential contribution to credit capacity that these shares could accrue, if their value per share was to hit the maximum.
 255 |     |      *
 256 |     |      * The resulting value is calculated multiplying the amount of creditCapacity provided by the pool by the delta between the maxValue per share vs current value.
 257 |     |      *
 258 |     |      * This function is used when the Pools are rebalanced to adjust each pool credit capacity based on a change in the amount of shares provided and/or a new maxValue per share
 259 |     |      *
 260 |     |      */
 261 |     |     function getCreditCapacityContribution(
 262 |     |         Data storage self,
 263 |     |         uint256 creditCapacitySharesD18,
 264 |     |         int256 maxShareValueD18
 265 |     |     ) internal view returns (int256 contributionD18) {
 266 |     |         // Determine how much the current value per share deviates from the maximum.
 267 |     |         uint256 deltaValuePerShareD18 = (maxShareValueD18 -
 268 |     |             self.poolsDebtDistribution.getValuePerShare()).toUint();
 269 |     | 
 270 |     |         return deltaValuePerShareD18.mulDecimal(creditCapacitySharesD18).toInt();
 271 |     |     }
 272 |     | 
 273 |     |     /**
 274 |     |      * @dev Returns true if the market's current capacity is below the amount of locked capacity.
 275 |     |      *
 276 |     |      */
 277 |     |     function isCapacityLocked(Data storage self) internal view returns (bool) {
 278 |     |         return self.creditCapacityD18 < getLockedCreditCapacity(self).toInt();
 279 |     |     }
 280 |     | 
 281 |     |     /**
 282 |     |      * @dev Gets any outstanding debt. Do not call this method except in tests
 283 |     |      *
 284 |     |      * Note: This function should only be used in tests!
 285 |     |      */
 286 |     |     // solhint-disable-next-line private-vars-leading-underscore, func-name-mixedcase
 287 |     |     function _testOnly_getOutstandingDebt(
 288 |     |         Data storage self,
 289 |     |         uint128 poolId
 290 |     |     ) internal returns (int256 debtChangeD18) {
 291 |     |         return
 292 |     |             self.pools[poolId].pendingDebtD18.toInt() +
 293 |     |             self.poolsDebtDistribution.accumulateActor(poolId.toBytes32());
 294 |     |     }
 295 |     | 
 296 |     |     /**
 297 |     |      * Returns the number of pools currently active in the market
 298 |     |      *
 299 |     |      * Note: this is test only
 300 |     |      */
 301 |     |     // solhint-disable-next-line private-vars-leading-underscore, func-name-mixedcase
 302 |     |     function _testOnly_inRangePools(Data storage self) internal view returns (uint256) {
 303 |     |         return self.inRangePools.size();
 304 |     |     }
 305 |     | 
 306 |     |     /**
 307 |     |      * Returns the number of pools currently active in the market
 308 |     |      *
 309 |     |      * Note: this is test only
 310 |     |      */
 311 |     |     // solhint-disable-next-line private-vars-leading-underscore, func-name-mixedcase
 312 |     |     function _testOnly_outRangePools(Data storage self) internal view returns (uint256) {
 313 |     |         return self.outRangePools.size();
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Returns the debt value per share
 318 |     |      */
 319 |     |     function getDebtPerShare(Data storage self) internal view returns (int256 debtPerShareD18) {
 320 |     |         return self.poolsDebtDistribution.getValuePerShare();
 321 |     |     }
 322 |     | 
 323 |     |     /**
 324 |     |      * @dev Determine the amount of debt the pool would assume if its lastValue was updated
 325 |     |      * Needed for optimization.
 326 |     |      *
 327 |     |      * Called by a pool when it distributes its debt.
 328 |     |      *
 329 |     |      */
 330 |     |     function accumulateDebtChange(
 331 |     |         Data storage self,
 332 |     |         uint128 poolId
 333 |     |     ) internal returns (int256 debtChangeD18) {
 334 |     |         int256 changedValueD18 = self.poolsDebtDistribution.accumulateActor(poolId.toBytes32());
 335 |     |         debtChangeD18 = self.pools[poolId].pendingDebtD18.toInt() + changedValueD18;
 336 |     |         self.pools[poolId].pendingDebtD18 = 0;
 337 |     |     }
 338 |     | 
 339 |     |     /**
 340 |     |      * @dev Wrapper that adjusts a pool's shares in the market's credit capacity, making sure that the market's outstanding debt is first passed on to its connected pools.
 341 |     |      *
 342 |     |      * Called by a pool when it distributes its debt.
 343 |     |      *
 344 |     |      */
 345 |     |     function rebalancePools(
 346 |     |         uint128 marketId,
 347 |     |         uint128 poolId,
 348 |     |         int256 maxDebtShareValueD18, // (in USD)
 349 |     |         uint256 newCreditCapacityD18 // in collateralValue (USD)
 350 |     |     ) internal returns (int256 debtChangeD18) {
 351 |     |         Data storage self = load(marketId);
 352 |     | 
 353 |     |         if (self.marketAddress == address(0)) {
 354 |     |             revert MarketNotFound(marketId);
 355 |     |         }
 356 |     | 
 357 |     |         return adjustPoolShares(self, poolId, newCreditCapacityD18, maxDebtShareValueD18);
 358 |     |     }
 359 |     | 
 360 |     |     /**
 361 |     |      * @dev Called by pools when they modify the credit capacity provided to the market, as well as the maximum value per share they tolerate for the market.
 362 |     |      *
 363 |     |      * These two settings affect the market in the following ways:
 364 |     |      * - Updates the pool's shares in `poolsDebtDistribution`.
 365 |     |      * - Moves the pool in and out of inRangePools/outRangePools.
 366 |     |      * - Updates the market credit capacity property.
 367 |     |      */
 368 |     |     function adjustPoolShares(
 369 |     |         Data storage self,
 370 |     |         uint128 poolId,
 371 |     |         uint256 newCreditCapacityD18,
 372 |     |         int256 newPoolMaxShareValueD18
 373 |     |     ) internal returns (int256 debtChangeD18) {
 374 |     |         uint256 oldCreditCapacityD18 = getPoolCreditCapacity(self, poolId);
 375 |     |         int256 oldPoolMaxShareValueD18 = -self.inRangePools.getById(poolId).priority;
 376 |     | 
 377 |     |         // Sanity checks
 378 |     |         // require(oldPoolMaxShareValue == 0, "value is not 0");
 379 |     |         // require(newPoolMaxShareValue == 0, "new pool max share value is in fact set");
 380 |     | 
 381 |     |         self.pools[poolId].creditCapacityAmountD18 = newCreditCapacityD18.to128();
 382 |     | 
 383 |     |         int128 valuePerShareD18 = self.poolsDebtDistribution.getValuePerShare().to128();
 384 |     | 
 385 |     |         if (newCreditCapacityD18 == 0) {
 386 |     |             self.inRangePools.extractById(poolId);
 387 |     |             self.outRangePools.extractById(poolId);
 388 |     |         } else if (newPoolMaxShareValueD18 < valuePerShareD18) {
 389 |     |             // this will ensure calculations below can correctly gauge shares changes
 390 |     |             newCreditCapacityD18 = 0;
 391 |     |             self.inRangePools.extractById(poolId);
 392 |     |             self.outRangePools.insert(poolId, newPoolMaxShareValueD18.to128());
 393 |     |         } else {
 394 |     |             self.inRangePools.insert(poolId, -newPoolMaxShareValueD18.to128());
 395 |     |             self.outRangePools.extractById(poolId);
 396 |     |         }
 397 |     | 
 398 |     |         int256 changedValueD18 = self.poolsDebtDistribution.setActorShares(
 399 |     |             poolId.toBytes32(),
 400 |     |             newCreditCapacityD18
 401 |     |         );
 402 |     |         debtChangeD18 = self.pools[poolId].pendingDebtD18.toInt() + changedValueD18;
 403 |     |         self.pools[poolId].pendingDebtD18 = 0;
 404 |     | 
 405 |     |         // recalculate market capacity
 406 |     |         if (newPoolMaxShareValueD18 > valuePerShareD18) {
 407 |     |             self.creditCapacityD18 += getCreditCapacityContribution(
 408 |     |                 self,
 409 |     |                 newCreditCapacityD18,
 410 |     |                 newPoolMaxShareValueD18
 411 |     |             ).to128();
 412 |     |         }
 413 |     | 
 414 |     |         if (oldPoolMaxShareValueD18 > valuePerShareD18) {
 415 |     |             self.creditCapacityD18 -= getCreditCapacityContribution(
 416 |     |                 self,
 417 |     |                 oldCreditCapacityD18,
 418 |     |                 oldPoolMaxShareValueD18
 419 |     |             ).to128();
 420 |     |         }
 421 |     |     }
 422 |     | 
 423 |     |     /**
 424 |     |      * @dev Moves debt from the market into the pools that connect to it.
 425 |     |      *
 426 |     |      * This function should be called before any of the pools' shares are modified in `poolsDebtDistribution`.
 427 |     |      *
 428 |     |      * Note: The parameter `maxIter` is used as an escape hatch to discourage griefing.
 429 |     |      */
 430 |     |     function distributeDebtToPools(
 431 |     |         Data storage self,
 432 |     |         uint256 maxIter
 433 |     |     ) internal returns (bool fullyDistributed) {
 434 |     |         // Get the current and last distributed market balances.
 435 |     |         // Note: The last distributed balance will be cached within this function's execution.
 436 |     |         int256 targetBalanceD18 = totalDebt(self);
 437 |     |         int256 outstandingBalanceD18 = targetBalanceD18 - self.lastDistributedMarketBalanceD18;
 438 |     | 
 439 |     |         (, bool exhausted) = bumpPools(self, outstandingBalanceD18, maxIter);
 440 |     | 
 441 |     |         if (!exhausted && self.poolsDebtDistribution.totalSharesD18 > 0) {
 442 |     |             // cannot use `outstandingBalance` here because `self.lastDistributedMarketBalance`
 443 |     |             // may have changed after calling the bump functions above
 444 |     |             self.poolsDebtDistribution.distributeValue(
 445 |     |                 targetBalanceD18 - self.lastDistributedMarketBalanceD18
 446 |     |             );
 447 |     |             self.lastDistributedMarketBalanceD18 = targetBalanceD18.to128();
 448 |     |         }
 449 |     | 
 450 |     |         return !exhausted;
 451 |     |     }
 452 |     | 
 453 |     |     /**
 454 |     |      * @dev Determine the target valuePerShare of the poolsDebtDistribution, given the value that is yet to be distributed.
 455 |     |      */
 456 |     |     function getTargetValuePerShare(
 457 |     |         Market.Data storage self,
 458 |     |         int256 valueToDistributeD18
 459 |     |     ) internal view returns (int256 targetValuePerShareD18) {
 460 |     |         return
 461 |     |             self.poolsDebtDistribution.getValuePerShare() +
 462 |     |             (
 463 |     |                 self.poolsDebtDistribution.totalSharesD18 > 0
 464 |     |                     ? valueToDistributeD18.divDecimal(
 465 |     |                         self.poolsDebtDistribution.totalSharesD18.toInt()
 466 |     |                     ) // solhint-disable-next-line numcast/safe-cast
 467 |     |                     : int256(0)
 468 |     |             );
 469 |     |     }
 470 |     | 
 471 |     |     /**
 472 |     |      * @dev Finds pools for which this market's max value per share limit is hit, distributes their debt, and disconnects the market from them.
 473 |     |      *
 474 |     |      * The debt is distributed up to the limit of the max value per share that the pool tolerates on the market.
 475 |     |      */
 476 |     |     function bumpPools(
 477 |     |         Data storage self,
 478 |     |         int256 maxDistributedD18,
 479 |     |         uint256 maxIter
 480 |     |     ) internal returns (int256 actuallyDistributedD18, bool exhausted) {
 481 |     |         if (maxDistributedD18 == 0) {
 482 |     |             return (0, false);
 483 |     |         }
 484 |     | 
 485 |     |         // Determine the direction based on the amount to be distributed.
 486 |     |         int128 k;
 487 |     |         HeapUtil.Data storage fromHeap;
 488 |     |         HeapUtil.Data storage toHeap;
 489 |     |         if (maxDistributedD18 > 0) {
 490 |     |             k = 1;
 491 |     |             fromHeap = self.inRangePools;
 492 |     |             toHeap = self.outRangePools;
 493 |     |         } else {
 494 |     |             k = -1;
 495 |     |             fromHeap = self.outRangePools;
 496 |     |             toHeap = self.inRangePools;
 497 |     |         }
 498 |     | 
 499 |     |         // Note: This loop should rarely execute its main body. When it does, it only executes once for each pool that exceeds the limit since `distributeValue` is not run for most pools. Thus, market users are not hit with any overhead as a result of this.
 500 |     |         uint256 iters;
 501 |     |         for (iters = 0; iters < maxIter; iters++) {
 502 |     |             // Exit if there are no pools that can be moved
 503 |     |             if (fromHeap.size() == 0) {
 504 |     |                 break;
 505 |     |             }
 506 |     | 
 507 |     |             // Identify the pool with the lowest maximum value per share.
 508 |     |             HeapUtil.Node memory edgePool = fromHeap.getMax();
 509 |     | 
 510 |     |             // 2 cases where we want to break out of this loop
 511 |     |             if (
 512 |     |                 // If there is no pool in range, and we are going down
 513 |     |                 (maxDistributedD18 - actuallyDistributedD18 > 0 &&
 514 |     |                     self.poolsDebtDistribution.totalSharesD18 == 0) ||
 515 |     |                 // If there is a pool in ragne, and the lowest max value per share does not hit the limit, exit
 516 |     |                 // Note: `-edgePool.priority` is actually the max value per share limit of the pool
 517 |     |                 (self.poolsDebtDistribution.totalSharesD18 > 0 &&
 518 |     |                     -edgePool.priority >=
 519 |     |                     k * getTargetValuePerShare(self, (maxDistributedD18 - actuallyDistributedD18)))
 520 |     |             ) {
 521 |     |                 break;
 522 |     |             }
 523 |     | 
 524 |     |             // The pool has hit its maximum value per share and needs to be removed.
 525 |     |             // Note: No need to update capacity because pool max share value = valuePerShare when this happens.
 526 |     |             togglePool(fromHeap, toHeap);
 527 |     | 
 528 |     |             // Distribute the market's debt to the limit, i.e. for that which exceeds the maximum value per share.
 529 |     |             if (self.poolsDebtDistribution.totalSharesD18 > 0) {
 530 |     |                 int256 debtToLimitD18 = self
 531 |     |                     .poolsDebtDistribution
 532 |     |                     .totalSharesD18
 533 |     |                     .toInt()
 534 |     |                     .mulDecimal(
 535 |     |                         -k * edgePool.priority - self.poolsDebtDistribution.getValuePerShare() // Diff between current value and max value per share.
 536 |     |                     );
 537 |     |                 self.poolsDebtDistribution.distributeValue(debtToLimitD18);
 538 |     | 
 539 |     |                 // Update the global distributed and outstanding balances with the debt that was just distributed.
 540 |     |                 actuallyDistributedD18 += debtToLimitD18;
 541 |     |             } else {
 542 |     |                 self.poolsDebtDistribution.valuePerShareD27 = (-k * edgePool.priority)
 543 |     |                     .to256()
 544 |     |                     .upscale(DecimalMath.PRECISION_FACTOR)
 545 |     |                     .to128();
 546 |     |             }
 547 |     | 
 548 |     |             // Detach the market from this pool by removing the pool's shares from the market.
 549 |     |             // The pool will remain "detached" until the pool manager specifies a new poolsDebtDistribution.
 550 |     |             if (maxDistributedD18 > 0) {
 551 |     |                 // the below requires are only for sanity
 552 |     |                 require(
 553 |     |                     self.poolsDebtDistribution.getActorShares(edgePool.id.toBytes32()) > 0,
 554 |     |                     "no shares before actor removal"
 555 |     |                 );
 556 |     | 
 557 |     |                 uint256 newPoolDebtD18 = self
 558 |     |                     .poolsDebtDistribution
 559 |     |                     .setActorShares(edgePool.id.toBytes32(), 0)
 560 |     |                     .toUint();
 561 |     |                 self.pools[edgePool.id].pendingDebtD18 += newPoolDebtD18.to128();
 562 |     |             } else {
 563 |     |                 require(
 564 |     |                     self.poolsDebtDistribution.getActorShares(edgePool.id.toBytes32()) == 0,
 565 |     |                     "actor has shares before add"
 566 |     |                 );
 567 |     | 
 568 |     |                 self.poolsDebtDistribution.setActorShares(
 569 |     |                     edgePool.id.toBytes32(),
 570 |     |                     self.pools[edgePool.id].creditCapacityAmountD18
 571 |     |                 );
 572 |     |             }
 573 |     |         }
 574 |     | 
 575 |     |         // Record the accumulated distributed balance.
 576 |     |         self.lastDistributedMarketBalanceD18 += actuallyDistributedD18.to128();
 577 |     | 
 578 |     |         exhausted = iters == maxIter;
 579 |     |     }
 580 |     | 
 581 |     |     /**
 582 |     |      * @dev Moves a pool from one heap into another.
 583 |     |      */
 584 |     |     function togglePool(HeapUtil.Data storage from, HeapUtil.Data storage to) internal {
 585 |     |         HeapUtil.Node memory node = from.extractMax();
 586 |     |         to.insert(node.id, -node.priority);
 587 |     |     }
 588 |     | 
 589 |     |     /**
 590 |     |      * @dev Returns whether or not a pool is past its maxDebtPerShare configuration for this market
 591 |     |      */
 592 |     |     function isPoolInRange(Data storage self, uint128 poolId) internal view returns (bool) {
 593 |     |         return self.inRangePools.getById(poolId).id == poolId;
 594 |     |     }
 595 |     | }
 596 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/MarketConfiguration.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Tracks a market's weight within a Pool, and its maximum debt.
  6 |     |  *
  7 |     |  * Each pool has an array of these, with one entry per market managed by the pool.
  8 |     |  *
  9 |     |  * A market's weight determines how much liquidity the pool provides to the market, and how much debt exposure the market gives the pool.
 10 |     |  *
 11 |     |  * Weights are used to calculate percentages by adding all the weights in the pool and dividing the market's weight by the total weights.
 12 |     |  *
 13 |     |  * A market's maximum debt in a pool is indicated with a maximum debt value per share.
 14 |     |  */
 15 |     | library MarketConfiguration {
 16 |     |     struct Data {
 17 |     |         /**
 18 |     |          * @dev Numeric identifier for the market.
 19 |     |          *
 20 |     |          * Must be unique, and in a list of `MarketConfiguration[]`, must be increasing.
 21 |     |          */
 22 |     |         uint128 marketId;
 23 |     |         /**
 24 |     |          * @dev The ratio of each market's `weight` to the pool's `totalWeights` determines the pro-rata share of the market to the pool's total liquidity.
 25 |     |          */
 26 |     |         uint128 weightD18;
 27 |     |         /**
 28 |     |          * @dev Maximum value per share that a pool will tolerate for this market.
 29 |     |          *
 30 |     |          * If the the limit is met, the markets exceeding debt will be distributed, and it will be disconnected from the pool that no longer provides credit to it.
 31 |     |          *
 32 |     |          * Note: This value will have no effect if the system wide limit is hit first. See `PoolConfiguration.minLiquidityRatioD18`.
 33 |     |          */
 34 |     |         int128 maxDebtShareValueD18;
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/MarketPoolInfo.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Stores information regarding a pool's relationship to a market, such that it can be added or removed from a distribution
  6 |     |  */
  7 |     | library MarketPoolInfo {
  8 |     |     struct Data {
  9 |     |         /**
 10 |     |          * @dev The credit capacity that this pool is providing to the relevant market. Needed to re-add the pool to the distribution when going back in range.
 11 |     |          */
 12 |     |         uint128 creditCapacityAmountD18;
 13 |     |         /**
 14 |     |          * @dev The amount of debt the pool has which hasn't been passed down the debt distribution chain yet.
 15 |     |          */
 16 |     |         uint128 pendingDebtD18;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/OracleManager.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Represents Oracle Manager
  6 |     |  */
  7 |     | library OracleManager {
  8 |     |     bytes32 private constant _SLOT_ORACLE_MANAGER =
  9 |     |         keccak256(abi.encode("io.synthetix.synthetix.OracleManager"));
 10 |     | 
 11 |     |     struct Data {
 12 |     |         /**
 13 |     |          * @dev The oracle manager address.
 14 |     |          */
 15 |     |         address oracleManagerAddress;
 16 |     |     }
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Loads the singleton storage info about the oracle manager.
 20 |     |      */
 21 |     |     function load() internal pure returns (Data storage oracleManager) {
 22 |     |         bytes32 s = _SLOT_ORACLE_MANAGER;
 23 |     |         assembly {
 24 |     |             oracleManager.slot := s
 25 |     |         }
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Pool.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "./Config.sol";
   5 |     | import "./Distribution.sol";
   6 |     | import "./MarketConfiguration.sol";
   7 |     | import "./Vault.sol";
   8 |     | import "./Market.sol";
   9 |     | import "./PoolCollateralConfiguration.sol";
  10 |     | import "./SystemPoolConfiguration.sol";
  11 |     | import "./PoolCollateralConfiguration.sol";
  12 |     | 
  13 |     | import "@synthetixio/core-contracts/contracts/errors/AccessError.sol";
  14 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  15 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title Aggregates collateral from multiple users in order to provide liquidity to a configurable set of markets.
  19 |     |  *
  20 |     |  * The set of markets is configured as an array of MarketConfiguration objects, where the weight of the market can be specified. This weight, and the aggregated total weight of all the configured markets, determines how much collateral from the pool each market has, as well as in what proportion the market passes on debt to the pool and thus to all its users.
  21 |     |  *
  22 |     |  * The pool tracks the collateral provided by users using an array of Vaults objects, for which there will be one per collateral type. Each vault tracks how much collateral each user has delegated to this pool, how much debt the user has because of minting USD, as well as how much corresponding debt the pool has passed on to the user.
  23 |     |  */
  24 |     | library Pool {
  25 |     |     using CollateralConfiguration for CollateralConfiguration.Data;
  26 |     |     using Market for Market.Data;
  27 |     |     using Vault for Vault.Data;
  28 |     |     using VaultEpoch for VaultEpoch.Data;
  29 |     |     using Distribution for Distribution.Data;
  30 |     |     using DecimalMath for uint256;
  31 |     |     using DecimalMath for int256;
  32 |     |     using DecimalMath for int128;
  33 |     |     using SafeCastAddress for address;
  34 |     |     using SafeCastU128 for uint128;
  35 |     |     using SafeCastU256 for uint256;
  36 |     |     using SafeCastI128 for int128;
  37 |     |     using SafeCastI256 for int256;
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Thrown when the specified pool is not found.
  41 |     |      */
  42 |     |     error PoolNotFound(uint128 poolId);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Thrown when attempting to create a pool that already exists.
  46 |     |      */
  47 |     |     error PoolAlreadyExists(uint128 poolId);
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Thrown when min delegation time for a market connected to the pool has not elapsed
  51 |     |      */
  52 |     |     error MinDelegationTimeoutPending(uint128 poolId, uint32 timeRemaining);
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev Thrown when pool has surpassed max collateral deposit
  56 |     |      */
  57 |     |     error PoolCollateralLimitExceeded(
  58 |     |         uint128 poolId,
  59 |     |         address collateralType,
  60 |     |         uint256 currentCollateral,
  61 |     |         uint256 maxCollateral
  62 |     |     );
  63 |     | 
  64 |     |     bytes32 private constant _CONFIG_SET_MARKET_MIN_DELEGATE_MAX = "setMarketMinDelegateTime_max";
  65 |     | 
  66 |     |     struct Data {
  67 |     |         /**
  68 |     |          * @dev Numeric identifier for the pool. Must be unique.
  69 |     |          * @dev A pool with id zero exists! (See Pool.loadExisting()). Users can delegate to this pool to be able to mint USD without being exposed to fluctuating debt.
  70 |     |          */
  71 |     |         uint128 id;
  72 |     |         /**
  73 |     |          * @dev Text identifier for the pool.
  74 |     |          *
  75 |     |          * Not required to be unique.
  76 |     |          */
  77 |     |         string name;
  78 |     |         /**
  79 |     |          * @dev Creator of the pool, which has configuration access rights for the pool.
  80 |     |          *
  81 |     |          * See onlyPoolOwner.
  82 |     |          */
  83 |     |         address owner;
  84 |     |         /**
  85 |     |          * @dev Allows the current pool owner to nominate a new owner, and thus transfer pool configuration credentials.
  86 |     |          */
  87 |     |         address nominatedOwner;
  88 |     |         /**
  89 |     |          * @dev Sum of all market weights.
  90 |     |          *
  91 |     |          * Market weights are tracked in `MarketConfiguration.weight`, one for each market. The ratio of each market's `weight` to the pool's `totalWeights` determines the pro-rata share of the market to the pool's total liquidity.
  92 |     |          *
  93 |     |          * Reciprocally, this pro-rata share also determines how much the pool is exposed to each market's debt.
  94 |     |          */
  95 |     |         uint128 totalWeightsD18;
  96 |     |         /**
  97 |     |          * @dev Accumulated cache value of all vault collateral debts
  98 |     |          */
  99 |     |         int128 totalVaultDebtsD18;
 100 |     |         /**
 101 |     |          * @dev Array of markets connected to this pool, and their configurations. I.e. weight, etc.
 102 |     |          *
 103 |     |          * See totalWeights.
 104 |     |          */
 105 |     |         MarketConfiguration.Data[] marketConfigurations;
 106 |     |         /**
 107 |     |          * @dev A pool's debt distribution connects pools to the debt distribution chain, i.e. vaults and markets. Vaults are actors in the pool's debt distribution, where the amount of shares they possess depends on the amount of collateral each vault delegates to the pool.
 108 |     |          *
 109 |     |          * The debt distribution chain will move debt from markets into this pools, and then from pools to vaults.
 110 |     |          *
 111 |     |          * Actors: Vaults.
 112 |     |          * Shares: USD value, proportional to the amount of collateral that the vault delegates to the pool.
 113 |     |          * Value per share: Debt per dollar of collateral. Depends on aggregated debt of connected markets.
 114 |     |          *
 115 |     |          */
 116 |     |         Distribution.Data vaultsDebtDistribution;
 117 |     |         /**
 118 |     |          * @dev Reference to all the vaults that provide liquidity to this pool.
 119 |     |          *
 120 |     |          * Each collateral type will have its own vault, specific to this pool. I.e. if two pools both use SNX collateral, each will have its own SNX vault.
 121 |     |          *
 122 |     |          * Vaults track user collateral and debt using a debt distribution, which is connected to the debt distribution chain.
 123 |     |          */
 124 |     |         mapping(address => Vault.Data) vaults;
 125 |     |         uint64 lastConfigurationTime;
 126 |     |         uint64 __reserved1;
 127 |     |         uint64 __reserved2;
 128 |     |         uint64 __reserved3;
 129 |     |         mapping(address => PoolCollateralConfiguration.Data) collateralConfigurations;
 130 |     |         /**
 131 |     |          * @dev A switch to make the pool opt-in for new collateral
 132 |     |          *
 133 |     |          * By default it's set to false, which means any new collateral accepeted by the system will be accpeted by the pool.
 134 |     |          *
 135 |     |          * If the pool owner sets this value to true, then new collaterals will be disabled for the pool unless a maxDeposit is set for a that collateral.
 136 |     |          */
 137 |     |         bool collateralDisabledByDefault;
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @dev Returns the pool stored at the specified pool id.
 142 |     |      */
 143 |     |     function load(uint128 id) internal pure returns (Data storage pool) {
 144 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.synthetix.Pool", id));
 145 |     |         assembly {
 146 |     |             pool.slot := s
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     /**
 151 |     |      * @dev Creates a pool for the given pool id, and assigns the caller as its owner.
 152 |     |      *
 153 |     |      * Reverts if the specified pool already exists.
 154 |     |      */
 155 |     |     function create(uint128 id, address owner) internal returns (Pool.Data storage pool) {
 156 |     |         if (id == 0 || load(id).id == id) {
 157 |     |             revert PoolAlreadyExists(id);
 158 |     |         }
 159 |     | 
 160 |     |         pool = load(id);
 161 |     | 
 162 |     |         pool.id = id;
 163 |     |         pool.owner = owner;
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Ticker function that updates the debt distribution chain downwards, from markets into the pool, according to each market's weight.
 168 |     |      * IMPORTANT: debt must be distributed downstream before invoking this function.
 169 |     |      *
 170 |     |      * It updates the chain by performing these actions:
 171 |     |      * - Splits the pool's total liquidity of the pool into each market, pro-rata. The amount of shares that the pool has on each market depends on how much liquidity the pool provides to the market.
 172 |     |      * - Accumulates the change in debt value from each market into the pools own vault debt distribution's value per share.
 173 |     |      */
 174 |     |     function rebalanceMarketsInPool(Data storage self) internal {
 175 |     |         uint256 totalWeightsD18 = self.totalWeightsD18;
 176 |     | 
 177 |     |         if (totalWeightsD18 == 0) {
 178 |     |             return; // Nothing to rebalance.
 179 |     |         }
 180 |     | 
 181 |     |         // Read from storage once, before entering the loop below.
 182 |     |         // These values should not change while iterating through each market.
 183 |     |         uint256 totalCreditCapacityD18 = self.vaultsDebtDistribution.totalSharesD18;
 184 |     |         int128 debtPerShareD18 = totalCreditCapacityD18 > 0 // solhint-disable-next-line numcast/safe-cast
 185 |     |             ? int256(self.totalVaultDebtsD18).divDecimal(totalCreditCapacityD18.toInt()).to128() // solhint-disable-next-line numcast/safe-cast
 186 |     |             : int128(0);
 187 |     | 
 188 |     |         uint256 systemMinLiquidityRatioD18 = SystemPoolConfiguration.load().minLiquidityRatioD18;
 189 |     | 
 190 |     |         // Loop through the pool's markets, applying market weights, and tracking how this changes the amount of debt that this pool is responsible for.
 191 |     |         // This debt extracted from markets is then applied to the pool's vault debt distribution, which thus exposes debt to the pool's vaults.
 192 |     |         for (uint256 i = 0; i < self.marketConfigurations.length; i++) {
 193 |     |             MarketConfiguration.Data storage marketConfiguration = self.marketConfigurations[i];
 194 |     | 
 195 |     |             uint256 weightD18 = marketConfiguration.weightD18;
 196 |     | 
 197 |     |             // Calculate each market's pro-rata USD liquidity.
 198 |     |             // Note: the factor `(weight / totalWeights)` is not deduped in the operations below to maintain numeric precision.
 199 |     | 
 200 |     |             uint256 marketCreditCapacityD18 = (totalCreditCapacityD18 * weightD18) /
 201 |     |                 totalWeightsD18;
 202 |     | 
 203 |     |             Market.Data storage marketData = Market.load(marketConfiguration.marketId);
 204 |     | 
 205 |     |             // Use market-specific minimum liquidity ratio if set, otherwise use system default.
 206 |     |             uint256 minLiquidityRatioD18 = marketData.minLiquidityRatioD18 > 0
 207 |     |                 ? marketData.minLiquidityRatioD18
 208 |     |                 : systemMinLiquidityRatioD18;
 209 |     | 
 210 |     |             // Contain the pool imposed market's maximum debt share value.
 211 |     |             // Imposed by system.
 212 |     |             int256 effectiveMaxShareValueD18 = getSystemMaxValuePerShare(
 213 |     |                 marketData.id,
 214 |     |                 minLiquidityRatioD18,
 215 |     |                 debtPerShareD18
 216 |     |             );
 217 |     |             // Imposed by pool.
 218 |     |             int256 configuredMaxShareValueD18 = marketConfiguration.maxDebtShareValueD18;
 219 |     |             effectiveMaxShareValueD18 = effectiveMaxShareValueD18 < configuredMaxShareValueD18
 220 |     |                 ? effectiveMaxShareValueD18
 221 |     |                 : configuredMaxShareValueD18;
 222 |     | 
 223 |     |             // Update each market's corresponding credit capacity.
 224 |     |             // The returned value represents how much the market's debt changed after changing the shares of this pool actor, which is aggregated to later be passed on the pools debt distribution.
 225 |     |             Market.rebalancePools(
 226 |     |                 marketConfiguration.marketId,
 227 |     |                 self.id,
 228 |     |                 effectiveMaxShareValueD18,
 229 |     |                 marketCreditCapacityD18
 230 |     |             );
 231 |     |         }
 232 |     |     }
 233 |     | 
 234 |     |     /**
 235 |     |      * @dev Determines the resulting maximum value per share for a market, according to a system-wide minimum liquidity ratio. This prevents markets from assigning more debt to pools than they have collateral to cover.
 236 |     |      *
 237 |     |      * Note: There is a market-wide fail safe for each market at `MarketConfiguration.maxDebtShareValue`. The lower of the two values should be used.
 238 |     |      *
 239 |     |      * See `SystemPoolConfiguration.minLiquidityRatio`.
 240 |     |      */
 241 |     |     function getSystemMaxValuePerShare(
 242 |     |         uint128 marketId,
 243 |     |         uint256 minLiquidityRatioD18,
 244 |     |         int256 debtPerShareD18
 245 |     |     ) internal view returns (int256) {
 246 |     |         // Retrieve the current value per share of the market.
 247 |     |         Market.Data storage marketData = Market.load(marketId);
 248 |     |         int256 valuePerShareD18 = marketData.poolsDebtDistribution.getValuePerShare();
 249 |     | 
 250 |     |         // Calculate the margin of debt that the market would incur if it hit the system wide limit.
 251 |     |         uint256 marginD18 = minLiquidityRatioD18 == 0
 252 |     |             ? DecimalMath.UNIT
 253 |     |             : DecimalMath.UNIT.divDecimal(minLiquidityRatioD18);
 254 |     | 
 255 |     |         // The resulting maximum value per share is the distribution's value per share,
 256 |     |         // plus the margin to hit the limit, minus the current debt per share.
 257 |     |         return valuePerShareD18 + marginD18.toInt() - debtPerShareD18;
 258 |     |     }
 259 |     | 
 260 |     |     /**
 261 |     |      * @dev Reverts if the pool does not exist with appropriate error. Otherwise, returns the pool.
 262 |     |      */
 263 |     |     function loadExisting(uint128 id) internal view returns (Data storage) {
 264 |     |         Data storage p = load(id);
 265 |     |         if (id != 0 && p.id != id) {
 266 |     |             revert PoolNotFound(id);
 267 |     |         }
 268 |     | 
 269 |     |         return p;
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @dev Returns true if the pool is exposed to the specified market.
 274 |     |      */
 275 |     |     function hasMarket(Data storage self, uint128 marketId) internal view returns (bool) {
 276 |     |         for (uint256 i = 0; i < self.marketConfigurations.length; i++) {
 277 |     |             if (
 278 |     |                 self.marketConfigurations[i].marketId == marketId &&
 279 |     |                 Market.load(marketId).isPoolInRange(self.id)
 280 |     |             ) {
 281 |     |                 return true;
 282 |     |             }
 283 |     |         }
 284 |     | 
 285 |     |         return false;
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * IMPORTANT: after this function, you should accumulateVaultDebt
 290 |     |      */
 291 |     |     function distributeDebtToVaults(
 292 |     |         Data storage self,
 293 |     |         address optionalCollateralType
 294 |     |     ) internal returns (int256 cumulativeDebtChange) {
 295 |     |         // Update each market's pro-rata liquidity and collect accumulated debt into the pool's debt distribution.
 296 |     |         uint128 myPoolId = self.id;
 297 |     |         for (uint256 i = 0; i < self.marketConfigurations.length; i++) {
 298 |     |             Market.Data storage market = Market.load(self.marketConfigurations[i].marketId);
 299 |     | 
 300 |     |             market.distributeDebtToPools(9999999999);
 301 |     |             cumulativeDebtChange += market.accumulateDebtChange(myPoolId);
 302 |     |         }
 303 |     | 
 304 |     |         assignDebt(self, cumulativeDebtChange);
 305 |     | 
 306 |     |         // Transfer the debt change from the pool into the vault.
 307 |     |         if (optionalCollateralType != address(0)) {
 308 |     |             bytes32 actorId = optionalCollateralType.toBytes32();
 309 |     |             self.vaults[optionalCollateralType].distributeDebtToAccounts(
 310 |     |                 self.vaultsDebtDistribution.accumulateActor(actorId)
 311 |     |             );
 312 |     |         }
 313 |     |     }
 314 |     | 
 315 |     |     function assignDebt(Data storage self, int256 debtAmountD18) internal {
 316 |     |         // Accumulate the change in total liquidity, from the vault, into the pool.
 317 |     |         self.totalVaultDebtsD18 = self.totalVaultDebtsD18 + debtAmountD18.to128();
 318 |     | 
 319 |     |         self.vaultsDebtDistribution.distributeValue(debtAmountD18);
 320 |     |     }
 321 |     | 
 322 |     |     function assignDebtToAccount(
 323 |     |         Data storage self,
 324 |     |         address collateralType,
 325 |     |         uint128 accountId,
 326 |     |         int256 debtAmountD18
 327 |     |     ) internal {
 328 |     |         self.totalVaultDebtsD18 = self.totalVaultDebtsD18 + debtAmountD18.to128();
 329 |     | 
 330 |     |         self.vaults[collateralType].currentEpoch().assignDebtToAccount(accountId, debtAmountD18);
 331 |     |     }
 332 |     | 
 333 |     |     /**
 334 |     |      * @dev Ticker function that updates the debt distribution chain for a specific collateral type downwards, from the pool into the corresponding the vault, according to changes in the collateral's price.
 335 |     |      * IMPORTANT: *should* call distributeDebtToVaults() to ensure that deltaDebtD18 is referencing the latest
 336 |     |      *
 337 |     |      * It updates the chain by performing these actions:
 338 |     |      * - Collects the latest price of the corresponding collateral and updates the vault's liquidity.
 339 |     |      * - Updates the vaults shares in the pool's debt distribution, according to the collateral provided by the vault.
 340 |     |      * - Updates the value per share of the vault's debt distribution.
 341 |     |      */
 342 |     |     function recalculateVaultCollateral(
 343 |     |         Data storage self,
 344 |     |         address collateralType
 345 |     |     ) internal returns (uint256 collateralPriceD18) {
 346 |     |         // Get the latest collateral price.
 347 |     |         collateralPriceD18 = CollateralConfiguration.load(collateralType).getCollateralPrice(
 348 |     |             DecimalMath.UNIT
 349 |     |         );
 350 |     | 
 351 |     |         // Changes in price update the corresponding vault's total collateral value as well as its liquidity (collateral - debt).
 352 |     |         (uint256 usdWeightD18, ) = self.vaults[collateralType].updateCreditCapacity(
 353 |     |             collateralPriceD18
 354 |     |         );
 355 |     | 
 356 |     |         // Update the vault's shares in the pool's debt distribution, according to the value of its collateral.
 357 |     |         self.vaultsDebtDistribution.setActorShares(collateralType.toBytes32(), usdWeightD18);
 358 |     | 
 359 |     |         // now that available vault collateral has been recalculated, we should also rebalance the pool markets
 360 |     |         rebalanceMarketsInPool(self);
 361 |     |     }
 362 |     | 
 363 |     |     /**
 364 |     |      * @dev Updates the debt distribution chain for this pool, and consolidates the given account's debt.
 365 |     |      */
 366 |     |     function updateAccountDebt(
 367 |     |         Data storage self,
 368 |     |         address collateralType,
 369 |     |         uint128 accountId
 370 |     |     ) internal returns (int256 debtD18) {
 371 |     |         distributeDebtToVaults(self, collateralType);
 372 |     |         return self.vaults[collateralType].consolidateAccountDebt(accountId);
 373 |     |     }
 374 |     | 
 375 |     |     /**
 376 |     |      * @dev Clears all vault data for the specified collateral type.
 377 |     |      */
 378 |     |     function resetVault(Data storage self, address collateralType) internal {
 379 |     |         // Creates a new epoch in the vault, effectively zeroing out all values.
 380 |     |         self.vaults[collateralType].reset();
 381 |     | 
 382 |     |         // Ensure that the vault's values update the debt distribution chain.
 383 |     |         recalculateVaultCollateral(self, collateralType);
 384 |     |     }
 385 |     | 
 386 |     |     /**
 387 |     |      * @dev Calculates the collateralization ratio of the vault that tracks the given collateral type.
 388 |     |      *
 389 |     |      * The c-ratio is the vault's share of the total debt of the pool, divided by the collateral it delegates to the pool.
 390 |     |      *
 391 |     |      * Note: This is not a view function. It updates the debt distribution chain before performing any calculations.
 392 |     |      */
 393 |     |     function currentVaultCollateralRatio(
 394 |     |         Data storage self,
 395 |     |         address collateralType
 396 |     |     ) internal returns (uint256) {
 397 |     |         int256 vaultDebtD18 = currentVaultDebt(self, collateralType);
 398 |     |         (, uint256 collateralValueD18) = currentVaultCollateral(self, collateralType);
 399 |     | 
 400 |     |         return vaultDebtD18 > 0 ? collateralValueD18.divDecimal(vaultDebtD18.toUint()) : 0;
 401 |     |     }
 402 |     | 
 403 |     |     /**
 404 |     |      * @dev Finds a connected market whose credit capacity has reached its locked limit.
 405 |     |      *
 406 |     |      * Note: Returns market zero (null market) if none is found.
 407 |     |      */
 408 |     |     function findMarketWithCapacityLocked(
 409 |     |         Data storage self
 410 |     |     ) internal view returns (Market.Data storage lockedMarket) {
 411 |     |         for (uint256 i = 0; i < self.marketConfigurations.length; i++) {
 412 |     |             Market.Data storage market = Market.load(self.marketConfigurations[i].marketId);
 413 |     | 
 414 |     |             if (market.isCapacityLocked()) {
 415 |     |                 return market;
 416 |     |             }
 417 |     |         }
 418 |     | 
 419 |     |         // Market zero = null market.
 420 |     |         return Market.load(0);
 421 |     |     }
 422 |     | 
 423 |     |     function getRequiredMinDelegationTime(
 424 |     |         Data storage self
 425 |     |     ) internal view returns (uint32 requiredMinDelegateTime) {
 426 |     |         for (uint256 i = 0; i < self.marketConfigurations.length; i++) {
 427 |     |             uint32 marketMinDelegateTime = Market
 428 |     |                 .load(self.marketConfigurations[i].marketId)
 429 |     |                 .minDelegateTime;
 430 |     | 
 431 |     |             if (marketMinDelegateTime > requiredMinDelegateTime) {
 432 |     |                 requiredMinDelegateTime = marketMinDelegateTime;
 433 |     |             }
 434 |     |         }
 435 |     | 
 436 |     |         // solhint-disable-next-line numcast/safe-cast
 437 |     |         uint32 maxMinDelegateTime = uint32(
 438 |     |             Config.readUint(_CONFIG_SET_MARKET_MIN_DELEGATE_MAX, 86400 * 30)
 439 |     |         );
 440 |     |         return
 441 |     |             maxMinDelegateTime < requiredMinDelegateTime
 442 |     |                 ? maxMinDelegateTime
 443 |     |                 : requiredMinDelegateTime;
 444 |     |     }
 445 |     | 
 446 |     |     /**
 447 |     |      * @dev Returns the debt of the vault that tracks the given collateral type.
 448 |     |      *
 449 |     |      * The vault's debt is the vault's share of the total debt of the pool, or its share of the total debt of the markets connected to the pool. The size of this share depends on how much collateral the pool provides to the pool.
 450 |     |      *
 451 |     |      * Note: This is not a view function. It updates the debt distribution chain before performing any calculations.
 452 |     |      */
 453 |     |     function currentVaultDebt(Data storage self, address collateralType) internal returns (int256) {
 454 |     |         // TODO: assert that all debts have been paid, otherwise vault cant be reset (its so critical here)
 455 |     |         distributeDebtToVaults(self, collateralType);
 456 |     |         rebalanceMarketsInPool(self);
 457 |     |         return self.vaults[collateralType].currentDebt();
 458 |     |     }
 459 |     | 
 460 |     |     /**
 461 |     |      * @dev Returns the total amount and value of the specified collateral delegated to this pool.
 462 |     |      */
 463 |     |     function currentVaultCollateral(
 464 |     |         Data storage self,
 465 |     |         address collateralType
 466 |     |     ) internal view returns (uint256 collateralAmountD18, uint256 collateralValueD18) {
 467 |     |         uint256 collateralPriceD18 = CollateralConfiguration
 468 |     |             .load(collateralType)
 469 |     |             .getCollateralPrice(collateralAmountD18);
 470 |     | 
 471 |     |         collateralAmountD18 = self.vaults[collateralType].currentCollateral();
 472 |     |         collateralValueD18 = collateralPriceD18.mulDecimal(collateralAmountD18);
 473 |     |     }
 474 |     | 
 475 |     |     /**
 476 |     |      * @dev Returns the amount and value of collateral that the specified account has delegated to this pool.
 477 |     |      */
 478 |     |     function currentAccountCollateral(
 479 |     |         Data storage self,
 480 |     |         address collateralType,
 481 |     |         uint128 accountId
 482 |     |     ) internal view returns (uint256 collateralAmountD18, uint256 collateralValueD18) {
 483 |     |         collateralAmountD18 = self.vaults[collateralType].currentAccountCollateral(accountId);
 484 |     |         uint256 collateralPriceD18 = CollateralConfiguration
 485 |     |             .load(collateralType)
 486 |     |             .getCollateralPrice(collateralAmountD18);
 487 |     |         collateralValueD18 = collateralPriceD18.mulDecimal(collateralAmountD18);
 488 |     |     }
 489 |     | 
 490 |     |     /**
 491 |     |      * @dev Returns the specified account's collateralization ratio (collateral / debt).
 492 |     |      * @dev If the account's debt is negative or zero, returns an "infinite" c-ratio.
 493 |     |      */
 494 |     |     function currentAccountCollateralRatio(
 495 |     |         Data storage self,
 496 |     |         address collateralType,
 497 |     |         uint128 accountId
 498 |     |     ) internal returns (uint256) {
 499 |     |         int256 positionDebtD18 = updateAccountDebt(self, collateralType, accountId);
 500 |     |         rebalanceMarketsInPool(self);
 501 |     |         if (positionDebtD18 <= 0) {
 502 |     |             return type(uint256).max;
 503 |     |         }
 504 |     | 
 505 |     |         (, uint256 positionCollateralValueD18) = currentAccountCollateral(
 506 |     |             self,
 507 |     |             collateralType,
 508 |     |             accountId
 509 |     |         );
 510 |     | 
 511 |     |         return positionCollateralValueD18.divDecimal(positionDebtD18.toUint());
 512 |     |     }
 513 |     | 
 514 |     |     /**
 515 |     |      * @dev Reverts if the caller is not the owner of the specified pool.
 516 |     |      */
 517 |     |     function onlyPoolOwner(uint128 poolId, address caller) internal view {
 518 |     |         if (Pool.load(poolId).owner != caller) {
 519 |     |             revert AccessError.Unauthorized(caller);
 520 |     |         }
 521 |     |     }
 522 |     | 
 523 |     |     function requireMinDelegationTimeElapsed(
 524 |     |         Data storage self,
 525 |     |         uint64 lastDelegationTime
 526 |     |     ) internal view {
 527 |     |         uint32 requiredMinDelegationTime = getRequiredMinDelegationTime(self);
 528 |     |         if (block.timestamp < lastDelegationTime + requiredMinDelegationTime) {
 529 |     |             revert MinDelegationTimeoutPending(
 530 |     |                 self.id,
 531 |     |                 // solhint-disable-next-line numcast/safe-cast
 532 |     |                 uint32(lastDelegationTime + requiredMinDelegationTime - block.timestamp)
 533 |     |             );
 534 |     |         }
 535 |     |     }
 536 |     | 
 537 |     |     function checkPoolCollateralLimit(
 538 |     |         Data storage self,
 539 |     |         address collateralType,
 540 |     |         uint256 collateralAmountD18
 541 |     |     ) internal view {
 542 |     |         uint256 collateralLimitD18 = self
 543 |     |             .collateralConfigurations[collateralType]
 544 |     |             .collateralLimitD18;
 545 |     |         uint256 currentCollateral = self.vaults[collateralType].currentCollateral();
 546 |     | 
 547 |     |         if (
 548 |     |             (self.collateralDisabledByDefault && collateralLimitD18 == 0) ||
 549 |     |             (collateralLimitD18 > 0 && currentCollateral + collateralAmountD18 > collateralLimitD18)
 550 |     |         ) {
 551 |     |             revert PoolCollateralLimitExceeded(
 552 |     |                 self.id,
 553 |     |                 collateralType,
 554 |     |                 currentCollateral + collateralAmountD18,
 555 |     |                 collateralLimitD18
 556 |     |             );
 557 |     |         }
 558 |     |     }
 559 |     | }
 560 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/PoolCollateralConfiguration.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | library PoolCollateralConfiguration {
  5 |     |     bytes32 private constant _SLOT =
  6 |     |         keccak256(abi.encode("io.synthetix.synthetix.PoolCollateralConfiguration"));
  7 |     | 
  8 |     |     struct Data {
  9 |     |         uint256 collateralLimitD18;
 10 |     |         uint256 issuanceRatioD18;
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/RewardDistribution.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/errors/ParameterError.sol";
   6 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   7 |     | 
   8 |     | import "../interfaces/external/IRewardDistributor.sol";
   9 |     | 
  10 |     | import "./Distribution.sol";
  11 |     | import "./RewardDistributionClaimStatus.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title Used by vaults to track rewards for its participants. There will be one of these for each pool, collateral type, and distributor combination.
  15 |     |  */
  16 |     | library RewardDistribution {
  17 |     |     using DecimalMath for int256;
  18 |     |     using SafeCastU128 for uint128;
  19 |     |     using SafeCastU256 for uint256;
  20 |     |     using SafeCastI128 for int128;
  21 |     |     using SafeCastI256 for int256;
  22 |     |     using SafeCastU64 for uint64;
  23 |     |     using SafeCastU32 for uint32;
  24 |     |     using SafeCastI32 for int32;
  25 |     | 
  26 |     |     struct Data {
  27 |     |         /**
  28 |     |          * @dev The 3rd party smart contract which holds/mints tokens for distributing rewards to vault participants.
  29 |     |          */
  30 |     |         IRewardDistributor distributor;
  31 |     |         /**
  32 |     |          * @dev Available slot.
  33 |     |          */
  34 |     |         uint128 __slotAvailableForFutureUse;
  35 |     |         /**
  36 |     |          * @dev The value of the rewards in this entry.
  37 |     |          */
  38 |     |         uint128 rewardPerShareD18;
  39 |     |         /**
  40 |     |          * @dev The status for each actor, regarding this distribution's entry.
  41 |     |          */
  42 |     |         mapping(uint256 => RewardDistributionClaimStatus.Data) claimStatus;
  43 |     |         /**
  44 |     |          * @dev Value to be distributed as rewards in a scheduled form.
  45 |     |          */
  46 |     |         int128 scheduledValueD18;
  47 |     |         /**
  48 |     |          * @dev Date at which the entry's rewards will begin to be claimable.
  49 |     |          *
  50 |     |          * Note: Set to <= block.timestamp to distribute immediately to currently participating users.
  51 |     |          */
  52 |     |         uint64 start;
  53 |     |         /**
  54 |     |          * @dev Time span after the start date, in which the whole of the entry's rewards will become claimable.
  55 |     |          */
  56 |     |         uint32 duration;
  57 |     |         /**
  58 |     |          * @dev Date on which this distribution entry was last updated.
  59 |     |          */
  60 |     |         uint32 lastUpdate;
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Distributes rewards into a new rewards distribution entry.
  65 |     |      *
  66 |     |      * Note: this function allows for more special cases such as distributing at a future date or distributing over time.
  67 |     |      * If you want to apply the distribution to the pool, call `distribute` with the return value. Otherwise, you can
  68 |     |      * record this independently as well.
  69 |     |      */
  70 |     |     function distribute(
  71 |     |         Data storage self,
  72 |     |         Distribution.Data storage dist,
  73 |     |         int256 amountD18,
  74 |     |         uint64 start,
  75 |     |         uint32 duration
  76 |     |     ) internal returns (int256 diffD18) {
  77 |     |         uint256 totalSharesD18 = dist.totalSharesD18;
  78 |     | 
  79 |     |         if (totalSharesD18 == 0) {
  80 |     |             revert ParameterError.InvalidParameter(
  81 |     |                 "amount",
  82 |     |                 "can't distribute to empty distribution"
  83 |     |             );
  84 |     |         }
  85 |     | 
  86 |     |         uint256 curTime = block.timestamp;
  87 |     | 
  88 |     |         // Unlocks the entry's distributed amount into its value per share.
  89 |     |         diffD18 += updateEntry(self, totalSharesD18);
  90 |     | 
  91 |     |         // If the current time is past the end of the entry's duration,
  92 |     |         // update any rewards which may have accrued since last run.
  93 |     |         // (instant distribution--immediately disperse amount).
  94 |     |         if (start + duration <= curTime) {
  95 |     |             diffD18 += amountD18.divDecimal(totalSharesD18.toInt());
  96 |     | 
  97 |     |             self.lastUpdate = 0;
  98 |     |             self.start = 0;
  99 |     |             self.duration = 0;
 100 |     |             self.scheduledValueD18 = 0;
 101 |     |             // Else, schedule the amount to distribute.
 102 |     |         } else {
 103 |     |             self.scheduledValueD18 = amountD18.to128();
 104 |     | 
 105 |     |             self.start = start;
 106 |     |             self.duration = duration;
 107 |     | 
 108 |     |             // The amount is actually the amount distributed already *plus* whatever has been specified now.
 109 |     |             self.lastUpdate = 0;
 110 |     | 
 111 |     |             diffD18 += updateEntry(self, totalSharesD18);
 112 |     |         }
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Gets the total shares of a reward distribution entry.
 117 |     |      */
 118 |     |     function getEntry(
 119 |     |         Data storage self,
 120 |     |         uint256 totalSharesAmountD18
 121 |     |     ) internal view returns (int256) {
 122 |     |         // No balance if a pool is empty or if it has no rewards
 123 |     |         if (self.scheduledValueD18 == 0 || totalSharesAmountD18 == 0) {
 124 |     |             return 0;
 125 |     |         }
 126 |     | 
 127 |     |         uint256 curTime = block.timestamp;
 128 |     | 
 129 |     |         int256 valuePerShareChangeD18 = 0;
 130 |     | 
 131 |     |         // No balance if current time is before start time
 132 |     |         if (curTime < self.start) {
 133 |     |             return 0;
 134 |     |         }
 135 |     | 
 136 |     |         // If the entry's duration is zero and its last update was before the start time,
 137 |     |         // consider the entry to be an instant distribution.
 138 |     |         if (self.duration == 0 && self.lastUpdate < self.start) {
 139 |     |             // Simply update the value per share to the total value divided by the total shares.
 140 |     |             valuePerShareChangeD18 = self.scheduledValueD18.to256().divDecimal(
 141 |     |                 totalSharesAmountD18.toInt()
 142 |     |             );
 143 |     |             // Else, if the last update was before the end of the duration.
 144 |     |         } else if (self.lastUpdate < self.start + self.duration) {
 145 |     |             // Determine how much was previously distributed.
 146 |     |             // If the last update is zero, then nothing was distributed,
 147 |     |             // otherwise the amount is proportional to the time elapsed since the start.
 148 |     |             int256 lastUpdateDistributedD18 = self.lastUpdate < self.start
 149 |     |                 ? SafeCastI128.zero()
 150 |     |                 : (self.scheduledValueD18 * (self.lastUpdate - self.start).toInt()) /
 151 |     |                     self.duration.toInt();
 152 |     | 
 153 |     |             // If the current time is beyond the duration, then consider all scheduled value to be distributed.
 154 |     |             // Else, the amount distributed is proportional to the elapsed time.
 155 |     |             int256 curUpdateDistributedD18 = self.scheduledValueD18;
 156 |     |             if (curTime < self.start + self.duration) {
 157 |     |                 // Note: Not using an intermediate time ratio variable
 158 |     |                 // in the following calculation to maintain precision.
 159 |     |                 curUpdateDistributedD18 =
 160 |     |                     (curUpdateDistributedD18 * (curTime - self.start).toInt()) /
 161 |     |                     self.duration.toInt();
 162 |     |             }
 163 |     | 
 164 |     |             // The final value per share change is the difference between what is to be distributed and what was distributed.
 165 |     |             valuePerShareChangeD18 = (curUpdateDistributedD18 - lastUpdateDistributedD18)
 166 |     |                 .divDecimal(totalSharesAmountD18.toInt());
 167 |     |         }
 168 |     | 
 169 |     |         return valuePerShareChangeD18;
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Updates the total shares of a reward distribution entry, and releases its unlocked value into its value per share, depending on the time elapsed since the start of the distribution's entry.
 174 |     |      *
 175 |     |      * Note: call every time before `totalShares` changes.
 176 |     |      */
 177 |     |     function updateEntry(
 178 |     |         Data storage self,
 179 |     |         uint256 totalSharesAmountD18
 180 |     |     ) internal returns (int256) {
 181 |     |         // Cannot process distributed rewards if a pool is empty or if it has no rewards.
 182 |     |         if (self.scheduledValueD18 == 0 || totalSharesAmountD18 == 0) {
 183 |     |             return 0;
 184 |     |         }
 185 |     | 
 186 |     |         uint256 curTime = block.timestamp;
 187 |     | 
 188 |     |         int256 valuePerShareChangeD18 = 0;
 189 |     | 
 190 |     |         // Cannot update an entry whose start date has not being reached.
 191 |     |         if (curTime < self.start) {
 192 |     |             return 0;
 193 |     |         }
 194 |     | 
 195 |     |         // If the entry's duration is zero and its last update was before the start time,
 196 |     |         // consider the entry to be an instant distribution.
 197 |     |         if (self.duration == 0 && self.lastUpdate < self.start) {
 198 |     |             // Simply update the value per share to the total value divided by the total shares.
 199 |     |             valuePerShareChangeD18 = self.scheduledValueD18.to256().divDecimal(
 200 |     |                 totalSharesAmountD18.toInt()
 201 |     |             );
 202 |     |             // Else, if the last update was before the end of the duration.
 203 |     |         } else if (self.lastUpdate < self.start + self.duration) {
 204 |     |             // Determine how much was previously distributed.
 205 |     |             // If the last update is zero, then nothing was distributed,
 206 |     |             // otherwise the amount is proportional to the time elapsed since the start.
 207 |     |             int256 lastUpdateDistributedD18 = 0;
 208 |     | 
 209 |     |             if (self.lastUpdate >= self.start) {
 210 |     |                 // solhint-disable numcast/safe-cast
 211 |     |                 lastUpdateDistributedD18 =
 212 |     |                     (int256(self.scheduledValueD18) * (self.lastUpdate - self.start).toInt()) /
 213 |     |                     self.duration.toInt();
 214 |     |                 // solhint-enable numcast/safe-cast
 215 |     |             }
 216 |     | 
 217 |     |             // If the current time is beyond the duration, then consider all scheduled value to be distributed.
 218 |     |             // Else, the amount distributed is proportional to the elapsed time.
 219 |     |             int256 curUpdateDistributedD18 = self.scheduledValueD18;
 220 |     |             if (curTime < self.start + self.duration) {
 221 |     |                 // Note: Not using an intermediate time ratio variable
 222 |     |                 // in the following calculation to maintain precision.
 223 |     |                 curUpdateDistributedD18 =
 224 |     |                     (curUpdateDistributedD18 * (curTime - self.start).toInt()) /
 225 |     |                     self.duration.toInt();
 226 |     |             }
 227 |     | 
 228 |     |             // The final value per share change is the difference between what is to be distributed and what was distributed.
 229 |     |             valuePerShareChangeD18 = (curUpdateDistributedD18 - lastUpdateDistributedD18)
 230 |     |                 .divDecimal(totalSharesAmountD18.toInt());
 231 |     |         }
 232 |     | 
 233 |     |         self.lastUpdate = curTime.to32();
 234 |     | 
 235 |     |         return valuePerShareChangeD18;
 236 |     |     }
 237 |     | }
 238 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/RewardDistributionClaimStatus.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Tracks information per actor within a RewardDistribution.
  6 |     |  */
  7 |     | library RewardDistributionClaimStatus {
  8 |     |     struct Data {
  9 |     |         /**
 10 |     |          * @dev The last known reward per share for this actor.
 11 |     |          */
 12 |     |         uint128 lastRewardPerShareD18;
 13 |     |         /**
 14 |     |          * @dev The amount of rewards pending to be claimed by this actor.
 15 |     |          */
 16 |     |         uint128 pendingSendD18;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/ScalableMapping.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Data structure that wraps a mapping with a scalar multiplier.
   9 |     |  *
  10 |     |  * If you wanted to modify all the values in a mapping by the same amount, you would normally have to loop through each entry in the mapping. This object allows you to modify all of them at once, by simply modifying the scalar multiplier.
  11 |     |  *
  12 |     |  * I.e. a regular mapping represents values like this:
  13 |     |  * value = mapping[id]
  14 |     |  *
  15 |     |  * And a scalable mapping represents values like this:
  16 |     |  * value = mapping[id] * scalar
  17 |     |  *
  18 |     |  * This reduces the number of computations needed for modifying the balances of N users from O(n) to O(1).
  19 |     | 
  20 |     |  * Note: Notice how users are tracked by a generic bytes32 id instead of an address. This allows the actors of the mapping not just to be addresses. They can be anything, for example a pool id, an account id, etc.
  21 |     |  *
  22 |     |  * *********************
  23 |     |  * Conceptual Examples
  24 |     |  * *********************
  25 |     |  *
  26 |     |  * 1) Socialization of collateral during a liquidation.
  27 |     |  *
  28 |     |  * Scalable mappings are very useful for "socialization" of collateral, that is, the re-distribution of collateral when an account is liquidated. Suppose 1000 ETH are liquidated, and would need to be distributed amongst 1000 depositors. With a regular mapping, every depositor's balance would have to be modified in a loop that iterates through every single one of them. With a scalable mapping, the scalar would simply need to be incremented so that the total value of the mapping increases by 1000 ETH.
  29 |     |  *
  30 |     |  * 2) Socialization of debt during a liquidation.
  31 |     |  *
  32 |     |  * Similar to the socialization of collateral during a liquidation, the debt of the position that is being liquidated can be re-allocated using a scalable mapping with a single action. Supposing a scalable mapping tracks each user's debt in the system, and that 1000 sUSD has to be distributed amongst 1000 depositors, the debt data structure's scalar would simply need to be incremented so that the total value or debt of the distribution increments by 1000 sUSD.
  33 |     |  *
  34 |     |  */
  35 |     | library ScalableMapping {
  36 |     |     using SafeCastU128 for uint128;
  37 |     |     using SafeCastU256 for uint256;
  38 |     |     using SafeCastI128 for int128;
  39 |     |     using SafeCastI256 for int256;
  40 |     |     using DecimalMath for int256;
  41 |     |     using DecimalMath for uint256;
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Thrown when attempting to scale a mapping with an amount that is lower than its resolution.
  45 |     |      */
  46 |     |     error InsufficientMappedAmount();
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Thrown when attempting to scale a mapping with no shares.
  50 |     |      */
  51 |     |     error CannotScaleEmptyMapping();
  52 |     | 
  53 |     |     struct Data {
  54 |     |         uint128 totalSharesD18;
  55 |     |         int128 scaleModifierD27;
  56 |     |         mapping(bytes32 => uint256) sharesD18;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Inflates or deflates the total value of the distribution by the given value.
  61 |     |      * @dev The incoming value is split per share, and used as a delta that is *added* to the existing scale modifier. The resulting scale modifier must be in the range [-1, type(int128).max).
  62 |     |      */
  63 |     |     function scale(Data storage self, int256 valueD18) internal {
  64 |     |         if (valueD18 == 0) {
  65 |     |             return;
  66 |     |         }
  67 |     | 
  68 |     |         uint256 totalSharesD18 = self.totalSharesD18;
  69 |     |         if (totalSharesD18 == 0) {
  70 |     |             revert CannotScaleEmptyMapping();
  71 |     |         }
  72 |     | 
  73 |     |         int256 valueD45 = valueD18 * DecimalMath.UNIT_PRECISE_INT;
  74 |     |         int256 deltaScaleModifierD27 = valueD45 / totalSharesD18.toInt();
  75 |     | 
  76 |     |         self.scaleModifierD27 += deltaScaleModifierD27.to128();
  77 |     | 
  78 |     |         if (self.scaleModifierD27 < -DecimalMath.UNIT_PRECISE_INT) {
  79 |     |             revert InsufficientMappedAmount();
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Updates an actor's individual value in the distribution to the specified amount.
  85 |     |      *
  86 |     |      * The change in value is manifested in the distribution by changing the actor's number of shares in it, and thus the distribution's total number of shares.
  87 |     |      *
  88 |     |      * Returns the resulting amount of shares that the actor has after this change in value.
  89 |     |      */
  90 |     |     function set(
  91 |     |         Data storage self,
  92 |     |         bytes32 actorId,
  93 |     |         uint256 newActorValueD18
  94 |     |     ) internal returns (uint256 resultingSharesD18) {
  95 |     |         // Represent the actor's change in value by changing the actor's number of shares,
  96 |     |         // and keeping the distribution's scaleModifier constant.
  97 |     | 
  98 |     |         resultingSharesD18 = getSharesForAmount(self, newActorValueD18);
  99 |     | 
 100 |     |         // Modify the total shares with the actor's change in shares.
 101 |     |         self.totalSharesD18 = (self.totalSharesD18 + resultingSharesD18 - self.sharesD18[actorId])
 102 |     |             .to128();
 103 |     | 
 104 |     |         self.sharesD18[actorId] = resultingSharesD18.to128();
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Returns the value owned by the actor in the distribution.
 109 |     |      *
 110 |     |      * i.e. actor.shares * scaleModifier
 111 |     |      */
 112 |     |     function get(Data storage self, bytes32 actorId) internal view returns (uint256 valueD18) {
 113 |     |         uint256 totalSharesD18 = self.totalSharesD18;
 114 |     |         if (totalSharesD18 == 0) {
 115 |     |             return 0;
 116 |     |         }
 117 |     | 
 118 |     |         return (self.sharesD18[actorId] * totalAmount(self)) / totalSharesD18;
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Returns the total value held in the distribution.
 123 |     |      *
 124 |     |      * i.e. totalShares * scaleModifier
 125 |     |      */
 126 |     |     function totalAmount(Data storage self) internal view returns (uint256 valueD18) {
 127 |     |         return
 128 |     |             ((self.scaleModifierD27 + DecimalMath.UNIT_PRECISE_INT).toUint() *
 129 |     |                 self.totalSharesD18) / DecimalMath.UNIT_PRECISE;
 130 |     |     }
 131 |     | 
 132 |     |     function getSharesForAmount(
 133 |     |         Data storage self,
 134 |     |         uint256 amountD18
 135 |     |     ) internal view returns (uint256 sharesD18) {
 136 |     |         sharesD18 =
 137 |     |             (amountD18 * DecimalMath.UNIT_PRECISE) /
 138 |     |             (self.scaleModifierD27 + DecimalMath.UNIT_PRECISE_INT128).toUint();
 139 |     |     }
 140 |     | }
 141 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/SystemPoolConfiguration.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title System wide configuration for pools.
  8 |     |  */
  9 |     | library SystemPoolConfiguration {
 10 |     |     bytes32 private constant _SLOT_SYSTEM_POOL_CONFIGURATION =
 11 |     |         keccak256(abi.encode("io.synthetix.synthetix.SystemPoolConfiguration"));
 12 |     | 
 13 |     |     struct Data {
 14 |     |         /**
 15 |     |          * @dev Owner specified system-wide limiting factor that prevents markets from minting too much debt, similar to the issuance ratio to a collateral type.
 16 |     |          *
 17 |     |          * Note: If zero, then this value defaults to 100%.
 18 |     |          */
 19 |     |         uint256 minLiquidityRatioD18;
 20 |     |         uint128 __reservedForFutureUse;
 21 |     |         /**
 22 |     |          * @dev Id of the main pool set by the system owner.
 23 |     |          */
 24 |     |         uint128 preferredPool;
 25 |     |         /**
 26 |     |          * @dev List of pools approved by the system owner.
 27 |     |          */
 28 |     |         SetUtil.UintSet approvedPools;
 29 |     |     }
 30 |     | 
 31 |     |     /**
 32 |     |      * @dev Returns the configuration singleton.
 33 |     |      */
 34 |     |     function load() internal pure returns (Data storage systemPoolConfiguration) {
 35 |     |         bytes32 s = _SLOT_SYSTEM_POOL_CONFIGURATION;
 36 |     |         assembly {
 37 |     |             systemPoolConfiguration.slot := s
 38 |     |         }
 39 |     |     }
 40 |     | }
 41 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/Vault.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "./VaultEpoch.sol";
   5 |     | import "./RewardDistribution.sol";
   6 |     | 
   7 |     | import "@synthetixio/core-contracts/contracts/utils/SetUtil.sol";
   8 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title Tracks collateral and debt distributions in a pool, for a specific collateral type.
  12 |     |  *
  13 |     |  * I.e. if a pool supports SNX and ETH collaterals, it will have an SNX Vault, and an ETH Vault.
  14 |     |  *
  15 |     |  * The Vault data structure is itself split into VaultEpoch sub-structures. This facilitates liquidations,
  16 |     |  * so that whenever one occurs, a clean state of all data is achieved by simply incrementing the epoch index.
  17 |     |  *
  18 |     |  * It is recommended to understand VaultEpoch before understanding this object.
  19 |     |  */
  20 |     | library Vault {
  21 |     |     using VaultEpoch for VaultEpoch.Data;
  22 |     |     using Distribution for Distribution.Data;
  23 |     |     using RewardDistribution for RewardDistribution.Data;
  24 |     |     using ScalableMapping for ScalableMapping.Data;
  25 |     |     using DecimalMath for uint256;
  26 |     |     using DecimalMath for int128;
  27 |     |     using DecimalMath for int256;
  28 |     |     using SafeCastU128 for uint128;
  29 |     |     using SafeCastU256 for uint256;
  30 |     |     using SafeCastI128 for int128;
  31 |     |     using SafeCastI256 for int256;
  32 |     |     using SetUtil for SetUtil.Bytes32Set;
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev Thrown when a non-existent reward distributor is referenced
  36 |     |      */
  37 |     |     error RewardDistributorNotFound();
  38 |     | 
  39 |     |     struct Data {
  40 |     |         /**
  41 |     |          * @dev The vault's current epoch number.
  42 |     |          *
  43 |     |          * Vault data is divided into epochs. An epoch changes when an entire vault is liquidated.
  44 |     |          */
  45 |     |         uint256 epoch;
  46 |     |         /**
  47 |     |          * @dev Unused property, maintained for backwards compatibility in storage layout.
  48 |     |          */
  49 |     |         // solhint-disable-next-line private-vars-leading-underscore
  50 |     |         bytes32 __slotAvailableForFutureUse;
  51 |     |         /**
  52 |     |          * @dev The previous debt of the vault, when `updateCreditCapacity` was last called by the Pool.
  53 |     |          */
  54 |     |         // solhint-disable-next-line var-name-mixedcase
  55 |     |         int128 _unused_prevTotalDebtD18;
  56 |     |         /**
  57 |     |          * @dev Vault data for all the liquidation cycles divided into epochs.
  58 |     |          */
  59 |     |         mapping(uint256 => VaultEpoch.Data) epochData;
  60 |     |         /**
  61 |     |          * @dev Tracks available rewards, per user, for this vault.
  62 |     |          */
  63 |     |         mapping(bytes32 => RewardDistribution.Data) rewards;
  64 |     |         /**
  65 |     |          * @dev Tracks reward ids, for this vault.
  66 |     |          */
  67 |     |         SetUtil.Bytes32Set rewardIds;
  68 |     |     }
  69 |     | 
  70 |     |     struct PositionSelector {
  71 |     |         uint128 accountId;
  72 |     |         uint128 poolId;
  73 |     |         address collateralType;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev Return's the VaultEpoch data for the current epoch.
  78 |     |      */
  79 |     |     function currentEpoch(Data storage self) internal view returns (VaultEpoch.Data storage) {
  80 |     |         return self.epochData[self.epoch];
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Updates the vault's credit capacity as the value of its collateral minus its debt.
  85 |     |      *
  86 |     |      * Called as a ticker when users interact with pools, allowing pools to set
  87 |     |      * vaults' credit capacity shares within them.
  88 |     |      *
  89 |     |      * Returns the amount of collateral that this vault is providing in net USD terms.
  90 |     |      */
  91 |     |     function updateCreditCapacity(
  92 |     |         Data storage self,
  93 |     |         uint256 collateralPriceD18
  94 |     |     ) internal view returns (uint256 usdWeightD18, int256 totalDebtD18) {
  95 |     |         VaultEpoch.Data storage epochData = currentEpoch(self);
  96 |     | 
  97 |     |         usdWeightD18 = (epochData.collateralAmounts.totalAmount()).mulDecimal(collateralPriceD18);
  98 |     | 
  99 |     |         totalDebtD18 = epochData.totalDebt();
 100 |     | 
 101 |     |         //self.prevTotalDebtD18 = totalDebtD18.to128();
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev Updated the value per share of the current epoch's incoming debt distribution.
 106 |     |      */
 107 |     |     function distributeDebtToAccounts(Data storage self, int256 debtChangeD18) internal {
 108 |     |         currentEpoch(self).distributeDebtToAccounts(debtChangeD18);
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Consolidates an accounts debt.
 113 |     |      */
 114 |     |     function consolidateAccountDebt(
 115 |     |         Data storage self,
 116 |     |         uint128 accountId
 117 |     |     ) internal returns (int256) {
 118 |     |         return currentEpoch(self).consolidateAccountDebt(accountId);
 119 |     |     }
 120 |     | 
 121 |     |     function updateRewards(
 122 |     |         Data storage self,
 123 |     |         uint128 accountId,
 124 |     |         uint128 poolId,
 125 |     |         address collateralType
 126 |     |     ) internal returns (uint256[] memory rewards, address[] memory distributors) {
 127 |     |         uint256 totalSharesD18 = currentEpoch(self).accountsDebtDistribution.totalSharesD18;
 128 |     |         uint256 actorSharesD18 = currentEpoch(self).accountsDebtDistribution.getActorShares(
 129 |     |             accountId.toBytes32()
 130 |     |         );
 131 |     | 
 132 |     |         return
 133 |     |             updateRewards(
 134 |     |                 self,
 135 |     |                 PositionSelector(accountId, poolId, collateralType),
 136 |     |                 totalSharesD18,
 137 |     |                 actorSharesD18
 138 |     |             );
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Traverses available rewards for this vault, and updates an accounts
 143 |     |      * claim on them according to the amount of debt shares they have.
 144 |     |      */
 145 |     |     function updateRewards(
 146 |     |         Data storage self,
 147 |     |         PositionSelector memory pos,
 148 |     |         uint256 totalSharesD18,
 149 |     |         uint256 actorSharesD18
 150 |     |     ) internal returns (uint256[] memory rewards, address[] memory distributors) {
 151 |     |         rewards = new uint256[](self.rewardIds.length());
 152 |     |         distributors = new address[](self.rewardIds.length());
 153 |     | 
 154 |     |         uint256 numRewards = self.rewardIds.length();
 155 |     |         for (uint256 i = 0; i < numRewards; i++) {
 156 |     |             RewardDistribution.Data storage dist = self.rewards[self.rewardIds.valueAt(i + 1)];
 157 |     | 
 158 |     |             if (address(dist.distributor) == address(0)) {
 159 |     |                 continue;
 160 |     |             }
 161 |     | 
 162 |     |             distributors[i] = address(dist.distributor);
 163 |     |             rewards[i] = updateReward(
 164 |     |                 self,
 165 |     |                 pos,
 166 |     |                 self.rewardIds.valueAt(i + 1),
 167 |     |                 totalSharesD18,
 168 |     |                 actorSharesD18
 169 |     |             );
 170 |     |         }
 171 |     |     }
 172 |     | 
 173 |     |     /**
 174 |     |      * @dev Traverses available rewards for this vault and the reward id, and returns an accounts
 175 |     |      * pending claim on them according to the amount of debt shares they have.
 176 |     |      */
 177 |     |     function getReward(
 178 |     |         Data storage self,
 179 |     |         uint128 accountId,
 180 |     |         bytes32 rewardId
 181 |     |     ) internal view returns (uint256) {
 182 |     |         uint256 totalSharesD18 = currentEpoch(self).accountsDebtDistribution.totalSharesD18;
 183 |     |         uint256 actorSharesD18 = currentEpoch(self).accountsDebtDistribution.getActorShares(
 184 |     |             accountId.toBytes32()
 185 |     |         );
 186 |     | 
 187 |     |         RewardDistribution.Data storage dist = self.rewards[rewardId];
 188 |     | 
 189 |     |         if (address(dist.distributor) == address(0)) {
 190 |     |             revert RewardDistributorNotFound();
 191 |     |         }
 192 |     | 
 193 |     |         uint256 currentRewardPerShare = dist.rewardPerShareD18;
 194 |     | 
 195 |     |         currentRewardPerShare += dist.getEntry(totalSharesD18).toUint().to128();
 196 |     | 
 197 |     |         uint256 currentPending = dist.claimStatus[accountId].pendingSendD18 +
 198 |     |             actorSharesD18.mulDecimal(
 199 |     |                 currentRewardPerShare - dist.claimStatus[accountId].lastRewardPerShareD18
 200 |     |             );
 201 |     | 
 202 |     |         return currentPending;
 203 |     |     }
 204 |     | 
 205 |     |     /**
 206 |     |      * @dev Traverses available rewards for this vault and the reward id, and updates an accounts
 207 |     |      * claim on them according to the amount of debt shares they have.
 208 |     |      */
 209 |     |     function updateReward(
 210 |     |         Data storage self,
 211 |     |         PositionSelector memory pos,
 212 |     |         bytes32 rewardId,
 213 |     |         uint256 totalSharesD18,
 214 |     |         uint256 actorSharesD18
 215 |     |     ) internal returns (uint256) {
 216 |     |         RewardDistribution.Data storage dist = self.rewards[rewardId];
 217 |     | 
 218 |     |         if (address(dist.distributor) == address(0)) {
 219 |     |             revert RewardDistributorNotFound();
 220 |     |         }
 221 |     | 
 222 |     |         dist.distributor.onPositionUpdated(
 223 |     |             pos.accountId,
 224 |     |             pos.poolId,
 225 |     |             pos.collateralType,
 226 |     |             actorSharesD18
 227 |     |         );
 228 |     | 
 229 |     |         dist.rewardPerShareD18 += dist.updateEntry(totalSharesD18).toUint().to128();
 230 |     | 
 231 |     |         dist.claimStatus[pos.accountId].pendingSendD18 += actorSharesD18
 232 |     |             .mulDecimal(
 233 |     |                 dist.rewardPerShareD18 - dist.claimStatus[pos.accountId].lastRewardPerShareD18
 234 |     |             )
 235 |     |             .to128();
 236 |     | 
 237 |     |         dist.claimStatus[pos.accountId].lastRewardPerShareD18 = dist.rewardPerShareD18;
 238 |     | 
 239 |     |         return dist.claimStatus[pos.accountId].pendingSendD18;
 240 |     |     }
 241 |     | 
 242 |     |     /**
 243 |     |      * @dev Increments the current epoch index, effectively producing a
 244 |     |      * completely blank new VaultEpoch data structure in the vault.
 245 |     |      */
 246 |     |     function reset(Data storage self) internal {
 247 |     |         self.epoch++;
 248 |     |     }
 249 |     | 
 250 |     |     /**
 251 |     |      * @dev Returns the vault's combined debt (consolidated and unconsolidated),
 252 |     |      * for the current epoch.
 253 |     |      */
 254 |     |     function currentDebt(Data storage self) internal view returns (int256) {
 255 |     |         return currentEpoch(self).totalDebt();
 256 |     |     }
 257 |     | 
 258 |     |     /**
 259 |     |      * @dev Returns the total value in the Vault's collateral distribution, for the current epoch.
 260 |     |      */
 261 |     |     function currentCollateral(Data storage self) internal view returns (uint256) {
 262 |     |         return currentEpoch(self).collateralAmounts.totalAmount();
 263 |     |     }
 264 |     | 
 265 |     |     /**
 266 |     |      * @dev Returns an account's collateral value in this vault's current epoch.
 267 |     |      */
 268 |     |     function currentAccountCollateral(
 269 |     |         Data storage self,
 270 |     |         uint128 accountId
 271 |     |     ) internal view returns (uint256) {
 272 |     |         return currentEpoch(self).getAccountCollateral(accountId);
 273 |     |     }
 274 |     | }
 275 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/main/contracts/storage/VaultEpoch.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "./Distribution.sol";
   5 |     | import "./ScalableMapping.sol";
   6 |     | 
   7 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title Tracks collateral and debt distributions in a pool, for a specific collateral type, in a given epoch.
  11 |     |  *
  12 |     |  * Collateral is tracked with a distribution as opposed to a regular mapping because liquidations cause collateral to be socialized. If collateral was tracked using a regular mapping, such socialization would be difficult and require looping through individual balances, or some other sort of complex and expensive mechanism. Distributions make socialization easy.
  13 |     |  *
  14 |     |  * Debt is also tracked in a distribution for the same reason, but it is additionally split in two distributions: incoming and consolidated debt.
  15 |     |  *
  16 |     |  * Incoming debt is modified when a liquidations occurs.
  17 |     |  * Consolidated debt is updated when users interact with the system.
  18 |     |  */
  19 |     | library VaultEpoch {
  20 |     |     using Distribution for Distribution.Data;
  21 |     |     using DecimalMath for uint256;
  22 |     |     using SafeCastU128 for uint128;
  23 |     |     using SafeCastU256 for uint256;
  24 |     |     using SafeCastI128 for int128;
  25 |     |     using SafeCastI256 for int256;
  26 |     |     using ScalableMapping for ScalableMapping.Data;
  27 |     | 
  28 |     |     struct Data {
  29 |     |         /**
  30 |     |          * @dev Amount of debt in this Vault that is yet to be consolidated.
  31 |     |          *
  32 |     |          * E.g. when a given amount of debt is socialized during a liquidation, but it yet hasn't been rolled into
  33 |     |          * the consolidated debt distribution.
  34 |     |          */
  35 |     |         int128 unconsolidatedDebtD18;
  36 |     |         /**
  37 |     |          * @dev Amount of debt in this Vault that has been consolidated.
  38 |     |          */
  39 |     |         int128 totalConsolidatedDebtD18;
  40 |     |         /**
  41 |     |          * @dev Tracks incoming debt for each user.
  42 |     |          *
  43 |     |          * The value of shares in this distribution change as the associate market changes, i.e. price changes in an asset in
  44 |     |          * a spot market.
  45 |     |          *
  46 |     |          * Also, when debt is socialized in a liquidation, it is done onto this distribution. As users
  47 |     |          * interact with the system, their independent debt is consolidated or rolled into consolidatedDebtDist.
  48 |     |          */
  49 |     |         Distribution.Data accountsDebtDistribution;
  50 |     |         /**
  51 |     |          * @dev Tracks collateral delegated to this vault, for each user.
  52 |     |          *
  53 |     |          * Uses a distribution instead of a regular market because of the way collateral is socialized during liquidations.
  54 |     |          *
  55 |     |          * A regular mapping would require looping over the mapping of each account's collateral, or moving the liquidated
  56 |     |          * collateral into a place where it could later be claimed. With a distribution, liquidated collateral can be
  57 |     |          * socialized very easily.
  58 |     |          */
  59 |     |         ScalableMapping.Data collateralAmounts;
  60 |     |         /**
  61 |     |          * @dev Tracks consolidated debt for each user.
  62 |     |          *
  63 |     |          * Updated when users interact with the system, consolidating changes from the fluctuating accountsDebtDistribution,
  64 |     |          * and directly when users mint or burn USD, or repay debt.
  65 |     |          */
  66 |     |         mapping(uint256 => int256) consolidatedDebtAmountsD18;
  67 |     |         /**
  68 |     |          * @dev Tracks last time a user delegated to this vault.
  69 |     |          *
  70 |     |          * Needed to validate min delegation time compliance to prevent small scale debt pool frontrunning
  71 |     |          */
  72 |     |         mapping(uint128 => uint64) lastDelegationTime;
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Updates the value per share of the incoming debt distribution.
  77 |     |      * Used for socialization during liquidations, and to bake in market changes.
  78 |     |      *
  79 |     |      * Called from:
  80 |     |      * - LiquidationModule.liquidate
  81 |     |      * - Pool.recalculateVaultCollateral (ticker)
  82 |     |      */
  83 |     |     function distributeDebtToAccounts(Data storage self, int256 debtChangeD18) internal {
  84 |     |         self.accountsDebtDistribution.distributeValue(debtChangeD18);
  85 |     | 
  86 |     |         // Cache total debt here.
  87 |     |         // Will roll over to individual users as they interact with the system.
  88 |     |         self.unconsolidatedDebtD18 += debtChangeD18.to128();
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Adjusts the debt associated with `accountId` by `amountD18`.
  93 |     |      * Used to add or remove debt from/to a specific account, instead of all accounts at once (use distributeDebtToAccounts for that)
  94 |     |      */
  95 |     |     function assignDebtToAccount(
  96 |     |         Data storage self,
  97 |     |         uint128 accountId,
  98 |     |         int256 amountD18
  99 |     |     ) internal returns (int256 newDebtD18) {
 100 |     |         int256 currentDebtD18 = self.consolidatedDebtAmountsD18[accountId];
 101 |     |         self.consolidatedDebtAmountsD18[accountId] += amountD18;
 102 |     |         self.totalConsolidatedDebtD18 += amountD18.to128();
 103 |     |         return currentDebtD18 + amountD18;
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Consolidates user debt as they interact with the system.
 108 |     |      *
 109 |     |      * Fluctuating debt is moved from incoming to consolidated debt.
 110 |     |      *
 111 |     |      * Called as a ticker from various parts of the system, usually whenever the
 112 |     |      * real debt of a user needs to be known.
 113 |     |      */
 114 |     |     function consolidateAccountDebt(
 115 |     |         Data storage self,
 116 |     |         uint128 accountId
 117 |     |     ) internal returns (int256 currentDebtD18) {
 118 |     |         int256 newDebtD18 = self.accountsDebtDistribution.accumulateActor(accountId.toBytes32());
 119 |     | 
 120 |     |         currentDebtD18 = assignDebtToAccount(self, accountId, newDebtD18);
 121 |     |         self.unconsolidatedDebtD18 -= newDebtD18.to128();
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev Updates a user's collateral value, and sets their exposure to debt
 126 |     |      * according to the collateral they delegated and the leverage used.
 127 |     |      *
 128 |     |      * Called whenever a user's collateral changes.
 129 |     |      */
 130 |     |     function updateAccountPosition(
 131 |     |         Data storage self,
 132 |     |         uint128 accountId,
 133 |     |         uint256 collateralAmountD18,
 134 |     |         uint256 leverageD18
 135 |     |     ) internal {
 136 |     |         bytes32 actorId = accountId.toBytes32();
 137 |     | 
 138 |     |         // Ensure account debt is consolidated before we do next things.
 139 |     |         consolidateAccountDebt(self, accountId);
 140 |     | 
 141 |     |         self.collateralAmounts.set(actorId, collateralAmountD18);
 142 |     |         self.accountsDebtDistribution.setActorShares(
 143 |     |             actorId,
 144 |     |             self.collateralAmounts.sharesD18[actorId].mulDecimal(leverageD18)
 145 |     |         );
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Returns the vault's total debt in this epoch, including the debt
 150 |     |      * that hasn't yet been consolidated into individual accounts.
 151 |     |      */
 152 |     |     function totalDebt(Data storage self) internal view returns (int256) {
 153 |     |         return self.unconsolidatedDebtD18 + self.totalConsolidatedDebtD18;
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @dev Returns an account's value in the Vault's collateral distribution.
 158 |     |      */
 159 |     |     function getAccountCollateral(
 160 |     |         Data storage self,
 161 |     |         uint128 accountId
 162 |     |     ) internal view returns (uint256 amountD18) {
 163 |     |         return self.collateralAmounts.get(accountId.toBytes32());
 164 |     |     }
 165 |     | }
 166 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../storage/NodeOutput.sol";
  5 |     | import "../storage/NodeDefinition.sol";
  6 |     | 
  7 |     | /// @title Module for managing nodes
  8 |     | interface INodeModule {
  9 |     |     /**
 10 |     |      * @notice Thrown when the specified nodeId has not been registered in the system.
 11 |     |      */
 12 |     |     error NodeNotRegistered(bytes32 nodeId);
 13 |     | 
 14 |     |     /**
 15 |     |      * @notice Thrown when a node is registered without a valid definition.
 16 |     |      */
 17 |     |     error InvalidNodeDefinition(NodeDefinition.Data nodeType);
 18 |     | 
 19 |     |     /**
 20 |     |      * @notice Emitted when `registerNode` is called.
 21 |     |      * @param nodeId The id of the registered node.
 22 |     |      * @param nodeType The nodeType assigned to this node.
 23 |     |      * @param parameters The parameters assigned to this node.
 24 |     |      * @param parents The parents assigned to this node.
 25 |     |      */
 26 |     |     event NodeRegistered(
 27 |     |         bytes32 nodeId,
 28 |     |         NodeDefinition.NodeType nodeType,
 29 |     |         bytes parameters,
 30 |     |         bytes32[] parents
 31 |     |     );
 32 |     | 
 33 |     |     /**
 34 |     |      * @notice Registers a node
 35 |     |      * @param nodeType The nodeType assigned to this node.
 36 |     |      * @param parameters The parameters assigned to this node.
 37 |     |      * @param parents The parents assigned to this node.
 38 |     |      * @return nodeId The id of the registered node.
 39 |     |      */
 40 |     |     function registerNode(
 41 |     |         NodeDefinition.NodeType nodeType,
 42 |     |         bytes memory parameters,
 43 |     |         bytes32[] memory parents
 44 |     |     ) external returns (bytes32 nodeId);
 45 |     | 
 46 |     |     /**
 47 |     |      * @notice Returns the ID of a node, whether or not it has been registered.
 48 |     |      * @param parents The parents assigned to this node.
 49 |     |      * @param nodeType The nodeType assigned to this node.
 50 |     |      * @param parameters The parameters assigned to this node.
 51 |     |      * @return nodeId The id of the node.
 52 |     |      */
 53 |     |     function getNodeId(
 54 |     |         NodeDefinition.NodeType nodeType,
 55 |     |         bytes memory parameters,
 56 |     |         bytes32[] memory parents
 57 |     |     ) external pure returns (bytes32 nodeId);
 58 |     | 
 59 |     |     /**
 60 |     |      * @notice Returns a node's definition (type, parameters, and parents)
 61 |     |      * @param nodeId The node ID
 62 |     |      * @return node The node's definition data
 63 |     |      */
 64 |     |     function getNode(bytes32 nodeId) external pure returns (NodeDefinition.Data memory node);
 65 |     | 
 66 |     |     /**
 67 |     |      * @notice Returns a node current output data
 68 |     |      * @param nodeId The node ID
 69 |     |      * @return node The node's output data
 70 |     |      */
 71 |     |     function process(bytes32 nodeId) external view returns (NodeOutput.Data memory node);
 72 |     | 
 73 |     |     /**
 74 |     |      * @notice Returns a node current output data
 75 |     |      * @param nodeId The node ID
 76 |     |      * @param runtimeKeys Keys corresponding to runtime values which could be used by the node graph
 77 |     |      * @param runtimeValues The values used by the node graph
 78 |     |      * @return node The node's output data
 79 |     |      */
 80 |     |     function processWithRuntime(
 81 |     |         bytes32 nodeId,
 82 |     |         bytes32[] memory runtimeKeys,
 83 |     |         bytes32[] memory runtimeValues
 84 |     |     ) external view returns (NodeOutput.Data memory node);
 85 |     | }
 86 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IAggregatorV3Interface.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /// @title Interface an aggregator needs to adhere.
  5 |     | interface IAggregatorV3Interface {
  6 |     |     /// @notice decimals used by the aggregator
  7 |     |     function decimals() external view returns (uint8);
  8 |     | 
  9 |     |     /// @notice aggregator's description
 10 |     |     function description() external view returns (string memory);
 11 |     | 
 12 |     |     /// @notice aggregator's version
 13 |     |     function version() external view returns (uint256);
 14 |     | 
 15 |     |     // getRoundData and latestRoundData should both raise "No data present"
 16 |     |     // if they do not have data to report, instead of returning unset values
 17 |     |     // which could be misinterpreted as actual reported values.
 18 |     |     /// @notice get's round data for requested id
 19 |     |     function getRoundData(
 20 |     |         uint80 id
 21 |     |     )
 22 |     |         external
 23 |     |         view
 24 |     |         returns (
 25 |     |             uint80 roundId,
 26 |     |             int256 answer,
 27 |     |             uint256 startedAt,
 28 |     |             uint256 updatedAt,
 29 |     |             uint80 answeredInRound
 30 |     |         );
 31 |     | 
 32 |     |     /// @notice get's latest round data
 33 |     |     function latestRoundData()
 34 |     |         external
 35 |     |         view
 36 |     |         returns (
 37 |     |             uint80 roundId,
 38 |     |             int256 answer,
 39 |     |             uint256 startedAt,
 40 |     |             uint256 updatedAt,
 41 |     |             uint80 answeredInRound
 42 |     |         );
 43 |     | }
 44 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IExternalNode.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
  5 |     | 
  6 |     | import "../../storage/NodeOutput.sol";
  7 |     | import "../../storage/NodeDefinition.sol";
  8 |     | 
  9 |     | /// @title Interface for an external node
 10 |     | interface IExternalNode is IERC165 {
 11 |     |     function process(
 12 |     |         NodeOutput.Data[] memory parentNodeOutputs,
 13 |     |         bytes memory parameters,
 14 |     |         bytes32[] memory runtimeKeys,
 15 |     |         bytes32[] memory runtimeValues
 16 |     |     ) external view returns (NodeOutput.Data memory);
 17 |     | 
 18 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) external returns (bool);
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IPyth.sol
   1 |     | // SPDX-License-Identifier: Apache-2.0
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /// @title Consume prices from the Pyth Network (https://pyth.network/).
   5 |     | /// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.
   6 |     | /// @author Pyth Data Association
   7 |     | interface IPyth {
   8 |     |     /// @dev Emitted when an update for price feed with `id` is processed successfully.
   9 |     |     /// @param id The Pyth Price Feed ID.
  10 |     |     /// @param fresh True if the price update is more recent and stored.
  11 |     |     /// @param chainId ID of the source chain that the batch price update containing this price.
  12 |     |     /// This value comes from Wormhole, and you can find the corresponding chains at https://docs.wormholenetwork.com/wormhole/contracts.
  13 |     |     /// @param sequenceNumber Sequence number of the batch price update containing this price.
  14 |     |     /// @param lastPublishTime Publish time of the previously stored price.
  15 |     |     /// @param publishTime Publish time of the given price update.
  16 |     |     /// @param price Price of the given price update.
  17 |     |     /// @param conf Confidence interval of the given price update.
  18 |     |     event PriceFeedUpdate(
  19 |     |         bytes32 indexed id,
  20 |     |         bool indexed fresh,
  21 |     |         uint16 chainId,
  22 |     |         uint64 sequenceNumber,
  23 |     |         uint256 lastPublishTime,
  24 |     |         uint256 publishTime,
  25 |     |         int64 price,
  26 |     |         uint64 conf
  27 |     |     );
  28 |     | 
  29 |     |     /// @dev Emitted when a batch price update is processed successfully.
  30 |     |     /// @param chainId ID of the source chain that the batch price update comes from.
  31 |     |     /// @param sequenceNumber Sequence number of the batch price update.
  32 |     |     /// @param batchSize Number of prices within the batch price update.
  33 |     |     /// @param freshPricesInBatch Number of prices that were more recent and were stored.
  34 |     |     event BatchPriceFeedUpdate(
  35 |     |         uint16 chainId,
  36 |     |         uint64 sequenceNumber,
  37 |     |         uint256 batchSize,
  38 |     |         uint256 freshPricesInBatch
  39 |     |     );
  40 |     | 
  41 |     |     /// @dev Emitted when a call to `updatePriceFeeds` is processed successfully.
  42 |     |     /// @param sender Sender of the call (`msg.sender`).
  43 |     |     /// @param batchCount Number of batches that this function processed.
  44 |     |     /// @param fee Amount of paid fee for updating the prices.
  45 |     |     event UpdatePriceFeeds(address indexed sender, uint256 batchCount, uint256 fee);
  46 |     | 
  47 |     |     /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time
  48 |     |     function getValidTimePeriod() external view returns (uint256 validTimePeriod);
  49 |     | 
  50 |     |     /// @notice Returns the price and confidence interval.
  51 |     |     /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.
  52 |     |     /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.
  53 |     |     /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.
  54 |     |     function getPrice(bytes32 id) external view returns (PythStructs.Price memory price);
  55 |     | 
  56 |     |     /// @notice Returns the exponentially-weighted moving average price and confidence interval.
  57 |     |     /// @dev Reverts if the EMA price is not available.
  58 |     |     /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.
  59 |     |     /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.
  60 |     |     function getEmaPrice(bytes32 id) external view returns (PythStructs.Price memory price);
  61 |     | 
  62 |     |     /// @notice Returns the price of a price feed without any sanity checks.
  63 |     |     /// @dev This function returns the most recent price update in this contract without any recency checks.
  64 |     |     /// This function is unsafe as the returned price update may be arbitrarily far in the past.
  65 |     |     ///
  66 |     |     /// Users of this function should check the `publishTime` in the price to ensure that the returned price is
  67 |     |     /// sufficiently recent for their application. If you are considering using this function, it may be
  68 |     |     /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.
  69 |     |     /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.
  70 |     |     function getPriceUnsafe(bytes32 id) external view returns (PythStructs.Price memory price);
  71 |     | 
  72 |     |     /// @notice Returns the price that is no older than `age` seconds of the current time.
  73 |     |     /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in
  74 |     |     /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently
  75 |     |     /// recently.
  76 |     |     /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.
  77 |     |     function getPriceNoOlderThan(
  78 |     |         bytes32 id,
  79 |     |         uint256 age
  80 |     |     ) external view returns (PythStructs.Price memory price);
  81 |     | 
  82 |     |     /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.
  83 |     |     /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.
  84 |     |     /// However, if the price is not recent this function returns the latest available price.
  85 |     |     ///
  86 |     |     /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that
  87 |     |     /// the returned price is recent or useful for any particular application.
  88 |     |     ///
  89 |     |     /// Users of this function should check the `publishTime` in the price to ensure that the returned price is
  90 |     |     /// sufficiently recent for their application. If you are considering using this function, it may be
  91 |     |     /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.
  92 |     |     /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.
  93 |     |     function getEmaPriceUnsafe(bytes32 id) external view returns (PythStructs.Price memory price);
  94 |     | 
  95 |     |     /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds
  96 |     |     /// of the current time.
  97 |     |     /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in
  98 |     |     /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently
  99 |     |     /// recently.
 100 |     |     /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.
 101 |     |     function getEmaPriceNoOlderThan(
 102 |     |         bytes32 id,
 103 |     |         uint256 age
 104 |     |     ) external view returns (PythStructs.Price memory price);
 105 |     | 
 106 |     |     /// @notice Update price feeds with given update messages.
 107 |     |     /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling
 108 |     |     /// `getUpdateFee` with the length of the `updateData` array.
 109 |     |     /// Prices will be updated if they are more recent than the current stored prices.
 110 |     |     /// The call will succeed even if the update is not the most recent.
 111 |     |     /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.
 112 |     |     /// @param updateData Array of price update data.
 113 |     |     function updatePriceFeeds(bytes[] calldata updateData) external payable;
 114 |     | 
 115 |     |     /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is
 116 |     |     /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the
 117 |     |     /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.
 118 |     |     ///
 119 |     |     /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling
 120 |     |     /// `getUpdateFee` with the length of the `updateData` array.
 121 |     |     ///
 122 |     |     /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime
 123 |     |     /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have
 124 |     |     /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.
 125 |     |     /// Otherwise, it calls updatePriceFeeds method to update the prices.
 126 |     |     ///
 127 |     |     /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.
 128 |     |     /// @param updateData Array of price update data.
 129 |     |     /// @param priceIds Array of price ids.
 130 |     |     /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`
 131 |     |     function updatePriceFeedsIfNecessary(
 132 |     |         bytes[] calldata updateData,
 133 |     |         bytes32[] calldata priceIds,
 134 |     |         uint64[] calldata publishTimes
 135 |     |     ) external payable;
 136 |     | 
 137 |     |     /// @notice Returns the required fee to update an array of price updates.
 138 |     |     /// @param updateData Array of price update data.
 139 |     |     /// @return feeAmount The required fee in Wei.
 140 |     |     function getUpdateFee(bytes[] calldata updateData) external view returns (uint256 feeAmount);
 141 |     | 
 142 |     |     /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are
 143 |     |     /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,
 144 |     |     /// this method will return the first update.
 145 |     |     ///
 146 |     |     ///
 147 |     |     /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is
 148 |     |     /// no update for any of the given `priceIds` within the given time range and uniqueness condition.
 149 |     |     /// @param updateData Array of price update data.
 150 |     |     /// @param priceIds Array of price ids.
 151 |     |     /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.
 152 |     |     /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.
 153 |     |     /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).
 154 |     |     function parsePriceFeedUpdatesUnique(
 155 |     |         bytes[] calldata updateData,
 156 |     |         bytes32[] calldata priceIds,
 157 |     |         uint64 minPublishTime,
 158 |     |         uint64 maxPublishTime
 159 |     |     ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);
 160 |     | }
 161 |     | 
 162 |     | contract PythStructs {
 163 |     |     // A price with a degree of uncertainty, represented as a price +- a confidence interval.
 164 |     |     //
 165 |     |     // The confidence interval roughly corresponds to the standard error of a normal distribution.
 166 |     |     // Both the price and confidence are stored in a fixed-point numeric representation,
 167 |     |     // `x * (10^expo)`, where `expo` is the exponent.
 168 |     |     //
 169 |     |     // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how
 170 |     |     // to how this price safely.
 171 |     |     struct Price {
 172 |     |         // Price
 173 |     |         int64 price;
 174 |     |         // Confidence interval around the price
 175 |     |         uint64 conf;
 176 |     |         // Price exponent
 177 |     |         int32 expo;
 178 |     |         // Unix timestamp describing when the price was published
 179 |     |         uint256 publishTime;
 180 |     |     }
 181 |     | 
 182 |     |     // PriceFeed represents a current aggregate price from pyth publisher feeds.
 183 |     |     struct PriceFeed {
 184 |     |         // The price ID.
 185 |     |         bytes32 id;
 186 |     |         // Latest available price
 187 |     |         Price price;
 188 |     |         // Latest available exponentially-weighted moving average price
 189 |     |         Price emaPrice;
 190 |     |     }
 191 |     | }
 192 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/interfaces/external/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: Apache-2.0
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | interface IUniswapV3Pool {
  5 |     |     function observe(
  6 |     |         uint32[] calldata secondsAgos
  7 |     |     )
  8 |     |         external
  9 |     |         view
 10 |     |         returns (
 11 |     |             int56[] memory tickCumulatives,
 12 |     |             uint160[] memory secondsPerLiquidityCumulativeX128s
 13 |     |         );
 14 |     | 
 15 |     |     function token0() external view returns (address);
 16 |     | 
 17 |     |     function token1() external view returns (address);
 18 |     | }
 19 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ChainlinkNode.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | 
   7 |     | import "../storage/NodeDefinition.sol";
   8 |     | import "../storage/NodeOutput.sol";
   9 |     | import "../interfaces/external/IAggregatorV3Interface.sol";
  10 |     | 
  11 |     | library ChainlinkNode {
  12 |     |     using SafeCastU256 for uint256;
  13 |     |     using SafeCastI256 for int256;
  14 |     |     using DecimalMath for int256;
  15 |     | 
  16 |     |     uint256 public constant PRECISION = 18;
  17 |     | 
  18 |     |     function process(
  19 |     |         bytes memory parameters
  20 |     |     ) internal view returns (NodeOutput.Data memory nodeOutput) {
  21 |     |         (address chainlinkAddr, uint256 twapTimeInterval, uint8 decimals) = abi.decode(
  22 |     |             parameters,
  23 |     |             (address, uint256, uint8)
  24 |     |         );
  25 |     |         IAggregatorV3Interface chainlink = IAggregatorV3Interface(chainlinkAddr);
  26 |     |         (uint80 roundId, int256 price, , uint256 updatedAt, ) = chainlink.latestRoundData();
  27 |     | 
  28 |     |         int256 finalPrice = twapTimeInterval == 0
  29 |     |             ? price
  30 |     |             : getTwapPrice(chainlink, roundId, price, twapTimeInterval);
  31 |     | 
  32 |     |         finalPrice = decimals > PRECISION
  33 |     |             ? finalPrice.downscale(decimals - PRECISION)
  34 |     |             : finalPrice.upscale(PRECISION - decimals);
  35 |     | 
  36 |     |         return NodeOutput.Data(finalPrice, updatedAt, 0, 0);
  37 |     |     }
  38 |     | 
  39 |     |     function getTwapPrice(
  40 |     |         IAggregatorV3Interface chainlink,
  41 |     |         uint80 latestRoundId,
  42 |     |         int256 latestPrice,
  43 |     |         uint256 twapTimeInterval
  44 |     |     ) internal view returns (int256 price) {
  45 |     |         int256 priceSum = latestPrice;
  46 |     |         uint256 priceCount = 1;
  47 |     | 
  48 |     |         uint256 startTime = block.timestamp - twapTimeInterval;
  49 |     | 
  50 |     |         while (latestRoundId > 0) {
  51 |     |             try chainlink.getRoundData(--latestRoundId) returns (
  52 |     |                 uint80,
  53 |     |                 int256 answer,
  54 |     |                 uint256,
  55 |     |                 uint256 updatedAt,
  56 |     |                 uint80
  57 |     |             ) {
  58 |     |                 if (updatedAt < startTime) {
  59 |     |                     break;
  60 |     |                 }
  61 |     |                 priceSum += answer;
  62 |     |                 priceCount++;
  63 |     |             } catch {
  64 |     |                 break;
  65 |     |             }
  66 |     |         }
  67 |     | 
  68 |     |         return priceSum / priceCount.toInt();
  69 |     |     }
  70 |     | 
  71 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal view returns (bool valid) {
  72 |     |         // Must have no parents
  73 |     |         if (nodeDefinition.parents.length > 0) {
  74 |     |             return false;
  75 |     |         }
  76 |     | 
  77 |     |         // Must have correct length of parameters data
  78 |     |         if (nodeDefinition.parameters.length != 32 * 3) {
  79 |     |             return false;
  80 |     |         }
  81 |     | 
  82 |     |         (address chainlinkAddr, , uint8 decimals) = abi.decode(
  83 |     |             nodeDefinition.parameters,
  84 |     |             (address, uint256, uint8)
  85 |     |         );
  86 |     |         IAggregatorV3Interface chainlink = IAggregatorV3Interface(chainlinkAddr);
  87 |     | 
  88 |     |         // Must return latestRoundData without error
  89 |     |         chainlink.latestRoundData();
  90 |     | 
  91 |     |         // Must return decimals that match the definition
  92 |     |         if (decimals != chainlink.decimals()) {
  93 |     |             return false;
  94 |     |         }
  95 |     | 
  96 |     |         return true;
  97 |     |     }
  98 |     | }
  99 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ConstantNode.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "../storage/NodeDefinition.sol";
  5 |     | import "../storage/NodeOutput.sol";
  6 |     | 
  7 |     | library ConstantNode {
  8 |     |     function process(
  9 |     |         bytes memory parameters
 10 |     |     ) internal view returns (NodeOutput.Data memory nodeOutput) {
 11 |     |         return NodeOutput.Data(abi.decode(parameters, (int256)), block.timestamp, 0, 0);
 12 |     |     }
 13 |     | 
 14 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {
 15 |     |         // Must have no parents
 16 |     |         if (nodeDefinition.parents.length > 0) {
 17 |     |             return false;
 18 |     |         }
 19 |     | 
 20 |     |         // Must have correct length of parameters data
 21 |     |         if (nodeDefinition.parameters.length < 32) {
 22 |     |             return false;
 23 |     |         }
 24 |     | 
 25 |     |         return true;
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ExternalNode.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/ERC165Helper.sol";
  5 |     | 
  6 |     | import "../storage/NodeDefinition.sol";
  7 |     | import "../storage/NodeOutput.sol";
  8 |     | import "../interfaces/external/IExternalNode.sol";
  9 |     | 
 10 |     | library ExternalNode {
 11 |     |     function process(
 12 |     |         NodeOutput.Data[] memory prices,
 13 |     |         bytes memory parameters,
 14 |     |         bytes32[] memory runtimeKeys,
 15 |     |         bytes32[] memory runtimeValues
 16 |     |     ) internal view returns (NodeOutput.Data memory nodeOutput) {
 17 |     |         IExternalNode externalNode = IExternalNode(abi.decode(parameters, (address)));
 18 |     |         return externalNode.process(prices, parameters, runtimeKeys, runtimeValues);
 19 |     |     }
 20 |     | 
 21 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal returns (bool valid) {
 22 |     |         // Must have correct length of parameters data
 23 |     |         if (nodeDefinition.parameters.length < 32) {
 24 |     |             return false;
 25 |     |         }
 26 |     | 
 27 |     |         address externalNode = abi.decode(nodeDefinition.parameters, (address));
 28 |     |         if (!ERC165Helper.safeSupportsInterface(externalNode, type(IExternalNode).interfaceId)) {
 29 |     |             return false;
 30 |     |         }
 31 |     | 
 32 |     |         if (!IExternalNode(externalNode).isValid(nodeDefinition)) {
 33 |     |             return false;
 34 |     |         }
 35 |     | 
 36 |     |         return true;
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/PriceDeviationCircuitBreakerNode.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  5 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
  6 |     | 
  7 |     | import "../storage/NodeDefinition.sol";
  8 |     | import "../storage/NodeOutput.sol";
  9 |     | 
 10 |     | library PriceDeviationCircuitBreakerNode {
 11 |     |     using SafeCastU256 for uint256;
 12 |     |     using DecimalMath for int256;
 13 |     | 
 14 |     |     error DeviationToleranceExceeded(int256 deviation);
 15 |     |     error InvalidInputPrice();
 16 |     | 
 17 |     |     function process(
 18 |     |         NodeOutput.Data[] memory parentNodeOutputs,
 19 |     |         bytes memory parameters
 20 |     |     ) internal pure returns (NodeOutput.Data memory nodeOutput) {
 21 |     |         uint256 deviationTolerance = abi.decode(parameters, (uint256));
 22 |     | 
 23 |     |         int256 primaryPrice = parentNodeOutputs[0].price;
 24 |     |         int256 comparisonPrice = parentNodeOutputs[1].price;
 25 |     | 
 26 |     |         if (primaryPrice != comparisonPrice) {
 27 |     |             int256 difference = abs(primaryPrice - comparisonPrice).upscale(18);
 28 |     |             if (
 29 |     |                 primaryPrice == 0 || deviationTolerance.toInt() < (difference / abs(primaryPrice))
 30 |     |             ) {
 31 |     |                 if (parentNodeOutputs.length > 2) {
 32 |     |                     return parentNodeOutputs[2];
 33 |     |                 } else {
 34 |     |                     if (primaryPrice == 0) {
 35 |     |                         revert InvalidInputPrice();
 36 |     |                     } else {
 37 |     |                         revert DeviationToleranceExceeded(difference / abs(primaryPrice));
 38 |     |                     }
 39 |     |                 }
 40 |     |             }
 41 |     |         }
 42 |     | 
 43 |     |         return parentNodeOutputs[0];
 44 |     |     }
 45 |     | 
 46 |     |     function abs(int256 x) private pure returns (int256 result) {
 47 |     |         return x >= 0 ? x : -x;
 48 |     |     }
 49 |     | 
 50 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {
 51 |     |         // Must have 2-3 parents
 52 |     |         if (!(nodeDefinition.parents.length == 2 || nodeDefinition.parents.length == 3)) {
 53 |     |             return false;
 54 |     |         }
 55 |     | 
 56 |     |         // Must have correct length of parameters data
 57 |     |         if (nodeDefinition.parameters.length != 32) {
 58 |     |             return false;
 59 |     |         }
 60 |     | 
 61 |     |         return true;
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/ReducerNode.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | 
   7 |     | import "../storage/NodeDefinition.sol";
   8 |     | import "../storage/NodeOutput.sol";
   9 |     | 
  10 |     | library ReducerNode {
  11 |     |     using SafeCastI256 for int256;
  12 |     |     using SafeCastU256 for uint256;
  13 |     |     using DecimalMath for int256;
  14 |     | 
  15 |     |     error UnsupportedOperation(Operations operation);
  16 |     |     error InvalidPrice(int256 price);
  17 |     | 
  18 |     |     enum Operations {
  19 |     |         RECENT,
  20 |     |         MIN,
  21 |     |         MAX,
  22 |     |         MEAN,
  23 |     |         MEDIAN,
  24 |     |         MUL,
  25 |     |         DIV,
  26 |     |         MULDECIMAL,
  27 |     |         DIVDECIMAL
  28 |     |     }
  29 |     | 
  30 |     |     function process(
  31 |     |         NodeOutput.Data[] memory parentNodeOutputs,
  32 |     |         bytes memory parameters
  33 |     |     ) internal pure returns (NodeOutput.Data memory nodeOutput) {
  34 |     |         Operations operation = abi.decode(parameters, (Operations));
  35 |     | 
  36 |     |         if (operation == Operations.RECENT) {
  37 |     |             return recent(parentNodeOutputs);
  38 |     |         }
  39 |     |         if (operation == Operations.MIN) {
  40 |     |             return min(parentNodeOutputs);
  41 |     |         }
  42 |     |         if (operation == Operations.MAX) {
  43 |     |             return max(parentNodeOutputs);
  44 |     |         }
  45 |     |         if (operation == Operations.MEAN) {
  46 |     |             return mean(parentNodeOutputs);
  47 |     |         }
  48 |     |         if (operation == Operations.MEDIAN) {
  49 |     |             return median(parentNodeOutputs);
  50 |     |         }
  51 |     |         if (operation == Operations.MUL) {
  52 |     |             return mul(parentNodeOutputs);
  53 |     |         }
  54 |     |         if (operation == Operations.DIV) {
  55 |     |             return div(parentNodeOutputs);
  56 |     |         }
  57 |     |         if (operation == Operations.MULDECIMAL) {
  58 |     |             return mulDecimal(parentNodeOutputs);
  59 |     |         }
  60 |     |         if (operation == Operations.DIVDECIMAL) {
  61 |     |             return divDecimal(parentNodeOutputs);
  62 |     |         }
  63 |     | 
  64 |     |         revert UnsupportedOperation(operation);
  65 |     |     }
  66 |     | 
  67 |     |     function median(
  68 |     |         NodeOutput.Data[] memory parentNodeOutputs
  69 |     |     ) internal pure returns (NodeOutput.Data memory medianPrice) {
  70 |     |         quickSort(parentNodeOutputs, SafeCastI256.zero(), (parentNodeOutputs.length - 1).toInt());
  71 |     |         if (parentNodeOutputs.length % 2 == 0) {
  72 |     |             NodeOutput.Data[] memory middleSet = new NodeOutput.Data[](2);
  73 |     |             middleSet[0] = parentNodeOutputs[(parentNodeOutputs.length / 2) - 1];
  74 |     |             middleSet[1] = parentNodeOutputs[(parentNodeOutputs.length / 2)];
  75 |     |             return mean(middleSet);
  76 |     |         } else {
  77 |     |             return parentNodeOutputs[parentNodeOutputs.length / 2];
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     function mean(
  82 |     |         NodeOutput.Data[] memory parentNodeOutputs
  83 |     |     ) internal pure returns (NodeOutput.Data memory meanPrice) {
  84 |     |         for (uint256 i = 0; i < parentNodeOutputs.length; i++) {
  85 |     |             meanPrice.price += parentNodeOutputs[i].price;
  86 |     |             meanPrice.timestamp += parentNodeOutputs[i].timestamp;
  87 |     |         }
  88 |     | 
  89 |     |         meanPrice.price = meanPrice.price / parentNodeOutputs.length.toInt();
  90 |     |         meanPrice.timestamp = meanPrice.timestamp / parentNodeOutputs.length;
  91 |     |     }
  92 |     | 
  93 |     |     function recent(
  94 |     |         NodeOutput.Data[] memory parentNodeOutputs
  95 |     |     ) internal pure returns (NodeOutput.Data memory recentPrice) {
  96 |     |         for (uint256 i = 0; i < parentNodeOutputs.length; i++) {
  97 |     |             if (parentNodeOutputs[i].timestamp > recentPrice.timestamp) {
  98 |     |                 recentPrice = parentNodeOutputs[i];
  99 |     |             }
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     function max(
 104 |     |         NodeOutput.Data[] memory parentNodeOutputs
 105 |     |     ) internal pure returns (NodeOutput.Data memory maxPrice) {
 106 |     |         maxPrice = parentNodeOutputs[0];
 107 |     |         for (uint256 i = 1; i < parentNodeOutputs.length; i++) {
 108 |     |             if (parentNodeOutputs[i].price > maxPrice.price) {
 109 |     |                 maxPrice = parentNodeOutputs[i];
 110 |     |             }
 111 |     |         }
 112 |     |     }
 113 |     | 
 114 |     |     function min(
 115 |     |         NodeOutput.Data[] memory parentNodeOutputs
 116 |     |     ) internal pure returns (NodeOutput.Data memory minPrice) {
 117 |     |         minPrice = parentNodeOutputs[0];
 118 |     |         for (uint256 i = 1; i < parentNodeOutputs.length; i++) {
 119 |     |             if (parentNodeOutputs[i].price < minPrice.price) {
 120 |     |                 minPrice = parentNodeOutputs[i];
 121 |     |             }
 122 |     |         }
 123 |     |     }
 124 |     | 
 125 |     |     function mul(
 126 |     |         NodeOutput.Data[] memory parentNodeOutputs
 127 |     |     ) internal pure returns (NodeOutput.Data memory mulPrice) {
 128 |     |         mulPrice.price = parentNodeOutputs[0].price;
 129 |     |         mulPrice.timestamp = parentNodeOutputs[0].timestamp;
 130 |     |         for (uint256 i = 1; i < parentNodeOutputs.length; i++) {
 131 |     |             mulPrice.price *= parentNodeOutputs[i].price;
 132 |     |             mulPrice.timestamp += parentNodeOutputs[i].timestamp;
 133 |     |         }
 134 |     |         mulPrice.timestamp = mulPrice.timestamp / parentNodeOutputs.length;
 135 |     |     }
 136 |     | 
 137 |     |     function div(
 138 |     |         NodeOutput.Data[] memory parentNodeOutputs
 139 |     |     ) internal pure returns (NodeOutput.Data memory divPrice) {
 140 |     |         divPrice.price = parentNodeOutputs[0].price;
 141 |     |         divPrice.timestamp = parentNodeOutputs[0].timestamp;
 142 |     |         for (uint256 i = 1; i < parentNodeOutputs.length; i++) {
 143 |     |             if (parentNodeOutputs[i].price == 0) {
 144 |     |                 revert InvalidPrice(parentNodeOutputs[i].price);
 145 |     |             }
 146 |     |             divPrice.price /= parentNodeOutputs[i].price;
 147 |     |             divPrice.timestamp += parentNodeOutputs[i].timestamp;
 148 |     |         }
 149 |     |         divPrice.timestamp = divPrice.timestamp / parentNodeOutputs.length;
 150 |     |     }
 151 |     | 
 152 |     |     function mulDecimal(
 153 |     |         NodeOutput.Data[] memory parentNodeOutputs
 154 |     |     ) internal pure returns (NodeOutput.Data memory mulPrice) {
 155 |     |         mulPrice.price = parentNodeOutputs[0].price;
 156 |     |         mulPrice.timestamp = parentNodeOutputs[0].timestamp;
 157 |     |         for (uint256 i = 1; i < parentNodeOutputs.length; i++) {
 158 |     |             mulPrice.price = mulPrice.price.mulDecimal(parentNodeOutputs[i].price);
 159 |     |             mulPrice.timestamp += parentNodeOutputs[i].timestamp;
 160 |     |         }
 161 |     |         mulPrice.timestamp = mulPrice.timestamp / parentNodeOutputs.length;
 162 |     |     }
 163 |     | 
 164 |     |     function divDecimal(
 165 |     |         NodeOutput.Data[] memory parentNodeOutputs
 166 |     |     ) internal pure returns (NodeOutput.Data memory divPrice) {
 167 |     |         divPrice.price = parentNodeOutputs[0].price;
 168 |     |         divPrice.timestamp = parentNodeOutputs[0].timestamp;
 169 |     |         for (uint256 i = 1; i < parentNodeOutputs.length; i++) {
 170 |     |             if (parentNodeOutputs[i].price == 0) {
 171 |     |                 revert InvalidPrice(parentNodeOutputs[i].price);
 172 |     |             }
 173 |     |             divPrice.price = divPrice.price.divDecimal(parentNodeOutputs[i].price);
 174 |     |             divPrice.timestamp += parentNodeOutputs[i].timestamp;
 175 |     |         }
 176 |     |         divPrice.timestamp = divPrice.timestamp / parentNodeOutputs.length;
 177 |     |     }
 178 |     | 
 179 |     |     function quickSort(NodeOutput.Data[] memory arr, int256 left, int256 right) internal pure {
 180 |     |         int256 i = left;
 181 |     |         int256 j = right;
 182 |     |         if (i == j) return;
 183 |     |         int256 pivot = arr[(left + (right - left) / 2).toUint()].price;
 184 |     |         while (i <= j) {
 185 |     |             while (arr[i.toUint()].price < pivot) i++;
 186 |     |             while (pivot < arr[j.toUint()].price) j--;
 187 |     |             if (i <= j) {
 188 |     |                 (arr[i.toUint()], arr[j.toUint()]) = (arr[j.toUint()], arr[i.toUint()]);
 189 |     |                 i++;
 190 |     |                 j--;
 191 |     |             }
 192 |     |         }
 193 |     |         if (left < j) quickSort(arr, left, j);
 194 |     |         if (i < right) quickSort(arr, i, right);
 195 |     |     }
 196 |     | 
 197 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {
 198 |     |         // Must have at least 2 parents
 199 |     |         if (nodeDefinition.parents.length < 2) {
 200 |     |             return false;
 201 |     |         }
 202 |     | 
 203 |     |         // Must have correct length of parameters data
 204 |     |         if (nodeDefinition.parameters.length != 32) {
 205 |     |             return false;
 206 |     |         }
 207 |     | 
 208 |     |         // Must have valid operation
 209 |     |         uint256 operationId = abi.decode(nodeDefinition.parameters, (uint256));
 210 |     |         if (operationId > 8) {
 211 |     |             return false;
 212 |     |         }
 213 |     | 
 214 |     |         return true;
 215 |     |     }
 216 |     | }
 217 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/StalenessCircuitBreakerNode.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {SafeCastBytes32} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  5 |     | import {NodeDefinition} from "../storage/NodeDefinition.sol";
  6 |     | import {NodeOutput} from "../storage/NodeOutput.sol";
  7 |     | 
  8 |     | library StalenessCircuitBreakerNode {
  9 |     |     using SafeCastBytes32 for bytes32;
 10 |     | 
 11 |     |     error StalenessToleranceExceeded();
 12 |     | 
 13 |     |     function process(
 14 |     |         NodeDefinition.Data memory nodeDefinition,
 15 |     |         bytes32[] memory runtimeKeys,
 16 |     |         bytes32[] memory runtimeValues
 17 |     |     ) internal view returns (NodeOutput.Data memory nodeOutput) {
 18 |     |         uint256 stalenessTolerance = abi.decode(nodeDefinition.parameters, (uint256));
 19 |     | 
 20 |     |         for (uint256 i = 0; i < runtimeKeys.length; i++) {
 21 |     |             if (runtimeKeys[i] == "stalenessTolerance") {
 22 |     |                 stalenessTolerance = runtimeValues[i].toUint();
 23 |     |                 break;
 24 |     |             }
 25 |     |         }
 26 |     | 
 27 |     |         bytes32 priceNodeId = nodeDefinition.parents[0];
 28 |     |         NodeOutput.Data memory priceNodeOutput = NodeDefinition.process(
 29 |     |             priceNodeId,
 30 |     |             runtimeKeys,
 31 |     |             runtimeValues
 32 |     |         );
 33 |     | 
 34 |     |         if (block.timestamp - priceNodeOutput.timestamp <= stalenessTolerance) {
 35 |     |             return priceNodeOutput;
 36 |     |         } else if (nodeDefinition.parents.length == 1) {
 37 |     |             revert StalenessToleranceExceeded();
 38 |     |         }
 39 |     |         // If there are two parents, return the output of the second parent (which in this case, should revert with OracleDataRequired)
 40 |     |         return NodeDefinition.process(nodeDefinition.parents[1], runtimeKeys, runtimeValues);
 41 |     |     }
 42 |     | 
 43 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {
 44 |     |         // Must have 1-2 parents
 45 |     |         if (!(nodeDefinition.parents.length == 1 || nodeDefinition.parents.length == 2)) {
 46 |     |             return false;
 47 |     |         }
 48 |     | 
 49 |     |         // Must have correct length of parameters data
 50 |     |         if (nodeDefinition.parameters.length != 32) {
 51 |     |             return false;
 52 |     |         }
 53 |     | 
 54 |     |         return true;
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/UniswapNode.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   5 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   6 |     | import "@synthetixio/core-contracts/contracts/interfaces/IERC20.sol";
   7 |     | 
   8 |     | import "../utils/FullMath.sol";
   9 |     | import "../utils/TickMath.sol";
  10 |     | 
  11 |     | import "../storage/NodeDefinition.sol";
  12 |     | import "../storage/NodeOutput.sol";
  13 |     | import "../interfaces/external/IUniswapV3Pool.sol";
  14 |     | 
  15 |     | library UniswapNode {
  16 |     |     using SafeCastU256 for uint256;
  17 |     |     using SafeCastU160 for uint160;
  18 |     |     using SafeCastU56 for uint56;
  19 |     |     using SafeCastU32 for uint32;
  20 |     |     using SafeCastI56 for int56;
  21 |     |     using SafeCastI256 for int256;
  22 |     | 
  23 |     |     using DecimalMath for int256;
  24 |     | 
  25 |     |     uint8 public constant PRECISION = 18;
  26 |     | 
  27 |     |     function process(
  28 |     |         bytes memory parameters
  29 |     |     ) internal view returns (NodeOutput.Data memory nodeOutput) {
  30 |     |         (
  31 |     |             address token,
  32 |     |             address stablecoin,
  33 |     |             uint8 decimalsToken,
  34 |     |             uint8 decimalsStablecoin,
  35 |     |             address pool,
  36 |     |             uint32 secondsAgo
  37 |     |         ) = abi.decode(parameters, (address, address, uint8, uint8, address, uint32));
  38 |     | 
  39 |     |         uint32[] memory secondsAgos = new uint32[](2);
  40 |     |         secondsAgos[0] = secondsAgo;
  41 |     |         secondsAgos[1] = 0;
  42 |     | 
  43 |     |         (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondsAgos);
  44 |     | 
  45 |     |         int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
  46 |     | 
  47 |     |         int24 tick = (tickCumulativesDelta / secondsAgo.to56().toInt()).to24();
  48 |     | 
  49 |     |         if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo.to256().toInt() != 0)) {
  50 |     |             tick--;
  51 |     |         }
  52 |     | 
  53 |     |         uint256 baseAmount = 10 ** PRECISION;
  54 |     |         int256 price = getQuoteAtTick(tick, baseAmount, token, stablecoin).toInt();
  55 |     | 
  56 |     |         // solhint-disable-next-line numcast/safe-cast
  57 |     |         int256 scale = uint256(decimalsToken).toInt() - uint256(decimalsStablecoin).toInt();
  58 |     | 
  59 |     |         int256 finalPrice = scale > 0
  60 |     |             ? price.upscale(scale.toUint())
  61 |     |             : price.downscale((-scale).toUint());
  62 |     | 
  63 |     |         return NodeOutput.Data(finalPrice, block.timestamp, 0, 0);
  64 |     |     }
  65 |     | 
  66 |     |     function getQuoteAtTick(
  67 |     |         int24 tick,
  68 |     |         uint256 baseAmount,
  69 |     |         address baseToken,
  70 |     |         address quoteToken
  71 |     |     ) internal pure returns (uint256 quoteAmount) {
  72 |     |         uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
  73 |     | 
  74 |     |         // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
  75 |     |         if (sqrtRatioX96 <= type(uint128).max) {
  76 |     |             uint256 ratioX192 = sqrtRatioX96.to256() * sqrtRatioX96;
  77 |     |             quoteAmount = baseToken < quoteToken
  78 |     |                 ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
  79 |     |                 : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
  80 |     |         } else {
  81 |     |             uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
  82 |     |             quoteAmount = baseToken < quoteToken
  83 |     |                 ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
  84 |     |                 : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
  85 |     |         }
  86 |     |     }
  87 |     | 
  88 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal view returns (bool valid) {
  89 |     |         // Must have no parents
  90 |     |         if (nodeDefinition.parents.length > 0) {
  91 |     |             return false;
  92 |     |         }
  93 |     | 
  94 |     |         // Must have correct length of parameters data
  95 |     |         if (nodeDefinition.parameters.length != 192) {
  96 |     |             return false;
  97 |     |         }
  98 |     | 
  99 |     |         (
 100 |     |             address token,
 101 |     |             address stablecoin,
 102 |     |             uint8 decimalsToken,
 103 |     |             uint8 decimalsStablecoin,
 104 |     |             address pool,
 105 |     |             uint32 secondsAgo
 106 |     |         ) = abi.decode(
 107 |     |                 nodeDefinition.parameters,
 108 |     |                 (address, address, uint8, uint8, address, uint32)
 109 |     |             );
 110 |     | 
 111 |     |         if (IERC20(token).decimals() != decimalsToken) {
 112 |     |             return false;
 113 |     |         }
 114 |     | 
 115 |     |         if (IERC20(stablecoin).decimals() != decimalsStablecoin) {
 116 |     |             return false;
 117 |     |         }
 118 |     | 
 119 |     |         address poolToken0 = IUniswapV3Pool(pool).token0();
 120 |     |         address poolToken1 = IUniswapV3Pool(pool).token1();
 121 |     | 
 122 |     |         if (
 123 |     |             !(poolToken0 == token && poolToken1 == stablecoin) &&
 124 |     |             !(poolToken0 == stablecoin && poolToken1 == token)
 125 |     |         ) {
 126 |     |             return false;
 127 |     |         }
 128 |     | 
 129 |     |         if (decimalsToken > 18 || decimalsStablecoin > 18) {
 130 |     |             return false;
 131 |     |         }
 132 |     | 
 133 |     |         if (secondsAgo == 0) {
 134 |     |             return false;
 135 |     |         }
 136 |     | 
 137 |     |         // Must call relevant function without error
 138 |     |         uint32[] memory secondsAgos = new uint32[](2);
 139 |     |         secondsAgos[0] = secondsAgo;
 140 |     |         secondsAgos[1] = 0;
 141 |     |         IUniswapV3Pool(pool).observe(secondsAgos);
 142 |     | 
 143 |     |         return true;
 144 |     |     }
 145 |     | }
 146 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/pyth/PythNode.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
  5 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  6 |     | 
  7 |     | import "../../storage/NodeDefinition.sol";
  8 |     | import "../../storage/NodeOutput.sol";
  9 |     | import "../../interfaces/external/IPyth.sol";
 10 |     | 
 11 |     | library PythNode {
 12 |     |     using DecimalMath for int64;
 13 |     |     using SafeCastI256 for int256;
 14 |     | 
 15 |     |     int256 public constant PRECISION = 18;
 16 |     | 
 17 |     |     function process(
 18 |     |         bytes memory parameters
 19 |     |     ) internal view returns (NodeOutput.Data memory nodeOutput) {
 20 |     |         (address pythAddress, bytes32 priceFeedId, bool useEma) = abi.decode(
 21 |     |             parameters,
 22 |     |             (address, bytes32, bool)
 23 |     |         );
 24 |     |         IPyth pyth = IPyth(pythAddress);
 25 |     |         PythStructs.Price memory pythData = useEma
 26 |     |             ? pyth.getEmaPriceUnsafe(priceFeedId)
 27 |     |             : pyth.getPriceUnsafe(priceFeedId);
 28 |     | 
 29 |     |         int256 factor = PRECISION + pythData.expo;
 30 |     |         int256 price = factor > 0
 31 |     |             ? pythData.price.upscale(factor.toUint())
 32 |     |             : pythData.price.downscale((-factor).toUint());
 33 |     | 
 34 |     |         return NodeOutput.Data(price, pythData.publishTime, 0, 0);
 35 |     |     }
 36 |     | 
 37 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal view returns (bool valid) {
 38 |     |         // Must have no parents
 39 |     |         if (nodeDefinition.parents.length > 0) {
 40 |     |             return false;
 41 |     |         }
 42 |     | 
 43 |     |         // Must have correct length of parameters data
 44 |     |         if (nodeDefinition.parameters.length != 32 * 3) {
 45 |     |             return false;
 46 |     |         }
 47 |     | 
 48 |     |         (address pythAddress, bytes32 priceFeedId, bool useEma) = abi.decode(
 49 |     |             nodeDefinition.parameters,
 50 |     |             (address, bytes32, bool)
 51 |     |         );
 52 |     |         IPyth pyth = IPyth(pythAddress);
 53 |     | 
 54 |     |         // Must return relevant function without error
 55 |     |         useEma ? pyth.getEmaPriceUnsafe(priceFeedId) : pyth.getPriceUnsafe(priceFeedId);
 56 |     | 
 57 |     |         return true;
 58 |     |     }
 59 |     | }
 60 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/nodes/pyth/PythOffchainLookupNode.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
  5 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  6 |     | 
  7 |     | import "../../storage/NodeDefinition.sol";
  8 |     | import "../../storage/NodeOutput.sol";
  9 |     | 
 10 |     | library PythOffchainLookupNode {
 11 |     |     using DecimalMath for int64;
 12 |     |     using SafeCastI256 for int256;
 13 |     | 
 14 |     |     error OracleDataRequired(address oracleContract, bytes oracleQuery);
 15 |     | 
 16 |     |     int256 public constant PRECISION = 18;
 17 |     | 
 18 |     |     function process(
 19 |     |         bytes memory parameters,
 20 |     |         bytes32[] memory runtimeKeys,
 21 |     |         bytes32[] memory runtimeValues
 22 |     |     ) internal pure returns (NodeOutput.Data memory) {
 23 |     |         (address pythAddress, bytes32 priceId, uint256 stalenessTolerance) = abi.decode(
 24 |     |             parameters,
 25 |     |             (address, bytes32, uint256)
 26 |     |         );
 27 |     | 
 28 |     |         for (uint256 i = 0; i < runtimeKeys.length; i++) {
 29 |     |             if (runtimeKeys[i] == "stalenessTolerance") {
 30 |     |                 // solhint-disable-next-line numcast/safe-cast
 31 |     |                 stalenessTolerance = uint256(runtimeValues[i]);
 32 |     |             }
 33 |     |         }
 34 |     | 
 35 |     |         bytes32[] memory priceIds = new bytes32[](1);
 36 |     |         priceIds[0] = priceId;
 37 |     | 
 38 |     |         // In the future Pyth revert data will have the following
 39 |     |         // Query schema:
 40 |     |         //
 41 |     |         // Enum PythQuery {
 42 |     |         //  Latest = 0 {
 43 |     |         //    bytes32[] priceIds,
 44 |     |         //  },
 45 |     |         //  NoOlderThan = 1 {
 46 |     |         //    uint64 stalenessTolerance,
 47 |     |         //    bytes32[] priceIds,
 48 |     |         //  },
 49 |     |         //  Benchmark = 2 {
 50 |     |         //    uint64 publishTime,
 51 |     |         //    bytes32[] priceIds,
 52 |     |         //  }
 53 |     |         // }
 54 |     |         //
 55 |     |         // This contract only implements the PythQuery::NoOlderThan
 56 |     |         revert OracleDataRequired(
 57 |     |             pythAddress,
 58 |     |             abi.encode(
 59 |     |                 // solhint-disable-next-line numcast/safe-cast
 60 |     |                 uint8(1), // PythQuery::NoOlderThan tag
 61 |     |                 // solhint-disable-next-line numcast/safe-cast
 62 |     |                 uint64(stalenessTolerance),
 63 |     |                 priceIds
 64 |     |             )
 65 |     |         );
 66 |     |     }
 67 |     | 
 68 |     |     function isValid(NodeDefinition.Data memory nodeDefinition) internal pure returns (bool valid) {
 69 |     |         // Must have no parents
 70 |     |         if (nodeDefinition.parents.length > 0) {
 71 |     |             return false;
 72 |     |         }
 73 |     | 
 74 |     |         // Must have correct length of parameters data
 75 |     |         if (nodeDefinition.parameters.length != 32 * 3) {
 76 |     |             return false;
 77 |     |         }
 78 |     | 
 79 |     |         abi.decode(nodeDefinition.parameters, (address, bytes32, uint256));
 80 |     | 
 81 |     |         return true;
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/storage/NodeDefinition.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {ParameterError} from "@synthetixio/core-contracts/contracts/errors/ParameterError.sol";
   5 |     | import {NodeOutput} from "./NodeOutput.sol";
   6 |     | 
   7 |     | import "../nodes/ReducerNode.sol";
   8 |     | import "../nodes/ExternalNode.sol";
   9 |     | import "../nodes/pyth/PythNode.sol";
  10 |     | import "../nodes/pyth/PythOffchainLookupNode.sol";
  11 |     | import "../nodes/ChainlinkNode.sol";
  12 |     | import "../nodes/PriceDeviationCircuitBreakerNode.sol";
  13 |     | import "../nodes/StalenessCircuitBreakerNode.sol";
  14 |     | import "../nodes/UniswapNode.sol";
  15 |     | import "../nodes/ConstantNode.sol";
  16 |     | 
  17 |     | library NodeDefinition {
  18 |     |     /**
  19 |     |      * @notice Thrown when a node cannot be processed
  20 |     |      */
  21 |     |     error UnprocessableNode(bytes32 nodeId);
  22 |     | 
  23 |     |     enum NodeType {
  24 |     |         NONE,
  25 |     |         REDUCER,
  26 |     |         EXTERNAL,
  27 |     |         CHAINLINK,
  28 |     |         UNISWAP,
  29 |     |         PYTH,
  30 |     |         PRICE_DEVIATION_CIRCUIT_BREAKER,
  31 |     |         STALENESS_CIRCUIT_BREAKER,
  32 |     |         CONSTANT,
  33 |     |         PYTH_OFFCHAIN_LOOKUP // works in conjunction with PYTH node
  34 |     |     }
  35 |     | 
  36 |     |     struct Data {
  37 |     |         /**
  38 |     |          * @dev Oracle node type enum
  39 |     |          */
  40 |     |         NodeType nodeType;
  41 |     |         /**
  42 |     |          * @dev Node parameters, specific to each node type
  43 |     |          */
  44 |     |         bytes parameters;
  45 |     |         /**
  46 |     |          * @dev Parent node IDs, if any
  47 |     |          */
  48 |     |         bytes32[] parents;
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @dev Returns the node stored at the specified node ID.
  53 |     |      */
  54 |     |     function load(bytes32 id) internal pure returns (Data storage node) {
  55 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.oracle-manager.Node", id));
  56 |     |         assembly {
  57 |     |             node.slot := s
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Register a new node for a given node definition. The resulting node is a function of the definition.
  63 |     |      */
  64 |     |     function create(
  65 |     |         Data memory nodeDefinition
  66 |     |     ) internal returns (NodeDefinition.Data storage node, bytes32 id) {
  67 |     |         id = getId(nodeDefinition);
  68 |     | 
  69 |     |         node = load(id);
  70 |     | 
  71 |     |         node.nodeType = nodeDefinition.nodeType;
  72 |     |         node.parameters = nodeDefinition.parameters;
  73 |     |         node.parents = nodeDefinition.parents;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev Returns a node ID based on its definition
  78 |     |      */
  79 |     |     function getId(Data memory nodeDefinition) internal pure returns (bytes32 id) {
  80 |     |         return
  81 |     |             keccak256(
  82 |     |                 abi.encode(
  83 |     |                     nodeDefinition.nodeType,
  84 |     |                     nodeDefinition.parameters,
  85 |     |                     nodeDefinition.parents
  86 |     |                 )
  87 |     |             );
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Returns the output of a specified node.
  92 |     |      */
  93 |     |     function process(
  94 |     |         bytes32 nodeId,
  95 |     |         bytes32[] memory runtimeKeys,
  96 |     |         bytes32[] memory runtimeValues
  97 |     |     ) internal view returns (NodeOutput.Data memory price) {
  98 |     |         if (runtimeKeys.length != runtimeValues.length) {
  99 |     |             revert ParameterError.InvalidParameter(
 100 |     |                 "runtimeValues",
 101 |     |                 "must be same length as runtimeKeys"
 102 |     |             );
 103 |     |         }
 104 |     | 
 105 |     |         Data storage nodeDefinition = load(nodeId);
 106 |     |         NodeType nodeType = nodeDefinition.nodeType;
 107 |     | 
 108 |     |         if (nodeType == NodeType.REDUCER) {
 109 |     |             return
 110 |     |                 ReducerNode.process(
 111 |     |                     _processParentNodeOutputs(nodeDefinition, runtimeKeys, runtimeValues),
 112 |     |                     nodeDefinition.parameters
 113 |     |                 );
 114 |     |         } else if (nodeType == NodeType.EXTERNAL) {
 115 |     |             return
 116 |     |                 ExternalNode.process(
 117 |     |                     _processParentNodeOutputs(nodeDefinition, runtimeKeys, runtimeValues),
 118 |     |                     nodeDefinition.parameters,
 119 |     |                     runtimeKeys,
 120 |     |                     runtimeValues
 121 |     |                 );
 122 |     |         } else if (nodeType == NodeType.CHAINLINK) {
 123 |     |             return ChainlinkNode.process(nodeDefinition.parameters);
 124 |     |         } else if (nodeType == NodeType.UNISWAP) {
 125 |     |             return UniswapNode.process(nodeDefinition.parameters);
 126 |     |         } else if (nodeType == NodeType.PYTH) {
 127 |     |             return PythNode.process(nodeDefinition.parameters);
 128 |     |         } else if (nodeType == NodeType.PYTH_OFFCHAIN_LOOKUP) {
 129 |     |             return
 130 |     |                 PythOffchainLookupNode.process(
 131 |     |                     nodeDefinition.parameters,
 132 |     |                     runtimeKeys,
 133 |     |                     runtimeValues
 134 |     |                 );
 135 |     |         } else if (nodeType == NodeType.PRICE_DEVIATION_CIRCUIT_BREAKER) {
 136 |     |             return
 137 |     |                 PriceDeviationCircuitBreakerNode.process(
 138 |     |                     _processParentNodeOutputs(nodeDefinition, runtimeKeys, runtimeValues),
 139 |     |                     nodeDefinition.parameters
 140 |     |                 );
 141 |     |         } else if (nodeType == NodeType.STALENESS_CIRCUIT_BREAKER) {
 142 |     |             return StalenessCircuitBreakerNode.process(nodeDefinition, runtimeKeys, runtimeValues);
 143 |     |         } else if (nodeType == NodeType.CONSTANT) {
 144 |     |             return ConstantNode.process(nodeDefinition.parameters);
 145 |     |         }
 146 |     |         revert UnprocessableNode(nodeId);
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev helper function that calls process on parent nodes.
 151 |     |      */
 152 |     |     function _processParentNodeOutputs(
 153 |     |         Data storage nodeDefinition,
 154 |     |         bytes32[] memory runtimeKeys,
 155 |     |         bytes32[] memory runtimeValues
 156 |     |     ) private view returns (NodeOutput.Data[] memory parentNodeOutputs) {
 157 |     |         parentNodeOutputs = new NodeOutput.Data[](nodeDefinition.parents.length);
 158 |     |         for (uint256 i = 0; i < nodeDefinition.parents.length; i++) {
 159 |     |             parentNodeOutputs[i] = process(nodeDefinition.parents[i], runtimeKeys, runtimeValues);
 160 |     |         }
 161 |     |     }
 162 |     | }
 163 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | library NodeOutput {
  5 |     |     struct Data {
  6 |     |         /**
  7 |     |          * @dev Price returned from the oracle node, expressed with 18 decimals of precision
  8 |     |          */
  9 |     |         int256 price;
 10 |     |         /**
 11 |     |          * @dev Timestamp associated with the price
 12 |     |          */
 13 |     |         uint256 timestamp;
 14 |     |         // solhint-disable-next-line private-vars-leading-underscore
 15 |     |         uint256 __slotAvailableForFutureUse1;
 16 |     |         // solhint-disable-next-line private-vars-leading-underscore
 17 |     |         uint256 __slotAvailableForFutureUse2;
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/utils/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   5 |     | 
   6 |     | /// @title Contains 512-bit math functions
   7 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   8 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   9 |     | library FullMath {
  10 |     |     using SafeCastU256 for uint256;
  11 |     |     using SafeCastI256 for int256;
  12 |     | 
  13 |     |     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  14 |     |     /// @param a The multiplicand
  15 |     |     /// @param b The multiplier
  16 |     |     /// @param denominator The divisor
  17 |     |     /// @return result The 256-bit result
  18 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  19 |     |     function mulDiv(
  20 |     |         uint256 a,
  21 |     |         uint256 b,
  22 |     |         uint256 denominator
  23 |     |     ) internal pure returns (uint256 result) {
  24 |     |         // 512-bit multiply [prod1 prod0] = a * b
  25 |     |         // Compute the product mod 2**256 and mod 2**256 - 1
  26 |     |         // then use the Chinese Remainder Theorem to reconstruct
  27 |     |         // the 512 bit result. The result is stored in two 256
  28 |     |         // variables such that product = prod1 * 2**256 + prod0
  29 |     |         uint256 prod0; // Least significant 256 bits of the product
  30 |     |         uint256 prod1; // Most significant 256 bits of the product
  31 |     |         assembly {
  32 |     |             let mm := mulmod(a, b, not(0))
  33 |     |             prod0 := mul(a, b)
  34 |     |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  35 |     |         }
  36 |     | 
  37 |     |         // Handle non-overflow cases, 256 by 256 division
  38 |     |         if (prod1 == 0) {
  39 |     |             require(denominator > 0, "Handle non-overflow cases");
  40 |     |             assembly {
  41 |     |                 result := div(prod0, denominator)
  42 |     |             }
  43 |     |             return result;
  44 |     |         }
  45 |     | 
  46 |     |         // Make sure the result is less than 2**256.
  47 |     |         // Also prevents denominator == 0
  48 |     |         require(denominator > prod1, "prevents denominator == 0");
  49 |     | 
  50 |     |         ///////////////////////////////////////////////
  51 |     |         // 512 by 256 division.
  52 |     |         ///////////////////////////////////////////////
  53 |     | 
  54 |     |         // Make division exact by subtracting the remainder from [prod1 prod0]
  55 |     |         // Compute remainder using mulmod
  56 |     |         uint256 remainder;
  57 |     |         assembly {
  58 |     |             remainder := mulmod(a, b, denominator)
  59 |     |         }
  60 |     |         // Subtract 256 bit number from 512 bit number
  61 |     |         assembly {
  62 |     |             prod1 := sub(prod1, gt(remainder, prod0))
  63 |     |             prod0 := sub(prod0, remainder)
  64 |     |         }
  65 |     | 
  66 |     |         // Factor powers of two out of denominator
  67 |     |         // Compute largest power of two divisor of denominator.
  68 |     |         // Always >= 1.
  69 |     |         uint256 twos = (-denominator.toInt() & denominator.toInt()).toUint();
  70 |     |         // Divide denominator by power of two
  71 |     |         assembly {
  72 |     |             denominator := div(denominator, twos)
  73 |     |         }
  74 |     | 
  75 |     |         // Divide [prod1 prod0] by the factors of two
  76 |     |         assembly {
  77 |     |             prod0 := div(prod0, twos)
  78 |     |         }
  79 |     |         // Shift in bits from prod1 into prod0. For this we need
  80 |     |         // to flip `twos` such that it is 2**256 / twos.
  81 |     |         // If twos is zero, then it becomes one
  82 |     |         assembly {
  83 |     |             twos := add(div(sub(0, twos), twos), 1)
  84 |     |         }
  85 |     |         prod0 |= prod1 * twos;
  86 |     | 
  87 |     |         // Invert denominator mod 2**256
  88 |     |         // Now that denominator is an odd number, it has an inverse
  89 |     |         // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  90 |     |         // Compute the inverse by starting with a seed that is correct
  91 |     |         // correct for four bits. That is, denominator * inv = 1 mod 2**4
  92 |     |         uint256 inv = (3 * denominator) ^ 2;
  93 |     |         // Now use Newton-Raphson iteration to improve the precision.
  94 |     |         // Thanks to Hensel's lifting lemma, this also works in modular
  95 |     |         // arithmetic, doubling the correct bits in each step.
  96 |     |         inv *= 2 - denominator * inv; // inverse mod 2**8
  97 |     |         inv *= 2 - denominator * inv; // inverse mod 2**16
  98 |     |         inv *= 2 - denominator * inv; // inverse mod 2**32
  99 |     |         inv *= 2 - denominator * inv; // inverse mod 2**64
 100 |     |         inv *= 2 - denominator * inv; // inverse mod 2**128
 101 |     |         inv *= 2 - denominator * inv; // inverse mod 2**256
 102 |     | 
 103 |     |         // Because the division is now exact we can divide by multiplying
 104 |     |         // with the modular inverse of denominator. This will give us the
 105 |     |         // correct result modulo 2**256. Since the precoditions guarantee
 106 |     |         // that the outcome is less than 2**256, this is the final result.
 107 |     |         // We don't need to compute the high bits of the result and prod1
 108 |     |         // is no longer required.
 109 |     |         result = prod0 * inv;
 110 |     |         return result;
 111 |     |     }
 112 |     | 
 113 |     |     /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 114 |     |     /// @param a The multiplicand
 115 |     |     /// @param b The multiplier
 116 |     |     /// @param denominator The divisor
 117 |     |     /// @return result The 256-bit result
 118 |     |     function mulDivRoundingUp(
 119 |     |         uint256 a,
 120 |     |         uint256 b,
 121 |     |         uint256 denominator
 122 |     |     ) internal pure returns (uint256 result) {
 123 |     |         result = mulDiv(a, b, denominator);
 124 |     |         if (mulmod(a, b, denominator) > 0) {
 125 |     |             require(result < type(uint256).max, "result more than max");
 126 |     |             result++;
 127 |     |         }
 128 |     |     }
 129 |     | }
 130 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/oracle-manager/contracts/utils/TickMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   5 |     | 
   6 |     | /// @title Math library for computing sqrt prices from ticks and vice versa
   7 |     | /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
   8 |     | /// prices between 2**-128 and 2**128
   9 |     | library TickMath {
  10 |     |     using SafeCastU256 for uint256;
  11 |     |     using SafeCastI256 for int256;
  12 |     |     using SafeCastI24 for int24;
  13 |     |     using SafeCastU160 for uint160;
  14 |     | 
  15 |     |     /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
  16 |     |     int24 internal constant MIN_TICK = -887272;
  17 |     |     /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  18 |     |     int24 internal constant MAX_TICK = -MIN_TICK;
  19 |     | 
  20 |     |     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  21 |     |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  22 |     |     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  23 |     |     uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
  24 |     | 
  25 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96
  26 |     |     /// @dev Throws if |tick| > max tick
  27 |     |     /// @param tick The input tick for the above formula
  28 |     |     /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  29 |     |     /// at the given tick
  30 |     |     function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
  31 |     |         uint256 absTick = tick < 0 ? (-tick.to256()).toUint() : tick.to256().toUint();
  32 |     |         require(absTick <= MAX_TICK.to256().toUint(), "T");
  33 |     | 
  34 |     |         uint256 ratio = absTick & 0x1 != 0
  35 |     |             ? 0xfffcb933bd6fad37aa2d162d1a594001
  36 |     |             : 0x100000000000000000000000000000000;
  37 |     |         if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  38 |     |         if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  39 |     |         if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  40 |     |         if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  41 |     |         if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  42 |     |         if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  43 |     |         if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  44 |     |         if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  45 |     |         if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  46 |     |         if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  47 |     |         if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  48 |     |         if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  49 |     |         if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  50 |     |         if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  51 |     |         if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  52 |     |         if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  53 |     |         if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  54 |     |         if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  55 |     |         if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  56 |     | 
  57 |     |         if (tick > 0) ratio = type(uint256).max / ratio;
  58 |     | 
  59 |     |         // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  60 |     |         // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  61 |     |         // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  62 |     |         sqrtPriceX96 = ((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)).to160();
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
  66 |     |     /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
  67 |     |     /// ever return.
  68 |     |     /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
  69 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
  70 |     |     function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
  71 |     |         // second inequality must be < because the price can never reach the price at the max tick
  72 |     |         require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, "R");
  73 |     |         uint256 ratio = sqrtPriceX96.to256() << 32;
  74 |     | 
  75 |     |         uint256 r = ratio;
  76 |     |         uint256 msb = 0;
  77 |     | 
  78 |     |         assembly {
  79 |     |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
  80 |     |             msb := or(msb, f)
  81 |     |             r := shr(f, r)
  82 |     |         }
  83 |     |         assembly {
  84 |     |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
  85 |     |             msb := or(msb, f)
  86 |     |             r := shr(f, r)
  87 |     |         }
  88 |     |         assembly {
  89 |     |             let f := shl(5, gt(r, 0xFFFFFFFF))
  90 |     |             msb := or(msb, f)
  91 |     |             r := shr(f, r)
  92 |     |         }
  93 |     |         assembly {
  94 |     |             let f := shl(4, gt(r, 0xFFFF))
  95 |     |             msb := or(msb, f)
  96 |     |             r := shr(f, r)
  97 |     |         }
  98 |     |         assembly {
  99 |     |             let f := shl(3, gt(r, 0xFF))
 100 |     |             msb := or(msb, f)
 101 |     |             r := shr(f, r)
 102 |     |         }
 103 |     |         assembly {
 104 |     |             let f := shl(2, gt(r, 0xF))
 105 |     |             msb := or(msb, f)
 106 |     |             r := shr(f, r)
 107 |     |         }
 108 |     |         assembly {
 109 |     |             let f := shl(1, gt(r, 0x3))
 110 |     |             msb := or(msb, f)
 111 |     |             r := shr(f, r)
 112 |     |         }
 113 |     |         assembly {
 114 |     |             let f := gt(r, 0x1)
 115 |     |             msb := or(msb, f)
 116 |     |         }
 117 |     | 
 118 |     |         if (msb >= 128) r = ratio >> (msb - 127);
 119 |     |         else r = ratio << (127 - msb);
 120 |     | 
 121 |     |         int256 _log2 = (msb.toInt() - 128) << 64;
 122 |     | 
 123 |     |         assembly {
 124 |     |             r := shr(127, mul(r, r))
 125 |     |             let f := shr(128, r)
 126 |     |             _log2 := or(_log2, shl(63, f))
 127 |     |             r := shr(f, r)
 128 |     |         }
 129 |     |         assembly {
 130 |     |             r := shr(127, mul(r, r))
 131 |     |             let f := shr(128, r)
 132 |     |             _log2 := or(_log2, shl(62, f))
 133 |     |             r := shr(f, r)
 134 |     |         }
 135 |     |         assembly {
 136 |     |             r := shr(127, mul(r, r))
 137 |     |             let f := shr(128, r)
 138 |     |             _log2 := or(_log2, shl(61, f))
 139 |     |             r := shr(f, r)
 140 |     |         }
 141 |     |         assembly {
 142 |     |             r := shr(127, mul(r, r))
 143 |     |             let f := shr(128, r)
 144 |     |             _log2 := or(_log2, shl(60, f))
 145 |     |             r := shr(f, r)
 146 |     |         }
 147 |     |         assembly {
 148 |     |             r := shr(127, mul(r, r))
 149 |     |             let f := shr(128, r)
 150 |     |             _log2 := or(_log2, shl(59, f))
 151 |     |             r := shr(f, r)
 152 |     |         }
 153 |     |         assembly {
 154 |     |             r := shr(127, mul(r, r))
 155 |     |             let f := shr(128, r)
 156 |     |             _log2 := or(_log2, shl(58, f))
 157 |     |             r := shr(f, r)
 158 |     |         }
 159 |     |         assembly {
 160 |     |             r := shr(127, mul(r, r))
 161 |     |             let f := shr(128, r)
 162 |     |             _log2 := or(_log2, shl(57, f))
 163 |     |             r := shr(f, r)
 164 |     |         }
 165 |     |         assembly {
 166 |     |             r := shr(127, mul(r, r))
 167 |     |             let f := shr(128, r)
 168 |     |             _log2 := or(_log2, shl(56, f))
 169 |     |             r := shr(f, r)
 170 |     |         }
 171 |     |         assembly {
 172 |     |             r := shr(127, mul(r, r))
 173 |     |             let f := shr(128, r)
 174 |     |             _log2 := or(_log2, shl(55, f))
 175 |     |             r := shr(f, r)
 176 |     |         }
 177 |     |         assembly {
 178 |     |             r := shr(127, mul(r, r))
 179 |     |             let f := shr(128, r)
 180 |     |             _log2 := or(_log2, shl(54, f))
 181 |     |             r := shr(f, r)
 182 |     |         }
 183 |     |         assembly {
 184 |     |             r := shr(127, mul(r, r))
 185 |     |             let f := shr(128, r)
 186 |     |             _log2 := or(_log2, shl(53, f))
 187 |     |             r := shr(f, r)
 188 |     |         }
 189 |     |         assembly {
 190 |     |             r := shr(127, mul(r, r))
 191 |     |             let f := shr(128, r)
 192 |     |             _log2 := or(_log2, shl(52, f))
 193 |     |             r := shr(f, r)
 194 |     |         }
 195 |     |         assembly {
 196 |     |             r := shr(127, mul(r, r))
 197 |     |             let f := shr(128, r)
 198 |     |             _log2 := or(_log2, shl(51, f))
 199 |     |             r := shr(f, r)
 200 |     |         }
 201 |     |         assembly {
 202 |     |             r := shr(127, mul(r, r))
 203 |     |             let f := shr(128, r)
 204 |     |             _log2 := or(_log2, shl(50, f))
 205 |     |         }
 206 |     | 
 207 |     |         int256 logSqrt10001 = _log2 * 255738958999603826347141; // 128.128 number
 208 |     | 
 209 |     |         int24 tickLow = (logSqrt10001 - 3402992956809132418596140100660247210).to24() >> 128;
 210 |     |         int24 tickHi = (logSqrt10001 + 291339464771989622907027621153398088495).to24() >> 128;
 211 |     | 
 212 |     |         if (tickLow == tickHi) {
 213 |     |             tick = tickLow;
 214 |     |         } else {
 215 |     |             tick = getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
 216 |     |         }
 217 |     |     }
 218 |     | }
 219 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/rewards-distributor/src/RewardsDistributor.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | // solhint-disable meta-transactions/no-msg-sender
   3 |     | pragma solidity >=0.8.11 <0.9.0;
   4 |     | 
   5 |     | import {IRewardDistributor} from "@synthetixio/main/contracts/interfaces/external/IRewardDistributor.sol";
   6 |     | import {IRewardsManagerModule} from "@synthetixio/main/contracts/interfaces/IRewardsManagerModule.sol";
   7 |     | import {IPoolModule} from "@synthetixio/main/contracts/interfaces/IPoolModule.sol";
   8 |     | import {AccessError} from "@synthetixio/core-contracts/contracts/errors/AccessError.sol";
   9 |     | import {ParameterError} from "@synthetixio/core-contracts/contracts/errors/ParameterError.sol";
  10 |     | import {ERC20Helper} from "@synthetixio/core-contracts/contracts/token/ERC20Helper.sol";
  11 |     | import {IERC165} from "@synthetixio/core-contracts/contracts/interfaces/IERC165.sol";
  12 |     | import {IERC20} from "@synthetixio/core-contracts/contracts/interfaces/IERC20.sol";
  13 |     | 
  14 |     | contract RewardsDistributor is IRewardDistributor {
  15 |     |     error NotEnoughRewardsLeft(uint256 amountRequested, uint256 amountLeft);
  16 |     |     error NotEnoughBalance(uint256 amountRequested, uint256 currentBalance);
  17 |     | 
  18 |     |     using ERC20Helper for address;
  19 |     | 
  20 |     |     address public rewardManager;
  21 |     |     uint128 public poolId;
  22 |     |     address public collateralType;
  23 |     |     address public payoutToken;
  24 |     |     string public name;
  25 |     | 
  26 |     |     uint256 public precision;
  27 |     |     uint256 public constant SYSTEM_PRECISION = 10 ** 18;
  28 |     | 
  29 |     |     bool public shouldFailPayout;
  30 |     | 
  31 |     |     // Internal tracking for the remaining rewards, it keeps value in payoutToken precision
  32 |     |     uint256 public rewardsAmount = 0;
  33 |     | 
  34 |     |     constructor(
  35 |     |         address rewardManager_,
  36 |     |         uint128 poolId_,
  37 |     |         address collateralType_,
  38 |     |         address payoutToken_,
  39 |     |         uint8 payoutTokenDecimals_,
  40 |     |         string memory name_
  41 |     |     ) {
  42 |     |         rewardManager = rewardManager_; // Synthetix CoreProxy
  43 |     |         poolId = poolId_;
  44 |     |         collateralType = collateralType_;
  45 |     |         payoutToken = payoutToken_;
  46 |     |         name = name_;
  47 |     | 
  48 |     |         (bool success, bytes memory data) = payoutToken_.staticcall(
  49 |     |             abi.encodeWithSignature("decimals()")
  50 |     |         );
  51 |     | 
  52 |     |         if (success && data.length > 0 && abi.decode(data, (uint8)) != payoutTokenDecimals_) {
  53 |     |             revert ParameterError.InvalidParameter(
  54 |     |                 "payoutTokenDecimals",
  55 |     |                 "Specified token decimals do not match actual token decimals"
  56 |     |             );
  57 |     |         }
  58 |     |         // Fallback to the specified token decimals skipping the check if token does not support decimals method
  59 |     |         precision = 10 ** payoutTokenDecimals_;
  60 |     |     }
  61 |     | 
  62 |     |     function token() public view returns (address) {
  63 |     |         return payoutToken;
  64 |     |     }
  65 |     | 
  66 |     |     function setShouldFailPayout(bool shouldFailPayout_) external {
  67 |     |         if (msg.sender != IPoolModule(rewardManager).getPoolOwner(poolId)) {
  68 |     |             revert AccessError.Unauthorized(msg.sender);
  69 |     |         }
  70 |     |         shouldFailPayout = shouldFailPayout_;
  71 |     |     }
  72 |     | 
  73 |     |     function payout(
  74 |     |         uint128, // accountId,
  75 |     |         uint128 poolId_,
  76 |     |         address collateralType_,
  77 |     |         address payoutTarget_, // msg.sender of claimRewards() call, payout target address
  78 |     |         uint256 payoutAmount_
  79 |     |     ) external returns (bool) {
  80 |     |         if (shouldFailPayout) {
  81 |     |             return false;
  82 |     |         }
  83 |     |         // IMPORTANT: In production, this function should revert if msg.sender is not the Synthetix CoreProxy address.
  84 |     |         if (msg.sender != rewardManager) {
  85 |     |             revert AccessError.Unauthorized(msg.sender);
  86 |     |         }
  87 |     |         if (poolId_ != poolId) {
  88 |     |             revert ParameterError.InvalidParameter(
  89 |     |                 "poolId",
  90 |     |                 "Pool does not match the rewards pool"
  91 |     |             );
  92 |     |         }
  93 |     |         if (collateralType_ != collateralType) {
  94 |     |             revert ParameterError.InvalidParameter(
  95 |     |                 "collateralType",
  96 |     |                 "Collateral does not match the rewards token"
  97 |     |             );
  98 |     |         }
  99 |     | 
 100 |     |         // payoutAmount_ is always in 18 decimals precision, adjust actual payout amount to match payout token decimals
 101 |     |         uint256 adjustedAmount = (payoutAmount_ * precision) / SYSTEM_PRECISION;
 102 |     | 
 103 |     |         if (adjustedAmount > rewardsAmount) {
 104 |     |             revert NotEnoughRewardsLeft(adjustedAmount, rewardsAmount);
 105 |     |         }
 106 |     |         rewardsAmount = rewardsAmount - adjustedAmount;
 107 |     | 
 108 |     |         payoutToken.safeTransfer(payoutTarget_, adjustedAmount);
 109 |     | 
 110 |     |         return true;
 111 |     |     }
 112 |     | 
 113 |     |     function distributeRewards(
 114 |     |         uint128 poolId_,
 115 |     |         address collateralType_,
 116 |     |         uint256 amount_,
 117 |     |         uint64 start_,
 118 |     |         uint32 duration_
 119 |     |     ) public {
 120 |     |         _checkDistributeSender();
 121 |     |         if (poolId_ != poolId) {
 122 |     |             revert ParameterError.InvalidParameter(
 123 |     |                 "poolId",
 124 |     |                 "Pool does not match the rewards pool"
 125 |     |             );
 126 |     |         }
 127 |     |         if (collateralType_ != collateralType) {
 128 |     |             revert ParameterError.InvalidParameter(
 129 |     |                 "collateralType",
 130 |     |                 "Collateral does not match the rewards token"
 131 |     |             );
 132 |     |         }
 133 |     | 
 134 |     |         rewardsAmount = rewardsAmount + amount_;
 135 |     |         uint256 balance = IERC20(payoutToken).balanceOf(address(this));
 136 |     |         if (rewardsAmount > balance) {
 137 |     |             revert NotEnoughBalance(amount_, balance);
 138 |     |         }
 139 |     | 
 140 |     |         // amount_ is in payout token decimals precision, adjust actual distribution amount to 18 decimals that core is making its calculations in
 141 |     |         // this is necessary to avoid rounding issues when doing actual payouts
 142 |     |         uint256 adjustedAmount = (amount_ * SYSTEM_PRECISION) / precision;
 143 |     | 
 144 |     |         IRewardsManagerModule(rewardManager).distributeRewards(
 145 |     |             poolId_,
 146 |     |             collateralType_,
 147 |     |             adjustedAmount,
 148 |     |             start_,
 149 |     |             duration_
 150 |     |         );
 151 |     |     }
 152 |     | 
 153 |     |     function onPositionUpdated(
 154 |     |         uint128, // accountId,
 155 |     |         uint128, // poolId,
 156 |     |         address, // collateralType,
 157 |     |         uint256 // actorSharesD18
 158 |     |     ) external {} // solhint-disable-line no-empty-blocks
 159 |     | 
 160 |     |     /**
 161 |     |      * @dev See {IERC165-supportsInterface}.
 162 |     |      */
 163 |     |     function supportsInterface(
 164 |     |         bytes4 interfaceId
 165 |     |     ) public view virtual override(IERC165) returns (bool) {
 166 |     |         return
 167 |     |             interfaceId == type(IRewardDistributor).interfaceId ||
 168 |     |             interfaceId == this.supportsInterface.selector;
 169 |     |     }
 170 |     | 
 171 |     |     function _checkDistributeSender() internal view virtual {
 172 |     |         if (msg.sender != IPoolModule(rewardManager).getPoolOwner(poolId)) {
 173 |     |             revert AccessError.Unauthorized(msg.sender);
 174 |     |         }
 175 |     |     }
 176 |     | }
 177 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/IAtomicOrderModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {OrderFees} from "../storage/OrderFees.sol";
   5 |     | import {Price} from "../storage/Price.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Module for atomic buy and sell orders for traders.
   9 |     |  */
  10 |     | interface IAtomicOrderModule {
  11 |     |     /**
  12 |     |      * @notice Thrown when trade is charging more USD than the max amount specified by the trader.
  13 |     |      * @dev Used in buyExactOut
  14 |     |      */
  15 |     |     error ExceedsMaxUsdAmount(uint256 maxUsdAmount, uint256 usdAmountCharged);
  16 |     |     /**
  17 |     |      * @notice Thrown when trade is charging more synth than the max amount specified by the trader.
  18 |     |      * @dev Used in sellExactOut
  19 |     |      */
  20 |     |     error ExceedsMaxSynthAmount(uint256 maxSynthAmount, uint256 synthAmountCharged);
  21 |     |     /**
  22 |     |      * @notice Thrown when a trade doesn't meet minimum expected return amount.
  23 |     |      */
  24 |     |     error InsufficientAmountReceived(uint256 expected, uint256 current);
  25 |     | 
  26 |     |     /**
  27 |     |      * @notice Thrown when the sell price is higher than the buy price
  28 |     |      */
  29 |     |     error InvalidPrices();
  30 |     | 
  31 |     |     /**
  32 |     |      * @notice Gets fired when buy trade is complete
  33 |     |      * @param synthMarketId Id of the market used for the trade.
  34 |     |      * @param synthReturned Synth received on the trade based on amount provided by trader.
  35 |     |      * @param fees breakdown of all fees incurred for transaction.
  36 |     |      * @param collectedFees Fees collected by the configured FeeCollector for the market (rest of the fees are deposited to market manager).
  37 |     |      * @param referrer Optional address of the referrer, for fee share
  38 |     |      */
  39 |     |     event SynthBought(
  40 |     |         uint256 indexed synthMarketId,
  41 |     |         uint256 synthReturned,
  42 |     |         OrderFees.Data fees,
  43 |     |         uint256 collectedFees,
  44 |     |         address referrer,
  45 |     |         uint256 price
  46 |     |     );
  47 |     | 
  48 |     |     /**
  49 |     |      * @notice Gets fired when sell trade is complete
  50 |     |      * @param synthMarketId Id of the market used for the trade.
  51 |     |      * @param amountReturned Amount of snxUSD returned to user based on synth provided by trader.
  52 |     |      * @param fees breakdown of all fees incurred for transaction.
  53 |     |      * @param collectedFees Fees collected by the configured FeeCollector for the market (rest of the fees are deposited to market manager).
  54 |     |      * @param referrer Optional address of the referrer, for fee share
  55 |     |      */
  56 |     |     event SynthSold(
  57 |     |         uint256 indexed synthMarketId,
  58 |     |         uint256 amountReturned,
  59 |     |         OrderFees.Data fees,
  60 |     |         uint256 collectedFees,
  61 |     |         address referrer,
  62 |     |         uint256 price
  63 |     |     );
  64 |     | 
  65 |     |     /**
  66 |     |      * @notice Initiates a buy trade returning synth for the specified amountUsd.
  67 |     |      * @dev Transfers the specified amountUsd, collects fees through configured fee collector, returns synth to the trader.
  68 |     |      * @dev Leftover fees not collected get deposited into the market manager to improve market PnL.
  69 |     |      * @dev Uses the buyFeedId configured for the market.
  70 |     |      * @param synthMarketId Id of the market used for the trade.
  71 |     |      * @param amountUsd Amount of snxUSD trader is providing allowance for the trade.
  72 |     |      * @param minAmountReceived Min Amount of synth is expected the trader to receive otherwise the transaction will revert.
  73 |     |      * @param referrer Optional address of the referrer, for fee share
  74 |     |      * @return synthAmount Synth received on the trade based on amount provided by trader.
  75 |     |      * @return fees breakdown of all the fees incurred for the transaction.
  76 |     |      */
  77 |     |     function buyExactIn(
  78 |     |         uint128 synthMarketId,
  79 |     |         uint256 amountUsd,
  80 |     |         uint256 minAmountReceived,
  81 |     |         address referrer
  82 |     |     ) external returns (uint256 synthAmount, OrderFees.Data memory fees);
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice  alias for buyExactIn
  86 |     |      * @param   marketId  (see buyExactIn)
  87 |     |      * @param   usdAmount  (see buyExactIn)
  88 |     |      * @param   minAmountReceived  (see buyExactIn)
  89 |     |      * @param   referrer  (see buyExactIn)
  90 |     |      * @return  synthAmount  (see buyExactIn)
  91 |     |      * @return  fees  (see buyExactIn)
  92 |     |      */
  93 |     |     function buy(
  94 |     |         uint128 marketId,
  95 |     |         uint256 usdAmount,
  96 |     |         uint256 minAmountReceived,
  97 |     |         address referrer
  98 |     |     ) external returns (uint256 synthAmount, OrderFees.Data memory fees);
  99 |     | 
 100 |     |     /**
 101 |     |      * @notice  user provides the synth amount they'd like to buy, and the function charges the USD amount which includes fees
 102 |     |      * @dev     the inverse of buyExactIn
 103 |     |      * @param   synthMarketId  market id value
 104 |     |      * @param   synthAmount  the amount of synth the trader wants to buy
 105 |     |      * @param   maxUsdAmount  max amount the trader is willing to pay for the specified synth
 106 |     |      * @param   referrer  optional address of the referrer, for fee share
 107 |     |      * @return  usdAmountCharged  amount of USD charged for the trade
 108 |     |      * @return  fees  breakdown of all the fees incurred for the transaction
 109 |     |      */
 110 |     |     function buyExactOut(
 111 |     |         uint128 synthMarketId,
 112 |     |         uint256 synthAmount,
 113 |     |         uint256 maxUsdAmount,
 114 |     |         address referrer
 115 |     |     ) external returns (uint256 usdAmountCharged, OrderFees.Data memory fees);
 116 |     | 
 117 |     |     /**
 118 |     |      * @notice  quote for buyExactIn.  same parameters and return values as buyExactIn
 119 |     |      * @param   synthMarketId  market id value
 120 |     |      * @param   usdAmount  amount of USD to use for the trade
 121 |     |      * @param   stalenessTolerance  this enum determines what staleness tolerance to use
 122 |     |      * @return  synthAmount  return amount of synth given the USD amount - fees
 123 |     |      * @return  fees  breakdown of all the quoted fees for the buy txn
 124 |     |      */
 125 |     |     function quoteBuyExactIn(
 126 |     |         uint128 synthMarketId,
 127 |     |         uint256 usdAmount,
 128 |     |         Price.Tolerance stalenessTolerance
 129 |     |     ) external view returns (uint256 synthAmount, OrderFees.Data memory fees);
 130 |     | 
 131 |     |     /**
 132 |     |      * @notice  quote for buyExactOut.  same parameters and return values as buyExactOut
 133 |     |      * @param   synthMarketId  market id value
 134 |     |      * @param   synthAmount  amount of synth requested
 135 |     |      * @param   stalenessTolerance  this enum determines what staleness tolerance to use
 136 |     |      * @return  usdAmountCharged  USD amount charged for the synth requested - fees
 137 |     |      * @return  fees  breakdown of all the quoted fees for the buy txn
 138 |     |      */
 139 |     |     function quoteBuyExactOut(
 140 |     |         uint128 synthMarketId,
 141 |     |         uint256 synthAmount,
 142 |     |         Price.Tolerance stalenessTolerance
 143 |     |     ) external view returns (uint256 usdAmountCharged, OrderFees.Data memory);
 144 |     | 
 145 |     |     /**
 146 |     |      * @notice Initiates a sell trade returning snxUSD for the specified amount of synth (sellAmount)
 147 |     |      * @dev Transfers the specified synth, collects fees through configured fee collector, returns snxUSD to the trader.
 148 |     |      * @dev Leftover fees not collected get deposited into the market manager to improve market PnL.
 149 |     |      * @param synthMarketId Id of the market used for the trade.
 150 |     |      * @param sellAmount Amount of synth provided by trader for trade into snxUSD.
 151 |     |      * @param minAmountReceived Min Amount of snxUSD trader expects to receive for the trade
 152 |     |      * @param referrer Optional address of the referrer, for fee share
 153 |     |      * @return returnAmount Amount of snxUSD returned to user
 154 |     |      * @return fees breakdown of all the fees incurred for the transaction.
 155 |     |      */
 156 |     |     function sellExactIn(
 157 |     |         uint128 synthMarketId,
 158 |     |         uint256 sellAmount,
 159 |     |         uint256 minAmountReceived,
 160 |     |         address referrer
 161 |     |     ) external returns (uint256 returnAmount, OrderFees.Data memory fees);
 162 |     | 
 163 |     |     /**
 164 |     |      * @notice  initiates a trade where trader specifies USD amount they'd like to receive
 165 |     |      * @dev     the inverse of sellExactIn
 166 |     |      * @param   marketId  synth market id
 167 |     |      * @param   usdAmount  amount of USD trader wants to receive
 168 |     |      * @param   maxSynthAmount  max amount of synth trader is willing to use to receive the specified USD amount
 169 |     |      * @param   referrer  optional address of the referrer, for fee share
 170 |     |      * @return  synthToBurn amount of synth charged for the specified usd amount
 171 |     |      * @return  fees breakdown of all the fees incurred for the transaction
 172 |     |      */
 173 |     |     function sellExactOut(
 174 |     |         uint128 marketId,
 175 |     |         uint256 usdAmount,
 176 |     |         uint256 maxSynthAmount,
 177 |     |         address referrer
 178 |     |     ) external returns (uint256 synthToBurn, OrderFees.Data memory fees);
 179 |     | 
 180 |     |     /**
 181 |     |      * @notice  alias for sellExactIn
 182 |     |      * @param   marketId  (see sellExactIn)
 183 |     |      * @param   synthAmount  (see sellExactIn)
 184 |     |      * @param   minUsdAmount  (see sellExactIn)
 185 |     |      * @param   referrer  (see sellExactIn)
 186 |     |      * @return  usdAmountReceived  (see sellExactIn)
 187 |     |      * @return  fees  (see sellExactIn)
 188 |     |      */
 189 |     |     function sell(
 190 |     |         uint128 marketId,
 191 |     |         uint256 synthAmount,
 192 |     |         uint256 minUsdAmount,
 193 |     |         address referrer
 194 |     |     ) external returns (uint256 usdAmountReceived, OrderFees.Data memory fees);
 195 |     | 
 196 |     |     /**
 197 |     |      * @notice  quote for sellExactIn
 198 |     |      * @dev     returns expected USD amount trader would receive for the specified synth amount
 199 |     |      * @param   marketId  synth market id
 200 |     |      * @param   synthAmount  synth amount trader is providing for the trade
 201 |     |      * @param   stalenessTolerance  this enum determines what staleness tolerance to use
 202 |     |      * @return  returnAmount  amount of USD expected back
 203 |     |      * @return  fees  breakdown of all the quoted fees for the txn
 204 |     |      */
 205 |     |     function quoteSellExactIn(
 206 |     |         uint128 marketId,
 207 |     |         uint256 synthAmount,
 208 |     |         Price.Tolerance stalenessTolerance
 209 |     |     ) external view returns (uint256 returnAmount, OrderFees.Data memory fees);
 210 |     | 
 211 |     |     /**
 212 |     |      * @notice  quote for sellExactOut
 213 |     |      * @dev     returns expected synth amount expected from trader for the requested USD amount
 214 |     |      * @param   marketId  synth market id
 215 |     |      * @param   usdAmount  USD amount trader wants to receive
 216 |     |      * @param   stalenessTolerance  this enum determines what staleness tolerance to use
 217 |     |      * @return  synthToBurn  amount of synth expected from trader
 218 |     |      * @return  fees  breakdown of all the quoted fees for the txn
 219 |     |      */
 220 |     |     function quoteSellExactOut(
 221 |     |         uint128 marketId,
 222 |     |         uint256 usdAmount,
 223 |     |         Price.Tolerance stalenessTolerance
 224 |     |     ) external view returns (uint256 synthToBurn, OrderFees.Data memory fees);
 225 |     | 
 226 |     |     /**
 227 |     |      * @notice  gets the current market skew
 228 |     |      * @param   marketId  synth market id
 229 |     |      * @return  marketSkew  the skew
 230 |     |      */
 231 |     |     function getMarketSkew(uint128 marketId) external view returns (int256 marketSkew);
 232 |     | }
 233 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/IMarketConfigurationModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | /**
   5 |     |  * @title Module for market-specific configuration.
   6 |     |  */
   7 |     | interface IMarketConfigurationModule {
   8 |     |     /**
   9 |     |      * @notice thrown when wrap + unwrap fees are being set to a negative value in total
  10 |     |      */
  11 |     |     error InvalidWrapperFees();
  12 |     | 
  13 |     |     /**
  14 |     |      * @notice emitted when market utilization fees are set for specified market
  15 |     |      * @param synthMarketId market id
  16 |     |      * @param utilizationFeeRate utilization fee rate value
  17 |     |      */
  18 |     |     event MarketUtilizationFeesSet(uint256 indexed synthMarketId, uint256 utilizationFeeRate);
  19 |     | 
  20 |     |     /**
  21 |     |      * @notice emitted when the skew scale is set for a market
  22 |     |      * @param synthMarketId market id
  23 |     |      * @param skewScale skew scale value
  24 |     |      */
  25 |     |     event MarketSkewScaleSet(uint256 indexed synthMarketId, uint256 skewScale);
  26 |     | 
  27 |     |     /**
  28 |     |      * @notice emitted when the collateral leverage is set for a market
  29 |     |      * @param synthMarketId market id
  30 |     |      * @param collateralLeverage leverage value
  31 |     |      */
  32 |     |     event CollateralLeverageSet(uint256 indexed synthMarketId, uint256 collateralLeverage);
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice emitted when the fixed fee for atomic orders is set.
  36 |     |      * @param synthMarketId market id
  37 |     |      * @param atomicFixedFee fee value
  38 |     |      */
  39 |     |     event AtomicFixedFeeSet(uint256 indexed synthMarketId, uint256 atomicFixedFee);
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice emitted when the fixed fee for async orders is set.
  43 |     |      * @param synthMarketId market id
  44 |     |      * @param asyncFixedFee fee value
  45 |     |      */
  46 |     |     event AsyncFixedFeeSet(uint256 indexed synthMarketId, uint256 asyncFixedFee);
  47 |     | 
  48 |     |     /**
  49 |     |      * @notice emitted when the fixed fee is set for a given transactor
  50 |     |      * @dev this overrides the async/atomic fixed fees for a given transactor
  51 |     |      * @param synthMarketId Id of the market to set the fees for.
  52 |     |      * @param transactor fixed fee for the transactor (overrides the global fixed fee)
  53 |     |      * @param fixedFeeAmount the fixed fee for the corresponding market, and transactor
  54 |     |      */
  55 |     |     event TransactorFixedFeeSet(
  56 |     |         uint256 indexed synthMarketId,
  57 |     |         address transactor,
  58 |     |         uint256 fixedFeeAmount
  59 |     |     );
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice emitted when custom fee collector is set for a given market
  63 |     |      * @param synthMarketId Id of the market to set the collector for.
  64 |     |      * @param feeCollector the address of the fee collector to set.
  65 |     |      */
  66 |     |     event FeeCollectorSet(uint256 indexed synthMarketId, address feeCollector);
  67 |     | 
  68 |     |     /**
  69 |     |      * @notice emitted when wrapper fees are set for a given market
  70 |     |      * @param synthMarketId Id of the market to set the wrapper fees.
  71 |     |      * @param wrapFee wrapping fee in %, 18 decimals. Can be negative.
  72 |     |      * @param unwrapFee unwrapping fee in %, 18 decimals. Can be negative.
  73 |     |      */
  74 |     |     event WrapperFeesSet(uint256 indexed synthMarketId, int256 wrapFee, int256 unwrapFee);
  75 |     | 
  76 |     |     /**
  77 |     |      * @notice Emitted when the share percentage for a referrer address has been updated.
  78 |     |      * @param marketId Id of the market
  79 |     |      * @param referrer The address of the referrer
  80 |     |      * @param sharePercentage The new share percentage for the referrer
  81 |     |      */
  82 |     |     event ReferrerShareUpdated(uint128 indexed marketId, address referrer, uint256 sharePercentage);
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Thrown when the fee collector does not implement the IFeeCollector interface
  86 |     |      */
  87 |     |     error InvalidFeeCollectorInterface(address invalidFeeCollector);
  88 |     | 
  89 |     |     /**
  90 |     |      * @notice gets the atomic fixed fee for a given market
  91 |     |      * @param synthMarketId Id of the market the fee applies to.
  92 |     |      * @return atomicFixedFee fixed fee amount represented in bips with 18 decimals.
  93 |     |      * @return asyncFixedFee fixed fee amount represented in bips with 18 decimals.
  94 |     |      * @return wrapFee wrapping fee in %, 18 decimals. Can be negative.
  95 |     |      * @return unwrapFee unwrapping fee in %, 18 decimals. Can be negative.
  96 |     |      */
  97 |     |     function getMarketFees(
  98 |     |         uint128 synthMarketId
  99 |     |     )
 100 |     |         external
 101 |     |         returns (uint256 atomicFixedFee, uint256 asyncFixedFee, int256 wrapFee, int256 unwrapFee);
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice sets the atomic fixed fee for a given market
 105 |     |      * @dev only marketOwner can set the fee
 106 |     |      * @param synthMarketId Id of the market the fee applies to.
 107 |     |      * @param atomicFixedFee fixed fee amount represented in bips with 18 decimals.
 108 |     |      */
 109 |     |     function setAtomicFixedFee(uint128 synthMarketId, uint256 atomicFixedFee) external;
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice sets the async fixed fee for a given market
 113 |     |      * @dev only marketOwner can set the fee
 114 |     |      * @param synthMarketId Id of the market the fee applies to.
 115 |     |      * @param asyncFixedFee fixed fee amount represented in bips with 18 decimals.
 116 |     |      */
 117 |     |     function setAsyncFixedFee(uint128 synthMarketId, uint256 asyncFixedFee) external;
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice sets the skew scale for a given market
 121 |     |      * @dev only marketOwner can set the skew scale
 122 |     |      * @param synthMarketId Id of the market the skew scale applies to.
 123 |     |      * @param skewScale max amount of synth which makes the skew 100%. the fee is derived as a % of the max value.  100% premium means outstanding synth == skewScale.
 124 |     |      */
 125 |     |     function setMarketSkewScale(uint128 synthMarketId, uint256 skewScale) external;
 126 |     | 
 127 |     |     /**
 128 |     |      * @notice gets the skew scale for a given market
 129 |     |      * @param synthMarketId Id of the market the skew scale applies to.
 130 |     |      * @return skewScale max amount of synth which makes the skew 100%. the fee is derived as a % of the max value.  100% premium means outstanding synth == skewScale.
 131 |     |      */
 132 |     |     function getMarketSkewScale(uint128 synthMarketId) external view returns (uint256 skewScale);
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice sets the market utilization fee for a given market
 136 |     |      * @dev only marketOwner can set the fee
 137 |     |      * @dev 100% utilization means the fee is 0.  120% utilization means the fee is 20% * this fee rate (in bips).
 138 |     |      * @param synthMarketId Id of the market the utilization fee applies to.
 139 |     |      * @param utilizationFeeRate the rate is represented in bips with 18 decimals and is the rate at which fee increases based on the % above 100% utilization of the delegated collateral for the market.
 140 |     |      */
 141 |     |     function setMarketUtilizationFees(uint128 synthMarketId, uint256 utilizationFeeRate) external;
 142 |     | 
 143 |     |     /**
 144 |     |      * @notice gets the market utilization fee for a given market
 145 |     |      * @dev 100% utilization means the fee is 0.  120% utilization means the fee is 20% * this fee rate (in bips).
 146 |     |      * @param synthMarketId Id of the market the utilization fee applies to.
 147 |     |      * @return utilizationFeeRate the rate is represented in bips with 18 decimals and is the rate at which fee increases based on the % above 100% utilization of the delegated collateral for the market.
 148 |     |      */
 149 |     |     function getMarketUtilizationFees(
 150 |     |         uint128 synthMarketId
 151 |     |     ) external view returns (uint256 utilizationFeeRate);
 152 |     | 
 153 |     |     /**
 154 |     |      * @notice sets the collateral leverage for a given market
 155 |     |      * @dev only marketOwner can set the leverage
 156 |     |      * @dev this leverage value is a value applied to delegated collateral which is compared to outstanding synth to determine utilization of market, and locked amounts
 157 |     |      * @param synthMarketId Id of the market the collateral leverage applies to.
 158 |     |      * @param collateralLeverage the leverage is represented as % with 18 decimals. 1 = 1x leverage
 159 |     |      */
 160 |     |     function setCollateralLeverage(uint128 synthMarketId, uint256 collateralLeverage) external;
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice gets the collateral leverage for a given market
 164 |     |      * @dev this leverage value is a value applied to delegated collateral which is compared to outstanding synth to determine utilization of market, and locked amounts
 165 |     |      * @param synthMarketId Id of the market the collateral leverage applies to.
 166 |     |      * @return collateralLeverage the leverage is represented as % with 18 decimals. 1 = 1x leverage
 167 |     |      */
 168 |     |     function getCollateralLeverage(
 169 |     |         uint128 synthMarketId
 170 |     |     ) external view returns (uint256 collateralLeverage);
 171 |     | 
 172 |     |     /**
 173 |     |      * @notice sets the fixed fee for a given market and transactor
 174 |     |      * @dev overrides both the atomic and async fixed fees
 175 |     |      * @dev only marketOwner can set the fee
 176 |     |      * @dev especially useful for direct integrations where configured traders get a discount
 177 |     |      * @param synthMarketId Id of the market the custom transactor fee applies to.
 178 |     |      * @param transactor address of the trader getting discounted fees.
 179 |     |      * @param fixedFeeAmount the fixed fee applying to the provided transactor.
 180 |     |      */
 181 |     |     function setCustomTransactorFees(
 182 |     |         uint128 synthMarketId,
 183 |     |         address transactor,
 184 |     |         uint256 fixedFeeAmount
 185 |     |     ) external;
 186 |     | 
 187 |     |     /**
 188 |     |      * @notice gets the fixed fee for a given market and transactor
 189 |     |      * @dev overrides both the atomic and async fixed fees
 190 |     |      * @dev especially useful for direct integrations where configured traders get a discount
 191 |     |      * @param synthMarketId Id of the market the custom transactor fee applies to.
 192 |     |      * @param transactor address of the trader getting discounted fees.
 193 |     |      * @return fixedFeeAmount the fixed fee applying to the provided transactor.
 194 |     |      */
 195 |     |     function getCustomTransactorFees(
 196 |     |         uint128 synthMarketId,
 197 |     |         address transactor
 198 |     |     ) external view returns (uint256 fixedFeeAmount);
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice sets a custom fee collector for a given market
 202 |     |      * @dev only marketOwner can set the fee collector
 203 |     |      * @dev a use case here would be if the market owner wants to collect the fees via this contract and distribute via rewards distributor to SNX holders for example.
 204 |     |      * @dev if fee collector is not set, the fees are deposited into the market manager.
 205 |     |      * @param synthMarketId Id of the market the fee collector applies to.
 206 |     |      * @param feeCollector address of the fee collector inheriting the IFeeCollector interface.
 207 |     |      */
 208 |     |     function setFeeCollector(uint128 synthMarketId, address feeCollector) external;
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice gets a custom fee collector for a given market
 212 |     |      * @param synthMarketId Id of the market the fee collector applies to.
 213 |     |      * @return feeCollector address of the fee collector inheriting the IFeeCollector interface.
 214 |     |      */
 215 |     |     function getFeeCollector(uint128 synthMarketId) external view returns (address feeCollector);
 216 |     | 
 217 |     |     /**
 218 |     |      * @notice sets wrapper related fees.
 219 |     |      * @dev only marketOwner can set the wrapper fees
 220 |     |      * @dev fees can be negative.  this is a way to unwind the wrapper if needed by providing incentives.
 221 |     |      * @param synthMarketId Id of the market the wrapper fees apply to.
 222 |     |      * @param wrapFee wrapping fee in %, 18 decimals. Can be negative.
 223 |     |      * @param unwrapFee unwrapping fee in %, 18 decimals. Can be negative.
 224 |     |      */
 225 |     |     function setWrapperFees(uint128 synthMarketId, int256 wrapFee, int256 unwrapFee) external;
 226 |     | 
 227 |     |     /**
 228 |     |      * @notice Update the referral share percentage for a given market
 229 |     |      * @param marketId id of the market
 230 |     |      * @param referrer The address of the referrer
 231 |     |      * @param sharePercentage The new share percentage for the referrer
 232 |     |      */
 233 |     |     function updateReferrerShare(
 234 |     |         uint128 marketId,
 235 |     |         address referrer,
 236 |     |         uint256 sharePercentage
 237 |     |     ) external;
 238 |     | 
 239 |     |     /**
 240 |     |      * @notice get the referral share percentage for a given market
 241 |     |      * @param marketId id of the market
 242 |     |      * @param referrer The address of the referrer
 243 |     |      * @return sharePercentage The new share percentage for the referrer
 244 |     |      */
 245 |     |     function getReferrerShare(
 246 |     |         uint128 marketId,
 247 |     |         address referrer
 248 |     |     ) external view returns (uint256 sharePercentage);
 249 |     | }
 250 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/ISpotMarketFactoryModule.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {IMarket} from "@synthetixio/main/contracts/interfaces/external/IMarket.sol";
   5 |     | import {ISynthetixSystem} from "./external/ISynthetixSystem.sol";
   6 |     | import {Price} from "../storage/Price.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title Module for spot market factory
  10 |     |  */
  11 |     | interface ISpotMarketFactoryModule is IMarket {
  12 |     |     /**
  13 |     |      * @notice Thrown when an address tries to accept market ownership but has not been nominated.
  14 |     |      * @param addr The address that is trying to accept ownership.
  15 |     |      */
  16 |     |     error NotNominated(address addr);
  17 |     | 
  18 |     |     /**
  19 |     |      * @notice Thrown when createSynth is called with zero-address synth owner
  20 |     |      */
  21 |     |     error InvalidMarketOwner();
  22 |     | 
  23 |     |     /**
  24 |     |      * @notice Gets fired when the synthetix is set
  25 |     |      * @param synthetix address of the synthetix core contract
  26 |     |      * @param usdTokenAddress address of the USDToken contract
  27 |     |      * @param oracleManager address of the Oracle Manager contract
  28 |     |      */
  29 |     |     event SynthetixSystemSet(address synthetix, address usdTokenAddress, address oracleManager);
  30 |     |     /**
  31 |     |      * @notice Gets fired when the synth implementation is set
  32 |     |      * @param synthImplementation address of the synth implementation
  33 |     |      */
  34 |     |     event SynthImplementationSet(address synthImplementation);
  35 |     |     /**
  36 |     |      * @notice Gets fired when the synth is registered as a market.
  37 |     |      * @param synthMarketId Id of the synth market that was created
  38 |     |      * @param synthTokenAddress address of the newly created synth token
  39 |     |      */
  40 |     |     event SynthRegistered(uint256 indexed synthMarketId, address synthTokenAddress);
  41 |     |     /**
  42 |     |      * @notice Gets fired when the synth's implementation is updated on the corresponding proxy.
  43 |     |      * @param proxy the synth proxy servicing the latest implementation
  44 |     |      * @param implementation the latest implementation of the synth
  45 |     |      */
  46 |     |     event SynthImplementationUpgraded(
  47 |     |         uint256 indexed synthMarketId,
  48 |     |         address indexed proxy,
  49 |     |         address implementation
  50 |     |     );
  51 |     |     /**
  52 |     |      * @notice Gets fired when the market's price feeds are updated, compatible with oracle manager
  53 |     |      * @param buyFeedId the oracle manager feed id for the buy price
  54 |     |      * @param sellFeedId the oracle manager feed id for the sell price
  55 |     |      */
  56 |     |     event SynthPriceDataUpdated(
  57 |     |         uint256 indexed synthMarketId,
  58 |     |         bytes32 indexed buyFeedId,
  59 |     |         bytes32 indexed sellFeedId,
  60 |     |         uint256 strictStalenessTolerance
  61 |     |     );
  62 |     |     /**
  63 |     |      * @notice Gets fired when the market's price feeds are updated, compatible with oracle manager
  64 |     |      * @param marketId Id of the synth market
  65 |     |      * @param rate the new decay rate (1e16 means 1% decay per year)
  66 |     |      */
  67 |     |     event DecayRateUpdated(uint128 indexed marketId, uint256 rate);
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Emitted when an address has been nominated.
  71 |     |      * @param marketId id of the market
  72 |     |      * @param newOwner The address that has been nominated.
  73 |     |      */
  74 |     |     event MarketOwnerNominated(uint128 indexed marketId, address newOwner);
  75 |     | 
  76 |     |     /**
  77 |     |      * @notice Emitted when market nominee renounces nomination.
  78 |     |      * @param marketId id of the market
  79 |     |      * @param nominee The address that has been nominated.
  80 |     |      */
  81 |     |     event MarketNominationRenounced(uint128 indexed marketId, address nominee);
  82 |     | 
  83 |     |     /**
  84 |     |      * @notice Emitted when the owner of the market has changed.
  85 |     |      * @param marketId id of the market
  86 |     |      * @param oldOwner The previous owner of the market.
  87 |     |      * @param newOwner The new owner of the market.
  88 |     |      */
  89 |     |     event MarketOwnerChanged(uint128 indexed marketId, address oldOwner, address newOwner);
  90 |     | 
  91 |     |     /**
  92 |     |      * @notice Sets the v3 synthetix core system.
  93 |     |      * @dev Pulls in the USDToken and oracle manager from the synthetix core system and sets those appropriately.
  94 |     |      * @param synthetix synthetix v3 core system address
  95 |     |      */
  96 |     |     function setSynthetix(ISynthetixSystem synthetix) external;
  97 |     | 
  98 |     |     /**
  99 |     |      * @notice When a new synth is created, this is the erc20 implementation that is used.
 100 |     |      * @param synthImplementation erc20 implementation address
 101 |     |      */
 102 |     |     function setSynthImplementation(address synthImplementation) external;
 103 |     | 
 104 |     |     /**
 105 |     |      * @notice Creates a new synth market with synthetix v3 core system via market manager
 106 |     |      * @dev The synth is created using the initial synth implementation and creates a proxy for future upgrades of the synth implementation.
 107 |     |      * @dev Sets up the market owner who can update configuration for the synth.
 108 |     |      * @param tokenName name of synth (i.e Synthetix ETH)
 109 |     |      * @param tokenSymbol symbol of synth (i.e snxETH)
 110 |     |      * @param synthOwner owner of the market that's created.
 111 |     |      * @return synthMarketId id of the synth market that was created
 112 |     |      */
 113 |     |     function createSynth(
 114 |     |         string memory tokenName,
 115 |     |         string memory tokenSymbol,
 116 |     |         address synthOwner
 117 |     |     ) external returns (uint128 synthMarketId);
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Get the proxy address of the synth for the provided marketId
 121 |     |      * @dev Uses associated systems module to retrieve the token address.
 122 |     |      * @param marketId id of the market
 123 |     |      * @return synthAddress address of the proxy for the synth
 124 |     |      */
 125 |     |     function getSynth(uint128 marketId) external view returns (address synthAddress);
 126 |     | 
 127 |     |     /**
 128 |     |      * @notice Get the implementation address of the synth for the provided marketId.
 129 |     |      * This address should not be used directly--use `getSynth` instead
 130 |     |      * @dev Uses associated systems module to retrieve the token address.
 131 |     |      * @param marketId id of the market
 132 |     |      * @return implAddress address of the proxy for the synth
 133 |     |      */
 134 |     |     function getSynthImpl(uint128 marketId) external view returns (address implAddress);
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Update the price data for a given market.
 138 |     |      * @dev Only the market owner can call this function.
 139 |     |      * @param marketId id of the market
 140 |     |      * @param buyFeedId the oracle manager buy feed node id
 141 |     |      * @param sellFeedId the oracle manager sell feed node id
 142 |     |      * @param strictPriceStalenessTolerance configurable price staleness tolerance used for transacting
 143 |     |      */
 144 |     |     function updatePriceData(
 145 |     |         uint128 marketId,
 146 |     |         bytes32 buyFeedId,
 147 |     |         bytes32 sellFeedId,
 148 |     |         uint256 strictPriceStalenessTolerance
 149 |     |     ) external;
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice Gets the price data for a given market.
 153 |     |      * @dev Only the market owner can call this function.
 154 |     |      * @param marketId id of the market
 155 |     |      * @return buyFeedId the oracle manager buy feed node id
 156 |     |      * @return sellFeedId the oracle manager sell feed node id
 157 |     |      * @return strictPriceStalenessTolerance configurable price staleness tolerance used for transacting
 158 |     |      */
 159 |     |     function getPriceData(
 160 |     |         uint128 marketId
 161 |     |     )
 162 |     |         external
 163 |     |         view
 164 |     |         returns (bytes32 buyFeedId, bytes32 sellFeedId, uint256 strictPriceStalenessTolerance);
 165 |     | 
 166 |     |     /**
 167 |     |      * @notice upgrades the synth implementation to the current implementation for the specified market.
 168 |     |      * Anyone who is willing and able to spend the gas can call this method.
 169 |     |      * @dev The synth implementation is upgraded via the proxy.
 170 |     |      * @param marketId id of the market
 171 |     |      */
 172 |     |     function upgradeSynthImpl(uint128 marketId) external;
 173 |     | 
 174 |     |     /**
 175 |     |      * @notice Allows market to adjust decay rate of the synth
 176 |     |      * @param marketId the market to update the synth decay rate for
 177 |     |      * @param rate APY to decay of the synth to decay by, as a 18 decimal ratio
 178 |     |      */
 179 |     |     function setDecayRate(uint128 marketId, uint256 rate) external;
 180 |     | 
 181 |     |     /**
 182 |     |      * @notice Allows the current market owner to nominate a new owner.
 183 |     |      * @dev The nominated owner will have to call `acceptOwnership` in a separate transaction in order to finalize the action and become the new contract owner.
 184 |     |      * @param synthMarketId synth market id value
 185 |     |      * @param newNominatedOwner The address that is to become nominated.
 186 |     |      */
 187 |     |     function nominateMarketOwner(uint128 synthMarketId, address newNominatedOwner) external;
 188 |     | 
 189 |     |     /**
 190 |     |      * @notice Allows a nominated address to accept ownership of the market.
 191 |     |      * @dev Reverts if the caller is not nominated.
 192 |     |      * @param synthMarketId synth market id value
 193 |     |      */
 194 |     |     function acceptMarketOwnership(uint128 synthMarketId) external;
 195 |     | 
 196 |     |     /**
 197 |     |      * @notice Allows a nominated address to renounce ownership of the market.
 198 |     |      * @dev Reverts if the caller is not nominated.
 199 |     |      * @param synthMarketId synth market id value
 200 |     |      */
 201 |     |     function renounceMarketNomination(uint128 synthMarketId) external;
 202 |     | 
 203 |     |     /**
 204 |     |      * @notice Allows the market owner to renounce his ownership.
 205 |     |      * @dev Reverts if the caller is not the owner.
 206 |     |      * @param synthMarketId synth market id value
 207 |     |      */
 208 |     |     function renounceMarketOwnership(uint128 synthMarketId) external;
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice Returns market owner.
 212 |     |      * @param synthMarketId synth market id value
 213 |     |      */
 214 |     |     function getMarketOwner(uint128 synthMarketId) external view returns (address);
 215 |     | 
 216 |     |     /**
 217 |     |      * @notice Returns nominated market owner.
 218 |     |      * @param synthMarketId synth market id value
 219 |     |      */
 220 |     |     function getNominatedMarketOwner(uint128 synthMarketId) external view returns (address);
 221 |     | 
 222 |     |     /**
 223 |     |      * @notice Get current price based on type of transaction and tolerance
 224 |     |      * @param marketId synth market id value
 225 |     |      * @param transactionType type of txn
 226 |     |      * @param priceTolerance staleness tolerance to use for price
 227 |     |      * @return price current price of the synth
 228 |     |      */
 229 |     |     function indexPrice(
 230 |     |         uint128 marketId,
 231 |     |         uint128 transactionType,
 232 |     |         Price.Tolerance priceTolerance
 233 |     |     ) external view returns (uint256 price);
 234 |     | }
 235 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/interfaces/external/ISynthetixSystem.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-modules/contracts/interfaces/IAssociatedSystemsModule.sol";
  5 |     | import "@synthetixio/main/contracts/interfaces/IMarketManagerModule.sol";
  6 |     | import "@synthetixio/main/contracts/interfaces/IMarketCollateralModule.sol";
  7 |     | import "@synthetixio/main/contracts/interfaces/IUtilsModule.sol";
  8 |     | 
  9 |     | // solhint-disable no-empty-blocks
 10 |     | interface ISynthetixSystem is
 11 |     |     IAssociatedSystemsModule,
 12 |     |     IMarketCollateralModule,
 13 |     |     IMarketManagerModule,
 14 |     |     IUtilsModule
 15 |     | {}
 16 |     | // solhint-enable no-empty-blocks
 17 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/storage/OrderFees.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import {SafeCastU256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @notice  A convenience library that includes a Data struct which is used to track fees across different trade types
  8 |     |  */
  9 |     | library OrderFees {
 10 |     |     using SafeCastU256 for uint256;
 11 |     | 
 12 |     |     struct Data {
 13 |     |         uint256 fixedFees;
 14 |     |         uint256 utilizationFees;
 15 |     |         int256 skewFees;
 16 |     |         int256 wrapperFees;
 17 |     |     }
 18 |     | 
 19 |     |     function total(Data memory self) internal pure returns (int256 amount) {
 20 |     |         return
 21 |     |             self.fixedFees.toInt() +
 22 |     |             self.utilizationFees.toInt() +
 23 |     |             self.skewFees +
 24 |     |             self.wrapperFees;
 25 |     |     }
 26 |     | }
 27 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/storage/Price.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.11 <0.9.0;
   3 |     | 
   4 |     | import {INodeModule} from "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
   5 |     | import {NodeOutput} from "@synthetixio/oracle-manager/contracts/storage/NodeOutput.sol";
   6 |     | import {DecimalMath} from "@synthetixio/core-contracts/contracts/utils/DecimalMath.sol";
   7 |     | import {SafeCastI256} from "@synthetixio/core-contracts/contracts/utils/SafeCast.sol";
   8 |     | import {SpotMarketFactory} from "./SpotMarketFactory.sol";
   9 |     | import {Transaction} from "../utils/TransactionUtil.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @title Price storage for a specific synth market.
  13 |     |  */
  14 |     | library Price {
  15 |     |     using DecimalMath for int256;
  16 |     |     using DecimalMath for uint256;
  17 |     |     using SafeCastI256 for int256;
  18 |     | 
  19 |     |     enum Tolerance {
  20 |     |         DEFAULT,
  21 |     |         STRICT
  22 |     |     }
  23 |     | 
  24 |     |     struct Data {
  25 |     |         /**
  26 |     |          * @dev The oracle manager node id used for buy transactions.
  27 |     |          */
  28 |     |         bytes32 buyFeedId;
  29 |     |         /**
  30 |     |          * @dev The oracle manager node id used for all non-buy transactions.
  31 |     |          * @dev also used to for calculating reported debt
  32 |     |          */
  33 |     |         bytes32 sellFeedId;
  34 |     |         /**
  35 |     |          * @dev configurable staleness tolerance to use when fetching prices.
  36 |     |          */
  37 |     |         uint256 strictStalenessTolerance;
  38 |     |     }
  39 |     | 
  40 |     |     function load(uint128 marketId) internal pure returns (Data storage price) {
  41 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.spot-market.Price", marketId));
  42 |     |         assembly {
  43 |     |             price.slot := s
  44 |     |         }
  45 |     |     }
  46 |     | 
  47 |     |     function getCurrentPrice(
  48 |     |         uint128 marketId,
  49 |     |         Transaction.Type transactionType,
  50 |     |         Tolerance priceTolerance
  51 |     |     ) internal view returns (uint256 price) {
  52 |     |         Data storage self = load(marketId);
  53 |     |         SpotMarketFactory.Data storage factory = SpotMarketFactory.load();
  54 |     |         bytes32 feedId = Transaction.isBuy(transactionType) ? self.buyFeedId : self.sellFeedId;
  55 |     | 
  56 |     |         NodeOutput.Data memory output;
  57 |     | 
  58 |     |         if (priceTolerance == Tolerance.STRICT) {
  59 |     |             bytes32[] memory runtimeKeys = new bytes32[](1);
  60 |     |             bytes32[] memory runtimeValues = new bytes32[](1);
  61 |     |             runtimeKeys[0] = bytes32("stalenessTolerance");
  62 |     |             runtimeValues[0] = bytes32(self.strictStalenessTolerance);
  63 |     |             output = INodeModule(factory.oracle).processWithRuntime(
  64 |     |                 feedId,
  65 |     |                 runtimeKeys,
  66 |     |                 runtimeValues
  67 |     |             );
  68 |     |         } else {
  69 |     |             output = INodeModule(factory.oracle).process(feedId);
  70 |     |         }
  71 |     | 
  72 |     |         price = output.price.toUint();
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Updates price feeds.  Function resides in SpotMarketFactory to update these values.
  77 |     |      * Only market owner can update these values.
  78 |     |      */
  79 |     |     function update(
  80 |     |         Data storage self,
  81 |     |         bytes32 buyFeedId,
  82 |     |         bytes32 sellFeedId,
  83 |     |         uint256 strictStalenessTolerance
  84 |     |     ) internal {
  85 |     |         self.buyFeedId = buyFeedId;
  86 |     |         self.sellFeedId = sellFeedId;
  87 |     |         self.strictStalenessTolerance = strictStalenessTolerance;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Utility function that returns the amount denominated with 18 decimals of precision.
  92 |     |      */
  93 |     |     function scale(int256 amount, uint256 decimals) internal pure returns (int256 scaledAmount) {
  94 |     |         return (decimals > 18 ? amount.downscale(decimals - 18) : amount.upscale(18 - decimals));
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Utility function that receive amount with 18 decimals
  99 |     |      * returns the amount denominated with number of decimals as arg of 18.
 100 |     |      */
 101 |     |     function scaleTo(int256 amount, uint256 decimals) internal pure returns (int256 scaledAmount) {
 102 |     |         return (decimals > 18 ? amount.upscale(decimals - 18) : amount.downscale(18 - decimals));
 103 |     |     }
 104 |     | }
 105 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/storage/SpotMarketFactory.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | import "@synthetixio/core-contracts/contracts/utils/ERC2771Context.sol";
  5 |     | import {ITokenModule} from "@synthetixio/core-modules/contracts/interfaces/ITokenModule.sol";
  6 |     | import {INodeModule} from "@synthetixio/oracle-manager/contracts/interfaces/INodeModule.sol";
  7 |     | import {ISynthetixSystem} from "../interfaces/external/ISynthetixSystem.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title Main factory library that registers synths.  Also houses global configuration for all synths.
 11 |     |  */
 12 |     | library SpotMarketFactory {
 13 |     |     bytes32 private constant _SLOT_SPOT_MARKET_FACTORY =
 14 |     |         keccak256(abi.encode("io.synthetix.spot-market.SpotMarketFactory"));
 15 |     | 
 16 |     |     error OnlyMarketOwner(address marketOwner, address sender);
 17 |     |     error InvalidMarket(uint128 marketId);
 18 |     |     error InvalidSynthImplementation(uint256 synthImplementation);
 19 |     | 
 20 |     |     struct Data {
 21 |     |         /**
 22 |     |          * @dev snxUSD token address
 23 |     |          */
 24 |     |         ITokenModule usdToken;
 25 |     |         /**
 26 |     |          * @dev oracle manager address used for price feeds
 27 |     |          */
 28 |     |         INodeModule oracle;
 29 |     |         /**
 30 |     |          * @dev Synthetix core v3 proxy
 31 |     |          */
 32 |     |         ISynthetixSystem synthetix;
 33 |     |         /**
 34 |     |          * @dev erc20 synth implementation address.  associated systems creates a proxy backed by this implementation.
 35 |     |          */
 36 |     |         address synthImplementation;
 37 |     |         /**
 38 |     |          * @dev mapping of marketId to marketOwner
 39 |     |          */
 40 |     |         mapping(uint128 => address) marketOwners;
 41 |     |         /**
 42 |     |          * @dev mapping of marketId to marketNominatedOwner
 43 |     |          */
 44 |     |         mapping(uint128 => address) nominatedMarketOwners;
 45 |     |     }
 46 |     | 
 47 |     |     function load() internal pure returns (Data storage spotMarketFactory) {
 48 |     |         bytes32 s = _SLOT_SPOT_MARKET_FACTORY;
 49 |     |         assembly {
 50 |     |             spotMarketFactory.slot := s
 51 |     |         }
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @notice ensures synth implementation is set before creating synth
 56 |     |      */
 57 |     |     function checkSynthImplemention(Data storage self) internal view {
 58 |     |         if (self.synthImplementation == address(0)) {
 59 |     |             revert InvalidSynthImplementation(0);
 60 |     |         }
 61 |     |     }
 62 |     | 
 63 |     |     /**
 64 |     |      * @notice only owner of market passes check, otherwise reverts
 65 |     |      */
 66 |     |     function onlyMarketOwner(Data storage self, uint128 marketId) internal view {
 67 |     |         address marketOwner = self.marketOwners[marketId];
 68 |     | 
 69 |     |         if (marketOwner != ERC2771Context._msgSender()) {
 70 |     |             revert OnlyMarketOwner(marketOwner, ERC2771Context._msgSender());
 71 |     |         }
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @notice validates market id by checking that an owner exists for the market
 76 |     |      */
 77 |     |     function validateMarket(Data storage self, uint128 marketId) internal view {
 78 |     |         if (self.marketOwners[marketId] == address(0)) {
 79 |     |             revert InvalidMarket(marketId);
 80 |     |         }
 81 |     |     }
 82 |     | 
 83 |     |     /**
 84 |     |      * @dev first creates an allowance entry in usdToken for market manager, then deposits snxUSD amount into mm.
 85 |     |      */
 86 |     |     function depositToMarketManager(Data storage self, uint128 marketId, uint256 amount) internal {
 87 |     |         self.usdToken.approve(address(this), amount);
 88 |     |         self.synthetix.depositMarketUsd(marketId, address(this), amount);
 89 |     |     }
 90 |     | }
 91 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/node_modules/@synthetixio/spot-market/contracts/utils/TransactionUtil.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.11 <0.9.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title Transaction types supported by the spot market system
  6 |     |  */
  7 |     | library Transaction {
  8 |     |     error InvalidAsyncTransactionType(Type transactionType);
  9 |     |     error InvalidTransactionTypeIndex(uint128 txnType);
 10 |     | 
 11 |     |     enum Type {
 12 |     |         NULL, // reserved for 0 (default value)
 13 |     |         BUY,
 14 |     |         SELL,
 15 |     |         ASYNC_BUY,
 16 |     |         ASYNC_SELL,
 17 |     |         WRAP,
 18 |     |         UNWRAP
 19 |     |     }
 20 |     | 
 21 |     |     function loadValidTransactionType(uint128 txnType) internal pure returns (Type) {
 22 |     |         // solhint-disable-next-line numcast/safe-cast
 23 |     |         uint128 txnTypeMax = uint128(Type.UNWRAP);
 24 |     |         if (txnType > txnTypeMax) {
 25 |     |             revert InvalidTransactionTypeIndex(txnType);
 26 |     |         }
 27 |     | 
 28 |     |         return Type(txnType);
 29 |     |     }
 30 |     | 
 31 |     |     function validateAsyncTransaction(Type orderType) internal pure {
 32 |     |         if (orderType != Type.ASYNC_BUY && orderType != Type.ASYNC_SELL) {
 33 |     |             revert InvalidAsyncTransactionType(orderType);
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function isBuy(Type orderType) internal pure returns (bool) {
 38 |     |         return orderType == Type.BUY || orderType == Type.ASYNC_BUY;
 39 |     |     }
 40 |     | 
 41 |     |     function isSell(Type orderType) internal pure returns (bool) {
 42 |     |         return orderType == Type.SELL || orderType == Type.ASYNC_SELL;
 43 |     |     }
 44 |     | 
 45 |     |     function isWrapper(Type orderType) internal pure returns (bool) {
 46 |     |         return orderType == Type.WRAP || orderType == Type.UNWRAP;
 47 |     |     }
 48 |     | 
 49 |     |     function isAsync(Type orderType) internal pure returns (bool) {
 50 |     |         return orderType == Type.ASYNC_BUY || orderType == Type.ASYNC_SELL;
 51 |     |     }
 52 |     | }
 53 |     | 

/Users/vladimirdzotov/Dropbox/do/GA/synthetix/synthetix-perps-minimal/markets/perps-market/storage.dump.sol
    1 |     | // SPDX-License-Identifier: UNLICENSED
    2 |     | pragma solidity >=0.8.11 <0.9.0;
    3 |     | 
    4 |     | // @custom:artifact @synthetixio/core-contracts/contracts/ownership/OwnableStorage.sol:OwnableStorage
    5 |     | library OwnableStorage {
    6 |     |     bytes32 private constant _SLOT_OWNABLE_STORAGE =
    7 |     |         keccak256(abi.encode("io.synthetix.core-contracts.Ownable"));
    8 |     |     struct Data {
    9 |     |         address owner;
   10 |     |         address nominatedOwner;
   11 |     |     }
   12 |     |     function load() internal pure returns (Data storage store) {
   13 |     |         bytes32 s = _SLOT_OWNABLE_STORAGE;
   14 |     |         assembly {
   15 |     |             store.slot := s
   16 |     |         }
   17 |     |     }
   18 |     | }
   19 |     | 
   20 |     | // @custom:artifact @synthetixio/core-contracts/contracts/proxy/ProxyStorage.sol:ProxyStorage
   21 |     | contract ProxyStorage {
   22 |     |     bytes32 private constant _SLOT_PROXY_STORAGE =
   23 |     |         keccak256(abi.encode("io.synthetix.core-contracts.Proxy"));
   24 |     |     struct ProxyStore {
   25 |     |         address implementation;
   26 |     |         bool simulatingUpgrade;
   27 |     |     }
   28 |     |     function _proxyStore() internal pure returns (ProxyStore storage store) {
   29 |     |         bytes32 s = _SLOT_PROXY_STORAGE;
   30 |     |         assembly {
   31 |     |             store.slot := s
   32 |     |         }
   33 |     |     }
   34 |     | }
   35 |     | 
   36 |     | // @custom:artifact @synthetixio/core-contracts/contracts/utils/DecimalMath.sol:DecimalMath
   37 |     | library DecimalMath {
   38 |     |     uint256 public constant UNIT = 1e18;
   39 |     |     int256 public constant UNIT_INT = int256(UNIT);
   40 |     |     uint128 public constant UNIT_UINT128 = uint128(UNIT);
   41 |     |     int128 public constant UNIT_INT128 = int128(UNIT_INT);
   42 |     |     uint256 public constant UNIT_PRECISE = 1e27;
   43 |     |     int256 public constant UNIT_PRECISE_INT = int256(UNIT_PRECISE);
   44 |     |     int128 public constant UNIT_PRECISE_INT128 = int128(UNIT_PRECISE_INT);
   45 |     |     uint256 public constant PRECISION_FACTOR = 9;
   46 |     | }
   47 |     | 
   48 |     | // @custom:artifact @synthetixio/core-contracts/contracts/utils/ERC2771Context.sol:ERC2771Context
   49 |     | library ERC2771Context {
   50 |     |     address private constant TRUSTED_FORWARDER =
   51 |     |         0xE2C5658cC5C448B48141168f3e475dF8f65A1e3e;
   52 |     | }
   53 |     | 
   54 |     | // @custom:artifact @synthetixio/core-contracts/contracts/utils/HeapUtil.sol:HeapUtil
   55 |     | library HeapUtil {
   56 |     |     uint256 private constant _ROOT_INDEX = 1;
   57 |     |     struct Data {
   58 |     |         uint128 idCount;
   59 |     |         Node[] nodes;
   60 |     |         mapping(uint128 => uint256) indices;
   61 |     |     }
   62 |     |     struct Node {
   63 |     |         uint128 id;
   64 |     |         int128 priority;
   65 |     |     }
   66 |     | }
   67 |     | 
   68 |     | // @custom:artifact @synthetixio/core-contracts/contracts/utils/SetUtil.sol:SetUtil
   69 |     | library SetUtil {
   70 |     |     struct UintSet {
   71 |     |         Bytes32Set raw;
   72 |     |     }
   73 |     |     struct AddressSet {
   74 |     |         Bytes32Set raw;
   75 |     |     }
   76 |     |     struct Bytes32Set {
   77 |     |         bytes32[] _values;
   78 |     |         mapping(bytes32 => uint256) _positions;
   79 |     |     }
   80 |     | }
   81 |     | 
   82 |     | // @custom:artifact @synthetixio/core-modules/contracts/storage/AssociatedSystem.sol:AssociatedSystem
   83 |     | library AssociatedSystem {
   84 |     |     bytes32 public constant KIND_ERC20 = "erc20";
   85 |     |     bytes32 public constant KIND_ERC721 = "erc721";
   86 |     |     bytes32 public constant KIND_UNMANAGED = "unmanaged";
   87 |     |     struct Data {
   88 |     |         address proxy;
   89 |     |         address impl;
   90 |     |         bytes32 kind;
   91 |     |     }
   92 |     |     function load(bytes32 id) internal pure returns (Data storage store) {
   93 |     |         bytes32 s = keccak256(
   94 |     |             abi.encode("io.synthetix.core-modules.AssociatedSystem", id)
   95 |     |         );
   96 |     |         assembly {
   97 |     |             store.slot := s
   98 |     |         }
   99 |     |     }
  100 |     | }
  101 |     | 
  102 |     | // @custom:artifact @synthetixio/core-modules/contracts/storage/FeatureFlag.sol:FeatureFlag
  103 |     | library FeatureFlag {
  104 |     |     struct Data {
  105 |     |         bytes32 name;
  106 |     |         bool allowAll;
  107 |     |         bool denyAll;
  108 |     |         SetUtil.AddressSet permissionedAddresses;
  109 |     |         address[] deniers;
  110 |     |     }
  111 |     |     function load(
  112 |     |         bytes32 featureName
  113 |     |     ) internal pure returns (Data storage store) {
  114 |     |         bytes32 s = keccak256(
  115 |     |             abi.encode("io.synthetix.core-modules.FeatureFlag", featureName)
  116 |     |         );
  117 |     |         assembly {
  118 |     |             store.slot := s
  119 |     |         }
  120 |     |     }
  121 |     | }
  122 |     | 
  123 |     | // @custom:artifact @synthetixio/main/contracts/storage/Account.sol:Account
  124 |     | library Account {
  125 |     |     struct Data {
  126 |     |         uint128 id;
  127 |     |         AccountRBAC.Data rbac;
  128 |     |         uint64 lastInteraction;
  129 |     |         uint64 __slotAvailableForFutureUse;
  130 |     |         uint128 __slot2AvailableForFutureUse;
  131 |     |         mapping(address => Collateral.Data) collaterals;
  132 |     |     }
  133 |     |     function load(uint128 id) internal pure returns (Data storage account) {
  134 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.synthetix.Account", id));
  135 |     |         assembly {
  136 |     |             account.slot := s
  137 |     |         }
  138 |     |     }
  139 |     | }
  140 |     | 
  141 |     | // @custom:artifact @synthetixio/main/contracts/storage/AccountRBAC.sol:AccountRBAC
  142 |     | library AccountRBAC {
  143 |     |     bytes32 internal constant _ADMIN_PERMISSION = "ADMIN";
  144 |     |     bytes32 internal constant _WITHDRAW_PERMISSION = "WITHDRAW";
  145 |     |     bytes32 internal constant _DELEGATE_PERMISSION = "DELEGATE";
  146 |     |     bytes32 internal constant _MINT_PERMISSION = "MINT";
  147 |     |     bytes32 internal constant _REWARDS_PERMISSION = "REWARDS";
  148 |     |     bytes32 internal constant _PERPS_MODIFY_COLLATERAL_PERMISSION =
  149 |     |         "PERPS_MODIFY_COLLATERAL";
  150 |     |     bytes32 internal constant _PERPS_COMMIT_ASYNC_ORDER_PERMISSION =
  151 |     |         "PERPS_COMMIT_ASYNC_ORDER";
  152 |     |     bytes32 internal constant _BURN_PERMISSION = "BURN";
  153 |     |     struct Data {
  154 |     |         address owner;
  155 |     |         mapping(address => SetUtil.Bytes32Set) permissions;
  156 |     |         SetUtil.AddressSet permissionAddresses;
  157 |     |     }
  158 |     | }
  159 |     | 
  160 |     | // @custom:artifact @synthetixio/main/contracts/storage/Collateral.sol:Collateral
  161 |     | library Collateral {
  162 |     |     struct Data {
  163 |     |         uint256 amountAvailableForDelegationD18;
  164 |     |         SetUtil.UintSet pools;
  165 |     |         CollateralLock.Data[] locks;
  166 |     |     }
  167 |     | }
  168 |     | 
  169 |     | // @custom:artifact @synthetixio/main/contracts/storage/CollateralConfiguration.sol:CollateralConfiguration
  170 |     | library CollateralConfiguration {
  171 |     |     bytes32 private constant _SLOT_AVAILABLE_COLLATERALS =
  172 |     |         keccak256(
  173 |     |             abi.encode(
  174 |     |                 "io.synthetix.synthetix.CollateralConfiguration_availableCollaterals"
  175 |     |             )
  176 |     |         );
  177 |     |     struct Data {
  178 |     |         bool depositingEnabled;
  179 |     |         uint256 issuanceRatioD18;
  180 |     |         uint256 liquidationRatioD18;
  181 |     |         uint256 liquidationRewardD18;
  182 |     |         bytes32 oracleNodeId;
  183 |     |         address tokenAddress;
  184 |     |         uint256 minDelegationD18;
  185 |     |     }
  186 |     |     function load(
  187 |     |         address token
  188 |     |     ) internal pure returns (Data storage collateralConfiguration) {
  189 |     |         bytes32 s = keccak256(
  190 |     |             abi.encode("io.synthetix.synthetix.CollateralConfiguration", token)
  191 |     |         );
  192 |     |         assembly {
  193 |     |             collateralConfiguration.slot := s
  194 |     |         }
  195 |     |     }
  196 |     |     function loadAvailableCollaterals()
  197 |     |         internal
  198 |     |         pure
  199 |     |         returns (SetUtil.AddressSet storage availableCollaterals)
  200 |     |     {
  201 |     |         bytes32 s = _SLOT_AVAILABLE_COLLATERALS;
  202 |     |         assembly {
  203 |     |             availableCollaterals.slot := s
  204 |     |         }
  205 |     |     }
  206 |     | }
  207 |     | 
  208 |     | // @custom:artifact @synthetixio/main/contracts/storage/CollateralLock.sol:CollateralLock
  209 |     | library CollateralLock {
  210 |     |     struct Data {
  211 |     |         uint128 amountD18;
  212 |     |         uint64 lockExpirationTime;
  213 |     |     }
  214 |     | }
  215 |     | 
  216 |     | // @custom:artifact @synthetixio/main/contracts/storage/Config.sol:Config
  217 |     | library Config {
  218 |     |     struct Data {
  219 |     |         uint256 __unused;
  220 |     |     }
  221 |     | }
  222 |     | 
  223 |     | // @custom:artifact @synthetixio/main/contracts/storage/Distribution.sol:Distribution
  224 |     | library Distribution {
  225 |     |     struct Data {
  226 |     |         uint128 totalSharesD18;
  227 |     |         int128 valuePerShareD27;
  228 |     |         mapping(bytes32 => DistributionActor.Data) actorInfo;
  229 |     |     }
  230 |     | }
  231 |     | 
  232 |     | // @custom:artifact @synthetixio/main/contracts/storage/DistributionActor.sol:DistributionActor
  233 |     | library DistributionActor {
  234 |     |     struct Data {
  235 |     |         uint128 sharesD18;
  236 |     |         int128 lastValuePerShareD27;
  237 |     |     }
  238 |     | }
  239 |     | 
  240 |     | // @custom:artifact @synthetixio/main/contracts/storage/Market.sol:Market
  241 |     | library Market {
  242 |     |     struct Data {
  243 |     |         uint128 id;
  244 |     |         address marketAddress;
  245 |     |         int128 netIssuanceD18;
  246 |     |         int128 creditCapacityD18;
  247 |     |         int128 lastDistributedMarketBalanceD18;
  248 |     |         HeapUtil.Data inRangePools;
  249 |     |         HeapUtil.Data outRangePools;
  250 |     |         Distribution.Data poolsDebtDistribution;
  251 |     |         mapping(uint128 => MarketPoolInfo.Data) pools;
  252 |     |         DepositedCollateral[] depositedCollateral;
  253 |     |         mapping(address => uint256) maximumDepositableD18;
  254 |     |         uint32 minDelegateTime;
  255 |     |         uint32 __reservedForLater1;
  256 |     |         uint64 __reservedForLater2;
  257 |     |         uint64 __reservedForLater3;
  258 |     |         uint64 __reservedForLater4;
  259 |     |         uint256 minLiquidityRatioD18;
  260 |     |     }
  261 |     |     struct DepositedCollateral {
  262 |     |         address collateralType;
  263 |     |         uint256 amountD18;
  264 |     |     }
  265 |     |     function load(uint128 id) internal pure returns (Data storage market) {
  266 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.synthetix.Market", id));
  267 |     |         assembly {
  268 |     |             market.slot := s
  269 |     |         }
  270 |     |     }
  271 |     | }
  272 |     | 
  273 |     | // @custom:artifact @synthetixio/main/contracts/storage/MarketConfiguration.sol:MarketConfiguration
  274 |     | library MarketConfiguration {
  275 |     |     struct Data {
  276 |     |         uint128 marketId;
  277 |     |         uint128 weightD18;
  278 |     |         int128 maxDebtShareValueD18;
  279 |     |     }
  280 |     | }
  281 |     | 
  282 |     | // @custom:artifact @synthetixio/main/contracts/storage/MarketPoolInfo.sol:MarketPoolInfo
  283 |     | library MarketPoolInfo {
  284 |     |     struct Data {
  285 |     |         uint128 creditCapacityAmountD18;
  286 |     |         uint128 pendingDebtD18;
  287 |     |     }
  288 |     | }
  289 |     | 
  290 |     | // @custom:artifact @synthetixio/main/contracts/storage/OracleManager.sol:OracleManager
  291 |     | library OracleManager {
  292 |     |     bytes32 private constant _SLOT_ORACLE_MANAGER =
  293 |     |         keccak256(abi.encode("io.synthetix.synthetix.OracleManager"));
  294 |     |     struct Data {
  295 |     |         address oracleManagerAddress;
  296 |     |     }
  297 |     |     function load() internal pure returns (Data storage oracleManager) {
  298 |     |         bytes32 s = _SLOT_ORACLE_MANAGER;
  299 |     |         assembly {
  300 |     |             oracleManager.slot := s
  301 |     |         }
  302 |     |     }
  303 |     | }
  304 |     | 
  305 |     | // @custom:artifact @synthetixio/main/contracts/storage/Pool.sol:Pool
  306 |     | library Pool {
  307 |     |     bytes32 private constant _CONFIG_SET_MARKET_MIN_DELEGATE_MAX =
  308 |     |         "setMarketMinDelegateTime_max";
  309 |     |     struct Data {
  310 |     |         uint128 id;
  311 |     |         string name;
  312 |     |         address owner;
  313 |     |         address nominatedOwner;
  314 |     |         uint128 totalWeightsD18;
  315 |     |         int128 totalVaultDebtsD18;
  316 |     |         MarketConfiguration.Data[] marketConfigurations;
  317 |     |         Distribution.Data vaultsDebtDistribution;
  318 |     |         mapping(address => Vault.Data) vaults;
  319 |     |         uint64 lastConfigurationTime;
  320 |     |         uint64 __reserved1;
  321 |     |         uint64 __reserved2;
  322 |     |         uint64 __reserved3;
  323 |     |         mapping(address => PoolCollateralConfiguration.Data) collateralConfigurations;
  324 |     |         bool collateralDisabledByDefault;
  325 |     |     }
  326 |     |     function load(uint128 id) internal pure returns (Data storage pool) {
  327 |     |         bytes32 s = keccak256(abi.encode("io.synthetix.synthetix.Pool", id));
  328 |     |         assembly {
  329 |     |             pool.slot := s
  330 |     |         }
  331 |     |     }
  332 |     | }
  333 |     | 
  334 |     | // @custom:artifact @synthetixio/main/contracts/storage/PoolCollateralConfiguration.sol:PoolCollateralConfiguration
  335 |     | library PoolCollateralConfiguration {
  336 |     |     bytes32 private constant _SLOT =
  337 |     |         keccak256(
  338 |     |             abi.encode("io.synthetix.synthetix.PoolCollateralConfiguration")
  339 |     |         );
  340 |     |     struct Data {
  341 |     |         uint256 collateralLimitD18;
  342 |     |         uint256 issuanceRatioD18;
  343 |     |     }
  344 |     | }
  345 |     | 
  346 |     | // @custom:artifact @synthetixio/main/contracts/storage/RewardDistribution.sol:RewardDistribution
  347 |     | library RewardDistribution {
  348 |     |     struct Data {
  349 |     |         address distributor;
  350 |     |         uint128 __slotAvailableForFutureUse;
  351 |     |         uint128 rewardPerShareD18;
  352 |     |         mapping(uint256 => RewardDistributionClaimStatus.Data) claimStatus;
  353 |     |         int128 scheduledValueD18;
  354 |     |         uint64 start;
  355 |     |         uint32 duration;
  356 |     |         uint32 lastUpdate;
  357 |     |     }
  358 |     | }
  359 |     | 
  360 |     | // @custom:artifact @synthetixio/main/contracts/storage/RewardDistributionClaimStatus.sol:RewardDistributionClaimStatus
  361 |     | library RewardDistributionClaimStatus {
  362 |     |     struct Data {
  363 |     |         uint128 lastRewardPerShareD18;
  364 |     |         uint128 pendingSendD18;
  365 |     |     }
  366 |     | }
  367 |     | 
  368 |     | // @custom:artifact @synthetixio/main/contracts/storage/ScalableMapping.sol:ScalableMapping
  369 |     | library ScalableMapping {
  370 |     |     struct Data {
  371 |     |         uint128 totalSharesD18;
  372 |     |         int128 scaleModifierD27;
  373 |     |         mapping(bytes32 => uint256) sharesD18;
  374 |     |     }
  375 |     | }
  376 |     | 
  377 |     | // @custom:artifact @synthetixio/main/contracts/storage/SystemPoolConfiguration.sol:SystemPoolConfiguration
  378 |     | library SystemPoolConfiguration {
  379 |     |     bytes32 private constant _SLOT_SYSTEM_POOL_CONFIGURATION =
  380 |     |         keccak256(abi.encode("io.synthetix.synthetix.SystemPoolConfiguration"));
  381 |     |     struct Data {
  382 |     |         uint256 minLiquidityRatioD18;
  383 |     |         uint128 __reservedForFutureUse;
  384 |     |         uint128 preferredPool;
  385 |     |         SetUtil.UintSet approvedPools;
  386 |     |     }
  387 |     |     function load()
  388 |     |         internal
  389 |     |         pure
  390 |     |         returns (Data storage systemPoolConfiguration)
  391 |     |     {
  392 |     |         bytes32 s = _SLOT_SYSTEM_POOL_CONFIGURATION;
  393 |     |         assembly {
  394 |     |             systemPoolConfiguration.slot := s
  395 |     |         }
  396 |     |     }
  397 |     | }
  398 |     | 
  399 |     | // @custom:artifact @synthetixio/main/contracts/storage/Vault.sol:Vault
  400 |     | library Vault {
  401 |     |     struct Data {
  402 |     |         uint256 epoch;
  403 |     |         bytes32 __slotAvailableForFutureUse;
  404 |     |         int128 _unused_prevTotalDebtD18;
  405 |     |         mapping(uint256 => VaultEpoch.Data) epochData;
  406 |     |         mapping(bytes32 => RewardDistribution.Data) rewards;
  407 |     |         SetUtil.Bytes32Set rewardIds;
  408 |     |     }
  409 |     |     struct PositionSelector {
  410 |     |         uint128 accountId;
  411 |     |         uint128 poolId;
  412 |     |         address collateralType;
  413 |     |     }
  414 |     | }
  415 |     | 
  416 |     | // @custom:artifact @synthetixio/main/contracts/storage/VaultEpoch.sol:VaultEpoch
  417 |     | library VaultEpoch {
  418 |     |     struct Data {
  419 |     |         int128 unconsolidatedDebtD18;
  420 |     |         int128 totalConsolidatedDebtD18;
  421 |     |         Distribution.Data accountsDebtDistribution;
  422 |     |         ScalableMapping.Data collateralAmounts;
  423 |     |         mapping(uint256 => int256) consolidatedDebtAmountsD18;
  424 |     |         mapping(uint128 => uint64) lastDelegationTime;
  425 |     |     }
  426 |     | }
  427 |     | 
  428 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/interfaces/external/IPyth.sol:PythStructs
  429 |     | contract PythStructs {
  430 |     |     struct Price {
  431 |     |         int64 price;
  432 |     |         uint64 conf;
  433 |     |         int32 expo;
  434 |     |         uint256 publishTime;
  435 |     |     }
  436 |     |     struct PriceFeed {
  437 |     |         bytes32 id;
  438 |     |         Price price;
  439 |     |         Price emaPrice;
  440 |     |     }
  441 |     | }
  442 |     | 
  443 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/nodes/ChainlinkNode.sol:ChainlinkNode
  444 |     | library ChainlinkNode {
  445 |     |     uint256 public constant PRECISION = 18;
  446 |     | }
  447 |     | 
  448 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/nodes/ReducerNode.sol:ReducerNode
  449 |     | library ReducerNode {
  450 |     |     enum Operations {
  451 |     |         RECENT,
  452 |     |         MIN,
  453 |     |         MAX,
  454 |     |         MEAN,
  455 |     |         MEDIAN,
  456 |     |         MUL,
  457 |     |         DIV,
  458 |     |         MULDECIMAL,
  459 |     |         DIVDECIMAL
  460 |     |     }
  461 |     | }
  462 |     | 
  463 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/nodes/UniswapNode.sol:UniswapNode
  464 |     | library UniswapNode {
  465 |     |     uint8 public constant PRECISION = 18;
  466 |     | }
  467 |     | 
  468 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/nodes/pyth/PythNode.sol:PythNode
  469 |     | library PythNode {
  470 |     |     int256 public constant PRECISION = 18;
  471 |     | }
  472 |     | 
  473 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/nodes/pyth/PythOffchainLookupNode.sol:PythOffchainLookupNode
  474 |     | library PythOffchainLookupNode {
  475 |     |     int256 public constant PRECISION = 18;
  476 |     | }
  477 |     | 
  478 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/storage/NodeDefinition.sol:NodeDefinition
  479 |     | library NodeDefinition {
  480 |     |     enum NodeType {
  481 |     |         NONE,
  482 |     |         REDUCER,
  483 |     |         EXTERNAL,
  484 |     |         CHAINLINK,
  485 |     |         UNISWAP,
  486 |     |         PYTH,
  487 |     |         PRICE_DEVIATION_CIRCUIT_BREAKER,
  488 |     |         STALENESS_CIRCUIT_BREAKER,
  489 |     |         CONSTANT,
  490 |     |         PYTH_OFFCHAIN_LOOKUP
  491 |     |     }
  492 |     |     struct Data {
  493 |     |         NodeType nodeType;
  494 |     |         bytes parameters;
  495 |     |         bytes32[] parents;
  496 |     |     }
  497 |     |     function load(bytes32 id) internal pure returns (Data storage node) {
  498 |     |         bytes32 s = keccak256(
  499 |     |             abi.encode("io.synthetix.oracle-manager.Node", id)
  500 |     |         );
  501 |     |         assembly {
  502 |     |             node.slot := s
  503 |     |         }
  504 |     |     }
  505 |     | }
  506 |     | 
  507 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/storage/NodeOutput.sol:NodeOutput
  508 |     | library NodeOutput {
  509 |     |     struct Data {
  510 |     |         int256 price;
  511 |     |         uint256 timestamp;
  512 |     |         uint256 __slotAvailableForFutureUse1;
  513 |     |         uint256 __slotAvailableForFutureUse2;
  514 |     |     }
  515 |     | }
  516 |     | 
  517 |     | // @custom:artifact @synthetixio/oracle-manager/contracts/utils/TickMath.sol:TickMath
  518 |     | library TickMath {
  519 |     |     int24 internal constant MIN_TICK = -887272;
  520 |     |     int24 internal constant MAX_TICK = -MIN_TICK;
  521 |     |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  522 |     |     uint160 internal constant MAX_SQRT_RATIO =
  523 |     |         1461446703485210103287273052203988822378723970342;
  524 |     | }
  525 |     | 
  526 |     | // @custom:artifact @synthetixio/rewards-distributor/src/RewardsDistributor.sol:RewardsDistributor
  527 |     | contract RewardsDistributor {
  528 |     |     uint256 public constant SYSTEM_PRECISION = 10 ** 18;
  529 |     | }
  530 |     | 
  531 |     | // @custom:artifact @synthetixio/spot-market/contracts/storage/OrderFees.sol:OrderFees
  532 |     | library OrderFees {
  533 |     |     struct Data {
  534 |     |         uint256 fixedFees;
  535 |     |         uint256 utilizationFees;
  536 |     |         int256 skewFees;
  537 |     |         int256 wrapperFees;
  538 |     |     }
  539 |     | }
  540 |     | 
  541 |     | // @custom:artifact @synthetixio/spot-market/contracts/storage/Price.sol:Price
  542 |     | library Price {
  543 |     |     enum Tolerance {
  544 |     |         DEFAULT,
  545 |     |         STRICT
  546 |     |     }
  547 |     |     struct Data {
  548 |     |         bytes32 buyFeedId;
  549 |     |         bytes32 sellFeedId;
  550 |     |         uint256 strictStalenessTolerance;
  551 |     |     }
  552 |     |     function load(uint128 marketId) internal pure returns (Data storage price) {
  553 |     |         bytes32 s = keccak256(
  554 |     |             abi.encode("io.synthetix.spot-market.Price", marketId)
  555 |     |         );
  556 |     |         assembly {
  557 |     |             price.slot := s
  558 |     |         }
  559 |     |     }
  560 |     | }
  561 |     | 
  562 |     | // @custom:artifact @synthetixio/spot-market/contracts/storage/SpotMarketFactory.sol:SpotMarketFactory
  563 |     | library SpotMarketFactory {
  564 |     |     bytes32 private constant _SLOT_SPOT_MARKET_FACTORY =
  565 |     |         keccak256(abi.encode("io.synthetix.spot-market.SpotMarketFactory"));
  566 |     |     struct Data {
  567 |     |         address usdToken;
  568 |     |         address oracle;
  569 |     |         address synthetix;
  570 |     |         address synthImplementation;
  571 |     |         mapping(uint128 => address) marketOwners;
  572 |     |         mapping(uint128 => address) nominatedMarketOwners;
  573 |     |     }
  574 |     |     function load() internal pure returns (Data storage spotMarketFactory) {
  575 |     |         bytes32 s = _SLOT_SPOT_MARKET_FACTORY;
  576 |     |         assembly {
  577 |     |             spotMarketFactory.slot := s
  578 |     |         }
  579 |     |     }
  580 |     | }
  581 |     | 
  582 |     | // @custom:artifact @synthetixio/spot-market/contracts/utils/TransactionUtil.sol:Transaction
  583 |     | library Transaction {
  584 |     |     enum Type {
  585 |     |         NULL,
  586 |     |         BUY,
  587 |     |         SELL,
  588 |     |         ASYNC_BUY,
  589 |     |         ASYNC_SELL,
  590 |     |         WRAP,
  591 |     |         UNWRAP
  592 |     |     }
  593 |     | }
  594 |     | 
  595 |     | // @custom:artifact contracts/interfaces/IAsyncOrderCancelModule.sol:IAsyncOrderCancelModule
  596 |     | interface IAsyncOrderCancelModule {
  597 |     |     struct CancelOrderRuntime {
  598 |     |         uint128 marketId;
  599 |     |         uint128 accountId;
  600 |     |         int128 sizeDelta;
  601 |     |         uint256 settlementReward;
  602 |     |         uint256 fillPrice;
  603 |     |         uint256 acceptablePrice;
  604 |     |     }
  605 |     | }
  606 |     | 
  607 |     | // @custom:artifact contracts/interfaces/IAsyncOrderSettlementPythModule.sol:IAsyncOrderSettlementPythModule
  608 |     | interface IAsyncOrderSettlementPythModule {
  609 |     |     struct SettleOrderRuntime {
  610 |     |         uint128 marketId;
  611 |     |         uint128 accountId;
  612 |     |         int128 sizeDelta;
  613 |     |         int256 pnl;
  614 |     |         uint256 chargedInterest;
  615 |     |         int256 accruedFunding;
  616 |     |         uint256 settlementReward;
  617 |     |         uint256 fillPrice;
  618 |     |         uint256 totalFees;
  619 |     |         uint256 referralFees;
  620 |     |         uint256 feeCollectorFees;
  621 |     |         Position.Data newPosition;
  622 |     |         MarketUpdate.Data updateData;
  623 |     |         uint256 synthDeductionIterator;
  624 |     |         uint128[] deductedSynthIds;
  625 |     |         uint256[] deductedAmount;
  626 |     |         int256 chargedAmount;
  627 |     |         uint256 newAccountDebt;
  628 |     |     }
  629 |     | }
  630 |     | 
  631 |     | // @custom:artifact contracts/interfaces/IPerpsMarketModule.sol:IPerpsMarketModule
  632 |     | interface IPerpsMarketModule {
  633 |     |     struct MarketSummary {
  634 |     |         int256 skew;
  635 |     |         uint256 size;
  636 |     |         uint256 maxOpenInterest;
  637 |     |         int256 currentFundingRate;
  638 |     |         int256 currentFundingVelocity;
  639 |     |         uint256 indexPrice;
  640 |     |     }
  641 |     | }
  642 |     | 
  643 |     | // @custom:artifact contracts/modules/LiquidationModule.sol:LiquidationModule
  644 |     | contract LiquidationModule {
  645 |     |     struct LiquidateAccountRuntime {
  646 |     |         uint128 accountId;
  647 |     |         uint256 totalFlaggingRewards;
  648 |     |         uint256 totalLiquidated;
  649 |     |         bool accountFullyLiquidated;
  650 |     |         uint256 totalLiquidationCost;
  651 |     |         uint256 price;
  652 |     |         uint128 positionMarketId;
  653 |     |         uint256 loopIterator;
  654 |     |     }
  655 |     | }
  656 |     | 
  657 |     | // @custom:artifact contracts/modules/PerpsMarketFactoryModule.sol:PerpsMarketFactoryModule
  658 |     | contract PerpsMarketFactoryModule {
  659 |     |     bytes32 private constant _ACCOUNT_TOKEN_SYSTEM = "accountNft";
  660 |     | }
  661 |     | 
  662 |     | // @custom:artifact contracts/storage/AsyncOrder.sol:AsyncOrder
  663 |     | library AsyncOrder {
  664 |     |     struct Data {
  665 |     |         uint256 commitmentTime;
  666 |     |         OrderCommitmentRequest request;
  667 |     |     }
  668 |     |     struct OrderCommitmentRequest {
  669 |     |         uint128 marketId;
  670 |     |         uint128 accountId;
  671 |     |         int128 sizeDelta;
  672 |     |         uint128 settlementStrategyId;
  673 |     |         uint256 acceptablePrice;
  674 |     |         bytes32 trackingCode;
  675 |     |         address referrer;
  676 |     |     }
  677 |     |     struct SimulateDataRuntime {
  678 |     |         bool isEligible;
  679 |     |         int128 sizeDelta;
  680 |     |         uint128 accountId;
  681 |     |         uint128 marketId;
  682 |     |         uint256 fillPrice;
  683 |     |         uint256 orderFees;
  684 |     |         uint256 availableMargin;
  685 |     |         uint256 currentLiquidationMargin;
  686 |     |         uint256 accumulatedLiquidationRewards;
  687 |     |         uint256 currentLiquidationReward;
  688 |     |         int128 newPositionSize;
  689 |     |         uint256 newNotionalValue;
  690 |     |         int256 currentAvailableMargin;
  691 |     |         uint256 requiredInitialMargin;
  692 |     |         uint256 initialRequiredMargin;
  693 |     |         uint256 totalRequiredMargin;
  694 |     |         Position.Data newPosition;
  695 |     |         bytes32 trackingCode;
  696 |     |     }
  697 |     |     struct RequiredMarginWithNewPositionRuntime {
  698 |     |         uint256 newRequiredMargin;
  699 |     |         uint256 oldRequiredMargin;
  700 |     |         uint256 requiredMarginForNewPosition;
  701 |     |         uint256 accumulatedLiquidationRewards;
  702 |     |         uint256 maxNumberOfWindows;
  703 |     |         uint256 numberOfWindows;
  704 |     |         uint256 requiredRewardMargin;
  705 |     |     }
  706 |     |     function load(
  707 |     |         uint128 accountId
  708 |     |     ) internal pure returns (Data storage order) {
  709 |     |         bytes32 s = keccak256(
  710 |     |             abi.encode("io.synthetix.perps-market.AsyncOrder", accountId)
  711 |     |         );
  712 |     |         assembly {
  713 |     |             order.slot := s
  714 |     |         }
  715 |     |     }
  716 |     | }
  717 |     | 
  718 |     | // @custom:artifact contracts/storage/GlobalPerpsMarket.sol:GlobalPerpsMarket
  719 |     | library GlobalPerpsMarket {
  720 |     |     bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET =
  721 |     |         keccak256(abi.encode("io.synthetix.perps-market.GlobalPerpsMarket"));
  722 |     |     struct Data {
  723 |     |         SetUtil.UintSet liquidatableAccounts;
  724 |     |         mapping(uint128 => uint256) collateralAmounts;
  725 |     |         SetUtil.UintSet activeCollateralTypes;
  726 |     |         SetUtil.UintSet activeMarkets;
  727 |     |         uint256 totalAccountsDebt;
  728 |     |     }
  729 |     |     function load() internal pure returns (Data storage marketData) {
  730 |     |         bytes32 s = _SLOT_GLOBAL_PERPS_MARKET;
  731 |     |         assembly {
  732 |     |             marketData.slot := s
  733 |     |         }
  734 |     |     }
  735 |     | }
  736 |     | 
  737 |     | // @custom:artifact contracts/storage/GlobalPerpsMarketConfiguration.sol:GlobalPerpsMarketConfiguration
  738 |     | library GlobalPerpsMarketConfiguration {
  739 |     |     bytes32 private constant _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION =
  740 |     |         keccak256(
  741 |     |             abi.encode(
  742 |     |                 "io.synthetix.perps-market.GlobalPerpsMarketConfiguration"
  743 |     |             )
  744 |     |         );
  745 |     |     struct Data {
  746 |     |         address feeCollector;
  747 |     |         mapping(address => uint256) referrerShare;
  748 |     |         mapping(uint128 => uint256) __unused_1;
  749 |     |         uint128[] __unused_2;
  750 |     |         uint256 minKeeperRewardUsd;
  751 |     |         uint256 maxKeeperRewardUsd;
  752 |     |         uint128 maxPositionsPerAccount;
  753 |     |         uint128 maxCollateralsPerAccount;
  754 |     |         uint256 minKeeperProfitRatioD18;
  755 |     |         uint256 maxKeeperScalingRatioD18;
  756 |     |         SetUtil.UintSet supportedCollateralTypes;
  757 |     |         uint128 lowUtilizationInterestRateGradient;
  758 |     |         uint128 interestRateGradientBreakpoint;
  759 |     |         uint128 highUtilizationInterestRateGradient;
  760 |     |         uint128 collateralLiquidateRewardRatioD18;
  761 |     |         address rewardDistributorImplementation;
  762 |     |     }
  763 |     |     function load() internal pure returns (Data storage globalMarketConfig) {
  764 |     |         bytes32 s = _SLOT_GLOBAL_PERPS_MARKET_CONFIGURATION;
  765 |     |         assembly {
  766 |     |             globalMarketConfig.slot := s
  767 |     |         }
  768 |     |     }
  769 |     | }
  770 |     | 
  771 |     | // @custom:artifact contracts/storage/InterestRate.sol:InterestRate
  772 |     | library InterestRate {
  773 |     |     uint256 private constant AVERAGE_SECONDS_PER_YEAR = 31557600;
  774 |     |     bytes32 private constant _SLOT_INTEREST_RATE =
  775 |     |         keccak256(abi.encode("io.synthetix.perps-market.InterestRate"));
  776 |     |     struct Data {
  777 |     |         uint256 interestAccrued;
  778 |     |         uint128 interestRate;
  779 |     |         uint256 lastTimestamp;
  780 |     |     }
  781 |     |     function load() internal pure returns (Data storage interestRate) {
  782 |     |         bytes32 s = _SLOT_INTEREST_RATE;
  783 |     |         assembly {
  784 |     |             interestRate.slot := s
  785 |     |         }
  786 |     |     }
  787 |     | }
  788 |     | 
  789 |     | // @custom:artifact contracts/storage/KeeperCosts.sol:KeeperCosts
  790 |     | library KeeperCosts {
  791 |     |     uint256 private constant KIND_SETTLEMENT = 0;
  792 |     |     uint256 private constant KIND_FLAG = 1;
  793 |     |     uint256 private constant KIND_LIQUIDATE = 2;
  794 |     |     struct Data {
  795 |     |         bytes32 keeperCostNodeId;
  796 |     |     }
  797 |     |     function load() internal pure returns (Data storage price) {
  798 |     |         bytes32 s = keccak256(
  799 |     |             abi.encode("io.synthetix.perps-market.KeeperCosts")
  800 |     |         );
  801 |     |         assembly {
  802 |     |             price.slot := s
  803 |     |         }
  804 |     |     }
  805 |     | }
  806 |     | 
  807 |     | // @custom:artifact contracts/storage/Liquidation.sol:Liquidation
  808 |     | library Liquidation {
  809 |     |     struct Data {
  810 |     |         uint128 amount;
  811 |     |         uint256 timestamp;
  812 |     |     }
  813 |     | }
  814 |     | 
  815 |     | // @custom:artifact contracts/storage/LiquidationAssetManager.sol:LiquidationAssetManager
  816 |     | library LiquidationAssetManager {
  817 |     |     struct Data {
  818 |     |         uint128 id;
  819 |     |         address distributor;
  820 |     |         address[] poolDelegatedCollateralTypes;
  821 |     |     }
  822 |     | }
  823 |     | 
  824 |     | // @custom:artifact contracts/storage/MarketUpdate.sol:MarketUpdate
  825 |     | library MarketUpdate {
  826 |     |     struct Data {
  827 |     |         uint128 marketId;
  828 |     |         uint128 interestRate;
  829 |     |         int256 skew;
  830 |     |         uint256 size;
  831 |     |         int256 currentFundingRate;
  832 |     |         int256 currentFundingVelocity;
  833 |     |     }
  834 |     | }
  835 |     | 
  836 |     | // @custom:artifact contracts/storage/OrderFee.sol:OrderFee
  837 |     | library OrderFee {
  838 |     |     struct Data {
  839 |     |         uint256 makerFee;
  840 |     |         uint256 takerFee;
  841 |     |     }
  842 |     | }
  843 |     | 
  844 |     | // @custom:artifact contracts/storage/PerpsAccount.sol:PerpsAccount
  845 |     | library PerpsAccount {
  846 |     |     struct Data {
  847 |     |         mapping(uint128 => uint256) collateralAmounts;
  848 |     |         uint128 id;
  849 |     |         SetUtil.UintSet activeCollateralTypes;
  850 |     |         SetUtil.UintSet openPositionMarketIds;
  851 |     |         uint256 debt;
  852 |     |     }
  853 |     |     function load(uint128 id) internal pure returns (Data storage account) {
  854 |     |         bytes32 s = keccak256(
  855 |     |             abi.encode("io.synthetix.perps-market.Account", id)
  856 |     |         );
  857 |     |         assembly {
  858 |     |             account.slot := s
  859 |     |         }
  860 |     |     }
  861 |     | }
  862 |     | 
  863 |     | // @custom:artifact contracts/storage/PerpsCollateralConfiguration.sol:PerpsCollateralConfiguration
  864 |     | library PerpsCollateralConfiguration {
  865 |     |     struct Data {
  866 |     |         uint128 id;
  867 |     |         uint256 maxAmount;
  868 |     |         uint256 upperLimitDiscount;
  869 |     |         uint256 lowerLimitDiscount;
  870 |     |         uint256 discountScalar;
  871 |     |         LiquidationAssetManager.Data lam;
  872 |     |     }
  873 |     |     function load(
  874 |     |         uint128 collateralId
  875 |     |     ) internal pure returns (Data storage collateralConfig) {
  876 |     |         bytes32 s = keccak256(
  877 |     |             abi.encode(
  878 |     |                 "io.synthetix.perps-market.CollateralConfiguration",
  879 |     |                 collateralId
  880 |     |             )
  881 |     |         );
  882 |     |         assembly {
  883 |     |             collateralConfig.slot := s
  884 |     |         }
  885 |     |     }
  886 |     | }
  887 |     | 
  888 |     | // @custom:artifact contracts/storage/PerpsMarket.sol:PerpsMarket
  889 |     | library PerpsMarket {
  890 |     |     struct Data {
  891 |     |         string name;
  892 |     |         string symbol;
  893 |     |         uint128 id;
  894 |     |         int256 skew;
  895 |     |         uint256 size;
  896 |     |         int256 lastFundingRate;
  897 |     |         int256 lastFundingValue;
  898 |     |         uint256 lastFundingTime;
  899 |     |         uint128 __unused_1;
  900 |     |         uint128 __unused_2;
  901 |     |         int256 debtCorrectionAccumulator;
  902 |     |         mapping(uint256 => AsyncOrder.Data) asyncOrders;
  903 |     |         mapping(uint256 => Position.Data) positions;
  904 |     |         Liquidation.Data[] liquidationData;
  905 |     |     }
  906 |     |     struct PositionDataRuntime {
  907 |     |         uint256 currentPrice;
  908 |     |         int256 sizeDelta;
  909 |     |         int256 fundingDelta;
  910 |     |         int256 notionalDelta;
  911 |     |     }
  912 |     |     function load(
  913 |     |         uint128 marketId
  914 |     |     ) internal pure returns (Data storage market) {
  915 |     |         bytes32 s = keccak256(
  916 |     |             abi.encode("io.synthetix.perps-market.PerpsMarket", marketId)
  917 |     |         );
  918 |     |         assembly {
  919 |     |             market.slot := s
  920 |     |         }
  921 |     |     }
  922 |     | }
  923 |     | 
  924 |     | // @custom:artifact contracts/storage/PerpsMarketConfiguration.sol:PerpsMarketConfiguration
  925 |     | library PerpsMarketConfiguration {
  926 |     |     struct Data {
  927 |     |         OrderFee.Data orderFees;
  928 |     |         SettlementStrategy.Data[] settlementStrategies;
  929 |     |         uint256 maxMarketSize;
  930 |     |         uint256 maxFundingVelocity;
  931 |     |         uint256 skewScale;
  932 |     |         uint256 initialMarginRatioD18;
  933 |     |         uint256 maintenanceMarginScalarD18;
  934 |     |         uint256 lockedOiRatioD18;
  935 |     |         uint256 maxLiquidationLimitAccumulationMultiplier;
  936 |     |         uint256 maxSecondsInLiquidationWindow;
  937 |     |         uint256 flagRewardRatioD18;
  938 |     |         uint256 minimumPositionMargin;
  939 |     |         uint256 minimumInitialMarginRatioD18;
  940 |     |         uint256 maxLiquidationPd;
  941 |     |         address endorsedLiquidator;
  942 |     |         uint256 maxMarketValue;
  943 |     |     }
  944 |     |     function load(uint128 marketId) internal pure returns (Data storage store) {
  945 |     |         bytes32 s = keccak256(
  946 |     |             abi.encode(
  947 |     |                 "io.synthetix.perps-market.PerpsMarketConfiguration",
  948 |     |                 marketId
  949 |     |             )
  950 |     |         );
  951 |     |         assembly {
  952 |     |             store.slot := s
  953 |     |         }
  954 |     |     }
  955 |     | }
  956 |     | 
  957 |     | // @custom:artifact contracts/storage/PerpsMarketFactory.sol:PerpsMarketFactory
  958 |     | library PerpsMarketFactory {
  959 |     |     bytes32 private constant _SLOT_PERPS_MARKET_FACTORY =
  960 |     |         keccak256(abi.encode("io.synthetix.perps-market.PerpsMarketFactory"));
  961 |     |     struct Data {
  962 |     |         address oracle;
  963 |     |         address usdToken;
  964 |     |         address synthetix;
  965 |     |         address spotMarket;
  966 |     |         uint128 perpsMarketId;
  967 |     |         string name;
  968 |     |         address liquidationAssetManager;
  969 |     |     }
  970 |     |     function load() internal pure returns (Data storage perpsMarketFactory) {
  971 |     |         bytes32 s = _SLOT_PERPS_MARKET_FACTORY;
  972 |     |         assembly {
  973 |     |             perpsMarketFactory.slot := s
  974 |     |         }
  975 |     |     }
  976 |     | }
  977 |     | 
  978 |     | // @custom:artifact contracts/storage/PerpsPrice.sol:PerpsPrice
  979 |     | library PerpsPrice {
  980 |     |     uint256 private constant ONE_MONTH = 2592000;
  981 |     |     enum Tolerance {
  982 |     |         DEFAULT,
  983 |     |         STRICT,
  984 |     |         ONE_MONTH
  985 |     |     }
  986 |     |     struct Data {
  987 |     |         bytes32 feedId;
  988 |     |         uint256 strictStalenessTolerance;
  989 |     |     }
  990 |     |     function load(uint128 marketId) internal pure returns (Data storage price) {
  991 |     |         bytes32 s = keccak256(
  992 |     |             abi.encode("io.synthetix.perps-market.Price", marketId)
  993 |     |         );
  994 |     |         assembly {
  995 |     |             price.slot := s
  996 |     |         }
  997 |     |     }
  998 |     | }
  999 |     | 
 1000 |     | // @custom:artifact contracts/storage/Position.sol:Position
 1001 |     | library Position {
 1002 |     |     struct Data {
 1003 |     |         uint128 marketId;
 1004 |     |         int128 size;
 1005 |     |         uint128 latestInteractionPrice;
 1006 |     |         int128 latestInteractionFunding;
 1007 |     |         uint256 latestInterestAccrued;
 1008 |     |     }
 1009 |     | }
 1010 |     | 
 1011 |     | // @custom:artifact contracts/storage/SettlementStrategy.sol:SettlementStrategy
 1012 |     | library SettlementStrategy {
 1013 |     |     enum Type {
 1014 |     |         PYTH
 1015 |     |     }
 1016 |     |     struct Data {
 1017 |     |         Type strategyType;
 1018 |     |         uint256 settlementDelay;
 1019 |     |         uint256 settlementWindowDuration;
 1020 |     |         address priceVerificationContract;
 1021 |     |         bytes32 feedId;
 1022 |     |         uint256 settlementReward;
 1023 |     |         bool disabled;
 1024 |     |         uint256 commitmentPriceDelay;
 1025 |     |     }
 1026 |     | }
 1027 |     | 
 1028 |     | // @custom:artifact contracts/utils/BigNumber.sol:BigNumber
 1029 |     | library BigNumber {
 1030 |     |     uint256 internal constant CHUNK_SIZE = 2 ** 255;
 1031 |     |     struct Data {
 1032 |     |         uint256[] chunks;
 1033 |     |     }
 1034 |     |     struct Snapshot {
 1035 |     |         uint256 currentChunkId;
 1036 |     |         uint256 valueAtChunk;
 1037 |     |     }
 1038 |     | }
 1039 |     | 
 1040 |     | // @custom:artifact contracts/utils/Flags.sol:Flags
 1041 |     | library Flags {
 1042 |     |     bytes32 public constant PERPS_SYSTEM = "perpsSystem";
 1043 |     |     bytes32 public constant CREATE_MARKET = "createMarket";
 1044 |     | }
 1045 |     | 

